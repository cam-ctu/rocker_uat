
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:01:44.665] plan(): Setting new future strategy stack:
[16:01:44.665] List of future strategies:
[16:01:44.665] 1. sequential:
[16:01:44.665]    - args: function (..., envir = parent.frame())
[16:01:44.665]    - tweaked: FALSE
[16:01:44.665]    - call: future::plan("sequential")
[16:01:44.680] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[16:01:44.739] plan(): Setting new future strategy stack:
[16:01:44.739] List of future strategies:
[16:01:44.739] 1. sequential:
[16:01:44.739]    - args: function (..., envir = parent.frame())
[16:01:44.739]    - tweaked: FALSE
[16:01:44.739]    - call: plan(strategy)
[16:01:44.751] plan(): nbrOfWorkers() = 1
[16:01:44.752] future_by_internal() ...
[16:01:44.753] future_lapply() ...
[16:01:44.757] Number of chunks: 1
[16:01:44.757] getGlobalsAndPackagesXApply() ...
[16:01:44.758]  - future.globals: TRUE
[16:01:44.758] getGlobalsAndPackages() ...
[16:01:44.758] Searching for globals...
[16:01:44.761] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:44.761] Searching for globals ... DONE
[16:01:44.761] Resolving globals: FALSE
[16:01:44.762] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:44.763] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:44.763] - globals: [1] ‘FUN’
[16:01:44.763] 
[16:01:44.763] getGlobalsAndPackages() ... DONE
[16:01:44.763]  - globals found/used: [n=1] ‘FUN’
[16:01:44.763]  - needed namespaces: [n=0] 
[16:01:44.763] Finding globals ... DONE
[16:01:44.763]  - use_args: TRUE
[16:01:44.763]  - Getting '...' globals ...
[16:01:44.764] resolve() on list ...
[16:01:44.764]  recursive: 0
[16:01:44.765]  length: 1
[16:01:44.765]  elements: ‘...’
[16:01:44.765]  length: 0 (resolved future 1)
[16:01:44.765] resolve() on list ... DONE
[16:01:44.765]    - '...' content: [n=0] 
[16:01:44.765] List of 1
[16:01:44.765]  $ ...: list()
[16:01:44.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.765]  - attr(*, "where")=List of 1
[16:01:44.765]   ..$ ...:<environment: 0x55b523aea2e0> 
[16:01:44.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.765]  - attr(*, "resolved")= logi TRUE
[16:01:44.765]  - attr(*, "total_size")= num NA
[16:01:44.770]  - Getting '...' globals ... DONE
[16:01:44.770] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:44.770] List of 2
[16:01:44.770]  $ ...future.FUN:function (object, ...)  
[16:01:44.770]  $ ...          : list()
[16:01:44.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.770]  - attr(*, "where")=List of 2
[16:01:44.770]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:44.770]   ..$ ...          :<environment: 0x55b523aea2e0> 
[16:01:44.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.770]  - attr(*, "resolved")= logi FALSE
[16:01:44.770]  - attr(*, "total_size")= num 1240
[16:01:44.773] Packages to be attached in all futures: [n=0] 
[16:01:44.773] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.773] Number of futures (= number of chunks): 1
[16:01:44.773] Launching 1 futures (chunks) ...
[16:01:44.773] Chunk #1 of 1 ...
[16:01:44.774]  - Finding globals in 'X' for chunk #1 ...
[16:01:44.774] getGlobalsAndPackages() ...
[16:01:44.774] Searching for globals...
[16:01:44.774] 
[16:01:44.775] Searching for globals ... DONE
[16:01:44.775] - globals: [0] <none>
[16:01:44.775] getGlobalsAndPackages() ... DONE
[16:01:44.775]    + additional globals found: [n=0] 
[16:01:44.775]    + additional namespaces needed: [n=0] 
[16:01:44.775]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:44.775]  - seeds: <none>
[16:01:44.775]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.775] getGlobalsAndPackages() ...
[16:01:44.776] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.776] Resolving globals: FALSE
[16:01:44.776] Tweak future expression to call with '...' arguments ...
[16:01:44.776] {
[16:01:44.776]     do.call(function(...) {
[16:01:44.776]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.776]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.776]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.776]             on.exit(options(oopts), add = TRUE)
[16:01:44.776]         }
[16:01:44.776]         {
[16:01:44.776]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.776]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.776]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.776]             })
[16:01:44.776]         }
[16:01:44.776]     }, args = future.call.arguments)
[16:01:44.776] }
[16:01:44.776] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.777] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.777] 
[16:01:44.777] getGlobalsAndPackages() ... DONE
[16:01:44.778] run() for ‘Future’ ...
[16:01:44.778] - state: ‘created’
[16:01:44.778] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:44.779] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:44.779]   - Field: ‘label’
[16:01:44.779]   - Field: ‘local’
[16:01:44.779]   - Field: ‘owner’
[16:01:44.782]   - Field: ‘envir’
[16:01:44.782]   - Field: ‘packages’
[16:01:44.783]   - Field: ‘gc’
[16:01:44.783]   - Field: ‘conditions’
[16:01:44.783]   - Field: ‘expr’
[16:01:44.783]   - Field: ‘uuid’
[16:01:44.783]   - Field: ‘seed’
[16:01:44.783]   - Field: ‘version’
[16:01:44.783]   - Field: ‘result’
[16:01:44.783]   - Field: ‘asynchronous’
[16:01:44.783]   - Field: ‘calls’
[16:01:44.784]   - Field: ‘globals’
[16:01:44.784]   - Field: ‘stdout’
[16:01:44.784]   - Field: ‘earlySignal’
[16:01:44.784]   - Field: ‘lazy’
[16:01:44.784]   - Field: ‘state’
[16:01:44.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:44.784] - Launch lazy future ...
[16:01:44.785] Packages needed by the future expression (n = 0): <none>
[16:01:44.785] Packages needed by future strategies (n = 0): <none>
[16:01:44.786] {
[16:01:44.786]     {
[16:01:44.786]         {
[16:01:44.786]             ...future.startTime <- base::Sys.time()
[16:01:44.786]             {
[16:01:44.786]                 {
[16:01:44.786]                   {
[16:01:44.786]                     base::local({
[16:01:44.786]                       has_future <- base::requireNamespace("future", 
[16:01:44.786]                         quietly = TRUE)
[16:01:44.786]                       if (has_future) {
[16:01:44.786]                         ns <- base::getNamespace("future")
[16:01:44.786]                         version <- ns[[".package"]][["version"]]
[16:01:44.786]                         if (is.null(version)) 
[16:01:44.786]                           version <- utils::packageVersion("future")
[16:01:44.786]                       }
[16:01:44.786]                       else {
[16:01:44.786]                         version <- NULL
[16:01:44.786]                       }
[16:01:44.786]                       if (!has_future || version < "1.8.0") {
[16:01:44.786]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.786]                           "", base::R.version$version.string), 
[16:01:44.786]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:44.786]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.786]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.786]                             "release", "version")], collapse = " "), 
[16:01:44.786]                           hostname = base::Sys.info()[["nodename"]])
[16:01:44.786]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.786]                           info)
[16:01:44.786]                         info <- base::paste(info, collapse = "; ")
[16:01:44.786]                         if (!has_future) {
[16:01:44.786]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.786]                             info)
[16:01:44.786]                         }
[16:01:44.786]                         else {
[16:01:44.786]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.786]                             info, version)
[16:01:44.786]                         }
[16:01:44.786]                         base::stop(msg)
[16:01:44.786]                       }
[16:01:44.786]                     })
[16:01:44.786]                   }
[16:01:44.786]                   options(future.plan = NULL)
[16:01:44.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.786]                 }
[16:01:44.786]                 ...future.workdir <- getwd()
[16:01:44.786]             }
[16:01:44.786]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.786]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.786]         }
[16:01:44.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:44.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.786]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.786]             base::names(...future.oldOptions))
[16:01:44.786]     }
[16:01:44.786]     if (FALSE) {
[16:01:44.786]     }
[16:01:44.786]     else {
[16:01:44.786]         if (TRUE) {
[16:01:44.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.786]                 open = "w")
[16:01:44.786]         }
[16:01:44.786]         else {
[16:01:44.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.786]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.786]         }
[16:01:44.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.786]             base::sink(type = "output", split = FALSE)
[16:01:44.786]             base::close(...future.stdout)
[16:01:44.786]         }, add = TRUE)
[16:01:44.786]     }
[16:01:44.786]     ...future.frame <- base::sys.nframe()
[16:01:44.786]     ...future.conditions <- base::list()
[16:01:44.786]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.786]     if (FALSE) {
[16:01:44.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.786]     }
[16:01:44.786]     ...future.result <- base::tryCatch({
[16:01:44.786]         base::withCallingHandlers({
[16:01:44.786]             ...future.value <- base::withVisible(base::local({
[16:01:44.786]                 do.call(function(...) {
[16:01:44.786]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.786]                   if (!identical(...future.globals.maxSize.org, 
[16:01:44.786]                     ...future.globals.maxSize)) {
[16:01:44.786]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.786]                     on.exit(options(oopts), add = TRUE)
[16:01:44.786]                   }
[16:01:44.786]                   {
[16:01:44.786]                     lapply(seq_along(...future.elements_ii), 
[16:01:44.786]                       FUN = function(jj) {
[16:01:44.786]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.786]                         ...future.FUN(...future.X_jj, ...)
[16:01:44.786]                       })
[16:01:44.786]                   }
[16:01:44.786]                 }, args = future.call.arguments)
[16:01:44.786]             }))
[16:01:44.786]             future::FutureResult(value = ...future.value$value, 
[16:01:44.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.786]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.786]                     ...future.globalenv.names))
[16:01:44.786]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.786]         }, condition = base::local({
[16:01:44.786]             c <- base::c
[16:01:44.786]             inherits <- base::inherits
[16:01:44.786]             invokeRestart <- base::invokeRestart
[16:01:44.786]             length <- base::length
[16:01:44.786]             list <- base::list
[16:01:44.786]             seq.int <- base::seq.int
[16:01:44.786]             signalCondition <- base::signalCondition
[16:01:44.786]             sys.calls <- base::sys.calls
[16:01:44.786]             `[[` <- base::`[[`
[16:01:44.786]             `+` <- base::`+`
[16:01:44.786]             `<<-` <- base::`<<-`
[16:01:44.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.786]                   3L)]
[16:01:44.786]             }
[16:01:44.786]             function(cond) {
[16:01:44.786]                 is_error <- inherits(cond, "error")
[16:01:44.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.786]                   NULL)
[16:01:44.786]                 if (is_error) {
[16:01:44.786]                   sessionInformation <- function() {
[16:01:44.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.786]                       search = base::search(), system = base::Sys.info())
[16:01:44.786]                   }
[16:01:44.786]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.786]                     cond$call), session = sessionInformation(), 
[16:01:44.786]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.786]                   signalCondition(cond)
[16:01:44.786]                 }
[16:01:44.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.786]                 "immediateCondition"))) {
[16:01:44.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.786]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.786]                   if (TRUE && !signal) {
[16:01:44.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.786]                     {
[16:01:44.786]                       inherits <- base::inherits
[16:01:44.786]                       invokeRestart <- base::invokeRestart
[16:01:44.786]                       is.null <- base::is.null
[16:01:44.786]                       muffled <- FALSE
[16:01:44.786]                       if (inherits(cond, "message")) {
[16:01:44.786]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.786]                         if (muffled) 
[16:01:44.786]                           invokeRestart("muffleMessage")
[16:01:44.786]                       }
[16:01:44.786]                       else if (inherits(cond, "warning")) {
[16:01:44.786]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.786]                         if (muffled) 
[16:01:44.786]                           invokeRestart("muffleWarning")
[16:01:44.786]                       }
[16:01:44.786]                       else if (inherits(cond, "condition")) {
[16:01:44.786]                         if (!is.null(pattern)) {
[16:01:44.786]                           computeRestarts <- base::computeRestarts
[16:01:44.786]                           grepl <- base::grepl
[16:01:44.786]                           restarts <- computeRestarts(cond)
[16:01:44.786]                           for (restart in restarts) {
[16:01:44.786]                             name <- restart$name
[16:01:44.786]                             if (is.null(name)) 
[16:01:44.786]                               next
[16:01:44.786]                             if (!grepl(pattern, name)) 
[16:01:44.786]                               next
[16:01:44.786]                             invokeRestart(restart)
[16:01:44.786]                             muffled <- TRUE
[16:01:44.786]                             break
[16:01:44.786]                           }
[16:01:44.786]                         }
[16:01:44.786]                       }
[16:01:44.786]                       invisible(muffled)
[16:01:44.786]                     }
[16:01:44.786]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.786]                   }
[16:01:44.786]                 }
[16:01:44.786]                 else {
[16:01:44.786]                   if (TRUE) {
[16:01:44.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.786]                     {
[16:01:44.786]                       inherits <- base::inherits
[16:01:44.786]                       invokeRestart <- base::invokeRestart
[16:01:44.786]                       is.null <- base::is.null
[16:01:44.786]                       muffled <- FALSE
[16:01:44.786]                       if (inherits(cond, "message")) {
[16:01:44.786]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.786]                         if (muffled) 
[16:01:44.786]                           invokeRestart("muffleMessage")
[16:01:44.786]                       }
[16:01:44.786]                       else if (inherits(cond, "warning")) {
[16:01:44.786]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.786]                         if (muffled) 
[16:01:44.786]                           invokeRestart("muffleWarning")
[16:01:44.786]                       }
[16:01:44.786]                       else if (inherits(cond, "condition")) {
[16:01:44.786]                         if (!is.null(pattern)) {
[16:01:44.786]                           computeRestarts <- base::computeRestarts
[16:01:44.786]                           grepl <- base::grepl
[16:01:44.786]                           restarts <- computeRestarts(cond)
[16:01:44.786]                           for (restart in restarts) {
[16:01:44.786]                             name <- restart$name
[16:01:44.786]                             if (is.null(name)) 
[16:01:44.786]                               next
[16:01:44.786]                             if (!grepl(pattern, name)) 
[16:01:44.786]                               next
[16:01:44.786]                             invokeRestart(restart)
[16:01:44.786]                             muffled <- TRUE
[16:01:44.786]                             break
[16:01:44.786]                           }
[16:01:44.786]                         }
[16:01:44.786]                       }
[16:01:44.786]                       invisible(muffled)
[16:01:44.786]                     }
[16:01:44.786]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.786]                   }
[16:01:44.786]                 }
[16:01:44.786]             }
[16:01:44.786]         }))
[16:01:44.786]     }, error = function(ex) {
[16:01:44.786]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.786]                 ...future.rng), started = ...future.startTime, 
[16:01:44.786]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.786]             version = "1.8"), class = "FutureResult")
[16:01:44.786]     }, finally = {
[16:01:44.786]         if (!identical(...future.workdir, getwd())) 
[16:01:44.786]             setwd(...future.workdir)
[16:01:44.786]         {
[16:01:44.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.786]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.786]             }
[16:01:44.786]             base::options(...future.oldOptions)
[16:01:44.786]             if (.Platform$OS.type == "windows") {
[16:01:44.786]                 old_names <- names(...future.oldEnvVars)
[16:01:44.786]                 envs <- base::Sys.getenv()
[16:01:44.786]                 names <- names(envs)
[16:01:44.786]                 common <- intersect(names, old_names)
[16:01:44.786]                 added <- setdiff(names, old_names)
[16:01:44.786]                 removed <- setdiff(old_names, names)
[16:01:44.786]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.786]                   envs[common]]
[16:01:44.786]                 NAMES <- toupper(changed)
[16:01:44.786]                 args <- list()
[16:01:44.786]                 for (kk in seq_along(NAMES)) {
[16:01:44.786]                   name <- changed[[kk]]
[16:01:44.786]                   NAME <- NAMES[[kk]]
[16:01:44.786]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.786]                     next
[16:01:44.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.786]                 }
[16:01:44.786]                 NAMES <- toupper(added)
[16:01:44.786]                 for (kk in seq_along(NAMES)) {
[16:01:44.786]                   name <- added[[kk]]
[16:01:44.786]                   NAME <- NAMES[[kk]]
[16:01:44.786]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.786]                     next
[16:01:44.786]                   args[[name]] <- ""
[16:01:44.786]                 }
[16:01:44.786]                 NAMES <- toupper(removed)
[16:01:44.786]                 for (kk in seq_along(NAMES)) {
[16:01:44.786]                   name <- removed[[kk]]
[16:01:44.786]                   NAME <- NAMES[[kk]]
[16:01:44.786]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.786]                     next
[16:01:44.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.786]                 }
[16:01:44.786]                 if (length(args) > 0) 
[16:01:44.786]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.786]             }
[16:01:44.786]             else {
[16:01:44.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.786]             }
[16:01:44.786]             {
[16:01:44.786]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.786]                   0L) {
[16:01:44.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.786]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.786]                   base::options(opts)
[16:01:44.786]                 }
[16:01:44.786]                 {
[16:01:44.786]                   {
[16:01:44.786]                     NULL
[16:01:44.786]                     RNGkind("Mersenne-Twister")
[16:01:44.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:44.786]                       inherits = FALSE)
[16:01:44.786]                   }
[16:01:44.786]                   options(future.plan = NULL)
[16:01:44.786]                   if (is.na(NA_character_)) 
[16:01:44.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.786]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:44.786]                   {
[16:01:44.786]                     future <- SequentialFuture(..., envir = envir)
[16:01:44.786]                     if (!future$lazy) 
[16:01:44.786]                       future <- run(future)
[16:01:44.786]                     invisible(future)
[16:01:44.786]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.786]                 }
[16:01:44.786]             }
[16:01:44.786]         }
[16:01:44.786]     })
[16:01:44.786]     if (TRUE) {
[16:01:44.786]         base::sink(type = "output", split = FALSE)
[16:01:44.786]         if (TRUE) {
[16:01:44.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.786]         }
[16:01:44.786]         else {
[16:01:44.786]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.786]         }
[16:01:44.786]         base::close(...future.stdout)
[16:01:44.786]         ...future.stdout <- NULL
[16:01:44.786]     }
[16:01:44.786]     ...future.result$conditions <- ...future.conditions
[16:01:44.786]     ...future.result$finished <- base::Sys.time()
[16:01:44.786]     ...future.result
[16:01:44.786] }
[16:01:44.789] assign_globals() ...
[16:01:44.789] List of 5
[16:01:44.789]  $ ...future.FUN            :function (object, ...)  
[16:01:44.789]  $ future.call.arguments    : list()
[16:01:44.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.789]  $ ...future.elements_ii    :List of 3
[16:01:44.789]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:44.789]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:44.789]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.789]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:44.789]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:44.789]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.789]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:44.789]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:44.789]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.789]  $ ...future.seeds_ii       : NULL
[16:01:44.789]  $ ...future.globals.maxSize: NULL
[16:01:44.789]  - attr(*, "where")=List of 5
[16:01:44.789]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:44.789]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:44.789]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:44.789]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:44.789]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:44.789]  - attr(*, "resolved")= logi FALSE
[16:01:44.789]  - attr(*, "total_size")= num 1240
[16:01:44.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.789]  - attr(*, "already-done")= logi TRUE
[16:01:44.797] - copied ‘...future.FUN’ to environment
[16:01:44.797] - copied ‘future.call.arguments’ to environment
[16:01:44.797] - copied ‘...future.elements_ii’ to environment
[16:01:44.798] - copied ‘...future.seeds_ii’ to environment
[16:01:44.798] - copied ‘...future.globals.maxSize’ to environment
[16:01:44.798] assign_globals() ... done
[16:01:44.798] plan(): Setting new future strategy stack:
[16:01:44.798] List of future strategies:
[16:01:44.798] 1. sequential:
[16:01:44.798]    - args: function (..., envir = parent.frame())
[16:01:44.798]    - tweaked: FALSE
[16:01:44.798]    - call: NULL
[16:01:44.799] plan(): nbrOfWorkers() = 1
[16:01:44.801] plan(): Setting new future strategy stack:
[16:01:44.801] List of future strategies:
[16:01:44.801] 1. sequential:
[16:01:44.801]    - args: function (..., envir = parent.frame())
[16:01:44.801]    - tweaked: FALSE
[16:01:44.801]    - call: plan(strategy)
[16:01:44.802] plan(): nbrOfWorkers() = 1
[16:01:44.802] SequentialFuture started (and completed)
[16:01:44.802] - Launch lazy future ... done
[16:01:44.802] run() for ‘SequentialFuture’ ... done
[16:01:44.803] Created future:
[16:01:44.803] SequentialFuture:
[16:01:44.803] Label: ‘future_by-1’
[16:01:44.803] Expression:
[16:01:44.803] {
[16:01:44.803]     do.call(function(...) {
[16:01:44.803]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.803]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.803]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.803]             on.exit(options(oopts), add = TRUE)
[16:01:44.803]         }
[16:01:44.803]         {
[16:01:44.803]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.803]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.803]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.803]             })
[16:01:44.803]         }
[16:01:44.803]     }, args = future.call.arguments)
[16:01:44.803] }
[16:01:44.803] Lazy evaluation: FALSE
[16:01:44.803] Asynchronous evaluation: FALSE
[16:01:44.803] Local evaluation: TRUE
[16:01:44.803] Environment: R_GlobalEnv
[16:01:44.803] Capture standard output: TRUE
[16:01:44.803] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.803] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:44.803] Packages: <none>
[16:01:44.803] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.803] Resolved: TRUE
[16:01:44.803] Value: 4.62 KiB of class ‘list’
[16:01:44.803] Early signaling: FALSE
[16:01:44.803] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:44.803] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.804] Chunk #1 of 1 ... DONE
[16:01:44.805] Launching 1 futures (chunks) ... DONE
[16:01:44.805] Resolving 1 futures (chunks) ...
[16:01:44.805] resolve() on list ...
[16:01:44.805]  recursive: 0
[16:01:44.805]  length: 1
[16:01:44.805] 
[16:01:44.805] resolved() for ‘SequentialFuture’ ...
[16:01:44.805] - state: ‘finished’
[16:01:44.806] - run: TRUE
[16:01:44.806] - result: ‘FutureResult’
[16:01:44.806] resolved() for ‘SequentialFuture’ ... done
[16:01:44.806] Future #1
[16:01:44.806] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:44.806] - nx: 1
[16:01:44.806] - relay: TRUE
[16:01:44.807] - stdout: TRUE
[16:01:44.807] - signal: TRUE
[16:01:44.807] - resignal: FALSE
[16:01:44.807] - force: TRUE
[16:01:44.807] - relayed: [n=1] FALSE
[16:01:44.807] - queued futures: [n=1] FALSE
[16:01:44.807]  - until=1
[16:01:44.807]  - relaying element #1
[16:01:44.807] - relayed: [n=1] TRUE
[16:01:44.807] - queued futures: [n=1] TRUE
[16:01:44.808] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:44.808]  length: 0 (resolved future 1)
[16:01:44.808] Relaying remaining futures
[16:01:44.808] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.808] - nx: 1
[16:01:44.808] - relay: TRUE
[16:01:44.808] - stdout: TRUE
[16:01:44.808] - signal: TRUE
[16:01:44.808] - resignal: FALSE
[16:01:44.808] - force: TRUE
[16:01:44.809] - relayed: [n=1] TRUE
[16:01:44.809] - queued futures: [n=1] TRUE
 - flush all
[16:01:44.809] - relayed: [n=1] TRUE
[16:01:44.809] - queued futures: [n=1] TRUE
[16:01:44.809] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.809] resolve() on list ... DONE
[16:01:44.809]  - Number of value chunks collected: 1
[16:01:44.809] Resolving 1 futures (chunks) ... DONE
[16:01:44.809] Reducing values from 1 chunks ...
[16:01:44.809]  - Number of values collected after concatenation: 3
[16:01:44.810]  - Number of values expected: 3
[16:01:44.810] Reducing values from 1 chunks ... DONE
[16:01:44.810] future_lapply() ... DONE
[16:01:44.810] future_by_internal() ... DONE
[16:01:44.813] future_by_internal() ...
[16:01:44.813] future_lapply() ...
[16:01:44.814] Number of chunks: 1
[16:01:44.814] getGlobalsAndPackagesXApply() ...
[16:01:44.814]  - future.globals: TRUE
[16:01:44.814] getGlobalsAndPackages() ...
[16:01:44.814] Searching for globals...
[16:01:44.815] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:44.815] Searching for globals ... DONE
[16:01:44.815] Resolving globals: FALSE
[16:01:44.816] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:44.816] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:44.816] - globals: [1] ‘FUN’
[16:01:44.816] 
[16:01:44.816] getGlobalsAndPackages() ... DONE
[16:01:44.817]  - globals found/used: [n=1] ‘FUN’
[16:01:44.817]  - needed namespaces: [n=0] 
[16:01:44.817] Finding globals ... DONE
[16:01:44.817]  - use_args: TRUE
[16:01:44.817]  - Getting '...' globals ...
[16:01:44.817] resolve() on list ...
[16:01:44.817]  recursive: 0
[16:01:44.817]  length: 1
[16:01:44.818]  elements: ‘...’
[16:01:44.818]  length: 0 (resolved future 1)
[16:01:44.818] resolve() on list ... DONE
[16:01:44.818]    - '...' content: [n=1] ‘digits’
[16:01:44.818] List of 1
[16:01:44.818]  $ ...:List of 1
[16:01:44.818]   ..$ digits: int 2
[16:01:44.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.818]  - attr(*, "where")=List of 1
[16:01:44.818]   ..$ ...:<environment: 0x55b52506e880> 
[16:01:44.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.818]  - attr(*, "resolved")= logi TRUE
[16:01:44.818]  - attr(*, "total_size")= num NA
[16:01:44.821]  - Getting '...' globals ... DONE
[16:01:44.821] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:44.821] List of 2
[16:01:44.821]  $ ...future.FUN:function (object, ...)  
[16:01:44.821]  $ ...          :List of 1
[16:01:44.821]   ..$ digits: int 2
[16:01:44.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.821]  - attr(*, "where")=List of 2
[16:01:44.821]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:44.821]   ..$ ...          :<environment: 0x55b52506e880> 
[16:01:44.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.821]  - attr(*, "resolved")= logi FALSE
[16:01:44.821]  - attr(*, "total_size")= num 1296
[16:01:44.824] Packages to be attached in all futures: [n=0] 
[16:01:44.825] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.825] Number of futures (= number of chunks): 1
[16:01:44.825] Launching 1 futures (chunks) ...
[16:01:44.825] Chunk #1 of 1 ...
[16:01:44.825]  - Finding globals in 'X' for chunk #1 ...
[16:01:44.825] getGlobalsAndPackages() ...
[16:01:44.825] Searching for globals...
[16:01:44.826] 
[16:01:44.826] Searching for globals ... DONE
[16:01:44.826] - globals: [0] <none>
[16:01:44.826] getGlobalsAndPackages() ... DONE
[16:01:44.826]    + additional globals found: [n=0] 
[16:01:44.826]    + additional namespaces needed: [n=0] 
[16:01:44.826]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:44.826]  - seeds: <none>
[16:01:44.826]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.826] getGlobalsAndPackages() ...
[16:01:44.826] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.827] Resolving globals: FALSE
[16:01:44.827] Tweak future expression to call with '...' arguments ...
[16:01:44.827] {
[16:01:44.827]     do.call(function(...) {
[16:01:44.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.827]             on.exit(options(oopts), add = TRUE)
[16:01:44.827]         }
[16:01:44.827]         {
[16:01:44.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.827]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.827]             })
[16:01:44.827]         }
[16:01:44.827]     }, args = future.call.arguments)
[16:01:44.827] }
[16:01:44.827] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.827] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.828] 
[16:01:44.828] getGlobalsAndPackages() ... DONE
[16:01:44.828] run() for ‘Future’ ...
[16:01:44.828] - state: ‘created’
[16:01:44.828] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:44.829] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.829] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:44.829]   - Field: ‘label’
[16:01:44.829]   - Field: ‘local’
[16:01:44.829]   - Field: ‘owner’
[16:01:44.829]   - Field: ‘envir’
[16:01:44.829]   - Field: ‘packages’
[16:01:44.829]   - Field: ‘gc’
[16:01:44.829]   - Field: ‘conditions’
[16:01:44.829]   - Field: ‘expr’
[16:01:44.830]   - Field: ‘uuid’
[16:01:44.830]   - Field: ‘seed’
[16:01:44.830]   - Field: ‘version’
[16:01:44.830]   - Field: ‘result’
[16:01:44.830]   - Field: ‘asynchronous’
[16:01:44.830]   - Field: ‘calls’
[16:01:44.830]   - Field: ‘globals’
[16:01:44.830]   - Field: ‘stdout’
[16:01:44.830]   - Field: ‘earlySignal’
[16:01:44.830]   - Field: ‘lazy’
[16:01:44.830]   - Field: ‘state’
[16:01:44.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:44.831] - Launch lazy future ...
[16:01:44.831] Packages needed by the future expression (n = 0): <none>
[16:01:44.831] Packages needed by future strategies (n = 0): <none>
[16:01:44.831] {
[16:01:44.831]     {
[16:01:44.831]         {
[16:01:44.831]             ...future.startTime <- base::Sys.time()
[16:01:44.831]             {
[16:01:44.831]                 {
[16:01:44.831]                   {
[16:01:44.831]                     base::local({
[16:01:44.831]                       has_future <- base::requireNamespace("future", 
[16:01:44.831]                         quietly = TRUE)
[16:01:44.831]                       if (has_future) {
[16:01:44.831]                         ns <- base::getNamespace("future")
[16:01:44.831]                         version <- ns[[".package"]][["version"]]
[16:01:44.831]                         if (is.null(version)) 
[16:01:44.831]                           version <- utils::packageVersion("future")
[16:01:44.831]                       }
[16:01:44.831]                       else {
[16:01:44.831]                         version <- NULL
[16:01:44.831]                       }
[16:01:44.831]                       if (!has_future || version < "1.8.0") {
[16:01:44.831]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.831]                           "", base::R.version$version.string), 
[16:01:44.831]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:44.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.831]                             "release", "version")], collapse = " "), 
[16:01:44.831]                           hostname = base::Sys.info()[["nodename"]])
[16:01:44.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.831]                           info)
[16:01:44.831]                         info <- base::paste(info, collapse = "; ")
[16:01:44.831]                         if (!has_future) {
[16:01:44.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.831]                             info)
[16:01:44.831]                         }
[16:01:44.831]                         else {
[16:01:44.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.831]                             info, version)
[16:01:44.831]                         }
[16:01:44.831]                         base::stop(msg)
[16:01:44.831]                       }
[16:01:44.831]                     })
[16:01:44.831]                   }
[16:01:44.831]                   options(future.plan = NULL)
[16:01:44.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.831]                 }
[16:01:44.831]                 ...future.workdir <- getwd()
[16:01:44.831]             }
[16:01:44.831]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.831]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.831]         }
[16:01:44.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:44.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.831]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.831]             base::names(...future.oldOptions))
[16:01:44.831]     }
[16:01:44.831]     if (FALSE) {
[16:01:44.831]     }
[16:01:44.831]     else {
[16:01:44.831]         if (TRUE) {
[16:01:44.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.831]                 open = "w")
[16:01:44.831]         }
[16:01:44.831]         else {
[16:01:44.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.831]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.831]         }
[16:01:44.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.831]             base::sink(type = "output", split = FALSE)
[16:01:44.831]             base::close(...future.stdout)
[16:01:44.831]         }, add = TRUE)
[16:01:44.831]     }
[16:01:44.831]     ...future.frame <- base::sys.nframe()
[16:01:44.831]     ...future.conditions <- base::list()
[16:01:44.831]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.831]     if (FALSE) {
[16:01:44.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.831]     }
[16:01:44.831]     ...future.result <- base::tryCatch({
[16:01:44.831]         base::withCallingHandlers({
[16:01:44.831]             ...future.value <- base::withVisible(base::local({
[16:01:44.831]                 do.call(function(...) {
[16:01:44.831]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.831]                   if (!identical(...future.globals.maxSize.org, 
[16:01:44.831]                     ...future.globals.maxSize)) {
[16:01:44.831]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.831]                     on.exit(options(oopts), add = TRUE)
[16:01:44.831]                   }
[16:01:44.831]                   {
[16:01:44.831]                     lapply(seq_along(...future.elements_ii), 
[16:01:44.831]                       FUN = function(jj) {
[16:01:44.831]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.831]                         ...future.FUN(...future.X_jj, ...)
[16:01:44.831]                       })
[16:01:44.831]                   }
[16:01:44.831]                 }, args = future.call.arguments)
[16:01:44.831]             }))
[16:01:44.831]             future::FutureResult(value = ...future.value$value, 
[16:01:44.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.831]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.831]                     ...future.globalenv.names))
[16:01:44.831]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.831]         }, condition = base::local({
[16:01:44.831]             c <- base::c
[16:01:44.831]             inherits <- base::inherits
[16:01:44.831]             invokeRestart <- base::invokeRestart
[16:01:44.831]             length <- base::length
[16:01:44.831]             list <- base::list
[16:01:44.831]             seq.int <- base::seq.int
[16:01:44.831]             signalCondition <- base::signalCondition
[16:01:44.831]             sys.calls <- base::sys.calls
[16:01:44.831]             `[[` <- base::`[[`
[16:01:44.831]             `+` <- base::`+`
[16:01:44.831]             `<<-` <- base::`<<-`
[16:01:44.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.831]                   3L)]
[16:01:44.831]             }
[16:01:44.831]             function(cond) {
[16:01:44.831]                 is_error <- inherits(cond, "error")
[16:01:44.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.831]                   NULL)
[16:01:44.831]                 if (is_error) {
[16:01:44.831]                   sessionInformation <- function() {
[16:01:44.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.831]                       search = base::search(), system = base::Sys.info())
[16:01:44.831]                   }
[16:01:44.831]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.831]                     cond$call), session = sessionInformation(), 
[16:01:44.831]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.831]                   signalCondition(cond)
[16:01:44.831]                 }
[16:01:44.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.831]                 "immediateCondition"))) {
[16:01:44.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.831]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.831]                   if (TRUE && !signal) {
[16:01:44.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.831]                     {
[16:01:44.831]                       inherits <- base::inherits
[16:01:44.831]                       invokeRestart <- base::invokeRestart
[16:01:44.831]                       is.null <- base::is.null
[16:01:44.831]                       muffled <- FALSE
[16:01:44.831]                       if (inherits(cond, "message")) {
[16:01:44.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.831]                         if (muffled) 
[16:01:44.831]                           invokeRestart("muffleMessage")
[16:01:44.831]                       }
[16:01:44.831]                       else if (inherits(cond, "warning")) {
[16:01:44.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.831]                         if (muffled) 
[16:01:44.831]                           invokeRestart("muffleWarning")
[16:01:44.831]                       }
[16:01:44.831]                       else if (inherits(cond, "condition")) {
[16:01:44.831]                         if (!is.null(pattern)) {
[16:01:44.831]                           computeRestarts <- base::computeRestarts
[16:01:44.831]                           grepl <- base::grepl
[16:01:44.831]                           restarts <- computeRestarts(cond)
[16:01:44.831]                           for (restart in restarts) {
[16:01:44.831]                             name <- restart$name
[16:01:44.831]                             if (is.null(name)) 
[16:01:44.831]                               next
[16:01:44.831]                             if (!grepl(pattern, name)) 
[16:01:44.831]                               next
[16:01:44.831]                             invokeRestart(restart)
[16:01:44.831]                             muffled <- TRUE
[16:01:44.831]                             break
[16:01:44.831]                           }
[16:01:44.831]                         }
[16:01:44.831]                       }
[16:01:44.831]                       invisible(muffled)
[16:01:44.831]                     }
[16:01:44.831]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.831]                   }
[16:01:44.831]                 }
[16:01:44.831]                 else {
[16:01:44.831]                   if (TRUE) {
[16:01:44.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.831]                     {
[16:01:44.831]                       inherits <- base::inherits
[16:01:44.831]                       invokeRestart <- base::invokeRestart
[16:01:44.831]                       is.null <- base::is.null
[16:01:44.831]                       muffled <- FALSE
[16:01:44.831]                       if (inherits(cond, "message")) {
[16:01:44.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.831]                         if (muffled) 
[16:01:44.831]                           invokeRestart("muffleMessage")
[16:01:44.831]                       }
[16:01:44.831]                       else if (inherits(cond, "warning")) {
[16:01:44.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.831]                         if (muffled) 
[16:01:44.831]                           invokeRestart("muffleWarning")
[16:01:44.831]                       }
[16:01:44.831]                       else if (inherits(cond, "condition")) {
[16:01:44.831]                         if (!is.null(pattern)) {
[16:01:44.831]                           computeRestarts <- base::computeRestarts
[16:01:44.831]                           grepl <- base::grepl
[16:01:44.831]                           restarts <- computeRestarts(cond)
[16:01:44.831]                           for (restart in restarts) {
[16:01:44.831]                             name <- restart$name
[16:01:44.831]                             if (is.null(name)) 
[16:01:44.831]                               next
[16:01:44.831]                             if (!grepl(pattern, name)) 
[16:01:44.831]                               next
[16:01:44.831]                             invokeRestart(restart)
[16:01:44.831]                             muffled <- TRUE
[16:01:44.831]                             break
[16:01:44.831]                           }
[16:01:44.831]                         }
[16:01:44.831]                       }
[16:01:44.831]                       invisible(muffled)
[16:01:44.831]                     }
[16:01:44.831]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.831]                   }
[16:01:44.831]                 }
[16:01:44.831]             }
[16:01:44.831]         }))
[16:01:44.831]     }, error = function(ex) {
[16:01:44.831]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.831]                 ...future.rng), started = ...future.startTime, 
[16:01:44.831]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.831]             version = "1.8"), class = "FutureResult")
[16:01:44.831]     }, finally = {
[16:01:44.831]         if (!identical(...future.workdir, getwd())) 
[16:01:44.831]             setwd(...future.workdir)
[16:01:44.831]         {
[16:01:44.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.831]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.831]             }
[16:01:44.831]             base::options(...future.oldOptions)
[16:01:44.831]             if (.Platform$OS.type == "windows") {
[16:01:44.831]                 old_names <- names(...future.oldEnvVars)
[16:01:44.831]                 envs <- base::Sys.getenv()
[16:01:44.831]                 names <- names(envs)
[16:01:44.831]                 common <- intersect(names, old_names)
[16:01:44.831]                 added <- setdiff(names, old_names)
[16:01:44.831]                 removed <- setdiff(old_names, names)
[16:01:44.831]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.831]                   envs[common]]
[16:01:44.831]                 NAMES <- toupper(changed)
[16:01:44.831]                 args <- list()
[16:01:44.831]                 for (kk in seq_along(NAMES)) {
[16:01:44.831]                   name <- changed[[kk]]
[16:01:44.831]                   NAME <- NAMES[[kk]]
[16:01:44.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.831]                     next
[16:01:44.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.831]                 }
[16:01:44.831]                 NAMES <- toupper(added)
[16:01:44.831]                 for (kk in seq_along(NAMES)) {
[16:01:44.831]                   name <- added[[kk]]
[16:01:44.831]                   NAME <- NAMES[[kk]]
[16:01:44.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.831]                     next
[16:01:44.831]                   args[[name]] <- ""
[16:01:44.831]                 }
[16:01:44.831]                 NAMES <- toupper(removed)
[16:01:44.831]                 for (kk in seq_along(NAMES)) {
[16:01:44.831]                   name <- removed[[kk]]
[16:01:44.831]                   NAME <- NAMES[[kk]]
[16:01:44.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.831]                     next
[16:01:44.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.831]                 }
[16:01:44.831]                 if (length(args) > 0) 
[16:01:44.831]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.831]             }
[16:01:44.831]             else {
[16:01:44.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.831]             }
[16:01:44.831]             {
[16:01:44.831]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.831]                   0L) {
[16:01:44.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.831]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.831]                   base::options(opts)
[16:01:44.831]                 }
[16:01:44.831]                 {
[16:01:44.831]                   {
[16:01:44.831]                     NULL
[16:01:44.831]                     RNGkind("Mersenne-Twister")
[16:01:44.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:44.831]                       inherits = FALSE)
[16:01:44.831]                   }
[16:01:44.831]                   options(future.plan = NULL)
[16:01:44.831]                   if (is.na(NA_character_)) 
[16:01:44.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.831]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:44.831]                   {
[16:01:44.831]                     future <- SequentialFuture(..., envir = envir)
[16:01:44.831]                     if (!future$lazy) 
[16:01:44.831]                       future <- run(future)
[16:01:44.831]                     invisible(future)
[16:01:44.831]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.831]                 }
[16:01:44.831]             }
[16:01:44.831]         }
[16:01:44.831]     })
[16:01:44.831]     if (TRUE) {
[16:01:44.831]         base::sink(type = "output", split = FALSE)
[16:01:44.831]         if (TRUE) {
[16:01:44.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.831]         }
[16:01:44.831]         else {
[16:01:44.831]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.831]         }
[16:01:44.831]         base::close(...future.stdout)
[16:01:44.831]         ...future.stdout <- NULL
[16:01:44.831]     }
[16:01:44.831]     ...future.result$conditions <- ...future.conditions
[16:01:44.831]     ...future.result$finished <- base::Sys.time()
[16:01:44.831]     ...future.result
[16:01:44.831] }
[16:01:44.833] assign_globals() ...
[16:01:44.833] List of 5
[16:01:44.833]  $ ...future.FUN            :function (object, ...)  
[16:01:44.833]  $ future.call.arguments    :List of 1
[16:01:44.833]   ..$ digits: int 2
[16:01:44.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.833]  $ ...future.elements_ii    :List of 6
[16:01:44.833]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:01:44.833]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:01:44.833]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:01:44.833]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:01:44.833]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:01:44.833]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:01:44.833]  $ ...future.seeds_ii       : NULL
[16:01:44.833]  $ ...future.globals.maxSize: NULL
[16:01:44.833]  - attr(*, "where")=List of 5
[16:01:44.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:44.833]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:44.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:44.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:44.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:44.833]  - attr(*, "resolved")= logi FALSE
[16:01:44.833]  - attr(*, "total_size")= num 1296
[16:01:44.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.833]  - attr(*, "already-done")= logi TRUE
[16:01:44.842] - copied ‘...future.FUN’ to environment
[16:01:44.842] - copied ‘future.call.arguments’ to environment
[16:01:44.842] - copied ‘...future.elements_ii’ to environment
[16:01:44.842] - copied ‘...future.seeds_ii’ to environment
[16:01:44.842] - copied ‘...future.globals.maxSize’ to environment
[16:01:44.842] assign_globals() ... done
[16:01:44.843] plan(): Setting new future strategy stack:
[16:01:44.843] List of future strategies:
[16:01:44.843] 1. sequential:
[16:01:44.843]    - args: function (..., envir = parent.frame())
[16:01:44.843]    - tweaked: FALSE
[16:01:44.843]    - call: NULL
[16:01:44.843] plan(): nbrOfWorkers() = 1
[16:01:44.844] plan(): Setting new future strategy stack:
[16:01:44.845] List of future strategies:
[16:01:44.845] 1. sequential:
[16:01:44.845]    - args: function (..., envir = parent.frame())
[16:01:44.845]    - tweaked: FALSE
[16:01:44.845]    - call: plan(strategy)
[16:01:44.845] plan(): nbrOfWorkers() = 1
[16:01:44.845] SequentialFuture started (and completed)
[16:01:44.845] - Launch lazy future ... done
[16:01:44.845] run() for ‘SequentialFuture’ ... done
[16:01:44.845] Created future:
[16:01:44.846] SequentialFuture:
[16:01:44.846] Label: ‘future_by-1’
[16:01:44.846] Expression:
[16:01:44.846] {
[16:01:44.846]     do.call(function(...) {
[16:01:44.846]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.846]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.846]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.846]             on.exit(options(oopts), add = TRUE)
[16:01:44.846]         }
[16:01:44.846]         {
[16:01:44.846]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.846]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.846]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.846]             })
[16:01:44.846]         }
[16:01:44.846]     }, args = future.call.arguments)
[16:01:44.846] }
[16:01:44.846] Lazy evaluation: FALSE
[16:01:44.846] Asynchronous evaluation: FALSE
[16:01:44.846] Local evaluation: TRUE
[16:01:44.846] Environment: R_GlobalEnv
[16:01:44.846] Capture standard output: TRUE
[16:01:44.846] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.846] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:44.846] Packages: <none>
[16:01:44.846] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.846] Resolved: TRUE
[16:01:44.846] Value: 5.48 KiB of class ‘list’
[16:01:44.846] Early signaling: FALSE
[16:01:44.846] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:44.846] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.847] Chunk #1 of 1 ... DONE
[16:01:44.847] Launching 1 futures (chunks) ... DONE
[16:01:44.847] Resolving 1 futures (chunks) ...
[16:01:44.847] resolve() on list ...
[16:01:44.847]  recursive: 0
[16:01:44.847]  length: 1
[16:01:44.847] 
[16:01:44.847] resolved() for ‘SequentialFuture’ ...
[16:01:44.847] - state: ‘finished’
[16:01:44.848] - run: TRUE
[16:01:44.848] - result: ‘FutureResult’
[16:01:44.848] resolved() for ‘SequentialFuture’ ... done
[16:01:44.848] Future #1
[16:01:44.848] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:44.848] - nx: 1
[16:01:44.848] - relay: TRUE
[16:01:44.848] - stdout: TRUE
[16:01:44.848] - signal: TRUE
[16:01:44.848] - resignal: FALSE
[16:01:44.849] - force: TRUE
[16:01:44.849] - relayed: [n=1] FALSE
[16:01:44.849] - queued futures: [n=1] FALSE
[16:01:44.849]  - until=1
[16:01:44.849]  - relaying element #1
[16:01:44.849] - relayed: [n=1] TRUE
[16:01:44.849] - queued futures: [n=1] TRUE
[16:01:44.849] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:44.849]  length: 0 (resolved future 1)
[16:01:44.849] Relaying remaining futures
[16:01:44.850] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.850] - nx: 1
[16:01:44.850] - relay: TRUE
[16:01:44.850] - stdout: TRUE
[16:01:44.850] - signal: TRUE
[16:01:44.850] - resignal: FALSE
[16:01:44.850] - force: TRUE
[16:01:44.850] - relayed: [n=1] TRUE
[16:01:44.850] - queued futures: [n=1] TRUE
 - flush all
[16:01:44.850] - relayed: [n=1] TRUE
[16:01:44.851] - queued futures: [n=1] TRUE
[16:01:44.851] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.851] resolve() on list ... DONE
[16:01:44.851]  - Number of value chunks collected: 1
[16:01:44.851] Resolving 1 futures (chunks) ... DONE
[16:01:44.851] Reducing values from 1 chunks ...
[16:01:44.851]  - Number of values collected after concatenation: 6
[16:01:44.851]  - Number of values expected: 6
[16:01:44.851] Reducing values from 1 chunks ... DONE
[16:01:44.851] future_lapply() ... DONE
[16:01:44.852] future_by_internal() ... DONE
[16:01:44.855] future_by_internal() ...
[16:01:44.855] future_lapply() ...
[16:01:44.856] Number of chunks: 1
[16:01:44.856] getGlobalsAndPackagesXApply() ...
[16:01:44.856]  - future.globals: TRUE
[16:01:44.856] getGlobalsAndPackages() ...
[16:01:44.856] Searching for globals...
[16:01:44.860] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:44.860] Searching for globals ... DONE
[16:01:44.860] Resolving globals: FALSE
[16:01:44.860] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:01:44.861] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:01:44.861] - globals: [1] ‘FUN’
[16:01:44.861] - packages: [1] ‘stats’
[16:01:44.861] getGlobalsAndPackages() ... DONE
[16:01:44.861]  - globals found/used: [n=1] ‘FUN’
[16:01:44.861]  - needed namespaces: [n=1] ‘stats’
[16:01:44.861] Finding globals ... DONE
[16:01:44.861]  - use_args: TRUE
[16:01:44.862]  - Getting '...' globals ...
[16:01:44.862] resolve() on list ...
[16:01:44.862]  recursive: 0
[16:01:44.862]  length: 1
[16:01:44.862]  elements: ‘...’
[16:01:44.862]  length: 0 (resolved future 1)
[16:01:44.862] resolve() on list ... DONE
[16:01:44.862]    - '...' content: [n=1] ‘singular.ok’
[16:01:44.863] List of 1
[16:01:44.863]  $ ...:List of 1
[16:01:44.863]   ..$ singular.ok: logi FALSE
[16:01:44.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.863]  - attr(*, "where")=List of 1
[16:01:44.863]   ..$ ...:<environment: 0x55b526100520> 
[16:01:44.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.863]  - attr(*, "resolved")= logi TRUE
[16:01:44.863]  - attr(*, "total_size")= num NA
[16:01:44.865]  - Getting '...' globals ... DONE
[16:01:44.866] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:44.866] List of 2
[16:01:44.866]  $ ...future.FUN:function (x, ...)  
[16:01:44.866]  $ ...          :List of 1
[16:01:44.866]   ..$ singular.ok: logi FALSE
[16:01:44.866]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.866]  - attr(*, "where")=List of 2
[16:01:44.866]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:44.866]   ..$ ...          :<environment: 0x55b526100520> 
[16:01:44.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.866]  - attr(*, "resolved")= logi FALSE
[16:01:44.866]  - attr(*, "total_size")= num 5384
[16:01:44.869] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:44.869] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.869] Number of futures (= number of chunks): 1
[16:01:44.869] Launching 1 futures (chunks) ...
[16:01:44.869] Chunk #1 of 1 ...
[16:01:44.869]  - Finding globals in 'X' for chunk #1 ...
[16:01:44.870] getGlobalsAndPackages() ...
[16:01:44.870] Searching for globals...
[16:01:44.870] 
[16:01:44.870] Searching for globals ... DONE
[16:01:44.870] - globals: [0] <none>
[16:01:44.870] getGlobalsAndPackages() ... DONE
[16:01:44.871]    + additional globals found: [n=0] 
[16:01:44.871]    + additional namespaces needed: [n=0] 
[16:01:44.871]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:44.871]  - seeds: <none>
[16:01:44.871]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.871] getGlobalsAndPackages() ...
[16:01:44.871] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.871] Resolving globals: FALSE
[16:01:44.871] Tweak future expression to call with '...' arguments ...
[16:01:44.871] {
[16:01:44.871]     do.call(function(...) {
[16:01:44.871]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.871]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.871]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.871]             on.exit(options(oopts), add = TRUE)
[16:01:44.871]         }
[16:01:44.871]         {
[16:01:44.871]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.871]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.871]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.871]             })
[16:01:44.871]         }
[16:01:44.871]     }, args = future.call.arguments)
[16:01:44.871] }
[16:01:44.872] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.872] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.872] 
[16:01:44.872] getGlobalsAndPackages() ... DONE
[16:01:44.873] run() for ‘Future’ ...
[16:01:44.873] - state: ‘created’
[16:01:44.873] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:44.873] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:44.873]   - Field: ‘label’
[16:01:44.873]   - Field: ‘local’
[16:01:44.874]   - Field: ‘owner’
[16:01:44.874]   - Field: ‘envir’
[16:01:44.874]   - Field: ‘packages’
[16:01:44.874]   - Field: ‘gc’
[16:01:44.874]   - Field: ‘conditions’
[16:01:44.874]   - Field: ‘expr’
[16:01:44.874]   - Field: ‘uuid’
[16:01:44.874]   - Field: ‘seed’
[16:01:44.874]   - Field: ‘version’
[16:01:44.874]   - Field: ‘result’
[16:01:44.874]   - Field: ‘asynchronous’
[16:01:44.875]   - Field: ‘calls’
[16:01:44.875]   - Field: ‘globals’
[16:01:44.875]   - Field: ‘stdout’
[16:01:44.875]   - Field: ‘earlySignal’
[16:01:44.875]   - Field: ‘lazy’
[16:01:44.875]   - Field: ‘state’
[16:01:44.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:44.875] - Launch lazy future ...
[16:01:44.875] Packages needed by the future expression (n = 1): ‘stats’
[16:01:44.876] Packages needed by future strategies (n = 0): <none>
[16:01:44.876] {
[16:01:44.876]     {
[16:01:44.876]         {
[16:01:44.876]             ...future.startTime <- base::Sys.time()
[16:01:44.876]             {
[16:01:44.876]                 {
[16:01:44.876]                   {
[16:01:44.876]                     {
[16:01:44.876]                       base::local({
[16:01:44.876]                         has_future <- base::requireNamespace("future", 
[16:01:44.876]                           quietly = TRUE)
[16:01:44.876]                         if (has_future) {
[16:01:44.876]                           ns <- base::getNamespace("future")
[16:01:44.876]                           version <- ns[[".package"]][["version"]]
[16:01:44.876]                           if (is.null(version)) 
[16:01:44.876]                             version <- utils::packageVersion("future")
[16:01:44.876]                         }
[16:01:44.876]                         else {
[16:01:44.876]                           version <- NULL
[16:01:44.876]                         }
[16:01:44.876]                         if (!has_future || version < "1.8.0") {
[16:01:44.876]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.876]                             "", base::R.version$version.string), 
[16:01:44.876]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:44.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.876]                               "release", "version")], collapse = " "), 
[16:01:44.876]                             hostname = base::Sys.info()[["nodename"]])
[16:01:44.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.876]                             info)
[16:01:44.876]                           info <- base::paste(info, collapse = "; ")
[16:01:44.876]                           if (!has_future) {
[16:01:44.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.876]                               info)
[16:01:44.876]                           }
[16:01:44.876]                           else {
[16:01:44.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.876]                               info, version)
[16:01:44.876]                           }
[16:01:44.876]                           base::stop(msg)
[16:01:44.876]                         }
[16:01:44.876]                       })
[16:01:44.876]                     }
[16:01:44.876]                     base::local({
[16:01:44.876]                       for (pkg in "stats") {
[16:01:44.876]                         base::loadNamespace(pkg)
[16:01:44.876]                         base::library(pkg, character.only = TRUE)
[16:01:44.876]                       }
[16:01:44.876]                     })
[16:01:44.876]                   }
[16:01:44.876]                   options(future.plan = NULL)
[16:01:44.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.876]                 }
[16:01:44.876]                 ...future.workdir <- getwd()
[16:01:44.876]             }
[16:01:44.876]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.876]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.876]         }
[16:01:44.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:44.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.876]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.876]             base::names(...future.oldOptions))
[16:01:44.876]     }
[16:01:44.876]     if (FALSE) {
[16:01:44.876]     }
[16:01:44.876]     else {
[16:01:44.876]         if (TRUE) {
[16:01:44.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.876]                 open = "w")
[16:01:44.876]         }
[16:01:44.876]         else {
[16:01:44.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.876]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.876]         }
[16:01:44.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.876]             base::sink(type = "output", split = FALSE)
[16:01:44.876]             base::close(...future.stdout)
[16:01:44.876]         }, add = TRUE)
[16:01:44.876]     }
[16:01:44.876]     ...future.frame <- base::sys.nframe()
[16:01:44.876]     ...future.conditions <- base::list()
[16:01:44.876]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.876]     if (FALSE) {
[16:01:44.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.876]     }
[16:01:44.876]     ...future.result <- base::tryCatch({
[16:01:44.876]         base::withCallingHandlers({
[16:01:44.876]             ...future.value <- base::withVisible(base::local({
[16:01:44.876]                 do.call(function(...) {
[16:01:44.876]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.876]                   if (!identical(...future.globals.maxSize.org, 
[16:01:44.876]                     ...future.globals.maxSize)) {
[16:01:44.876]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.876]                     on.exit(options(oopts), add = TRUE)
[16:01:44.876]                   }
[16:01:44.876]                   {
[16:01:44.876]                     lapply(seq_along(...future.elements_ii), 
[16:01:44.876]                       FUN = function(jj) {
[16:01:44.876]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.876]                         ...future.FUN(...future.X_jj, ...)
[16:01:44.876]                       })
[16:01:44.876]                   }
[16:01:44.876]                 }, args = future.call.arguments)
[16:01:44.876]             }))
[16:01:44.876]             future::FutureResult(value = ...future.value$value, 
[16:01:44.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.876]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.876]                     ...future.globalenv.names))
[16:01:44.876]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.876]         }, condition = base::local({
[16:01:44.876]             c <- base::c
[16:01:44.876]             inherits <- base::inherits
[16:01:44.876]             invokeRestart <- base::invokeRestart
[16:01:44.876]             length <- base::length
[16:01:44.876]             list <- base::list
[16:01:44.876]             seq.int <- base::seq.int
[16:01:44.876]             signalCondition <- base::signalCondition
[16:01:44.876]             sys.calls <- base::sys.calls
[16:01:44.876]             `[[` <- base::`[[`
[16:01:44.876]             `+` <- base::`+`
[16:01:44.876]             `<<-` <- base::`<<-`
[16:01:44.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.876]                   3L)]
[16:01:44.876]             }
[16:01:44.876]             function(cond) {
[16:01:44.876]                 is_error <- inherits(cond, "error")
[16:01:44.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.876]                   NULL)
[16:01:44.876]                 if (is_error) {
[16:01:44.876]                   sessionInformation <- function() {
[16:01:44.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.876]                       search = base::search(), system = base::Sys.info())
[16:01:44.876]                   }
[16:01:44.876]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.876]                     cond$call), session = sessionInformation(), 
[16:01:44.876]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.876]                   signalCondition(cond)
[16:01:44.876]                 }
[16:01:44.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.876]                 "immediateCondition"))) {
[16:01:44.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.876]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.876]                   if (TRUE && !signal) {
[16:01:44.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.876]                     {
[16:01:44.876]                       inherits <- base::inherits
[16:01:44.876]                       invokeRestart <- base::invokeRestart
[16:01:44.876]                       is.null <- base::is.null
[16:01:44.876]                       muffled <- FALSE
[16:01:44.876]                       if (inherits(cond, "message")) {
[16:01:44.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.876]                         if (muffled) 
[16:01:44.876]                           invokeRestart("muffleMessage")
[16:01:44.876]                       }
[16:01:44.876]                       else if (inherits(cond, "warning")) {
[16:01:44.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.876]                         if (muffled) 
[16:01:44.876]                           invokeRestart("muffleWarning")
[16:01:44.876]                       }
[16:01:44.876]                       else if (inherits(cond, "condition")) {
[16:01:44.876]                         if (!is.null(pattern)) {
[16:01:44.876]                           computeRestarts <- base::computeRestarts
[16:01:44.876]                           grepl <- base::grepl
[16:01:44.876]                           restarts <- computeRestarts(cond)
[16:01:44.876]                           for (restart in restarts) {
[16:01:44.876]                             name <- restart$name
[16:01:44.876]                             if (is.null(name)) 
[16:01:44.876]                               next
[16:01:44.876]                             if (!grepl(pattern, name)) 
[16:01:44.876]                               next
[16:01:44.876]                             invokeRestart(restart)
[16:01:44.876]                             muffled <- TRUE
[16:01:44.876]                             break
[16:01:44.876]                           }
[16:01:44.876]                         }
[16:01:44.876]                       }
[16:01:44.876]                       invisible(muffled)
[16:01:44.876]                     }
[16:01:44.876]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.876]                   }
[16:01:44.876]                 }
[16:01:44.876]                 else {
[16:01:44.876]                   if (TRUE) {
[16:01:44.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.876]                     {
[16:01:44.876]                       inherits <- base::inherits
[16:01:44.876]                       invokeRestart <- base::invokeRestart
[16:01:44.876]                       is.null <- base::is.null
[16:01:44.876]                       muffled <- FALSE
[16:01:44.876]                       if (inherits(cond, "message")) {
[16:01:44.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.876]                         if (muffled) 
[16:01:44.876]                           invokeRestart("muffleMessage")
[16:01:44.876]                       }
[16:01:44.876]                       else if (inherits(cond, "warning")) {
[16:01:44.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.876]                         if (muffled) 
[16:01:44.876]                           invokeRestart("muffleWarning")
[16:01:44.876]                       }
[16:01:44.876]                       else if (inherits(cond, "condition")) {
[16:01:44.876]                         if (!is.null(pattern)) {
[16:01:44.876]                           computeRestarts <- base::computeRestarts
[16:01:44.876]                           grepl <- base::grepl
[16:01:44.876]                           restarts <- computeRestarts(cond)
[16:01:44.876]                           for (restart in restarts) {
[16:01:44.876]                             name <- restart$name
[16:01:44.876]                             if (is.null(name)) 
[16:01:44.876]                               next
[16:01:44.876]                             if (!grepl(pattern, name)) 
[16:01:44.876]                               next
[16:01:44.876]                             invokeRestart(restart)
[16:01:44.876]                             muffled <- TRUE
[16:01:44.876]                             break
[16:01:44.876]                           }
[16:01:44.876]                         }
[16:01:44.876]                       }
[16:01:44.876]                       invisible(muffled)
[16:01:44.876]                     }
[16:01:44.876]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.876]                   }
[16:01:44.876]                 }
[16:01:44.876]             }
[16:01:44.876]         }))
[16:01:44.876]     }, error = function(ex) {
[16:01:44.876]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.876]                 ...future.rng), started = ...future.startTime, 
[16:01:44.876]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.876]             version = "1.8"), class = "FutureResult")
[16:01:44.876]     }, finally = {
[16:01:44.876]         if (!identical(...future.workdir, getwd())) 
[16:01:44.876]             setwd(...future.workdir)
[16:01:44.876]         {
[16:01:44.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.876]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.876]             }
[16:01:44.876]             base::options(...future.oldOptions)
[16:01:44.876]             if (.Platform$OS.type == "windows") {
[16:01:44.876]                 old_names <- names(...future.oldEnvVars)
[16:01:44.876]                 envs <- base::Sys.getenv()
[16:01:44.876]                 names <- names(envs)
[16:01:44.876]                 common <- intersect(names, old_names)
[16:01:44.876]                 added <- setdiff(names, old_names)
[16:01:44.876]                 removed <- setdiff(old_names, names)
[16:01:44.876]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.876]                   envs[common]]
[16:01:44.876]                 NAMES <- toupper(changed)
[16:01:44.876]                 args <- list()
[16:01:44.876]                 for (kk in seq_along(NAMES)) {
[16:01:44.876]                   name <- changed[[kk]]
[16:01:44.876]                   NAME <- NAMES[[kk]]
[16:01:44.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.876]                     next
[16:01:44.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.876]                 }
[16:01:44.876]                 NAMES <- toupper(added)
[16:01:44.876]                 for (kk in seq_along(NAMES)) {
[16:01:44.876]                   name <- added[[kk]]
[16:01:44.876]                   NAME <- NAMES[[kk]]
[16:01:44.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.876]                     next
[16:01:44.876]                   args[[name]] <- ""
[16:01:44.876]                 }
[16:01:44.876]                 NAMES <- toupper(removed)
[16:01:44.876]                 for (kk in seq_along(NAMES)) {
[16:01:44.876]                   name <- removed[[kk]]
[16:01:44.876]                   NAME <- NAMES[[kk]]
[16:01:44.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.876]                     next
[16:01:44.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.876]                 }
[16:01:44.876]                 if (length(args) > 0) 
[16:01:44.876]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.876]             }
[16:01:44.876]             else {
[16:01:44.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.876]             }
[16:01:44.876]             {
[16:01:44.876]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.876]                   0L) {
[16:01:44.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.876]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.876]                   base::options(opts)
[16:01:44.876]                 }
[16:01:44.876]                 {
[16:01:44.876]                   {
[16:01:44.876]                     NULL
[16:01:44.876]                     RNGkind("Mersenne-Twister")
[16:01:44.876]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:44.876]                       inherits = FALSE)
[16:01:44.876]                   }
[16:01:44.876]                   options(future.plan = NULL)
[16:01:44.876]                   if (is.na(NA_character_)) 
[16:01:44.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.876]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:44.876]                   {
[16:01:44.876]                     future <- SequentialFuture(..., envir = envir)
[16:01:44.876]                     if (!future$lazy) 
[16:01:44.876]                       future <- run(future)
[16:01:44.876]                     invisible(future)
[16:01:44.876]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.876]                 }
[16:01:44.876]             }
[16:01:44.876]         }
[16:01:44.876]     })
[16:01:44.876]     if (TRUE) {
[16:01:44.876]         base::sink(type = "output", split = FALSE)
[16:01:44.876]         if (TRUE) {
[16:01:44.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.876]         }
[16:01:44.876]         else {
[16:01:44.876]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.876]         }
[16:01:44.876]         base::close(...future.stdout)
[16:01:44.876]         ...future.stdout <- NULL
[16:01:44.876]     }
[16:01:44.876]     ...future.result$conditions <- ...future.conditions
[16:01:44.876]     ...future.result$finished <- base::Sys.time()
[16:01:44.876]     ...future.result
[16:01:44.876] }
[16:01:44.878] assign_globals() ...
[16:01:44.878] List of 5
[16:01:44.878]  $ ...future.FUN            :function (x, ...)  
[16:01:44.878]  $ future.call.arguments    :List of 1
[16:01:44.878]   ..$ singular.ok: logi FALSE
[16:01:44.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.878]  $ ...future.elements_ii    :List of 3
[16:01:44.878]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.878]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:44.878]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.878]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:44.878]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.878]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:44.878]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.878]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:44.878]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.878]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:44.878]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.878]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:44.878]  $ ...future.seeds_ii       : NULL
[16:01:44.878]  $ ...future.globals.maxSize: NULL
[16:01:44.878]  - attr(*, "where")=List of 5
[16:01:44.878]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:44.878]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:44.878]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:44.878]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:44.878]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:44.878]  - attr(*, "resolved")= logi FALSE
[16:01:44.878]  - attr(*, "total_size")= num 5384
[16:01:44.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.878]  - attr(*, "already-done")= logi TRUE
[16:01:44.889] - reassign environment for ‘...future.FUN’
[16:01:44.889] - copied ‘...future.FUN’ to environment
[16:01:44.889] - copied ‘future.call.arguments’ to environment
[16:01:44.889] - copied ‘...future.elements_ii’ to environment
[16:01:44.889] - copied ‘...future.seeds_ii’ to environment
[16:01:44.889] - copied ‘...future.globals.maxSize’ to environment
[16:01:44.889] assign_globals() ... done
[16:01:44.890] plan(): Setting new future strategy stack:
[16:01:44.890] List of future strategies:
[16:01:44.890] 1. sequential:
[16:01:44.890]    - args: function (..., envir = parent.frame())
[16:01:44.890]    - tweaked: FALSE
[16:01:44.890]    - call: NULL
[16:01:44.890] plan(): nbrOfWorkers() = 1
[16:01:44.893] plan(): Setting new future strategy stack:
[16:01:44.893] List of future strategies:
[16:01:44.893] 1. sequential:
[16:01:44.893]    - args: function (..., envir = parent.frame())
[16:01:44.893]    - tweaked: FALSE
[16:01:44.893]    - call: plan(strategy)
[16:01:44.894] plan(): nbrOfWorkers() = 1
[16:01:44.894] SequentialFuture started (and completed)
[16:01:44.894] - Launch lazy future ... done
[16:01:44.894] run() for ‘SequentialFuture’ ... done
[16:01:44.894] Created future:
[16:01:44.894] SequentialFuture:
[16:01:44.894] Label: ‘future_by-1’
[16:01:44.894] Expression:
[16:01:44.894] {
[16:01:44.894]     do.call(function(...) {
[16:01:44.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.894]             on.exit(options(oopts), add = TRUE)
[16:01:44.894]         }
[16:01:44.894]         {
[16:01:44.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.894]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.894]             })
[16:01:44.894]         }
[16:01:44.894]     }, args = future.call.arguments)
[16:01:44.894] }
[16:01:44.894] Lazy evaluation: FALSE
[16:01:44.894] Asynchronous evaluation: FALSE
[16:01:44.894] Local evaluation: TRUE
[16:01:44.894] Environment: R_GlobalEnv
[16:01:44.894] Capture standard output: TRUE
[16:01:44.894] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.894] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:44.894] Packages: 1 packages (‘stats’)
[16:01:44.894] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.894] Resolved: TRUE
[16:01:44.894] Value: 26.06 KiB of class ‘list’
[16:01:44.894] Early signaling: FALSE
[16:01:44.894] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:44.894] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.896] Chunk #1 of 1 ... DONE
[16:01:44.896] Launching 1 futures (chunks) ... DONE
[16:01:44.896] Resolving 1 futures (chunks) ...
[16:01:44.896] resolve() on list ...
[16:01:44.896]  recursive: 0
[16:01:44.896]  length: 1
[16:01:44.896] 
[16:01:44.896] resolved() for ‘SequentialFuture’ ...
[16:01:44.897] - state: ‘finished’
[16:01:44.897] - run: TRUE
[16:01:44.897] - result: ‘FutureResult’
[16:01:44.897] resolved() for ‘SequentialFuture’ ... done
[16:01:44.897] Future #1
[16:01:44.897] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:44.897] - nx: 1
[16:01:44.897] - relay: TRUE
[16:01:44.897] - stdout: TRUE
[16:01:44.897] - signal: TRUE
[16:01:44.897] - resignal: FALSE
[16:01:44.898] - force: TRUE
[16:01:44.898] - relayed: [n=1] FALSE
[16:01:44.898] - queued futures: [n=1] FALSE
[16:01:44.898]  - until=1
[16:01:44.898]  - relaying element #1
[16:01:44.898] - relayed: [n=1] TRUE
[16:01:44.898] - queued futures: [n=1] TRUE
[16:01:44.898] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:44.898]  length: 0 (resolved future 1)
[16:01:44.898] Relaying remaining futures
[16:01:44.899] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.899] - nx: 1
[16:01:44.899] - relay: TRUE
[16:01:44.899] - stdout: TRUE
[16:01:44.899] - signal: TRUE
[16:01:44.899] - resignal: FALSE
[16:01:44.899] - force: TRUE
[16:01:44.899] - relayed: [n=1] TRUE
[16:01:44.899] - queued futures: [n=1] TRUE
 - flush all
[16:01:44.899] - relayed: [n=1] TRUE
[16:01:44.899] - queued futures: [n=1] TRUE
[16:01:44.900] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.900] resolve() on list ... DONE
[16:01:44.900]  - Number of value chunks collected: 1
[16:01:44.900] Resolving 1 futures (chunks) ... DONE
[16:01:44.900] Reducing values from 1 chunks ...
[16:01:44.900]  - Number of values collected after concatenation: 3
[16:01:44.900]  - Number of values expected: 3
[16:01:44.900] Reducing values from 1 chunks ... DONE
[16:01:44.900] future_lapply() ... DONE
[16:01:44.900] future_by_internal() ... DONE
[16:01:44.906] future_by_internal() ...
[16:01:44.907] future_lapply() ...
[16:01:44.908] Number of chunks: 1
[16:01:44.908] getGlobalsAndPackagesXApply() ...
[16:01:44.908]  - future.globals: TRUE
[16:01:44.908] getGlobalsAndPackages() ...
[16:01:44.908] Searching for globals...
[16:01:44.910] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:44.910] Searching for globals ... DONE
[16:01:44.910] Resolving globals: FALSE
[16:01:44.910] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:01:44.911] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:01:44.911] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:44.911] - packages: [1] ‘stats’
[16:01:44.911] getGlobalsAndPackages() ... DONE
[16:01:44.911]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:44.911]  - needed namespaces: [n=1] ‘stats’
[16:01:44.911] Finding globals ... DONE
[16:01:44.912]  - use_args: TRUE
[16:01:44.912]  - Getting '...' globals ...
[16:01:44.912] resolve() on list ...
[16:01:44.912]  recursive: 0
[16:01:44.912]  length: 1
[16:01:44.912]  elements: ‘...’
[16:01:44.912]  length: 0 (resolved future 1)
[16:01:44.912] resolve() on list ... DONE
[16:01:44.913]    - '...' content: [n=0] 
[16:01:44.913] List of 1
[16:01:44.913]  $ ...: list()
[16:01:44.913]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.913]  - attr(*, "where")=List of 1
[16:01:44.913]   ..$ ...:<environment: 0x55b523a19d10> 
[16:01:44.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.913]  - attr(*, "resolved")= logi TRUE
[16:01:44.913]  - attr(*, "total_size")= num NA
[16:01:44.915]  - Getting '...' globals ... DONE
[16:01:44.915] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:01:44.915] List of 4
[16:01:44.915]  $ ...future.FUN:function (x)  
[16:01:44.915]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:44.915]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:44.915]  $ ...          : list()
[16:01:44.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.915]  - attr(*, "where")=List of 4
[16:01:44.915]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:44.915]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:01:44.915]   ..$ wool         :<environment: R_EmptyEnv> 
[16:01:44.915]   ..$ ...          :<environment: 0x55b523a19d10> 
[16:01:44.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.915]  - attr(*, "resolved")= logi FALSE
[16:01:44.915]  - attr(*, "total_size")= num 2320
[16:01:44.919] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:44.919] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.921] Number of futures (= number of chunks): 1
[16:01:44.921] Launching 1 futures (chunks) ...
[16:01:44.922] Chunk #1 of 1 ...
[16:01:44.922]  - Finding globals in 'X' for chunk #1 ...
[16:01:44.922] getGlobalsAndPackages() ...
[16:01:44.922] Searching for globals...
[16:01:44.922] 
[16:01:44.922] Searching for globals ... DONE
[16:01:44.923] - globals: [0] <none>
[16:01:44.923] getGlobalsAndPackages() ... DONE
[16:01:44.923]    + additional globals found: [n=0] 
[16:01:44.923]    + additional namespaces needed: [n=0] 
[16:01:44.923]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:44.923]  - seeds: <none>
[16:01:44.923]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.923] getGlobalsAndPackages() ...
[16:01:44.923] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.924] Resolving globals: FALSE
[16:01:44.924] Tweak future expression to call with '...' arguments ...
[16:01:44.924] {
[16:01:44.924]     do.call(function(...) {
[16:01:44.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.924]             on.exit(options(oopts), add = TRUE)
[16:01:44.924]         }
[16:01:44.924]         {
[16:01:44.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.924]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.924]             })
[16:01:44.924]         }
[16:01:44.924]     }, args = future.call.arguments)
[16:01:44.924] }
[16:01:44.924] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.924] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.925] 
[16:01:44.925] getGlobalsAndPackages() ... DONE
[16:01:44.925] run() for ‘Future’ ...
[16:01:44.925] - state: ‘created’
[16:01:44.925] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:44.925] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:44.926]   - Field: ‘label’
[16:01:44.926]   - Field: ‘local’
[16:01:44.926]   - Field: ‘owner’
[16:01:44.926]   - Field: ‘envir’
[16:01:44.926]   - Field: ‘packages’
[16:01:44.926]   - Field: ‘gc’
[16:01:44.926]   - Field: ‘conditions’
[16:01:44.926]   - Field: ‘expr’
[16:01:44.926]   - Field: ‘uuid’
[16:01:44.927]   - Field: ‘seed’
[16:01:44.927]   - Field: ‘version’
[16:01:44.927]   - Field: ‘result’
[16:01:44.927]   - Field: ‘asynchronous’
[16:01:44.927]   - Field: ‘calls’
[16:01:44.927]   - Field: ‘globals’
[16:01:44.927]   - Field: ‘stdout’
[16:01:44.927]   - Field: ‘earlySignal’
[16:01:44.927]   - Field: ‘lazy’
[16:01:44.927]   - Field: ‘state’
[16:01:44.928] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:44.928] - Launch lazy future ...
[16:01:44.928] Packages needed by the future expression (n = 1): ‘stats’
[16:01:44.928] Packages needed by future strategies (n = 0): <none>
[16:01:44.929] {
[16:01:44.929]     {
[16:01:44.929]         {
[16:01:44.929]             ...future.startTime <- base::Sys.time()
[16:01:44.929]             {
[16:01:44.929]                 {
[16:01:44.929]                   {
[16:01:44.929]                     {
[16:01:44.929]                       base::local({
[16:01:44.929]                         has_future <- base::requireNamespace("future", 
[16:01:44.929]                           quietly = TRUE)
[16:01:44.929]                         if (has_future) {
[16:01:44.929]                           ns <- base::getNamespace("future")
[16:01:44.929]                           version <- ns[[".package"]][["version"]]
[16:01:44.929]                           if (is.null(version)) 
[16:01:44.929]                             version <- utils::packageVersion("future")
[16:01:44.929]                         }
[16:01:44.929]                         else {
[16:01:44.929]                           version <- NULL
[16:01:44.929]                         }
[16:01:44.929]                         if (!has_future || version < "1.8.0") {
[16:01:44.929]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.929]                             "", base::R.version$version.string), 
[16:01:44.929]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:44.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.929]                               "release", "version")], collapse = " "), 
[16:01:44.929]                             hostname = base::Sys.info()[["nodename"]])
[16:01:44.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.929]                             info)
[16:01:44.929]                           info <- base::paste(info, collapse = "; ")
[16:01:44.929]                           if (!has_future) {
[16:01:44.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.929]                               info)
[16:01:44.929]                           }
[16:01:44.929]                           else {
[16:01:44.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.929]                               info, version)
[16:01:44.929]                           }
[16:01:44.929]                           base::stop(msg)
[16:01:44.929]                         }
[16:01:44.929]                       })
[16:01:44.929]                     }
[16:01:44.929]                     base::local({
[16:01:44.929]                       for (pkg in "stats") {
[16:01:44.929]                         base::loadNamespace(pkg)
[16:01:44.929]                         base::library(pkg, character.only = TRUE)
[16:01:44.929]                       }
[16:01:44.929]                     })
[16:01:44.929]                   }
[16:01:44.929]                   options(future.plan = NULL)
[16:01:44.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.929]                 }
[16:01:44.929]                 ...future.workdir <- getwd()
[16:01:44.929]             }
[16:01:44.929]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.929]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.929]         }
[16:01:44.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.929]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:44.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.929]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.929]             base::names(...future.oldOptions))
[16:01:44.929]     }
[16:01:44.929]     if (FALSE) {
[16:01:44.929]     }
[16:01:44.929]     else {
[16:01:44.929]         if (TRUE) {
[16:01:44.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.929]                 open = "w")
[16:01:44.929]         }
[16:01:44.929]         else {
[16:01:44.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.929]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.929]         }
[16:01:44.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.929]             base::sink(type = "output", split = FALSE)
[16:01:44.929]             base::close(...future.stdout)
[16:01:44.929]         }, add = TRUE)
[16:01:44.929]     }
[16:01:44.929]     ...future.frame <- base::sys.nframe()
[16:01:44.929]     ...future.conditions <- base::list()
[16:01:44.929]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.929]     if (FALSE) {
[16:01:44.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.929]     }
[16:01:44.929]     ...future.result <- base::tryCatch({
[16:01:44.929]         base::withCallingHandlers({
[16:01:44.929]             ...future.value <- base::withVisible(base::local({
[16:01:44.929]                 do.call(function(...) {
[16:01:44.929]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.929]                   if (!identical(...future.globals.maxSize.org, 
[16:01:44.929]                     ...future.globals.maxSize)) {
[16:01:44.929]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.929]                     on.exit(options(oopts), add = TRUE)
[16:01:44.929]                   }
[16:01:44.929]                   {
[16:01:44.929]                     lapply(seq_along(...future.elements_ii), 
[16:01:44.929]                       FUN = function(jj) {
[16:01:44.929]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.929]                         ...future.FUN(...future.X_jj, ...)
[16:01:44.929]                       })
[16:01:44.929]                   }
[16:01:44.929]                 }, args = future.call.arguments)
[16:01:44.929]             }))
[16:01:44.929]             future::FutureResult(value = ...future.value$value, 
[16:01:44.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.929]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.929]                     ...future.globalenv.names))
[16:01:44.929]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.929]         }, condition = base::local({
[16:01:44.929]             c <- base::c
[16:01:44.929]             inherits <- base::inherits
[16:01:44.929]             invokeRestart <- base::invokeRestart
[16:01:44.929]             length <- base::length
[16:01:44.929]             list <- base::list
[16:01:44.929]             seq.int <- base::seq.int
[16:01:44.929]             signalCondition <- base::signalCondition
[16:01:44.929]             sys.calls <- base::sys.calls
[16:01:44.929]             `[[` <- base::`[[`
[16:01:44.929]             `+` <- base::`+`
[16:01:44.929]             `<<-` <- base::`<<-`
[16:01:44.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.929]                   3L)]
[16:01:44.929]             }
[16:01:44.929]             function(cond) {
[16:01:44.929]                 is_error <- inherits(cond, "error")
[16:01:44.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.929]                   NULL)
[16:01:44.929]                 if (is_error) {
[16:01:44.929]                   sessionInformation <- function() {
[16:01:44.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.929]                       search = base::search(), system = base::Sys.info())
[16:01:44.929]                   }
[16:01:44.929]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.929]                     cond$call), session = sessionInformation(), 
[16:01:44.929]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.929]                   signalCondition(cond)
[16:01:44.929]                 }
[16:01:44.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.929]                 "immediateCondition"))) {
[16:01:44.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.929]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.929]                   if (TRUE && !signal) {
[16:01:44.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.929]                     {
[16:01:44.929]                       inherits <- base::inherits
[16:01:44.929]                       invokeRestart <- base::invokeRestart
[16:01:44.929]                       is.null <- base::is.null
[16:01:44.929]                       muffled <- FALSE
[16:01:44.929]                       if (inherits(cond, "message")) {
[16:01:44.929]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.929]                         if (muffled) 
[16:01:44.929]                           invokeRestart("muffleMessage")
[16:01:44.929]                       }
[16:01:44.929]                       else if (inherits(cond, "warning")) {
[16:01:44.929]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.929]                         if (muffled) 
[16:01:44.929]                           invokeRestart("muffleWarning")
[16:01:44.929]                       }
[16:01:44.929]                       else if (inherits(cond, "condition")) {
[16:01:44.929]                         if (!is.null(pattern)) {
[16:01:44.929]                           computeRestarts <- base::computeRestarts
[16:01:44.929]                           grepl <- base::grepl
[16:01:44.929]                           restarts <- computeRestarts(cond)
[16:01:44.929]                           for (restart in restarts) {
[16:01:44.929]                             name <- restart$name
[16:01:44.929]                             if (is.null(name)) 
[16:01:44.929]                               next
[16:01:44.929]                             if (!grepl(pattern, name)) 
[16:01:44.929]                               next
[16:01:44.929]                             invokeRestart(restart)
[16:01:44.929]                             muffled <- TRUE
[16:01:44.929]                             break
[16:01:44.929]                           }
[16:01:44.929]                         }
[16:01:44.929]                       }
[16:01:44.929]                       invisible(muffled)
[16:01:44.929]                     }
[16:01:44.929]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.929]                   }
[16:01:44.929]                 }
[16:01:44.929]                 else {
[16:01:44.929]                   if (TRUE) {
[16:01:44.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.929]                     {
[16:01:44.929]                       inherits <- base::inherits
[16:01:44.929]                       invokeRestart <- base::invokeRestart
[16:01:44.929]                       is.null <- base::is.null
[16:01:44.929]                       muffled <- FALSE
[16:01:44.929]                       if (inherits(cond, "message")) {
[16:01:44.929]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.929]                         if (muffled) 
[16:01:44.929]                           invokeRestart("muffleMessage")
[16:01:44.929]                       }
[16:01:44.929]                       else if (inherits(cond, "warning")) {
[16:01:44.929]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.929]                         if (muffled) 
[16:01:44.929]                           invokeRestart("muffleWarning")
[16:01:44.929]                       }
[16:01:44.929]                       else if (inherits(cond, "condition")) {
[16:01:44.929]                         if (!is.null(pattern)) {
[16:01:44.929]                           computeRestarts <- base::computeRestarts
[16:01:44.929]                           grepl <- base::grepl
[16:01:44.929]                           restarts <- computeRestarts(cond)
[16:01:44.929]                           for (restart in restarts) {
[16:01:44.929]                             name <- restart$name
[16:01:44.929]                             if (is.null(name)) 
[16:01:44.929]                               next
[16:01:44.929]                             if (!grepl(pattern, name)) 
[16:01:44.929]                               next
[16:01:44.929]                             invokeRestart(restart)
[16:01:44.929]                             muffled <- TRUE
[16:01:44.929]                             break
[16:01:44.929]                           }
[16:01:44.929]                         }
[16:01:44.929]                       }
[16:01:44.929]                       invisible(muffled)
[16:01:44.929]                     }
[16:01:44.929]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.929]                   }
[16:01:44.929]                 }
[16:01:44.929]             }
[16:01:44.929]         }))
[16:01:44.929]     }, error = function(ex) {
[16:01:44.929]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.929]                 ...future.rng), started = ...future.startTime, 
[16:01:44.929]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.929]             version = "1.8"), class = "FutureResult")
[16:01:44.929]     }, finally = {
[16:01:44.929]         if (!identical(...future.workdir, getwd())) 
[16:01:44.929]             setwd(...future.workdir)
[16:01:44.929]         {
[16:01:44.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.929]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.929]             }
[16:01:44.929]             base::options(...future.oldOptions)
[16:01:44.929]             if (.Platform$OS.type == "windows") {
[16:01:44.929]                 old_names <- names(...future.oldEnvVars)
[16:01:44.929]                 envs <- base::Sys.getenv()
[16:01:44.929]                 names <- names(envs)
[16:01:44.929]                 common <- intersect(names, old_names)
[16:01:44.929]                 added <- setdiff(names, old_names)
[16:01:44.929]                 removed <- setdiff(old_names, names)
[16:01:44.929]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.929]                   envs[common]]
[16:01:44.929]                 NAMES <- toupper(changed)
[16:01:44.929]                 args <- list()
[16:01:44.929]                 for (kk in seq_along(NAMES)) {
[16:01:44.929]                   name <- changed[[kk]]
[16:01:44.929]                   NAME <- NAMES[[kk]]
[16:01:44.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.929]                     next
[16:01:44.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.929]                 }
[16:01:44.929]                 NAMES <- toupper(added)
[16:01:44.929]                 for (kk in seq_along(NAMES)) {
[16:01:44.929]                   name <- added[[kk]]
[16:01:44.929]                   NAME <- NAMES[[kk]]
[16:01:44.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.929]                     next
[16:01:44.929]                   args[[name]] <- ""
[16:01:44.929]                 }
[16:01:44.929]                 NAMES <- toupper(removed)
[16:01:44.929]                 for (kk in seq_along(NAMES)) {
[16:01:44.929]                   name <- removed[[kk]]
[16:01:44.929]                   NAME <- NAMES[[kk]]
[16:01:44.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.929]                     next
[16:01:44.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.929]                 }
[16:01:44.929]                 if (length(args) > 0) 
[16:01:44.929]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.929]             }
[16:01:44.929]             else {
[16:01:44.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.929]             }
[16:01:44.929]             {
[16:01:44.929]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.929]                   0L) {
[16:01:44.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.929]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.929]                   base::options(opts)
[16:01:44.929]                 }
[16:01:44.929]                 {
[16:01:44.929]                   {
[16:01:44.929]                     NULL
[16:01:44.929]                     RNGkind("Mersenne-Twister")
[16:01:44.929]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:44.929]                       inherits = FALSE)
[16:01:44.929]                   }
[16:01:44.929]                   options(future.plan = NULL)
[16:01:44.929]                   if (is.na(NA_character_)) 
[16:01:44.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.929]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:44.929]                   {
[16:01:44.929]                     future <- SequentialFuture(..., envir = envir)
[16:01:44.929]                     if (!future$lazy) 
[16:01:44.929]                       future <- run(future)
[16:01:44.929]                     invisible(future)
[16:01:44.929]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.929]                 }
[16:01:44.929]             }
[16:01:44.929]         }
[16:01:44.929]     })
[16:01:44.929]     if (TRUE) {
[16:01:44.929]         base::sink(type = "output", split = FALSE)
[16:01:44.929]         if (TRUE) {
[16:01:44.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.929]         }
[16:01:44.929]         else {
[16:01:44.929]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.929]         }
[16:01:44.929]         base::close(...future.stdout)
[16:01:44.929]         ...future.stdout <- NULL
[16:01:44.929]     }
[16:01:44.929]     ...future.result$conditions <- ...future.conditions
[16:01:44.929]     ...future.result$finished <- base::Sys.time()
[16:01:44.929]     ...future.result
[16:01:44.929] }
[16:01:44.930] assign_globals() ...
[16:01:44.930] List of 7
[16:01:44.930]  $ ...future.FUN            :function (x)  
[16:01:44.930]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:44.930]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:44.930]  $ future.call.arguments    : list()
[16:01:44.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.930]  $ ...future.elements_ii    :List of 3
[16:01:44.930]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.930]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:44.930]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.930]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:44.930]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.930]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:44.930]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.930]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:44.930]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.930]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:44.930]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.930]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:44.930]  $ ...future.seeds_ii       : NULL
[16:01:44.930]  $ ...future.globals.maxSize: NULL
[16:01:44.930]  - attr(*, "where")=List of 7
[16:01:44.930]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:44.930]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:01:44.930]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:01:44.930]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:44.930]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:44.930]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:44.930]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:44.930]  - attr(*, "resolved")= logi FALSE
[16:01:44.930]  - attr(*, "total_size")= num 2320
[16:01:44.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.930]  - attr(*, "already-done")= logi TRUE
[16:01:44.940] - reassign environment for ‘...future.FUN’
[16:01:44.940] - copied ‘...future.FUN’ to environment
[16:01:44.940] - copied ‘breaks’ to environment
[16:01:44.940] - copied ‘wool’ to environment
[16:01:44.940] - copied ‘future.call.arguments’ to environment
[16:01:44.941] - copied ‘...future.elements_ii’ to environment
[16:01:44.941] - copied ‘...future.seeds_ii’ to environment
[16:01:44.941] - copied ‘...future.globals.maxSize’ to environment
[16:01:44.941] assign_globals() ... done
[16:01:44.941] plan(): Setting new future strategy stack:
[16:01:44.941] List of future strategies:
[16:01:44.941] 1. sequential:
[16:01:44.941]    - args: function (..., envir = parent.frame())
[16:01:44.941]    - tweaked: FALSE
[16:01:44.941]    - call: NULL
[16:01:44.942] plan(): nbrOfWorkers() = 1
[16:01:44.946] plan(): Setting new future strategy stack:
[16:01:44.946] List of future strategies:
[16:01:44.946] 1. sequential:
[16:01:44.946]    - args: function (..., envir = parent.frame())
[16:01:44.946]    - tweaked: FALSE
[16:01:44.946]    - call: plan(strategy)
[16:01:44.947] plan(): nbrOfWorkers() = 1
[16:01:44.947] SequentialFuture started (and completed)
[16:01:44.947] - Launch lazy future ... done
[16:01:44.947] run() for ‘SequentialFuture’ ... done
[16:01:44.947] Created future:
[16:01:44.947] SequentialFuture:
[16:01:44.947] Label: ‘future_by-1’
[16:01:44.947] Expression:
[16:01:44.947] {
[16:01:44.947]     do.call(function(...) {
[16:01:44.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.947]             on.exit(options(oopts), add = TRUE)
[16:01:44.947]         }
[16:01:44.947]         {
[16:01:44.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.947]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.947]             })
[16:01:44.947]         }
[16:01:44.947]     }, args = future.call.arguments)
[16:01:44.947] }
[16:01:44.947] Lazy evaluation: FALSE
[16:01:44.947] Asynchronous evaluation: FALSE
[16:01:44.947] Local evaluation: TRUE
[16:01:44.947] Environment: 0x55b523787ce8
[16:01:44.947] Capture standard output: TRUE
[16:01:44.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.947] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:01:44.947] Packages: 1 packages (‘stats’)
[16:01:44.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.947] Resolved: TRUE
[16:01:44.947] Value: 25.57 KiB of class ‘list’
[16:01:44.947] Early signaling: FALSE
[16:01:44.947] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:44.947] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.949] Chunk #1 of 1 ... DONE
[16:01:44.949] Launching 1 futures (chunks) ... DONE
[16:01:44.949] Resolving 1 futures (chunks) ...
[16:01:44.949] resolve() on list ...
[16:01:44.949]  recursive: 0
[16:01:44.949]  length: 1
[16:01:44.949] 
[16:01:44.950] resolved() for ‘SequentialFuture’ ...
[16:01:44.950] - state: ‘finished’
[16:01:44.950] - run: TRUE
[16:01:44.950] - result: ‘FutureResult’
[16:01:44.950] resolved() for ‘SequentialFuture’ ... done
[16:01:44.950] Future #1
[16:01:44.950] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:44.950] - nx: 1
[16:01:44.950] - relay: TRUE
[16:01:44.950] - stdout: TRUE
[16:01:44.951] - signal: TRUE
[16:01:44.951] - resignal: FALSE
[16:01:44.951] - force: TRUE
[16:01:44.951] - relayed: [n=1] FALSE
[16:01:44.951] - queued futures: [n=1] FALSE
[16:01:44.951]  - until=1
[16:01:44.951]  - relaying element #1
[16:01:44.951] - relayed: [n=1] TRUE
[16:01:44.951] - queued futures: [n=1] TRUE
[16:01:44.952] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:44.952]  length: 0 (resolved future 1)
[16:01:44.952] Relaying remaining futures
[16:01:44.952] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.952] - nx: 1
[16:01:44.952] - relay: TRUE
[16:01:44.952] - stdout: TRUE
[16:01:44.952] - signal: TRUE
[16:01:44.952] - resignal: FALSE
[16:01:44.952] - force: TRUE
[16:01:44.952] - relayed: [n=1] TRUE
[16:01:44.952] - queued futures: [n=1] TRUE
 - flush all
[16:01:44.953] - relayed: [n=1] TRUE
[16:01:44.953] - queued futures: [n=1] TRUE
[16:01:44.953] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.953] resolve() on list ... DONE
[16:01:44.953]  - Number of value chunks collected: 1
[16:01:44.953] Resolving 1 futures (chunks) ... DONE
[16:01:44.953] Reducing values from 1 chunks ...
[16:01:44.953]  - Number of values collected after concatenation: 3
[16:01:44.953]  - Number of values expected: 3
[16:01:44.953] Reducing values from 1 chunks ... DONE
[16:01:44.954] future_lapply() ... DONE
[16:01:44.954] future_by_internal() ... DONE
[16:01:44.954] future_by_internal() ...
[16:01:44.954] future_lapply() ...
[16:01:44.955] Number of chunks: 1
[16:01:44.955] getGlobalsAndPackagesXApply() ...
[16:01:44.955]  - future.globals: TRUE
[16:01:44.955] getGlobalsAndPackages() ...
[16:01:44.955] Searching for globals...
[16:01:44.956] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:44.956] Searching for globals ... DONE
[16:01:44.957] Resolving globals: FALSE
[16:01:44.957] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:44.957] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:44.957] - globals: [1] ‘FUN’
[16:01:44.958] 
[16:01:44.958] getGlobalsAndPackages() ... DONE
[16:01:44.958]  - globals found/used: [n=1] ‘FUN’
[16:01:44.958]  - needed namespaces: [n=0] 
[16:01:44.958] Finding globals ... DONE
[16:01:44.958]  - use_args: TRUE
[16:01:44.958]  - Getting '...' globals ...
[16:01:44.958] resolve() on list ...
[16:01:44.958]  recursive: 0
[16:01:44.959]  length: 1
[16:01:44.959]  elements: ‘...’
[16:01:44.959]  length: 0 (resolved future 1)
[16:01:44.959] resolve() on list ... DONE
[16:01:44.959]    - '...' content: [n=0] 
[16:01:44.959] List of 1
[16:01:44.959]  $ ...: list()
[16:01:44.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.959]  - attr(*, "where")=List of 1
[16:01:44.959]   ..$ ...:<environment: 0x55b525af1c48> 
[16:01:44.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.959]  - attr(*, "resolved")= logi TRUE
[16:01:44.959]  - attr(*, "total_size")= num NA
[16:01:44.962]  - Getting '...' globals ... DONE
[16:01:44.962] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:44.962] List of 2
[16:01:44.962]  $ ...future.FUN:function (object, ...)  
[16:01:44.962]  $ ...          : list()
[16:01:44.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.962]  - attr(*, "where")=List of 2
[16:01:44.962]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:44.962]   ..$ ...          :<environment: 0x55b525af1c48> 
[16:01:44.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.962]  - attr(*, "resolved")= logi FALSE
[16:01:44.962]  - attr(*, "total_size")= num 1240
[16:01:44.966] Packages to be attached in all futures: [n=0] 
[16:01:44.966] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.967] Number of futures (= number of chunks): 1
[16:01:44.967] Launching 1 futures (chunks) ...
[16:01:44.967] Chunk #1 of 1 ...
[16:01:44.967]  - Finding globals in 'X' for chunk #1 ...
[16:01:44.967] getGlobalsAndPackages() ...
[16:01:44.967] Searching for globals...
[16:01:44.968] 
[16:01:44.968] Searching for globals ... DONE
[16:01:44.968] - globals: [0] <none>
[16:01:44.968] getGlobalsAndPackages() ... DONE
[16:01:44.968]    + additional globals found: [n=0] 
[16:01:44.968]    + additional namespaces needed: [n=0] 
[16:01:44.968]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:44.968]  - seeds: <none>
[16:01:44.968]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.968] getGlobalsAndPackages() ...
[16:01:44.969] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.969] Resolving globals: FALSE
[16:01:44.969] Tweak future expression to call with '...' arguments ...
[16:01:44.969] {
[16:01:44.969]     do.call(function(...) {
[16:01:44.969]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.969]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.969]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.969]             on.exit(options(oopts), add = TRUE)
[16:01:44.969]         }
[16:01:44.969]         {
[16:01:44.969]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.969]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.969]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.969]             })
[16:01:44.969]         }
[16:01:44.969]     }, args = future.call.arguments)
[16:01:44.969] }
[16:01:44.969] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.970] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.970] 
[16:01:44.970] getGlobalsAndPackages() ... DONE
[16:01:44.970] run() for ‘Future’ ...
[16:01:44.970] - state: ‘created’
[16:01:44.970] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:44.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:44.971]   - Field: ‘label’
[16:01:44.971]   - Field: ‘local’
[16:01:44.971]   - Field: ‘owner’
[16:01:44.971]   - Field: ‘envir’
[16:01:44.971]   - Field: ‘packages’
[16:01:44.971]   - Field: ‘gc’
[16:01:44.971]   - Field: ‘conditions’
[16:01:44.972]   - Field: ‘expr’
[16:01:44.972]   - Field: ‘uuid’
[16:01:44.972]   - Field: ‘seed’
[16:01:44.972]   - Field: ‘version’
[16:01:44.972]   - Field: ‘result’
[16:01:44.972]   - Field: ‘asynchronous’
[16:01:44.972]   - Field: ‘calls’
[16:01:44.972]   - Field: ‘globals’
[16:01:44.972]   - Field: ‘stdout’
[16:01:44.972]   - Field: ‘earlySignal’
[16:01:44.972]   - Field: ‘lazy’
[16:01:44.973]   - Field: ‘state’
[16:01:44.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:44.973] - Launch lazy future ...
[16:01:44.973] Packages needed by the future expression (n = 0): <none>
[16:01:44.973] Packages needed by future strategies (n = 0): <none>
[16:01:44.974] {
[16:01:44.974]     {
[16:01:44.974]         {
[16:01:44.974]             ...future.startTime <- base::Sys.time()
[16:01:44.974]             {
[16:01:44.974]                 {
[16:01:44.974]                   {
[16:01:44.974]                     base::local({
[16:01:44.974]                       has_future <- base::requireNamespace("future", 
[16:01:44.974]                         quietly = TRUE)
[16:01:44.974]                       if (has_future) {
[16:01:44.974]                         ns <- base::getNamespace("future")
[16:01:44.974]                         version <- ns[[".package"]][["version"]]
[16:01:44.974]                         if (is.null(version)) 
[16:01:44.974]                           version <- utils::packageVersion("future")
[16:01:44.974]                       }
[16:01:44.974]                       else {
[16:01:44.974]                         version <- NULL
[16:01:44.974]                       }
[16:01:44.974]                       if (!has_future || version < "1.8.0") {
[16:01:44.974]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.974]                           "", base::R.version$version.string), 
[16:01:44.974]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:44.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.974]                             "release", "version")], collapse = " "), 
[16:01:44.974]                           hostname = base::Sys.info()[["nodename"]])
[16:01:44.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.974]                           info)
[16:01:44.974]                         info <- base::paste(info, collapse = "; ")
[16:01:44.974]                         if (!has_future) {
[16:01:44.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.974]                             info)
[16:01:44.974]                         }
[16:01:44.974]                         else {
[16:01:44.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.974]                             info, version)
[16:01:44.974]                         }
[16:01:44.974]                         base::stop(msg)
[16:01:44.974]                       }
[16:01:44.974]                     })
[16:01:44.974]                   }
[16:01:44.974]                   options(future.plan = NULL)
[16:01:44.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.974]                 }
[16:01:44.974]                 ...future.workdir <- getwd()
[16:01:44.974]             }
[16:01:44.974]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.974]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.974]         }
[16:01:44.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:44.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.974]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.974]             base::names(...future.oldOptions))
[16:01:44.974]     }
[16:01:44.974]     if (FALSE) {
[16:01:44.974]     }
[16:01:44.974]     else {
[16:01:44.974]         if (TRUE) {
[16:01:44.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.974]                 open = "w")
[16:01:44.974]         }
[16:01:44.974]         else {
[16:01:44.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.974]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.974]         }
[16:01:44.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.974]             base::sink(type = "output", split = FALSE)
[16:01:44.974]             base::close(...future.stdout)
[16:01:44.974]         }, add = TRUE)
[16:01:44.974]     }
[16:01:44.974]     ...future.frame <- base::sys.nframe()
[16:01:44.974]     ...future.conditions <- base::list()
[16:01:44.974]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.974]     if (FALSE) {
[16:01:44.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.974]     }
[16:01:44.974]     ...future.result <- base::tryCatch({
[16:01:44.974]         base::withCallingHandlers({
[16:01:44.974]             ...future.value <- base::withVisible(base::local({
[16:01:44.974]                 do.call(function(...) {
[16:01:44.974]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.974]                   if (!identical(...future.globals.maxSize.org, 
[16:01:44.974]                     ...future.globals.maxSize)) {
[16:01:44.974]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.974]                     on.exit(options(oopts), add = TRUE)
[16:01:44.974]                   }
[16:01:44.974]                   {
[16:01:44.974]                     lapply(seq_along(...future.elements_ii), 
[16:01:44.974]                       FUN = function(jj) {
[16:01:44.974]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.974]                         ...future.FUN(...future.X_jj, ...)
[16:01:44.974]                       })
[16:01:44.974]                   }
[16:01:44.974]                 }, args = future.call.arguments)
[16:01:44.974]             }))
[16:01:44.974]             future::FutureResult(value = ...future.value$value, 
[16:01:44.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.974]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.974]                     ...future.globalenv.names))
[16:01:44.974]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.974]         }, condition = base::local({
[16:01:44.974]             c <- base::c
[16:01:44.974]             inherits <- base::inherits
[16:01:44.974]             invokeRestart <- base::invokeRestart
[16:01:44.974]             length <- base::length
[16:01:44.974]             list <- base::list
[16:01:44.974]             seq.int <- base::seq.int
[16:01:44.974]             signalCondition <- base::signalCondition
[16:01:44.974]             sys.calls <- base::sys.calls
[16:01:44.974]             `[[` <- base::`[[`
[16:01:44.974]             `+` <- base::`+`
[16:01:44.974]             `<<-` <- base::`<<-`
[16:01:44.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.974]                   3L)]
[16:01:44.974]             }
[16:01:44.974]             function(cond) {
[16:01:44.974]                 is_error <- inherits(cond, "error")
[16:01:44.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.974]                   NULL)
[16:01:44.974]                 if (is_error) {
[16:01:44.974]                   sessionInformation <- function() {
[16:01:44.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.974]                       search = base::search(), system = base::Sys.info())
[16:01:44.974]                   }
[16:01:44.974]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.974]                     cond$call), session = sessionInformation(), 
[16:01:44.974]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.974]                   signalCondition(cond)
[16:01:44.974]                 }
[16:01:44.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.974]                 "immediateCondition"))) {
[16:01:44.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.974]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.974]                   if (TRUE && !signal) {
[16:01:44.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.974]                     {
[16:01:44.974]                       inherits <- base::inherits
[16:01:44.974]                       invokeRestart <- base::invokeRestart
[16:01:44.974]                       is.null <- base::is.null
[16:01:44.974]                       muffled <- FALSE
[16:01:44.974]                       if (inherits(cond, "message")) {
[16:01:44.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.974]                         if (muffled) 
[16:01:44.974]                           invokeRestart("muffleMessage")
[16:01:44.974]                       }
[16:01:44.974]                       else if (inherits(cond, "warning")) {
[16:01:44.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.974]                         if (muffled) 
[16:01:44.974]                           invokeRestart("muffleWarning")
[16:01:44.974]                       }
[16:01:44.974]                       else if (inherits(cond, "condition")) {
[16:01:44.974]                         if (!is.null(pattern)) {
[16:01:44.974]                           computeRestarts <- base::computeRestarts
[16:01:44.974]                           grepl <- base::grepl
[16:01:44.974]                           restarts <- computeRestarts(cond)
[16:01:44.974]                           for (restart in restarts) {
[16:01:44.974]                             name <- restart$name
[16:01:44.974]                             if (is.null(name)) 
[16:01:44.974]                               next
[16:01:44.974]                             if (!grepl(pattern, name)) 
[16:01:44.974]                               next
[16:01:44.974]                             invokeRestart(restart)
[16:01:44.974]                             muffled <- TRUE
[16:01:44.974]                             break
[16:01:44.974]                           }
[16:01:44.974]                         }
[16:01:44.974]                       }
[16:01:44.974]                       invisible(muffled)
[16:01:44.974]                     }
[16:01:44.974]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.974]                   }
[16:01:44.974]                 }
[16:01:44.974]                 else {
[16:01:44.974]                   if (TRUE) {
[16:01:44.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.974]                     {
[16:01:44.974]                       inherits <- base::inherits
[16:01:44.974]                       invokeRestart <- base::invokeRestart
[16:01:44.974]                       is.null <- base::is.null
[16:01:44.974]                       muffled <- FALSE
[16:01:44.974]                       if (inherits(cond, "message")) {
[16:01:44.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.974]                         if (muffled) 
[16:01:44.974]                           invokeRestart("muffleMessage")
[16:01:44.974]                       }
[16:01:44.974]                       else if (inherits(cond, "warning")) {
[16:01:44.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.974]                         if (muffled) 
[16:01:44.974]                           invokeRestart("muffleWarning")
[16:01:44.974]                       }
[16:01:44.974]                       else if (inherits(cond, "condition")) {
[16:01:44.974]                         if (!is.null(pattern)) {
[16:01:44.974]                           computeRestarts <- base::computeRestarts
[16:01:44.974]                           grepl <- base::grepl
[16:01:44.974]                           restarts <- computeRestarts(cond)
[16:01:44.974]                           for (restart in restarts) {
[16:01:44.974]                             name <- restart$name
[16:01:44.974]                             if (is.null(name)) 
[16:01:44.974]                               next
[16:01:44.974]                             if (!grepl(pattern, name)) 
[16:01:44.974]                               next
[16:01:44.974]                             invokeRestart(restart)
[16:01:44.974]                             muffled <- TRUE
[16:01:44.974]                             break
[16:01:44.974]                           }
[16:01:44.974]                         }
[16:01:44.974]                       }
[16:01:44.974]                       invisible(muffled)
[16:01:44.974]                     }
[16:01:44.974]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.974]                   }
[16:01:44.974]                 }
[16:01:44.974]             }
[16:01:44.974]         }))
[16:01:44.974]     }, error = function(ex) {
[16:01:44.974]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.974]                 ...future.rng), started = ...future.startTime, 
[16:01:44.974]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.974]             version = "1.8"), class = "FutureResult")
[16:01:44.974]     }, finally = {
[16:01:44.974]         if (!identical(...future.workdir, getwd())) 
[16:01:44.974]             setwd(...future.workdir)
[16:01:44.974]         {
[16:01:44.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.974]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.974]             }
[16:01:44.974]             base::options(...future.oldOptions)
[16:01:44.974]             if (.Platform$OS.type == "windows") {
[16:01:44.974]                 old_names <- names(...future.oldEnvVars)
[16:01:44.974]                 envs <- base::Sys.getenv()
[16:01:44.974]                 names <- names(envs)
[16:01:44.974]                 common <- intersect(names, old_names)
[16:01:44.974]                 added <- setdiff(names, old_names)
[16:01:44.974]                 removed <- setdiff(old_names, names)
[16:01:44.974]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.974]                   envs[common]]
[16:01:44.974]                 NAMES <- toupper(changed)
[16:01:44.974]                 args <- list()
[16:01:44.974]                 for (kk in seq_along(NAMES)) {
[16:01:44.974]                   name <- changed[[kk]]
[16:01:44.974]                   NAME <- NAMES[[kk]]
[16:01:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.974]                     next
[16:01:44.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.974]                 }
[16:01:44.974]                 NAMES <- toupper(added)
[16:01:44.974]                 for (kk in seq_along(NAMES)) {
[16:01:44.974]                   name <- added[[kk]]
[16:01:44.974]                   NAME <- NAMES[[kk]]
[16:01:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.974]                     next
[16:01:44.974]                   args[[name]] <- ""
[16:01:44.974]                 }
[16:01:44.974]                 NAMES <- toupper(removed)
[16:01:44.974]                 for (kk in seq_along(NAMES)) {
[16:01:44.974]                   name <- removed[[kk]]
[16:01:44.974]                   NAME <- NAMES[[kk]]
[16:01:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.974]                     next
[16:01:44.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.974]                 }
[16:01:44.974]                 if (length(args) > 0) 
[16:01:44.974]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.974]             }
[16:01:44.974]             else {
[16:01:44.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.974]             }
[16:01:44.974]             {
[16:01:44.974]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.974]                   0L) {
[16:01:44.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.974]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.974]                   base::options(opts)
[16:01:44.974]                 }
[16:01:44.974]                 {
[16:01:44.974]                   {
[16:01:44.974]                     NULL
[16:01:44.974]                     RNGkind("Mersenne-Twister")
[16:01:44.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:44.974]                       inherits = FALSE)
[16:01:44.974]                   }
[16:01:44.974]                   options(future.plan = NULL)
[16:01:44.974]                   if (is.na(NA_character_)) 
[16:01:44.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.974]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:44.974]                   {
[16:01:44.974]                     future <- SequentialFuture(..., envir = envir)
[16:01:44.974]                     if (!future$lazy) 
[16:01:44.974]                       future <- run(future)
[16:01:44.974]                     invisible(future)
[16:01:44.974]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.974]                 }
[16:01:44.974]             }
[16:01:44.974]         }
[16:01:44.974]     })
[16:01:44.974]     if (TRUE) {
[16:01:44.974]         base::sink(type = "output", split = FALSE)
[16:01:44.974]         if (TRUE) {
[16:01:44.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.974]         }
[16:01:44.974]         else {
[16:01:44.974]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.974]         }
[16:01:44.974]         base::close(...future.stdout)
[16:01:44.974]         ...future.stdout <- NULL
[16:01:44.974]     }
[16:01:44.974]     ...future.result$conditions <- ...future.conditions
[16:01:44.974]     ...future.result$finished <- base::Sys.time()
[16:01:44.974]     ...future.result
[16:01:44.974] }
[16:01:44.975] assign_globals() ...
[16:01:44.975] List of 5
[16:01:44.975]  $ ...future.FUN            :function (object, ...)  
[16:01:44.975]  $ future.call.arguments    : list()
[16:01:44.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.975]  $ ...future.elements_ii    :List of 3
[16:01:44.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.975]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:44.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:44.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.975]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:44.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:44.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:44.975]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:44.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:44.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:44.975]  $ ...future.seeds_ii       : NULL
[16:01:44.975]  $ ...future.globals.maxSize: NULL
[16:01:44.975]  - attr(*, "where")=List of 5
[16:01:44.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:44.975]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:44.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:44.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:44.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:44.975]  - attr(*, "resolved")= logi FALSE
[16:01:44.975]  - attr(*, "total_size")= num 1240
[16:01:44.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.975]  - attr(*, "already-done")= logi TRUE
[16:01:44.984] - copied ‘...future.FUN’ to environment
[16:01:44.984] - copied ‘future.call.arguments’ to environment
[16:01:44.984] - copied ‘...future.elements_ii’ to environment
[16:01:44.984] - copied ‘...future.seeds_ii’ to environment
[16:01:44.984] - copied ‘...future.globals.maxSize’ to environment
[16:01:44.984] assign_globals() ... done
[16:01:44.985] plan(): Setting new future strategy stack:
[16:01:44.985] List of future strategies:
[16:01:44.985] 1. sequential:
[16:01:44.985]    - args: function (..., envir = parent.frame())
[16:01:44.985]    - tweaked: FALSE
[16:01:44.985]    - call: NULL
[16:01:44.987] plan(): nbrOfWorkers() = 1
[16:01:44.989] plan(): Setting new future strategy stack:
[16:01:44.989] List of future strategies:
[16:01:44.989] 1. sequential:
[16:01:44.989]    - args: function (..., envir = parent.frame())
[16:01:44.989]    - tweaked: FALSE
[16:01:44.989]    - call: plan(strategy)
[16:01:44.990] plan(): nbrOfWorkers() = 1
[16:01:44.990] SequentialFuture started (and completed)
[16:01:44.990] - Launch lazy future ... done
[16:01:44.990] run() for ‘SequentialFuture’ ... done
[16:01:44.990] Created future:
[16:01:44.990] SequentialFuture:
[16:01:44.990] Label: ‘future_by-1’
[16:01:44.990] Expression:
[16:01:44.990] {
[16:01:44.990]     do.call(function(...) {
[16:01:44.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.990]             on.exit(options(oopts), add = TRUE)
[16:01:44.990]         }
[16:01:44.990]         {
[16:01:44.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.990]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.990]             })
[16:01:44.990]         }
[16:01:44.990]     }, args = future.call.arguments)
[16:01:44.990] }
[16:01:44.990] Lazy evaluation: FALSE
[16:01:44.990] Asynchronous evaluation: FALSE
[16:01:44.990] Local evaluation: TRUE
[16:01:44.990] Environment: 0x55b525aa93c8
[16:01:44.990] Capture standard output: TRUE
[16:01:44.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.990] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:44.990] Packages: <none>
[16:01:44.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.990] Resolved: TRUE
[16:01:44.990] Value: 5.37 KiB of class ‘list’
[16:01:44.990] Early signaling: FALSE
[16:01:44.990] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:44.990] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:44.991] Chunk #1 of 1 ... DONE
[16:01:44.992] Launching 1 futures (chunks) ... DONE
[16:01:44.992] Resolving 1 futures (chunks) ...
[16:01:44.992] resolve() on list ...
[16:01:44.992]  recursive: 0
[16:01:44.992]  length: 1
[16:01:44.992] 
[16:01:44.992] resolved() for ‘SequentialFuture’ ...
[16:01:44.992] - state: ‘finished’
[16:01:44.992] - run: TRUE
[16:01:44.992] - result: ‘FutureResult’
[16:01:44.993] resolved() for ‘SequentialFuture’ ... done
[16:01:44.993] Future #1
[16:01:44.993] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:44.993] - nx: 1
[16:01:44.993] - relay: TRUE
[16:01:44.993] - stdout: TRUE
[16:01:44.993] - signal: TRUE
[16:01:44.993] - resignal: FALSE
[16:01:44.993] - force: TRUE
[16:01:44.993] - relayed: [n=1] FALSE
[16:01:44.993] - queued futures: [n=1] FALSE
[16:01:44.994]  - until=1
[16:01:44.994]  - relaying element #1
[16:01:44.994] - relayed: [n=1] TRUE
[16:01:44.994] - queued futures: [n=1] TRUE
[16:01:44.994] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:44.994]  length: 0 (resolved future 1)
[16:01:44.994] Relaying remaining futures
[16:01:44.994] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.994] - nx: 1
[16:01:44.995] - relay: TRUE
[16:01:44.995] - stdout: TRUE
[16:01:44.995] - signal: TRUE
[16:01:44.995] - resignal: FALSE
[16:01:44.995] - force: TRUE
[16:01:44.995] - relayed: [n=1] TRUE
[16:01:44.995] - queued futures: [n=1] TRUE
 - flush all
[16:01:44.995] - relayed: [n=1] TRUE
[16:01:44.995] - queued futures: [n=1] TRUE
[16:01:44.995] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.996] resolve() on list ... DONE
[16:01:44.996]  - Number of value chunks collected: 1
[16:01:44.996] Resolving 1 futures (chunks) ... DONE
[16:01:44.996] Reducing values from 1 chunks ...
[16:01:44.996]  - Number of values collected after concatenation: 3
[16:01:44.996]  - Number of values expected: 3
[16:01:44.996] Reducing values from 1 chunks ... DONE
[16:01:44.996] future_lapply() ... DONE
[16:01:44.996] future_by_internal() ... DONE
[16:01:44.998] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:01:44.999] future_lapply() ...
[16:01:45.000] Number of chunks: 1
[16:01:45.000] getGlobalsAndPackagesXApply() ...
[16:01:45.000]  - future.globals: TRUE
[16:01:45.000] getGlobalsAndPackages() ...
[16:01:45.000] Searching for globals...
[16:01:45.001] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.001] Searching for globals ... DONE
[16:01:45.001] Resolving globals: FALSE
[16:01:45.002] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.002] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.002] - globals: [1] ‘FUN’
[16:01:45.002] 
[16:01:45.002] getGlobalsAndPackages() ... DONE
[16:01:45.002]  - globals found/used: [n=1] ‘FUN’
[16:01:45.002]  - needed namespaces: [n=0] 
[16:01:45.002] Finding globals ... DONE
[16:01:45.003]  - use_args: TRUE
[16:01:45.003]  - Getting '...' globals ...
[16:01:45.003] resolve() on list ...
[16:01:45.003]  recursive: 0
[16:01:45.003]  length: 1
[16:01:45.003]  elements: ‘...’
[16:01:45.003]  length: 0 (resolved future 1)
[16:01:45.003] resolve() on list ... DONE
[16:01:45.004]    - '...' content: [n=0] 
[16:01:45.004] List of 1
[16:01:45.004]  $ ...: list()
[16:01:45.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.004]  - attr(*, "where")=List of 1
[16:01:45.004]   ..$ ...:<environment: 0x55b525c61600> 
[16:01:45.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.004]  - attr(*, "resolved")= logi TRUE
[16:01:45.004]  - attr(*, "total_size")= num NA
[16:01:45.008]  - Getting '...' globals ... DONE
[16:01:45.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.008] List of 2
[16:01:45.008]  $ ...future.FUN:function (object, ...)  
[16:01:45.008]  $ ...          : list()
[16:01:45.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.008]  - attr(*, "where")=List of 2
[16:01:45.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.008]   ..$ ...          :<environment: 0x55b525c61600> 
[16:01:45.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.008]  - attr(*, "resolved")= logi FALSE
[16:01:45.008]  - attr(*, "total_size")= num 1240
[16:01:45.011] Packages to be attached in all futures: [n=0] 
[16:01:45.011] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.011] Number of futures (= number of chunks): 1
[16:01:45.011] Launching 1 futures (chunks) ...
[16:01:45.011] Chunk #1 of 1 ...
[16:01:45.012]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.012] getGlobalsAndPackages() ...
[16:01:45.012] Searching for globals...
[16:01:45.012] 
[16:01:45.012] Searching for globals ... DONE
[16:01:45.012] - globals: [0] <none>
[16:01:45.012] getGlobalsAndPackages() ... DONE
[16:01:45.013]    + additional globals found: [n=0] 
[16:01:45.013]    + additional namespaces needed: [n=0] 
[16:01:45.013]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.013]  - seeds: <none>
[16:01:45.013]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.013] getGlobalsAndPackages() ...
[16:01:45.013] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.013] Resolving globals: FALSE
[16:01:45.013] Tweak future expression to call with '...' arguments ...
[16:01:45.013] {
[16:01:45.013]     do.call(function(...) {
[16:01:45.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.013]             on.exit(options(oopts), add = TRUE)
[16:01:45.013]         }
[16:01:45.013]         {
[16:01:45.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.013]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.013]             })
[16:01:45.013]         }
[16:01:45.013]     }, args = future.call.arguments)
[16:01:45.013] }
[16:01:45.014] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.014] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.014] 
[16:01:45.014] getGlobalsAndPackages() ... DONE
[16:01:45.015] run() for ‘Future’ ...
[16:01:45.015] - state: ‘created’
[16:01:45.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:45.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.015]   - Field: ‘label’
[16:01:45.016]   - Field: ‘local’
[16:01:45.016]   - Field: ‘owner’
[16:01:45.016]   - Field: ‘envir’
[16:01:45.016]   - Field: ‘packages’
[16:01:45.016]   - Field: ‘gc’
[16:01:45.016]   - Field: ‘conditions’
[16:01:45.016]   - Field: ‘expr’
[16:01:45.016]   - Field: ‘uuid’
[16:01:45.016]   - Field: ‘seed’
[16:01:45.016]   - Field: ‘version’
[16:01:45.016]   - Field: ‘result’
[16:01:45.017]   - Field: ‘asynchronous’
[16:01:45.017]   - Field: ‘calls’
[16:01:45.017]   - Field: ‘globals’
[16:01:45.017]   - Field: ‘stdout’
[16:01:45.017]   - Field: ‘earlySignal’
[16:01:45.017]   - Field: ‘lazy’
[16:01:45.017]   - Field: ‘state’
[16:01:45.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.017] - Launch lazy future ...
[16:01:45.017] Packages needed by the future expression (n = 0): <none>
[16:01:45.018] Packages needed by future strategies (n = 0): <none>
[16:01:45.018] {
[16:01:45.018]     {
[16:01:45.018]         {
[16:01:45.018]             ...future.startTime <- base::Sys.time()
[16:01:45.018]             {
[16:01:45.018]                 {
[16:01:45.018]                   {
[16:01:45.018]                     base::local({
[16:01:45.018]                       has_future <- base::requireNamespace("future", 
[16:01:45.018]                         quietly = TRUE)
[16:01:45.018]                       if (has_future) {
[16:01:45.018]                         ns <- base::getNamespace("future")
[16:01:45.018]                         version <- ns[[".package"]][["version"]]
[16:01:45.018]                         if (is.null(version)) 
[16:01:45.018]                           version <- utils::packageVersion("future")
[16:01:45.018]                       }
[16:01:45.018]                       else {
[16:01:45.018]                         version <- NULL
[16:01:45.018]                       }
[16:01:45.018]                       if (!has_future || version < "1.8.0") {
[16:01:45.018]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.018]                           "", base::R.version$version.string), 
[16:01:45.018]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.018]                             "release", "version")], collapse = " "), 
[16:01:45.018]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.018]                           info)
[16:01:45.018]                         info <- base::paste(info, collapse = "; ")
[16:01:45.018]                         if (!has_future) {
[16:01:45.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.018]                             info)
[16:01:45.018]                         }
[16:01:45.018]                         else {
[16:01:45.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.018]                             info, version)
[16:01:45.018]                         }
[16:01:45.018]                         base::stop(msg)
[16:01:45.018]                       }
[16:01:45.018]                     })
[16:01:45.018]                   }
[16:01:45.018]                   options(future.plan = NULL)
[16:01:45.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.018]                 }
[16:01:45.018]                 ...future.workdir <- getwd()
[16:01:45.018]             }
[16:01:45.018]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.018]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.018]         }
[16:01:45.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.018]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.018]             base::names(...future.oldOptions))
[16:01:45.018]     }
[16:01:45.018]     if (FALSE) {
[16:01:45.018]     }
[16:01:45.018]     else {
[16:01:45.018]         if (TRUE) {
[16:01:45.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.018]                 open = "w")
[16:01:45.018]         }
[16:01:45.018]         else {
[16:01:45.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.018]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.018]         }
[16:01:45.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.018]             base::sink(type = "output", split = FALSE)
[16:01:45.018]             base::close(...future.stdout)
[16:01:45.018]         }, add = TRUE)
[16:01:45.018]     }
[16:01:45.018]     ...future.frame <- base::sys.nframe()
[16:01:45.018]     ...future.conditions <- base::list()
[16:01:45.018]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.018]     if (FALSE) {
[16:01:45.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.018]     }
[16:01:45.018]     ...future.result <- base::tryCatch({
[16:01:45.018]         base::withCallingHandlers({
[16:01:45.018]             ...future.value <- base::withVisible(base::local({
[16:01:45.018]                 do.call(function(...) {
[16:01:45.018]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.018]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.018]                     ...future.globals.maxSize)) {
[16:01:45.018]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.018]                     on.exit(options(oopts), add = TRUE)
[16:01:45.018]                   }
[16:01:45.018]                   {
[16:01:45.018]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.018]                       FUN = function(jj) {
[16:01:45.018]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.018]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.018]                       })
[16:01:45.018]                   }
[16:01:45.018]                 }, args = future.call.arguments)
[16:01:45.018]             }))
[16:01:45.018]             future::FutureResult(value = ...future.value$value, 
[16:01:45.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.018]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.018]                     ...future.globalenv.names))
[16:01:45.018]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.018]         }, condition = base::local({
[16:01:45.018]             c <- base::c
[16:01:45.018]             inherits <- base::inherits
[16:01:45.018]             invokeRestart <- base::invokeRestart
[16:01:45.018]             length <- base::length
[16:01:45.018]             list <- base::list
[16:01:45.018]             seq.int <- base::seq.int
[16:01:45.018]             signalCondition <- base::signalCondition
[16:01:45.018]             sys.calls <- base::sys.calls
[16:01:45.018]             `[[` <- base::`[[`
[16:01:45.018]             `+` <- base::`+`
[16:01:45.018]             `<<-` <- base::`<<-`
[16:01:45.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.018]                   3L)]
[16:01:45.018]             }
[16:01:45.018]             function(cond) {
[16:01:45.018]                 is_error <- inherits(cond, "error")
[16:01:45.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.018]                   NULL)
[16:01:45.018]                 if (is_error) {
[16:01:45.018]                   sessionInformation <- function() {
[16:01:45.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.018]                       search = base::search(), system = base::Sys.info())
[16:01:45.018]                   }
[16:01:45.018]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.018]                     cond$call), session = sessionInformation(), 
[16:01:45.018]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.018]                   signalCondition(cond)
[16:01:45.018]                 }
[16:01:45.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.018]                 "immediateCondition"))) {
[16:01:45.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.018]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.018]                   if (TRUE && !signal) {
[16:01:45.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.018]                     {
[16:01:45.018]                       inherits <- base::inherits
[16:01:45.018]                       invokeRestart <- base::invokeRestart
[16:01:45.018]                       is.null <- base::is.null
[16:01:45.018]                       muffled <- FALSE
[16:01:45.018]                       if (inherits(cond, "message")) {
[16:01:45.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.018]                         if (muffled) 
[16:01:45.018]                           invokeRestart("muffleMessage")
[16:01:45.018]                       }
[16:01:45.018]                       else if (inherits(cond, "warning")) {
[16:01:45.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.018]                         if (muffled) 
[16:01:45.018]                           invokeRestart("muffleWarning")
[16:01:45.018]                       }
[16:01:45.018]                       else if (inherits(cond, "condition")) {
[16:01:45.018]                         if (!is.null(pattern)) {
[16:01:45.018]                           computeRestarts <- base::computeRestarts
[16:01:45.018]                           grepl <- base::grepl
[16:01:45.018]                           restarts <- computeRestarts(cond)
[16:01:45.018]                           for (restart in restarts) {
[16:01:45.018]                             name <- restart$name
[16:01:45.018]                             if (is.null(name)) 
[16:01:45.018]                               next
[16:01:45.018]                             if (!grepl(pattern, name)) 
[16:01:45.018]                               next
[16:01:45.018]                             invokeRestart(restart)
[16:01:45.018]                             muffled <- TRUE
[16:01:45.018]                             break
[16:01:45.018]                           }
[16:01:45.018]                         }
[16:01:45.018]                       }
[16:01:45.018]                       invisible(muffled)
[16:01:45.018]                     }
[16:01:45.018]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.018]                   }
[16:01:45.018]                 }
[16:01:45.018]                 else {
[16:01:45.018]                   if (TRUE) {
[16:01:45.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.018]                     {
[16:01:45.018]                       inherits <- base::inherits
[16:01:45.018]                       invokeRestart <- base::invokeRestart
[16:01:45.018]                       is.null <- base::is.null
[16:01:45.018]                       muffled <- FALSE
[16:01:45.018]                       if (inherits(cond, "message")) {
[16:01:45.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.018]                         if (muffled) 
[16:01:45.018]                           invokeRestart("muffleMessage")
[16:01:45.018]                       }
[16:01:45.018]                       else if (inherits(cond, "warning")) {
[16:01:45.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.018]                         if (muffled) 
[16:01:45.018]                           invokeRestart("muffleWarning")
[16:01:45.018]                       }
[16:01:45.018]                       else if (inherits(cond, "condition")) {
[16:01:45.018]                         if (!is.null(pattern)) {
[16:01:45.018]                           computeRestarts <- base::computeRestarts
[16:01:45.018]                           grepl <- base::grepl
[16:01:45.018]                           restarts <- computeRestarts(cond)
[16:01:45.018]                           for (restart in restarts) {
[16:01:45.018]                             name <- restart$name
[16:01:45.018]                             if (is.null(name)) 
[16:01:45.018]                               next
[16:01:45.018]                             if (!grepl(pattern, name)) 
[16:01:45.018]                               next
[16:01:45.018]                             invokeRestart(restart)
[16:01:45.018]                             muffled <- TRUE
[16:01:45.018]                             break
[16:01:45.018]                           }
[16:01:45.018]                         }
[16:01:45.018]                       }
[16:01:45.018]                       invisible(muffled)
[16:01:45.018]                     }
[16:01:45.018]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.018]                   }
[16:01:45.018]                 }
[16:01:45.018]             }
[16:01:45.018]         }))
[16:01:45.018]     }, error = function(ex) {
[16:01:45.018]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.018]                 ...future.rng), started = ...future.startTime, 
[16:01:45.018]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.018]             version = "1.8"), class = "FutureResult")
[16:01:45.018]     }, finally = {
[16:01:45.018]         if (!identical(...future.workdir, getwd())) 
[16:01:45.018]             setwd(...future.workdir)
[16:01:45.018]         {
[16:01:45.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.018]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.018]             }
[16:01:45.018]             base::options(...future.oldOptions)
[16:01:45.018]             if (.Platform$OS.type == "windows") {
[16:01:45.018]                 old_names <- names(...future.oldEnvVars)
[16:01:45.018]                 envs <- base::Sys.getenv()
[16:01:45.018]                 names <- names(envs)
[16:01:45.018]                 common <- intersect(names, old_names)
[16:01:45.018]                 added <- setdiff(names, old_names)
[16:01:45.018]                 removed <- setdiff(old_names, names)
[16:01:45.018]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.018]                   envs[common]]
[16:01:45.018]                 NAMES <- toupper(changed)
[16:01:45.018]                 args <- list()
[16:01:45.018]                 for (kk in seq_along(NAMES)) {
[16:01:45.018]                   name <- changed[[kk]]
[16:01:45.018]                   NAME <- NAMES[[kk]]
[16:01:45.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.018]                     next
[16:01:45.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.018]                 }
[16:01:45.018]                 NAMES <- toupper(added)
[16:01:45.018]                 for (kk in seq_along(NAMES)) {
[16:01:45.018]                   name <- added[[kk]]
[16:01:45.018]                   NAME <- NAMES[[kk]]
[16:01:45.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.018]                     next
[16:01:45.018]                   args[[name]] <- ""
[16:01:45.018]                 }
[16:01:45.018]                 NAMES <- toupper(removed)
[16:01:45.018]                 for (kk in seq_along(NAMES)) {
[16:01:45.018]                   name <- removed[[kk]]
[16:01:45.018]                   NAME <- NAMES[[kk]]
[16:01:45.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.018]                     next
[16:01:45.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.018]                 }
[16:01:45.018]                 if (length(args) > 0) 
[16:01:45.018]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.018]             }
[16:01:45.018]             else {
[16:01:45.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.018]             }
[16:01:45.018]             {
[16:01:45.018]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.018]                   0L) {
[16:01:45.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.018]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.018]                   base::options(opts)
[16:01:45.018]                 }
[16:01:45.018]                 {
[16:01:45.018]                   {
[16:01:45.018]                     NULL
[16:01:45.018]                     RNGkind("Mersenne-Twister")
[16:01:45.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.018]                       inherits = FALSE)
[16:01:45.018]                   }
[16:01:45.018]                   options(future.plan = NULL)
[16:01:45.018]                   if (is.na(NA_character_)) 
[16:01:45.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.018]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:45.018]                   {
[16:01:45.018]                     future <- SequentialFuture(..., envir = envir)
[16:01:45.018]                     if (!future$lazy) 
[16:01:45.018]                       future <- run(future)
[16:01:45.018]                     invisible(future)
[16:01:45.018]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.018]                 }
[16:01:45.018]             }
[16:01:45.018]         }
[16:01:45.018]     })
[16:01:45.018]     if (TRUE) {
[16:01:45.018]         base::sink(type = "output", split = FALSE)
[16:01:45.018]         if (TRUE) {
[16:01:45.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.018]         }
[16:01:45.018]         else {
[16:01:45.018]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.018]         }
[16:01:45.018]         base::close(...future.stdout)
[16:01:45.018]         ...future.stdout <- NULL
[16:01:45.018]     }
[16:01:45.018]     ...future.result$conditions <- ...future.conditions
[16:01:45.018]     ...future.result$finished <- base::Sys.time()
[16:01:45.018]     ...future.result
[16:01:45.018] }
[16:01:45.020] assign_globals() ...
[16:01:45.020] List of 5
[16:01:45.020]  $ ...future.FUN            :function (object, ...)  
[16:01:45.020]  $ future.call.arguments    : list()
[16:01:45.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.020]  $ ...future.elements_ii    :List of 3
[16:01:45.020]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.020]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.020]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.020]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.020]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.020]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.020]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.020]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.020]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.020]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.020]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.020]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.020]  $ ...future.seeds_ii       : NULL
[16:01:45.020]  $ ...future.globals.maxSize: NULL
[16:01:45.020]  - attr(*, "where")=List of 5
[16:01:45.020]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.020]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.020]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.020]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.020]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.020]  - attr(*, "resolved")= logi FALSE
[16:01:45.020]  - attr(*, "total_size")= num 1240
[16:01:45.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.020]  - attr(*, "already-done")= logi TRUE
[16:01:45.030] - copied ‘...future.FUN’ to environment
[16:01:45.030] - copied ‘future.call.arguments’ to environment
[16:01:45.030] - copied ‘...future.elements_ii’ to environment
[16:01:45.031] - copied ‘...future.seeds_ii’ to environment
[16:01:45.031] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.031] assign_globals() ... done
[16:01:45.031] plan(): Setting new future strategy stack:
[16:01:45.031] List of future strategies:
[16:01:45.031] 1. sequential:
[16:01:45.031]    - args: function (..., envir = parent.frame())
[16:01:45.031]    - tweaked: FALSE
[16:01:45.031]    - call: NULL
[16:01:45.032] plan(): nbrOfWorkers() = 1
[16:01:45.034] plan(): Setting new future strategy stack:
[16:01:45.034] List of future strategies:
[16:01:45.034] 1. sequential:
[16:01:45.034]    - args: function (..., envir = parent.frame())
[16:01:45.034]    - tweaked: FALSE
[16:01:45.034]    - call: plan(strategy)
[16:01:45.034] plan(): nbrOfWorkers() = 1
[16:01:45.034] SequentialFuture started (and completed)
[16:01:45.035] - Launch lazy future ... done
[16:01:45.035] run() for ‘SequentialFuture’ ... done
[16:01:45.035] Created future:
[16:01:45.035] SequentialFuture:
[16:01:45.035] Label: ‘future_by-1’
[16:01:45.035] Expression:
[16:01:45.035] {
[16:01:45.035]     do.call(function(...) {
[16:01:45.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.035]             on.exit(options(oopts), add = TRUE)
[16:01:45.035]         }
[16:01:45.035]         {
[16:01:45.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.035]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.035]             })
[16:01:45.035]         }
[16:01:45.035]     }, args = future.call.arguments)
[16:01:45.035] }
[16:01:45.035] Lazy evaluation: FALSE
[16:01:45.035] Asynchronous evaluation: FALSE
[16:01:45.035] Local evaluation: TRUE
[16:01:45.035] Environment: 0x55b525aa9b48
[16:01:45.035] Capture standard output: TRUE
[16:01:45.035] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.035] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.035] Packages: <none>
[16:01:45.035] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.035] Resolved: TRUE
[16:01:45.035] Value: 5.37 KiB of class ‘list’
[16:01:45.035] Early signaling: FALSE
[16:01:45.035] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.035] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.036] Chunk #1 of 1 ... DONE
[16:01:45.036] Launching 1 futures (chunks) ... DONE
[16:01:45.036] Resolving 1 futures (chunks) ...
[16:01:45.037] resolve() on list ...
[16:01:45.037]  recursive: 0
[16:01:45.037]  length: 1
[16:01:45.037] 
[16:01:45.037] resolved() for ‘SequentialFuture’ ...
[16:01:45.037] - state: ‘finished’
[16:01:45.037] - run: TRUE
[16:01:45.037] - result: ‘FutureResult’
[16:01:45.037] resolved() for ‘SequentialFuture’ ... done
[16:01:45.037] Future #1
[16:01:45.038] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.038] - nx: 1
[16:01:45.038] - relay: TRUE
[16:01:45.038] - stdout: TRUE
[16:01:45.038] - signal: TRUE
[16:01:45.038] - resignal: FALSE
[16:01:45.038] - force: TRUE
[16:01:45.038] - relayed: [n=1] FALSE
[16:01:45.038] - queued futures: [n=1] FALSE
[16:01:45.038]  - until=1
[16:01:45.038]  - relaying element #1
[16:01:45.039] - relayed: [n=1] TRUE
[16:01:45.039] - queued futures: [n=1] TRUE
[16:01:45.039] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.039]  length: 0 (resolved future 1)
[16:01:45.039] Relaying remaining futures
[16:01:45.039] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.039] - nx: 1
[16:01:45.039] - relay: TRUE
[16:01:45.039] - stdout: TRUE
[16:01:45.039] - signal: TRUE
[16:01:45.040] - resignal: FALSE
[16:01:45.040] - force: TRUE
[16:01:45.040] - relayed: [n=1] TRUE
[16:01:45.040] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.040] - relayed: [n=1] TRUE
[16:01:45.040] - queued futures: [n=1] TRUE
[16:01:45.040] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.040] resolve() on list ... DONE
[16:01:45.040]  - Number of value chunks collected: 1
[16:01:45.040] Resolving 1 futures (chunks) ... DONE
[16:01:45.040] Reducing values from 1 chunks ...
[16:01:45.041]  - Number of values collected after concatenation: 3
[16:01:45.041]  - Number of values expected: 3
[16:01:45.041] Reducing values from 1 chunks ... DONE
[16:01:45.041] future_lapply() ... DONE
[16:01:45.041] future_by_internal() ... DONE
[16:01:45.042] future_by_internal() ...
- plan('multicore') ...
[16:01:45.042] plan(): Setting new future strategy stack:
[16:01:45.042] List of future strategies:
[16:01:45.042] 1. multicore:
[16:01:45.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.042]    - tweaked: FALSE
[16:01:45.042]    - call: plan(strategy)
[16:01:45.046] plan(): nbrOfWorkers() = 1
[16:01:45.047] future_by_internal() ...
[16:01:45.047] future_lapply() ...
[16:01:45.051] Number of chunks: 1
[16:01:45.051] getGlobalsAndPackagesXApply() ...
[16:01:45.051]  - future.globals: TRUE
[16:01:45.051] getGlobalsAndPackages() ...
[16:01:45.051] Searching for globals...
[16:01:45.052] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.052] Searching for globals ... DONE
[16:01:45.052] Resolving globals: FALSE
[16:01:45.053] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.053] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.053] - globals: [1] ‘FUN’
[16:01:45.053] 
[16:01:45.053] getGlobalsAndPackages() ... DONE
[16:01:45.053]  - globals found/used: [n=1] ‘FUN’
[16:01:45.055]  - needed namespaces: [n=0] 
[16:01:45.055] Finding globals ... DONE
[16:01:45.056]  - use_args: TRUE
[16:01:45.056]  - Getting '...' globals ...
[16:01:45.056] resolve() on list ...
[16:01:45.056]  recursive: 0
[16:01:45.056]  length: 1
[16:01:45.056]  elements: ‘...’
[16:01:45.056]  length: 0 (resolved future 1)
[16:01:45.056] resolve() on list ... DONE
[16:01:45.057]    - '...' content: [n=0] 
[16:01:45.057] List of 1
[16:01:45.057]  $ ...: list()
[16:01:45.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.057]  - attr(*, "where")=List of 1
[16:01:45.057]   ..$ ...:<environment: 0x55b525de1178> 
[16:01:45.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.057]  - attr(*, "resolved")= logi TRUE
[16:01:45.057]  - attr(*, "total_size")= num NA
[16:01:45.059]  - Getting '...' globals ... DONE
[16:01:45.059] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.060] List of 2
[16:01:45.060]  $ ...future.FUN:function (object, ...)  
[16:01:45.060]  $ ...          : list()
[16:01:45.060]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.060]  - attr(*, "where")=List of 2
[16:01:45.060]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.060]   ..$ ...          :<environment: 0x55b525de1178> 
[16:01:45.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.060]  - attr(*, "resolved")= logi FALSE
[16:01:45.060]  - attr(*, "total_size")= num 1240
[16:01:45.062] Packages to be attached in all futures: [n=0] 
[16:01:45.062] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.063] Number of futures (= number of chunks): 1
[16:01:45.063] Launching 1 futures (chunks) ...
[16:01:45.063] Chunk #1 of 1 ...
[16:01:45.063]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.063] getGlobalsAndPackages() ...
[16:01:45.063] Searching for globals...
[16:01:45.064] 
[16:01:45.064] Searching for globals ... DONE
[16:01:45.064] - globals: [0] <none>
[16:01:45.064] getGlobalsAndPackages() ... DONE
[16:01:45.064]    + additional globals found: [n=0] 
[16:01:45.064]    + additional namespaces needed: [n=0] 
[16:01:45.064]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.064]  - seeds: <none>
[16:01:45.064]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.064] getGlobalsAndPackages() ...
[16:01:45.065] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.065] Resolving globals: FALSE
[16:01:45.065] Tweak future expression to call with '...' arguments ...
[16:01:45.065] {
[16:01:45.065]     do.call(function(...) {
[16:01:45.065]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.065]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.065]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.065]             on.exit(options(oopts), add = TRUE)
[16:01:45.065]         }
[16:01:45.065]         {
[16:01:45.065]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.065]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.065]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.065]             })
[16:01:45.065]         }
[16:01:45.065]     }, args = future.call.arguments)
[16:01:45.065] }
[16:01:45.065] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.065] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.066] 
[16:01:45.066] getGlobalsAndPackages() ... DONE
[16:01:45.066] run() for ‘Future’ ...
[16:01:45.066] - state: ‘created’
[16:01:45.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.070] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.070]   - Field: ‘label’
[16:01:45.071]   - Field: ‘local’
[16:01:45.071]   - Field: ‘owner’
[16:01:45.071]   - Field: ‘envir’
[16:01:45.071]   - Field: ‘packages’
[16:01:45.071]   - Field: ‘gc’
[16:01:45.071]   - Field: ‘conditions’
[16:01:45.071]   - Field: ‘expr’
[16:01:45.071]   - Field: ‘uuid’
[16:01:45.072]   - Field: ‘seed’
[16:01:45.072]   - Field: ‘version’
[16:01:45.072]   - Field: ‘result’
[16:01:45.072]   - Field: ‘asynchronous’
[16:01:45.072]   - Field: ‘calls’
[16:01:45.072]   - Field: ‘globals’
[16:01:45.072]   - Field: ‘stdout’
[16:01:45.072]   - Field: ‘earlySignal’
[16:01:45.072]   - Field: ‘lazy’
[16:01:45.072]   - Field: ‘state’
[16:01:45.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.073] - Launch lazy future ...
[16:01:45.073] Packages needed by the future expression (n = 0): <none>
[16:01:45.073] Packages needed by future strategies (n = 0): <none>
[16:01:45.073] {
[16:01:45.073]     {
[16:01:45.073]         {
[16:01:45.073]             ...future.startTime <- base::Sys.time()
[16:01:45.073]             {
[16:01:45.073]                 {
[16:01:45.073]                   {
[16:01:45.073]                     base::local({
[16:01:45.073]                       has_future <- base::requireNamespace("future", 
[16:01:45.073]                         quietly = TRUE)
[16:01:45.073]                       if (has_future) {
[16:01:45.073]                         ns <- base::getNamespace("future")
[16:01:45.073]                         version <- ns[[".package"]][["version"]]
[16:01:45.073]                         if (is.null(version)) 
[16:01:45.073]                           version <- utils::packageVersion("future")
[16:01:45.073]                       }
[16:01:45.073]                       else {
[16:01:45.073]                         version <- NULL
[16:01:45.073]                       }
[16:01:45.073]                       if (!has_future || version < "1.8.0") {
[16:01:45.073]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.073]                           "", base::R.version$version.string), 
[16:01:45.073]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.073]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.073]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.073]                             "release", "version")], collapse = " "), 
[16:01:45.073]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.073]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.073]                           info)
[16:01:45.073]                         info <- base::paste(info, collapse = "; ")
[16:01:45.073]                         if (!has_future) {
[16:01:45.073]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.073]                             info)
[16:01:45.073]                         }
[16:01:45.073]                         else {
[16:01:45.073]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.073]                             info, version)
[16:01:45.073]                         }
[16:01:45.073]                         base::stop(msg)
[16:01:45.073]                       }
[16:01:45.073]                     })
[16:01:45.073]                   }
[16:01:45.073]                   options(future.plan = NULL)
[16:01:45.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.073]                 }
[16:01:45.073]                 ...future.workdir <- getwd()
[16:01:45.073]             }
[16:01:45.073]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.073]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.073]         }
[16:01:45.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.073]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.073]             base::names(...future.oldOptions))
[16:01:45.073]     }
[16:01:45.073]     if (FALSE) {
[16:01:45.073]     }
[16:01:45.073]     else {
[16:01:45.073]         if (TRUE) {
[16:01:45.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.073]                 open = "w")
[16:01:45.073]         }
[16:01:45.073]         else {
[16:01:45.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.073]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.073]         }
[16:01:45.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.073]             base::sink(type = "output", split = FALSE)
[16:01:45.073]             base::close(...future.stdout)
[16:01:45.073]         }, add = TRUE)
[16:01:45.073]     }
[16:01:45.073]     ...future.frame <- base::sys.nframe()
[16:01:45.073]     ...future.conditions <- base::list()
[16:01:45.073]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.073]     if (FALSE) {
[16:01:45.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.073]     }
[16:01:45.073]     ...future.result <- base::tryCatch({
[16:01:45.073]         base::withCallingHandlers({
[16:01:45.073]             ...future.value <- base::withVisible(base::local({
[16:01:45.073]                 do.call(function(...) {
[16:01:45.073]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.073]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.073]                     ...future.globals.maxSize)) {
[16:01:45.073]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.073]                     on.exit(options(oopts), add = TRUE)
[16:01:45.073]                   }
[16:01:45.073]                   {
[16:01:45.073]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.073]                       FUN = function(jj) {
[16:01:45.073]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.073]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.073]                       })
[16:01:45.073]                   }
[16:01:45.073]                 }, args = future.call.arguments)
[16:01:45.073]             }))
[16:01:45.073]             future::FutureResult(value = ...future.value$value, 
[16:01:45.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.073]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.073]                     ...future.globalenv.names))
[16:01:45.073]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.073]         }, condition = base::local({
[16:01:45.073]             c <- base::c
[16:01:45.073]             inherits <- base::inherits
[16:01:45.073]             invokeRestart <- base::invokeRestart
[16:01:45.073]             length <- base::length
[16:01:45.073]             list <- base::list
[16:01:45.073]             seq.int <- base::seq.int
[16:01:45.073]             signalCondition <- base::signalCondition
[16:01:45.073]             sys.calls <- base::sys.calls
[16:01:45.073]             `[[` <- base::`[[`
[16:01:45.073]             `+` <- base::`+`
[16:01:45.073]             `<<-` <- base::`<<-`
[16:01:45.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.073]                   3L)]
[16:01:45.073]             }
[16:01:45.073]             function(cond) {
[16:01:45.073]                 is_error <- inherits(cond, "error")
[16:01:45.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.073]                   NULL)
[16:01:45.073]                 if (is_error) {
[16:01:45.073]                   sessionInformation <- function() {
[16:01:45.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.073]                       search = base::search(), system = base::Sys.info())
[16:01:45.073]                   }
[16:01:45.073]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.073]                     cond$call), session = sessionInformation(), 
[16:01:45.073]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.073]                   signalCondition(cond)
[16:01:45.073]                 }
[16:01:45.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.073]                 "immediateCondition"))) {
[16:01:45.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.073]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.073]                   if (TRUE && !signal) {
[16:01:45.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.073]                     {
[16:01:45.073]                       inherits <- base::inherits
[16:01:45.073]                       invokeRestart <- base::invokeRestart
[16:01:45.073]                       is.null <- base::is.null
[16:01:45.073]                       muffled <- FALSE
[16:01:45.073]                       if (inherits(cond, "message")) {
[16:01:45.073]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.073]                         if (muffled) 
[16:01:45.073]                           invokeRestart("muffleMessage")
[16:01:45.073]                       }
[16:01:45.073]                       else if (inherits(cond, "warning")) {
[16:01:45.073]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.073]                         if (muffled) 
[16:01:45.073]                           invokeRestart("muffleWarning")
[16:01:45.073]                       }
[16:01:45.073]                       else if (inherits(cond, "condition")) {
[16:01:45.073]                         if (!is.null(pattern)) {
[16:01:45.073]                           computeRestarts <- base::computeRestarts
[16:01:45.073]                           grepl <- base::grepl
[16:01:45.073]                           restarts <- computeRestarts(cond)
[16:01:45.073]                           for (restart in restarts) {
[16:01:45.073]                             name <- restart$name
[16:01:45.073]                             if (is.null(name)) 
[16:01:45.073]                               next
[16:01:45.073]                             if (!grepl(pattern, name)) 
[16:01:45.073]                               next
[16:01:45.073]                             invokeRestart(restart)
[16:01:45.073]                             muffled <- TRUE
[16:01:45.073]                             break
[16:01:45.073]                           }
[16:01:45.073]                         }
[16:01:45.073]                       }
[16:01:45.073]                       invisible(muffled)
[16:01:45.073]                     }
[16:01:45.073]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.073]                   }
[16:01:45.073]                 }
[16:01:45.073]                 else {
[16:01:45.073]                   if (TRUE) {
[16:01:45.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.073]                     {
[16:01:45.073]                       inherits <- base::inherits
[16:01:45.073]                       invokeRestart <- base::invokeRestart
[16:01:45.073]                       is.null <- base::is.null
[16:01:45.073]                       muffled <- FALSE
[16:01:45.073]                       if (inherits(cond, "message")) {
[16:01:45.073]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.073]                         if (muffled) 
[16:01:45.073]                           invokeRestart("muffleMessage")
[16:01:45.073]                       }
[16:01:45.073]                       else if (inherits(cond, "warning")) {
[16:01:45.073]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.073]                         if (muffled) 
[16:01:45.073]                           invokeRestart("muffleWarning")
[16:01:45.073]                       }
[16:01:45.073]                       else if (inherits(cond, "condition")) {
[16:01:45.073]                         if (!is.null(pattern)) {
[16:01:45.073]                           computeRestarts <- base::computeRestarts
[16:01:45.073]                           grepl <- base::grepl
[16:01:45.073]                           restarts <- computeRestarts(cond)
[16:01:45.073]                           for (restart in restarts) {
[16:01:45.073]                             name <- restart$name
[16:01:45.073]                             if (is.null(name)) 
[16:01:45.073]                               next
[16:01:45.073]                             if (!grepl(pattern, name)) 
[16:01:45.073]                               next
[16:01:45.073]                             invokeRestart(restart)
[16:01:45.073]                             muffled <- TRUE
[16:01:45.073]                             break
[16:01:45.073]                           }
[16:01:45.073]                         }
[16:01:45.073]                       }
[16:01:45.073]                       invisible(muffled)
[16:01:45.073]                     }
[16:01:45.073]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.073]                   }
[16:01:45.073]                 }
[16:01:45.073]             }
[16:01:45.073]         }))
[16:01:45.073]     }, error = function(ex) {
[16:01:45.073]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.073]                 ...future.rng), started = ...future.startTime, 
[16:01:45.073]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.073]             version = "1.8"), class = "FutureResult")
[16:01:45.073]     }, finally = {
[16:01:45.073]         if (!identical(...future.workdir, getwd())) 
[16:01:45.073]             setwd(...future.workdir)
[16:01:45.073]         {
[16:01:45.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.073]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.073]             }
[16:01:45.073]             base::options(...future.oldOptions)
[16:01:45.073]             if (.Platform$OS.type == "windows") {
[16:01:45.073]                 old_names <- names(...future.oldEnvVars)
[16:01:45.073]                 envs <- base::Sys.getenv()
[16:01:45.073]                 names <- names(envs)
[16:01:45.073]                 common <- intersect(names, old_names)
[16:01:45.073]                 added <- setdiff(names, old_names)
[16:01:45.073]                 removed <- setdiff(old_names, names)
[16:01:45.073]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.073]                   envs[common]]
[16:01:45.073]                 NAMES <- toupper(changed)
[16:01:45.073]                 args <- list()
[16:01:45.073]                 for (kk in seq_along(NAMES)) {
[16:01:45.073]                   name <- changed[[kk]]
[16:01:45.073]                   NAME <- NAMES[[kk]]
[16:01:45.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.073]                     next
[16:01:45.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.073]                 }
[16:01:45.073]                 NAMES <- toupper(added)
[16:01:45.073]                 for (kk in seq_along(NAMES)) {
[16:01:45.073]                   name <- added[[kk]]
[16:01:45.073]                   NAME <- NAMES[[kk]]
[16:01:45.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.073]                     next
[16:01:45.073]                   args[[name]] <- ""
[16:01:45.073]                 }
[16:01:45.073]                 NAMES <- toupper(removed)
[16:01:45.073]                 for (kk in seq_along(NAMES)) {
[16:01:45.073]                   name <- removed[[kk]]
[16:01:45.073]                   NAME <- NAMES[[kk]]
[16:01:45.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.073]                     next
[16:01:45.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.073]                 }
[16:01:45.073]                 if (length(args) > 0) 
[16:01:45.073]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.073]             }
[16:01:45.073]             else {
[16:01:45.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.073]             }
[16:01:45.073]             {
[16:01:45.073]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.073]                   0L) {
[16:01:45.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.073]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.073]                   base::options(opts)
[16:01:45.073]                 }
[16:01:45.073]                 {
[16:01:45.073]                   {
[16:01:45.073]                     NULL
[16:01:45.073]                     RNGkind("Mersenne-Twister")
[16:01:45.073]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.073]                       inherits = FALSE)
[16:01:45.073]                   }
[16:01:45.073]                   options(future.plan = NULL)
[16:01:45.073]                   if (is.na(NA_character_)) 
[16:01:45.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.073]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:45.073]                     envir = parent.frame()) 
[16:01:45.073]                   {
[16:01:45.073]                     default_workers <- missing(workers)
[16:01:45.073]                     if (is.function(workers)) 
[16:01:45.073]                       workers <- workers()
[16:01:45.073]                     workers <- structure(as.integer(workers), 
[16:01:45.073]                       class = class(workers))
[16:01:45.073]                     stop_if_not(is.finite(workers), workers >= 
[16:01:45.073]                       1L)
[16:01:45.073]                     if ((workers == 1L && !inherits(workers, 
[16:01:45.073]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:45.073]                       if (default_workers) 
[16:01:45.073]                         supportsMulticore(warn = TRUE)
[16:01:45.073]                       return(sequential(..., envir = envir))
[16:01:45.073]                     }
[16:01:45.073]                     oopts <- options(mc.cores = workers)
[16:01:45.073]                     on.exit(options(oopts))
[16:01:45.073]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:45.073]                       envir = envir)
[16:01:45.073]                     if (!future$lazy) 
[16:01:45.073]                       future <- run(future)
[16:01:45.073]                     invisible(future)
[16:01:45.073]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.073]                 }
[16:01:45.073]             }
[16:01:45.073]         }
[16:01:45.073]     })
[16:01:45.073]     if (TRUE) {
[16:01:45.073]         base::sink(type = "output", split = FALSE)
[16:01:45.073]         if (TRUE) {
[16:01:45.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.073]         }
[16:01:45.073]         else {
[16:01:45.073]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.073]         }
[16:01:45.073]         base::close(...future.stdout)
[16:01:45.073]         ...future.stdout <- NULL
[16:01:45.073]     }
[16:01:45.073]     ...future.result$conditions <- ...future.conditions
[16:01:45.073]     ...future.result$finished <- base::Sys.time()
[16:01:45.073]     ...future.result
[16:01:45.073] }
[16:01:45.075] assign_globals() ...
[16:01:45.075] List of 5
[16:01:45.075]  $ ...future.FUN            :function (object, ...)  
[16:01:45.075]  $ future.call.arguments    : list()
[16:01:45.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.075]  $ ...future.elements_ii    :List of 3
[16:01:45.075]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.075]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.075]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.075]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.075]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.075]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.075]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.075]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.075]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.075]  $ ...future.seeds_ii       : NULL
[16:01:45.075]  $ ...future.globals.maxSize: NULL
[16:01:45.075]  - attr(*, "where")=List of 5
[16:01:45.075]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.075]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.075]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.075]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.075]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.075]  - attr(*, "resolved")= logi FALSE
[16:01:45.075]  - attr(*, "total_size")= num 1240
[16:01:45.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.075]  - attr(*, "already-done")= logi TRUE
[16:01:45.085] - copied ‘...future.FUN’ to environment
[16:01:45.085] - copied ‘future.call.arguments’ to environment
[16:01:45.085] - copied ‘...future.elements_ii’ to environment
[16:01:45.085] - copied ‘...future.seeds_ii’ to environment
[16:01:45.085] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.085] assign_globals() ... done
[16:01:45.086] plan(): Setting new future strategy stack:
[16:01:45.086] List of future strategies:
[16:01:45.086] 1. sequential:
[16:01:45.086]    - args: function (..., envir = parent.frame())
[16:01:45.086]    - tweaked: FALSE
[16:01:45.086]    - call: NULL
[16:01:45.086] plan(): nbrOfWorkers() = 1
[16:01:45.088] plan(): Setting new future strategy stack:
[16:01:45.088] List of future strategies:
[16:01:45.088] 1. multicore:
[16:01:45.088]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.088]    - tweaked: FALSE
[16:01:45.088]    - call: plan(strategy)
[16:01:45.092] plan(): nbrOfWorkers() = 1
[16:01:45.092] SequentialFuture started (and completed)
[16:01:45.092] - Launch lazy future ... done
[16:01:45.092] run() for ‘SequentialFuture’ ... done
[16:01:45.092] Created future:
[16:01:45.092] SequentialFuture:
[16:01:45.092] Label: ‘future_by-1’
[16:01:45.092] Expression:
[16:01:45.092] {
[16:01:45.092]     do.call(function(...) {
[16:01:45.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.092]             on.exit(options(oopts), add = TRUE)
[16:01:45.092]         }
[16:01:45.092]         {
[16:01:45.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.092]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.092]             })
[16:01:45.092]         }
[16:01:45.092]     }, args = future.call.arguments)
[16:01:45.092] }
[16:01:45.092] Lazy evaluation: FALSE
[16:01:45.092] Asynchronous evaluation: FALSE
[16:01:45.092] Local evaluation: TRUE
[16:01:45.092] Environment: R_GlobalEnv
[16:01:45.092] Capture standard output: TRUE
[16:01:45.092] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.092] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.092] Packages: <none>
[16:01:45.092] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.092] Resolved: TRUE
[16:01:45.092] Value: 4.62 KiB of class ‘list’
[16:01:45.092] Early signaling: FALSE
[16:01:45.092] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.092] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.094] Chunk #1 of 1 ... DONE
[16:01:45.094] Launching 1 futures (chunks) ... DONE
[16:01:45.094] Resolving 1 futures (chunks) ...
[16:01:45.094] resolve() on list ...
[16:01:45.094]  recursive: 0
[16:01:45.094]  length: 1
[16:01:45.094] 
[16:01:45.094] resolved() for ‘SequentialFuture’ ...
[16:01:45.094] - state: ‘finished’
[16:01:45.094] - run: TRUE
[16:01:45.095] - result: ‘FutureResult’
[16:01:45.095] resolved() for ‘SequentialFuture’ ... done
[16:01:45.095] Future #1
[16:01:45.095] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.095] - nx: 1
[16:01:45.095] - relay: TRUE
[16:01:45.095] - stdout: TRUE
[16:01:45.095] - signal: TRUE
[16:01:45.095] - resignal: FALSE
[16:01:45.095] - force: TRUE
[16:01:45.096] - relayed: [n=1] FALSE
[16:01:45.096] - queued futures: [n=1] FALSE
[16:01:45.096]  - until=1
[16:01:45.096]  - relaying element #1
[16:01:45.096] - relayed: [n=1] TRUE
[16:01:45.096] - queued futures: [n=1] TRUE
[16:01:45.096] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.096]  length: 0 (resolved future 1)
[16:01:45.096] Relaying remaining futures
[16:01:45.096] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.097] - nx: 1
[16:01:45.097] - relay: TRUE
[16:01:45.097] - stdout: TRUE
[16:01:45.097] - signal: TRUE
[16:01:45.097] - resignal: FALSE
[16:01:45.097] - force: TRUE
[16:01:45.097] - relayed: [n=1] TRUE
[16:01:45.097] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.097] - relayed: [n=1] TRUE
[16:01:45.097] - queued futures: [n=1] TRUE
[16:01:45.097] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.098] resolve() on list ... DONE
[16:01:45.098]  - Number of value chunks collected: 1
[16:01:45.098] Resolving 1 futures (chunks) ... DONE
[16:01:45.098] Reducing values from 1 chunks ...
[16:01:45.098]  - Number of values collected after concatenation: 3
[16:01:45.098]  - Number of values expected: 3
[16:01:45.098] Reducing values from 1 chunks ... DONE
[16:01:45.098] future_lapply() ... DONE
[16:01:45.098] future_by_internal() ... DONE
[16:01:45.099] future_by_internal() ...
[16:01:45.099] future_lapply() ...
[16:01:45.103] Number of chunks: 1
[16:01:45.103] getGlobalsAndPackagesXApply() ...
[16:01:45.103]  - future.globals: TRUE
[16:01:45.103] getGlobalsAndPackages() ...
[16:01:45.103] Searching for globals...
[16:01:45.106] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.106] Searching for globals ... DONE
[16:01:45.106] Resolving globals: FALSE
[16:01:45.106] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.107] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.107] - globals: [1] ‘FUN’
[16:01:45.107] 
[16:01:45.107] getGlobalsAndPackages() ... DONE
[16:01:45.107]  - globals found/used: [n=1] ‘FUN’
[16:01:45.107]  - needed namespaces: [n=0] 
[16:01:45.107] Finding globals ... DONE
[16:01:45.107]  - use_args: TRUE
[16:01:45.107]  - Getting '...' globals ...
[16:01:45.108] resolve() on list ...
[16:01:45.108]  recursive: 0
[16:01:45.108]  length: 1
[16:01:45.108]  elements: ‘...’
[16:01:45.108]  length: 0 (resolved future 1)
[16:01:45.108] resolve() on list ... DONE
[16:01:45.108]    - '...' content: [n=1] ‘digits’
[16:01:45.108] List of 1
[16:01:45.108]  $ ...:List of 1
[16:01:45.108]   ..$ digits: int 2
[16:01:45.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.108]  - attr(*, "where")=List of 1
[16:01:45.108]   ..$ ...:<environment: 0x55b525f3f600> 
[16:01:45.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.108]  - attr(*, "resolved")= logi TRUE
[16:01:45.108]  - attr(*, "total_size")= num NA
[16:01:45.112]  - Getting '...' globals ... DONE
[16:01:45.112] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.112] List of 2
[16:01:45.112]  $ ...future.FUN:function (object, ...)  
[16:01:45.112]  $ ...          :List of 1
[16:01:45.112]   ..$ digits: int 2
[16:01:45.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.112]  - attr(*, "where")=List of 2
[16:01:45.112]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.112]   ..$ ...          :<environment: 0x55b525f3f600> 
[16:01:45.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.112]  - attr(*, "resolved")= logi FALSE
[16:01:45.112]  - attr(*, "total_size")= num 1296
[16:01:45.115] Packages to be attached in all futures: [n=0] 
[16:01:45.115] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.115] Number of futures (= number of chunks): 1
[16:01:45.115] Launching 1 futures (chunks) ...
[16:01:45.115] Chunk #1 of 1 ...
[16:01:45.116]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.116] getGlobalsAndPackages() ...
[16:01:45.116] Searching for globals...
[16:01:45.116] 
[16:01:45.116] Searching for globals ... DONE
[16:01:45.116] - globals: [0] <none>
[16:01:45.116] getGlobalsAndPackages() ... DONE
[16:01:45.116]    + additional globals found: [n=0] 
[16:01:45.117]    + additional namespaces needed: [n=0] 
[16:01:45.117]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.117]  - seeds: <none>
[16:01:45.117]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.117] getGlobalsAndPackages() ...
[16:01:45.117] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.117] Resolving globals: FALSE
[16:01:45.117] Tweak future expression to call with '...' arguments ...
[16:01:45.118] {
[16:01:45.118]     do.call(function(...) {
[16:01:45.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.118]             on.exit(options(oopts), add = TRUE)
[16:01:45.118]         }
[16:01:45.118]         {
[16:01:45.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.118]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.118]             })
[16:01:45.118]         }
[16:01:45.118]     }, args = future.call.arguments)
[16:01:45.118] }
[16:01:45.118] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.118] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.118] 
[16:01:45.118] getGlobalsAndPackages() ... DONE
[16:01:45.119] run() for ‘Future’ ...
[16:01:45.119] - state: ‘created’
[16:01:45.119] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.122] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.123]   - Field: ‘label’
[16:01:45.123]   - Field: ‘local’
[16:01:45.123]   - Field: ‘owner’
[16:01:45.123]   - Field: ‘envir’
[16:01:45.123]   - Field: ‘packages’
[16:01:45.123]   - Field: ‘gc’
[16:01:45.123]   - Field: ‘conditions’
[16:01:45.123]   - Field: ‘expr’
[16:01:45.124]   - Field: ‘uuid’
[16:01:45.124]   - Field: ‘seed’
[16:01:45.124]   - Field: ‘version’
[16:01:45.124]   - Field: ‘result’
[16:01:45.124]   - Field: ‘asynchronous’
[16:01:45.124]   - Field: ‘calls’
[16:01:45.124]   - Field: ‘globals’
[16:01:45.124]   - Field: ‘stdout’
[16:01:45.124]   - Field: ‘earlySignal’
[16:01:45.124]   - Field: ‘lazy’
[16:01:45.124]   - Field: ‘state’
[16:01:45.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.125] - Launch lazy future ...
[16:01:45.125] Packages needed by the future expression (n = 0): <none>
[16:01:45.125] Packages needed by future strategies (n = 0): <none>
[16:01:45.125] {
[16:01:45.125]     {
[16:01:45.125]         {
[16:01:45.125]             ...future.startTime <- base::Sys.time()
[16:01:45.125]             {
[16:01:45.125]                 {
[16:01:45.125]                   {
[16:01:45.125]                     base::local({
[16:01:45.125]                       has_future <- base::requireNamespace("future", 
[16:01:45.125]                         quietly = TRUE)
[16:01:45.125]                       if (has_future) {
[16:01:45.125]                         ns <- base::getNamespace("future")
[16:01:45.125]                         version <- ns[[".package"]][["version"]]
[16:01:45.125]                         if (is.null(version)) 
[16:01:45.125]                           version <- utils::packageVersion("future")
[16:01:45.125]                       }
[16:01:45.125]                       else {
[16:01:45.125]                         version <- NULL
[16:01:45.125]                       }
[16:01:45.125]                       if (!has_future || version < "1.8.0") {
[16:01:45.125]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.125]                           "", base::R.version$version.string), 
[16:01:45.125]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.125]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.125]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.125]                             "release", "version")], collapse = " "), 
[16:01:45.125]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.125]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.125]                           info)
[16:01:45.125]                         info <- base::paste(info, collapse = "; ")
[16:01:45.125]                         if (!has_future) {
[16:01:45.125]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.125]                             info)
[16:01:45.125]                         }
[16:01:45.125]                         else {
[16:01:45.125]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.125]                             info, version)
[16:01:45.125]                         }
[16:01:45.125]                         base::stop(msg)
[16:01:45.125]                       }
[16:01:45.125]                     })
[16:01:45.125]                   }
[16:01:45.125]                   options(future.plan = NULL)
[16:01:45.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.125]                 }
[16:01:45.125]                 ...future.workdir <- getwd()
[16:01:45.125]             }
[16:01:45.125]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.125]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.125]         }
[16:01:45.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.125]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.125]             base::names(...future.oldOptions))
[16:01:45.125]     }
[16:01:45.125]     if (FALSE) {
[16:01:45.125]     }
[16:01:45.125]     else {
[16:01:45.125]         if (TRUE) {
[16:01:45.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.125]                 open = "w")
[16:01:45.125]         }
[16:01:45.125]         else {
[16:01:45.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.125]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.125]         }
[16:01:45.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.125]             base::sink(type = "output", split = FALSE)
[16:01:45.125]             base::close(...future.stdout)
[16:01:45.125]         }, add = TRUE)
[16:01:45.125]     }
[16:01:45.125]     ...future.frame <- base::sys.nframe()
[16:01:45.125]     ...future.conditions <- base::list()
[16:01:45.125]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.125]     if (FALSE) {
[16:01:45.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.125]     }
[16:01:45.125]     ...future.result <- base::tryCatch({
[16:01:45.125]         base::withCallingHandlers({
[16:01:45.125]             ...future.value <- base::withVisible(base::local({
[16:01:45.125]                 do.call(function(...) {
[16:01:45.125]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.125]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.125]                     ...future.globals.maxSize)) {
[16:01:45.125]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.125]                     on.exit(options(oopts), add = TRUE)
[16:01:45.125]                   }
[16:01:45.125]                   {
[16:01:45.125]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.125]                       FUN = function(jj) {
[16:01:45.125]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.125]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.125]                       })
[16:01:45.125]                   }
[16:01:45.125]                 }, args = future.call.arguments)
[16:01:45.125]             }))
[16:01:45.125]             future::FutureResult(value = ...future.value$value, 
[16:01:45.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.125]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.125]                     ...future.globalenv.names))
[16:01:45.125]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.125]         }, condition = base::local({
[16:01:45.125]             c <- base::c
[16:01:45.125]             inherits <- base::inherits
[16:01:45.125]             invokeRestart <- base::invokeRestart
[16:01:45.125]             length <- base::length
[16:01:45.125]             list <- base::list
[16:01:45.125]             seq.int <- base::seq.int
[16:01:45.125]             signalCondition <- base::signalCondition
[16:01:45.125]             sys.calls <- base::sys.calls
[16:01:45.125]             `[[` <- base::`[[`
[16:01:45.125]             `+` <- base::`+`
[16:01:45.125]             `<<-` <- base::`<<-`
[16:01:45.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.125]                   3L)]
[16:01:45.125]             }
[16:01:45.125]             function(cond) {
[16:01:45.125]                 is_error <- inherits(cond, "error")
[16:01:45.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.125]                   NULL)
[16:01:45.125]                 if (is_error) {
[16:01:45.125]                   sessionInformation <- function() {
[16:01:45.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.125]                       search = base::search(), system = base::Sys.info())
[16:01:45.125]                   }
[16:01:45.125]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.125]                     cond$call), session = sessionInformation(), 
[16:01:45.125]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.125]                   signalCondition(cond)
[16:01:45.125]                 }
[16:01:45.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.125]                 "immediateCondition"))) {
[16:01:45.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.125]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.125]                   if (TRUE && !signal) {
[16:01:45.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.125]                     {
[16:01:45.125]                       inherits <- base::inherits
[16:01:45.125]                       invokeRestart <- base::invokeRestart
[16:01:45.125]                       is.null <- base::is.null
[16:01:45.125]                       muffled <- FALSE
[16:01:45.125]                       if (inherits(cond, "message")) {
[16:01:45.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.125]                         if (muffled) 
[16:01:45.125]                           invokeRestart("muffleMessage")
[16:01:45.125]                       }
[16:01:45.125]                       else if (inherits(cond, "warning")) {
[16:01:45.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.125]                         if (muffled) 
[16:01:45.125]                           invokeRestart("muffleWarning")
[16:01:45.125]                       }
[16:01:45.125]                       else if (inherits(cond, "condition")) {
[16:01:45.125]                         if (!is.null(pattern)) {
[16:01:45.125]                           computeRestarts <- base::computeRestarts
[16:01:45.125]                           grepl <- base::grepl
[16:01:45.125]                           restarts <- computeRestarts(cond)
[16:01:45.125]                           for (restart in restarts) {
[16:01:45.125]                             name <- restart$name
[16:01:45.125]                             if (is.null(name)) 
[16:01:45.125]                               next
[16:01:45.125]                             if (!grepl(pattern, name)) 
[16:01:45.125]                               next
[16:01:45.125]                             invokeRestart(restart)
[16:01:45.125]                             muffled <- TRUE
[16:01:45.125]                             break
[16:01:45.125]                           }
[16:01:45.125]                         }
[16:01:45.125]                       }
[16:01:45.125]                       invisible(muffled)
[16:01:45.125]                     }
[16:01:45.125]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.125]                   }
[16:01:45.125]                 }
[16:01:45.125]                 else {
[16:01:45.125]                   if (TRUE) {
[16:01:45.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.125]                     {
[16:01:45.125]                       inherits <- base::inherits
[16:01:45.125]                       invokeRestart <- base::invokeRestart
[16:01:45.125]                       is.null <- base::is.null
[16:01:45.125]                       muffled <- FALSE
[16:01:45.125]                       if (inherits(cond, "message")) {
[16:01:45.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.125]                         if (muffled) 
[16:01:45.125]                           invokeRestart("muffleMessage")
[16:01:45.125]                       }
[16:01:45.125]                       else if (inherits(cond, "warning")) {
[16:01:45.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.125]                         if (muffled) 
[16:01:45.125]                           invokeRestart("muffleWarning")
[16:01:45.125]                       }
[16:01:45.125]                       else if (inherits(cond, "condition")) {
[16:01:45.125]                         if (!is.null(pattern)) {
[16:01:45.125]                           computeRestarts <- base::computeRestarts
[16:01:45.125]                           grepl <- base::grepl
[16:01:45.125]                           restarts <- computeRestarts(cond)
[16:01:45.125]                           for (restart in restarts) {
[16:01:45.125]                             name <- restart$name
[16:01:45.125]                             if (is.null(name)) 
[16:01:45.125]                               next
[16:01:45.125]                             if (!grepl(pattern, name)) 
[16:01:45.125]                               next
[16:01:45.125]                             invokeRestart(restart)
[16:01:45.125]                             muffled <- TRUE
[16:01:45.125]                             break
[16:01:45.125]                           }
[16:01:45.125]                         }
[16:01:45.125]                       }
[16:01:45.125]                       invisible(muffled)
[16:01:45.125]                     }
[16:01:45.125]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.125]                   }
[16:01:45.125]                 }
[16:01:45.125]             }
[16:01:45.125]         }))
[16:01:45.125]     }, error = function(ex) {
[16:01:45.125]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.125]                 ...future.rng), started = ...future.startTime, 
[16:01:45.125]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.125]             version = "1.8"), class = "FutureResult")
[16:01:45.125]     }, finally = {
[16:01:45.125]         if (!identical(...future.workdir, getwd())) 
[16:01:45.125]             setwd(...future.workdir)
[16:01:45.125]         {
[16:01:45.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.125]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.125]             }
[16:01:45.125]             base::options(...future.oldOptions)
[16:01:45.125]             if (.Platform$OS.type == "windows") {
[16:01:45.125]                 old_names <- names(...future.oldEnvVars)
[16:01:45.125]                 envs <- base::Sys.getenv()
[16:01:45.125]                 names <- names(envs)
[16:01:45.125]                 common <- intersect(names, old_names)
[16:01:45.125]                 added <- setdiff(names, old_names)
[16:01:45.125]                 removed <- setdiff(old_names, names)
[16:01:45.125]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.125]                   envs[common]]
[16:01:45.125]                 NAMES <- toupper(changed)
[16:01:45.125]                 args <- list()
[16:01:45.125]                 for (kk in seq_along(NAMES)) {
[16:01:45.125]                   name <- changed[[kk]]
[16:01:45.125]                   NAME <- NAMES[[kk]]
[16:01:45.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.125]                     next
[16:01:45.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.125]                 }
[16:01:45.125]                 NAMES <- toupper(added)
[16:01:45.125]                 for (kk in seq_along(NAMES)) {
[16:01:45.125]                   name <- added[[kk]]
[16:01:45.125]                   NAME <- NAMES[[kk]]
[16:01:45.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.125]                     next
[16:01:45.125]                   args[[name]] <- ""
[16:01:45.125]                 }
[16:01:45.125]                 NAMES <- toupper(removed)
[16:01:45.125]                 for (kk in seq_along(NAMES)) {
[16:01:45.125]                   name <- removed[[kk]]
[16:01:45.125]                   NAME <- NAMES[[kk]]
[16:01:45.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.125]                     next
[16:01:45.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.125]                 }
[16:01:45.125]                 if (length(args) > 0) 
[16:01:45.125]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.125]             }
[16:01:45.125]             else {
[16:01:45.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.125]             }
[16:01:45.125]             {
[16:01:45.125]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.125]                   0L) {
[16:01:45.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.125]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.125]                   base::options(opts)
[16:01:45.125]                 }
[16:01:45.125]                 {
[16:01:45.125]                   {
[16:01:45.125]                     NULL
[16:01:45.125]                     RNGkind("Mersenne-Twister")
[16:01:45.125]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.125]                       inherits = FALSE)
[16:01:45.125]                   }
[16:01:45.125]                   options(future.plan = NULL)
[16:01:45.125]                   if (is.na(NA_character_)) 
[16:01:45.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.125]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:45.125]                     envir = parent.frame()) 
[16:01:45.125]                   {
[16:01:45.125]                     default_workers <- missing(workers)
[16:01:45.125]                     if (is.function(workers)) 
[16:01:45.125]                       workers <- workers()
[16:01:45.125]                     workers <- structure(as.integer(workers), 
[16:01:45.125]                       class = class(workers))
[16:01:45.125]                     stop_if_not(is.finite(workers), workers >= 
[16:01:45.125]                       1L)
[16:01:45.125]                     if ((workers == 1L && !inherits(workers, 
[16:01:45.125]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:45.125]                       if (default_workers) 
[16:01:45.125]                         supportsMulticore(warn = TRUE)
[16:01:45.125]                       return(sequential(..., envir = envir))
[16:01:45.125]                     }
[16:01:45.125]                     oopts <- options(mc.cores = workers)
[16:01:45.125]                     on.exit(options(oopts))
[16:01:45.125]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:45.125]                       envir = envir)
[16:01:45.125]                     if (!future$lazy) 
[16:01:45.125]                       future <- run(future)
[16:01:45.125]                     invisible(future)
[16:01:45.125]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.125]                 }
[16:01:45.125]             }
[16:01:45.125]         }
[16:01:45.125]     })
[16:01:45.125]     if (TRUE) {
[16:01:45.125]         base::sink(type = "output", split = FALSE)
[16:01:45.125]         if (TRUE) {
[16:01:45.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.125]         }
[16:01:45.125]         else {
[16:01:45.125]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.125]         }
[16:01:45.125]         base::close(...future.stdout)
[16:01:45.125]         ...future.stdout <- NULL
[16:01:45.125]     }
[16:01:45.125]     ...future.result$conditions <- ...future.conditions
[16:01:45.125]     ...future.result$finished <- base::Sys.time()
[16:01:45.125]     ...future.result
[16:01:45.125] }
[16:01:45.127] assign_globals() ...
[16:01:45.127] List of 5
[16:01:45.127]  $ ...future.FUN            :function (object, ...)  
[16:01:45.127]  $ future.call.arguments    :List of 1
[16:01:45.127]   ..$ digits: int 2
[16:01:45.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.127]  $ ...future.elements_ii    :List of 6
[16:01:45.127]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:01:45.127]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:01:45.127]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:01:45.127]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:01:45.127]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:01:45.127]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:01:45.127]  $ ...future.seeds_ii       : NULL
[16:01:45.127]  $ ...future.globals.maxSize: NULL
[16:01:45.127]  - attr(*, "where")=List of 5
[16:01:45.127]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.127]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.127]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.127]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.127]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.127]  - attr(*, "resolved")= logi FALSE
[16:01:45.127]  - attr(*, "total_size")= num 1296
[16:01:45.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.127]  - attr(*, "already-done")= logi TRUE
[16:01:45.136] - copied ‘...future.FUN’ to environment
[16:01:45.136] - copied ‘future.call.arguments’ to environment
[16:01:45.136] - copied ‘...future.elements_ii’ to environment
[16:01:45.136] - copied ‘...future.seeds_ii’ to environment
[16:01:45.136] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.136] assign_globals() ... done
[16:01:45.136] plan(): Setting new future strategy stack:
[16:01:45.137] List of future strategies:
[16:01:45.137] 1. sequential:
[16:01:45.137]    - args: function (..., envir = parent.frame())
[16:01:45.137]    - tweaked: FALSE
[16:01:45.137]    - call: NULL
[16:01:45.137] plan(): nbrOfWorkers() = 1
[16:01:45.138] plan(): Setting new future strategy stack:
[16:01:45.138] List of future strategies:
[16:01:45.138] 1. multicore:
[16:01:45.138]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.138]    - tweaked: FALSE
[16:01:45.138]    - call: plan(strategy)
[16:01:45.142] plan(): nbrOfWorkers() = 1
[16:01:45.142] SequentialFuture started (and completed)
[16:01:45.142] - Launch lazy future ... done
[16:01:45.142] run() for ‘SequentialFuture’ ... done
[16:01:45.143] Created future:
[16:01:45.143] SequentialFuture:
[16:01:45.143] Label: ‘future_by-1’
[16:01:45.143] Expression:
[16:01:45.143] {
[16:01:45.143]     do.call(function(...) {
[16:01:45.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.143]             on.exit(options(oopts), add = TRUE)
[16:01:45.143]         }
[16:01:45.143]         {
[16:01:45.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.143]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.143]             })
[16:01:45.143]         }
[16:01:45.143]     }, args = future.call.arguments)
[16:01:45.143] }
[16:01:45.143] Lazy evaluation: FALSE
[16:01:45.143] Asynchronous evaluation: FALSE
[16:01:45.143] Local evaluation: TRUE
[16:01:45.143] Environment: R_GlobalEnv
[16:01:45.143] Capture standard output: TRUE
[16:01:45.143] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.143] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.143] Packages: <none>
[16:01:45.143] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.143] Resolved: TRUE
[16:01:45.143] Value: 5.48 KiB of class ‘list’
[16:01:45.143] Early signaling: FALSE
[16:01:45.143] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.143] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.144] Chunk #1 of 1 ... DONE
[16:01:45.144] Launching 1 futures (chunks) ... DONE
[16:01:45.144] Resolving 1 futures (chunks) ...
[16:01:45.144] resolve() on list ...
[16:01:45.144]  recursive: 0
[16:01:45.144]  length: 1
[16:01:45.144] 
[16:01:45.144] resolved() for ‘SequentialFuture’ ...
[16:01:45.145] - state: ‘finished’
[16:01:45.145] - run: TRUE
[16:01:45.145] - result: ‘FutureResult’
[16:01:45.145] resolved() for ‘SequentialFuture’ ... done
[16:01:45.145] Future #1
[16:01:45.145] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.145] - nx: 1
[16:01:45.145] - relay: TRUE
[16:01:45.145] - stdout: TRUE
[16:01:45.145] - signal: TRUE
[16:01:45.146] - resignal: FALSE
[16:01:45.146] - force: TRUE
[16:01:45.146] - relayed: [n=1] FALSE
[16:01:45.146] - queued futures: [n=1] FALSE
[16:01:45.146]  - until=1
[16:01:45.146]  - relaying element #1
[16:01:45.146] - relayed: [n=1] TRUE
[16:01:45.146] - queued futures: [n=1] TRUE
[16:01:45.146] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.146]  length: 0 (resolved future 1)
[16:01:45.147] Relaying remaining futures
[16:01:45.147] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.147] - nx: 1
[16:01:45.147] - relay: TRUE
[16:01:45.147] - stdout: TRUE
[16:01:45.147] - signal: TRUE
[16:01:45.147] - resignal: FALSE
[16:01:45.147] - force: TRUE
[16:01:45.147] - relayed: [n=1] TRUE
[16:01:45.147] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.147] - relayed: [n=1] TRUE
[16:01:45.148] - queued futures: [n=1] TRUE
[16:01:45.148] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.148] resolve() on list ... DONE
[16:01:45.148]  - Number of value chunks collected: 1
[16:01:45.148] Resolving 1 futures (chunks) ... DONE
[16:01:45.148] Reducing values from 1 chunks ...
[16:01:45.148]  - Number of values collected after concatenation: 6
[16:01:45.148]  - Number of values expected: 6
[16:01:45.148] Reducing values from 1 chunks ... DONE
[16:01:45.148] future_lapply() ... DONE
[16:01:45.149] future_by_internal() ... DONE
[16:01:45.180] future_by_internal() ...
[16:01:45.180] future_lapply() ...
[16:01:45.185] Number of chunks: 1
[16:01:45.185] getGlobalsAndPackagesXApply() ...
[16:01:45.185]  - future.globals: TRUE
[16:01:45.185] getGlobalsAndPackages() ...
[16:01:45.185] Searching for globals...
[16:01:45.187] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:45.187] Searching for globals ... DONE
[16:01:45.187] Resolving globals: FALSE
[16:01:45.188] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:01:45.188] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:01:45.188] - globals: [1] ‘FUN’
[16:01:45.188] - packages: [1] ‘stats’
[16:01:45.188] getGlobalsAndPackages() ... DONE
[16:01:45.188]  - globals found/used: [n=1] ‘FUN’
[16:01:45.188]  - needed namespaces: [n=1] ‘stats’
[16:01:45.189] Finding globals ... DONE
[16:01:45.189]  - use_args: TRUE
[16:01:45.189]  - Getting '...' globals ...
[16:01:45.189] resolve() on list ...
[16:01:45.189]  recursive: 0
[16:01:45.189]  length: 1
[16:01:45.189]  elements: ‘...’
[16:01:45.189]  length: 0 (resolved future 1)
[16:01:45.190] resolve() on list ... DONE
[16:01:45.190]    - '...' content: [n=1] ‘singular.ok’
[16:01:45.190] List of 1
[16:01:45.190]  $ ...:List of 1
[16:01:45.190]   ..$ singular.ok: logi FALSE
[16:01:45.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.190]  - attr(*, "where")=List of 1
[16:01:45.190]   ..$ ...:<environment: 0x55b52614cb60> 
[16:01:45.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.190]  - attr(*, "resolved")= logi TRUE
[16:01:45.190]  - attr(*, "total_size")= num NA
[16:01:45.193]  - Getting '...' globals ... DONE
[16:01:45.193] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.193] List of 2
[16:01:45.193]  $ ...future.FUN:function (x, ...)  
[16:01:45.193]  $ ...          :List of 1
[16:01:45.193]   ..$ singular.ok: logi FALSE
[16:01:45.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.193]  - attr(*, "where")=List of 2
[16:01:45.193]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.193]   ..$ ...          :<environment: 0x55b52614cb60> 
[16:01:45.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.193]  - attr(*, "resolved")= logi FALSE
[16:01:45.193]  - attr(*, "total_size")= num 5384
[16:01:45.196] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:45.196] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.197] Number of futures (= number of chunks): 1
[16:01:45.197] Launching 1 futures (chunks) ...
[16:01:45.197] Chunk #1 of 1 ...
[16:01:45.197]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.197] getGlobalsAndPackages() ...
[16:01:45.197] Searching for globals...
[16:01:45.198] 
[16:01:45.198] Searching for globals ... DONE
[16:01:45.198] - globals: [0] <none>
[16:01:45.198] getGlobalsAndPackages() ... DONE
[16:01:45.198]    + additional globals found: [n=0] 
[16:01:45.198]    + additional namespaces needed: [n=0] 
[16:01:45.198]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.198]  - seeds: <none>
[16:01:45.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.199] getGlobalsAndPackages() ...
[16:01:45.199] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.199] Resolving globals: FALSE
[16:01:45.199] Tweak future expression to call with '...' arguments ...
[16:01:45.199] {
[16:01:45.199]     do.call(function(...) {
[16:01:45.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.199]             on.exit(options(oopts), add = TRUE)
[16:01:45.199]         }
[16:01:45.199]         {
[16:01:45.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.199]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.199]             })
[16:01:45.199]         }
[16:01:45.199]     }, args = future.call.arguments)
[16:01:45.199] }
[16:01:45.199] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.200] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.200] 
[16:01:45.200] getGlobalsAndPackages() ... DONE
[16:01:45.200] run() for ‘Future’ ...
[16:01:45.200] - state: ‘created’
[16:01:45.200] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.204] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.204]   - Field: ‘label’
[16:01:45.205]   - Field: ‘local’
[16:01:45.205]   - Field: ‘owner’
[16:01:45.205]   - Field: ‘envir’
[16:01:45.205]   - Field: ‘packages’
[16:01:45.205]   - Field: ‘gc’
[16:01:45.205]   - Field: ‘conditions’
[16:01:45.205]   - Field: ‘expr’
[16:01:45.205]   - Field: ‘uuid’
[16:01:45.205]   - Field: ‘seed’
[16:01:45.205]   - Field: ‘version’
[16:01:45.206]   - Field: ‘result’
[16:01:45.206]   - Field: ‘asynchronous’
[16:01:45.206]   - Field: ‘calls’
[16:01:45.207]   - Field: ‘globals’
[16:01:45.207]   - Field: ‘stdout’
[16:01:45.208]   - Field: ‘earlySignal’
[16:01:45.208]   - Field: ‘lazy’
[16:01:45.208]   - Field: ‘state’
[16:01:45.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.208] - Launch lazy future ...
[16:01:45.208] Packages needed by the future expression (n = 1): ‘stats’
[16:01:45.208] Packages needed by future strategies (n = 0): <none>
[16:01:45.209] {
[16:01:45.209]     {
[16:01:45.209]         {
[16:01:45.209]             ...future.startTime <- base::Sys.time()
[16:01:45.209]             {
[16:01:45.209]                 {
[16:01:45.209]                   {
[16:01:45.209]                     {
[16:01:45.209]                       base::local({
[16:01:45.209]                         has_future <- base::requireNamespace("future", 
[16:01:45.209]                           quietly = TRUE)
[16:01:45.209]                         if (has_future) {
[16:01:45.209]                           ns <- base::getNamespace("future")
[16:01:45.209]                           version <- ns[[".package"]][["version"]]
[16:01:45.209]                           if (is.null(version)) 
[16:01:45.209]                             version <- utils::packageVersion("future")
[16:01:45.209]                         }
[16:01:45.209]                         else {
[16:01:45.209]                           version <- NULL
[16:01:45.209]                         }
[16:01:45.209]                         if (!has_future || version < "1.8.0") {
[16:01:45.209]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.209]                             "", base::R.version$version.string), 
[16:01:45.209]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:45.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.209]                               "release", "version")], collapse = " "), 
[16:01:45.209]                             hostname = base::Sys.info()[["nodename"]])
[16:01:45.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.209]                             info)
[16:01:45.209]                           info <- base::paste(info, collapse = "; ")
[16:01:45.209]                           if (!has_future) {
[16:01:45.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.209]                               info)
[16:01:45.209]                           }
[16:01:45.209]                           else {
[16:01:45.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.209]                               info, version)
[16:01:45.209]                           }
[16:01:45.209]                           base::stop(msg)
[16:01:45.209]                         }
[16:01:45.209]                       })
[16:01:45.209]                     }
[16:01:45.209]                     base::local({
[16:01:45.209]                       for (pkg in "stats") {
[16:01:45.209]                         base::loadNamespace(pkg)
[16:01:45.209]                         base::library(pkg, character.only = TRUE)
[16:01:45.209]                       }
[16:01:45.209]                     })
[16:01:45.209]                   }
[16:01:45.209]                   options(future.plan = NULL)
[16:01:45.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.209]                 }
[16:01:45.209]                 ...future.workdir <- getwd()
[16:01:45.209]             }
[16:01:45.209]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.209]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.209]         }
[16:01:45.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.209]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.209]             base::names(...future.oldOptions))
[16:01:45.209]     }
[16:01:45.209]     if (FALSE) {
[16:01:45.209]     }
[16:01:45.209]     else {
[16:01:45.209]         if (TRUE) {
[16:01:45.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.209]                 open = "w")
[16:01:45.209]         }
[16:01:45.209]         else {
[16:01:45.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.209]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.209]         }
[16:01:45.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.209]             base::sink(type = "output", split = FALSE)
[16:01:45.209]             base::close(...future.stdout)
[16:01:45.209]         }, add = TRUE)
[16:01:45.209]     }
[16:01:45.209]     ...future.frame <- base::sys.nframe()
[16:01:45.209]     ...future.conditions <- base::list()
[16:01:45.209]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.209]     if (FALSE) {
[16:01:45.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.209]     }
[16:01:45.209]     ...future.result <- base::tryCatch({
[16:01:45.209]         base::withCallingHandlers({
[16:01:45.209]             ...future.value <- base::withVisible(base::local({
[16:01:45.209]                 do.call(function(...) {
[16:01:45.209]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.209]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.209]                     ...future.globals.maxSize)) {
[16:01:45.209]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.209]                     on.exit(options(oopts), add = TRUE)
[16:01:45.209]                   }
[16:01:45.209]                   {
[16:01:45.209]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.209]                       FUN = function(jj) {
[16:01:45.209]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.209]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.209]                       })
[16:01:45.209]                   }
[16:01:45.209]                 }, args = future.call.arguments)
[16:01:45.209]             }))
[16:01:45.209]             future::FutureResult(value = ...future.value$value, 
[16:01:45.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.209]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.209]                     ...future.globalenv.names))
[16:01:45.209]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.209]         }, condition = base::local({
[16:01:45.209]             c <- base::c
[16:01:45.209]             inherits <- base::inherits
[16:01:45.209]             invokeRestart <- base::invokeRestart
[16:01:45.209]             length <- base::length
[16:01:45.209]             list <- base::list
[16:01:45.209]             seq.int <- base::seq.int
[16:01:45.209]             signalCondition <- base::signalCondition
[16:01:45.209]             sys.calls <- base::sys.calls
[16:01:45.209]             `[[` <- base::`[[`
[16:01:45.209]             `+` <- base::`+`
[16:01:45.209]             `<<-` <- base::`<<-`
[16:01:45.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.209]                   3L)]
[16:01:45.209]             }
[16:01:45.209]             function(cond) {
[16:01:45.209]                 is_error <- inherits(cond, "error")
[16:01:45.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.209]                   NULL)
[16:01:45.209]                 if (is_error) {
[16:01:45.209]                   sessionInformation <- function() {
[16:01:45.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.209]                       search = base::search(), system = base::Sys.info())
[16:01:45.209]                   }
[16:01:45.209]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.209]                     cond$call), session = sessionInformation(), 
[16:01:45.209]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.209]                   signalCondition(cond)
[16:01:45.209]                 }
[16:01:45.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.209]                 "immediateCondition"))) {
[16:01:45.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.209]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.209]                   if (TRUE && !signal) {
[16:01:45.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.209]                     {
[16:01:45.209]                       inherits <- base::inherits
[16:01:45.209]                       invokeRestart <- base::invokeRestart
[16:01:45.209]                       is.null <- base::is.null
[16:01:45.209]                       muffled <- FALSE
[16:01:45.209]                       if (inherits(cond, "message")) {
[16:01:45.209]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.209]                         if (muffled) 
[16:01:45.209]                           invokeRestart("muffleMessage")
[16:01:45.209]                       }
[16:01:45.209]                       else if (inherits(cond, "warning")) {
[16:01:45.209]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.209]                         if (muffled) 
[16:01:45.209]                           invokeRestart("muffleWarning")
[16:01:45.209]                       }
[16:01:45.209]                       else if (inherits(cond, "condition")) {
[16:01:45.209]                         if (!is.null(pattern)) {
[16:01:45.209]                           computeRestarts <- base::computeRestarts
[16:01:45.209]                           grepl <- base::grepl
[16:01:45.209]                           restarts <- computeRestarts(cond)
[16:01:45.209]                           for (restart in restarts) {
[16:01:45.209]                             name <- restart$name
[16:01:45.209]                             if (is.null(name)) 
[16:01:45.209]                               next
[16:01:45.209]                             if (!grepl(pattern, name)) 
[16:01:45.209]                               next
[16:01:45.209]                             invokeRestart(restart)
[16:01:45.209]                             muffled <- TRUE
[16:01:45.209]                             break
[16:01:45.209]                           }
[16:01:45.209]                         }
[16:01:45.209]                       }
[16:01:45.209]                       invisible(muffled)
[16:01:45.209]                     }
[16:01:45.209]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.209]                   }
[16:01:45.209]                 }
[16:01:45.209]                 else {
[16:01:45.209]                   if (TRUE) {
[16:01:45.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.209]                     {
[16:01:45.209]                       inherits <- base::inherits
[16:01:45.209]                       invokeRestart <- base::invokeRestart
[16:01:45.209]                       is.null <- base::is.null
[16:01:45.209]                       muffled <- FALSE
[16:01:45.209]                       if (inherits(cond, "message")) {
[16:01:45.209]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.209]                         if (muffled) 
[16:01:45.209]                           invokeRestart("muffleMessage")
[16:01:45.209]                       }
[16:01:45.209]                       else if (inherits(cond, "warning")) {
[16:01:45.209]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.209]                         if (muffled) 
[16:01:45.209]                           invokeRestart("muffleWarning")
[16:01:45.209]                       }
[16:01:45.209]                       else if (inherits(cond, "condition")) {
[16:01:45.209]                         if (!is.null(pattern)) {
[16:01:45.209]                           computeRestarts <- base::computeRestarts
[16:01:45.209]                           grepl <- base::grepl
[16:01:45.209]                           restarts <- computeRestarts(cond)
[16:01:45.209]                           for (restart in restarts) {
[16:01:45.209]                             name <- restart$name
[16:01:45.209]                             if (is.null(name)) 
[16:01:45.209]                               next
[16:01:45.209]                             if (!grepl(pattern, name)) 
[16:01:45.209]                               next
[16:01:45.209]                             invokeRestart(restart)
[16:01:45.209]                             muffled <- TRUE
[16:01:45.209]                             break
[16:01:45.209]                           }
[16:01:45.209]                         }
[16:01:45.209]                       }
[16:01:45.209]                       invisible(muffled)
[16:01:45.209]                     }
[16:01:45.209]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.209]                   }
[16:01:45.209]                 }
[16:01:45.209]             }
[16:01:45.209]         }))
[16:01:45.209]     }, error = function(ex) {
[16:01:45.209]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.209]                 ...future.rng), started = ...future.startTime, 
[16:01:45.209]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.209]             version = "1.8"), class = "FutureResult")
[16:01:45.209]     }, finally = {
[16:01:45.209]         if (!identical(...future.workdir, getwd())) 
[16:01:45.209]             setwd(...future.workdir)
[16:01:45.209]         {
[16:01:45.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.209]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.209]             }
[16:01:45.209]             base::options(...future.oldOptions)
[16:01:45.209]             if (.Platform$OS.type == "windows") {
[16:01:45.209]                 old_names <- names(...future.oldEnvVars)
[16:01:45.209]                 envs <- base::Sys.getenv()
[16:01:45.209]                 names <- names(envs)
[16:01:45.209]                 common <- intersect(names, old_names)
[16:01:45.209]                 added <- setdiff(names, old_names)
[16:01:45.209]                 removed <- setdiff(old_names, names)
[16:01:45.209]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.209]                   envs[common]]
[16:01:45.209]                 NAMES <- toupper(changed)
[16:01:45.209]                 args <- list()
[16:01:45.209]                 for (kk in seq_along(NAMES)) {
[16:01:45.209]                   name <- changed[[kk]]
[16:01:45.209]                   NAME <- NAMES[[kk]]
[16:01:45.209]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.209]                     next
[16:01:45.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.209]                 }
[16:01:45.209]                 NAMES <- toupper(added)
[16:01:45.209]                 for (kk in seq_along(NAMES)) {
[16:01:45.209]                   name <- added[[kk]]
[16:01:45.209]                   NAME <- NAMES[[kk]]
[16:01:45.209]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.209]                     next
[16:01:45.209]                   args[[name]] <- ""
[16:01:45.209]                 }
[16:01:45.209]                 NAMES <- toupper(removed)
[16:01:45.209]                 for (kk in seq_along(NAMES)) {
[16:01:45.209]                   name <- removed[[kk]]
[16:01:45.209]                   NAME <- NAMES[[kk]]
[16:01:45.209]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.209]                     next
[16:01:45.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.209]                 }
[16:01:45.209]                 if (length(args) > 0) 
[16:01:45.209]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.209]             }
[16:01:45.209]             else {
[16:01:45.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.209]             }
[16:01:45.209]             {
[16:01:45.209]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.209]                   0L) {
[16:01:45.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.209]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.209]                   base::options(opts)
[16:01:45.209]                 }
[16:01:45.209]                 {
[16:01:45.209]                   {
[16:01:45.209]                     NULL
[16:01:45.209]                     RNGkind("Mersenne-Twister")
[16:01:45.209]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.209]                       inherits = FALSE)
[16:01:45.209]                   }
[16:01:45.209]                   options(future.plan = NULL)
[16:01:45.209]                   if (is.na(NA_character_)) 
[16:01:45.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.209]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:45.209]                     envir = parent.frame()) 
[16:01:45.209]                   {
[16:01:45.209]                     default_workers <- missing(workers)
[16:01:45.209]                     if (is.function(workers)) 
[16:01:45.209]                       workers <- workers()
[16:01:45.209]                     workers <- structure(as.integer(workers), 
[16:01:45.209]                       class = class(workers))
[16:01:45.209]                     stop_if_not(is.finite(workers), workers >= 
[16:01:45.209]                       1L)
[16:01:45.209]                     if ((workers == 1L && !inherits(workers, 
[16:01:45.209]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:45.209]                       if (default_workers) 
[16:01:45.209]                         supportsMulticore(warn = TRUE)
[16:01:45.209]                       return(sequential(..., envir = envir))
[16:01:45.209]                     }
[16:01:45.209]                     oopts <- options(mc.cores = workers)
[16:01:45.209]                     on.exit(options(oopts))
[16:01:45.209]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:45.209]                       envir = envir)
[16:01:45.209]                     if (!future$lazy) 
[16:01:45.209]                       future <- run(future)
[16:01:45.209]                     invisible(future)
[16:01:45.209]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.209]                 }
[16:01:45.209]             }
[16:01:45.209]         }
[16:01:45.209]     })
[16:01:45.209]     if (TRUE) {
[16:01:45.209]         base::sink(type = "output", split = FALSE)
[16:01:45.209]         if (TRUE) {
[16:01:45.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.209]         }
[16:01:45.209]         else {
[16:01:45.209]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.209]         }
[16:01:45.209]         base::close(...future.stdout)
[16:01:45.209]         ...future.stdout <- NULL
[16:01:45.209]     }
[16:01:45.209]     ...future.result$conditions <- ...future.conditions
[16:01:45.209]     ...future.result$finished <- base::Sys.time()
[16:01:45.209]     ...future.result
[16:01:45.209] }
[16:01:45.211] assign_globals() ...
[16:01:45.211] List of 5
[16:01:45.211]  $ ...future.FUN            :function (x, ...)  
[16:01:45.211]  $ future.call.arguments    :List of 1
[16:01:45.211]   ..$ singular.ok: logi FALSE
[16:01:45.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.211]  $ ...future.elements_ii    :List of 3
[16:01:45.211]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.211]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.211]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.211]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.211]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.211]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.211]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.211]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.211]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.211]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.211]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.211]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.211]  $ ...future.seeds_ii       : NULL
[16:01:45.211]  $ ...future.globals.maxSize: NULL
[16:01:45.211]  - attr(*, "where")=List of 5
[16:01:45.211]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.211]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.211]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.211]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.211]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.211]  - attr(*, "resolved")= logi FALSE
[16:01:45.211]  - attr(*, "total_size")= num 5384
[16:01:45.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.211]  - attr(*, "already-done")= logi TRUE
[16:01:45.220] - reassign environment for ‘...future.FUN’
[16:01:45.221] - copied ‘...future.FUN’ to environment
[16:01:45.221] - copied ‘future.call.arguments’ to environment
[16:01:45.221] - copied ‘...future.elements_ii’ to environment
[16:01:45.221] - copied ‘...future.seeds_ii’ to environment
[16:01:45.221] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.221] assign_globals() ... done
[16:01:45.221] plan(): Setting new future strategy stack:
[16:01:45.222] List of future strategies:
[16:01:45.222] 1. sequential:
[16:01:45.222]    - args: function (..., envir = parent.frame())
[16:01:45.222]    - tweaked: FALSE
[16:01:45.222]    - call: NULL
[16:01:45.222] plan(): nbrOfWorkers() = 1
[16:01:45.225] plan(): Setting new future strategy stack:
[16:01:45.225] List of future strategies:
[16:01:45.225] 1. multicore:
[16:01:45.225]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.225]    - tweaked: FALSE
[16:01:45.225]    - call: plan(strategy)
[16:01:45.229] plan(): nbrOfWorkers() = 1
[16:01:45.229] SequentialFuture started (and completed)
[16:01:45.229] - Launch lazy future ... done
[16:01:45.229] run() for ‘SequentialFuture’ ... done
[16:01:45.229] Created future:
[16:01:45.229] SequentialFuture:
[16:01:45.229] Label: ‘future_by-1’
[16:01:45.229] Expression:
[16:01:45.229] {
[16:01:45.229]     do.call(function(...) {
[16:01:45.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.229]             on.exit(options(oopts), add = TRUE)
[16:01:45.229]         }
[16:01:45.229]         {
[16:01:45.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.229]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.229]             })
[16:01:45.229]         }
[16:01:45.229]     }, args = future.call.arguments)
[16:01:45.229] }
[16:01:45.229] Lazy evaluation: FALSE
[16:01:45.229] Asynchronous evaluation: FALSE
[16:01:45.229] Local evaluation: TRUE
[16:01:45.229] Environment: R_GlobalEnv
[16:01:45.229] Capture standard output: TRUE
[16:01:45.229] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.229] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.229] Packages: 1 packages (‘stats’)
[16:01:45.229] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.229] Resolved: TRUE
[16:01:45.229] Value: 26.06 KiB of class ‘list’
[16:01:45.229] Early signaling: FALSE
[16:01:45.229] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.229] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.231] Chunk #1 of 1 ... DONE
[16:01:45.231] Launching 1 futures (chunks) ... DONE
[16:01:45.231] Resolving 1 futures (chunks) ...
[16:01:45.231] resolve() on list ...
[16:01:45.231]  recursive: 0
[16:01:45.232]  length: 1
[16:01:45.232] 
[16:01:45.232] resolved() for ‘SequentialFuture’ ...
[16:01:45.232] - state: ‘finished’
[16:01:45.232] - run: TRUE
[16:01:45.232] - result: ‘FutureResult’
[16:01:45.232] resolved() for ‘SequentialFuture’ ... done
[16:01:45.232] Future #1
[16:01:45.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.232] - nx: 1
[16:01:45.233] - relay: TRUE
[16:01:45.233] - stdout: TRUE
[16:01:45.233] - signal: TRUE
[16:01:45.233] - resignal: FALSE
[16:01:45.233] - force: TRUE
[16:01:45.233] - relayed: [n=1] FALSE
[16:01:45.233] - queued futures: [n=1] FALSE
[16:01:45.235]  - until=1
[16:01:45.235]  - relaying element #1
[16:01:45.235] - relayed: [n=1] TRUE
[16:01:45.235] - queued futures: [n=1] TRUE
[16:01:45.235] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.235]  length: 0 (resolved future 1)
[16:01:45.236] Relaying remaining futures
[16:01:45.236] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.236] - nx: 1
[16:01:45.236] - relay: TRUE
[16:01:45.236] - stdout: TRUE
[16:01:45.236] - signal: TRUE
[16:01:45.236] - resignal: FALSE
[16:01:45.236] - force: TRUE
[16:01:45.236] - relayed: [n=1] TRUE
[16:01:45.236] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.237] - relayed: [n=1] TRUE
[16:01:45.237] - queued futures: [n=1] TRUE
[16:01:45.237] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.237] resolve() on list ... DONE
[16:01:45.237]  - Number of value chunks collected: 1
[16:01:45.237] Resolving 1 futures (chunks) ... DONE
[16:01:45.237] Reducing values from 1 chunks ...
[16:01:45.237]  - Number of values collected after concatenation: 3
[16:01:45.238]  - Number of values expected: 3
[16:01:45.238] Reducing values from 1 chunks ... DONE
[16:01:45.238] future_lapply() ... DONE
[16:01:45.238] future_by_internal() ... DONE
[16:01:45.242] future_by_internal() ...
[16:01:45.242] future_lapply() ...
[16:01:45.247] Number of chunks: 1
[16:01:45.247] getGlobalsAndPackagesXApply() ...
[16:01:45.247]  - future.globals: TRUE
[16:01:45.247] getGlobalsAndPackages() ...
[16:01:45.247] Searching for globals...
[16:01:45.249] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:45.249] Searching for globals ... DONE
[16:01:45.249] Resolving globals: FALSE
[16:01:45.250] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:01:45.250] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:01:45.250] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:45.250] - packages: [1] ‘stats’
[16:01:45.250] getGlobalsAndPackages() ... DONE
[16:01:45.250]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:45.251]  - needed namespaces: [n=1] ‘stats’
[16:01:45.251] Finding globals ... DONE
[16:01:45.251]  - use_args: TRUE
[16:01:45.251]  - Getting '...' globals ...
[16:01:45.251] resolve() on list ...
[16:01:45.251]  recursive: 0
[16:01:45.251]  length: 1
[16:01:45.251]  elements: ‘...’
[16:01:45.252]  length: 0 (resolved future 1)
[16:01:45.252] resolve() on list ... DONE
[16:01:45.252]    - '...' content: [n=0] 
[16:01:45.252] List of 1
[16:01:45.252]  $ ...: list()
[16:01:45.252]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.252]  - attr(*, "where")=List of 1
[16:01:45.252]   ..$ ...:<environment: 0x55b523f7b8c0> 
[16:01:45.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.252]  - attr(*, "resolved")= logi TRUE
[16:01:45.252]  - attr(*, "total_size")= num NA
[16:01:45.254]  - Getting '...' globals ... DONE
[16:01:45.255] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:01:45.255] List of 4
[16:01:45.255]  $ ...future.FUN:function (x)  
[16:01:45.255]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:45.255]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.255]  $ ...          : list()
[16:01:45.255]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.255]  - attr(*, "where")=List of 4
[16:01:45.255]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.255]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:01:45.255]   ..$ wool         :<environment: R_EmptyEnv> 
[16:01:45.255]   ..$ ...          :<environment: 0x55b523f7b8c0> 
[16:01:45.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.255]  - attr(*, "resolved")= logi FALSE
[16:01:45.255]  - attr(*, "total_size")= num 2320
[16:01:45.261] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:45.261] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.261] Number of futures (= number of chunks): 1
[16:01:45.261] Launching 1 futures (chunks) ...
[16:01:45.261] Chunk #1 of 1 ...
[16:01:45.261]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.261] getGlobalsAndPackages() ...
[16:01:45.261] Searching for globals...
[16:01:45.262] 
[16:01:45.262] Searching for globals ... DONE
[16:01:45.262] - globals: [0] <none>
[16:01:45.262] getGlobalsAndPackages() ... DONE
[16:01:45.262]    + additional globals found: [n=0] 
[16:01:45.262]    + additional namespaces needed: [n=0] 
[16:01:45.263]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.263]  - seeds: <none>
[16:01:45.263]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.263] getGlobalsAndPackages() ...
[16:01:45.263] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.263] Resolving globals: FALSE
[16:01:45.263] Tweak future expression to call with '...' arguments ...
[16:01:45.263] {
[16:01:45.263]     do.call(function(...) {
[16:01:45.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.263]             on.exit(options(oopts), add = TRUE)
[16:01:45.263]         }
[16:01:45.263]         {
[16:01:45.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.263]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.263]             })
[16:01:45.263]         }
[16:01:45.263]     }, args = future.call.arguments)
[16:01:45.263] }
[16:01:45.264] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.264] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.264] 
[16:01:45.264] getGlobalsAndPackages() ... DONE
[16:01:45.265] run() for ‘Future’ ...
[16:01:45.265] - state: ‘created’
[16:01:45.265] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.269] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.269]   - Field: ‘label’
[16:01:45.269]   - Field: ‘local’
[16:01:45.269]   - Field: ‘owner’
[16:01:45.269]   - Field: ‘envir’
[16:01:45.269]   - Field: ‘packages’
[16:01:45.269]   - Field: ‘gc’
[16:01:45.270]   - Field: ‘conditions’
[16:01:45.270]   - Field: ‘expr’
[16:01:45.270]   - Field: ‘uuid’
[16:01:45.270]   - Field: ‘seed’
[16:01:45.270]   - Field: ‘version’
[16:01:45.270]   - Field: ‘result’
[16:01:45.270]   - Field: ‘asynchronous’
[16:01:45.270]   - Field: ‘calls’
[16:01:45.270]   - Field: ‘globals’
[16:01:45.270]   - Field: ‘stdout’
[16:01:45.271]   - Field: ‘earlySignal’
[16:01:45.271]   - Field: ‘lazy’
[16:01:45.271]   - Field: ‘state’
[16:01:45.271] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.271] - Launch lazy future ...
[16:01:45.271] Packages needed by the future expression (n = 1): ‘stats’
[16:01:45.271] Packages needed by future strategies (n = 0): <none>
[16:01:45.272] {
[16:01:45.272]     {
[16:01:45.272]         {
[16:01:45.272]             ...future.startTime <- base::Sys.time()
[16:01:45.272]             {
[16:01:45.272]                 {
[16:01:45.272]                   {
[16:01:45.272]                     {
[16:01:45.272]                       base::local({
[16:01:45.272]                         has_future <- base::requireNamespace("future", 
[16:01:45.272]                           quietly = TRUE)
[16:01:45.272]                         if (has_future) {
[16:01:45.272]                           ns <- base::getNamespace("future")
[16:01:45.272]                           version <- ns[[".package"]][["version"]]
[16:01:45.272]                           if (is.null(version)) 
[16:01:45.272]                             version <- utils::packageVersion("future")
[16:01:45.272]                         }
[16:01:45.272]                         else {
[16:01:45.272]                           version <- NULL
[16:01:45.272]                         }
[16:01:45.272]                         if (!has_future || version < "1.8.0") {
[16:01:45.272]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.272]                             "", base::R.version$version.string), 
[16:01:45.272]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:45.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.272]                               "release", "version")], collapse = " "), 
[16:01:45.272]                             hostname = base::Sys.info()[["nodename"]])
[16:01:45.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.272]                             info)
[16:01:45.272]                           info <- base::paste(info, collapse = "; ")
[16:01:45.272]                           if (!has_future) {
[16:01:45.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.272]                               info)
[16:01:45.272]                           }
[16:01:45.272]                           else {
[16:01:45.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.272]                               info, version)
[16:01:45.272]                           }
[16:01:45.272]                           base::stop(msg)
[16:01:45.272]                         }
[16:01:45.272]                       })
[16:01:45.272]                     }
[16:01:45.272]                     base::local({
[16:01:45.272]                       for (pkg in "stats") {
[16:01:45.272]                         base::loadNamespace(pkg)
[16:01:45.272]                         base::library(pkg, character.only = TRUE)
[16:01:45.272]                       }
[16:01:45.272]                     })
[16:01:45.272]                   }
[16:01:45.272]                   options(future.plan = NULL)
[16:01:45.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.272]                 }
[16:01:45.272]                 ...future.workdir <- getwd()
[16:01:45.272]             }
[16:01:45.272]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.272]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.272]         }
[16:01:45.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.272]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.272]             base::names(...future.oldOptions))
[16:01:45.272]     }
[16:01:45.272]     if (FALSE) {
[16:01:45.272]     }
[16:01:45.272]     else {
[16:01:45.272]         if (TRUE) {
[16:01:45.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.272]                 open = "w")
[16:01:45.272]         }
[16:01:45.272]         else {
[16:01:45.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.272]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.272]         }
[16:01:45.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.272]             base::sink(type = "output", split = FALSE)
[16:01:45.272]             base::close(...future.stdout)
[16:01:45.272]         }, add = TRUE)
[16:01:45.272]     }
[16:01:45.272]     ...future.frame <- base::sys.nframe()
[16:01:45.272]     ...future.conditions <- base::list()
[16:01:45.272]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.272]     if (FALSE) {
[16:01:45.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.272]     }
[16:01:45.272]     ...future.result <- base::tryCatch({
[16:01:45.272]         base::withCallingHandlers({
[16:01:45.272]             ...future.value <- base::withVisible(base::local({
[16:01:45.272]                 do.call(function(...) {
[16:01:45.272]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.272]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.272]                     ...future.globals.maxSize)) {
[16:01:45.272]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.272]                     on.exit(options(oopts), add = TRUE)
[16:01:45.272]                   }
[16:01:45.272]                   {
[16:01:45.272]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.272]                       FUN = function(jj) {
[16:01:45.272]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.272]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.272]                       })
[16:01:45.272]                   }
[16:01:45.272]                 }, args = future.call.arguments)
[16:01:45.272]             }))
[16:01:45.272]             future::FutureResult(value = ...future.value$value, 
[16:01:45.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.272]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.272]                     ...future.globalenv.names))
[16:01:45.272]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.272]         }, condition = base::local({
[16:01:45.272]             c <- base::c
[16:01:45.272]             inherits <- base::inherits
[16:01:45.272]             invokeRestart <- base::invokeRestart
[16:01:45.272]             length <- base::length
[16:01:45.272]             list <- base::list
[16:01:45.272]             seq.int <- base::seq.int
[16:01:45.272]             signalCondition <- base::signalCondition
[16:01:45.272]             sys.calls <- base::sys.calls
[16:01:45.272]             `[[` <- base::`[[`
[16:01:45.272]             `+` <- base::`+`
[16:01:45.272]             `<<-` <- base::`<<-`
[16:01:45.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.272]                   3L)]
[16:01:45.272]             }
[16:01:45.272]             function(cond) {
[16:01:45.272]                 is_error <- inherits(cond, "error")
[16:01:45.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.272]                   NULL)
[16:01:45.272]                 if (is_error) {
[16:01:45.272]                   sessionInformation <- function() {
[16:01:45.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.272]                       search = base::search(), system = base::Sys.info())
[16:01:45.272]                   }
[16:01:45.272]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.272]                     cond$call), session = sessionInformation(), 
[16:01:45.272]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.272]                   signalCondition(cond)
[16:01:45.272]                 }
[16:01:45.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.272]                 "immediateCondition"))) {
[16:01:45.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.272]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.272]                   if (TRUE && !signal) {
[16:01:45.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.272]                     {
[16:01:45.272]                       inherits <- base::inherits
[16:01:45.272]                       invokeRestart <- base::invokeRestart
[16:01:45.272]                       is.null <- base::is.null
[16:01:45.272]                       muffled <- FALSE
[16:01:45.272]                       if (inherits(cond, "message")) {
[16:01:45.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.272]                         if (muffled) 
[16:01:45.272]                           invokeRestart("muffleMessage")
[16:01:45.272]                       }
[16:01:45.272]                       else if (inherits(cond, "warning")) {
[16:01:45.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.272]                         if (muffled) 
[16:01:45.272]                           invokeRestart("muffleWarning")
[16:01:45.272]                       }
[16:01:45.272]                       else if (inherits(cond, "condition")) {
[16:01:45.272]                         if (!is.null(pattern)) {
[16:01:45.272]                           computeRestarts <- base::computeRestarts
[16:01:45.272]                           grepl <- base::grepl
[16:01:45.272]                           restarts <- computeRestarts(cond)
[16:01:45.272]                           for (restart in restarts) {
[16:01:45.272]                             name <- restart$name
[16:01:45.272]                             if (is.null(name)) 
[16:01:45.272]                               next
[16:01:45.272]                             if (!grepl(pattern, name)) 
[16:01:45.272]                               next
[16:01:45.272]                             invokeRestart(restart)
[16:01:45.272]                             muffled <- TRUE
[16:01:45.272]                             break
[16:01:45.272]                           }
[16:01:45.272]                         }
[16:01:45.272]                       }
[16:01:45.272]                       invisible(muffled)
[16:01:45.272]                     }
[16:01:45.272]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.272]                   }
[16:01:45.272]                 }
[16:01:45.272]                 else {
[16:01:45.272]                   if (TRUE) {
[16:01:45.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.272]                     {
[16:01:45.272]                       inherits <- base::inherits
[16:01:45.272]                       invokeRestart <- base::invokeRestart
[16:01:45.272]                       is.null <- base::is.null
[16:01:45.272]                       muffled <- FALSE
[16:01:45.272]                       if (inherits(cond, "message")) {
[16:01:45.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.272]                         if (muffled) 
[16:01:45.272]                           invokeRestart("muffleMessage")
[16:01:45.272]                       }
[16:01:45.272]                       else if (inherits(cond, "warning")) {
[16:01:45.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.272]                         if (muffled) 
[16:01:45.272]                           invokeRestart("muffleWarning")
[16:01:45.272]                       }
[16:01:45.272]                       else if (inherits(cond, "condition")) {
[16:01:45.272]                         if (!is.null(pattern)) {
[16:01:45.272]                           computeRestarts <- base::computeRestarts
[16:01:45.272]                           grepl <- base::grepl
[16:01:45.272]                           restarts <- computeRestarts(cond)
[16:01:45.272]                           for (restart in restarts) {
[16:01:45.272]                             name <- restart$name
[16:01:45.272]                             if (is.null(name)) 
[16:01:45.272]                               next
[16:01:45.272]                             if (!grepl(pattern, name)) 
[16:01:45.272]                               next
[16:01:45.272]                             invokeRestart(restart)
[16:01:45.272]                             muffled <- TRUE
[16:01:45.272]                             break
[16:01:45.272]                           }
[16:01:45.272]                         }
[16:01:45.272]                       }
[16:01:45.272]                       invisible(muffled)
[16:01:45.272]                     }
[16:01:45.272]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.272]                   }
[16:01:45.272]                 }
[16:01:45.272]             }
[16:01:45.272]         }))
[16:01:45.272]     }, error = function(ex) {
[16:01:45.272]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.272]                 ...future.rng), started = ...future.startTime, 
[16:01:45.272]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.272]             version = "1.8"), class = "FutureResult")
[16:01:45.272]     }, finally = {
[16:01:45.272]         if (!identical(...future.workdir, getwd())) 
[16:01:45.272]             setwd(...future.workdir)
[16:01:45.272]         {
[16:01:45.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.272]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.272]             }
[16:01:45.272]             base::options(...future.oldOptions)
[16:01:45.272]             if (.Platform$OS.type == "windows") {
[16:01:45.272]                 old_names <- names(...future.oldEnvVars)
[16:01:45.272]                 envs <- base::Sys.getenv()
[16:01:45.272]                 names <- names(envs)
[16:01:45.272]                 common <- intersect(names, old_names)
[16:01:45.272]                 added <- setdiff(names, old_names)
[16:01:45.272]                 removed <- setdiff(old_names, names)
[16:01:45.272]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.272]                   envs[common]]
[16:01:45.272]                 NAMES <- toupper(changed)
[16:01:45.272]                 args <- list()
[16:01:45.272]                 for (kk in seq_along(NAMES)) {
[16:01:45.272]                   name <- changed[[kk]]
[16:01:45.272]                   NAME <- NAMES[[kk]]
[16:01:45.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.272]                     next
[16:01:45.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.272]                 }
[16:01:45.272]                 NAMES <- toupper(added)
[16:01:45.272]                 for (kk in seq_along(NAMES)) {
[16:01:45.272]                   name <- added[[kk]]
[16:01:45.272]                   NAME <- NAMES[[kk]]
[16:01:45.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.272]                     next
[16:01:45.272]                   args[[name]] <- ""
[16:01:45.272]                 }
[16:01:45.272]                 NAMES <- toupper(removed)
[16:01:45.272]                 for (kk in seq_along(NAMES)) {
[16:01:45.272]                   name <- removed[[kk]]
[16:01:45.272]                   NAME <- NAMES[[kk]]
[16:01:45.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.272]                     next
[16:01:45.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.272]                 }
[16:01:45.272]                 if (length(args) > 0) 
[16:01:45.272]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.272]             }
[16:01:45.272]             else {
[16:01:45.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.272]             }
[16:01:45.272]             {
[16:01:45.272]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.272]                   0L) {
[16:01:45.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.272]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.272]                   base::options(opts)
[16:01:45.272]                 }
[16:01:45.272]                 {
[16:01:45.272]                   {
[16:01:45.272]                     NULL
[16:01:45.272]                     RNGkind("Mersenne-Twister")
[16:01:45.272]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.272]                       inherits = FALSE)
[16:01:45.272]                   }
[16:01:45.272]                   options(future.plan = NULL)
[16:01:45.272]                   if (is.na(NA_character_)) 
[16:01:45.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.272]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:45.272]                     envir = parent.frame()) 
[16:01:45.272]                   {
[16:01:45.272]                     default_workers <- missing(workers)
[16:01:45.272]                     if (is.function(workers)) 
[16:01:45.272]                       workers <- workers()
[16:01:45.272]                     workers <- structure(as.integer(workers), 
[16:01:45.272]                       class = class(workers))
[16:01:45.272]                     stop_if_not(is.finite(workers), workers >= 
[16:01:45.272]                       1L)
[16:01:45.272]                     if ((workers == 1L && !inherits(workers, 
[16:01:45.272]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:45.272]                       if (default_workers) 
[16:01:45.272]                         supportsMulticore(warn = TRUE)
[16:01:45.272]                       return(sequential(..., envir = envir))
[16:01:45.272]                     }
[16:01:45.272]                     oopts <- options(mc.cores = workers)
[16:01:45.272]                     on.exit(options(oopts))
[16:01:45.272]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:45.272]                       envir = envir)
[16:01:45.272]                     if (!future$lazy) 
[16:01:45.272]                       future <- run(future)
[16:01:45.272]                     invisible(future)
[16:01:45.272]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.272]                 }
[16:01:45.272]             }
[16:01:45.272]         }
[16:01:45.272]     })
[16:01:45.272]     if (TRUE) {
[16:01:45.272]         base::sink(type = "output", split = FALSE)
[16:01:45.272]         if (TRUE) {
[16:01:45.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.272]         }
[16:01:45.272]         else {
[16:01:45.272]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.272]         }
[16:01:45.272]         base::close(...future.stdout)
[16:01:45.272]         ...future.stdout <- NULL
[16:01:45.272]     }
[16:01:45.272]     ...future.result$conditions <- ...future.conditions
[16:01:45.272]     ...future.result$finished <- base::Sys.time()
[16:01:45.272]     ...future.result
[16:01:45.272] }
[16:01:45.274] assign_globals() ...
[16:01:45.274] List of 7
[16:01:45.274]  $ ...future.FUN            :function (x)  
[16:01:45.274]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:45.274]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.274]  $ future.call.arguments    : list()
[16:01:45.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.274]  $ ...future.elements_ii    :List of 3
[16:01:45.274]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.274]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.274]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.274]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.274]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.274]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.274]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.274]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.274]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.274]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.274]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.274]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.274]  $ ...future.seeds_ii       : NULL
[16:01:45.274]  $ ...future.globals.maxSize: NULL
[16:01:45.274]  - attr(*, "where")=List of 7
[16:01:45.274]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.274]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:01:45.274]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:01:45.274]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.274]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.274]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.274]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.274]  - attr(*, "resolved")= logi FALSE
[16:01:45.274]  - attr(*, "total_size")= num 2320
[16:01:45.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.274]  - attr(*, "already-done")= logi TRUE
[16:01:45.285] - reassign environment for ‘...future.FUN’
[16:01:45.286] - copied ‘...future.FUN’ to environment
[16:01:45.286] - copied ‘breaks’ to environment
[16:01:45.286] - copied ‘wool’ to environment
[16:01:45.286] - copied ‘future.call.arguments’ to environment
[16:01:45.286] - copied ‘...future.elements_ii’ to environment
[16:01:45.286] - copied ‘...future.seeds_ii’ to environment
[16:01:45.286] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.286] assign_globals() ... done
[16:01:45.287] plan(): Setting new future strategy stack:
[16:01:45.287] List of future strategies:
[16:01:45.287] 1. sequential:
[16:01:45.287]    - args: function (..., envir = parent.frame())
[16:01:45.287]    - tweaked: FALSE
[16:01:45.287]    - call: NULL
[16:01:45.288] plan(): nbrOfWorkers() = 1
[16:01:45.290] plan(): Setting new future strategy stack:
[16:01:45.291] List of future strategies:
[16:01:45.291] 1. multicore:
[16:01:45.291]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.291]    - tweaked: FALSE
[16:01:45.291]    - call: plan(strategy)
[16:01:45.294] plan(): nbrOfWorkers() = 1
[16:01:45.294] SequentialFuture started (and completed)
[16:01:45.295] - Launch lazy future ... done
[16:01:45.295] run() for ‘SequentialFuture’ ... done
[16:01:45.295] Created future:
[16:01:45.295] SequentialFuture:
[16:01:45.295] Label: ‘future_by-1’
[16:01:45.295] Expression:
[16:01:45.295] {
[16:01:45.295]     do.call(function(...) {
[16:01:45.295]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.295]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.295]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.295]             on.exit(options(oopts), add = TRUE)
[16:01:45.295]         }
[16:01:45.295]         {
[16:01:45.295]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.295]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.295]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.295]             })
[16:01:45.295]         }
[16:01:45.295]     }, args = future.call.arguments)
[16:01:45.295] }
[16:01:45.295] Lazy evaluation: FALSE
[16:01:45.295] Asynchronous evaluation: FALSE
[16:01:45.295] Local evaluation: TRUE
[16:01:45.295] Environment: 0x55b52435c810
[16:01:45.295] Capture standard output: TRUE
[16:01:45.295] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.295] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:01:45.295] Packages: 1 packages (‘stats’)
[16:01:45.295] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.295] Resolved: TRUE
[16:01:45.295] Value: 25.57 KiB of class ‘list’
[16:01:45.295] Early signaling: FALSE
[16:01:45.295] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.295] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.297] Chunk #1 of 1 ... DONE
[16:01:45.297] Launching 1 futures (chunks) ... DONE
[16:01:45.297] Resolving 1 futures (chunks) ...
[16:01:45.297] resolve() on list ...
[16:01:45.297]  recursive: 0
[16:01:45.297]  length: 1
[16:01:45.297] 
[16:01:45.297] resolved() for ‘SequentialFuture’ ...
[16:01:45.297] - state: ‘finished’
[16:01:45.297] - run: TRUE
[16:01:45.298] - result: ‘FutureResult’
[16:01:45.298] resolved() for ‘SequentialFuture’ ... done
[16:01:45.298] Future #1
[16:01:45.298] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.298] - nx: 1
[16:01:45.298] - relay: TRUE
[16:01:45.298] - stdout: TRUE
[16:01:45.298] - signal: TRUE
[16:01:45.298] - resignal: FALSE
[16:01:45.298] - force: TRUE
[16:01:45.299] - relayed: [n=1] FALSE
[16:01:45.299] - queued futures: [n=1] FALSE
[16:01:45.299]  - until=1
[16:01:45.299]  - relaying element #1
[16:01:45.299] - relayed: [n=1] TRUE
[16:01:45.299] - queued futures: [n=1] TRUE
[16:01:45.299] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.299]  length: 0 (resolved future 1)
[16:01:45.299] Relaying remaining futures
[16:01:45.300] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.300] - nx: 1
[16:01:45.300] - relay: TRUE
[16:01:45.300] - stdout: TRUE
[16:01:45.300] - signal: TRUE
[16:01:45.300] - resignal: FALSE
[16:01:45.300] - force: TRUE
[16:01:45.300] - relayed: [n=1] TRUE
[16:01:45.300] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.300] - relayed: [n=1] TRUE
[16:01:45.300] - queued futures: [n=1] TRUE
[16:01:45.301] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.301] resolve() on list ... DONE
[16:01:45.301]  - Number of value chunks collected: 1
[16:01:45.301] Resolving 1 futures (chunks) ... DONE
[16:01:45.301] Reducing values from 1 chunks ...
[16:01:45.301]  - Number of values collected after concatenation: 3
[16:01:45.301]  - Number of values expected: 3
[16:01:45.301] Reducing values from 1 chunks ... DONE
[16:01:45.301] future_lapply() ... DONE
[16:01:45.301] future_by_internal() ... DONE
[16:01:45.302] future_by_internal() ...
[16:01:45.302] future_lapply() ...
[16:01:45.306] Number of chunks: 1
[16:01:45.306] getGlobalsAndPackagesXApply() ...
[16:01:45.306]  - future.globals: TRUE
[16:01:45.306] getGlobalsAndPackages() ...
[16:01:45.306] Searching for globals...
[16:01:45.308] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.308] Searching for globals ... DONE
[16:01:45.308] Resolving globals: FALSE
[16:01:45.308] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.308] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.309] - globals: [1] ‘FUN’
[16:01:45.309] 
[16:01:45.309] getGlobalsAndPackages() ... DONE
[16:01:45.309]  - globals found/used: [n=1] ‘FUN’
[16:01:45.309]  - needed namespaces: [n=0] 
[16:01:45.309] Finding globals ... DONE
[16:01:45.309]  - use_args: TRUE
[16:01:45.309]  - Getting '...' globals ...
[16:01:45.310] resolve() on list ...
[16:01:45.310]  recursive: 0
[16:01:45.310]  length: 1
[16:01:45.310]  elements: ‘...’
[16:01:45.310]  length: 0 (resolved future 1)
[16:01:45.310] resolve() on list ... DONE
[16:01:45.310]    - '...' content: [n=0] 
[16:01:45.310] List of 1
[16:01:45.310]  $ ...: list()
[16:01:45.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.310]  - attr(*, "where")=List of 1
[16:01:45.310]   ..$ ...:<environment: 0x55b525c5b280> 
[16:01:45.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.310]  - attr(*, "resolved")= logi TRUE
[16:01:45.310]  - attr(*, "total_size")= num NA
[16:01:45.315]  - Getting '...' globals ... DONE
[16:01:45.315] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.315] List of 2
[16:01:45.315]  $ ...future.FUN:function (object, ...)  
[16:01:45.315]  $ ...          : list()
[16:01:45.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.315]  - attr(*, "where")=List of 2
[16:01:45.315]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.315]   ..$ ...          :<environment: 0x55b525c5b280> 
[16:01:45.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.315]  - attr(*, "resolved")= logi FALSE
[16:01:45.315]  - attr(*, "total_size")= num 1240
[16:01:45.318] Packages to be attached in all futures: [n=0] 
[16:01:45.318] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.318] Number of futures (= number of chunks): 1
[16:01:45.318] Launching 1 futures (chunks) ...
[16:01:45.318] Chunk #1 of 1 ...
[16:01:45.319]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.319] getGlobalsAndPackages() ...
[16:01:45.319] Searching for globals...
[16:01:45.319] 
[16:01:45.319] Searching for globals ... DONE
[16:01:45.320] - globals: [0] <none>
[16:01:45.320] getGlobalsAndPackages() ... DONE
[16:01:45.320]    + additional globals found: [n=0] 
[16:01:45.320]    + additional namespaces needed: [n=0] 
[16:01:45.320]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.320]  - seeds: <none>
[16:01:45.320]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.320] getGlobalsAndPackages() ...
[16:01:45.320] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.320] Resolving globals: FALSE
[16:01:45.320] Tweak future expression to call with '...' arguments ...
[16:01:45.321] {
[16:01:45.321]     do.call(function(...) {
[16:01:45.321]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.321]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.321]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.321]             on.exit(options(oopts), add = TRUE)
[16:01:45.321]         }
[16:01:45.321]         {
[16:01:45.321]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.321]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.321]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.321]             })
[16:01:45.321]         }
[16:01:45.321]     }, args = future.call.arguments)
[16:01:45.321] }
[16:01:45.321] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.321] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.321] 
[16:01:45.321] getGlobalsAndPackages() ... DONE
[16:01:45.322] run() for ‘Future’ ...
[16:01:45.322] - state: ‘created’
[16:01:45.322] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.326]   - Field: ‘label’
[16:01:45.326]   - Field: ‘local’
[16:01:45.326]   - Field: ‘owner’
[16:01:45.326]   - Field: ‘envir’
[16:01:45.326]   - Field: ‘packages’
[16:01:45.327]   - Field: ‘gc’
[16:01:45.327]   - Field: ‘conditions’
[16:01:45.327]   - Field: ‘expr’
[16:01:45.327]   - Field: ‘uuid’
[16:01:45.327]   - Field: ‘seed’
[16:01:45.327]   - Field: ‘version’
[16:01:45.327]   - Field: ‘result’
[16:01:45.327]   - Field: ‘asynchronous’
[16:01:45.327]   - Field: ‘calls’
[16:01:45.327]   - Field: ‘globals’
[16:01:45.328]   - Field: ‘stdout’
[16:01:45.328]   - Field: ‘earlySignal’
[16:01:45.328]   - Field: ‘lazy’
[16:01:45.328]   - Field: ‘state’
[16:01:45.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.328] - Launch lazy future ...
[16:01:45.328] Packages needed by the future expression (n = 0): <none>
[16:01:45.328] Packages needed by future strategies (n = 0): <none>
[16:01:45.329] {
[16:01:45.329]     {
[16:01:45.329]         {
[16:01:45.329]             ...future.startTime <- base::Sys.time()
[16:01:45.329]             {
[16:01:45.329]                 {
[16:01:45.329]                   {
[16:01:45.329]                     base::local({
[16:01:45.329]                       has_future <- base::requireNamespace("future", 
[16:01:45.329]                         quietly = TRUE)
[16:01:45.329]                       if (has_future) {
[16:01:45.329]                         ns <- base::getNamespace("future")
[16:01:45.329]                         version <- ns[[".package"]][["version"]]
[16:01:45.329]                         if (is.null(version)) 
[16:01:45.329]                           version <- utils::packageVersion("future")
[16:01:45.329]                       }
[16:01:45.329]                       else {
[16:01:45.329]                         version <- NULL
[16:01:45.329]                       }
[16:01:45.329]                       if (!has_future || version < "1.8.0") {
[16:01:45.329]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.329]                           "", base::R.version$version.string), 
[16:01:45.329]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.329]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.329]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.329]                             "release", "version")], collapse = " "), 
[16:01:45.329]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.329]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.329]                           info)
[16:01:45.329]                         info <- base::paste(info, collapse = "; ")
[16:01:45.329]                         if (!has_future) {
[16:01:45.329]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.329]                             info)
[16:01:45.329]                         }
[16:01:45.329]                         else {
[16:01:45.329]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.329]                             info, version)
[16:01:45.329]                         }
[16:01:45.329]                         base::stop(msg)
[16:01:45.329]                       }
[16:01:45.329]                     })
[16:01:45.329]                   }
[16:01:45.329]                   options(future.plan = NULL)
[16:01:45.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.329]                 }
[16:01:45.329]                 ...future.workdir <- getwd()
[16:01:45.329]             }
[16:01:45.329]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.329]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.329]         }
[16:01:45.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.329]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.329]             base::names(...future.oldOptions))
[16:01:45.329]     }
[16:01:45.329]     if (FALSE) {
[16:01:45.329]     }
[16:01:45.329]     else {
[16:01:45.329]         if (TRUE) {
[16:01:45.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.329]                 open = "w")
[16:01:45.329]         }
[16:01:45.329]         else {
[16:01:45.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.329]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.329]         }
[16:01:45.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.329]             base::sink(type = "output", split = FALSE)
[16:01:45.329]             base::close(...future.stdout)
[16:01:45.329]         }, add = TRUE)
[16:01:45.329]     }
[16:01:45.329]     ...future.frame <- base::sys.nframe()
[16:01:45.329]     ...future.conditions <- base::list()
[16:01:45.329]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.329]     if (FALSE) {
[16:01:45.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.329]     }
[16:01:45.329]     ...future.result <- base::tryCatch({
[16:01:45.329]         base::withCallingHandlers({
[16:01:45.329]             ...future.value <- base::withVisible(base::local({
[16:01:45.329]                 do.call(function(...) {
[16:01:45.329]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.329]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.329]                     ...future.globals.maxSize)) {
[16:01:45.329]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.329]                     on.exit(options(oopts), add = TRUE)
[16:01:45.329]                   }
[16:01:45.329]                   {
[16:01:45.329]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.329]                       FUN = function(jj) {
[16:01:45.329]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.329]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.329]                       })
[16:01:45.329]                   }
[16:01:45.329]                 }, args = future.call.arguments)
[16:01:45.329]             }))
[16:01:45.329]             future::FutureResult(value = ...future.value$value, 
[16:01:45.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.329]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.329]                     ...future.globalenv.names))
[16:01:45.329]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.329]         }, condition = base::local({
[16:01:45.329]             c <- base::c
[16:01:45.329]             inherits <- base::inherits
[16:01:45.329]             invokeRestart <- base::invokeRestart
[16:01:45.329]             length <- base::length
[16:01:45.329]             list <- base::list
[16:01:45.329]             seq.int <- base::seq.int
[16:01:45.329]             signalCondition <- base::signalCondition
[16:01:45.329]             sys.calls <- base::sys.calls
[16:01:45.329]             `[[` <- base::`[[`
[16:01:45.329]             `+` <- base::`+`
[16:01:45.329]             `<<-` <- base::`<<-`
[16:01:45.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.329]                   3L)]
[16:01:45.329]             }
[16:01:45.329]             function(cond) {
[16:01:45.329]                 is_error <- inherits(cond, "error")
[16:01:45.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.329]                   NULL)
[16:01:45.329]                 if (is_error) {
[16:01:45.329]                   sessionInformation <- function() {
[16:01:45.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.329]                       search = base::search(), system = base::Sys.info())
[16:01:45.329]                   }
[16:01:45.329]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.329]                     cond$call), session = sessionInformation(), 
[16:01:45.329]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.329]                   signalCondition(cond)
[16:01:45.329]                 }
[16:01:45.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.329]                 "immediateCondition"))) {
[16:01:45.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.329]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.329]                   if (TRUE && !signal) {
[16:01:45.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.329]                     {
[16:01:45.329]                       inherits <- base::inherits
[16:01:45.329]                       invokeRestart <- base::invokeRestart
[16:01:45.329]                       is.null <- base::is.null
[16:01:45.329]                       muffled <- FALSE
[16:01:45.329]                       if (inherits(cond, "message")) {
[16:01:45.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.329]                         if (muffled) 
[16:01:45.329]                           invokeRestart("muffleMessage")
[16:01:45.329]                       }
[16:01:45.329]                       else if (inherits(cond, "warning")) {
[16:01:45.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.329]                         if (muffled) 
[16:01:45.329]                           invokeRestart("muffleWarning")
[16:01:45.329]                       }
[16:01:45.329]                       else if (inherits(cond, "condition")) {
[16:01:45.329]                         if (!is.null(pattern)) {
[16:01:45.329]                           computeRestarts <- base::computeRestarts
[16:01:45.329]                           grepl <- base::grepl
[16:01:45.329]                           restarts <- computeRestarts(cond)
[16:01:45.329]                           for (restart in restarts) {
[16:01:45.329]                             name <- restart$name
[16:01:45.329]                             if (is.null(name)) 
[16:01:45.329]                               next
[16:01:45.329]                             if (!grepl(pattern, name)) 
[16:01:45.329]                               next
[16:01:45.329]                             invokeRestart(restart)
[16:01:45.329]                             muffled <- TRUE
[16:01:45.329]                             break
[16:01:45.329]                           }
[16:01:45.329]                         }
[16:01:45.329]                       }
[16:01:45.329]                       invisible(muffled)
[16:01:45.329]                     }
[16:01:45.329]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.329]                   }
[16:01:45.329]                 }
[16:01:45.329]                 else {
[16:01:45.329]                   if (TRUE) {
[16:01:45.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.329]                     {
[16:01:45.329]                       inherits <- base::inherits
[16:01:45.329]                       invokeRestart <- base::invokeRestart
[16:01:45.329]                       is.null <- base::is.null
[16:01:45.329]                       muffled <- FALSE
[16:01:45.329]                       if (inherits(cond, "message")) {
[16:01:45.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.329]                         if (muffled) 
[16:01:45.329]                           invokeRestart("muffleMessage")
[16:01:45.329]                       }
[16:01:45.329]                       else if (inherits(cond, "warning")) {
[16:01:45.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.329]                         if (muffled) 
[16:01:45.329]                           invokeRestart("muffleWarning")
[16:01:45.329]                       }
[16:01:45.329]                       else if (inherits(cond, "condition")) {
[16:01:45.329]                         if (!is.null(pattern)) {
[16:01:45.329]                           computeRestarts <- base::computeRestarts
[16:01:45.329]                           grepl <- base::grepl
[16:01:45.329]                           restarts <- computeRestarts(cond)
[16:01:45.329]                           for (restart in restarts) {
[16:01:45.329]                             name <- restart$name
[16:01:45.329]                             if (is.null(name)) 
[16:01:45.329]                               next
[16:01:45.329]                             if (!grepl(pattern, name)) 
[16:01:45.329]                               next
[16:01:45.329]                             invokeRestart(restart)
[16:01:45.329]                             muffled <- TRUE
[16:01:45.329]                             break
[16:01:45.329]                           }
[16:01:45.329]                         }
[16:01:45.329]                       }
[16:01:45.329]                       invisible(muffled)
[16:01:45.329]                     }
[16:01:45.329]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.329]                   }
[16:01:45.329]                 }
[16:01:45.329]             }
[16:01:45.329]         }))
[16:01:45.329]     }, error = function(ex) {
[16:01:45.329]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.329]                 ...future.rng), started = ...future.startTime, 
[16:01:45.329]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.329]             version = "1.8"), class = "FutureResult")
[16:01:45.329]     }, finally = {
[16:01:45.329]         if (!identical(...future.workdir, getwd())) 
[16:01:45.329]             setwd(...future.workdir)
[16:01:45.329]         {
[16:01:45.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.329]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.329]             }
[16:01:45.329]             base::options(...future.oldOptions)
[16:01:45.329]             if (.Platform$OS.type == "windows") {
[16:01:45.329]                 old_names <- names(...future.oldEnvVars)
[16:01:45.329]                 envs <- base::Sys.getenv()
[16:01:45.329]                 names <- names(envs)
[16:01:45.329]                 common <- intersect(names, old_names)
[16:01:45.329]                 added <- setdiff(names, old_names)
[16:01:45.329]                 removed <- setdiff(old_names, names)
[16:01:45.329]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.329]                   envs[common]]
[16:01:45.329]                 NAMES <- toupper(changed)
[16:01:45.329]                 args <- list()
[16:01:45.329]                 for (kk in seq_along(NAMES)) {
[16:01:45.329]                   name <- changed[[kk]]
[16:01:45.329]                   NAME <- NAMES[[kk]]
[16:01:45.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.329]                     next
[16:01:45.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.329]                 }
[16:01:45.329]                 NAMES <- toupper(added)
[16:01:45.329]                 for (kk in seq_along(NAMES)) {
[16:01:45.329]                   name <- added[[kk]]
[16:01:45.329]                   NAME <- NAMES[[kk]]
[16:01:45.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.329]                     next
[16:01:45.329]                   args[[name]] <- ""
[16:01:45.329]                 }
[16:01:45.329]                 NAMES <- toupper(removed)
[16:01:45.329]                 for (kk in seq_along(NAMES)) {
[16:01:45.329]                   name <- removed[[kk]]
[16:01:45.329]                   NAME <- NAMES[[kk]]
[16:01:45.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.329]                     next
[16:01:45.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.329]                 }
[16:01:45.329]                 if (length(args) > 0) 
[16:01:45.329]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.329]             }
[16:01:45.329]             else {
[16:01:45.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.329]             }
[16:01:45.329]             {
[16:01:45.329]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.329]                   0L) {
[16:01:45.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.329]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.329]                   base::options(opts)
[16:01:45.329]                 }
[16:01:45.329]                 {
[16:01:45.329]                   {
[16:01:45.329]                     NULL
[16:01:45.329]                     RNGkind("Mersenne-Twister")
[16:01:45.329]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.329]                       inherits = FALSE)
[16:01:45.329]                   }
[16:01:45.329]                   options(future.plan = NULL)
[16:01:45.329]                   if (is.na(NA_character_)) 
[16:01:45.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.329]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:45.329]                     envir = parent.frame()) 
[16:01:45.329]                   {
[16:01:45.329]                     default_workers <- missing(workers)
[16:01:45.329]                     if (is.function(workers)) 
[16:01:45.329]                       workers <- workers()
[16:01:45.329]                     workers <- structure(as.integer(workers), 
[16:01:45.329]                       class = class(workers))
[16:01:45.329]                     stop_if_not(is.finite(workers), workers >= 
[16:01:45.329]                       1L)
[16:01:45.329]                     if ((workers == 1L && !inherits(workers, 
[16:01:45.329]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:45.329]                       if (default_workers) 
[16:01:45.329]                         supportsMulticore(warn = TRUE)
[16:01:45.329]                       return(sequential(..., envir = envir))
[16:01:45.329]                     }
[16:01:45.329]                     oopts <- options(mc.cores = workers)
[16:01:45.329]                     on.exit(options(oopts))
[16:01:45.329]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:45.329]                       envir = envir)
[16:01:45.329]                     if (!future$lazy) 
[16:01:45.329]                       future <- run(future)
[16:01:45.329]                     invisible(future)
[16:01:45.329]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.329]                 }
[16:01:45.329]             }
[16:01:45.329]         }
[16:01:45.329]     })
[16:01:45.329]     if (TRUE) {
[16:01:45.329]         base::sink(type = "output", split = FALSE)
[16:01:45.329]         if (TRUE) {
[16:01:45.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.329]         }
[16:01:45.329]         else {
[16:01:45.329]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.329]         }
[16:01:45.329]         base::close(...future.stdout)
[16:01:45.329]         ...future.stdout <- NULL
[16:01:45.329]     }
[16:01:45.329]     ...future.result$conditions <- ...future.conditions
[16:01:45.329]     ...future.result$finished <- base::Sys.time()
[16:01:45.329]     ...future.result
[16:01:45.329] }
[16:01:45.331] assign_globals() ...
[16:01:45.331] List of 5
[16:01:45.331]  $ ...future.FUN            :function (object, ...)  
[16:01:45.331]  $ future.call.arguments    : list()
[16:01:45.331]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.331]  $ ...future.elements_ii    :List of 3
[16:01:45.331]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.331]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.331]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.331]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.331]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.331]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.331]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.331]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.331]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.331]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.331]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.331]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.331]  $ ...future.seeds_ii       : NULL
[16:01:45.331]  $ ...future.globals.maxSize: NULL
[16:01:45.331]  - attr(*, "where")=List of 5
[16:01:45.331]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.331]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.331]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.331]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.331]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.331]  - attr(*, "resolved")= logi FALSE
[16:01:45.331]  - attr(*, "total_size")= num 1240
[16:01:45.331]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.331]  - attr(*, "already-done")= logi TRUE
[16:01:45.342] - copied ‘...future.FUN’ to environment
[16:01:45.342] - copied ‘future.call.arguments’ to environment
[16:01:45.342] - copied ‘...future.elements_ii’ to environment
[16:01:45.342] - copied ‘...future.seeds_ii’ to environment
[16:01:45.342] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.342] assign_globals() ... done
[16:01:45.342] plan(): Setting new future strategy stack:
[16:01:45.343] List of future strategies:
[16:01:45.343] 1. sequential:
[16:01:45.343]    - args: function (..., envir = parent.frame())
[16:01:45.343]    - tweaked: FALSE
[16:01:45.343]    - call: NULL
[16:01:45.343] plan(): nbrOfWorkers() = 1
[16:01:45.345] plan(): Setting new future strategy stack:
[16:01:45.345] List of future strategies:
[16:01:45.345] 1. multicore:
[16:01:45.345]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.345]    - tweaked: FALSE
[16:01:45.345]    - call: plan(strategy)
[16:01:45.349] plan(): nbrOfWorkers() = 1
[16:01:45.349] SequentialFuture started (and completed)
[16:01:45.349] - Launch lazy future ... done
[16:01:45.349] run() for ‘SequentialFuture’ ... done
[16:01:45.350] Created future:
[16:01:45.350] SequentialFuture:
[16:01:45.350] Label: ‘future_by-1’
[16:01:45.350] Expression:
[16:01:45.350] {
[16:01:45.350]     do.call(function(...) {
[16:01:45.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.350]             on.exit(options(oopts), add = TRUE)
[16:01:45.350]         }
[16:01:45.350]         {
[16:01:45.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.350]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.350]             })
[16:01:45.350]         }
[16:01:45.350]     }, args = future.call.arguments)
[16:01:45.350] }
[16:01:45.350] Lazy evaluation: FALSE
[16:01:45.350] Asynchronous evaluation: FALSE
[16:01:45.350] Local evaluation: TRUE
[16:01:45.350] Environment: 0x55b525c200f8
[16:01:45.350] Capture standard output: TRUE
[16:01:45.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.350] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.350] Packages: <none>
[16:01:45.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.350] Resolved: TRUE
[16:01:45.350] Value: 5.37 KiB of class ‘list’
[16:01:45.350] Early signaling: FALSE
[16:01:45.350] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.350] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.351] Chunk #1 of 1 ... DONE
[16:01:45.351] Launching 1 futures (chunks) ... DONE
[16:01:45.351] Resolving 1 futures (chunks) ...
[16:01:45.351] resolve() on list ...
[16:01:45.352]  recursive: 0
[16:01:45.352]  length: 1
[16:01:45.352] 
[16:01:45.352] resolved() for ‘SequentialFuture’ ...
[16:01:45.352] - state: ‘finished’
[16:01:45.352] - run: TRUE
[16:01:45.352] - result: ‘FutureResult’
[16:01:45.352] resolved() for ‘SequentialFuture’ ... done
[16:01:45.352] Future #1
[16:01:45.352] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.353] - nx: 1
[16:01:45.353] - relay: TRUE
[16:01:45.353] - stdout: TRUE
[16:01:45.353] - signal: TRUE
[16:01:45.353] - resignal: FALSE
[16:01:45.353] - force: TRUE
[16:01:45.353] - relayed: [n=1] FALSE
[16:01:45.353] - queued futures: [n=1] FALSE
[16:01:45.353]  - until=1
[16:01:45.353]  - relaying element #1
[16:01:45.354] - relayed: [n=1] TRUE
[16:01:45.354] - queued futures: [n=1] TRUE
[16:01:45.354] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.354]  length: 0 (resolved future 1)
[16:01:45.354] Relaying remaining futures
[16:01:45.354] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.354] - nx: 1
[16:01:45.354] - relay: TRUE
[16:01:45.354] - stdout: TRUE
[16:01:45.354] - signal: TRUE
[16:01:45.354] - resignal: FALSE
[16:01:45.354] - force: TRUE
[16:01:45.355] - relayed: [n=1] TRUE
[16:01:45.355] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.355] - relayed: [n=1] TRUE
[16:01:45.355] - queued futures: [n=1] TRUE
[16:01:45.355] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.355] resolve() on list ... DONE
[16:01:45.355]  - Number of value chunks collected: 1
[16:01:45.355] Resolving 1 futures (chunks) ... DONE
[16:01:45.355] Reducing values from 1 chunks ...
[16:01:45.356]  - Number of values collected after concatenation: 3
[16:01:45.356]  - Number of values expected: 3
[16:01:45.356] Reducing values from 1 chunks ... DONE
[16:01:45.356] future_lapply() ... DONE
[16:01:45.356] future_by_internal() ... DONE
[16:01:45.357] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:01:45.357] future_lapply() ...
[16:01:45.361] Number of chunks: 1
[16:01:45.361] getGlobalsAndPackagesXApply() ...
[16:01:45.361]  - future.globals: TRUE
[16:01:45.361] getGlobalsAndPackages() ...
[16:01:45.361] Searching for globals...
[16:01:45.362] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.363] Searching for globals ... DONE
[16:01:45.363] Resolving globals: FALSE
[16:01:45.363] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.363] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.364] - globals: [1] ‘FUN’
[16:01:45.364] 
[16:01:45.364] getGlobalsAndPackages() ... DONE
[16:01:45.364]  - globals found/used: [n=1] ‘FUN’
[16:01:45.364]  - needed namespaces: [n=0] 
[16:01:45.364] Finding globals ... DONE
[16:01:45.364]  - use_args: TRUE
[16:01:45.364]  - Getting '...' globals ...
[16:01:45.365] resolve() on list ...
[16:01:45.365]  recursive: 0
[16:01:45.365]  length: 1
[16:01:45.365]  elements: ‘...’
[16:01:45.365]  length: 0 (resolved future 1)
[16:01:45.365] resolve() on list ... DONE
[16:01:45.365]    - '...' content: [n=0] 
[16:01:45.365] List of 1
[16:01:45.365]  $ ...: list()
[16:01:45.365]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.365]  - attr(*, "where")=List of 1
[16:01:45.365]   ..$ ...:<environment: 0x55b525cadb48> 
[16:01:45.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.365]  - attr(*, "resolved")= logi TRUE
[16:01:45.365]  - attr(*, "total_size")= num NA
[16:01:45.370]  - Getting '...' globals ... DONE
[16:01:45.370] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.370] List of 2
[16:01:45.370]  $ ...future.FUN:function (object, ...)  
[16:01:45.370]  $ ...          : list()
[16:01:45.370]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.370]  - attr(*, "where")=List of 2
[16:01:45.370]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.370]   ..$ ...          :<environment: 0x55b525cadb48> 
[16:01:45.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.370]  - attr(*, "resolved")= logi FALSE
[16:01:45.370]  - attr(*, "total_size")= num 1240
[16:01:45.373] Packages to be attached in all futures: [n=0] 
[16:01:45.373] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.373] Number of futures (= number of chunks): 1
[16:01:45.373] Launching 1 futures (chunks) ...
[16:01:45.374] Chunk #1 of 1 ...
[16:01:45.374]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.374] getGlobalsAndPackages() ...
[16:01:45.374] Searching for globals...
[16:01:45.374] 
[16:01:45.374] Searching for globals ... DONE
[16:01:45.375] - globals: [0] <none>
[16:01:45.375] getGlobalsAndPackages() ... DONE
[16:01:45.375]    + additional globals found: [n=0] 
[16:01:45.375]    + additional namespaces needed: [n=0] 
[16:01:45.375]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.375]  - seeds: <none>
[16:01:45.375]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.375] getGlobalsAndPackages() ...
[16:01:45.375] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.375] Resolving globals: FALSE
[16:01:45.376] Tweak future expression to call with '...' arguments ...
[16:01:45.376] {
[16:01:45.376]     do.call(function(...) {
[16:01:45.376]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.376]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.376]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.376]             on.exit(options(oopts), add = TRUE)
[16:01:45.376]         }
[16:01:45.376]         {
[16:01:45.376]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.376]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.376]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.376]             })
[16:01:45.376]         }
[16:01:45.376]     }, args = future.call.arguments)
[16:01:45.376] }
[16:01:45.376] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.376] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.376] 
[16:01:45.377] getGlobalsAndPackages() ... DONE
[16:01:45.377] run() for ‘Future’ ...
[16:01:45.377] - state: ‘created’
[16:01:45.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.381] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.381]   - Field: ‘label’
[16:01:45.381]   - Field: ‘local’
[16:01:45.381]   - Field: ‘owner’
[16:01:45.381]   - Field: ‘envir’
[16:01:45.382]   - Field: ‘packages’
[16:01:45.382]   - Field: ‘gc’
[16:01:45.382]   - Field: ‘conditions’
[16:01:45.382]   - Field: ‘expr’
[16:01:45.382]   - Field: ‘uuid’
[16:01:45.382]   - Field: ‘seed’
[16:01:45.382]   - Field: ‘version’
[16:01:45.382]   - Field: ‘result’
[16:01:45.382]   - Field: ‘asynchronous’
[16:01:45.382]   - Field: ‘calls’
[16:01:45.383]   - Field: ‘globals’
[16:01:45.383]   - Field: ‘stdout’
[16:01:45.383]   - Field: ‘earlySignal’
[16:01:45.383]   - Field: ‘lazy’
[16:01:45.383]   - Field: ‘state’
[16:01:45.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.383] - Launch lazy future ...
[16:01:45.383] Packages needed by the future expression (n = 0): <none>
[16:01:45.383] Packages needed by future strategies (n = 0): <none>
[16:01:45.384] {
[16:01:45.384]     {
[16:01:45.384]         {
[16:01:45.384]             ...future.startTime <- base::Sys.time()
[16:01:45.384]             {
[16:01:45.384]                 {
[16:01:45.384]                   {
[16:01:45.384]                     base::local({
[16:01:45.384]                       has_future <- base::requireNamespace("future", 
[16:01:45.384]                         quietly = TRUE)
[16:01:45.384]                       if (has_future) {
[16:01:45.384]                         ns <- base::getNamespace("future")
[16:01:45.384]                         version <- ns[[".package"]][["version"]]
[16:01:45.384]                         if (is.null(version)) 
[16:01:45.384]                           version <- utils::packageVersion("future")
[16:01:45.384]                       }
[16:01:45.384]                       else {
[16:01:45.384]                         version <- NULL
[16:01:45.384]                       }
[16:01:45.384]                       if (!has_future || version < "1.8.0") {
[16:01:45.384]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.384]                           "", base::R.version$version.string), 
[16:01:45.384]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.384]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.384]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.384]                             "release", "version")], collapse = " "), 
[16:01:45.384]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.384]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.384]                           info)
[16:01:45.384]                         info <- base::paste(info, collapse = "; ")
[16:01:45.384]                         if (!has_future) {
[16:01:45.384]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.384]                             info)
[16:01:45.384]                         }
[16:01:45.384]                         else {
[16:01:45.384]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.384]                             info, version)
[16:01:45.384]                         }
[16:01:45.384]                         base::stop(msg)
[16:01:45.384]                       }
[16:01:45.384]                     })
[16:01:45.384]                   }
[16:01:45.384]                   options(future.plan = NULL)
[16:01:45.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.384]                 }
[16:01:45.384]                 ...future.workdir <- getwd()
[16:01:45.384]             }
[16:01:45.384]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.384]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.384]         }
[16:01:45.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.384]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.384]             base::names(...future.oldOptions))
[16:01:45.384]     }
[16:01:45.384]     if (FALSE) {
[16:01:45.384]     }
[16:01:45.384]     else {
[16:01:45.384]         if (TRUE) {
[16:01:45.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.384]                 open = "w")
[16:01:45.384]         }
[16:01:45.384]         else {
[16:01:45.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.384]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.384]         }
[16:01:45.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.384]             base::sink(type = "output", split = FALSE)
[16:01:45.384]             base::close(...future.stdout)
[16:01:45.384]         }, add = TRUE)
[16:01:45.384]     }
[16:01:45.384]     ...future.frame <- base::sys.nframe()
[16:01:45.384]     ...future.conditions <- base::list()
[16:01:45.384]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.384]     if (FALSE) {
[16:01:45.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.384]     }
[16:01:45.384]     ...future.result <- base::tryCatch({
[16:01:45.384]         base::withCallingHandlers({
[16:01:45.384]             ...future.value <- base::withVisible(base::local({
[16:01:45.384]                 do.call(function(...) {
[16:01:45.384]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.384]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.384]                     ...future.globals.maxSize)) {
[16:01:45.384]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.384]                     on.exit(options(oopts), add = TRUE)
[16:01:45.384]                   }
[16:01:45.384]                   {
[16:01:45.384]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.384]                       FUN = function(jj) {
[16:01:45.384]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.384]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.384]                       })
[16:01:45.384]                   }
[16:01:45.384]                 }, args = future.call.arguments)
[16:01:45.384]             }))
[16:01:45.384]             future::FutureResult(value = ...future.value$value, 
[16:01:45.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.384]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.384]                     ...future.globalenv.names))
[16:01:45.384]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.384]         }, condition = base::local({
[16:01:45.384]             c <- base::c
[16:01:45.384]             inherits <- base::inherits
[16:01:45.384]             invokeRestart <- base::invokeRestart
[16:01:45.384]             length <- base::length
[16:01:45.384]             list <- base::list
[16:01:45.384]             seq.int <- base::seq.int
[16:01:45.384]             signalCondition <- base::signalCondition
[16:01:45.384]             sys.calls <- base::sys.calls
[16:01:45.384]             `[[` <- base::`[[`
[16:01:45.384]             `+` <- base::`+`
[16:01:45.384]             `<<-` <- base::`<<-`
[16:01:45.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.384]                   3L)]
[16:01:45.384]             }
[16:01:45.384]             function(cond) {
[16:01:45.384]                 is_error <- inherits(cond, "error")
[16:01:45.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.384]                   NULL)
[16:01:45.384]                 if (is_error) {
[16:01:45.384]                   sessionInformation <- function() {
[16:01:45.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.384]                       search = base::search(), system = base::Sys.info())
[16:01:45.384]                   }
[16:01:45.384]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.384]                     cond$call), session = sessionInformation(), 
[16:01:45.384]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.384]                   signalCondition(cond)
[16:01:45.384]                 }
[16:01:45.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.384]                 "immediateCondition"))) {
[16:01:45.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.384]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.384]                   if (TRUE && !signal) {
[16:01:45.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.384]                     {
[16:01:45.384]                       inherits <- base::inherits
[16:01:45.384]                       invokeRestart <- base::invokeRestart
[16:01:45.384]                       is.null <- base::is.null
[16:01:45.384]                       muffled <- FALSE
[16:01:45.384]                       if (inherits(cond, "message")) {
[16:01:45.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.384]                         if (muffled) 
[16:01:45.384]                           invokeRestart("muffleMessage")
[16:01:45.384]                       }
[16:01:45.384]                       else if (inherits(cond, "warning")) {
[16:01:45.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.384]                         if (muffled) 
[16:01:45.384]                           invokeRestart("muffleWarning")
[16:01:45.384]                       }
[16:01:45.384]                       else if (inherits(cond, "condition")) {
[16:01:45.384]                         if (!is.null(pattern)) {
[16:01:45.384]                           computeRestarts <- base::computeRestarts
[16:01:45.384]                           grepl <- base::grepl
[16:01:45.384]                           restarts <- computeRestarts(cond)
[16:01:45.384]                           for (restart in restarts) {
[16:01:45.384]                             name <- restart$name
[16:01:45.384]                             if (is.null(name)) 
[16:01:45.384]                               next
[16:01:45.384]                             if (!grepl(pattern, name)) 
[16:01:45.384]                               next
[16:01:45.384]                             invokeRestart(restart)
[16:01:45.384]                             muffled <- TRUE
[16:01:45.384]                             break
[16:01:45.384]                           }
[16:01:45.384]                         }
[16:01:45.384]                       }
[16:01:45.384]                       invisible(muffled)
[16:01:45.384]                     }
[16:01:45.384]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.384]                   }
[16:01:45.384]                 }
[16:01:45.384]                 else {
[16:01:45.384]                   if (TRUE) {
[16:01:45.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.384]                     {
[16:01:45.384]                       inherits <- base::inherits
[16:01:45.384]                       invokeRestart <- base::invokeRestart
[16:01:45.384]                       is.null <- base::is.null
[16:01:45.384]                       muffled <- FALSE
[16:01:45.384]                       if (inherits(cond, "message")) {
[16:01:45.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.384]                         if (muffled) 
[16:01:45.384]                           invokeRestart("muffleMessage")
[16:01:45.384]                       }
[16:01:45.384]                       else if (inherits(cond, "warning")) {
[16:01:45.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.384]                         if (muffled) 
[16:01:45.384]                           invokeRestart("muffleWarning")
[16:01:45.384]                       }
[16:01:45.384]                       else if (inherits(cond, "condition")) {
[16:01:45.384]                         if (!is.null(pattern)) {
[16:01:45.384]                           computeRestarts <- base::computeRestarts
[16:01:45.384]                           grepl <- base::grepl
[16:01:45.384]                           restarts <- computeRestarts(cond)
[16:01:45.384]                           for (restart in restarts) {
[16:01:45.384]                             name <- restart$name
[16:01:45.384]                             if (is.null(name)) 
[16:01:45.384]                               next
[16:01:45.384]                             if (!grepl(pattern, name)) 
[16:01:45.384]                               next
[16:01:45.384]                             invokeRestart(restart)
[16:01:45.384]                             muffled <- TRUE
[16:01:45.384]                             break
[16:01:45.384]                           }
[16:01:45.384]                         }
[16:01:45.384]                       }
[16:01:45.384]                       invisible(muffled)
[16:01:45.384]                     }
[16:01:45.384]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.384]                   }
[16:01:45.384]                 }
[16:01:45.384]             }
[16:01:45.384]         }))
[16:01:45.384]     }, error = function(ex) {
[16:01:45.384]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.384]                 ...future.rng), started = ...future.startTime, 
[16:01:45.384]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.384]             version = "1.8"), class = "FutureResult")
[16:01:45.384]     }, finally = {
[16:01:45.384]         if (!identical(...future.workdir, getwd())) 
[16:01:45.384]             setwd(...future.workdir)
[16:01:45.384]         {
[16:01:45.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.384]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.384]             }
[16:01:45.384]             base::options(...future.oldOptions)
[16:01:45.384]             if (.Platform$OS.type == "windows") {
[16:01:45.384]                 old_names <- names(...future.oldEnvVars)
[16:01:45.384]                 envs <- base::Sys.getenv()
[16:01:45.384]                 names <- names(envs)
[16:01:45.384]                 common <- intersect(names, old_names)
[16:01:45.384]                 added <- setdiff(names, old_names)
[16:01:45.384]                 removed <- setdiff(old_names, names)
[16:01:45.384]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.384]                   envs[common]]
[16:01:45.384]                 NAMES <- toupper(changed)
[16:01:45.384]                 args <- list()
[16:01:45.384]                 for (kk in seq_along(NAMES)) {
[16:01:45.384]                   name <- changed[[kk]]
[16:01:45.384]                   NAME <- NAMES[[kk]]
[16:01:45.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.384]                     next
[16:01:45.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.384]                 }
[16:01:45.384]                 NAMES <- toupper(added)
[16:01:45.384]                 for (kk in seq_along(NAMES)) {
[16:01:45.384]                   name <- added[[kk]]
[16:01:45.384]                   NAME <- NAMES[[kk]]
[16:01:45.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.384]                     next
[16:01:45.384]                   args[[name]] <- ""
[16:01:45.384]                 }
[16:01:45.384]                 NAMES <- toupper(removed)
[16:01:45.384]                 for (kk in seq_along(NAMES)) {
[16:01:45.384]                   name <- removed[[kk]]
[16:01:45.384]                   NAME <- NAMES[[kk]]
[16:01:45.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.384]                     next
[16:01:45.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.384]                 }
[16:01:45.384]                 if (length(args) > 0) 
[16:01:45.384]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.384]             }
[16:01:45.384]             else {
[16:01:45.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.384]             }
[16:01:45.384]             {
[16:01:45.384]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.384]                   0L) {
[16:01:45.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.384]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.384]                   base::options(opts)
[16:01:45.384]                 }
[16:01:45.384]                 {
[16:01:45.384]                   {
[16:01:45.384]                     NULL
[16:01:45.384]                     RNGkind("Mersenne-Twister")
[16:01:45.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.384]                       inherits = FALSE)
[16:01:45.384]                   }
[16:01:45.384]                   options(future.plan = NULL)
[16:01:45.384]                   if (is.na(NA_character_)) 
[16:01:45.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.384]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:45.384]                     envir = parent.frame()) 
[16:01:45.384]                   {
[16:01:45.384]                     default_workers <- missing(workers)
[16:01:45.384]                     if (is.function(workers)) 
[16:01:45.384]                       workers <- workers()
[16:01:45.384]                     workers <- structure(as.integer(workers), 
[16:01:45.384]                       class = class(workers))
[16:01:45.384]                     stop_if_not(is.finite(workers), workers >= 
[16:01:45.384]                       1L)
[16:01:45.384]                     if ((workers == 1L && !inherits(workers, 
[16:01:45.384]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:45.384]                       if (default_workers) 
[16:01:45.384]                         supportsMulticore(warn = TRUE)
[16:01:45.384]                       return(sequential(..., envir = envir))
[16:01:45.384]                     }
[16:01:45.384]                     oopts <- options(mc.cores = workers)
[16:01:45.384]                     on.exit(options(oopts))
[16:01:45.384]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:45.384]                       envir = envir)
[16:01:45.384]                     if (!future$lazy) 
[16:01:45.384]                       future <- run(future)
[16:01:45.384]                     invisible(future)
[16:01:45.384]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.384]                 }
[16:01:45.384]             }
[16:01:45.384]         }
[16:01:45.384]     })
[16:01:45.384]     if (TRUE) {
[16:01:45.384]         base::sink(type = "output", split = FALSE)
[16:01:45.384]         if (TRUE) {
[16:01:45.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.384]         }
[16:01:45.384]         else {
[16:01:45.384]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.384]         }
[16:01:45.384]         base::close(...future.stdout)
[16:01:45.384]         ...future.stdout <- NULL
[16:01:45.384]     }
[16:01:45.384]     ...future.result$conditions <- ...future.conditions
[16:01:45.384]     ...future.result$finished <- base::Sys.time()
[16:01:45.384]     ...future.result
[16:01:45.384] }
[16:01:45.386] assign_globals() ...
[16:01:45.386] List of 5
[16:01:45.386]  $ ...future.FUN            :function (object, ...)  
[16:01:45.386]  $ future.call.arguments    : list()
[16:01:45.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.386]  $ ...future.elements_ii    :List of 3
[16:01:45.386]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.386]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.386]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.386]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.386]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.386]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.386]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.386]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.386]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.386]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.386]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.386]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.386]  $ ...future.seeds_ii       : NULL
[16:01:45.386]  $ ...future.globals.maxSize: NULL
[16:01:45.386]  - attr(*, "where")=List of 5
[16:01:45.386]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.386]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.386]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.386]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.386]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.386]  - attr(*, "resolved")= logi FALSE
[16:01:45.386]  - attr(*, "total_size")= num 1240
[16:01:45.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.386]  - attr(*, "already-done")= logi TRUE
[16:01:45.397] - copied ‘...future.FUN’ to environment
[16:01:45.397] - copied ‘future.call.arguments’ to environment
[16:01:45.397] - copied ‘...future.elements_ii’ to environment
[16:01:45.397] - copied ‘...future.seeds_ii’ to environment
[16:01:45.397] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.397] assign_globals() ... done
[16:01:45.398] plan(): Setting new future strategy stack:
[16:01:45.398] List of future strategies:
[16:01:45.398] 1. sequential:
[16:01:45.398]    - args: function (..., envir = parent.frame())
[16:01:45.398]    - tweaked: FALSE
[16:01:45.398]    - call: NULL
[16:01:45.398] plan(): nbrOfWorkers() = 1
[16:01:45.400] plan(): Setting new future strategy stack:
[16:01:45.400] List of future strategies:
[16:01:45.400] 1. multicore:
[16:01:45.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:45.400]    - tweaked: FALSE
[16:01:45.400]    - call: plan(strategy)
[16:01:45.404] plan(): nbrOfWorkers() = 1
[16:01:45.404] SequentialFuture started (and completed)
[16:01:45.404] - Launch lazy future ... done
[16:01:45.405] run() for ‘SequentialFuture’ ... done
[16:01:45.405] Created future:
[16:01:45.405] SequentialFuture:
[16:01:45.405] Label: ‘future_by-1’
[16:01:45.405] Expression:
[16:01:45.405] {
[16:01:45.405]     do.call(function(...) {
[16:01:45.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.405]             on.exit(options(oopts), add = TRUE)
[16:01:45.405]         }
[16:01:45.405]         {
[16:01:45.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.405]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.405]             })
[16:01:45.405]         }
[16:01:45.405]     }, args = future.call.arguments)
[16:01:45.405] }
[16:01:45.405] Lazy evaluation: FALSE
[16:01:45.405] Asynchronous evaluation: FALSE
[16:01:45.405] Local evaluation: TRUE
[16:01:45.405] Environment: 0x55b525c70440
[16:01:45.405] Capture standard output: TRUE
[16:01:45.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.405] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.405] Packages: <none>
[16:01:45.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.405] Resolved: TRUE
[16:01:45.405] Value: 5.37 KiB of class ‘list’
[16:01:45.405] Early signaling: FALSE
[16:01:45.405] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.405] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.406] Chunk #1 of 1 ... DONE
[16:01:45.406] Launching 1 futures (chunks) ... DONE
[16:01:45.406] Resolving 1 futures (chunks) ...
[16:01:45.406] resolve() on list ...
[16:01:45.407]  recursive: 0
[16:01:45.407]  length: 1
[16:01:45.407] 
[16:01:45.407] resolved() for ‘SequentialFuture’ ...
[16:01:45.407] - state: ‘finished’
[16:01:45.407] - run: TRUE
[16:01:45.407] - result: ‘FutureResult’
[16:01:45.407] resolved() for ‘SequentialFuture’ ... done
[16:01:45.407] Future #1
[16:01:45.408] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.408] - nx: 1
[16:01:45.408] - relay: TRUE
[16:01:45.408] - stdout: TRUE
[16:01:45.408] - signal: TRUE
[16:01:45.408] - resignal: FALSE
[16:01:45.408] - force: TRUE
[16:01:45.408] - relayed: [n=1] FALSE
[16:01:45.408] - queued futures: [n=1] FALSE
[16:01:45.408]  - until=1
[16:01:45.408]  - relaying element #1
[16:01:45.409] - relayed: [n=1] TRUE
[16:01:45.409] - queued futures: [n=1] TRUE
[16:01:45.409] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.409]  length: 0 (resolved future 1)
[16:01:45.409] Relaying remaining futures
[16:01:45.409] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.409] - nx: 1
[16:01:45.409] - relay: TRUE
[16:01:45.409] - stdout: TRUE
[16:01:45.409] - signal: TRUE
[16:01:45.409] - resignal: FALSE
[16:01:45.410] - force: TRUE
[16:01:45.410] - relayed: [n=1] TRUE
[16:01:45.410] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.410] - relayed: [n=1] TRUE
[16:01:45.410] - queued futures: [n=1] TRUE
[16:01:45.410] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.410] resolve() on list ... DONE
[16:01:45.410]  - Number of value chunks collected: 1
[16:01:45.410] Resolving 1 futures (chunks) ... DONE
[16:01:45.410] Reducing values from 1 chunks ...
[16:01:45.411]  - Number of values collected after concatenation: 3
[16:01:45.411]  - Number of values expected: 3
[16:01:45.411] Reducing values from 1 chunks ... DONE
[16:01:45.411] future_lapply() ... DONE
[16:01:45.411] future_by_internal() ... DONE
[16:01:45.412] future_by_internal() ...
- plan('multisession') ...
[16:01:45.412] plan(): Setting new future strategy stack:
[16:01:45.413] List of future strategies:
[16:01:45.413] 1. multisession:
[16:01:45.413]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.413]    - tweaked: FALSE
[16:01:45.413]    - call: plan(strategy)
[16:01:45.413] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:01:45.413] multisession:
[16:01:45.413] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.413] - tweaked: FALSE
[16:01:45.413] - call: plan(strategy)
[16:01:45.417] getGlobalsAndPackages() ...
[16:01:45.417] Not searching for globals
[16:01:45.417] - globals: [0] <none>
[16:01:45.417] getGlobalsAndPackages() ... DONE
[16:01:45.418] Packages needed by the future expression (n = 0): <none>
[16:01:45.418] Packages needed by future strategies (n = 0): <none>
[16:01:45.418] {
[16:01:45.418]     {
[16:01:45.418]         {
[16:01:45.418]             ...future.startTime <- base::Sys.time()
[16:01:45.418]             {
[16:01:45.418]                 {
[16:01:45.418]                   {
[16:01:45.418]                     base::local({
[16:01:45.418]                       has_future <- base::requireNamespace("future", 
[16:01:45.418]                         quietly = TRUE)
[16:01:45.418]                       if (has_future) {
[16:01:45.418]                         ns <- base::getNamespace("future")
[16:01:45.418]                         version <- ns[[".package"]][["version"]]
[16:01:45.418]                         if (is.null(version)) 
[16:01:45.418]                           version <- utils::packageVersion("future")
[16:01:45.418]                       }
[16:01:45.418]                       else {
[16:01:45.418]                         version <- NULL
[16:01:45.418]                       }
[16:01:45.418]                       if (!has_future || version < "1.8.0") {
[16:01:45.418]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.418]                           "", base::R.version$version.string), 
[16:01:45.418]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.418]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.418]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.418]                             "release", "version")], collapse = " "), 
[16:01:45.418]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.418]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.418]                           info)
[16:01:45.418]                         info <- base::paste(info, collapse = "; ")
[16:01:45.418]                         if (!has_future) {
[16:01:45.418]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.418]                             info)
[16:01:45.418]                         }
[16:01:45.418]                         else {
[16:01:45.418]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.418]                             info, version)
[16:01:45.418]                         }
[16:01:45.418]                         base::stop(msg)
[16:01:45.418]                       }
[16:01:45.418]                     })
[16:01:45.418]                   }
[16:01:45.418]                   options(future.plan = NULL)
[16:01:45.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.418]                 }
[16:01:45.418]                 ...future.workdir <- getwd()
[16:01:45.418]             }
[16:01:45.418]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.418]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.418]         }
[16:01:45.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.418]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.418]             base::names(...future.oldOptions))
[16:01:45.418]     }
[16:01:45.418]     if (FALSE) {
[16:01:45.418]     }
[16:01:45.418]     else {
[16:01:45.418]         if (TRUE) {
[16:01:45.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.418]                 open = "w")
[16:01:45.418]         }
[16:01:45.418]         else {
[16:01:45.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.418]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.418]         }
[16:01:45.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.418]             base::sink(type = "output", split = FALSE)
[16:01:45.418]             base::close(...future.stdout)
[16:01:45.418]         }, add = TRUE)
[16:01:45.418]     }
[16:01:45.418]     ...future.frame <- base::sys.nframe()
[16:01:45.418]     ...future.conditions <- base::list()
[16:01:45.418]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.418]     if (FALSE) {
[16:01:45.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.418]     }
[16:01:45.418]     ...future.result <- base::tryCatch({
[16:01:45.418]         base::withCallingHandlers({
[16:01:45.418]             ...future.value <- base::withVisible(base::local(NA))
[16:01:45.418]             future::FutureResult(value = ...future.value$value, 
[16:01:45.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.418]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.418]                     ...future.globalenv.names))
[16:01:45.418]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.418]         }, condition = base::local({
[16:01:45.418]             c <- base::c
[16:01:45.418]             inherits <- base::inherits
[16:01:45.418]             invokeRestart <- base::invokeRestart
[16:01:45.418]             length <- base::length
[16:01:45.418]             list <- base::list
[16:01:45.418]             seq.int <- base::seq.int
[16:01:45.418]             signalCondition <- base::signalCondition
[16:01:45.418]             sys.calls <- base::sys.calls
[16:01:45.418]             `[[` <- base::`[[`
[16:01:45.418]             `+` <- base::`+`
[16:01:45.418]             `<<-` <- base::`<<-`
[16:01:45.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.418]                   3L)]
[16:01:45.418]             }
[16:01:45.418]             function(cond) {
[16:01:45.418]                 is_error <- inherits(cond, "error")
[16:01:45.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.418]                   NULL)
[16:01:45.418]                 if (is_error) {
[16:01:45.418]                   sessionInformation <- function() {
[16:01:45.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.418]                       search = base::search(), system = base::Sys.info())
[16:01:45.418]                   }
[16:01:45.418]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.418]                     cond$call), session = sessionInformation(), 
[16:01:45.418]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.418]                   signalCondition(cond)
[16:01:45.418]                 }
[16:01:45.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.418]                 "immediateCondition"))) {
[16:01:45.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.418]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.418]                   if (TRUE && !signal) {
[16:01:45.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.418]                     {
[16:01:45.418]                       inherits <- base::inherits
[16:01:45.418]                       invokeRestart <- base::invokeRestart
[16:01:45.418]                       is.null <- base::is.null
[16:01:45.418]                       muffled <- FALSE
[16:01:45.418]                       if (inherits(cond, "message")) {
[16:01:45.418]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.418]                         if (muffled) 
[16:01:45.418]                           invokeRestart("muffleMessage")
[16:01:45.418]                       }
[16:01:45.418]                       else if (inherits(cond, "warning")) {
[16:01:45.418]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.418]                         if (muffled) 
[16:01:45.418]                           invokeRestart("muffleWarning")
[16:01:45.418]                       }
[16:01:45.418]                       else if (inherits(cond, "condition")) {
[16:01:45.418]                         if (!is.null(pattern)) {
[16:01:45.418]                           computeRestarts <- base::computeRestarts
[16:01:45.418]                           grepl <- base::grepl
[16:01:45.418]                           restarts <- computeRestarts(cond)
[16:01:45.418]                           for (restart in restarts) {
[16:01:45.418]                             name <- restart$name
[16:01:45.418]                             if (is.null(name)) 
[16:01:45.418]                               next
[16:01:45.418]                             if (!grepl(pattern, name)) 
[16:01:45.418]                               next
[16:01:45.418]                             invokeRestart(restart)
[16:01:45.418]                             muffled <- TRUE
[16:01:45.418]                             break
[16:01:45.418]                           }
[16:01:45.418]                         }
[16:01:45.418]                       }
[16:01:45.418]                       invisible(muffled)
[16:01:45.418]                     }
[16:01:45.418]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.418]                   }
[16:01:45.418]                 }
[16:01:45.418]                 else {
[16:01:45.418]                   if (TRUE) {
[16:01:45.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.418]                     {
[16:01:45.418]                       inherits <- base::inherits
[16:01:45.418]                       invokeRestart <- base::invokeRestart
[16:01:45.418]                       is.null <- base::is.null
[16:01:45.418]                       muffled <- FALSE
[16:01:45.418]                       if (inherits(cond, "message")) {
[16:01:45.418]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.418]                         if (muffled) 
[16:01:45.418]                           invokeRestart("muffleMessage")
[16:01:45.418]                       }
[16:01:45.418]                       else if (inherits(cond, "warning")) {
[16:01:45.418]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.418]                         if (muffled) 
[16:01:45.418]                           invokeRestart("muffleWarning")
[16:01:45.418]                       }
[16:01:45.418]                       else if (inherits(cond, "condition")) {
[16:01:45.418]                         if (!is.null(pattern)) {
[16:01:45.418]                           computeRestarts <- base::computeRestarts
[16:01:45.418]                           grepl <- base::grepl
[16:01:45.418]                           restarts <- computeRestarts(cond)
[16:01:45.418]                           for (restart in restarts) {
[16:01:45.418]                             name <- restart$name
[16:01:45.418]                             if (is.null(name)) 
[16:01:45.418]                               next
[16:01:45.418]                             if (!grepl(pattern, name)) 
[16:01:45.418]                               next
[16:01:45.418]                             invokeRestart(restart)
[16:01:45.418]                             muffled <- TRUE
[16:01:45.418]                             break
[16:01:45.418]                           }
[16:01:45.418]                         }
[16:01:45.418]                       }
[16:01:45.418]                       invisible(muffled)
[16:01:45.418]                     }
[16:01:45.418]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.418]                   }
[16:01:45.418]                 }
[16:01:45.418]             }
[16:01:45.418]         }))
[16:01:45.418]     }, error = function(ex) {
[16:01:45.418]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.418]                 ...future.rng), started = ...future.startTime, 
[16:01:45.418]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.418]             version = "1.8"), class = "FutureResult")
[16:01:45.418]     }, finally = {
[16:01:45.418]         if (!identical(...future.workdir, getwd())) 
[16:01:45.418]             setwd(...future.workdir)
[16:01:45.418]         {
[16:01:45.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.418]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.418]             }
[16:01:45.418]             base::options(...future.oldOptions)
[16:01:45.418]             if (.Platform$OS.type == "windows") {
[16:01:45.418]                 old_names <- names(...future.oldEnvVars)
[16:01:45.418]                 envs <- base::Sys.getenv()
[16:01:45.418]                 names <- names(envs)
[16:01:45.418]                 common <- intersect(names, old_names)
[16:01:45.418]                 added <- setdiff(names, old_names)
[16:01:45.418]                 removed <- setdiff(old_names, names)
[16:01:45.418]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.418]                   envs[common]]
[16:01:45.418]                 NAMES <- toupper(changed)
[16:01:45.418]                 args <- list()
[16:01:45.418]                 for (kk in seq_along(NAMES)) {
[16:01:45.418]                   name <- changed[[kk]]
[16:01:45.418]                   NAME <- NAMES[[kk]]
[16:01:45.418]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.418]                     next
[16:01:45.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.418]                 }
[16:01:45.418]                 NAMES <- toupper(added)
[16:01:45.418]                 for (kk in seq_along(NAMES)) {
[16:01:45.418]                   name <- added[[kk]]
[16:01:45.418]                   NAME <- NAMES[[kk]]
[16:01:45.418]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.418]                     next
[16:01:45.418]                   args[[name]] <- ""
[16:01:45.418]                 }
[16:01:45.418]                 NAMES <- toupper(removed)
[16:01:45.418]                 for (kk in seq_along(NAMES)) {
[16:01:45.418]                   name <- removed[[kk]]
[16:01:45.418]                   NAME <- NAMES[[kk]]
[16:01:45.418]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.418]                     next
[16:01:45.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.418]                 }
[16:01:45.418]                 if (length(args) > 0) 
[16:01:45.418]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.418]             }
[16:01:45.418]             else {
[16:01:45.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.418]             }
[16:01:45.418]             {
[16:01:45.418]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.418]                   0L) {
[16:01:45.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.418]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.418]                   base::options(opts)
[16:01:45.418]                 }
[16:01:45.418]                 {
[16:01:45.418]                   {
[16:01:45.418]                     NULL
[16:01:45.418]                     RNGkind("Mersenne-Twister")
[16:01:45.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.418]                       inherits = FALSE)
[16:01:45.418]                   }
[16:01:45.418]                   options(future.plan = NULL)
[16:01:45.418]                   if (is.na(NA_character_)) 
[16:01:45.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.418]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.418]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.418]                     envir = parent.frame()) 
[16:01:45.418]                   {
[16:01:45.418]                     if (is.function(workers)) 
[16:01:45.418]                       workers <- workers()
[16:01:45.418]                     workers <- structure(as.integer(workers), 
[16:01:45.418]                       class = class(workers))
[16:01:45.418]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.418]                       workers >= 1)
[16:01:45.418]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.418]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.418]                     }
[16:01:45.418]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.418]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.418]                       envir = envir)
[16:01:45.418]                     if (!future$lazy) 
[16:01:45.418]                       future <- run(future)
[16:01:45.418]                     invisible(future)
[16:01:45.418]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.418]                 }
[16:01:45.418]             }
[16:01:45.418]         }
[16:01:45.418]     })
[16:01:45.418]     if (TRUE) {
[16:01:45.418]         base::sink(type = "output", split = FALSE)
[16:01:45.418]         if (TRUE) {
[16:01:45.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.418]         }
[16:01:45.418]         else {
[16:01:45.418]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.418]         }
[16:01:45.418]         base::close(...future.stdout)
[16:01:45.418]         ...future.stdout <- NULL
[16:01:45.418]     }
[16:01:45.418]     ...future.result$conditions <- ...future.conditions
[16:01:45.418]     ...future.result$finished <- base::Sys.time()
[16:01:45.418]     ...future.result
[16:01:45.418] }
[16:01:45.420] plan(): Setting new future strategy stack:
[16:01:45.420] List of future strategies:
[16:01:45.420] 1. sequential:
[16:01:45.420]    - args: function (..., envir = parent.frame())
[16:01:45.420]    - tweaked: FALSE
[16:01:45.420]    - call: NULL
[16:01:45.421] plan(): nbrOfWorkers() = 1
[16:01:45.421] plan(): Setting new future strategy stack:
[16:01:45.423] List of future strategies:
[16:01:45.423] 1. multisession:
[16:01:45.423]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.423]    - tweaked: FALSE
[16:01:45.423]    - call: plan(strategy)
[16:01:45.427] plan(): nbrOfWorkers() = 1
[16:01:45.427] SequentialFuture started (and completed)
[16:01:45.427] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:01:45.431] plan(): nbrOfWorkers() = 1
[16:01:45.431] future_by_internal() ...
[16:01:45.431] future_lapply() ...
[16:01:45.435] Number of chunks: 1
[16:01:45.435] getGlobalsAndPackagesXApply() ...
[16:01:45.435]  - future.globals: TRUE
[16:01:45.435] getGlobalsAndPackages() ...
[16:01:45.435] Searching for globals...
[16:01:45.436] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.437] Searching for globals ... DONE
[16:01:45.437] Resolving globals: FALSE
[16:01:45.437] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.437] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.438] - globals: [1] ‘FUN’
[16:01:45.438] 
[16:01:45.438] getGlobalsAndPackages() ... DONE
[16:01:45.438]  - globals found/used: [n=1] ‘FUN’
[16:01:45.438]  - needed namespaces: [n=0] 
[16:01:45.438] Finding globals ... DONE
[16:01:45.438]  - use_args: TRUE
[16:01:45.438]  - Getting '...' globals ...
[16:01:45.439] resolve() on list ...
[16:01:45.439]  recursive: 0
[16:01:45.439]  length: 1
[16:01:45.439]  elements: ‘...’
[16:01:45.439]  length: 0 (resolved future 1)
[16:01:45.439] resolve() on list ... DONE
[16:01:45.439]    - '...' content: [n=0] 
[16:01:45.439] List of 1
[16:01:45.439]  $ ...: list()
[16:01:45.439]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.439]  - attr(*, "where")=List of 1
[16:01:45.439]   ..$ ...:<environment: 0x55b524ff43b8> 
[16:01:45.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.439]  - attr(*, "resolved")= logi TRUE
[16:01:45.439]  - attr(*, "total_size")= num NA
[16:01:45.442]  - Getting '...' globals ... DONE
[16:01:45.442] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.442] List of 2
[16:01:45.442]  $ ...future.FUN:function (object, ...)  
[16:01:45.442]  $ ...          : list()
[16:01:45.442]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.442]  - attr(*, "where")=List of 2
[16:01:45.442]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.442]   ..$ ...          :<environment: 0x55b524ff43b8> 
[16:01:45.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.442]  - attr(*, "resolved")= logi FALSE
[16:01:45.442]  - attr(*, "total_size")= num 1240
[16:01:45.445] Packages to be attached in all futures: [n=0] 
[16:01:45.445] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.445] Number of futures (= number of chunks): 1
[16:01:45.445] Launching 1 futures (chunks) ...
[16:01:45.445] Chunk #1 of 1 ...
[16:01:45.446]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.446] getGlobalsAndPackages() ...
[16:01:45.446] Searching for globals...
[16:01:45.446] 
[16:01:45.446] Searching for globals ... DONE
[16:01:45.446] - globals: [0] <none>
[16:01:45.447] getGlobalsAndPackages() ... DONE
[16:01:45.447]    + additional globals found: [n=0] 
[16:01:45.447]    + additional namespaces needed: [n=0] 
[16:01:45.447]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.447]  - seeds: <none>
[16:01:45.447]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.447] getGlobalsAndPackages() ...
[16:01:45.447] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.447] Resolving globals: FALSE
[16:01:45.448] Tweak future expression to call with '...' arguments ...
[16:01:45.448] {
[16:01:45.448]     do.call(function(...) {
[16:01:45.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.448]             on.exit(options(oopts), add = TRUE)
[16:01:45.448]         }
[16:01:45.448]         {
[16:01:45.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.448]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.448]             })
[16:01:45.448]         }
[16:01:45.448]     }, args = future.call.arguments)
[16:01:45.448] }
[16:01:45.448] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.448] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.448] 
[16:01:45.448] getGlobalsAndPackages() ... DONE
[16:01:45.449] run() for ‘Future’ ...
[16:01:45.449] - state: ‘created’
[16:01:45.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.453] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.453]   - Field: ‘label’
[16:01:45.453]   - Field: ‘local’
[16:01:45.455]   - Field: ‘owner’
[16:01:45.455]   - Field: ‘envir’
[16:01:45.455]   - Field: ‘packages’
[16:01:45.455]   - Field: ‘gc’
[16:01:45.455]   - Field: ‘conditions’
[16:01:45.455]   - Field: ‘expr’
[16:01:45.456]   - Field: ‘uuid’
[16:01:45.456]   - Field: ‘seed’
[16:01:45.456]   - Field: ‘version’
[16:01:45.456]   - Field: ‘result’
[16:01:45.456]   - Field: ‘asynchronous’
[16:01:45.456]   - Field: ‘calls’
[16:01:45.456]   - Field: ‘globals’
[16:01:45.456]   - Field: ‘stdout’
[16:01:45.456]   - Field: ‘earlySignal’
[16:01:45.457]   - Field: ‘lazy’
[16:01:45.457]   - Field: ‘state’
[16:01:45.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.457] - Launch lazy future ...
[16:01:45.457] Packages needed by the future expression (n = 0): <none>
[16:01:45.457] Packages needed by future strategies (n = 0): <none>
[16:01:45.458] {
[16:01:45.458]     {
[16:01:45.458]         {
[16:01:45.458]             ...future.startTime <- base::Sys.time()
[16:01:45.458]             {
[16:01:45.458]                 {
[16:01:45.458]                   {
[16:01:45.458]                     base::local({
[16:01:45.458]                       has_future <- base::requireNamespace("future", 
[16:01:45.458]                         quietly = TRUE)
[16:01:45.458]                       if (has_future) {
[16:01:45.458]                         ns <- base::getNamespace("future")
[16:01:45.458]                         version <- ns[[".package"]][["version"]]
[16:01:45.458]                         if (is.null(version)) 
[16:01:45.458]                           version <- utils::packageVersion("future")
[16:01:45.458]                       }
[16:01:45.458]                       else {
[16:01:45.458]                         version <- NULL
[16:01:45.458]                       }
[16:01:45.458]                       if (!has_future || version < "1.8.0") {
[16:01:45.458]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.458]                           "", base::R.version$version.string), 
[16:01:45.458]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.458]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.458]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.458]                             "release", "version")], collapse = " "), 
[16:01:45.458]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.458]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.458]                           info)
[16:01:45.458]                         info <- base::paste(info, collapse = "; ")
[16:01:45.458]                         if (!has_future) {
[16:01:45.458]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.458]                             info)
[16:01:45.458]                         }
[16:01:45.458]                         else {
[16:01:45.458]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.458]                             info, version)
[16:01:45.458]                         }
[16:01:45.458]                         base::stop(msg)
[16:01:45.458]                       }
[16:01:45.458]                     })
[16:01:45.458]                   }
[16:01:45.458]                   options(future.plan = NULL)
[16:01:45.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.458]                 }
[16:01:45.458]                 ...future.workdir <- getwd()
[16:01:45.458]             }
[16:01:45.458]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.458]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.458]         }
[16:01:45.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.458]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.458]             base::names(...future.oldOptions))
[16:01:45.458]     }
[16:01:45.458]     if (FALSE) {
[16:01:45.458]     }
[16:01:45.458]     else {
[16:01:45.458]         if (TRUE) {
[16:01:45.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.458]                 open = "w")
[16:01:45.458]         }
[16:01:45.458]         else {
[16:01:45.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.458]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.458]         }
[16:01:45.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.458]             base::sink(type = "output", split = FALSE)
[16:01:45.458]             base::close(...future.stdout)
[16:01:45.458]         }, add = TRUE)
[16:01:45.458]     }
[16:01:45.458]     ...future.frame <- base::sys.nframe()
[16:01:45.458]     ...future.conditions <- base::list()
[16:01:45.458]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.458]     if (FALSE) {
[16:01:45.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.458]     }
[16:01:45.458]     ...future.result <- base::tryCatch({
[16:01:45.458]         base::withCallingHandlers({
[16:01:45.458]             ...future.value <- base::withVisible(base::local({
[16:01:45.458]                 do.call(function(...) {
[16:01:45.458]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.458]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.458]                     ...future.globals.maxSize)) {
[16:01:45.458]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.458]                     on.exit(options(oopts), add = TRUE)
[16:01:45.458]                   }
[16:01:45.458]                   {
[16:01:45.458]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.458]                       FUN = function(jj) {
[16:01:45.458]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.458]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.458]                       })
[16:01:45.458]                   }
[16:01:45.458]                 }, args = future.call.arguments)
[16:01:45.458]             }))
[16:01:45.458]             future::FutureResult(value = ...future.value$value, 
[16:01:45.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.458]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.458]                     ...future.globalenv.names))
[16:01:45.458]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.458]         }, condition = base::local({
[16:01:45.458]             c <- base::c
[16:01:45.458]             inherits <- base::inherits
[16:01:45.458]             invokeRestart <- base::invokeRestart
[16:01:45.458]             length <- base::length
[16:01:45.458]             list <- base::list
[16:01:45.458]             seq.int <- base::seq.int
[16:01:45.458]             signalCondition <- base::signalCondition
[16:01:45.458]             sys.calls <- base::sys.calls
[16:01:45.458]             `[[` <- base::`[[`
[16:01:45.458]             `+` <- base::`+`
[16:01:45.458]             `<<-` <- base::`<<-`
[16:01:45.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.458]                   3L)]
[16:01:45.458]             }
[16:01:45.458]             function(cond) {
[16:01:45.458]                 is_error <- inherits(cond, "error")
[16:01:45.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.458]                   NULL)
[16:01:45.458]                 if (is_error) {
[16:01:45.458]                   sessionInformation <- function() {
[16:01:45.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.458]                       search = base::search(), system = base::Sys.info())
[16:01:45.458]                   }
[16:01:45.458]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.458]                     cond$call), session = sessionInformation(), 
[16:01:45.458]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.458]                   signalCondition(cond)
[16:01:45.458]                 }
[16:01:45.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.458]                 "immediateCondition"))) {
[16:01:45.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.458]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.458]                   if (TRUE && !signal) {
[16:01:45.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.458]                     {
[16:01:45.458]                       inherits <- base::inherits
[16:01:45.458]                       invokeRestart <- base::invokeRestart
[16:01:45.458]                       is.null <- base::is.null
[16:01:45.458]                       muffled <- FALSE
[16:01:45.458]                       if (inherits(cond, "message")) {
[16:01:45.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.458]                         if (muffled) 
[16:01:45.458]                           invokeRestart("muffleMessage")
[16:01:45.458]                       }
[16:01:45.458]                       else if (inherits(cond, "warning")) {
[16:01:45.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.458]                         if (muffled) 
[16:01:45.458]                           invokeRestart("muffleWarning")
[16:01:45.458]                       }
[16:01:45.458]                       else if (inherits(cond, "condition")) {
[16:01:45.458]                         if (!is.null(pattern)) {
[16:01:45.458]                           computeRestarts <- base::computeRestarts
[16:01:45.458]                           grepl <- base::grepl
[16:01:45.458]                           restarts <- computeRestarts(cond)
[16:01:45.458]                           for (restart in restarts) {
[16:01:45.458]                             name <- restart$name
[16:01:45.458]                             if (is.null(name)) 
[16:01:45.458]                               next
[16:01:45.458]                             if (!grepl(pattern, name)) 
[16:01:45.458]                               next
[16:01:45.458]                             invokeRestart(restart)
[16:01:45.458]                             muffled <- TRUE
[16:01:45.458]                             break
[16:01:45.458]                           }
[16:01:45.458]                         }
[16:01:45.458]                       }
[16:01:45.458]                       invisible(muffled)
[16:01:45.458]                     }
[16:01:45.458]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.458]                   }
[16:01:45.458]                 }
[16:01:45.458]                 else {
[16:01:45.458]                   if (TRUE) {
[16:01:45.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.458]                     {
[16:01:45.458]                       inherits <- base::inherits
[16:01:45.458]                       invokeRestart <- base::invokeRestart
[16:01:45.458]                       is.null <- base::is.null
[16:01:45.458]                       muffled <- FALSE
[16:01:45.458]                       if (inherits(cond, "message")) {
[16:01:45.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.458]                         if (muffled) 
[16:01:45.458]                           invokeRestart("muffleMessage")
[16:01:45.458]                       }
[16:01:45.458]                       else if (inherits(cond, "warning")) {
[16:01:45.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.458]                         if (muffled) 
[16:01:45.458]                           invokeRestart("muffleWarning")
[16:01:45.458]                       }
[16:01:45.458]                       else if (inherits(cond, "condition")) {
[16:01:45.458]                         if (!is.null(pattern)) {
[16:01:45.458]                           computeRestarts <- base::computeRestarts
[16:01:45.458]                           grepl <- base::grepl
[16:01:45.458]                           restarts <- computeRestarts(cond)
[16:01:45.458]                           for (restart in restarts) {
[16:01:45.458]                             name <- restart$name
[16:01:45.458]                             if (is.null(name)) 
[16:01:45.458]                               next
[16:01:45.458]                             if (!grepl(pattern, name)) 
[16:01:45.458]                               next
[16:01:45.458]                             invokeRestart(restart)
[16:01:45.458]                             muffled <- TRUE
[16:01:45.458]                             break
[16:01:45.458]                           }
[16:01:45.458]                         }
[16:01:45.458]                       }
[16:01:45.458]                       invisible(muffled)
[16:01:45.458]                     }
[16:01:45.458]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.458]                   }
[16:01:45.458]                 }
[16:01:45.458]             }
[16:01:45.458]         }))
[16:01:45.458]     }, error = function(ex) {
[16:01:45.458]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.458]                 ...future.rng), started = ...future.startTime, 
[16:01:45.458]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.458]             version = "1.8"), class = "FutureResult")
[16:01:45.458]     }, finally = {
[16:01:45.458]         if (!identical(...future.workdir, getwd())) 
[16:01:45.458]             setwd(...future.workdir)
[16:01:45.458]         {
[16:01:45.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.458]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.458]             }
[16:01:45.458]             base::options(...future.oldOptions)
[16:01:45.458]             if (.Platform$OS.type == "windows") {
[16:01:45.458]                 old_names <- names(...future.oldEnvVars)
[16:01:45.458]                 envs <- base::Sys.getenv()
[16:01:45.458]                 names <- names(envs)
[16:01:45.458]                 common <- intersect(names, old_names)
[16:01:45.458]                 added <- setdiff(names, old_names)
[16:01:45.458]                 removed <- setdiff(old_names, names)
[16:01:45.458]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.458]                   envs[common]]
[16:01:45.458]                 NAMES <- toupper(changed)
[16:01:45.458]                 args <- list()
[16:01:45.458]                 for (kk in seq_along(NAMES)) {
[16:01:45.458]                   name <- changed[[kk]]
[16:01:45.458]                   NAME <- NAMES[[kk]]
[16:01:45.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.458]                     next
[16:01:45.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.458]                 }
[16:01:45.458]                 NAMES <- toupper(added)
[16:01:45.458]                 for (kk in seq_along(NAMES)) {
[16:01:45.458]                   name <- added[[kk]]
[16:01:45.458]                   NAME <- NAMES[[kk]]
[16:01:45.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.458]                     next
[16:01:45.458]                   args[[name]] <- ""
[16:01:45.458]                 }
[16:01:45.458]                 NAMES <- toupper(removed)
[16:01:45.458]                 for (kk in seq_along(NAMES)) {
[16:01:45.458]                   name <- removed[[kk]]
[16:01:45.458]                   NAME <- NAMES[[kk]]
[16:01:45.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.458]                     next
[16:01:45.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.458]                 }
[16:01:45.458]                 if (length(args) > 0) 
[16:01:45.458]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.458]             }
[16:01:45.458]             else {
[16:01:45.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.458]             }
[16:01:45.458]             {
[16:01:45.458]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.458]                   0L) {
[16:01:45.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.458]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.458]                   base::options(opts)
[16:01:45.458]                 }
[16:01:45.458]                 {
[16:01:45.458]                   {
[16:01:45.458]                     NULL
[16:01:45.458]                     RNGkind("Mersenne-Twister")
[16:01:45.458]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.458]                       inherits = FALSE)
[16:01:45.458]                   }
[16:01:45.458]                   options(future.plan = NULL)
[16:01:45.458]                   if (is.na(NA_character_)) 
[16:01:45.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.458]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.458]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.458]                     envir = parent.frame()) 
[16:01:45.458]                   {
[16:01:45.458]                     if (is.function(workers)) 
[16:01:45.458]                       workers <- workers()
[16:01:45.458]                     workers <- structure(as.integer(workers), 
[16:01:45.458]                       class = class(workers))
[16:01:45.458]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.458]                       workers >= 1)
[16:01:45.458]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.458]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.458]                     }
[16:01:45.458]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.458]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.458]                       envir = envir)
[16:01:45.458]                     if (!future$lazy) 
[16:01:45.458]                       future <- run(future)
[16:01:45.458]                     invisible(future)
[16:01:45.458]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.458]                 }
[16:01:45.458]             }
[16:01:45.458]         }
[16:01:45.458]     })
[16:01:45.458]     if (TRUE) {
[16:01:45.458]         base::sink(type = "output", split = FALSE)
[16:01:45.458]         if (TRUE) {
[16:01:45.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.458]         }
[16:01:45.458]         else {
[16:01:45.458]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.458]         }
[16:01:45.458]         base::close(...future.stdout)
[16:01:45.458]         ...future.stdout <- NULL
[16:01:45.458]     }
[16:01:45.458]     ...future.result$conditions <- ...future.conditions
[16:01:45.458]     ...future.result$finished <- base::Sys.time()
[16:01:45.458]     ...future.result
[16:01:45.458] }
[16:01:45.460] assign_globals() ...
[16:01:45.460] List of 5
[16:01:45.460]  $ ...future.FUN            :function (object, ...)  
[16:01:45.460]  $ future.call.arguments    : list()
[16:01:45.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.460]  $ ...future.elements_ii    :List of 3
[16:01:45.460]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.460]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.460]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.460]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.460]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.460]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.460]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.460]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.460]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.460]  $ ...future.seeds_ii       : NULL
[16:01:45.460]  $ ...future.globals.maxSize: NULL
[16:01:45.460]  - attr(*, "where")=List of 5
[16:01:45.460]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.460]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.460]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.460]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.460]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.460]  - attr(*, "resolved")= logi FALSE
[16:01:45.460]  - attr(*, "total_size")= num 1240
[16:01:45.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.460]  - attr(*, "already-done")= logi TRUE
[16:01:45.467] - copied ‘...future.FUN’ to environment
[16:01:45.468] - copied ‘future.call.arguments’ to environment
[16:01:45.468] - copied ‘...future.elements_ii’ to environment
[16:01:45.468] - copied ‘...future.seeds_ii’ to environment
[16:01:45.468] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.468] assign_globals() ... done
[16:01:45.468] plan(): Setting new future strategy stack:
[16:01:45.468] List of future strategies:
[16:01:45.468] 1. sequential:
[16:01:45.468]    - args: function (..., envir = parent.frame())
[16:01:45.468]    - tweaked: FALSE
[16:01:45.468]    - call: NULL
[16:01:45.469] plan(): nbrOfWorkers() = 1
[16:01:45.471] plan(): Setting new future strategy stack:
[16:01:45.471] List of future strategies:
[16:01:45.471] 1. multisession:
[16:01:45.471]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.471]    - tweaked: FALSE
[16:01:45.471]    - call: plan(strategy)
[16:01:45.474] plan(): nbrOfWorkers() = 1
[16:01:45.475] SequentialFuture started (and completed)
[16:01:45.475] - Launch lazy future ... done
[16:01:45.475] run() for ‘SequentialFuture’ ... done
[16:01:45.475] Created future:
[16:01:45.475] SequentialFuture:
[16:01:45.475] Label: ‘future_by-1’
[16:01:45.475] Expression:
[16:01:45.475] {
[16:01:45.475]     do.call(function(...) {
[16:01:45.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.475]             on.exit(options(oopts), add = TRUE)
[16:01:45.475]         }
[16:01:45.475]         {
[16:01:45.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.475]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.475]             })
[16:01:45.475]         }
[16:01:45.475]     }, args = future.call.arguments)
[16:01:45.475] }
[16:01:45.475] Lazy evaluation: FALSE
[16:01:45.475] Asynchronous evaluation: FALSE
[16:01:45.475] Local evaluation: TRUE
[16:01:45.475] Environment: R_GlobalEnv
[16:01:45.475] Capture standard output: TRUE
[16:01:45.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.475] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.475] Packages: <none>
[16:01:45.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.475] Resolved: TRUE
[16:01:45.475] Value: 4.62 KiB of class ‘list’
[16:01:45.475] Early signaling: FALSE
[16:01:45.475] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.475] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.476] Chunk #1 of 1 ... DONE
[16:01:45.477] Launching 1 futures (chunks) ... DONE
[16:01:45.477] Resolving 1 futures (chunks) ...
[16:01:45.477] resolve() on list ...
[16:01:45.477]  recursive: 0
[16:01:45.477]  length: 1
[16:01:45.477] 
[16:01:45.477] resolved() for ‘SequentialFuture’ ...
[16:01:45.477] - state: ‘finished’
[16:01:45.477] - run: TRUE
[16:01:45.477] - result: ‘FutureResult’
[16:01:45.477] resolved() for ‘SequentialFuture’ ... done
[16:01:45.478] Future #1
[16:01:45.478] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.478] - nx: 1
[16:01:45.478] - relay: TRUE
[16:01:45.478] - stdout: TRUE
[16:01:45.478] - signal: TRUE
[16:01:45.478] - resignal: FALSE
[16:01:45.478] - force: TRUE
[16:01:45.478] - relayed: [n=1] FALSE
[16:01:45.478] - queued futures: [n=1] FALSE
[16:01:45.479]  - until=1
[16:01:45.479]  - relaying element #1
[16:01:45.479] - relayed: [n=1] TRUE
[16:01:45.479] - queued futures: [n=1] TRUE
[16:01:45.479] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.481]  length: 0 (resolved future 1)
[16:01:45.481] Relaying remaining futures
[16:01:45.481] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.481] - nx: 1
[16:01:45.481] - relay: TRUE
[16:01:45.481] - stdout: TRUE
[16:01:45.481] - signal: TRUE
[16:01:45.481] - resignal: FALSE
[16:01:45.482] - force: TRUE
[16:01:45.482] - relayed: [n=1] TRUE
[16:01:45.482] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.482] - relayed: [n=1] TRUE
[16:01:45.482] - queued futures: [n=1] TRUE
[16:01:45.482] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.482] resolve() on list ... DONE
[16:01:45.482]  - Number of value chunks collected: 1
[16:01:45.483] Resolving 1 futures (chunks) ... DONE
[16:01:45.483] Reducing values from 1 chunks ...
[16:01:45.483]  - Number of values collected after concatenation: 3
[16:01:45.483]  - Number of values expected: 3
[16:01:45.483] Reducing values from 1 chunks ... DONE
[16:01:45.483] future_lapply() ... DONE
[16:01:45.483] future_by_internal() ... DONE
[16:01:45.484] future_by_internal() ...
[16:01:45.484] future_lapply() ...
[16:01:45.488] Number of chunks: 1
[16:01:45.488] getGlobalsAndPackagesXApply() ...
[16:01:45.488]  - future.globals: TRUE
[16:01:45.488] getGlobalsAndPackages() ...
[16:01:45.488] Searching for globals...
[16:01:45.489] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.489] Searching for globals ... DONE
[16:01:45.489] Resolving globals: FALSE
[16:01:45.490] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.490] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.490] - globals: [1] ‘FUN’
[16:01:45.490] 
[16:01:45.490] getGlobalsAndPackages() ... DONE
[16:01:45.491]  - globals found/used: [n=1] ‘FUN’
[16:01:45.491]  - needed namespaces: [n=0] 
[16:01:45.491] Finding globals ... DONE
[16:01:45.491]  - use_args: TRUE
[16:01:45.491]  - Getting '...' globals ...
[16:01:45.491] resolve() on list ...
[16:01:45.491]  recursive: 0
[16:01:45.491]  length: 1
[16:01:45.492]  elements: ‘...’
[16:01:45.492]  length: 0 (resolved future 1)
[16:01:45.492] resolve() on list ... DONE
[16:01:45.492]    - '...' content: [n=1] ‘digits’
[16:01:45.492] List of 1
[16:01:45.492]  $ ...:List of 1
[16:01:45.492]   ..$ digits: int 2
[16:01:45.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.492]  - attr(*, "where")=List of 1
[16:01:45.492]   ..$ ...:<environment: 0x55b52506d6b8> 
[16:01:45.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.492]  - attr(*, "resolved")= logi TRUE
[16:01:45.492]  - attr(*, "total_size")= num NA
[16:01:45.495]  - Getting '...' globals ... DONE
[16:01:45.495] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.495] List of 2
[16:01:45.495]  $ ...future.FUN:function (object, ...)  
[16:01:45.495]  $ ...          :List of 1
[16:01:45.495]   ..$ digits: int 2
[16:01:45.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.495]  - attr(*, "where")=List of 2
[16:01:45.495]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.495]   ..$ ...          :<environment: 0x55b52506d6b8> 
[16:01:45.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.495]  - attr(*, "resolved")= logi FALSE
[16:01:45.495]  - attr(*, "total_size")= num 1296
[16:01:45.498] Packages to be attached in all futures: [n=0] 
[16:01:45.498] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.499] Number of futures (= number of chunks): 1
[16:01:45.499] Launching 1 futures (chunks) ...
[16:01:45.499] Chunk #1 of 1 ...
[16:01:45.499]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.499] getGlobalsAndPackages() ...
[16:01:45.499] Searching for globals...
[16:01:45.499] 
[16:01:45.499] Searching for globals ... DONE
[16:01:45.500] - globals: [0] <none>
[16:01:45.500] getGlobalsAndPackages() ... DONE
[16:01:45.500]    + additional globals found: [n=0] 
[16:01:45.500]    + additional namespaces needed: [n=0] 
[16:01:45.500]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.500]  - seeds: <none>
[16:01:45.500]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.500] getGlobalsAndPackages() ...
[16:01:45.500] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.500] Resolving globals: FALSE
[16:01:45.501] Tweak future expression to call with '...' arguments ...
[16:01:45.501] {
[16:01:45.501]     do.call(function(...) {
[16:01:45.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.501]             on.exit(options(oopts), add = TRUE)
[16:01:45.501]         }
[16:01:45.501]         {
[16:01:45.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.501]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.501]             })
[16:01:45.501]         }
[16:01:45.501]     }, args = future.call.arguments)
[16:01:45.501] }
[16:01:45.501] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.501] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.501] 
[16:01:45.501] getGlobalsAndPackages() ... DONE
[16:01:45.502] run() for ‘Future’ ...
[16:01:45.502] - state: ‘created’
[16:01:45.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.507]   - Field: ‘label’
[16:01:45.507]   - Field: ‘local’
[16:01:45.508]   - Field: ‘owner’
[16:01:45.508]   - Field: ‘envir’
[16:01:45.508]   - Field: ‘packages’
[16:01:45.508]   - Field: ‘gc’
[16:01:45.508]   - Field: ‘conditions’
[16:01:45.508]   - Field: ‘expr’
[16:01:45.508]   - Field: ‘uuid’
[16:01:45.508]   - Field: ‘seed’
[16:01:45.508]   - Field: ‘version’
[16:01:45.509]   - Field: ‘result’
[16:01:45.509]   - Field: ‘asynchronous’
[16:01:45.509]   - Field: ‘calls’
[16:01:45.509]   - Field: ‘globals’
[16:01:45.509]   - Field: ‘stdout’
[16:01:45.509]   - Field: ‘earlySignal’
[16:01:45.509]   - Field: ‘lazy’
[16:01:45.509]   - Field: ‘state’
[16:01:45.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.510] - Launch lazy future ...
[16:01:45.510] Packages needed by the future expression (n = 0): <none>
[16:01:45.510] Packages needed by future strategies (n = 0): <none>
[16:01:45.510] {
[16:01:45.510]     {
[16:01:45.510]         {
[16:01:45.510]             ...future.startTime <- base::Sys.time()
[16:01:45.510]             {
[16:01:45.510]                 {
[16:01:45.510]                   {
[16:01:45.510]                     base::local({
[16:01:45.510]                       has_future <- base::requireNamespace("future", 
[16:01:45.510]                         quietly = TRUE)
[16:01:45.510]                       if (has_future) {
[16:01:45.510]                         ns <- base::getNamespace("future")
[16:01:45.510]                         version <- ns[[".package"]][["version"]]
[16:01:45.510]                         if (is.null(version)) 
[16:01:45.510]                           version <- utils::packageVersion("future")
[16:01:45.510]                       }
[16:01:45.510]                       else {
[16:01:45.510]                         version <- NULL
[16:01:45.510]                       }
[16:01:45.510]                       if (!has_future || version < "1.8.0") {
[16:01:45.510]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.510]                           "", base::R.version$version.string), 
[16:01:45.510]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.510]                             "release", "version")], collapse = " "), 
[16:01:45.510]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.510]                           info)
[16:01:45.510]                         info <- base::paste(info, collapse = "; ")
[16:01:45.510]                         if (!has_future) {
[16:01:45.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.510]                             info)
[16:01:45.510]                         }
[16:01:45.510]                         else {
[16:01:45.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.510]                             info, version)
[16:01:45.510]                         }
[16:01:45.510]                         base::stop(msg)
[16:01:45.510]                       }
[16:01:45.510]                     })
[16:01:45.510]                   }
[16:01:45.510]                   options(future.plan = NULL)
[16:01:45.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.510]                 }
[16:01:45.510]                 ...future.workdir <- getwd()
[16:01:45.510]             }
[16:01:45.510]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.510]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.510]         }
[16:01:45.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.510]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.510]             base::names(...future.oldOptions))
[16:01:45.510]     }
[16:01:45.510]     if (FALSE) {
[16:01:45.510]     }
[16:01:45.510]     else {
[16:01:45.510]         if (TRUE) {
[16:01:45.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.510]                 open = "w")
[16:01:45.510]         }
[16:01:45.510]         else {
[16:01:45.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.510]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.510]         }
[16:01:45.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.510]             base::sink(type = "output", split = FALSE)
[16:01:45.510]             base::close(...future.stdout)
[16:01:45.510]         }, add = TRUE)
[16:01:45.510]     }
[16:01:45.510]     ...future.frame <- base::sys.nframe()
[16:01:45.510]     ...future.conditions <- base::list()
[16:01:45.510]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.510]     if (FALSE) {
[16:01:45.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.510]     }
[16:01:45.510]     ...future.result <- base::tryCatch({
[16:01:45.510]         base::withCallingHandlers({
[16:01:45.510]             ...future.value <- base::withVisible(base::local({
[16:01:45.510]                 do.call(function(...) {
[16:01:45.510]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.510]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.510]                     ...future.globals.maxSize)) {
[16:01:45.510]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.510]                     on.exit(options(oopts), add = TRUE)
[16:01:45.510]                   }
[16:01:45.510]                   {
[16:01:45.510]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.510]                       FUN = function(jj) {
[16:01:45.510]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.510]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.510]                       })
[16:01:45.510]                   }
[16:01:45.510]                 }, args = future.call.arguments)
[16:01:45.510]             }))
[16:01:45.510]             future::FutureResult(value = ...future.value$value, 
[16:01:45.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.510]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.510]                     ...future.globalenv.names))
[16:01:45.510]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.510]         }, condition = base::local({
[16:01:45.510]             c <- base::c
[16:01:45.510]             inherits <- base::inherits
[16:01:45.510]             invokeRestart <- base::invokeRestart
[16:01:45.510]             length <- base::length
[16:01:45.510]             list <- base::list
[16:01:45.510]             seq.int <- base::seq.int
[16:01:45.510]             signalCondition <- base::signalCondition
[16:01:45.510]             sys.calls <- base::sys.calls
[16:01:45.510]             `[[` <- base::`[[`
[16:01:45.510]             `+` <- base::`+`
[16:01:45.510]             `<<-` <- base::`<<-`
[16:01:45.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.510]                   3L)]
[16:01:45.510]             }
[16:01:45.510]             function(cond) {
[16:01:45.510]                 is_error <- inherits(cond, "error")
[16:01:45.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.510]                   NULL)
[16:01:45.510]                 if (is_error) {
[16:01:45.510]                   sessionInformation <- function() {
[16:01:45.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.510]                       search = base::search(), system = base::Sys.info())
[16:01:45.510]                   }
[16:01:45.510]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.510]                     cond$call), session = sessionInformation(), 
[16:01:45.510]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.510]                   signalCondition(cond)
[16:01:45.510]                 }
[16:01:45.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.510]                 "immediateCondition"))) {
[16:01:45.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.510]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.510]                   if (TRUE && !signal) {
[16:01:45.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.510]                     {
[16:01:45.510]                       inherits <- base::inherits
[16:01:45.510]                       invokeRestart <- base::invokeRestart
[16:01:45.510]                       is.null <- base::is.null
[16:01:45.510]                       muffled <- FALSE
[16:01:45.510]                       if (inherits(cond, "message")) {
[16:01:45.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.510]                         if (muffled) 
[16:01:45.510]                           invokeRestart("muffleMessage")
[16:01:45.510]                       }
[16:01:45.510]                       else if (inherits(cond, "warning")) {
[16:01:45.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.510]                         if (muffled) 
[16:01:45.510]                           invokeRestart("muffleWarning")
[16:01:45.510]                       }
[16:01:45.510]                       else if (inherits(cond, "condition")) {
[16:01:45.510]                         if (!is.null(pattern)) {
[16:01:45.510]                           computeRestarts <- base::computeRestarts
[16:01:45.510]                           grepl <- base::grepl
[16:01:45.510]                           restarts <- computeRestarts(cond)
[16:01:45.510]                           for (restart in restarts) {
[16:01:45.510]                             name <- restart$name
[16:01:45.510]                             if (is.null(name)) 
[16:01:45.510]                               next
[16:01:45.510]                             if (!grepl(pattern, name)) 
[16:01:45.510]                               next
[16:01:45.510]                             invokeRestart(restart)
[16:01:45.510]                             muffled <- TRUE
[16:01:45.510]                             break
[16:01:45.510]                           }
[16:01:45.510]                         }
[16:01:45.510]                       }
[16:01:45.510]                       invisible(muffled)
[16:01:45.510]                     }
[16:01:45.510]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.510]                   }
[16:01:45.510]                 }
[16:01:45.510]                 else {
[16:01:45.510]                   if (TRUE) {
[16:01:45.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.510]                     {
[16:01:45.510]                       inherits <- base::inherits
[16:01:45.510]                       invokeRestart <- base::invokeRestart
[16:01:45.510]                       is.null <- base::is.null
[16:01:45.510]                       muffled <- FALSE
[16:01:45.510]                       if (inherits(cond, "message")) {
[16:01:45.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.510]                         if (muffled) 
[16:01:45.510]                           invokeRestart("muffleMessage")
[16:01:45.510]                       }
[16:01:45.510]                       else if (inherits(cond, "warning")) {
[16:01:45.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.510]                         if (muffled) 
[16:01:45.510]                           invokeRestart("muffleWarning")
[16:01:45.510]                       }
[16:01:45.510]                       else if (inherits(cond, "condition")) {
[16:01:45.510]                         if (!is.null(pattern)) {
[16:01:45.510]                           computeRestarts <- base::computeRestarts
[16:01:45.510]                           grepl <- base::grepl
[16:01:45.510]                           restarts <- computeRestarts(cond)
[16:01:45.510]                           for (restart in restarts) {
[16:01:45.510]                             name <- restart$name
[16:01:45.510]                             if (is.null(name)) 
[16:01:45.510]                               next
[16:01:45.510]                             if (!grepl(pattern, name)) 
[16:01:45.510]                               next
[16:01:45.510]                             invokeRestart(restart)
[16:01:45.510]                             muffled <- TRUE
[16:01:45.510]                             break
[16:01:45.510]                           }
[16:01:45.510]                         }
[16:01:45.510]                       }
[16:01:45.510]                       invisible(muffled)
[16:01:45.510]                     }
[16:01:45.510]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.510]                   }
[16:01:45.510]                 }
[16:01:45.510]             }
[16:01:45.510]         }))
[16:01:45.510]     }, error = function(ex) {
[16:01:45.510]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.510]                 ...future.rng), started = ...future.startTime, 
[16:01:45.510]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.510]             version = "1.8"), class = "FutureResult")
[16:01:45.510]     }, finally = {
[16:01:45.510]         if (!identical(...future.workdir, getwd())) 
[16:01:45.510]             setwd(...future.workdir)
[16:01:45.510]         {
[16:01:45.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.510]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.510]             }
[16:01:45.510]             base::options(...future.oldOptions)
[16:01:45.510]             if (.Platform$OS.type == "windows") {
[16:01:45.510]                 old_names <- names(...future.oldEnvVars)
[16:01:45.510]                 envs <- base::Sys.getenv()
[16:01:45.510]                 names <- names(envs)
[16:01:45.510]                 common <- intersect(names, old_names)
[16:01:45.510]                 added <- setdiff(names, old_names)
[16:01:45.510]                 removed <- setdiff(old_names, names)
[16:01:45.510]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.510]                   envs[common]]
[16:01:45.510]                 NAMES <- toupper(changed)
[16:01:45.510]                 args <- list()
[16:01:45.510]                 for (kk in seq_along(NAMES)) {
[16:01:45.510]                   name <- changed[[kk]]
[16:01:45.510]                   NAME <- NAMES[[kk]]
[16:01:45.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.510]                     next
[16:01:45.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.510]                 }
[16:01:45.510]                 NAMES <- toupper(added)
[16:01:45.510]                 for (kk in seq_along(NAMES)) {
[16:01:45.510]                   name <- added[[kk]]
[16:01:45.510]                   NAME <- NAMES[[kk]]
[16:01:45.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.510]                     next
[16:01:45.510]                   args[[name]] <- ""
[16:01:45.510]                 }
[16:01:45.510]                 NAMES <- toupper(removed)
[16:01:45.510]                 for (kk in seq_along(NAMES)) {
[16:01:45.510]                   name <- removed[[kk]]
[16:01:45.510]                   NAME <- NAMES[[kk]]
[16:01:45.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.510]                     next
[16:01:45.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.510]                 }
[16:01:45.510]                 if (length(args) > 0) 
[16:01:45.510]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.510]             }
[16:01:45.510]             else {
[16:01:45.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.510]             }
[16:01:45.510]             {
[16:01:45.510]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.510]                   0L) {
[16:01:45.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.510]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.510]                   base::options(opts)
[16:01:45.510]                 }
[16:01:45.510]                 {
[16:01:45.510]                   {
[16:01:45.510]                     NULL
[16:01:45.510]                     RNGkind("Mersenne-Twister")
[16:01:45.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.510]                       inherits = FALSE)
[16:01:45.510]                   }
[16:01:45.510]                   options(future.plan = NULL)
[16:01:45.510]                   if (is.na(NA_character_)) 
[16:01:45.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.510]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.510]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.510]                     envir = parent.frame()) 
[16:01:45.510]                   {
[16:01:45.510]                     if (is.function(workers)) 
[16:01:45.510]                       workers <- workers()
[16:01:45.510]                     workers <- structure(as.integer(workers), 
[16:01:45.510]                       class = class(workers))
[16:01:45.510]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.510]                       workers >= 1)
[16:01:45.510]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.510]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.510]                     }
[16:01:45.510]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.510]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.510]                       envir = envir)
[16:01:45.510]                     if (!future$lazy) 
[16:01:45.510]                       future <- run(future)
[16:01:45.510]                     invisible(future)
[16:01:45.510]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.510]                 }
[16:01:45.510]             }
[16:01:45.510]         }
[16:01:45.510]     })
[16:01:45.510]     if (TRUE) {
[16:01:45.510]         base::sink(type = "output", split = FALSE)
[16:01:45.510]         if (TRUE) {
[16:01:45.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.510]         }
[16:01:45.510]         else {
[16:01:45.510]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.510]         }
[16:01:45.510]         base::close(...future.stdout)
[16:01:45.510]         ...future.stdout <- NULL
[16:01:45.510]     }
[16:01:45.510]     ...future.result$conditions <- ...future.conditions
[16:01:45.510]     ...future.result$finished <- base::Sys.time()
[16:01:45.510]     ...future.result
[16:01:45.510] }
[16:01:45.512] assign_globals() ...
[16:01:45.512] List of 5
[16:01:45.512]  $ ...future.FUN            :function (object, ...)  
[16:01:45.512]  $ future.call.arguments    :List of 1
[16:01:45.512]   ..$ digits: int 2
[16:01:45.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.512]  $ ...future.elements_ii    :List of 6
[16:01:45.512]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:01:45.512]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:01:45.512]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:01:45.512]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:01:45.512]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:01:45.512]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:01:45.512]  $ ...future.seeds_ii       : NULL
[16:01:45.512]  $ ...future.globals.maxSize: NULL
[16:01:45.512]  - attr(*, "where")=List of 5
[16:01:45.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.512]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.512]  - attr(*, "resolved")= logi FALSE
[16:01:45.512]  - attr(*, "total_size")= num 1296
[16:01:45.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.512]  - attr(*, "already-done")= logi TRUE
[16:01:45.519] - copied ‘...future.FUN’ to environment
[16:01:45.519] - copied ‘future.call.arguments’ to environment
[16:01:45.519] - copied ‘...future.elements_ii’ to environment
[16:01:45.519] - copied ‘...future.seeds_ii’ to environment
[16:01:45.519] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.520] assign_globals() ... done
[16:01:45.520] plan(): Setting new future strategy stack:
[16:01:45.520] List of future strategies:
[16:01:45.520] 1. sequential:
[16:01:45.520]    - args: function (..., envir = parent.frame())
[16:01:45.520]    - tweaked: FALSE
[16:01:45.520]    - call: NULL
[16:01:45.520] plan(): nbrOfWorkers() = 1
[16:01:45.522] plan(): Setting new future strategy stack:
[16:01:45.522] List of future strategies:
[16:01:45.522] 1. multisession:
[16:01:45.522]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.522]    - tweaked: FALSE
[16:01:45.522]    - call: plan(strategy)
[16:01:45.525] plan(): nbrOfWorkers() = 1
[16:01:45.526] SequentialFuture started (and completed)
[16:01:45.526] - Launch lazy future ... done
[16:01:45.526] run() for ‘SequentialFuture’ ... done
[16:01:45.526] Created future:
[16:01:45.526] SequentialFuture:
[16:01:45.526] Label: ‘future_by-1’
[16:01:45.526] Expression:
[16:01:45.526] {
[16:01:45.526]     do.call(function(...) {
[16:01:45.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.526]             on.exit(options(oopts), add = TRUE)
[16:01:45.526]         }
[16:01:45.526]         {
[16:01:45.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.526]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.526]             })
[16:01:45.526]         }
[16:01:45.526]     }, args = future.call.arguments)
[16:01:45.526] }
[16:01:45.526] Lazy evaluation: FALSE
[16:01:45.526] Asynchronous evaluation: FALSE
[16:01:45.526] Local evaluation: TRUE
[16:01:45.526] Environment: R_GlobalEnv
[16:01:45.526] Capture standard output: TRUE
[16:01:45.526] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.526] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.526] Packages: <none>
[16:01:45.526] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.526] Resolved: TRUE
[16:01:45.526] Value: 5.48 KiB of class ‘list’
[16:01:45.526] Early signaling: FALSE
[16:01:45.526] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.526] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.527] Chunk #1 of 1 ... DONE
[16:01:45.527] Launching 1 futures (chunks) ... DONE
[16:01:45.527] Resolving 1 futures (chunks) ...
[16:01:45.528] resolve() on list ...
[16:01:45.528]  recursive: 0
[16:01:45.528]  length: 1
[16:01:45.528] 
[16:01:45.528] resolved() for ‘SequentialFuture’ ...
[16:01:45.528] - state: ‘finished’
[16:01:45.528] - run: TRUE
[16:01:45.528] - result: ‘FutureResult’
[16:01:45.528] resolved() for ‘SequentialFuture’ ... done
[16:01:45.528] Future #1
[16:01:45.529] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.529] - nx: 1
[16:01:45.529] - relay: TRUE
[16:01:45.529] - stdout: TRUE
[16:01:45.529] - signal: TRUE
[16:01:45.529] - resignal: FALSE
[16:01:45.529] - force: TRUE
[16:01:45.529] - relayed: [n=1] FALSE
[16:01:45.529] - queued futures: [n=1] FALSE
[16:01:45.529]  - until=1
[16:01:45.529]  - relaying element #1
[16:01:45.530] - relayed: [n=1] TRUE
[16:01:45.530] - queued futures: [n=1] TRUE
[16:01:45.530] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.530]  length: 0 (resolved future 1)
[16:01:45.530] Relaying remaining futures
[16:01:45.530] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.530] - nx: 1
[16:01:45.530] - relay: TRUE
[16:01:45.530] - stdout: TRUE
[16:01:45.532] - signal: TRUE
[16:01:45.532] - resignal: FALSE
[16:01:45.532] - force: TRUE
[16:01:45.532] - relayed: [n=1] TRUE
[16:01:45.532] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.533] - relayed: [n=1] TRUE
[16:01:45.533] - queued futures: [n=1] TRUE
[16:01:45.533] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.533] resolve() on list ... DONE
[16:01:45.533]  - Number of value chunks collected: 1
[16:01:45.533] Resolving 1 futures (chunks) ... DONE
[16:01:45.533] Reducing values from 1 chunks ...
[16:01:45.533]  - Number of values collected after concatenation: 6
[16:01:45.534]  - Number of values expected: 6
[16:01:45.534] Reducing values from 1 chunks ... DONE
[16:01:45.534] future_lapply() ... DONE
[16:01:45.534] future_by_internal() ... DONE
[16:01:45.535] future_by_internal() ...
[16:01:45.536] future_lapply() ...
[16:01:45.540] Number of chunks: 1
[16:01:45.540] getGlobalsAndPackagesXApply() ...
[16:01:45.540]  - future.globals: TRUE
[16:01:45.540] getGlobalsAndPackages() ...
[16:01:45.540] Searching for globals...
[16:01:45.542] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:45.542] Searching for globals ... DONE
[16:01:45.542] Resolving globals: FALSE
[16:01:45.542] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:01:45.543] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:01:45.543] - globals: [1] ‘FUN’
[16:01:45.543] - packages: [1] ‘stats’
[16:01:45.543] getGlobalsAndPackages() ... DONE
[16:01:45.543]  - globals found/used: [n=1] ‘FUN’
[16:01:45.543]  - needed namespaces: [n=1] ‘stats’
[16:01:45.543] Finding globals ... DONE
[16:01:45.544]  - use_args: TRUE
[16:01:45.544]  - Getting '...' globals ...
[16:01:45.544] resolve() on list ...
[16:01:45.544]  recursive: 0
[16:01:45.544]  length: 1
[16:01:45.544]  elements: ‘...’
[16:01:45.544]  length: 0 (resolved future 1)
[16:01:45.544] resolve() on list ... DONE
[16:01:45.545]    - '...' content: [n=1] ‘singular.ok’
[16:01:45.545] List of 1
[16:01:45.545]  $ ...:List of 1
[16:01:45.545]   ..$ singular.ok: logi FALSE
[16:01:45.545]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.545]  - attr(*, "where")=List of 1
[16:01:45.545]   ..$ ...:<environment: 0x55b52484e180> 
[16:01:45.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.545]  - attr(*, "resolved")= logi TRUE
[16:01:45.545]  - attr(*, "total_size")= num NA
[16:01:45.548]  - Getting '...' globals ... DONE
[16:01:45.548] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.548] List of 2
[16:01:45.548]  $ ...future.FUN:function (x, ...)  
[16:01:45.548]  $ ...          :List of 1
[16:01:45.548]   ..$ singular.ok: logi FALSE
[16:01:45.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.548]  - attr(*, "where")=List of 2
[16:01:45.548]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.548]   ..$ ...          :<environment: 0x55b52484e180> 
[16:01:45.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.548]  - attr(*, "resolved")= logi FALSE
[16:01:45.548]  - attr(*, "total_size")= num 5384
[16:01:45.551] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:45.551] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.551] Number of futures (= number of chunks): 1
[16:01:45.551] Launching 1 futures (chunks) ...
[16:01:45.551] Chunk #1 of 1 ...
[16:01:45.552]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.552] getGlobalsAndPackages() ...
[16:01:45.552] Searching for globals...
[16:01:45.552] 
[16:01:45.552] Searching for globals ... DONE
[16:01:45.552] - globals: [0] <none>
[16:01:45.553] getGlobalsAndPackages() ... DONE
[16:01:45.553]    + additional globals found: [n=0] 
[16:01:45.553]    + additional namespaces needed: [n=0] 
[16:01:45.553]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.553]  - seeds: <none>
[16:01:45.553]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.555] getGlobalsAndPackages() ...
[16:01:45.555] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.555] Resolving globals: FALSE
[16:01:45.555] Tweak future expression to call with '...' arguments ...
[16:01:45.555] {
[16:01:45.555]     do.call(function(...) {
[16:01:45.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.555]             on.exit(options(oopts), add = TRUE)
[16:01:45.555]         }
[16:01:45.555]         {
[16:01:45.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.555]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.555]             })
[16:01:45.555]         }
[16:01:45.555]     }, args = future.call.arguments)
[16:01:45.555] }
[16:01:45.556] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.556] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.556] 
[16:01:45.556] getGlobalsAndPackages() ... DONE
[16:01:45.557] run() for ‘Future’ ...
[16:01:45.557] - state: ‘created’
[16:01:45.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.561] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.561]   - Field: ‘label’
[16:01:45.561]   - Field: ‘local’
[16:01:45.561]   - Field: ‘owner’
[16:01:45.561]   - Field: ‘envir’
[16:01:45.561]   - Field: ‘packages’
[16:01:45.561]   - Field: ‘gc’
[16:01:45.562]   - Field: ‘conditions’
[16:01:45.562]   - Field: ‘expr’
[16:01:45.562]   - Field: ‘uuid’
[16:01:45.562]   - Field: ‘seed’
[16:01:45.562]   - Field: ‘version’
[16:01:45.562]   - Field: ‘result’
[16:01:45.562]   - Field: ‘asynchronous’
[16:01:45.562]   - Field: ‘calls’
[16:01:45.562]   - Field: ‘globals’
[16:01:45.562]   - Field: ‘stdout’
[16:01:45.563]   - Field: ‘earlySignal’
[16:01:45.563]   - Field: ‘lazy’
[16:01:45.563]   - Field: ‘state’
[16:01:45.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.563] - Launch lazy future ...
[16:01:45.563] Packages needed by the future expression (n = 1): ‘stats’
[16:01:45.563] Packages needed by future strategies (n = 0): <none>
[16:01:45.564] {
[16:01:45.564]     {
[16:01:45.564]         {
[16:01:45.564]             ...future.startTime <- base::Sys.time()
[16:01:45.564]             {
[16:01:45.564]                 {
[16:01:45.564]                   {
[16:01:45.564]                     {
[16:01:45.564]                       base::local({
[16:01:45.564]                         has_future <- base::requireNamespace("future", 
[16:01:45.564]                           quietly = TRUE)
[16:01:45.564]                         if (has_future) {
[16:01:45.564]                           ns <- base::getNamespace("future")
[16:01:45.564]                           version <- ns[[".package"]][["version"]]
[16:01:45.564]                           if (is.null(version)) 
[16:01:45.564]                             version <- utils::packageVersion("future")
[16:01:45.564]                         }
[16:01:45.564]                         else {
[16:01:45.564]                           version <- NULL
[16:01:45.564]                         }
[16:01:45.564]                         if (!has_future || version < "1.8.0") {
[16:01:45.564]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.564]                             "", base::R.version$version.string), 
[16:01:45.564]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:45.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.564]                               "release", "version")], collapse = " "), 
[16:01:45.564]                             hostname = base::Sys.info()[["nodename"]])
[16:01:45.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.564]                             info)
[16:01:45.564]                           info <- base::paste(info, collapse = "; ")
[16:01:45.564]                           if (!has_future) {
[16:01:45.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.564]                               info)
[16:01:45.564]                           }
[16:01:45.564]                           else {
[16:01:45.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.564]                               info, version)
[16:01:45.564]                           }
[16:01:45.564]                           base::stop(msg)
[16:01:45.564]                         }
[16:01:45.564]                       })
[16:01:45.564]                     }
[16:01:45.564]                     base::local({
[16:01:45.564]                       for (pkg in "stats") {
[16:01:45.564]                         base::loadNamespace(pkg)
[16:01:45.564]                         base::library(pkg, character.only = TRUE)
[16:01:45.564]                       }
[16:01:45.564]                     })
[16:01:45.564]                   }
[16:01:45.564]                   options(future.plan = NULL)
[16:01:45.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.564]                 }
[16:01:45.564]                 ...future.workdir <- getwd()
[16:01:45.564]             }
[16:01:45.564]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.564]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.564]         }
[16:01:45.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.564]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.564]             base::names(...future.oldOptions))
[16:01:45.564]     }
[16:01:45.564]     if (FALSE) {
[16:01:45.564]     }
[16:01:45.564]     else {
[16:01:45.564]         if (TRUE) {
[16:01:45.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.564]                 open = "w")
[16:01:45.564]         }
[16:01:45.564]         else {
[16:01:45.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.564]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.564]         }
[16:01:45.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.564]             base::sink(type = "output", split = FALSE)
[16:01:45.564]             base::close(...future.stdout)
[16:01:45.564]         }, add = TRUE)
[16:01:45.564]     }
[16:01:45.564]     ...future.frame <- base::sys.nframe()
[16:01:45.564]     ...future.conditions <- base::list()
[16:01:45.564]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.564]     if (FALSE) {
[16:01:45.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.564]     }
[16:01:45.564]     ...future.result <- base::tryCatch({
[16:01:45.564]         base::withCallingHandlers({
[16:01:45.564]             ...future.value <- base::withVisible(base::local({
[16:01:45.564]                 do.call(function(...) {
[16:01:45.564]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.564]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.564]                     ...future.globals.maxSize)) {
[16:01:45.564]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.564]                     on.exit(options(oopts), add = TRUE)
[16:01:45.564]                   }
[16:01:45.564]                   {
[16:01:45.564]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.564]                       FUN = function(jj) {
[16:01:45.564]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.564]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.564]                       })
[16:01:45.564]                   }
[16:01:45.564]                 }, args = future.call.arguments)
[16:01:45.564]             }))
[16:01:45.564]             future::FutureResult(value = ...future.value$value, 
[16:01:45.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.564]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.564]                     ...future.globalenv.names))
[16:01:45.564]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.564]         }, condition = base::local({
[16:01:45.564]             c <- base::c
[16:01:45.564]             inherits <- base::inherits
[16:01:45.564]             invokeRestart <- base::invokeRestart
[16:01:45.564]             length <- base::length
[16:01:45.564]             list <- base::list
[16:01:45.564]             seq.int <- base::seq.int
[16:01:45.564]             signalCondition <- base::signalCondition
[16:01:45.564]             sys.calls <- base::sys.calls
[16:01:45.564]             `[[` <- base::`[[`
[16:01:45.564]             `+` <- base::`+`
[16:01:45.564]             `<<-` <- base::`<<-`
[16:01:45.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.564]                   3L)]
[16:01:45.564]             }
[16:01:45.564]             function(cond) {
[16:01:45.564]                 is_error <- inherits(cond, "error")
[16:01:45.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.564]                   NULL)
[16:01:45.564]                 if (is_error) {
[16:01:45.564]                   sessionInformation <- function() {
[16:01:45.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.564]                       search = base::search(), system = base::Sys.info())
[16:01:45.564]                   }
[16:01:45.564]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.564]                     cond$call), session = sessionInformation(), 
[16:01:45.564]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.564]                   signalCondition(cond)
[16:01:45.564]                 }
[16:01:45.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.564]                 "immediateCondition"))) {
[16:01:45.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.564]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.564]                   if (TRUE && !signal) {
[16:01:45.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.564]                     {
[16:01:45.564]                       inherits <- base::inherits
[16:01:45.564]                       invokeRestart <- base::invokeRestart
[16:01:45.564]                       is.null <- base::is.null
[16:01:45.564]                       muffled <- FALSE
[16:01:45.564]                       if (inherits(cond, "message")) {
[16:01:45.564]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.564]                         if (muffled) 
[16:01:45.564]                           invokeRestart("muffleMessage")
[16:01:45.564]                       }
[16:01:45.564]                       else if (inherits(cond, "warning")) {
[16:01:45.564]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.564]                         if (muffled) 
[16:01:45.564]                           invokeRestart("muffleWarning")
[16:01:45.564]                       }
[16:01:45.564]                       else if (inherits(cond, "condition")) {
[16:01:45.564]                         if (!is.null(pattern)) {
[16:01:45.564]                           computeRestarts <- base::computeRestarts
[16:01:45.564]                           grepl <- base::grepl
[16:01:45.564]                           restarts <- computeRestarts(cond)
[16:01:45.564]                           for (restart in restarts) {
[16:01:45.564]                             name <- restart$name
[16:01:45.564]                             if (is.null(name)) 
[16:01:45.564]                               next
[16:01:45.564]                             if (!grepl(pattern, name)) 
[16:01:45.564]                               next
[16:01:45.564]                             invokeRestart(restart)
[16:01:45.564]                             muffled <- TRUE
[16:01:45.564]                             break
[16:01:45.564]                           }
[16:01:45.564]                         }
[16:01:45.564]                       }
[16:01:45.564]                       invisible(muffled)
[16:01:45.564]                     }
[16:01:45.564]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.564]                   }
[16:01:45.564]                 }
[16:01:45.564]                 else {
[16:01:45.564]                   if (TRUE) {
[16:01:45.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.564]                     {
[16:01:45.564]                       inherits <- base::inherits
[16:01:45.564]                       invokeRestart <- base::invokeRestart
[16:01:45.564]                       is.null <- base::is.null
[16:01:45.564]                       muffled <- FALSE
[16:01:45.564]                       if (inherits(cond, "message")) {
[16:01:45.564]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.564]                         if (muffled) 
[16:01:45.564]                           invokeRestart("muffleMessage")
[16:01:45.564]                       }
[16:01:45.564]                       else if (inherits(cond, "warning")) {
[16:01:45.564]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.564]                         if (muffled) 
[16:01:45.564]                           invokeRestart("muffleWarning")
[16:01:45.564]                       }
[16:01:45.564]                       else if (inherits(cond, "condition")) {
[16:01:45.564]                         if (!is.null(pattern)) {
[16:01:45.564]                           computeRestarts <- base::computeRestarts
[16:01:45.564]                           grepl <- base::grepl
[16:01:45.564]                           restarts <- computeRestarts(cond)
[16:01:45.564]                           for (restart in restarts) {
[16:01:45.564]                             name <- restart$name
[16:01:45.564]                             if (is.null(name)) 
[16:01:45.564]                               next
[16:01:45.564]                             if (!grepl(pattern, name)) 
[16:01:45.564]                               next
[16:01:45.564]                             invokeRestart(restart)
[16:01:45.564]                             muffled <- TRUE
[16:01:45.564]                             break
[16:01:45.564]                           }
[16:01:45.564]                         }
[16:01:45.564]                       }
[16:01:45.564]                       invisible(muffled)
[16:01:45.564]                     }
[16:01:45.564]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.564]                   }
[16:01:45.564]                 }
[16:01:45.564]             }
[16:01:45.564]         }))
[16:01:45.564]     }, error = function(ex) {
[16:01:45.564]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.564]                 ...future.rng), started = ...future.startTime, 
[16:01:45.564]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.564]             version = "1.8"), class = "FutureResult")
[16:01:45.564]     }, finally = {
[16:01:45.564]         if (!identical(...future.workdir, getwd())) 
[16:01:45.564]             setwd(...future.workdir)
[16:01:45.564]         {
[16:01:45.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.564]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.564]             }
[16:01:45.564]             base::options(...future.oldOptions)
[16:01:45.564]             if (.Platform$OS.type == "windows") {
[16:01:45.564]                 old_names <- names(...future.oldEnvVars)
[16:01:45.564]                 envs <- base::Sys.getenv()
[16:01:45.564]                 names <- names(envs)
[16:01:45.564]                 common <- intersect(names, old_names)
[16:01:45.564]                 added <- setdiff(names, old_names)
[16:01:45.564]                 removed <- setdiff(old_names, names)
[16:01:45.564]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.564]                   envs[common]]
[16:01:45.564]                 NAMES <- toupper(changed)
[16:01:45.564]                 args <- list()
[16:01:45.564]                 for (kk in seq_along(NAMES)) {
[16:01:45.564]                   name <- changed[[kk]]
[16:01:45.564]                   NAME <- NAMES[[kk]]
[16:01:45.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.564]                     next
[16:01:45.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.564]                 }
[16:01:45.564]                 NAMES <- toupper(added)
[16:01:45.564]                 for (kk in seq_along(NAMES)) {
[16:01:45.564]                   name <- added[[kk]]
[16:01:45.564]                   NAME <- NAMES[[kk]]
[16:01:45.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.564]                     next
[16:01:45.564]                   args[[name]] <- ""
[16:01:45.564]                 }
[16:01:45.564]                 NAMES <- toupper(removed)
[16:01:45.564]                 for (kk in seq_along(NAMES)) {
[16:01:45.564]                   name <- removed[[kk]]
[16:01:45.564]                   NAME <- NAMES[[kk]]
[16:01:45.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.564]                     next
[16:01:45.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.564]                 }
[16:01:45.564]                 if (length(args) > 0) 
[16:01:45.564]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.564]             }
[16:01:45.564]             else {
[16:01:45.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.564]             }
[16:01:45.564]             {
[16:01:45.564]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.564]                   0L) {
[16:01:45.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.564]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.564]                   base::options(opts)
[16:01:45.564]                 }
[16:01:45.564]                 {
[16:01:45.564]                   {
[16:01:45.564]                     NULL
[16:01:45.564]                     RNGkind("Mersenne-Twister")
[16:01:45.564]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.564]                       inherits = FALSE)
[16:01:45.564]                   }
[16:01:45.564]                   options(future.plan = NULL)
[16:01:45.564]                   if (is.na(NA_character_)) 
[16:01:45.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.564]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.564]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.564]                     envir = parent.frame()) 
[16:01:45.564]                   {
[16:01:45.564]                     if (is.function(workers)) 
[16:01:45.564]                       workers <- workers()
[16:01:45.564]                     workers <- structure(as.integer(workers), 
[16:01:45.564]                       class = class(workers))
[16:01:45.564]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.564]                       workers >= 1)
[16:01:45.564]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.564]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.564]                     }
[16:01:45.564]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.564]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.564]                       envir = envir)
[16:01:45.564]                     if (!future$lazy) 
[16:01:45.564]                       future <- run(future)
[16:01:45.564]                     invisible(future)
[16:01:45.564]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.564]                 }
[16:01:45.564]             }
[16:01:45.564]         }
[16:01:45.564]     })
[16:01:45.564]     if (TRUE) {
[16:01:45.564]         base::sink(type = "output", split = FALSE)
[16:01:45.564]         if (TRUE) {
[16:01:45.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.564]         }
[16:01:45.564]         else {
[16:01:45.564]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.564]         }
[16:01:45.564]         base::close(...future.stdout)
[16:01:45.564]         ...future.stdout <- NULL
[16:01:45.564]     }
[16:01:45.564]     ...future.result$conditions <- ...future.conditions
[16:01:45.564]     ...future.result$finished <- base::Sys.time()
[16:01:45.564]     ...future.result
[16:01:45.564] }
[16:01:45.566] assign_globals() ...
[16:01:45.566] List of 5
[16:01:45.566]  $ ...future.FUN            :function (x, ...)  
[16:01:45.566]  $ future.call.arguments    :List of 1
[16:01:45.566]   ..$ singular.ok: logi FALSE
[16:01:45.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.566]  $ ...future.elements_ii    :List of 3
[16:01:45.566]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.566]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.566]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.566]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.566]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.566]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.566]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.566]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.566]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.566]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.566]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.566]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.566]  $ ...future.seeds_ii       : NULL
[16:01:45.566]  $ ...future.globals.maxSize: NULL
[16:01:45.566]  - attr(*, "where")=List of 5
[16:01:45.566]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.566]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.566]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.566]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.566]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.566]  - attr(*, "resolved")= logi FALSE
[16:01:45.566]  - attr(*, "total_size")= num 5384
[16:01:45.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.566]  - attr(*, "already-done")= logi TRUE
[16:01:45.575] - reassign environment for ‘...future.FUN’
[16:01:45.575] - copied ‘...future.FUN’ to environment
[16:01:45.575] - copied ‘future.call.arguments’ to environment
[16:01:45.575] - copied ‘...future.elements_ii’ to environment
[16:01:45.575] - copied ‘...future.seeds_ii’ to environment
[16:01:45.575] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.576] assign_globals() ... done
[16:01:45.576] plan(): Setting new future strategy stack:
[16:01:45.576] List of future strategies:
[16:01:45.576] 1. sequential:
[16:01:45.576]    - args: function (..., envir = parent.frame())
[16:01:45.576]    - tweaked: FALSE
[16:01:45.576]    - call: NULL
[16:01:45.576] plan(): nbrOfWorkers() = 1
[16:01:45.581] plan(): Setting new future strategy stack:
[16:01:45.581] List of future strategies:
[16:01:45.581] 1. multisession:
[16:01:45.581]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.581]    - tweaked: FALSE
[16:01:45.581]    - call: plan(strategy)
[16:01:45.586] plan(): nbrOfWorkers() = 1
[16:01:45.586] SequentialFuture started (and completed)
[16:01:45.586] - Launch lazy future ... done
[16:01:45.586] run() for ‘SequentialFuture’ ... done
[16:01:45.586] Created future:
[16:01:45.586] SequentialFuture:
[16:01:45.586] Label: ‘future_by-1’
[16:01:45.586] Expression:
[16:01:45.586] {
[16:01:45.586]     do.call(function(...) {
[16:01:45.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.586]             on.exit(options(oopts), add = TRUE)
[16:01:45.586]         }
[16:01:45.586]         {
[16:01:45.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.586]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.586]             })
[16:01:45.586]         }
[16:01:45.586]     }, args = future.call.arguments)
[16:01:45.586] }
[16:01:45.586] Lazy evaluation: FALSE
[16:01:45.586] Asynchronous evaluation: FALSE
[16:01:45.586] Local evaluation: TRUE
[16:01:45.586] Environment: R_GlobalEnv
[16:01:45.586] Capture standard output: TRUE
[16:01:45.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.586] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.586] Packages: 1 packages (‘stats’)
[16:01:45.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.586] Resolved: TRUE
[16:01:45.586] Value: 26.06 KiB of class ‘list’
[16:01:45.586] Early signaling: FALSE
[16:01:45.586] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.586] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.588] Chunk #1 of 1 ... DONE
[16:01:45.588] Launching 1 futures (chunks) ... DONE
[16:01:45.588] Resolving 1 futures (chunks) ...
[16:01:45.588] resolve() on list ...
[16:01:45.588]  recursive: 0
[16:01:45.588]  length: 1
[16:01:45.588] 
[16:01:45.589] resolved() for ‘SequentialFuture’ ...
[16:01:45.589] - state: ‘finished’
[16:01:45.589] - run: TRUE
[16:01:45.589] - result: ‘FutureResult’
[16:01:45.589] resolved() for ‘SequentialFuture’ ... done
[16:01:45.589] Future #1
[16:01:45.589] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.589] - nx: 1
[16:01:45.589] - relay: TRUE
[16:01:45.589] - stdout: TRUE
[16:01:45.590] - signal: TRUE
[16:01:45.590] - resignal: FALSE
[16:01:45.590] - force: TRUE
[16:01:45.590] - relayed: [n=1] FALSE
[16:01:45.590] - queued futures: [n=1] FALSE
[16:01:45.590]  - until=1
[16:01:45.590]  - relaying element #1
[16:01:45.590] - relayed: [n=1] TRUE
[16:01:45.590] - queued futures: [n=1] TRUE
[16:01:45.590] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.591]  length: 0 (resolved future 1)
[16:01:45.591] Relaying remaining futures
[16:01:45.591] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.591] - nx: 1
[16:01:45.591] - relay: TRUE
[16:01:45.591] - stdout: TRUE
[16:01:45.591] - signal: TRUE
[16:01:45.591] - resignal: FALSE
[16:01:45.591] - force: TRUE
[16:01:45.591] - relayed: [n=1] TRUE
[16:01:45.591] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.592] - relayed: [n=1] TRUE
[16:01:45.592] - queued futures: [n=1] TRUE
[16:01:45.592] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.592] resolve() on list ... DONE
[16:01:45.592]  - Number of value chunks collected: 1
[16:01:45.592] Resolving 1 futures (chunks) ... DONE
[16:01:45.592] Reducing values from 1 chunks ...
[16:01:45.592]  - Number of values collected after concatenation: 3
[16:01:45.592]  - Number of values expected: 3
[16:01:45.592] Reducing values from 1 chunks ... DONE
[16:01:45.593] future_lapply() ... DONE
[16:01:45.593] future_by_internal() ... DONE
[16:01:45.597] future_by_internal() ...
[16:01:45.597] future_lapply() ...
[16:01:45.601] Number of chunks: 1
[16:01:45.602] getGlobalsAndPackagesXApply() ...
[16:01:45.602]  - future.globals: TRUE
[16:01:45.602] getGlobalsAndPackages() ...
[16:01:45.602] Searching for globals...
[16:01:45.606] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:45.606] Searching for globals ... DONE
[16:01:45.606] Resolving globals: FALSE
[16:01:45.607] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:01:45.607] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:01:45.607] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:45.608] - packages: [1] ‘stats’
[16:01:45.608] getGlobalsAndPackages() ... DONE
[16:01:45.608]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:45.608]  - needed namespaces: [n=1] ‘stats’
[16:01:45.608] Finding globals ... DONE
[16:01:45.608]  - use_args: TRUE
[16:01:45.608]  - Getting '...' globals ...
[16:01:45.608] resolve() on list ...
[16:01:45.609]  recursive: 0
[16:01:45.609]  length: 1
[16:01:45.609]  elements: ‘...’
[16:01:45.609]  length: 0 (resolved future 1)
[16:01:45.609] resolve() on list ... DONE
[16:01:45.609]    - '...' content: [n=0] 
[16:01:45.609] List of 1
[16:01:45.609]  $ ...: list()
[16:01:45.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.609]  - attr(*, "where")=List of 1
[16:01:45.609]   ..$ ...:<environment: 0x55b525d91490> 
[16:01:45.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.609]  - attr(*, "resolved")= logi TRUE
[16:01:45.609]  - attr(*, "total_size")= num NA
[16:01:45.612]  - Getting '...' globals ... DONE
[16:01:45.612] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:01:45.612] List of 4
[16:01:45.612]  $ ...future.FUN:function (x)  
[16:01:45.612]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:45.612]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.612]  $ ...          : list()
[16:01:45.612]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.612]  - attr(*, "where")=List of 4
[16:01:45.612]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.612]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:01:45.612]   ..$ wool         :<environment: R_EmptyEnv> 
[16:01:45.612]   ..$ ...          :<environment: 0x55b525d91490> 
[16:01:45.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.612]  - attr(*, "resolved")= logi FALSE
[16:01:45.612]  - attr(*, "total_size")= num 2320
[16:01:45.616] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:45.616] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.616] Number of futures (= number of chunks): 1
[16:01:45.616] Launching 1 futures (chunks) ...
[16:01:45.617] Chunk #1 of 1 ...
[16:01:45.617]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.617] getGlobalsAndPackages() ...
[16:01:45.617] Searching for globals...
[16:01:45.617] 
[16:01:45.617] Searching for globals ... DONE
[16:01:45.618] - globals: [0] <none>
[16:01:45.618] getGlobalsAndPackages() ... DONE
[16:01:45.618]    + additional globals found: [n=0] 
[16:01:45.618]    + additional namespaces needed: [n=0] 
[16:01:45.618]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.618]  - seeds: <none>
[16:01:45.618]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.618] getGlobalsAndPackages() ...
[16:01:45.618] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.618] Resolving globals: FALSE
[16:01:45.619] Tweak future expression to call with '...' arguments ...
[16:01:45.619] {
[16:01:45.619]     do.call(function(...) {
[16:01:45.619]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.619]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.619]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.619]             on.exit(options(oopts), add = TRUE)
[16:01:45.619]         }
[16:01:45.619]         {
[16:01:45.619]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.619]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.619]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.619]             })
[16:01:45.619]         }
[16:01:45.619]     }, args = future.call.arguments)
[16:01:45.619] }
[16:01:45.619] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.619] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.620] 
[16:01:45.620] getGlobalsAndPackages() ... DONE
[16:01:45.620] run() for ‘Future’ ...
[16:01:45.620] - state: ‘created’
[16:01:45.620] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.624] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.624]   - Field: ‘label’
[16:01:45.624]   - Field: ‘local’
[16:01:45.624]   - Field: ‘owner’
[16:01:45.624]   - Field: ‘envir’
[16:01:45.625]   - Field: ‘packages’
[16:01:45.625]   - Field: ‘gc’
[16:01:45.625]   - Field: ‘conditions’
[16:01:45.625]   - Field: ‘expr’
[16:01:45.625]   - Field: ‘uuid’
[16:01:45.625]   - Field: ‘seed’
[16:01:45.625]   - Field: ‘version’
[16:01:45.625]   - Field: ‘result’
[16:01:45.625]   - Field: ‘asynchronous’
[16:01:45.625]   - Field: ‘calls’
[16:01:45.625]   - Field: ‘globals’
[16:01:45.626]   - Field: ‘stdout’
[16:01:45.626]   - Field: ‘earlySignal’
[16:01:45.626]   - Field: ‘lazy’
[16:01:45.626]   - Field: ‘state’
[16:01:45.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.626] - Launch lazy future ...
[16:01:45.626] Packages needed by the future expression (n = 1): ‘stats’
[16:01:45.626] Packages needed by future strategies (n = 0): <none>
[16:01:45.629] {
[16:01:45.629]     {
[16:01:45.629]         {
[16:01:45.629]             ...future.startTime <- base::Sys.time()
[16:01:45.629]             {
[16:01:45.629]                 {
[16:01:45.629]                   {
[16:01:45.629]                     {
[16:01:45.629]                       base::local({
[16:01:45.629]                         has_future <- base::requireNamespace("future", 
[16:01:45.629]                           quietly = TRUE)
[16:01:45.629]                         if (has_future) {
[16:01:45.629]                           ns <- base::getNamespace("future")
[16:01:45.629]                           version <- ns[[".package"]][["version"]]
[16:01:45.629]                           if (is.null(version)) 
[16:01:45.629]                             version <- utils::packageVersion("future")
[16:01:45.629]                         }
[16:01:45.629]                         else {
[16:01:45.629]                           version <- NULL
[16:01:45.629]                         }
[16:01:45.629]                         if (!has_future || version < "1.8.0") {
[16:01:45.629]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.629]                             "", base::R.version$version.string), 
[16:01:45.629]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:45.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.629]                               "release", "version")], collapse = " "), 
[16:01:45.629]                             hostname = base::Sys.info()[["nodename"]])
[16:01:45.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.629]                             info)
[16:01:45.629]                           info <- base::paste(info, collapse = "; ")
[16:01:45.629]                           if (!has_future) {
[16:01:45.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.629]                               info)
[16:01:45.629]                           }
[16:01:45.629]                           else {
[16:01:45.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.629]                               info, version)
[16:01:45.629]                           }
[16:01:45.629]                           base::stop(msg)
[16:01:45.629]                         }
[16:01:45.629]                       })
[16:01:45.629]                     }
[16:01:45.629]                     base::local({
[16:01:45.629]                       for (pkg in "stats") {
[16:01:45.629]                         base::loadNamespace(pkg)
[16:01:45.629]                         base::library(pkg, character.only = TRUE)
[16:01:45.629]                       }
[16:01:45.629]                     })
[16:01:45.629]                   }
[16:01:45.629]                   options(future.plan = NULL)
[16:01:45.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.629]                 }
[16:01:45.629]                 ...future.workdir <- getwd()
[16:01:45.629]             }
[16:01:45.629]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.629]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.629]         }
[16:01:45.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.629]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.629]             base::names(...future.oldOptions))
[16:01:45.629]     }
[16:01:45.629]     if (FALSE) {
[16:01:45.629]     }
[16:01:45.629]     else {
[16:01:45.629]         if (TRUE) {
[16:01:45.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.629]                 open = "w")
[16:01:45.629]         }
[16:01:45.629]         else {
[16:01:45.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.629]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.629]         }
[16:01:45.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.629]             base::sink(type = "output", split = FALSE)
[16:01:45.629]             base::close(...future.stdout)
[16:01:45.629]         }, add = TRUE)
[16:01:45.629]     }
[16:01:45.629]     ...future.frame <- base::sys.nframe()
[16:01:45.629]     ...future.conditions <- base::list()
[16:01:45.629]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.629]     if (FALSE) {
[16:01:45.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.629]     }
[16:01:45.629]     ...future.result <- base::tryCatch({
[16:01:45.629]         base::withCallingHandlers({
[16:01:45.629]             ...future.value <- base::withVisible(base::local({
[16:01:45.629]                 do.call(function(...) {
[16:01:45.629]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.629]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.629]                     ...future.globals.maxSize)) {
[16:01:45.629]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.629]                     on.exit(options(oopts), add = TRUE)
[16:01:45.629]                   }
[16:01:45.629]                   {
[16:01:45.629]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.629]                       FUN = function(jj) {
[16:01:45.629]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.629]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.629]                       })
[16:01:45.629]                   }
[16:01:45.629]                 }, args = future.call.arguments)
[16:01:45.629]             }))
[16:01:45.629]             future::FutureResult(value = ...future.value$value, 
[16:01:45.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.629]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.629]                     ...future.globalenv.names))
[16:01:45.629]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.629]         }, condition = base::local({
[16:01:45.629]             c <- base::c
[16:01:45.629]             inherits <- base::inherits
[16:01:45.629]             invokeRestart <- base::invokeRestart
[16:01:45.629]             length <- base::length
[16:01:45.629]             list <- base::list
[16:01:45.629]             seq.int <- base::seq.int
[16:01:45.629]             signalCondition <- base::signalCondition
[16:01:45.629]             sys.calls <- base::sys.calls
[16:01:45.629]             `[[` <- base::`[[`
[16:01:45.629]             `+` <- base::`+`
[16:01:45.629]             `<<-` <- base::`<<-`
[16:01:45.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.629]                   3L)]
[16:01:45.629]             }
[16:01:45.629]             function(cond) {
[16:01:45.629]                 is_error <- inherits(cond, "error")
[16:01:45.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.629]                   NULL)
[16:01:45.629]                 if (is_error) {
[16:01:45.629]                   sessionInformation <- function() {
[16:01:45.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.629]                       search = base::search(), system = base::Sys.info())
[16:01:45.629]                   }
[16:01:45.629]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.629]                     cond$call), session = sessionInformation(), 
[16:01:45.629]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.629]                   signalCondition(cond)
[16:01:45.629]                 }
[16:01:45.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.629]                 "immediateCondition"))) {
[16:01:45.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.629]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.629]                   if (TRUE && !signal) {
[16:01:45.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.629]                     {
[16:01:45.629]                       inherits <- base::inherits
[16:01:45.629]                       invokeRestart <- base::invokeRestart
[16:01:45.629]                       is.null <- base::is.null
[16:01:45.629]                       muffled <- FALSE
[16:01:45.629]                       if (inherits(cond, "message")) {
[16:01:45.629]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.629]                         if (muffled) 
[16:01:45.629]                           invokeRestart("muffleMessage")
[16:01:45.629]                       }
[16:01:45.629]                       else if (inherits(cond, "warning")) {
[16:01:45.629]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.629]                         if (muffled) 
[16:01:45.629]                           invokeRestart("muffleWarning")
[16:01:45.629]                       }
[16:01:45.629]                       else if (inherits(cond, "condition")) {
[16:01:45.629]                         if (!is.null(pattern)) {
[16:01:45.629]                           computeRestarts <- base::computeRestarts
[16:01:45.629]                           grepl <- base::grepl
[16:01:45.629]                           restarts <- computeRestarts(cond)
[16:01:45.629]                           for (restart in restarts) {
[16:01:45.629]                             name <- restart$name
[16:01:45.629]                             if (is.null(name)) 
[16:01:45.629]                               next
[16:01:45.629]                             if (!grepl(pattern, name)) 
[16:01:45.629]                               next
[16:01:45.629]                             invokeRestart(restart)
[16:01:45.629]                             muffled <- TRUE
[16:01:45.629]                             break
[16:01:45.629]                           }
[16:01:45.629]                         }
[16:01:45.629]                       }
[16:01:45.629]                       invisible(muffled)
[16:01:45.629]                     }
[16:01:45.629]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.629]                   }
[16:01:45.629]                 }
[16:01:45.629]                 else {
[16:01:45.629]                   if (TRUE) {
[16:01:45.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.629]                     {
[16:01:45.629]                       inherits <- base::inherits
[16:01:45.629]                       invokeRestart <- base::invokeRestart
[16:01:45.629]                       is.null <- base::is.null
[16:01:45.629]                       muffled <- FALSE
[16:01:45.629]                       if (inherits(cond, "message")) {
[16:01:45.629]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.629]                         if (muffled) 
[16:01:45.629]                           invokeRestart("muffleMessage")
[16:01:45.629]                       }
[16:01:45.629]                       else if (inherits(cond, "warning")) {
[16:01:45.629]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.629]                         if (muffled) 
[16:01:45.629]                           invokeRestart("muffleWarning")
[16:01:45.629]                       }
[16:01:45.629]                       else if (inherits(cond, "condition")) {
[16:01:45.629]                         if (!is.null(pattern)) {
[16:01:45.629]                           computeRestarts <- base::computeRestarts
[16:01:45.629]                           grepl <- base::grepl
[16:01:45.629]                           restarts <- computeRestarts(cond)
[16:01:45.629]                           for (restart in restarts) {
[16:01:45.629]                             name <- restart$name
[16:01:45.629]                             if (is.null(name)) 
[16:01:45.629]                               next
[16:01:45.629]                             if (!grepl(pattern, name)) 
[16:01:45.629]                               next
[16:01:45.629]                             invokeRestart(restart)
[16:01:45.629]                             muffled <- TRUE
[16:01:45.629]                             break
[16:01:45.629]                           }
[16:01:45.629]                         }
[16:01:45.629]                       }
[16:01:45.629]                       invisible(muffled)
[16:01:45.629]                     }
[16:01:45.629]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.629]                   }
[16:01:45.629]                 }
[16:01:45.629]             }
[16:01:45.629]         }))
[16:01:45.629]     }, error = function(ex) {
[16:01:45.629]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.629]                 ...future.rng), started = ...future.startTime, 
[16:01:45.629]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.629]             version = "1.8"), class = "FutureResult")
[16:01:45.629]     }, finally = {
[16:01:45.629]         if (!identical(...future.workdir, getwd())) 
[16:01:45.629]             setwd(...future.workdir)
[16:01:45.629]         {
[16:01:45.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.629]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.629]             }
[16:01:45.629]             base::options(...future.oldOptions)
[16:01:45.629]             if (.Platform$OS.type == "windows") {
[16:01:45.629]                 old_names <- names(...future.oldEnvVars)
[16:01:45.629]                 envs <- base::Sys.getenv()
[16:01:45.629]                 names <- names(envs)
[16:01:45.629]                 common <- intersect(names, old_names)
[16:01:45.629]                 added <- setdiff(names, old_names)
[16:01:45.629]                 removed <- setdiff(old_names, names)
[16:01:45.629]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.629]                   envs[common]]
[16:01:45.629]                 NAMES <- toupper(changed)
[16:01:45.629]                 args <- list()
[16:01:45.629]                 for (kk in seq_along(NAMES)) {
[16:01:45.629]                   name <- changed[[kk]]
[16:01:45.629]                   NAME <- NAMES[[kk]]
[16:01:45.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.629]                     next
[16:01:45.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.629]                 }
[16:01:45.629]                 NAMES <- toupper(added)
[16:01:45.629]                 for (kk in seq_along(NAMES)) {
[16:01:45.629]                   name <- added[[kk]]
[16:01:45.629]                   NAME <- NAMES[[kk]]
[16:01:45.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.629]                     next
[16:01:45.629]                   args[[name]] <- ""
[16:01:45.629]                 }
[16:01:45.629]                 NAMES <- toupper(removed)
[16:01:45.629]                 for (kk in seq_along(NAMES)) {
[16:01:45.629]                   name <- removed[[kk]]
[16:01:45.629]                   NAME <- NAMES[[kk]]
[16:01:45.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.629]                     next
[16:01:45.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.629]                 }
[16:01:45.629]                 if (length(args) > 0) 
[16:01:45.629]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.629]             }
[16:01:45.629]             else {
[16:01:45.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.629]             }
[16:01:45.629]             {
[16:01:45.629]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.629]                   0L) {
[16:01:45.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.629]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.629]                   base::options(opts)
[16:01:45.629]                 }
[16:01:45.629]                 {
[16:01:45.629]                   {
[16:01:45.629]                     NULL
[16:01:45.629]                     RNGkind("Mersenne-Twister")
[16:01:45.629]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.629]                       inherits = FALSE)
[16:01:45.629]                   }
[16:01:45.629]                   options(future.plan = NULL)
[16:01:45.629]                   if (is.na(NA_character_)) 
[16:01:45.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.629]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.629]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.629]                     envir = parent.frame()) 
[16:01:45.629]                   {
[16:01:45.629]                     if (is.function(workers)) 
[16:01:45.629]                       workers <- workers()
[16:01:45.629]                     workers <- structure(as.integer(workers), 
[16:01:45.629]                       class = class(workers))
[16:01:45.629]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.629]                       workers >= 1)
[16:01:45.629]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.629]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.629]                     }
[16:01:45.629]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.629]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.629]                       envir = envir)
[16:01:45.629]                     if (!future$lazy) 
[16:01:45.629]                       future <- run(future)
[16:01:45.629]                     invisible(future)
[16:01:45.629]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.629]                 }
[16:01:45.629]             }
[16:01:45.629]         }
[16:01:45.629]     })
[16:01:45.629]     if (TRUE) {
[16:01:45.629]         base::sink(type = "output", split = FALSE)
[16:01:45.629]         if (TRUE) {
[16:01:45.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.629]         }
[16:01:45.629]         else {
[16:01:45.629]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.629]         }
[16:01:45.629]         base::close(...future.stdout)
[16:01:45.629]         ...future.stdout <- NULL
[16:01:45.629]     }
[16:01:45.629]     ...future.result$conditions <- ...future.conditions
[16:01:45.629]     ...future.result$finished <- base::Sys.time()
[16:01:45.629]     ...future.result
[16:01:45.629] }
[16:01:45.630] assign_globals() ...
[16:01:45.631] List of 7
[16:01:45.631]  $ ...future.FUN            :function (x)  
[16:01:45.631]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:45.631]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.631]  $ future.call.arguments    : list()
[16:01:45.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.631]  $ ...future.elements_ii    :List of 3
[16:01:45.631]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.631]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.631]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.631]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.631]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.631]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.631]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.631]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.631]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.631]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.631]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.631]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.631]  $ ...future.seeds_ii       : NULL
[16:01:45.631]  $ ...future.globals.maxSize: NULL
[16:01:45.631]  - attr(*, "where")=List of 7
[16:01:45.631]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.631]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:01:45.631]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:01:45.631]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.631]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.631]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.631]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.631]  - attr(*, "resolved")= logi FALSE
[16:01:45.631]  - attr(*, "total_size")= num 2320
[16:01:45.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.631]  - attr(*, "already-done")= logi TRUE
[16:01:45.641] - reassign environment for ‘...future.FUN’
[16:01:45.641] - copied ‘...future.FUN’ to environment
[16:01:45.641] - copied ‘breaks’ to environment
[16:01:45.641] - copied ‘wool’ to environment
[16:01:45.641] - copied ‘future.call.arguments’ to environment
[16:01:45.641] - copied ‘...future.elements_ii’ to environment
[16:01:45.641] - copied ‘...future.seeds_ii’ to environment
[16:01:45.642] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.642] assign_globals() ... done
[16:01:45.642] plan(): Setting new future strategy stack:
[16:01:45.642] List of future strategies:
[16:01:45.642] 1. sequential:
[16:01:45.642]    - args: function (..., envir = parent.frame())
[16:01:45.642]    - tweaked: FALSE
[16:01:45.642]    - call: NULL
[16:01:45.642] plan(): nbrOfWorkers() = 1
[16:01:45.645] plan(): Setting new future strategy stack:
[16:01:45.645] List of future strategies:
[16:01:45.645] 1. multisession:
[16:01:45.645]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.645]    - tweaked: FALSE
[16:01:45.645]    - call: plan(strategy)
[16:01:45.649] plan(): nbrOfWorkers() = 1
[16:01:45.649] SequentialFuture started (and completed)
[16:01:45.649] - Launch lazy future ... done
[16:01:45.649] run() for ‘SequentialFuture’ ... done
[16:01:45.650] Created future:
[16:01:45.650] SequentialFuture:
[16:01:45.650] Label: ‘future_by-1’
[16:01:45.650] Expression:
[16:01:45.650] {
[16:01:45.650]     do.call(function(...) {
[16:01:45.650]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.650]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.650]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.650]             on.exit(options(oopts), add = TRUE)
[16:01:45.650]         }
[16:01:45.650]         {
[16:01:45.650]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.650]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.650]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.650]             })
[16:01:45.650]         }
[16:01:45.650]     }, args = future.call.arguments)
[16:01:45.650] }
[16:01:45.650] Lazy evaluation: FALSE
[16:01:45.650] Asynchronous evaluation: FALSE
[16:01:45.650] Local evaluation: TRUE
[16:01:45.650] Environment: 0x55b525d3bb38
[16:01:45.650] Capture standard output: TRUE
[16:01:45.650] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.650] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:01:45.650] Packages: 1 packages (‘stats’)
[16:01:45.650] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.650] Resolved: TRUE
[16:01:45.650] Value: 25.57 KiB of class ‘list’
[16:01:45.650] Early signaling: FALSE
[16:01:45.650] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.650] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.653] Chunk #1 of 1 ... DONE
[16:01:45.653] Launching 1 futures (chunks) ... DONE
[16:01:45.653] Resolving 1 futures (chunks) ...
[16:01:45.653] resolve() on list ...
[16:01:45.653]  recursive: 0
[16:01:45.653]  length: 1
[16:01:45.654] 
[16:01:45.654] resolved() for ‘SequentialFuture’ ...
[16:01:45.654] - state: ‘finished’
[16:01:45.654] - run: TRUE
[16:01:45.654] - result: ‘FutureResult’
[16:01:45.654] resolved() for ‘SequentialFuture’ ... done
[16:01:45.654] Future #1
[16:01:45.654] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.655] - nx: 1
[16:01:45.655] - relay: TRUE
[16:01:45.655] - stdout: TRUE
[16:01:45.655] - signal: TRUE
[16:01:45.655] - resignal: FALSE
[16:01:45.655] - force: TRUE
[16:01:45.655] - relayed: [n=1] FALSE
[16:01:45.655] - queued futures: [n=1] FALSE
[16:01:45.655]  - until=1
[16:01:45.655]  - relaying element #1
[16:01:45.656] - relayed: [n=1] TRUE
[16:01:45.656] - queued futures: [n=1] TRUE
[16:01:45.656] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.656]  length: 0 (resolved future 1)
[16:01:45.656] Relaying remaining futures
[16:01:45.656] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.656] - nx: 1
[16:01:45.656] - relay: TRUE
[16:01:45.656] - stdout: TRUE
[16:01:45.656] - signal: TRUE
[16:01:45.656] - resignal: FALSE
[16:01:45.657] - force: TRUE
[16:01:45.657] - relayed: [n=1] TRUE
[16:01:45.657] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.657] - relayed: [n=1] TRUE
[16:01:45.657] - queued futures: [n=1] TRUE
[16:01:45.657] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.657] resolve() on list ... DONE
[16:01:45.657]  - Number of value chunks collected: 1
[16:01:45.657] Resolving 1 futures (chunks) ... DONE
[16:01:45.657] Reducing values from 1 chunks ...
[16:01:45.658]  - Number of values collected after concatenation: 3
[16:01:45.658]  - Number of values expected: 3
[16:01:45.658] Reducing values from 1 chunks ... DONE
[16:01:45.658] future_lapply() ... DONE
[16:01:45.658] future_by_internal() ... DONE
[16:01:45.658] future_by_internal() ...
[16:01:45.659] future_lapply() ...
[16:01:45.662] Number of chunks: 1
[16:01:45.662] getGlobalsAndPackagesXApply() ...
[16:01:45.662]  - future.globals: TRUE
[16:01:45.663] getGlobalsAndPackages() ...
[16:01:45.663] Searching for globals...
[16:01:45.664] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.664] Searching for globals ... DONE
[16:01:45.664] Resolving globals: FALSE
[16:01:45.664] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.665] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.665] - globals: [1] ‘FUN’
[16:01:45.665] 
[16:01:45.665] getGlobalsAndPackages() ... DONE
[16:01:45.665]  - globals found/used: [n=1] ‘FUN’
[16:01:45.665]  - needed namespaces: [n=0] 
[16:01:45.665] Finding globals ... DONE
[16:01:45.665]  - use_args: TRUE
[16:01:45.665]  - Getting '...' globals ...
[16:01:45.666] resolve() on list ...
[16:01:45.666]  recursive: 0
[16:01:45.666]  length: 1
[16:01:45.666]  elements: ‘...’
[16:01:45.666]  length: 0 (resolved future 1)
[16:01:45.666] resolve() on list ... DONE
[16:01:45.666]    - '...' content: [n=0] 
[16:01:45.666] List of 1
[16:01:45.666]  $ ...: list()
[16:01:45.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.666]  - attr(*, "where")=List of 1
[16:01:45.666]   ..$ ...:<environment: 0x55b523b9ec80> 
[16:01:45.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.666]  - attr(*, "resolved")= logi TRUE
[16:01:45.666]  - attr(*, "total_size")= num NA
[16:01:45.669]  - Getting '...' globals ... DONE
[16:01:45.669] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.669] List of 2
[16:01:45.669]  $ ...future.FUN:function (object, ...)  
[16:01:45.669]  $ ...          : list()
[16:01:45.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.669]  - attr(*, "where")=List of 2
[16:01:45.669]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.669]   ..$ ...          :<environment: 0x55b523b9ec80> 
[16:01:45.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.669]  - attr(*, "resolved")= logi FALSE
[16:01:45.669]  - attr(*, "total_size")= num 1240
[16:01:45.672] Packages to be attached in all futures: [n=0] 
[16:01:45.672] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.672] Number of futures (= number of chunks): 1
[16:01:45.673] Launching 1 futures (chunks) ...
[16:01:45.673] Chunk #1 of 1 ...
[16:01:45.673]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.673] getGlobalsAndPackages() ...
[16:01:45.673] Searching for globals...
[16:01:45.675] 
[16:01:45.675] Searching for globals ... DONE
[16:01:45.675] - globals: [0] <none>
[16:01:45.676] getGlobalsAndPackages() ... DONE
[16:01:45.676]    + additional globals found: [n=0] 
[16:01:45.676]    + additional namespaces needed: [n=0] 
[16:01:45.676]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.676]  - seeds: <none>
[16:01:45.676]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.676] getGlobalsAndPackages() ...
[16:01:45.676] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.677] Resolving globals: FALSE
[16:01:45.677] Tweak future expression to call with '...' arguments ...
[16:01:45.677] {
[16:01:45.677]     do.call(function(...) {
[16:01:45.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.677]             on.exit(options(oopts), add = TRUE)
[16:01:45.677]         }
[16:01:45.677]         {
[16:01:45.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.677]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.677]             })
[16:01:45.677]         }
[16:01:45.677]     }, args = future.call.arguments)
[16:01:45.677] }
[16:01:45.677] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.678] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.678] 
[16:01:45.678] getGlobalsAndPackages() ... DONE
[16:01:45.678] run() for ‘Future’ ...
[16:01:45.678] - state: ‘created’
[16:01:45.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.682] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.682]   - Field: ‘label’
[16:01:45.682]   - Field: ‘local’
[16:01:45.683]   - Field: ‘owner’
[16:01:45.683]   - Field: ‘envir’
[16:01:45.683]   - Field: ‘packages’
[16:01:45.683]   - Field: ‘gc’
[16:01:45.683]   - Field: ‘conditions’
[16:01:45.683]   - Field: ‘expr’
[16:01:45.683]   - Field: ‘uuid’
[16:01:45.683]   - Field: ‘seed’
[16:01:45.683]   - Field: ‘version’
[16:01:45.683]   - Field: ‘result’
[16:01:45.684]   - Field: ‘asynchronous’
[16:01:45.684]   - Field: ‘calls’
[16:01:45.684]   - Field: ‘globals’
[16:01:45.684]   - Field: ‘stdout’
[16:01:45.684]   - Field: ‘earlySignal’
[16:01:45.684]   - Field: ‘lazy’
[16:01:45.684]   - Field: ‘state’
[16:01:45.684] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.684] - Launch lazy future ...
[16:01:45.685] Packages needed by the future expression (n = 0): <none>
[16:01:45.685] Packages needed by future strategies (n = 0): <none>
[16:01:45.685] {
[16:01:45.685]     {
[16:01:45.685]         {
[16:01:45.685]             ...future.startTime <- base::Sys.time()
[16:01:45.685]             {
[16:01:45.685]                 {
[16:01:45.685]                   {
[16:01:45.685]                     base::local({
[16:01:45.685]                       has_future <- base::requireNamespace("future", 
[16:01:45.685]                         quietly = TRUE)
[16:01:45.685]                       if (has_future) {
[16:01:45.685]                         ns <- base::getNamespace("future")
[16:01:45.685]                         version <- ns[[".package"]][["version"]]
[16:01:45.685]                         if (is.null(version)) 
[16:01:45.685]                           version <- utils::packageVersion("future")
[16:01:45.685]                       }
[16:01:45.685]                       else {
[16:01:45.685]                         version <- NULL
[16:01:45.685]                       }
[16:01:45.685]                       if (!has_future || version < "1.8.0") {
[16:01:45.685]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.685]                           "", base::R.version$version.string), 
[16:01:45.685]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.685]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.685]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.685]                             "release", "version")], collapse = " "), 
[16:01:45.685]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.685]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.685]                           info)
[16:01:45.685]                         info <- base::paste(info, collapse = "; ")
[16:01:45.685]                         if (!has_future) {
[16:01:45.685]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.685]                             info)
[16:01:45.685]                         }
[16:01:45.685]                         else {
[16:01:45.685]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.685]                             info, version)
[16:01:45.685]                         }
[16:01:45.685]                         base::stop(msg)
[16:01:45.685]                       }
[16:01:45.685]                     })
[16:01:45.685]                   }
[16:01:45.685]                   options(future.plan = NULL)
[16:01:45.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.685]                 }
[16:01:45.685]                 ...future.workdir <- getwd()
[16:01:45.685]             }
[16:01:45.685]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.685]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.685]         }
[16:01:45.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.685]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.685]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.685]             base::names(...future.oldOptions))
[16:01:45.685]     }
[16:01:45.685]     if (FALSE) {
[16:01:45.685]     }
[16:01:45.685]     else {
[16:01:45.685]         if (TRUE) {
[16:01:45.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.685]                 open = "w")
[16:01:45.685]         }
[16:01:45.685]         else {
[16:01:45.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.685]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.685]         }
[16:01:45.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.685]             base::sink(type = "output", split = FALSE)
[16:01:45.685]             base::close(...future.stdout)
[16:01:45.685]         }, add = TRUE)
[16:01:45.685]     }
[16:01:45.685]     ...future.frame <- base::sys.nframe()
[16:01:45.685]     ...future.conditions <- base::list()
[16:01:45.685]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.685]     if (FALSE) {
[16:01:45.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.685]     }
[16:01:45.685]     ...future.result <- base::tryCatch({
[16:01:45.685]         base::withCallingHandlers({
[16:01:45.685]             ...future.value <- base::withVisible(base::local({
[16:01:45.685]                 do.call(function(...) {
[16:01:45.685]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.685]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.685]                     ...future.globals.maxSize)) {
[16:01:45.685]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.685]                     on.exit(options(oopts), add = TRUE)
[16:01:45.685]                   }
[16:01:45.685]                   {
[16:01:45.685]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.685]                       FUN = function(jj) {
[16:01:45.685]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.685]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.685]                       })
[16:01:45.685]                   }
[16:01:45.685]                 }, args = future.call.arguments)
[16:01:45.685]             }))
[16:01:45.685]             future::FutureResult(value = ...future.value$value, 
[16:01:45.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.685]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.685]                     ...future.globalenv.names))
[16:01:45.685]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.685]         }, condition = base::local({
[16:01:45.685]             c <- base::c
[16:01:45.685]             inherits <- base::inherits
[16:01:45.685]             invokeRestart <- base::invokeRestart
[16:01:45.685]             length <- base::length
[16:01:45.685]             list <- base::list
[16:01:45.685]             seq.int <- base::seq.int
[16:01:45.685]             signalCondition <- base::signalCondition
[16:01:45.685]             sys.calls <- base::sys.calls
[16:01:45.685]             `[[` <- base::`[[`
[16:01:45.685]             `+` <- base::`+`
[16:01:45.685]             `<<-` <- base::`<<-`
[16:01:45.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.685]                   3L)]
[16:01:45.685]             }
[16:01:45.685]             function(cond) {
[16:01:45.685]                 is_error <- inherits(cond, "error")
[16:01:45.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.685]                   NULL)
[16:01:45.685]                 if (is_error) {
[16:01:45.685]                   sessionInformation <- function() {
[16:01:45.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.685]                       search = base::search(), system = base::Sys.info())
[16:01:45.685]                   }
[16:01:45.685]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.685]                     cond$call), session = sessionInformation(), 
[16:01:45.685]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.685]                   signalCondition(cond)
[16:01:45.685]                 }
[16:01:45.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.685]                 "immediateCondition"))) {
[16:01:45.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.685]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.685]                   if (TRUE && !signal) {
[16:01:45.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.685]                     {
[16:01:45.685]                       inherits <- base::inherits
[16:01:45.685]                       invokeRestart <- base::invokeRestart
[16:01:45.685]                       is.null <- base::is.null
[16:01:45.685]                       muffled <- FALSE
[16:01:45.685]                       if (inherits(cond, "message")) {
[16:01:45.685]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.685]                         if (muffled) 
[16:01:45.685]                           invokeRestart("muffleMessage")
[16:01:45.685]                       }
[16:01:45.685]                       else if (inherits(cond, "warning")) {
[16:01:45.685]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.685]                         if (muffled) 
[16:01:45.685]                           invokeRestart("muffleWarning")
[16:01:45.685]                       }
[16:01:45.685]                       else if (inherits(cond, "condition")) {
[16:01:45.685]                         if (!is.null(pattern)) {
[16:01:45.685]                           computeRestarts <- base::computeRestarts
[16:01:45.685]                           grepl <- base::grepl
[16:01:45.685]                           restarts <- computeRestarts(cond)
[16:01:45.685]                           for (restart in restarts) {
[16:01:45.685]                             name <- restart$name
[16:01:45.685]                             if (is.null(name)) 
[16:01:45.685]                               next
[16:01:45.685]                             if (!grepl(pattern, name)) 
[16:01:45.685]                               next
[16:01:45.685]                             invokeRestart(restart)
[16:01:45.685]                             muffled <- TRUE
[16:01:45.685]                             break
[16:01:45.685]                           }
[16:01:45.685]                         }
[16:01:45.685]                       }
[16:01:45.685]                       invisible(muffled)
[16:01:45.685]                     }
[16:01:45.685]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.685]                   }
[16:01:45.685]                 }
[16:01:45.685]                 else {
[16:01:45.685]                   if (TRUE) {
[16:01:45.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.685]                     {
[16:01:45.685]                       inherits <- base::inherits
[16:01:45.685]                       invokeRestart <- base::invokeRestart
[16:01:45.685]                       is.null <- base::is.null
[16:01:45.685]                       muffled <- FALSE
[16:01:45.685]                       if (inherits(cond, "message")) {
[16:01:45.685]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.685]                         if (muffled) 
[16:01:45.685]                           invokeRestart("muffleMessage")
[16:01:45.685]                       }
[16:01:45.685]                       else if (inherits(cond, "warning")) {
[16:01:45.685]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.685]                         if (muffled) 
[16:01:45.685]                           invokeRestart("muffleWarning")
[16:01:45.685]                       }
[16:01:45.685]                       else if (inherits(cond, "condition")) {
[16:01:45.685]                         if (!is.null(pattern)) {
[16:01:45.685]                           computeRestarts <- base::computeRestarts
[16:01:45.685]                           grepl <- base::grepl
[16:01:45.685]                           restarts <- computeRestarts(cond)
[16:01:45.685]                           for (restart in restarts) {
[16:01:45.685]                             name <- restart$name
[16:01:45.685]                             if (is.null(name)) 
[16:01:45.685]                               next
[16:01:45.685]                             if (!grepl(pattern, name)) 
[16:01:45.685]                               next
[16:01:45.685]                             invokeRestart(restart)
[16:01:45.685]                             muffled <- TRUE
[16:01:45.685]                             break
[16:01:45.685]                           }
[16:01:45.685]                         }
[16:01:45.685]                       }
[16:01:45.685]                       invisible(muffled)
[16:01:45.685]                     }
[16:01:45.685]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.685]                   }
[16:01:45.685]                 }
[16:01:45.685]             }
[16:01:45.685]         }))
[16:01:45.685]     }, error = function(ex) {
[16:01:45.685]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.685]                 ...future.rng), started = ...future.startTime, 
[16:01:45.685]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.685]             version = "1.8"), class = "FutureResult")
[16:01:45.685]     }, finally = {
[16:01:45.685]         if (!identical(...future.workdir, getwd())) 
[16:01:45.685]             setwd(...future.workdir)
[16:01:45.685]         {
[16:01:45.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.685]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.685]             }
[16:01:45.685]             base::options(...future.oldOptions)
[16:01:45.685]             if (.Platform$OS.type == "windows") {
[16:01:45.685]                 old_names <- names(...future.oldEnvVars)
[16:01:45.685]                 envs <- base::Sys.getenv()
[16:01:45.685]                 names <- names(envs)
[16:01:45.685]                 common <- intersect(names, old_names)
[16:01:45.685]                 added <- setdiff(names, old_names)
[16:01:45.685]                 removed <- setdiff(old_names, names)
[16:01:45.685]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.685]                   envs[common]]
[16:01:45.685]                 NAMES <- toupper(changed)
[16:01:45.685]                 args <- list()
[16:01:45.685]                 for (kk in seq_along(NAMES)) {
[16:01:45.685]                   name <- changed[[kk]]
[16:01:45.685]                   NAME <- NAMES[[kk]]
[16:01:45.685]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.685]                     next
[16:01:45.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.685]                 }
[16:01:45.685]                 NAMES <- toupper(added)
[16:01:45.685]                 for (kk in seq_along(NAMES)) {
[16:01:45.685]                   name <- added[[kk]]
[16:01:45.685]                   NAME <- NAMES[[kk]]
[16:01:45.685]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.685]                     next
[16:01:45.685]                   args[[name]] <- ""
[16:01:45.685]                 }
[16:01:45.685]                 NAMES <- toupper(removed)
[16:01:45.685]                 for (kk in seq_along(NAMES)) {
[16:01:45.685]                   name <- removed[[kk]]
[16:01:45.685]                   NAME <- NAMES[[kk]]
[16:01:45.685]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.685]                     next
[16:01:45.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.685]                 }
[16:01:45.685]                 if (length(args) > 0) 
[16:01:45.685]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.685]             }
[16:01:45.685]             else {
[16:01:45.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.685]             }
[16:01:45.685]             {
[16:01:45.685]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.685]                   0L) {
[16:01:45.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.685]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.685]                   base::options(opts)
[16:01:45.685]                 }
[16:01:45.685]                 {
[16:01:45.685]                   {
[16:01:45.685]                     NULL
[16:01:45.685]                     RNGkind("Mersenne-Twister")
[16:01:45.685]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.685]                       inherits = FALSE)
[16:01:45.685]                   }
[16:01:45.685]                   options(future.plan = NULL)
[16:01:45.685]                   if (is.na(NA_character_)) 
[16:01:45.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.685]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.685]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.685]                     envir = parent.frame()) 
[16:01:45.685]                   {
[16:01:45.685]                     if (is.function(workers)) 
[16:01:45.685]                       workers <- workers()
[16:01:45.685]                     workers <- structure(as.integer(workers), 
[16:01:45.685]                       class = class(workers))
[16:01:45.685]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.685]                       workers >= 1)
[16:01:45.685]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.685]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.685]                     }
[16:01:45.685]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.685]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.685]                       envir = envir)
[16:01:45.685]                     if (!future$lazy) 
[16:01:45.685]                       future <- run(future)
[16:01:45.685]                     invisible(future)
[16:01:45.685]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.685]                 }
[16:01:45.685]             }
[16:01:45.685]         }
[16:01:45.685]     })
[16:01:45.685]     if (TRUE) {
[16:01:45.685]         base::sink(type = "output", split = FALSE)
[16:01:45.685]         if (TRUE) {
[16:01:45.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.685]         }
[16:01:45.685]         else {
[16:01:45.685]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.685]         }
[16:01:45.685]         base::close(...future.stdout)
[16:01:45.685]         ...future.stdout <- NULL
[16:01:45.685]     }
[16:01:45.685]     ...future.result$conditions <- ...future.conditions
[16:01:45.685]     ...future.result$finished <- base::Sys.time()
[16:01:45.685]     ...future.result
[16:01:45.685] }
[16:01:45.687] assign_globals() ...
[16:01:45.687] List of 5
[16:01:45.687]  $ ...future.FUN            :function (object, ...)  
[16:01:45.687]  $ future.call.arguments    : list()
[16:01:45.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.687]  $ ...future.elements_ii    :List of 3
[16:01:45.687]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.687]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.687]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.687]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.687]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.687]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.687]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.687]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.687]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.687]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.687]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.687]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.687]  $ ...future.seeds_ii       : NULL
[16:01:45.687]  $ ...future.globals.maxSize: NULL
[16:01:45.687]  - attr(*, "where")=List of 5
[16:01:45.687]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.687]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.687]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.687]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.687]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.687]  - attr(*, "resolved")= logi FALSE
[16:01:45.687]  - attr(*, "total_size")= num 1240
[16:01:45.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.687]  - attr(*, "already-done")= logi TRUE
[16:01:45.696] - copied ‘...future.FUN’ to environment
[16:01:45.696] - copied ‘future.call.arguments’ to environment
[16:01:45.696] - copied ‘...future.elements_ii’ to environment
[16:01:45.696] - copied ‘...future.seeds_ii’ to environment
[16:01:45.696] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.696] assign_globals() ... done
[16:01:45.697] plan(): Setting new future strategy stack:
[16:01:45.697] List of future strategies:
[16:01:45.697] 1. sequential:
[16:01:45.697]    - args: function (..., envir = parent.frame())
[16:01:45.697]    - tweaked: FALSE
[16:01:45.697]    - call: NULL
[16:01:45.697] plan(): nbrOfWorkers() = 1
[16:01:45.702] plan(): Setting new future strategy stack:
[16:01:45.702] List of future strategies:
[16:01:45.702] 1. multisession:
[16:01:45.702]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.702]    - tweaked: FALSE
[16:01:45.702]    - call: plan(strategy)
[16:01:45.706] plan(): nbrOfWorkers() = 1
[16:01:45.706] SequentialFuture started (and completed)
[16:01:45.706] - Launch lazy future ... done
[16:01:45.706] run() for ‘SequentialFuture’ ... done
[16:01:45.706] Created future:
[16:01:45.707] SequentialFuture:
[16:01:45.707] Label: ‘future_by-1’
[16:01:45.707] Expression:
[16:01:45.707] {
[16:01:45.707]     do.call(function(...) {
[16:01:45.707]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.707]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.707]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.707]             on.exit(options(oopts), add = TRUE)
[16:01:45.707]         }
[16:01:45.707]         {
[16:01:45.707]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.707]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.707]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.707]             })
[16:01:45.707]         }
[16:01:45.707]     }, args = future.call.arguments)
[16:01:45.707] }
[16:01:45.707] Lazy evaluation: FALSE
[16:01:45.707] Asynchronous evaluation: FALSE
[16:01:45.707] Local evaluation: TRUE
[16:01:45.707] Environment: 0x55b5241fb040
[16:01:45.707] Capture standard output: TRUE
[16:01:45.707] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.707] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.707] Packages: <none>
[16:01:45.707] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.707] Resolved: TRUE
[16:01:45.707] Value: 5.37 KiB of class ‘list’
[16:01:45.707] Early signaling: FALSE
[16:01:45.707] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.707] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.708] Chunk #1 of 1 ... DONE
[16:01:45.708] Launching 1 futures (chunks) ... DONE
[16:01:45.708] Resolving 1 futures (chunks) ...
[16:01:45.708] resolve() on list ...
[16:01:45.708]  recursive: 0
[16:01:45.709]  length: 1
[16:01:45.709] 
[16:01:45.709] resolved() for ‘SequentialFuture’ ...
[16:01:45.709] - state: ‘finished’
[16:01:45.709] - run: TRUE
[16:01:45.709] - result: ‘FutureResult’
[16:01:45.709] resolved() for ‘SequentialFuture’ ... done
[16:01:45.709] Future #1
[16:01:45.709] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.709] - nx: 1
[16:01:45.710] - relay: TRUE
[16:01:45.710] - stdout: TRUE
[16:01:45.710] - signal: TRUE
[16:01:45.710] - resignal: FALSE
[16:01:45.710] - force: TRUE
[16:01:45.710] - relayed: [n=1] FALSE
[16:01:45.710] - queued futures: [n=1] FALSE
[16:01:45.710]  - until=1
[16:01:45.710]  - relaying element #1
[16:01:45.710] - relayed: [n=1] TRUE
[16:01:45.711] - queued futures: [n=1] TRUE
[16:01:45.711] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.711]  length: 0 (resolved future 1)
[16:01:45.711] Relaying remaining futures
[16:01:45.711] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.711] - nx: 1
[16:01:45.711] - relay: TRUE
[16:01:45.711] - stdout: TRUE
[16:01:45.711] - signal: TRUE
[16:01:45.711] - resignal: FALSE
[16:01:45.712] - force: TRUE
[16:01:45.712] - relayed: [n=1] TRUE
[16:01:45.712] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.712] - relayed: [n=1] TRUE
[16:01:45.712] - queued futures: [n=1] TRUE
[16:01:45.712] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.712] resolve() on list ... DONE
[16:01:45.712]  - Number of value chunks collected: 1
[16:01:45.712] Resolving 1 futures (chunks) ... DONE
[16:01:45.712] Reducing values from 1 chunks ...
[16:01:45.713]  - Number of values collected after concatenation: 3
[16:01:45.713]  - Number of values expected: 3
[16:01:45.713] Reducing values from 1 chunks ... DONE
[16:01:45.713] future_lapply() ... DONE
[16:01:45.713] future_by_internal() ... DONE
[16:01:45.714] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:01:45.714] future_lapply() ...
[16:01:45.718] Number of chunks: 1
[16:01:45.718] getGlobalsAndPackagesXApply() ...
[16:01:45.718]  - future.globals: TRUE
[16:01:45.718] getGlobalsAndPackages() ...
[16:01:45.718] Searching for globals...
[16:01:45.720] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.720] Searching for globals ... DONE
[16:01:45.720] Resolving globals: FALSE
[16:01:45.720] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.721] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.721] - globals: [1] ‘FUN’
[16:01:45.721] 
[16:01:45.721] getGlobalsAndPackages() ... DONE
[16:01:45.721]  - globals found/used: [n=1] ‘FUN’
[16:01:45.721]  - needed namespaces: [n=0] 
[16:01:45.721] Finding globals ... DONE
[16:01:45.721]  - use_args: TRUE
[16:01:45.721]  - Getting '...' globals ...
[16:01:45.722] resolve() on list ...
[16:01:45.722]  recursive: 0
[16:01:45.722]  length: 1
[16:01:45.722]  elements: ‘...’
[16:01:45.722]  length: 0 (resolved future 1)
[16:01:45.722] resolve() on list ... DONE
[16:01:45.722]    - '...' content: [n=0] 
[16:01:45.722] List of 1
[16:01:45.722]  $ ...: list()
[16:01:45.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.722]  - attr(*, "where")=List of 1
[16:01:45.722]   ..$ ...:<environment: 0x55b5259c3578> 
[16:01:45.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.722]  - attr(*, "resolved")= logi TRUE
[16:01:45.722]  - attr(*, "total_size")= num NA
[16:01:45.728]  - Getting '...' globals ... DONE
[16:01:45.728] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.729] List of 2
[16:01:45.729]  $ ...future.FUN:function (object, ...)  
[16:01:45.729]  $ ...          : list()
[16:01:45.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.729]  - attr(*, "where")=List of 2
[16:01:45.729]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.729]   ..$ ...          :<environment: 0x55b5259c3578> 
[16:01:45.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.729]  - attr(*, "resolved")= logi FALSE
[16:01:45.729]  - attr(*, "total_size")= num 1240
[16:01:45.732] Packages to be attached in all futures: [n=0] 
[16:01:45.732] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.732] Number of futures (= number of chunks): 1
[16:01:45.732] Launching 1 futures (chunks) ...
[16:01:45.732] Chunk #1 of 1 ...
[16:01:45.732]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.733] getGlobalsAndPackages() ...
[16:01:45.733] Searching for globals...
[16:01:45.733] 
[16:01:45.733] Searching for globals ... DONE
[16:01:45.733] - globals: [0] <none>
[16:01:45.733] getGlobalsAndPackages() ... DONE
[16:01:45.733]    + additional globals found: [n=0] 
[16:01:45.734]    + additional namespaces needed: [n=0] 
[16:01:45.734]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.734]  - seeds: <none>
[16:01:45.734]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.734] getGlobalsAndPackages() ...
[16:01:45.734] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.734] Resolving globals: FALSE
[16:01:45.734] Tweak future expression to call with '...' arguments ...
[16:01:45.734] {
[16:01:45.734]     do.call(function(...) {
[16:01:45.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.734]             on.exit(options(oopts), add = TRUE)
[16:01:45.734]         }
[16:01:45.734]         {
[16:01:45.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.734]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.734]             })
[16:01:45.734]         }
[16:01:45.734]     }, args = future.call.arguments)
[16:01:45.734] }
[16:01:45.735] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.735] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.735] 
[16:01:45.735] getGlobalsAndPackages() ... DONE
[16:01:45.736] run() for ‘Future’ ...
[16:01:45.736] - state: ‘created’
[16:01:45.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:45.739] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.740]   - Field: ‘label’
[16:01:45.740]   - Field: ‘local’
[16:01:45.740]   - Field: ‘owner’
[16:01:45.740]   - Field: ‘envir’
[16:01:45.740]   - Field: ‘packages’
[16:01:45.740]   - Field: ‘gc’
[16:01:45.740]   - Field: ‘conditions’
[16:01:45.740]   - Field: ‘expr’
[16:01:45.740]   - Field: ‘uuid’
[16:01:45.740]   - Field: ‘seed’
[16:01:45.741]   - Field: ‘version’
[16:01:45.741]   - Field: ‘result’
[16:01:45.741]   - Field: ‘asynchronous’
[16:01:45.741]   - Field: ‘calls’
[16:01:45.741]   - Field: ‘globals’
[16:01:45.741]   - Field: ‘stdout’
[16:01:45.741]   - Field: ‘earlySignal’
[16:01:45.741]   - Field: ‘lazy’
[16:01:45.741]   - Field: ‘state’
[16:01:45.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.742] - Launch lazy future ...
[16:01:45.742] Packages needed by the future expression (n = 0): <none>
[16:01:45.742] Packages needed by future strategies (n = 0): <none>
[16:01:45.742] {
[16:01:45.742]     {
[16:01:45.742]         {
[16:01:45.742]             ...future.startTime <- base::Sys.time()
[16:01:45.742]             {
[16:01:45.742]                 {
[16:01:45.742]                   {
[16:01:45.742]                     base::local({
[16:01:45.742]                       has_future <- base::requireNamespace("future", 
[16:01:45.742]                         quietly = TRUE)
[16:01:45.742]                       if (has_future) {
[16:01:45.742]                         ns <- base::getNamespace("future")
[16:01:45.742]                         version <- ns[[".package"]][["version"]]
[16:01:45.742]                         if (is.null(version)) 
[16:01:45.742]                           version <- utils::packageVersion("future")
[16:01:45.742]                       }
[16:01:45.742]                       else {
[16:01:45.742]                         version <- NULL
[16:01:45.742]                       }
[16:01:45.742]                       if (!has_future || version < "1.8.0") {
[16:01:45.742]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.742]                           "", base::R.version$version.string), 
[16:01:45.742]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.742]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.742]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.742]                             "release", "version")], collapse = " "), 
[16:01:45.742]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.742]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.742]                           info)
[16:01:45.742]                         info <- base::paste(info, collapse = "; ")
[16:01:45.742]                         if (!has_future) {
[16:01:45.742]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.742]                             info)
[16:01:45.742]                         }
[16:01:45.742]                         else {
[16:01:45.742]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.742]                             info, version)
[16:01:45.742]                         }
[16:01:45.742]                         base::stop(msg)
[16:01:45.742]                       }
[16:01:45.742]                     })
[16:01:45.742]                   }
[16:01:45.742]                   options(future.plan = NULL)
[16:01:45.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.742]                 }
[16:01:45.742]                 ...future.workdir <- getwd()
[16:01:45.742]             }
[16:01:45.742]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.742]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.742]         }
[16:01:45.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.742]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.742]             base::names(...future.oldOptions))
[16:01:45.742]     }
[16:01:45.742]     if (FALSE) {
[16:01:45.742]     }
[16:01:45.742]     else {
[16:01:45.742]         if (TRUE) {
[16:01:45.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.742]                 open = "w")
[16:01:45.742]         }
[16:01:45.742]         else {
[16:01:45.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.742]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.742]         }
[16:01:45.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.742]             base::sink(type = "output", split = FALSE)
[16:01:45.742]             base::close(...future.stdout)
[16:01:45.742]         }, add = TRUE)
[16:01:45.742]     }
[16:01:45.742]     ...future.frame <- base::sys.nframe()
[16:01:45.742]     ...future.conditions <- base::list()
[16:01:45.742]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.742]     if (FALSE) {
[16:01:45.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.742]     }
[16:01:45.742]     ...future.result <- base::tryCatch({
[16:01:45.742]         base::withCallingHandlers({
[16:01:45.742]             ...future.value <- base::withVisible(base::local({
[16:01:45.742]                 do.call(function(...) {
[16:01:45.742]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.742]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.742]                     ...future.globals.maxSize)) {
[16:01:45.742]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.742]                     on.exit(options(oopts), add = TRUE)
[16:01:45.742]                   }
[16:01:45.742]                   {
[16:01:45.742]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.742]                       FUN = function(jj) {
[16:01:45.742]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.742]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.742]                       })
[16:01:45.742]                   }
[16:01:45.742]                 }, args = future.call.arguments)
[16:01:45.742]             }))
[16:01:45.742]             future::FutureResult(value = ...future.value$value, 
[16:01:45.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.742]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.742]                     ...future.globalenv.names))
[16:01:45.742]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.742]         }, condition = base::local({
[16:01:45.742]             c <- base::c
[16:01:45.742]             inherits <- base::inherits
[16:01:45.742]             invokeRestart <- base::invokeRestart
[16:01:45.742]             length <- base::length
[16:01:45.742]             list <- base::list
[16:01:45.742]             seq.int <- base::seq.int
[16:01:45.742]             signalCondition <- base::signalCondition
[16:01:45.742]             sys.calls <- base::sys.calls
[16:01:45.742]             `[[` <- base::`[[`
[16:01:45.742]             `+` <- base::`+`
[16:01:45.742]             `<<-` <- base::`<<-`
[16:01:45.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.742]                   3L)]
[16:01:45.742]             }
[16:01:45.742]             function(cond) {
[16:01:45.742]                 is_error <- inherits(cond, "error")
[16:01:45.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.742]                   NULL)
[16:01:45.742]                 if (is_error) {
[16:01:45.742]                   sessionInformation <- function() {
[16:01:45.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.742]                       search = base::search(), system = base::Sys.info())
[16:01:45.742]                   }
[16:01:45.742]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.742]                     cond$call), session = sessionInformation(), 
[16:01:45.742]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.742]                   signalCondition(cond)
[16:01:45.742]                 }
[16:01:45.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.742]                 "immediateCondition"))) {
[16:01:45.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.742]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.742]                   if (TRUE && !signal) {
[16:01:45.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.742]                     {
[16:01:45.742]                       inherits <- base::inherits
[16:01:45.742]                       invokeRestart <- base::invokeRestart
[16:01:45.742]                       is.null <- base::is.null
[16:01:45.742]                       muffled <- FALSE
[16:01:45.742]                       if (inherits(cond, "message")) {
[16:01:45.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.742]                         if (muffled) 
[16:01:45.742]                           invokeRestart("muffleMessage")
[16:01:45.742]                       }
[16:01:45.742]                       else if (inherits(cond, "warning")) {
[16:01:45.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.742]                         if (muffled) 
[16:01:45.742]                           invokeRestart("muffleWarning")
[16:01:45.742]                       }
[16:01:45.742]                       else if (inherits(cond, "condition")) {
[16:01:45.742]                         if (!is.null(pattern)) {
[16:01:45.742]                           computeRestarts <- base::computeRestarts
[16:01:45.742]                           grepl <- base::grepl
[16:01:45.742]                           restarts <- computeRestarts(cond)
[16:01:45.742]                           for (restart in restarts) {
[16:01:45.742]                             name <- restart$name
[16:01:45.742]                             if (is.null(name)) 
[16:01:45.742]                               next
[16:01:45.742]                             if (!grepl(pattern, name)) 
[16:01:45.742]                               next
[16:01:45.742]                             invokeRestart(restart)
[16:01:45.742]                             muffled <- TRUE
[16:01:45.742]                             break
[16:01:45.742]                           }
[16:01:45.742]                         }
[16:01:45.742]                       }
[16:01:45.742]                       invisible(muffled)
[16:01:45.742]                     }
[16:01:45.742]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.742]                   }
[16:01:45.742]                 }
[16:01:45.742]                 else {
[16:01:45.742]                   if (TRUE) {
[16:01:45.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.742]                     {
[16:01:45.742]                       inherits <- base::inherits
[16:01:45.742]                       invokeRestart <- base::invokeRestart
[16:01:45.742]                       is.null <- base::is.null
[16:01:45.742]                       muffled <- FALSE
[16:01:45.742]                       if (inherits(cond, "message")) {
[16:01:45.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.742]                         if (muffled) 
[16:01:45.742]                           invokeRestart("muffleMessage")
[16:01:45.742]                       }
[16:01:45.742]                       else if (inherits(cond, "warning")) {
[16:01:45.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.742]                         if (muffled) 
[16:01:45.742]                           invokeRestart("muffleWarning")
[16:01:45.742]                       }
[16:01:45.742]                       else if (inherits(cond, "condition")) {
[16:01:45.742]                         if (!is.null(pattern)) {
[16:01:45.742]                           computeRestarts <- base::computeRestarts
[16:01:45.742]                           grepl <- base::grepl
[16:01:45.742]                           restarts <- computeRestarts(cond)
[16:01:45.742]                           for (restart in restarts) {
[16:01:45.742]                             name <- restart$name
[16:01:45.742]                             if (is.null(name)) 
[16:01:45.742]                               next
[16:01:45.742]                             if (!grepl(pattern, name)) 
[16:01:45.742]                               next
[16:01:45.742]                             invokeRestart(restart)
[16:01:45.742]                             muffled <- TRUE
[16:01:45.742]                             break
[16:01:45.742]                           }
[16:01:45.742]                         }
[16:01:45.742]                       }
[16:01:45.742]                       invisible(muffled)
[16:01:45.742]                     }
[16:01:45.742]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.742]                   }
[16:01:45.742]                 }
[16:01:45.742]             }
[16:01:45.742]         }))
[16:01:45.742]     }, error = function(ex) {
[16:01:45.742]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.742]                 ...future.rng), started = ...future.startTime, 
[16:01:45.742]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.742]             version = "1.8"), class = "FutureResult")
[16:01:45.742]     }, finally = {
[16:01:45.742]         if (!identical(...future.workdir, getwd())) 
[16:01:45.742]             setwd(...future.workdir)
[16:01:45.742]         {
[16:01:45.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.742]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.742]             }
[16:01:45.742]             base::options(...future.oldOptions)
[16:01:45.742]             if (.Platform$OS.type == "windows") {
[16:01:45.742]                 old_names <- names(...future.oldEnvVars)
[16:01:45.742]                 envs <- base::Sys.getenv()
[16:01:45.742]                 names <- names(envs)
[16:01:45.742]                 common <- intersect(names, old_names)
[16:01:45.742]                 added <- setdiff(names, old_names)
[16:01:45.742]                 removed <- setdiff(old_names, names)
[16:01:45.742]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.742]                   envs[common]]
[16:01:45.742]                 NAMES <- toupper(changed)
[16:01:45.742]                 args <- list()
[16:01:45.742]                 for (kk in seq_along(NAMES)) {
[16:01:45.742]                   name <- changed[[kk]]
[16:01:45.742]                   NAME <- NAMES[[kk]]
[16:01:45.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.742]                     next
[16:01:45.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.742]                 }
[16:01:45.742]                 NAMES <- toupper(added)
[16:01:45.742]                 for (kk in seq_along(NAMES)) {
[16:01:45.742]                   name <- added[[kk]]
[16:01:45.742]                   NAME <- NAMES[[kk]]
[16:01:45.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.742]                     next
[16:01:45.742]                   args[[name]] <- ""
[16:01:45.742]                 }
[16:01:45.742]                 NAMES <- toupper(removed)
[16:01:45.742]                 for (kk in seq_along(NAMES)) {
[16:01:45.742]                   name <- removed[[kk]]
[16:01:45.742]                   NAME <- NAMES[[kk]]
[16:01:45.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.742]                     next
[16:01:45.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.742]                 }
[16:01:45.742]                 if (length(args) > 0) 
[16:01:45.742]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.742]             }
[16:01:45.742]             else {
[16:01:45.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.742]             }
[16:01:45.742]             {
[16:01:45.742]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.742]                   0L) {
[16:01:45.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.742]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.742]                   base::options(opts)
[16:01:45.742]                 }
[16:01:45.742]                 {
[16:01:45.742]                   {
[16:01:45.742]                     NULL
[16:01:45.742]                     RNGkind("Mersenne-Twister")
[16:01:45.742]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.742]                       inherits = FALSE)
[16:01:45.742]                   }
[16:01:45.742]                   options(future.plan = NULL)
[16:01:45.742]                   if (is.na(NA_character_)) 
[16:01:45.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.742]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:45.742]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:45.742]                     envir = parent.frame()) 
[16:01:45.742]                   {
[16:01:45.742]                     if (is.function(workers)) 
[16:01:45.742]                       workers <- workers()
[16:01:45.742]                     workers <- structure(as.integer(workers), 
[16:01:45.742]                       class = class(workers))
[16:01:45.742]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:45.742]                       workers >= 1)
[16:01:45.742]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:45.742]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:45.742]                     }
[16:01:45.742]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:45.742]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:45.742]                       envir = envir)
[16:01:45.742]                     if (!future$lazy) 
[16:01:45.742]                       future <- run(future)
[16:01:45.742]                     invisible(future)
[16:01:45.742]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.742]                 }
[16:01:45.742]             }
[16:01:45.742]         }
[16:01:45.742]     })
[16:01:45.742]     if (TRUE) {
[16:01:45.742]         base::sink(type = "output", split = FALSE)
[16:01:45.742]         if (TRUE) {
[16:01:45.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.742]         }
[16:01:45.742]         else {
[16:01:45.742]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.742]         }
[16:01:45.742]         base::close(...future.stdout)
[16:01:45.742]         ...future.stdout <- NULL
[16:01:45.742]     }
[16:01:45.742]     ...future.result$conditions <- ...future.conditions
[16:01:45.742]     ...future.result$finished <- base::Sys.time()
[16:01:45.742]     ...future.result
[16:01:45.742] }
[16:01:45.744] assign_globals() ...
[16:01:45.744] List of 5
[16:01:45.744]  $ ...future.FUN            :function (object, ...)  
[16:01:45.744]  $ future.call.arguments    : list()
[16:01:45.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.744]  $ ...future.elements_ii    :List of 3
[16:01:45.744]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.744]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.744]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.744]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.744]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.744]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.744]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.744]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.744]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.744]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.744]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.744]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.744]  $ ...future.seeds_ii       : NULL
[16:01:45.744]  $ ...future.globals.maxSize: NULL
[16:01:45.744]  - attr(*, "where")=List of 5
[16:01:45.744]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.744]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.744]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.744]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.744]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.744]  - attr(*, "resolved")= logi FALSE
[16:01:45.744]  - attr(*, "total_size")= num 1240
[16:01:45.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.744]  - attr(*, "already-done")= logi TRUE
[16:01:45.755] - copied ‘...future.FUN’ to environment
[16:01:45.755] - copied ‘future.call.arguments’ to environment
[16:01:45.755] - copied ‘...future.elements_ii’ to environment
[16:01:45.755] - copied ‘...future.seeds_ii’ to environment
[16:01:45.755] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.755] assign_globals() ... done
[16:01:45.755] plan(): Setting new future strategy stack:
[16:01:45.756] List of future strategies:
[16:01:45.756] 1. sequential:
[16:01:45.756]    - args: function (..., envir = parent.frame())
[16:01:45.756]    - tweaked: FALSE
[16:01:45.756]    - call: NULL
[16:01:45.756] plan(): nbrOfWorkers() = 1
[16:01:45.758] plan(): Setting new future strategy stack:
[16:01:45.758] List of future strategies:
[16:01:45.758] 1. multisession:
[16:01:45.758]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:45.758]    - tweaked: FALSE
[16:01:45.758]    - call: plan(strategy)
[16:01:45.762] plan(): nbrOfWorkers() = 1
[16:01:45.762] SequentialFuture started (and completed)
[16:01:45.762] - Launch lazy future ... done
[16:01:45.762] run() for ‘SequentialFuture’ ... done
[16:01:45.763] Created future:
[16:01:45.763] SequentialFuture:
[16:01:45.763] Label: ‘future_by-1’
[16:01:45.763] Expression:
[16:01:45.763] {
[16:01:45.763]     do.call(function(...) {
[16:01:45.763]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.763]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.763]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.763]             on.exit(options(oopts), add = TRUE)
[16:01:45.763]         }
[16:01:45.763]         {
[16:01:45.763]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.763]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.763]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.763]             })
[16:01:45.763]         }
[16:01:45.763]     }, args = future.call.arguments)
[16:01:45.763] }
[16:01:45.763] Lazy evaluation: FALSE
[16:01:45.763] Asynchronous evaluation: FALSE
[16:01:45.763] Local evaluation: TRUE
[16:01:45.763] Environment: 0x55b525943288
[16:01:45.763] Capture standard output: TRUE
[16:01:45.763] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.763] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.763] Packages: <none>
[16:01:45.763] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.763] Resolved: TRUE
[16:01:45.763] Value: 5.37 KiB of class ‘list’
[16:01:45.763] Early signaling: FALSE
[16:01:45.763] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.763] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.764] Chunk #1 of 1 ... DONE
[16:01:45.764] Launching 1 futures (chunks) ... DONE
[16:01:45.764] Resolving 1 futures (chunks) ...
[16:01:45.764] resolve() on list ...
[16:01:45.764]  recursive: 0
[16:01:45.765]  length: 1
[16:01:45.765] 
[16:01:45.765] resolved() for ‘SequentialFuture’ ...
[16:01:45.765] - state: ‘finished’
[16:01:45.765] - run: TRUE
[16:01:45.765] - result: ‘FutureResult’
[16:01:45.765] resolved() for ‘SequentialFuture’ ... done
[16:01:45.765] Future #1
[16:01:45.765] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.765] - nx: 1
[16:01:45.766] - relay: TRUE
[16:01:45.766] - stdout: TRUE
[16:01:45.766] - signal: TRUE
[16:01:45.766] - resignal: FALSE
[16:01:45.766] - force: TRUE
[16:01:45.766] - relayed: [n=1] FALSE
[16:01:45.766] - queued futures: [n=1] FALSE
[16:01:45.766]  - until=1
[16:01:45.766]  - relaying element #1
[16:01:45.766] - relayed: [n=1] TRUE
[16:01:45.767] - queued futures: [n=1] TRUE
[16:01:45.767] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.767]  length: 0 (resolved future 1)
[16:01:45.767] Relaying remaining futures
[16:01:45.767] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.767] - nx: 1
[16:01:45.767] - relay: TRUE
[16:01:45.767] - stdout: TRUE
[16:01:45.767] - signal: TRUE
[16:01:45.767] - resignal: FALSE
[16:01:45.767] - force: TRUE
[16:01:45.768] - relayed: [n=1] TRUE
[16:01:45.768] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.768] - relayed: [n=1] TRUE
[16:01:45.768] - queued futures: [n=1] TRUE
[16:01:45.768] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.768] resolve() on list ... DONE
[16:01:45.768]  - Number of value chunks collected: 1
[16:01:45.768] Resolving 1 futures (chunks) ... DONE
[16:01:45.768] Reducing values from 1 chunks ...
[16:01:45.768]  - Number of values collected after concatenation: 3
[16:01:45.769]  - Number of values expected: 3
[16:01:45.769] Reducing values from 1 chunks ... DONE
[16:01:45.769] future_lapply() ... DONE
[16:01:45.769] future_by_internal() ... DONE
[16:01:45.770] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[16:01:45.770] plan(): Setting new future strategy stack:
[16:01:45.771] List of future strategies:
[16:01:45.771] 1. sequential:
[16:01:45.771]    - args: function (..., envir = parent.frame())
[16:01:45.771]    - tweaked: FALSE
[16:01:45.771]    - call: plan(strategy)
[16:01:45.771] plan(): nbrOfWorkers() = 1
[16:01:45.771] future_by_internal() ...
[16:01:45.771] future_lapply() ...
[16:01:45.772] Number of chunks: 1
[16:01:45.772] getGlobalsAndPackagesXApply() ...
[16:01:45.772]  - future.globals: TRUE
[16:01:45.772] getGlobalsAndPackages() ...
[16:01:45.772] Searching for globals...
[16:01:45.773] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.773] Searching for globals ... DONE
[16:01:45.773] Resolving globals: FALSE
[16:01:45.774] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.774] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.774] - globals: [1] ‘FUN’
[16:01:45.774] 
[16:01:45.774] getGlobalsAndPackages() ... DONE
[16:01:45.775]  - globals found/used: [n=1] ‘FUN’
[16:01:45.775]  - needed namespaces: [n=0] 
[16:01:45.775] Finding globals ... DONE
[16:01:45.775]  - use_args: TRUE
[16:01:45.775]  - Getting '...' globals ...
[16:01:45.775] resolve() on list ...
[16:01:45.775]  recursive: 0
[16:01:45.775]  length: 1
[16:01:45.776]  elements: ‘...’
[16:01:45.776]  length: 0 (resolved future 1)
[16:01:45.776] resolve() on list ... DONE
[16:01:45.776]    - '...' content: [n=0] 
[16:01:45.776] List of 1
[16:01:45.776]  $ ...: list()
[16:01:45.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.776]  - attr(*, "where")=List of 1
[16:01:45.776]   ..$ ...:<environment: 0x55b525c3a030> 
[16:01:45.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.776]  - attr(*, "resolved")= logi TRUE
[16:01:45.776]  - attr(*, "total_size")= num NA
[16:01:45.780]  - Getting '...' globals ... DONE
[16:01:45.780] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.781] List of 2
[16:01:45.781]  $ ...future.FUN:function (object, ...)  
[16:01:45.781]  $ ...          : list()
[16:01:45.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.781]  - attr(*, "where")=List of 2
[16:01:45.781]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.781]   ..$ ...          :<environment: 0x55b525c3a030> 
[16:01:45.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.781]  - attr(*, "resolved")= logi FALSE
[16:01:45.781]  - attr(*, "total_size")= num 1240
[16:01:45.783] Packages to be attached in all futures: [n=0] 
[16:01:45.783] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.784] Number of futures (= number of chunks): 1
[16:01:45.784] Launching 1 futures (chunks) ...
[16:01:45.784] Chunk #1 of 1 ...
[16:01:45.784]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.784] getGlobalsAndPackages() ...
[16:01:45.784] Searching for globals...
[16:01:45.785] 
[16:01:45.785] Searching for globals ... DONE
[16:01:45.785] - globals: [0] <none>
[16:01:45.785] getGlobalsAndPackages() ... DONE
[16:01:45.785]    + additional globals found: [n=0] 
[16:01:45.785]    + additional namespaces needed: [n=0] 
[16:01:45.785]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.785]  - seeds: <none>
[16:01:45.785]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.785] getGlobalsAndPackages() ...
[16:01:45.786] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.786] Resolving globals: FALSE
[16:01:45.786] Tweak future expression to call with '...' arguments ...
[16:01:45.786] {
[16:01:45.786]     do.call(function(...) {
[16:01:45.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.786]             on.exit(options(oopts), add = TRUE)
[16:01:45.786]         }
[16:01:45.786]         {
[16:01:45.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.786]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.786]             })
[16:01:45.786]         }
[16:01:45.786]     }, args = future.call.arguments)
[16:01:45.786] }
[16:01:45.786] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.786] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.787] 
[16:01:45.787] getGlobalsAndPackages() ... DONE
[16:01:45.787] run() for ‘Future’ ...
[16:01:45.787] - state: ‘created’
[16:01:45.787] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:45.788] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.788]   - Field: ‘label’
[16:01:45.788]   - Field: ‘local’
[16:01:45.788]   - Field: ‘owner’
[16:01:45.788]   - Field: ‘envir’
[16:01:45.788]   - Field: ‘packages’
[16:01:45.788]   - Field: ‘gc’
[16:01:45.788]   - Field: ‘conditions’
[16:01:45.788]   - Field: ‘expr’
[16:01:45.788]   - Field: ‘uuid’
[16:01:45.789]   - Field: ‘seed’
[16:01:45.789]   - Field: ‘version’
[16:01:45.789]   - Field: ‘result’
[16:01:45.789]   - Field: ‘asynchronous’
[16:01:45.789]   - Field: ‘calls’
[16:01:45.789]   - Field: ‘globals’
[16:01:45.789]   - Field: ‘stdout’
[16:01:45.789]   - Field: ‘earlySignal’
[16:01:45.789]   - Field: ‘lazy’
[16:01:45.789]   - Field: ‘state’
[16:01:45.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.790] - Launch lazy future ...
[16:01:45.790] Packages needed by the future expression (n = 0): <none>
[16:01:45.790] Packages needed by future strategies (n = 0): <none>
[16:01:45.790] {
[16:01:45.790]     {
[16:01:45.790]         {
[16:01:45.790]             ...future.startTime <- base::Sys.time()
[16:01:45.790]             {
[16:01:45.790]                 {
[16:01:45.790]                   {
[16:01:45.790]                     base::local({
[16:01:45.790]                       has_future <- base::requireNamespace("future", 
[16:01:45.790]                         quietly = TRUE)
[16:01:45.790]                       if (has_future) {
[16:01:45.790]                         ns <- base::getNamespace("future")
[16:01:45.790]                         version <- ns[[".package"]][["version"]]
[16:01:45.790]                         if (is.null(version)) 
[16:01:45.790]                           version <- utils::packageVersion("future")
[16:01:45.790]                       }
[16:01:45.790]                       else {
[16:01:45.790]                         version <- NULL
[16:01:45.790]                       }
[16:01:45.790]                       if (!has_future || version < "1.8.0") {
[16:01:45.790]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.790]                           "", base::R.version$version.string), 
[16:01:45.790]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.790]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.790]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.790]                             "release", "version")], collapse = " "), 
[16:01:45.790]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.790]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.790]                           info)
[16:01:45.790]                         info <- base::paste(info, collapse = "; ")
[16:01:45.790]                         if (!has_future) {
[16:01:45.790]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.790]                             info)
[16:01:45.790]                         }
[16:01:45.790]                         else {
[16:01:45.790]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.790]                             info, version)
[16:01:45.790]                         }
[16:01:45.790]                         base::stop(msg)
[16:01:45.790]                       }
[16:01:45.790]                     })
[16:01:45.790]                   }
[16:01:45.790]                   options(future.plan = NULL)
[16:01:45.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.790]                 }
[16:01:45.790]                 ...future.workdir <- getwd()
[16:01:45.790]             }
[16:01:45.790]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.790]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.790]         }
[16:01:45.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.790]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.790]             base::names(...future.oldOptions))
[16:01:45.790]     }
[16:01:45.790]     if (FALSE) {
[16:01:45.790]     }
[16:01:45.790]     else {
[16:01:45.790]         if (TRUE) {
[16:01:45.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.790]                 open = "w")
[16:01:45.790]         }
[16:01:45.790]         else {
[16:01:45.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.790]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.790]         }
[16:01:45.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.790]             base::sink(type = "output", split = FALSE)
[16:01:45.790]             base::close(...future.stdout)
[16:01:45.790]         }, add = TRUE)
[16:01:45.790]     }
[16:01:45.790]     ...future.frame <- base::sys.nframe()
[16:01:45.790]     ...future.conditions <- base::list()
[16:01:45.790]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.790]     if (FALSE) {
[16:01:45.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.790]     }
[16:01:45.790]     ...future.result <- base::tryCatch({
[16:01:45.790]         base::withCallingHandlers({
[16:01:45.790]             ...future.value <- base::withVisible(base::local({
[16:01:45.790]                 do.call(function(...) {
[16:01:45.790]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.790]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.790]                     ...future.globals.maxSize)) {
[16:01:45.790]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.790]                     on.exit(options(oopts), add = TRUE)
[16:01:45.790]                   }
[16:01:45.790]                   {
[16:01:45.790]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.790]                       FUN = function(jj) {
[16:01:45.790]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.790]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.790]                       })
[16:01:45.790]                   }
[16:01:45.790]                 }, args = future.call.arguments)
[16:01:45.790]             }))
[16:01:45.790]             future::FutureResult(value = ...future.value$value, 
[16:01:45.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.790]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.790]                     ...future.globalenv.names))
[16:01:45.790]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.790]         }, condition = base::local({
[16:01:45.790]             c <- base::c
[16:01:45.790]             inherits <- base::inherits
[16:01:45.790]             invokeRestart <- base::invokeRestart
[16:01:45.790]             length <- base::length
[16:01:45.790]             list <- base::list
[16:01:45.790]             seq.int <- base::seq.int
[16:01:45.790]             signalCondition <- base::signalCondition
[16:01:45.790]             sys.calls <- base::sys.calls
[16:01:45.790]             `[[` <- base::`[[`
[16:01:45.790]             `+` <- base::`+`
[16:01:45.790]             `<<-` <- base::`<<-`
[16:01:45.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.790]                   3L)]
[16:01:45.790]             }
[16:01:45.790]             function(cond) {
[16:01:45.790]                 is_error <- inherits(cond, "error")
[16:01:45.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.790]                   NULL)
[16:01:45.790]                 if (is_error) {
[16:01:45.790]                   sessionInformation <- function() {
[16:01:45.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.790]                       search = base::search(), system = base::Sys.info())
[16:01:45.790]                   }
[16:01:45.790]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.790]                     cond$call), session = sessionInformation(), 
[16:01:45.790]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.790]                   signalCondition(cond)
[16:01:45.790]                 }
[16:01:45.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.790]                 "immediateCondition"))) {
[16:01:45.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.790]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.790]                   if (TRUE && !signal) {
[16:01:45.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.790]                     {
[16:01:45.790]                       inherits <- base::inherits
[16:01:45.790]                       invokeRestart <- base::invokeRestart
[16:01:45.790]                       is.null <- base::is.null
[16:01:45.790]                       muffled <- FALSE
[16:01:45.790]                       if (inherits(cond, "message")) {
[16:01:45.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.790]                         if (muffled) 
[16:01:45.790]                           invokeRestart("muffleMessage")
[16:01:45.790]                       }
[16:01:45.790]                       else if (inherits(cond, "warning")) {
[16:01:45.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.790]                         if (muffled) 
[16:01:45.790]                           invokeRestart("muffleWarning")
[16:01:45.790]                       }
[16:01:45.790]                       else if (inherits(cond, "condition")) {
[16:01:45.790]                         if (!is.null(pattern)) {
[16:01:45.790]                           computeRestarts <- base::computeRestarts
[16:01:45.790]                           grepl <- base::grepl
[16:01:45.790]                           restarts <- computeRestarts(cond)
[16:01:45.790]                           for (restart in restarts) {
[16:01:45.790]                             name <- restart$name
[16:01:45.790]                             if (is.null(name)) 
[16:01:45.790]                               next
[16:01:45.790]                             if (!grepl(pattern, name)) 
[16:01:45.790]                               next
[16:01:45.790]                             invokeRestart(restart)
[16:01:45.790]                             muffled <- TRUE
[16:01:45.790]                             break
[16:01:45.790]                           }
[16:01:45.790]                         }
[16:01:45.790]                       }
[16:01:45.790]                       invisible(muffled)
[16:01:45.790]                     }
[16:01:45.790]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.790]                   }
[16:01:45.790]                 }
[16:01:45.790]                 else {
[16:01:45.790]                   if (TRUE) {
[16:01:45.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.790]                     {
[16:01:45.790]                       inherits <- base::inherits
[16:01:45.790]                       invokeRestart <- base::invokeRestart
[16:01:45.790]                       is.null <- base::is.null
[16:01:45.790]                       muffled <- FALSE
[16:01:45.790]                       if (inherits(cond, "message")) {
[16:01:45.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.790]                         if (muffled) 
[16:01:45.790]                           invokeRestart("muffleMessage")
[16:01:45.790]                       }
[16:01:45.790]                       else if (inherits(cond, "warning")) {
[16:01:45.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.790]                         if (muffled) 
[16:01:45.790]                           invokeRestart("muffleWarning")
[16:01:45.790]                       }
[16:01:45.790]                       else if (inherits(cond, "condition")) {
[16:01:45.790]                         if (!is.null(pattern)) {
[16:01:45.790]                           computeRestarts <- base::computeRestarts
[16:01:45.790]                           grepl <- base::grepl
[16:01:45.790]                           restarts <- computeRestarts(cond)
[16:01:45.790]                           for (restart in restarts) {
[16:01:45.790]                             name <- restart$name
[16:01:45.790]                             if (is.null(name)) 
[16:01:45.790]                               next
[16:01:45.790]                             if (!grepl(pattern, name)) 
[16:01:45.790]                               next
[16:01:45.790]                             invokeRestart(restart)
[16:01:45.790]                             muffled <- TRUE
[16:01:45.790]                             break
[16:01:45.790]                           }
[16:01:45.790]                         }
[16:01:45.790]                       }
[16:01:45.790]                       invisible(muffled)
[16:01:45.790]                     }
[16:01:45.790]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.790]                   }
[16:01:45.790]                 }
[16:01:45.790]             }
[16:01:45.790]         }))
[16:01:45.790]     }, error = function(ex) {
[16:01:45.790]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.790]                 ...future.rng), started = ...future.startTime, 
[16:01:45.790]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.790]             version = "1.8"), class = "FutureResult")
[16:01:45.790]     }, finally = {
[16:01:45.790]         if (!identical(...future.workdir, getwd())) 
[16:01:45.790]             setwd(...future.workdir)
[16:01:45.790]         {
[16:01:45.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.790]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.790]             }
[16:01:45.790]             base::options(...future.oldOptions)
[16:01:45.790]             if (.Platform$OS.type == "windows") {
[16:01:45.790]                 old_names <- names(...future.oldEnvVars)
[16:01:45.790]                 envs <- base::Sys.getenv()
[16:01:45.790]                 names <- names(envs)
[16:01:45.790]                 common <- intersect(names, old_names)
[16:01:45.790]                 added <- setdiff(names, old_names)
[16:01:45.790]                 removed <- setdiff(old_names, names)
[16:01:45.790]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.790]                   envs[common]]
[16:01:45.790]                 NAMES <- toupper(changed)
[16:01:45.790]                 args <- list()
[16:01:45.790]                 for (kk in seq_along(NAMES)) {
[16:01:45.790]                   name <- changed[[kk]]
[16:01:45.790]                   NAME <- NAMES[[kk]]
[16:01:45.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.790]                     next
[16:01:45.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.790]                 }
[16:01:45.790]                 NAMES <- toupper(added)
[16:01:45.790]                 for (kk in seq_along(NAMES)) {
[16:01:45.790]                   name <- added[[kk]]
[16:01:45.790]                   NAME <- NAMES[[kk]]
[16:01:45.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.790]                     next
[16:01:45.790]                   args[[name]] <- ""
[16:01:45.790]                 }
[16:01:45.790]                 NAMES <- toupper(removed)
[16:01:45.790]                 for (kk in seq_along(NAMES)) {
[16:01:45.790]                   name <- removed[[kk]]
[16:01:45.790]                   NAME <- NAMES[[kk]]
[16:01:45.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.790]                     next
[16:01:45.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.790]                 }
[16:01:45.790]                 if (length(args) > 0) 
[16:01:45.790]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.790]             }
[16:01:45.790]             else {
[16:01:45.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.790]             }
[16:01:45.790]             {
[16:01:45.790]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.790]                   0L) {
[16:01:45.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.790]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.790]                   base::options(opts)
[16:01:45.790]                 }
[16:01:45.790]                 {
[16:01:45.790]                   {
[16:01:45.790]                     NULL
[16:01:45.790]                     RNGkind("Mersenne-Twister")
[16:01:45.790]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.790]                       inherits = FALSE)
[16:01:45.790]                   }
[16:01:45.790]                   options(future.plan = NULL)
[16:01:45.790]                   if (is.na(NA_character_)) 
[16:01:45.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.790]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:45.790]                   {
[16:01:45.790]                     future <- SequentialFuture(..., envir = envir)
[16:01:45.790]                     if (!future$lazy) 
[16:01:45.790]                       future <- run(future)
[16:01:45.790]                     invisible(future)
[16:01:45.790]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.790]                 }
[16:01:45.790]             }
[16:01:45.790]         }
[16:01:45.790]     })
[16:01:45.790]     if (TRUE) {
[16:01:45.790]         base::sink(type = "output", split = FALSE)
[16:01:45.790]         if (TRUE) {
[16:01:45.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.790]         }
[16:01:45.790]         else {
[16:01:45.790]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.790]         }
[16:01:45.790]         base::close(...future.stdout)
[16:01:45.790]         ...future.stdout <- NULL
[16:01:45.790]     }
[16:01:45.790]     ...future.result$conditions <- ...future.conditions
[16:01:45.790]     ...future.result$finished <- base::Sys.time()
[16:01:45.790]     ...future.result
[16:01:45.790] }
[16:01:45.792] assign_globals() ...
[16:01:45.792] List of 5
[16:01:45.792]  $ ...future.FUN            :function (object, ...)  
[16:01:45.792]  $ future.call.arguments    : list()
[16:01:45.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.792]  $ ...future.elements_ii    :List of 3
[16:01:45.792]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.792]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.792]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.792]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.792]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.792]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.792]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:45.792]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.792]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.792]  $ ...future.seeds_ii       : NULL
[16:01:45.792]  $ ...future.globals.maxSize: NULL
[16:01:45.792]  - attr(*, "where")=List of 5
[16:01:45.792]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.792]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.792]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.792]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.792]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.792]  - attr(*, "resolved")= logi FALSE
[16:01:45.792]  - attr(*, "total_size")= num 1240
[16:01:45.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.792]  - attr(*, "already-done")= logi TRUE
[16:01:45.801] - copied ‘...future.FUN’ to environment
[16:01:45.801] - copied ‘future.call.arguments’ to environment
[16:01:45.801] - copied ‘...future.elements_ii’ to environment
[16:01:45.802] - copied ‘...future.seeds_ii’ to environment
[16:01:45.802] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.802] assign_globals() ... done
[16:01:45.802] plan(): Setting new future strategy stack:
[16:01:45.802] List of future strategies:
[16:01:45.802] 1. sequential:
[16:01:45.802]    - args: function (..., envir = parent.frame())
[16:01:45.802]    - tweaked: FALSE
[16:01:45.802]    - call: NULL
[16:01:45.803] plan(): nbrOfWorkers() = 1
[16:01:45.805] plan(): Setting new future strategy stack:
[16:01:45.805] List of future strategies:
[16:01:45.805] 1. sequential:
[16:01:45.805]    - args: function (..., envir = parent.frame())
[16:01:45.805]    - tweaked: FALSE
[16:01:45.805]    - call: plan(strategy)
[16:01:45.805] plan(): nbrOfWorkers() = 1
[16:01:45.805] SequentialFuture started (and completed)
[16:01:45.806] - Launch lazy future ... done
[16:01:45.806] run() for ‘SequentialFuture’ ... done
[16:01:45.806] Created future:
[16:01:45.806] SequentialFuture:
[16:01:45.806] Label: ‘future_by-1’
[16:01:45.806] Expression:
[16:01:45.806] {
[16:01:45.806]     do.call(function(...) {
[16:01:45.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.806]             on.exit(options(oopts), add = TRUE)
[16:01:45.806]         }
[16:01:45.806]         {
[16:01:45.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.806]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.806]             })
[16:01:45.806]         }
[16:01:45.806]     }, args = future.call.arguments)
[16:01:45.806] }
[16:01:45.806] Lazy evaluation: FALSE
[16:01:45.806] Asynchronous evaluation: FALSE
[16:01:45.806] Local evaluation: TRUE
[16:01:45.806] Environment: R_GlobalEnv
[16:01:45.806] Capture standard output: TRUE
[16:01:45.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.806] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.806] Packages: <none>
[16:01:45.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.806] Resolved: TRUE
[16:01:45.806] Value: 4.62 KiB of class ‘list’
[16:01:45.806] Early signaling: FALSE
[16:01:45.806] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.806] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.807] Chunk #1 of 1 ... DONE
[16:01:45.807] Launching 1 futures (chunks) ... DONE
[16:01:45.807] Resolving 1 futures (chunks) ...
[16:01:45.807] resolve() on list ...
[16:01:45.808]  recursive: 0
[16:01:45.808]  length: 1
[16:01:45.808] 
[16:01:45.808] resolved() for ‘SequentialFuture’ ...
[16:01:45.808] - state: ‘finished’
[16:01:45.808] - run: TRUE
[16:01:45.808] - result: ‘FutureResult’
[16:01:45.808] resolved() for ‘SequentialFuture’ ... done
[16:01:45.808] Future #1
[16:01:45.808] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.809] - nx: 1
[16:01:45.809] - relay: TRUE
[16:01:45.809] - stdout: TRUE
[16:01:45.809] - signal: TRUE
[16:01:45.809] - resignal: FALSE
[16:01:45.809] - force: TRUE
[16:01:45.809] - relayed: [n=1] FALSE
[16:01:45.809] - queued futures: [n=1] FALSE
[16:01:45.809]  - until=1
[16:01:45.809]  - relaying element #1
[16:01:45.810] - relayed: [n=1] TRUE
[16:01:45.810] - queued futures: [n=1] TRUE
[16:01:45.810] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.810]  length: 0 (resolved future 1)
[16:01:45.810] Relaying remaining futures
[16:01:45.810] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.810] - nx: 1
[16:01:45.810] - relay: TRUE
[16:01:45.810] - stdout: TRUE
[16:01:45.810] - signal: TRUE
[16:01:45.810] - resignal: FALSE
[16:01:45.811] - force: TRUE
[16:01:45.811] - relayed: [n=1] TRUE
[16:01:45.811] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.811] - relayed: [n=1] TRUE
[16:01:45.811] - queued futures: [n=1] TRUE
[16:01:45.811] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.811] resolve() on list ... DONE
[16:01:45.811]  - Number of value chunks collected: 1
[16:01:45.811] Resolving 1 futures (chunks) ... DONE
[16:01:45.811] Reducing values from 1 chunks ...
[16:01:45.812]  - Number of values collected after concatenation: 3
[16:01:45.812]  - Number of values expected: 3
[16:01:45.812] Reducing values from 1 chunks ... DONE
[16:01:45.812] future_lapply() ... DONE
[16:01:45.812] future_by_internal() ... DONE
[16:01:45.812] future_by_internal() ...
[16:01:45.813] future_lapply() ...
[16:01:45.813] Number of chunks: 1
[16:01:45.813] getGlobalsAndPackagesXApply() ...
[16:01:45.813]  - future.globals: TRUE
[16:01:45.813] getGlobalsAndPackages() ...
[16:01:45.813] Searching for globals...
[16:01:45.814] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.815] Searching for globals ... DONE
[16:01:45.815] Resolving globals: FALSE
[16:01:45.815] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.815] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.816] - globals: [1] ‘FUN’
[16:01:45.816] 
[16:01:45.816] getGlobalsAndPackages() ... DONE
[16:01:45.816]  - globals found/used: [n=1] ‘FUN’
[16:01:45.816]  - needed namespaces: [n=0] 
[16:01:45.816] Finding globals ... DONE
[16:01:45.816]  - use_args: TRUE
[16:01:45.816]  - Getting '...' globals ...
[16:01:45.817] resolve() on list ...
[16:01:45.817]  recursive: 0
[16:01:45.817]  length: 1
[16:01:45.817]  elements: ‘...’
[16:01:45.817]  length: 0 (resolved future 1)
[16:01:45.817] resolve() on list ... DONE
[16:01:45.817]    - '...' content: [n=1] ‘digits’
[16:01:45.817] List of 1
[16:01:45.817]  $ ...:List of 1
[16:01:45.817]   ..$ digits: int 2
[16:01:45.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.817]  - attr(*, "where")=List of 1
[16:01:45.817]   ..$ ...:<environment: 0x55b5254a78f0> 
[16:01:45.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.817]  - attr(*, "resolved")= logi TRUE
[16:01:45.817]  - attr(*, "total_size")= num NA
[16:01:45.820]  - Getting '...' globals ... DONE
[16:01:45.820] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.820] List of 2
[16:01:45.820]  $ ...future.FUN:function (object, ...)  
[16:01:45.820]  $ ...          :List of 1
[16:01:45.820]   ..$ digits: int 2
[16:01:45.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.820]  - attr(*, "where")=List of 2
[16:01:45.820]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.820]   ..$ ...          :<environment: 0x55b5254a78f0> 
[16:01:45.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.820]  - attr(*, "resolved")= logi FALSE
[16:01:45.820]  - attr(*, "total_size")= num 1296
[16:01:45.826] Packages to be attached in all futures: [n=0] 
[16:01:45.826] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.826] Number of futures (= number of chunks): 1
[16:01:45.827] Launching 1 futures (chunks) ...
[16:01:45.827] Chunk #1 of 1 ...
[16:01:45.827]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.827] getGlobalsAndPackages() ...
[16:01:45.827] Searching for globals...
[16:01:45.827] 
[16:01:45.827] Searching for globals ... DONE
[16:01:45.828] - globals: [0] <none>
[16:01:45.828] getGlobalsAndPackages() ... DONE
[16:01:45.828]    + additional globals found: [n=0] 
[16:01:45.828]    + additional namespaces needed: [n=0] 
[16:01:45.828]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.828]  - seeds: <none>
[16:01:45.828]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.828] getGlobalsAndPackages() ...
[16:01:45.828] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.828] Resolving globals: FALSE
[16:01:45.828] Tweak future expression to call with '...' arguments ...
[16:01:45.829] {
[16:01:45.829]     do.call(function(...) {
[16:01:45.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.829]             on.exit(options(oopts), add = TRUE)
[16:01:45.829]         }
[16:01:45.829]         {
[16:01:45.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.829]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.829]             })
[16:01:45.829]         }
[16:01:45.829]     }, args = future.call.arguments)
[16:01:45.829] }
[16:01:45.829] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.829] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.829] 
[16:01:45.830] getGlobalsAndPackages() ... DONE
[16:01:45.830] run() for ‘Future’ ...
[16:01:45.830] - state: ‘created’
[16:01:45.830] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:45.830] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.831]   - Field: ‘label’
[16:01:45.831]   - Field: ‘local’
[16:01:45.831]   - Field: ‘owner’
[16:01:45.831]   - Field: ‘envir’
[16:01:45.831]   - Field: ‘packages’
[16:01:45.831]   - Field: ‘gc’
[16:01:45.831]   - Field: ‘conditions’
[16:01:45.831]   - Field: ‘expr’
[16:01:45.831]   - Field: ‘uuid’
[16:01:45.832]   - Field: ‘seed’
[16:01:45.832]   - Field: ‘version’
[16:01:45.832]   - Field: ‘result’
[16:01:45.832]   - Field: ‘asynchronous’
[16:01:45.832]   - Field: ‘calls’
[16:01:45.832]   - Field: ‘globals’
[16:01:45.832]   - Field: ‘stdout’
[16:01:45.832]   - Field: ‘earlySignal’
[16:01:45.832]   - Field: ‘lazy’
[16:01:45.832]   - Field: ‘state’
[16:01:45.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.833] - Launch lazy future ...
[16:01:45.833] Packages needed by the future expression (n = 0): <none>
[16:01:45.833] Packages needed by future strategies (n = 0): <none>
[16:01:45.833] {
[16:01:45.833]     {
[16:01:45.833]         {
[16:01:45.833]             ...future.startTime <- base::Sys.time()
[16:01:45.833]             {
[16:01:45.833]                 {
[16:01:45.833]                   {
[16:01:45.833]                     base::local({
[16:01:45.833]                       has_future <- base::requireNamespace("future", 
[16:01:45.833]                         quietly = TRUE)
[16:01:45.833]                       if (has_future) {
[16:01:45.833]                         ns <- base::getNamespace("future")
[16:01:45.833]                         version <- ns[[".package"]][["version"]]
[16:01:45.833]                         if (is.null(version)) 
[16:01:45.833]                           version <- utils::packageVersion("future")
[16:01:45.833]                       }
[16:01:45.833]                       else {
[16:01:45.833]                         version <- NULL
[16:01:45.833]                       }
[16:01:45.833]                       if (!has_future || version < "1.8.0") {
[16:01:45.833]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.833]                           "", base::R.version$version.string), 
[16:01:45.833]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.833]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.833]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.833]                             "release", "version")], collapse = " "), 
[16:01:45.833]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.833]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.833]                           info)
[16:01:45.833]                         info <- base::paste(info, collapse = "; ")
[16:01:45.833]                         if (!has_future) {
[16:01:45.833]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.833]                             info)
[16:01:45.833]                         }
[16:01:45.833]                         else {
[16:01:45.833]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.833]                             info, version)
[16:01:45.833]                         }
[16:01:45.833]                         base::stop(msg)
[16:01:45.833]                       }
[16:01:45.833]                     })
[16:01:45.833]                   }
[16:01:45.833]                   options(future.plan = NULL)
[16:01:45.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.833]                 }
[16:01:45.833]                 ...future.workdir <- getwd()
[16:01:45.833]             }
[16:01:45.833]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.833]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.833]         }
[16:01:45.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.833]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.833]             base::names(...future.oldOptions))
[16:01:45.833]     }
[16:01:45.833]     if (FALSE) {
[16:01:45.833]     }
[16:01:45.833]     else {
[16:01:45.833]         if (TRUE) {
[16:01:45.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.833]                 open = "w")
[16:01:45.833]         }
[16:01:45.833]         else {
[16:01:45.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.833]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.833]         }
[16:01:45.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.833]             base::sink(type = "output", split = FALSE)
[16:01:45.833]             base::close(...future.stdout)
[16:01:45.833]         }, add = TRUE)
[16:01:45.833]     }
[16:01:45.833]     ...future.frame <- base::sys.nframe()
[16:01:45.833]     ...future.conditions <- base::list()
[16:01:45.833]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.833]     if (FALSE) {
[16:01:45.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.833]     }
[16:01:45.833]     ...future.result <- base::tryCatch({
[16:01:45.833]         base::withCallingHandlers({
[16:01:45.833]             ...future.value <- base::withVisible(base::local({
[16:01:45.833]                 do.call(function(...) {
[16:01:45.833]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.833]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.833]                     ...future.globals.maxSize)) {
[16:01:45.833]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.833]                     on.exit(options(oopts), add = TRUE)
[16:01:45.833]                   }
[16:01:45.833]                   {
[16:01:45.833]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.833]                       FUN = function(jj) {
[16:01:45.833]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.833]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.833]                       })
[16:01:45.833]                   }
[16:01:45.833]                 }, args = future.call.arguments)
[16:01:45.833]             }))
[16:01:45.833]             future::FutureResult(value = ...future.value$value, 
[16:01:45.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.833]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.833]                     ...future.globalenv.names))
[16:01:45.833]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.833]         }, condition = base::local({
[16:01:45.833]             c <- base::c
[16:01:45.833]             inherits <- base::inherits
[16:01:45.833]             invokeRestart <- base::invokeRestart
[16:01:45.833]             length <- base::length
[16:01:45.833]             list <- base::list
[16:01:45.833]             seq.int <- base::seq.int
[16:01:45.833]             signalCondition <- base::signalCondition
[16:01:45.833]             sys.calls <- base::sys.calls
[16:01:45.833]             `[[` <- base::`[[`
[16:01:45.833]             `+` <- base::`+`
[16:01:45.833]             `<<-` <- base::`<<-`
[16:01:45.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.833]                   3L)]
[16:01:45.833]             }
[16:01:45.833]             function(cond) {
[16:01:45.833]                 is_error <- inherits(cond, "error")
[16:01:45.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.833]                   NULL)
[16:01:45.833]                 if (is_error) {
[16:01:45.833]                   sessionInformation <- function() {
[16:01:45.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.833]                       search = base::search(), system = base::Sys.info())
[16:01:45.833]                   }
[16:01:45.833]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.833]                     cond$call), session = sessionInformation(), 
[16:01:45.833]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.833]                   signalCondition(cond)
[16:01:45.833]                 }
[16:01:45.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.833]                 "immediateCondition"))) {
[16:01:45.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.833]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.833]                   if (TRUE && !signal) {
[16:01:45.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.833]                     {
[16:01:45.833]                       inherits <- base::inherits
[16:01:45.833]                       invokeRestart <- base::invokeRestart
[16:01:45.833]                       is.null <- base::is.null
[16:01:45.833]                       muffled <- FALSE
[16:01:45.833]                       if (inherits(cond, "message")) {
[16:01:45.833]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.833]                         if (muffled) 
[16:01:45.833]                           invokeRestart("muffleMessage")
[16:01:45.833]                       }
[16:01:45.833]                       else if (inherits(cond, "warning")) {
[16:01:45.833]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.833]                         if (muffled) 
[16:01:45.833]                           invokeRestart("muffleWarning")
[16:01:45.833]                       }
[16:01:45.833]                       else if (inherits(cond, "condition")) {
[16:01:45.833]                         if (!is.null(pattern)) {
[16:01:45.833]                           computeRestarts <- base::computeRestarts
[16:01:45.833]                           grepl <- base::grepl
[16:01:45.833]                           restarts <- computeRestarts(cond)
[16:01:45.833]                           for (restart in restarts) {
[16:01:45.833]                             name <- restart$name
[16:01:45.833]                             if (is.null(name)) 
[16:01:45.833]                               next
[16:01:45.833]                             if (!grepl(pattern, name)) 
[16:01:45.833]                               next
[16:01:45.833]                             invokeRestart(restart)
[16:01:45.833]                             muffled <- TRUE
[16:01:45.833]                             break
[16:01:45.833]                           }
[16:01:45.833]                         }
[16:01:45.833]                       }
[16:01:45.833]                       invisible(muffled)
[16:01:45.833]                     }
[16:01:45.833]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.833]                   }
[16:01:45.833]                 }
[16:01:45.833]                 else {
[16:01:45.833]                   if (TRUE) {
[16:01:45.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.833]                     {
[16:01:45.833]                       inherits <- base::inherits
[16:01:45.833]                       invokeRestart <- base::invokeRestart
[16:01:45.833]                       is.null <- base::is.null
[16:01:45.833]                       muffled <- FALSE
[16:01:45.833]                       if (inherits(cond, "message")) {
[16:01:45.833]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.833]                         if (muffled) 
[16:01:45.833]                           invokeRestart("muffleMessage")
[16:01:45.833]                       }
[16:01:45.833]                       else if (inherits(cond, "warning")) {
[16:01:45.833]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.833]                         if (muffled) 
[16:01:45.833]                           invokeRestart("muffleWarning")
[16:01:45.833]                       }
[16:01:45.833]                       else if (inherits(cond, "condition")) {
[16:01:45.833]                         if (!is.null(pattern)) {
[16:01:45.833]                           computeRestarts <- base::computeRestarts
[16:01:45.833]                           grepl <- base::grepl
[16:01:45.833]                           restarts <- computeRestarts(cond)
[16:01:45.833]                           for (restart in restarts) {
[16:01:45.833]                             name <- restart$name
[16:01:45.833]                             if (is.null(name)) 
[16:01:45.833]                               next
[16:01:45.833]                             if (!grepl(pattern, name)) 
[16:01:45.833]                               next
[16:01:45.833]                             invokeRestart(restart)
[16:01:45.833]                             muffled <- TRUE
[16:01:45.833]                             break
[16:01:45.833]                           }
[16:01:45.833]                         }
[16:01:45.833]                       }
[16:01:45.833]                       invisible(muffled)
[16:01:45.833]                     }
[16:01:45.833]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.833]                   }
[16:01:45.833]                 }
[16:01:45.833]             }
[16:01:45.833]         }))
[16:01:45.833]     }, error = function(ex) {
[16:01:45.833]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.833]                 ...future.rng), started = ...future.startTime, 
[16:01:45.833]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.833]             version = "1.8"), class = "FutureResult")
[16:01:45.833]     }, finally = {
[16:01:45.833]         if (!identical(...future.workdir, getwd())) 
[16:01:45.833]             setwd(...future.workdir)
[16:01:45.833]         {
[16:01:45.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.833]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.833]             }
[16:01:45.833]             base::options(...future.oldOptions)
[16:01:45.833]             if (.Platform$OS.type == "windows") {
[16:01:45.833]                 old_names <- names(...future.oldEnvVars)
[16:01:45.833]                 envs <- base::Sys.getenv()
[16:01:45.833]                 names <- names(envs)
[16:01:45.833]                 common <- intersect(names, old_names)
[16:01:45.833]                 added <- setdiff(names, old_names)
[16:01:45.833]                 removed <- setdiff(old_names, names)
[16:01:45.833]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.833]                   envs[common]]
[16:01:45.833]                 NAMES <- toupper(changed)
[16:01:45.833]                 args <- list()
[16:01:45.833]                 for (kk in seq_along(NAMES)) {
[16:01:45.833]                   name <- changed[[kk]]
[16:01:45.833]                   NAME <- NAMES[[kk]]
[16:01:45.833]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.833]                     next
[16:01:45.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.833]                 }
[16:01:45.833]                 NAMES <- toupper(added)
[16:01:45.833]                 for (kk in seq_along(NAMES)) {
[16:01:45.833]                   name <- added[[kk]]
[16:01:45.833]                   NAME <- NAMES[[kk]]
[16:01:45.833]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.833]                     next
[16:01:45.833]                   args[[name]] <- ""
[16:01:45.833]                 }
[16:01:45.833]                 NAMES <- toupper(removed)
[16:01:45.833]                 for (kk in seq_along(NAMES)) {
[16:01:45.833]                   name <- removed[[kk]]
[16:01:45.833]                   NAME <- NAMES[[kk]]
[16:01:45.833]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.833]                     next
[16:01:45.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.833]                 }
[16:01:45.833]                 if (length(args) > 0) 
[16:01:45.833]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.833]             }
[16:01:45.833]             else {
[16:01:45.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.833]             }
[16:01:45.833]             {
[16:01:45.833]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.833]                   0L) {
[16:01:45.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.833]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.833]                   base::options(opts)
[16:01:45.833]                 }
[16:01:45.833]                 {
[16:01:45.833]                   {
[16:01:45.833]                     NULL
[16:01:45.833]                     RNGkind("Mersenne-Twister")
[16:01:45.833]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.833]                       inherits = FALSE)
[16:01:45.833]                   }
[16:01:45.833]                   options(future.plan = NULL)
[16:01:45.833]                   if (is.na(NA_character_)) 
[16:01:45.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.833]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:45.833]                   {
[16:01:45.833]                     future <- SequentialFuture(..., envir = envir)
[16:01:45.833]                     if (!future$lazy) 
[16:01:45.833]                       future <- run(future)
[16:01:45.833]                     invisible(future)
[16:01:45.833]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.833]                 }
[16:01:45.833]             }
[16:01:45.833]         }
[16:01:45.833]     })
[16:01:45.833]     if (TRUE) {
[16:01:45.833]         base::sink(type = "output", split = FALSE)
[16:01:45.833]         if (TRUE) {
[16:01:45.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.833]         }
[16:01:45.833]         else {
[16:01:45.833]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.833]         }
[16:01:45.833]         base::close(...future.stdout)
[16:01:45.833]         ...future.stdout <- NULL
[16:01:45.833]     }
[16:01:45.833]     ...future.result$conditions <- ...future.conditions
[16:01:45.833]     ...future.result$finished <- base::Sys.time()
[16:01:45.833]     ...future.result
[16:01:45.833] }
[16:01:45.835] assign_globals() ...
[16:01:45.835] List of 5
[16:01:45.835]  $ ...future.FUN            :function (object, ...)  
[16:01:45.835]  $ future.call.arguments    :List of 1
[16:01:45.835]   ..$ digits: int 2
[16:01:45.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.835]  $ ...future.elements_ii    :List of 6
[16:01:45.835]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:01:45.835]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:01:45.835]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:01:45.835]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:01:45.835]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:01:45.835]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:01:45.835]  $ ...future.seeds_ii       : NULL
[16:01:45.835]  $ ...future.globals.maxSize: NULL
[16:01:45.835]  - attr(*, "where")=List of 5
[16:01:45.835]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.835]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.835]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.835]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.835]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.835]  - attr(*, "resolved")= logi FALSE
[16:01:45.835]  - attr(*, "total_size")= num 1296
[16:01:45.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.835]  - attr(*, "already-done")= logi TRUE
[16:01:45.842] - copied ‘...future.FUN’ to environment
[16:01:45.842] - copied ‘future.call.arguments’ to environment
[16:01:45.842] - copied ‘...future.elements_ii’ to environment
[16:01:45.842] - copied ‘...future.seeds_ii’ to environment
[16:01:45.842] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.842] assign_globals() ... done
[16:01:45.843] plan(): Setting new future strategy stack:
[16:01:45.843] List of future strategies:
[16:01:45.843] 1. sequential:
[16:01:45.843]    - args: function (..., envir = parent.frame())
[16:01:45.843]    - tweaked: FALSE
[16:01:45.843]    - call: NULL
[16:01:45.843] plan(): nbrOfWorkers() = 1
[16:01:45.846] plan(): Setting new future strategy stack:
[16:01:45.846] List of future strategies:
[16:01:45.846] 1. sequential:
[16:01:45.846]    - args: function (..., envir = parent.frame())
[16:01:45.846]    - tweaked: FALSE
[16:01:45.846]    - call: plan(strategy)
[16:01:45.847] plan(): nbrOfWorkers() = 1
[16:01:45.847] SequentialFuture started (and completed)
[16:01:45.847] - Launch lazy future ... done
[16:01:45.847] run() for ‘SequentialFuture’ ... done
[16:01:45.848] Created future:
[16:01:45.848] SequentialFuture:
[16:01:45.848] Label: ‘future_by-1’
[16:01:45.848] Expression:
[16:01:45.848] {
[16:01:45.848]     do.call(function(...) {
[16:01:45.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.848]             on.exit(options(oopts), add = TRUE)
[16:01:45.848]         }
[16:01:45.848]         {
[16:01:45.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.848]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.848]             })
[16:01:45.848]         }
[16:01:45.848]     }, args = future.call.arguments)
[16:01:45.848] }
[16:01:45.848] Lazy evaluation: FALSE
[16:01:45.848] Asynchronous evaluation: FALSE
[16:01:45.848] Local evaluation: TRUE
[16:01:45.848] Environment: R_GlobalEnv
[16:01:45.848] Capture standard output: TRUE
[16:01:45.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.848] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.848] Packages: <none>
[16:01:45.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.848] Resolved: TRUE
[16:01:45.848] Value: 5.48 KiB of class ‘list’
[16:01:45.848] Early signaling: FALSE
[16:01:45.848] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.848] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.849] Chunk #1 of 1 ... DONE
[16:01:45.849] Launching 1 futures (chunks) ... DONE
[16:01:45.849] Resolving 1 futures (chunks) ...
[16:01:45.849] resolve() on list ...
[16:01:45.849]  recursive: 0
[16:01:45.849]  length: 1
[16:01:45.850] 
[16:01:45.850] resolved() for ‘SequentialFuture’ ...
[16:01:45.850] - state: ‘finished’
[16:01:45.850] - run: TRUE
[16:01:45.850] - result: ‘FutureResult’
[16:01:45.850] resolved() for ‘SequentialFuture’ ... done
[16:01:45.850] Future #1
[16:01:45.850] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.850] - nx: 1
[16:01:45.851] - relay: TRUE
[16:01:45.851] - stdout: TRUE
[16:01:45.851] - signal: TRUE
[16:01:45.851] - resignal: FALSE
[16:01:45.851] - force: TRUE
[16:01:45.851] - relayed: [n=1] FALSE
[16:01:45.851] - queued futures: [n=1] FALSE
[16:01:45.851]  - until=1
[16:01:45.851]  - relaying element #1
[16:01:45.852] - relayed: [n=1] TRUE
[16:01:45.852] - queued futures: [n=1] TRUE
[16:01:45.852] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.852]  length: 0 (resolved future 1)
[16:01:45.852] Relaying remaining futures
[16:01:45.852] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.852] - nx: 1
[16:01:45.852] - relay: TRUE
[16:01:45.852] - stdout: TRUE
[16:01:45.852] - signal: TRUE
[16:01:45.852] - resignal: FALSE
[16:01:45.853] - force: TRUE
[16:01:45.853] - relayed: [n=1] TRUE
[16:01:45.853] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.853] - relayed: [n=1] TRUE
[16:01:45.853] - queued futures: [n=1] TRUE
[16:01:45.853] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.853] resolve() on list ... DONE
[16:01:45.853]  - Number of value chunks collected: 1
[16:01:45.853] Resolving 1 futures (chunks) ... DONE
[16:01:45.853] Reducing values from 1 chunks ...
[16:01:45.854]  - Number of values collected after concatenation: 6
[16:01:45.854]  - Number of values expected: 6
[16:01:45.854] Reducing values from 1 chunks ... DONE
[16:01:45.854] future_lapply() ... DONE
[16:01:45.854] future_by_internal() ... DONE
[16:01:45.855] future_by_internal() ...
[16:01:45.855] future_lapply() ...
[16:01:45.856] Number of chunks: 1
[16:01:45.856] getGlobalsAndPackagesXApply() ...
[16:01:45.856]  - future.globals: TRUE
[16:01:45.857] getGlobalsAndPackages() ...
[16:01:45.857] Searching for globals...
[16:01:45.858] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:45.858] Searching for globals ... DONE
[16:01:45.858] Resolving globals: FALSE
[16:01:45.859] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:01:45.859] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:01:45.859] - globals: [1] ‘FUN’
[16:01:45.859] - packages: [1] ‘stats’
[16:01:45.860] getGlobalsAndPackages() ... DONE
[16:01:45.860]  - globals found/used: [n=1] ‘FUN’
[16:01:45.860]  - needed namespaces: [n=1] ‘stats’
[16:01:45.860] Finding globals ... DONE
[16:01:45.860]  - use_args: TRUE
[16:01:45.860]  - Getting '...' globals ...
[16:01:45.860] resolve() on list ...
[16:01:45.860]  recursive: 0
[16:01:45.861]  length: 1
[16:01:45.861]  elements: ‘...’
[16:01:45.861]  length: 0 (resolved future 1)
[16:01:45.861] resolve() on list ... DONE
[16:01:45.861]    - '...' content: [n=1] ‘singular.ok’
[16:01:45.861] List of 1
[16:01:45.861]  $ ...:List of 1
[16:01:45.861]   ..$ singular.ok: logi FALSE
[16:01:45.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.861]  - attr(*, "where")=List of 1
[16:01:45.861]   ..$ ...:<environment: 0x55b523955a70> 
[16:01:45.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.861]  - attr(*, "resolved")= logi TRUE
[16:01:45.861]  - attr(*, "total_size")= num NA
[16:01:45.864]  - Getting '...' globals ... DONE
[16:01:45.864] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.864] List of 2
[16:01:45.864]  $ ...future.FUN:function (x, ...)  
[16:01:45.864]  $ ...          :List of 1
[16:01:45.864]   ..$ singular.ok: logi FALSE
[16:01:45.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.864]  - attr(*, "where")=List of 2
[16:01:45.864]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.864]   ..$ ...          :<environment: 0x55b523955a70> 
[16:01:45.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.864]  - attr(*, "resolved")= logi FALSE
[16:01:45.864]  - attr(*, "total_size")= num 5384
[16:01:45.869] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:45.869] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.869] Number of futures (= number of chunks): 1
[16:01:45.870] Launching 1 futures (chunks) ...
[16:01:45.870] Chunk #1 of 1 ...
[16:01:45.870]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.870] getGlobalsAndPackages() ...
[16:01:45.870] Searching for globals...
[16:01:45.871] 
[16:01:45.871] Searching for globals ... DONE
[16:01:45.871] - globals: [0] <none>
[16:01:45.871] getGlobalsAndPackages() ... DONE
[16:01:45.871]    + additional globals found: [n=0] 
[16:01:45.871]    + additional namespaces needed: [n=0] 
[16:01:45.871]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.871]  - seeds: <none>
[16:01:45.871]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.871] getGlobalsAndPackages() ...
[16:01:45.872] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.872] Resolving globals: FALSE
[16:01:45.872] Tweak future expression to call with '...' arguments ...
[16:01:45.872] {
[16:01:45.872]     do.call(function(...) {
[16:01:45.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.872]             on.exit(options(oopts), add = TRUE)
[16:01:45.872]         }
[16:01:45.872]         {
[16:01:45.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.872]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.872]             })
[16:01:45.872]         }
[16:01:45.872]     }, args = future.call.arguments)
[16:01:45.872] }
[16:01:45.872] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.872] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.873] 
[16:01:45.873] getGlobalsAndPackages() ... DONE
[16:01:45.873] run() for ‘Future’ ...
[16:01:45.873] - state: ‘created’
[16:01:45.873] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:45.874] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.874] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.874]   - Field: ‘label’
[16:01:45.874]   - Field: ‘local’
[16:01:45.874]   - Field: ‘owner’
[16:01:45.874]   - Field: ‘envir’
[16:01:45.874]   - Field: ‘packages’
[16:01:45.874]   - Field: ‘gc’
[16:01:45.874]   - Field: ‘conditions’
[16:01:45.874]   - Field: ‘expr’
[16:01:45.875]   - Field: ‘uuid’
[16:01:45.875]   - Field: ‘seed’
[16:01:45.875]   - Field: ‘version’
[16:01:45.875]   - Field: ‘result’
[16:01:45.875]   - Field: ‘asynchronous’
[16:01:45.875]   - Field: ‘calls’
[16:01:45.875]   - Field: ‘globals’
[16:01:45.875]   - Field: ‘stdout’
[16:01:45.875]   - Field: ‘earlySignal’
[16:01:45.875]   - Field: ‘lazy’
[16:01:45.875]   - Field: ‘state’
[16:01:45.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.876] - Launch lazy future ...
[16:01:45.876] Packages needed by the future expression (n = 1): ‘stats’
[16:01:45.876] Packages needed by future strategies (n = 0): <none>
[16:01:45.876] {
[16:01:45.876]     {
[16:01:45.876]         {
[16:01:45.876]             ...future.startTime <- base::Sys.time()
[16:01:45.876]             {
[16:01:45.876]                 {
[16:01:45.876]                   {
[16:01:45.876]                     {
[16:01:45.876]                       base::local({
[16:01:45.876]                         has_future <- base::requireNamespace("future", 
[16:01:45.876]                           quietly = TRUE)
[16:01:45.876]                         if (has_future) {
[16:01:45.876]                           ns <- base::getNamespace("future")
[16:01:45.876]                           version <- ns[[".package"]][["version"]]
[16:01:45.876]                           if (is.null(version)) 
[16:01:45.876]                             version <- utils::packageVersion("future")
[16:01:45.876]                         }
[16:01:45.876]                         else {
[16:01:45.876]                           version <- NULL
[16:01:45.876]                         }
[16:01:45.876]                         if (!has_future || version < "1.8.0") {
[16:01:45.876]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.876]                             "", base::R.version$version.string), 
[16:01:45.876]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:45.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.876]                               "release", "version")], collapse = " "), 
[16:01:45.876]                             hostname = base::Sys.info()[["nodename"]])
[16:01:45.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.876]                             info)
[16:01:45.876]                           info <- base::paste(info, collapse = "; ")
[16:01:45.876]                           if (!has_future) {
[16:01:45.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.876]                               info)
[16:01:45.876]                           }
[16:01:45.876]                           else {
[16:01:45.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.876]                               info, version)
[16:01:45.876]                           }
[16:01:45.876]                           base::stop(msg)
[16:01:45.876]                         }
[16:01:45.876]                       })
[16:01:45.876]                     }
[16:01:45.876]                     base::local({
[16:01:45.876]                       for (pkg in "stats") {
[16:01:45.876]                         base::loadNamespace(pkg)
[16:01:45.876]                         base::library(pkg, character.only = TRUE)
[16:01:45.876]                       }
[16:01:45.876]                     })
[16:01:45.876]                   }
[16:01:45.876]                   options(future.plan = NULL)
[16:01:45.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.876]                 }
[16:01:45.876]                 ...future.workdir <- getwd()
[16:01:45.876]             }
[16:01:45.876]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.876]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.876]         }
[16:01:45.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.876]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.876]             base::names(...future.oldOptions))
[16:01:45.876]     }
[16:01:45.876]     if (FALSE) {
[16:01:45.876]     }
[16:01:45.876]     else {
[16:01:45.876]         if (TRUE) {
[16:01:45.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.876]                 open = "w")
[16:01:45.876]         }
[16:01:45.876]         else {
[16:01:45.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.876]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.876]         }
[16:01:45.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.876]             base::sink(type = "output", split = FALSE)
[16:01:45.876]             base::close(...future.stdout)
[16:01:45.876]         }, add = TRUE)
[16:01:45.876]     }
[16:01:45.876]     ...future.frame <- base::sys.nframe()
[16:01:45.876]     ...future.conditions <- base::list()
[16:01:45.876]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.876]     if (FALSE) {
[16:01:45.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.876]     }
[16:01:45.876]     ...future.result <- base::tryCatch({
[16:01:45.876]         base::withCallingHandlers({
[16:01:45.876]             ...future.value <- base::withVisible(base::local({
[16:01:45.876]                 do.call(function(...) {
[16:01:45.876]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.876]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.876]                     ...future.globals.maxSize)) {
[16:01:45.876]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.876]                     on.exit(options(oopts), add = TRUE)
[16:01:45.876]                   }
[16:01:45.876]                   {
[16:01:45.876]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.876]                       FUN = function(jj) {
[16:01:45.876]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.876]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.876]                       })
[16:01:45.876]                   }
[16:01:45.876]                 }, args = future.call.arguments)
[16:01:45.876]             }))
[16:01:45.876]             future::FutureResult(value = ...future.value$value, 
[16:01:45.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.876]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.876]                     ...future.globalenv.names))
[16:01:45.876]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.876]         }, condition = base::local({
[16:01:45.876]             c <- base::c
[16:01:45.876]             inherits <- base::inherits
[16:01:45.876]             invokeRestart <- base::invokeRestart
[16:01:45.876]             length <- base::length
[16:01:45.876]             list <- base::list
[16:01:45.876]             seq.int <- base::seq.int
[16:01:45.876]             signalCondition <- base::signalCondition
[16:01:45.876]             sys.calls <- base::sys.calls
[16:01:45.876]             `[[` <- base::`[[`
[16:01:45.876]             `+` <- base::`+`
[16:01:45.876]             `<<-` <- base::`<<-`
[16:01:45.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.876]                   3L)]
[16:01:45.876]             }
[16:01:45.876]             function(cond) {
[16:01:45.876]                 is_error <- inherits(cond, "error")
[16:01:45.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.876]                   NULL)
[16:01:45.876]                 if (is_error) {
[16:01:45.876]                   sessionInformation <- function() {
[16:01:45.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.876]                       search = base::search(), system = base::Sys.info())
[16:01:45.876]                   }
[16:01:45.876]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.876]                     cond$call), session = sessionInformation(), 
[16:01:45.876]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.876]                   signalCondition(cond)
[16:01:45.876]                 }
[16:01:45.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.876]                 "immediateCondition"))) {
[16:01:45.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.876]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.876]                   if (TRUE && !signal) {
[16:01:45.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.876]                     {
[16:01:45.876]                       inherits <- base::inherits
[16:01:45.876]                       invokeRestart <- base::invokeRestart
[16:01:45.876]                       is.null <- base::is.null
[16:01:45.876]                       muffled <- FALSE
[16:01:45.876]                       if (inherits(cond, "message")) {
[16:01:45.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.876]                         if (muffled) 
[16:01:45.876]                           invokeRestart("muffleMessage")
[16:01:45.876]                       }
[16:01:45.876]                       else if (inherits(cond, "warning")) {
[16:01:45.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.876]                         if (muffled) 
[16:01:45.876]                           invokeRestart("muffleWarning")
[16:01:45.876]                       }
[16:01:45.876]                       else if (inherits(cond, "condition")) {
[16:01:45.876]                         if (!is.null(pattern)) {
[16:01:45.876]                           computeRestarts <- base::computeRestarts
[16:01:45.876]                           grepl <- base::grepl
[16:01:45.876]                           restarts <- computeRestarts(cond)
[16:01:45.876]                           for (restart in restarts) {
[16:01:45.876]                             name <- restart$name
[16:01:45.876]                             if (is.null(name)) 
[16:01:45.876]                               next
[16:01:45.876]                             if (!grepl(pattern, name)) 
[16:01:45.876]                               next
[16:01:45.876]                             invokeRestart(restart)
[16:01:45.876]                             muffled <- TRUE
[16:01:45.876]                             break
[16:01:45.876]                           }
[16:01:45.876]                         }
[16:01:45.876]                       }
[16:01:45.876]                       invisible(muffled)
[16:01:45.876]                     }
[16:01:45.876]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.876]                   }
[16:01:45.876]                 }
[16:01:45.876]                 else {
[16:01:45.876]                   if (TRUE) {
[16:01:45.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.876]                     {
[16:01:45.876]                       inherits <- base::inherits
[16:01:45.876]                       invokeRestart <- base::invokeRestart
[16:01:45.876]                       is.null <- base::is.null
[16:01:45.876]                       muffled <- FALSE
[16:01:45.876]                       if (inherits(cond, "message")) {
[16:01:45.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.876]                         if (muffled) 
[16:01:45.876]                           invokeRestart("muffleMessage")
[16:01:45.876]                       }
[16:01:45.876]                       else if (inherits(cond, "warning")) {
[16:01:45.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.876]                         if (muffled) 
[16:01:45.876]                           invokeRestart("muffleWarning")
[16:01:45.876]                       }
[16:01:45.876]                       else if (inherits(cond, "condition")) {
[16:01:45.876]                         if (!is.null(pattern)) {
[16:01:45.876]                           computeRestarts <- base::computeRestarts
[16:01:45.876]                           grepl <- base::grepl
[16:01:45.876]                           restarts <- computeRestarts(cond)
[16:01:45.876]                           for (restart in restarts) {
[16:01:45.876]                             name <- restart$name
[16:01:45.876]                             if (is.null(name)) 
[16:01:45.876]                               next
[16:01:45.876]                             if (!grepl(pattern, name)) 
[16:01:45.876]                               next
[16:01:45.876]                             invokeRestart(restart)
[16:01:45.876]                             muffled <- TRUE
[16:01:45.876]                             break
[16:01:45.876]                           }
[16:01:45.876]                         }
[16:01:45.876]                       }
[16:01:45.876]                       invisible(muffled)
[16:01:45.876]                     }
[16:01:45.876]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.876]                   }
[16:01:45.876]                 }
[16:01:45.876]             }
[16:01:45.876]         }))
[16:01:45.876]     }, error = function(ex) {
[16:01:45.876]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.876]                 ...future.rng), started = ...future.startTime, 
[16:01:45.876]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.876]             version = "1.8"), class = "FutureResult")
[16:01:45.876]     }, finally = {
[16:01:45.876]         if (!identical(...future.workdir, getwd())) 
[16:01:45.876]             setwd(...future.workdir)
[16:01:45.876]         {
[16:01:45.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.876]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.876]             }
[16:01:45.876]             base::options(...future.oldOptions)
[16:01:45.876]             if (.Platform$OS.type == "windows") {
[16:01:45.876]                 old_names <- names(...future.oldEnvVars)
[16:01:45.876]                 envs <- base::Sys.getenv()
[16:01:45.876]                 names <- names(envs)
[16:01:45.876]                 common <- intersect(names, old_names)
[16:01:45.876]                 added <- setdiff(names, old_names)
[16:01:45.876]                 removed <- setdiff(old_names, names)
[16:01:45.876]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.876]                   envs[common]]
[16:01:45.876]                 NAMES <- toupper(changed)
[16:01:45.876]                 args <- list()
[16:01:45.876]                 for (kk in seq_along(NAMES)) {
[16:01:45.876]                   name <- changed[[kk]]
[16:01:45.876]                   NAME <- NAMES[[kk]]
[16:01:45.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.876]                     next
[16:01:45.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.876]                 }
[16:01:45.876]                 NAMES <- toupper(added)
[16:01:45.876]                 for (kk in seq_along(NAMES)) {
[16:01:45.876]                   name <- added[[kk]]
[16:01:45.876]                   NAME <- NAMES[[kk]]
[16:01:45.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.876]                     next
[16:01:45.876]                   args[[name]] <- ""
[16:01:45.876]                 }
[16:01:45.876]                 NAMES <- toupper(removed)
[16:01:45.876]                 for (kk in seq_along(NAMES)) {
[16:01:45.876]                   name <- removed[[kk]]
[16:01:45.876]                   NAME <- NAMES[[kk]]
[16:01:45.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.876]                     next
[16:01:45.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.876]                 }
[16:01:45.876]                 if (length(args) > 0) 
[16:01:45.876]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.876]             }
[16:01:45.876]             else {
[16:01:45.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.876]             }
[16:01:45.876]             {
[16:01:45.876]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.876]                   0L) {
[16:01:45.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.876]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.876]                   base::options(opts)
[16:01:45.876]                 }
[16:01:45.876]                 {
[16:01:45.876]                   {
[16:01:45.876]                     NULL
[16:01:45.876]                     RNGkind("Mersenne-Twister")
[16:01:45.876]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.876]                       inherits = FALSE)
[16:01:45.876]                   }
[16:01:45.876]                   options(future.plan = NULL)
[16:01:45.876]                   if (is.na(NA_character_)) 
[16:01:45.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.876]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:45.876]                   {
[16:01:45.876]                     future <- SequentialFuture(..., envir = envir)
[16:01:45.876]                     if (!future$lazy) 
[16:01:45.876]                       future <- run(future)
[16:01:45.876]                     invisible(future)
[16:01:45.876]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.876]                 }
[16:01:45.876]             }
[16:01:45.876]         }
[16:01:45.876]     })
[16:01:45.876]     if (TRUE) {
[16:01:45.876]         base::sink(type = "output", split = FALSE)
[16:01:45.876]         if (TRUE) {
[16:01:45.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.876]         }
[16:01:45.876]         else {
[16:01:45.876]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.876]         }
[16:01:45.876]         base::close(...future.stdout)
[16:01:45.876]         ...future.stdout <- NULL
[16:01:45.876]     }
[16:01:45.876]     ...future.result$conditions <- ...future.conditions
[16:01:45.876]     ...future.result$finished <- base::Sys.time()
[16:01:45.876]     ...future.result
[16:01:45.876] }
[16:01:45.878] assign_globals() ...
[16:01:45.878] List of 5
[16:01:45.878]  $ ...future.FUN            :function (x, ...)  
[16:01:45.878]  $ future.call.arguments    :List of 1
[16:01:45.878]   ..$ singular.ok: logi FALSE
[16:01:45.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.878]  $ ...future.elements_ii    :List of 3
[16:01:45.878]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.878]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.878]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.878]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.878]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.878]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.878]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.878]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.878]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.878]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.878]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.878]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.878]  $ ...future.seeds_ii       : NULL
[16:01:45.878]  $ ...future.globals.maxSize: NULL
[16:01:45.878]  - attr(*, "where")=List of 5
[16:01:45.878]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.878]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.878]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.878]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.878]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.878]  - attr(*, "resolved")= logi FALSE
[16:01:45.878]  - attr(*, "total_size")= num 5384
[16:01:45.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.878]  - attr(*, "already-done")= logi TRUE
[16:01:45.889] - reassign environment for ‘...future.FUN’
[16:01:45.889] - copied ‘...future.FUN’ to environment
[16:01:45.889] - copied ‘future.call.arguments’ to environment
[16:01:45.889] - copied ‘...future.elements_ii’ to environment
[16:01:45.889] - copied ‘...future.seeds_ii’ to environment
[16:01:45.889] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.889] assign_globals() ... done
[16:01:45.890] plan(): Setting new future strategy stack:
[16:01:45.890] List of future strategies:
[16:01:45.890] 1. sequential:
[16:01:45.890]    - args: function (..., envir = parent.frame())
[16:01:45.890]    - tweaked: FALSE
[16:01:45.890]    - call: NULL
[16:01:45.890] plan(): nbrOfWorkers() = 1
[16:01:45.893] plan(): Setting new future strategy stack:
[16:01:45.893] List of future strategies:
[16:01:45.893] 1. sequential:
[16:01:45.893]    - args: function (..., envir = parent.frame())
[16:01:45.893]    - tweaked: FALSE
[16:01:45.893]    - call: plan(strategy)
[16:01:45.894] plan(): nbrOfWorkers() = 1
[16:01:45.894] SequentialFuture started (and completed)
[16:01:45.894] - Launch lazy future ... done
[16:01:45.894] run() for ‘SequentialFuture’ ... done
[16:01:45.894] Created future:
[16:01:45.894] SequentialFuture:
[16:01:45.894] Label: ‘future_by-1’
[16:01:45.894] Expression:
[16:01:45.894] {
[16:01:45.894]     do.call(function(...) {
[16:01:45.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.894]             on.exit(options(oopts), add = TRUE)
[16:01:45.894]         }
[16:01:45.894]         {
[16:01:45.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.894]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.894]             })
[16:01:45.894]         }
[16:01:45.894]     }, args = future.call.arguments)
[16:01:45.894] }
[16:01:45.894] Lazy evaluation: FALSE
[16:01:45.894] Asynchronous evaluation: FALSE
[16:01:45.894] Local evaluation: TRUE
[16:01:45.894] Environment: R_GlobalEnv
[16:01:45.894] Capture standard output: TRUE
[16:01:45.894] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.894] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.894] Packages: 1 packages (‘stats’)
[16:01:45.894] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.894] Resolved: TRUE
[16:01:45.894] Value: 26.06 KiB of class ‘list’
[16:01:45.894] Early signaling: FALSE
[16:01:45.894] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.894] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.896] Chunk #1 of 1 ... DONE
[16:01:45.896] Launching 1 futures (chunks) ... DONE
[16:01:45.896] Resolving 1 futures (chunks) ...
[16:01:45.896] resolve() on list ...
[16:01:45.896]  recursive: 0
[16:01:45.896]  length: 1
[16:01:45.896] 
[16:01:45.896] resolved() for ‘SequentialFuture’ ...
[16:01:45.896] - state: ‘finished’
[16:01:45.897] - run: TRUE
[16:01:45.897] - result: ‘FutureResult’
[16:01:45.897] resolved() for ‘SequentialFuture’ ... done
[16:01:45.897] Future #1
[16:01:45.897] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.897] - nx: 1
[16:01:45.897] - relay: TRUE
[16:01:45.897] - stdout: TRUE
[16:01:45.897] - signal: TRUE
[16:01:45.897] - resignal: FALSE
[16:01:45.898] - force: TRUE
[16:01:45.898] - relayed: [n=1] FALSE
[16:01:45.898] - queued futures: [n=1] FALSE
[16:01:45.898]  - until=1
[16:01:45.898]  - relaying element #1
[16:01:45.898] - relayed: [n=1] TRUE
[16:01:45.898] - queued futures: [n=1] TRUE
[16:01:45.898] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.898]  length: 0 (resolved future 1)
[16:01:45.898] Relaying remaining futures
[16:01:45.899] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.899] - nx: 1
[16:01:45.899] - relay: TRUE
[16:01:45.899] - stdout: TRUE
[16:01:45.899] - signal: TRUE
[16:01:45.899] - resignal: FALSE
[16:01:45.899] - force: TRUE
[16:01:45.899] - relayed: [n=1] TRUE
[16:01:45.899] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.899] - relayed: [n=1] TRUE
[16:01:45.899] - queued futures: [n=1] TRUE
[16:01:45.900] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.900] resolve() on list ... DONE
[16:01:45.900]  - Number of value chunks collected: 1
[16:01:45.900] Resolving 1 futures (chunks) ... DONE
[16:01:45.900] Reducing values from 1 chunks ...
[16:01:45.900]  - Number of values collected after concatenation: 3
[16:01:45.900]  - Number of values expected: 3
[16:01:45.900] Reducing values from 1 chunks ... DONE
[16:01:45.900] future_lapply() ... DONE
[16:01:45.900] future_by_internal() ... DONE
[16:01:45.904] future_by_internal() ...
[16:01:45.905] future_lapply() ...
[16:01:45.907] Number of chunks: 1
[16:01:45.907] getGlobalsAndPackagesXApply() ...
[16:01:45.907]  - future.globals: TRUE
[16:01:45.907] getGlobalsAndPackages() ...
[16:01:45.907] Searching for globals...
[16:01:45.909] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:45.909] Searching for globals ... DONE
[16:01:45.909] Resolving globals: FALSE
[16:01:45.910] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:01:45.910] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:01:45.910] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:45.911] - packages: [1] ‘stats’
[16:01:45.911] getGlobalsAndPackages() ... DONE
[16:01:45.911]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:45.911]  - needed namespaces: [n=1] ‘stats’
[16:01:45.911] Finding globals ... DONE
[16:01:45.911]  - use_args: TRUE
[16:01:45.911]  - Getting '...' globals ...
[16:01:45.912] resolve() on list ...
[16:01:45.912]  recursive: 0
[16:01:45.912]  length: 1
[16:01:45.912]  elements: ‘...’
[16:01:45.912]  length: 0 (resolved future 1)
[16:01:45.912] resolve() on list ... DONE
[16:01:45.912]    - '...' content: [n=0] 
[16:01:45.912] List of 1
[16:01:45.912]  $ ...: list()
[16:01:45.912]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.912]  - attr(*, "where")=List of 1
[16:01:45.912]   ..$ ...:<environment: 0x55b525ed5060> 
[16:01:45.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.912]  - attr(*, "resolved")= logi TRUE
[16:01:45.912]  - attr(*, "total_size")= num NA
[16:01:45.915]  - Getting '...' globals ... DONE
[16:01:45.915] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:01:45.915] List of 4
[16:01:45.915]  $ ...future.FUN:function (x)  
[16:01:45.915]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:45.915]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.915]  $ ...          : list()
[16:01:45.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.915]  - attr(*, "where")=List of 4
[16:01:45.915]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.915]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:01:45.915]   ..$ wool         :<environment: R_EmptyEnv> 
[16:01:45.915]   ..$ ...          :<environment: 0x55b525ed5060> 
[16:01:45.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.915]  - attr(*, "resolved")= logi FALSE
[16:01:45.915]  - attr(*, "total_size")= num 2320
[16:01:45.919] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:45.919] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.919] Number of futures (= number of chunks): 1
[16:01:45.919] Launching 1 futures (chunks) ...
[16:01:45.919] Chunk #1 of 1 ...
[16:01:45.919]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.919] getGlobalsAndPackages() ...
[16:01:45.920] Searching for globals...
[16:01:45.920] 
[16:01:45.920] Searching for globals ... DONE
[16:01:45.920] - globals: [0] <none>
[16:01:45.920] getGlobalsAndPackages() ... DONE
[16:01:45.920]    + additional globals found: [n=0] 
[16:01:45.920]    + additional namespaces needed: [n=0] 
[16:01:45.921]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.921]  - seeds: <none>
[16:01:45.921]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.921] getGlobalsAndPackages() ...
[16:01:45.921] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.921] Resolving globals: FALSE
[16:01:45.921] Tweak future expression to call with '...' arguments ...
[16:01:45.921] {
[16:01:45.921]     do.call(function(...) {
[16:01:45.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.921]             on.exit(options(oopts), add = TRUE)
[16:01:45.921]         }
[16:01:45.921]         {
[16:01:45.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.921]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.921]             })
[16:01:45.921]         }
[16:01:45.921]     }, args = future.call.arguments)
[16:01:45.921] }
[16:01:45.921] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.922] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.922] 
[16:01:45.922] getGlobalsAndPackages() ... DONE
[16:01:45.922] run() for ‘Future’ ...
[16:01:45.922] - state: ‘created’
[16:01:45.923] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:45.923] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.923] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.923]   - Field: ‘label’
[16:01:45.923]   - Field: ‘local’
[16:01:45.923]   - Field: ‘owner’
[16:01:45.923]   - Field: ‘envir’
[16:01:45.923]   - Field: ‘packages’
[16:01:45.924]   - Field: ‘gc’
[16:01:45.924]   - Field: ‘conditions’
[16:01:45.924]   - Field: ‘expr’
[16:01:45.924]   - Field: ‘uuid’
[16:01:45.924]   - Field: ‘seed’
[16:01:45.924]   - Field: ‘version’
[16:01:45.924]   - Field: ‘result’
[16:01:45.924]   - Field: ‘asynchronous’
[16:01:45.924]   - Field: ‘calls’
[16:01:45.924]   - Field: ‘globals’
[16:01:45.925]   - Field: ‘stdout’
[16:01:45.925]   - Field: ‘earlySignal’
[16:01:45.925]   - Field: ‘lazy’
[16:01:45.926]   - Field: ‘state’
[16:01:45.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.926] - Launch lazy future ...
[16:01:45.927] Packages needed by the future expression (n = 1): ‘stats’
[16:01:45.927] Packages needed by future strategies (n = 0): <none>
[16:01:45.927] {
[16:01:45.927]     {
[16:01:45.927]         {
[16:01:45.927]             ...future.startTime <- base::Sys.time()
[16:01:45.927]             {
[16:01:45.927]                 {
[16:01:45.927]                   {
[16:01:45.927]                     {
[16:01:45.927]                       base::local({
[16:01:45.927]                         has_future <- base::requireNamespace("future", 
[16:01:45.927]                           quietly = TRUE)
[16:01:45.927]                         if (has_future) {
[16:01:45.927]                           ns <- base::getNamespace("future")
[16:01:45.927]                           version <- ns[[".package"]][["version"]]
[16:01:45.927]                           if (is.null(version)) 
[16:01:45.927]                             version <- utils::packageVersion("future")
[16:01:45.927]                         }
[16:01:45.927]                         else {
[16:01:45.927]                           version <- NULL
[16:01:45.927]                         }
[16:01:45.927]                         if (!has_future || version < "1.8.0") {
[16:01:45.927]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.927]                             "", base::R.version$version.string), 
[16:01:45.927]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:45.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.927]                               "release", "version")], collapse = " "), 
[16:01:45.927]                             hostname = base::Sys.info()[["nodename"]])
[16:01:45.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.927]                             info)
[16:01:45.927]                           info <- base::paste(info, collapse = "; ")
[16:01:45.927]                           if (!has_future) {
[16:01:45.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.927]                               info)
[16:01:45.927]                           }
[16:01:45.927]                           else {
[16:01:45.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.927]                               info, version)
[16:01:45.927]                           }
[16:01:45.927]                           base::stop(msg)
[16:01:45.927]                         }
[16:01:45.927]                       })
[16:01:45.927]                     }
[16:01:45.927]                     base::local({
[16:01:45.927]                       for (pkg in "stats") {
[16:01:45.927]                         base::loadNamespace(pkg)
[16:01:45.927]                         base::library(pkg, character.only = TRUE)
[16:01:45.927]                       }
[16:01:45.927]                     })
[16:01:45.927]                   }
[16:01:45.927]                   options(future.plan = NULL)
[16:01:45.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.927]                 }
[16:01:45.927]                 ...future.workdir <- getwd()
[16:01:45.927]             }
[16:01:45.927]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.927]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.927]         }
[16:01:45.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.927]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.927]             base::names(...future.oldOptions))
[16:01:45.927]     }
[16:01:45.927]     if (FALSE) {
[16:01:45.927]     }
[16:01:45.927]     else {
[16:01:45.927]         if (TRUE) {
[16:01:45.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.927]                 open = "w")
[16:01:45.927]         }
[16:01:45.927]         else {
[16:01:45.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.927]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.927]         }
[16:01:45.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.927]             base::sink(type = "output", split = FALSE)
[16:01:45.927]             base::close(...future.stdout)
[16:01:45.927]         }, add = TRUE)
[16:01:45.927]     }
[16:01:45.927]     ...future.frame <- base::sys.nframe()
[16:01:45.927]     ...future.conditions <- base::list()
[16:01:45.927]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.927]     if (FALSE) {
[16:01:45.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.927]     }
[16:01:45.927]     ...future.result <- base::tryCatch({
[16:01:45.927]         base::withCallingHandlers({
[16:01:45.927]             ...future.value <- base::withVisible(base::local({
[16:01:45.927]                 do.call(function(...) {
[16:01:45.927]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.927]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.927]                     ...future.globals.maxSize)) {
[16:01:45.927]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.927]                     on.exit(options(oopts), add = TRUE)
[16:01:45.927]                   }
[16:01:45.927]                   {
[16:01:45.927]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.927]                       FUN = function(jj) {
[16:01:45.927]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.927]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.927]                       })
[16:01:45.927]                   }
[16:01:45.927]                 }, args = future.call.arguments)
[16:01:45.927]             }))
[16:01:45.927]             future::FutureResult(value = ...future.value$value, 
[16:01:45.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.927]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.927]                     ...future.globalenv.names))
[16:01:45.927]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.927]         }, condition = base::local({
[16:01:45.927]             c <- base::c
[16:01:45.927]             inherits <- base::inherits
[16:01:45.927]             invokeRestart <- base::invokeRestart
[16:01:45.927]             length <- base::length
[16:01:45.927]             list <- base::list
[16:01:45.927]             seq.int <- base::seq.int
[16:01:45.927]             signalCondition <- base::signalCondition
[16:01:45.927]             sys.calls <- base::sys.calls
[16:01:45.927]             `[[` <- base::`[[`
[16:01:45.927]             `+` <- base::`+`
[16:01:45.927]             `<<-` <- base::`<<-`
[16:01:45.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.927]                   3L)]
[16:01:45.927]             }
[16:01:45.927]             function(cond) {
[16:01:45.927]                 is_error <- inherits(cond, "error")
[16:01:45.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.927]                   NULL)
[16:01:45.927]                 if (is_error) {
[16:01:45.927]                   sessionInformation <- function() {
[16:01:45.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.927]                       search = base::search(), system = base::Sys.info())
[16:01:45.927]                   }
[16:01:45.927]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.927]                     cond$call), session = sessionInformation(), 
[16:01:45.927]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.927]                   signalCondition(cond)
[16:01:45.927]                 }
[16:01:45.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.927]                 "immediateCondition"))) {
[16:01:45.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.927]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.927]                   if (TRUE && !signal) {
[16:01:45.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.927]                     {
[16:01:45.927]                       inherits <- base::inherits
[16:01:45.927]                       invokeRestart <- base::invokeRestart
[16:01:45.927]                       is.null <- base::is.null
[16:01:45.927]                       muffled <- FALSE
[16:01:45.927]                       if (inherits(cond, "message")) {
[16:01:45.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.927]                         if (muffled) 
[16:01:45.927]                           invokeRestart("muffleMessage")
[16:01:45.927]                       }
[16:01:45.927]                       else if (inherits(cond, "warning")) {
[16:01:45.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.927]                         if (muffled) 
[16:01:45.927]                           invokeRestart("muffleWarning")
[16:01:45.927]                       }
[16:01:45.927]                       else if (inherits(cond, "condition")) {
[16:01:45.927]                         if (!is.null(pattern)) {
[16:01:45.927]                           computeRestarts <- base::computeRestarts
[16:01:45.927]                           grepl <- base::grepl
[16:01:45.927]                           restarts <- computeRestarts(cond)
[16:01:45.927]                           for (restart in restarts) {
[16:01:45.927]                             name <- restart$name
[16:01:45.927]                             if (is.null(name)) 
[16:01:45.927]                               next
[16:01:45.927]                             if (!grepl(pattern, name)) 
[16:01:45.927]                               next
[16:01:45.927]                             invokeRestart(restart)
[16:01:45.927]                             muffled <- TRUE
[16:01:45.927]                             break
[16:01:45.927]                           }
[16:01:45.927]                         }
[16:01:45.927]                       }
[16:01:45.927]                       invisible(muffled)
[16:01:45.927]                     }
[16:01:45.927]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.927]                   }
[16:01:45.927]                 }
[16:01:45.927]                 else {
[16:01:45.927]                   if (TRUE) {
[16:01:45.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.927]                     {
[16:01:45.927]                       inherits <- base::inherits
[16:01:45.927]                       invokeRestart <- base::invokeRestart
[16:01:45.927]                       is.null <- base::is.null
[16:01:45.927]                       muffled <- FALSE
[16:01:45.927]                       if (inherits(cond, "message")) {
[16:01:45.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.927]                         if (muffled) 
[16:01:45.927]                           invokeRestart("muffleMessage")
[16:01:45.927]                       }
[16:01:45.927]                       else if (inherits(cond, "warning")) {
[16:01:45.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.927]                         if (muffled) 
[16:01:45.927]                           invokeRestart("muffleWarning")
[16:01:45.927]                       }
[16:01:45.927]                       else if (inherits(cond, "condition")) {
[16:01:45.927]                         if (!is.null(pattern)) {
[16:01:45.927]                           computeRestarts <- base::computeRestarts
[16:01:45.927]                           grepl <- base::grepl
[16:01:45.927]                           restarts <- computeRestarts(cond)
[16:01:45.927]                           for (restart in restarts) {
[16:01:45.927]                             name <- restart$name
[16:01:45.927]                             if (is.null(name)) 
[16:01:45.927]                               next
[16:01:45.927]                             if (!grepl(pattern, name)) 
[16:01:45.927]                               next
[16:01:45.927]                             invokeRestart(restart)
[16:01:45.927]                             muffled <- TRUE
[16:01:45.927]                             break
[16:01:45.927]                           }
[16:01:45.927]                         }
[16:01:45.927]                       }
[16:01:45.927]                       invisible(muffled)
[16:01:45.927]                     }
[16:01:45.927]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.927]                   }
[16:01:45.927]                 }
[16:01:45.927]             }
[16:01:45.927]         }))
[16:01:45.927]     }, error = function(ex) {
[16:01:45.927]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.927]                 ...future.rng), started = ...future.startTime, 
[16:01:45.927]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.927]             version = "1.8"), class = "FutureResult")
[16:01:45.927]     }, finally = {
[16:01:45.927]         if (!identical(...future.workdir, getwd())) 
[16:01:45.927]             setwd(...future.workdir)
[16:01:45.927]         {
[16:01:45.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.927]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.927]             }
[16:01:45.927]             base::options(...future.oldOptions)
[16:01:45.927]             if (.Platform$OS.type == "windows") {
[16:01:45.927]                 old_names <- names(...future.oldEnvVars)
[16:01:45.927]                 envs <- base::Sys.getenv()
[16:01:45.927]                 names <- names(envs)
[16:01:45.927]                 common <- intersect(names, old_names)
[16:01:45.927]                 added <- setdiff(names, old_names)
[16:01:45.927]                 removed <- setdiff(old_names, names)
[16:01:45.927]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.927]                   envs[common]]
[16:01:45.927]                 NAMES <- toupper(changed)
[16:01:45.927]                 args <- list()
[16:01:45.927]                 for (kk in seq_along(NAMES)) {
[16:01:45.927]                   name <- changed[[kk]]
[16:01:45.927]                   NAME <- NAMES[[kk]]
[16:01:45.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.927]                     next
[16:01:45.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.927]                 }
[16:01:45.927]                 NAMES <- toupper(added)
[16:01:45.927]                 for (kk in seq_along(NAMES)) {
[16:01:45.927]                   name <- added[[kk]]
[16:01:45.927]                   NAME <- NAMES[[kk]]
[16:01:45.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.927]                     next
[16:01:45.927]                   args[[name]] <- ""
[16:01:45.927]                 }
[16:01:45.927]                 NAMES <- toupper(removed)
[16:01:45.927]                 for (kk in seq_along(NAMES)) {
[16:01:45.927]                   name <- removed[[kk]]
[16:01:45.927]                   NAME <- NAMES[[kk]]
[16:01:45.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.927]                     next
[16:01:45.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.927]                 }
[16:01:45.927]                 if (length(args) > 0) 
[16:01:45.927]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.927]             }
[16:01:45.927]             else {
[16:01:45.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.927]             }
[16:01:45.927]             {
[16:01:45.927]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.927]                   0L) {
[16:01:45.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.927]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.927]                   base::options(opts)
[16:01:45.927]                 }
[16:01:45.927]                 {
[16:01:45.927]                   {
[16:01:45.927]                     NULL
[16:01:45.927]                     RNGkind("Mersenne-Twister")
[16:01:45.927]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.927]                       inherits = FALSE)
[16:01:45.927]                   }
[16:01:45.927]                   options(future.plan = NULL)
[16:01:45.927]                   if (is.na(NA_character_)) 
[16:01:45.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.927]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:45.927]                   {
[16:01:45.927]                     future <- SequentialFuture(..., envir = envir)
[16:01:45.927]                     if (!future$lazy) 
[16:01:45.927]                       future <- run(future)
[16:01:45.927]                     invisible(future)
[16:01:45.927]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.927]                 }
[16:01:45.927]             }
[16:01:45.927]         }
[16:01:45.927]     })
[16:01:45.927]     if (TRUE) {
[16:01:45.927]         base::sink(type = "output", split = FALSE)
[16:01:45.927]         if (TRUE) {
[16:01:45.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.927]         }
[16:01:45.927]         else {
[16:01:45.927]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.927]         }
[16:01:45.927]         base::close(...future.stdout)
[16:01:45.927]         ...future.stdout <- NULL
[16:01:45.927]     }
[16:01:45.927]     ...future.result$conditions <- ...future.conditions
[16:01:45.927]     ...future.result$finished <- base::Sys.time()
[16:01:45.927]     ...future.result
[16:01:45.927] }
[16:01:45.929] assign_globals() ...
[16:01:45.929] List of 7
[16:01:45.929]  $ ...future.FUN            :function (x)  
[16:01:45.929]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:45.929]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.929]  $ future.call.arguments    : list()
[16:01:45.929]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.929]  $ ...future.elements_ii    :List of 3
[16:01:45.929]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.929]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.929]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.929]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.929]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.929]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.929]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.929]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.929]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.929]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.929]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.929]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.929]  $ ...future.seeds_ii       : NULL
[16:01:45.929]  $ ...future.globals.maxSize: NULL
[16:01:45.929]  - attr(*, "where")=List of 7
[16:01:45.929]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.929]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:01:45.929]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:01:45.929]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.929]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.929]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.929]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.929]  - attr(*, "resolved")= logi FALSE
[16:01:45.929]  - attr(*, "total_size")= num 2320
[16:01:45.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.929]  - attr(*, "already-done")= logi TRUE
[16:01:45.939] - reassign environment for ‘...future.FUN’
[16:01:45.939] - copied ‘...future.FUN’ to environment
[16:01:45.939] - copied ‘breaks’ to environment
[16:01:45.939] - copied ‘wool’ to environment
[16:01:45.940] - copied ‘future.call.arguments’ to environment
[16:01:45.940] - copied ‘...future.elements_ii’ to environment
[16:01:45.940] - copied ‘...future.seeds_ii’ to environment
[16:01:45.940] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.940] assign_globals() ... done
[16:01:45.940] plan(): Setting new future strategy stack:
[16:01:45.940] List of future strategies:
[16:01:45.940] 1. sequential:
[16:01:45.940]    - args: function (..., envir = parent.frame())
[16:01:45.940]    - tweaked: FALSE
[16:01:45.940]    - call: NULL
[16:01:45.941] plan(): nbrOfWorkers() = 1
[16:01:45.944] plan(): Setting new future strategy stack:
[16:01:45.944] List of future strategies:
[16:01:45.944] 1. sequential:
[16:01:45.944]    - args: function (..., envir = parent.frame())
[16:01:45.944]    - tweaked: FALSE
[16:01:45.944]    - call: plan(strategy)
[16:01:45.944] plan(): nbrOfWorkers() = 1
[16:01:45.944] SequentialFuture started (and completed)
[16:01:45.944] - Launch lazy future ... done
[16:01:45.944] run() for ‘SequentialFuture’ ... done
[16:01:45.945] Created future:
[16:01:45.945] SequentialFuture:
[16:01:45.945] Label: ‘future_by-1’
[16:01:45.945] Expression:
[16:01:45.945] {
[16:01:45.945]     do.call(function(...) {
[16:01:45.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.945]             on.exit(options(oopts), add = TRUE)
[16:01:45.945]         }
[16:01:45.945]         {
[16:01:45.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.945]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.945]             })
[16:01:45.945]         }
[16:01:45.945]     }, args = future.call.arguments)
[16:01:45.945] }
[16:01:45.945] Lazy evaluation: FALSE
[16:01:45.945] Asynchronous evaluation: FALSE
[16:01:45.945] Local evaluation: TRUE
[16:01:45.945] Environment: 0x55b525e67a10
[16:01:45.945] Capture standard output: TRUE
[16:01:45.945] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.945] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:01:45.945] Packages: 1 packages (‘stats’)
[16:01:45.945] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.945] Resolved: TRUE
[16:01:45.945] Value: 25.57 KiB of class ‘list’
[16:01:45.945] Early signaling: FALSE
[16:01:45.945] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.945] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.948] Chunk #1 of 1 ... DONE
[16:01:45.948] Launching 1 futures (chunks) ... DONE
[16:01:45.948] Resolving 1 futures (chunks) ...
[16:01:45.949] resolve() on list ...
[16:01:45.949]  recursive: 0
[16:01:45.949]  length: 1
[16:01:45.949] 
[16:01:45.949] resolved() for ‘SequentialFuture’ ...
[16:01:45.949] - state: ‘finished’
[16:01:45.949] - run: TRUE
[16:01:45.949] - result: ‘FutureResult’
[16:01:45.949] resolved() for ‘SequentialFuture’ ... done
[16:01:45.949] Future #1
[16:01:45.950] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.950] - nx: 1
[16:01:45.950] - relay: TRUE
[16:01:45.950] - stdout: TRUE
[16:01:45.950] - signal: TRUE
[16:01:45.950] - resignal: FALSE
[16:01:45.950] - force: TRUE
[16:01:45.950] - relayed: [n=1] FALSE
[16:01:45.950] - queued futures: [n=1] FALSE
[16:01:45.951]  - until=1
[16:01:45.951]  - relaying element #1
[16:01:45.951] - relayed: [n=1] TRUE
[16:01:45.951] - queued futures: [n=1] TRUE
[16:01:45.951] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.951]  length: 0 (resolved future 1)
[16:01:45.951] Relaying remaining futures
[16:01:45.951] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.952] - nx: 1
[16:01:45.952] - relay: TRUE
[16:01:45.952] - stdout: TRUE
[16:01:45.952] - signal: TRUE
[16:01:45.952] - resignal: FALSE
[16:01:45.952] - force: TRUE
[16:01:45.952] - relayed: [n=1] TRUE
[16:01:45.952] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.952] - relayed: [n=1] TRUE
[16:01:45.952] - queued futures: [n=1] TRUE
[16:01:45.952] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.953] resolve() on list ... DONE
[16:01:45.953]  - Number of value chunks collected: 1
[16:01:45.953] Resolving 1 futures (chunks) ... DONE
[16:01:45.953] Reducing values from 1 chunks ...
[16:01:45.953]  - Number of values collected after concatenation: 3
[16:01:45.953]  - Number of values expected: 3
[16:01:45.953] Reducing values from 1 chunks ... DONE
[16:01:45.953] future_lapply() ... DONE
[16:01:45.953] future_by_internal() ... DONE
[16:01:45.954] future_by_internal() ...
[16:01:45.954] future_lapply() ...
[16:01:45.955] Number of chunks: 1
[16:01:45.955] getGlobalsAndPackagesXApply() ...
[16:01:45.955]  - future.globals: TRUE
[16:01:45.955] getGlobalsAndPackages() ...
[16:01:45.955] Searching for globals...
[16:01:45.956] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:45.956] Searching for globals ... DONE
[16:01:45.956] Resolving globals: FALSE
[16:01:45.957] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:45.957] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:45.957] - globals: [1] ‘FUN’
[16:01:45.957] 
[16:01:45.957] getGlobalsAndPackages() ... DONE
[16:01:45.957]  - globals found/used: [n=1] ‘FUN’
[16:01:45.958]  - needed namespaces: [n=0] 
[16:01:45.958] Finding globals ... DONE
[16:01:45.958]  - use_args: TRUE
[16:01:45.958]  - Getting '...' globals ...
[16:01:45.958] resolve() on list ...
[16:01:45.958]  recursive: 0
[16:01:45.958]  length: 1
[16:01:45.958]  elements: ‘...’
[16:01:45.958]  length: 0 (resolved future 1)
[16:01:45.959] resolve() on list ... DONE
[16:01:45.959]    - '...' content: [n=0] 
[16:01:45.959] List of 1
[16:01:45.959]  $ ...: list()
[16:01:45.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.959]  - attr(*, "where")=List of 1
[16:01:45.959]   ..$ ...:<environment: 0x55b5244d93b8> 
[16:01:45.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.959]  - attr(*, "resolved")= logi TRUE
[16:01:45.959]  - attr(*, "total_size")= num NA
[16:01:45.961]  - Getting '...' globals ... DONE
[16:01:45.961] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:45.962] List of 2
[16:01:45.962]  $ ...future.FUN:function (object, ...)  
[16:01:45.962]  $ ...          : list()
[16:01:45.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.962]  - attr(*, "where")=List of 2
[16:01:45.962]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:45.962]   ..$ ...          :<environment: 0x55b5244d93b8> 
[16:01:45.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.962]  - attr(*, "resolved")= logi FALSE
[16:01:45.962]  - attr(*, "total_size")= num 1240
[16:01:45.964] Packages to be attached in all futures: [n=0] 
[16:01:45.964] getGlobalsAndPackagesXApply() ... DONE
[16:01:45.964] Number of futures (= number of chunks): 1
[16:01:45.965] Launching 1 futures (chunks) ...
[16:01:45.965] Chunk #1 of 1 ...
[16:01:45.965]  - Finding globals in 'X' for chunk #1 ...
[16:01:45.965] getGlobalsAndPackages() ...
[16:01:45.965] Searching for globals...
[16:01:45.965] 
[16:01:45.966] Searching for globals ... DONE
[16:01:45.966] - globals: [0] <none>
[16:01:45.966] getGlobalsAndPackages() ... DONE
[16:01:45.966]    + additional globals found: [n=0] 
[16:01:45.966]    + additional namespaces needed: [n=0] 
[16:01:45.966]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:45.966]  - seeds: <none>
[16:01:45.966]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.968] getGlobalsAndPackages() ...
[16:01:45.968] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.968] Resolving globals: FALSE
[16:01:45.968] Tweak future expression to call with '...' arguments ...
[16:01:45.968] {
[16:01:45.968]     do.call(function(...) {
[16:01:45.968]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.968]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.968]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.968]             on.exit(options(oopts), add = TRUE)
[16:01:45.968]         }
[16:01:45.968]         {
[16:01:45.968]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.968]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.968]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.968]             })
[16:01:45.968]         }
[16:01:45.968]     }, args = future.call.arguments)
[16:01:45.968] }
[16:01:45.969] Tweak future expression to call with '...' arguments ... DONE
[16:01:45.969] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:45.969] 
[16:01:45.969] getGlobalsAndPackages() ... DONE
[16:01:45.970] run() for ‘Future’ ...
[16:01:45.970] - state: ‘created’
[16:01:45.970] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:45.970] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:45.971]   - Field: ‘label’
[16:01:45.971]   - Field: ‘local’
[16:01:45.971]   - Field: ‘owner’
[16:01:45.971]   - Field: ‘envir’
[16:01:45.971]   - Field: ‘packages’
[16:01:45.971]   - Field: ‘gc’
[16:01:45.971]   - Field: ‘conditions’
[16:01:45.971]   - Field: ‘expr’
[16:01:45.971]   - Field: ‘uuid’
[16:01:45.972]   - Field: ‘seed’
[16:01:45.972]   - Field: ‘version’
[16:01:45.972]   - Field: ‘result’
[16:01:45.972]   - Field: ‘asynchronous’
[16:01:45.972]   - Field: ‘calls’
[16:01:45.972]   - Field: ‘globals’
[16:01:45.972]   - Field: ‘stdout’
[16:01:45.972]   - Field: ‘earlySignal’
[16:01:45.972]   - Field: ‘lazy’
[16:01:45.972]   - Field: ‘state’
[16:01:45.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:45.973] - Launch lazy future ...
[16:01:45.973] Packages needed by the future expression (n = 0): <none>
[16:01:45.973] Packages needed by future strategies (n = 0): <none>
[16:01:45.973] {
[16:01:45.973]     {
[16:01:45.973]         {
[16:01:45.973]             ...future.startTime <- base::Sys.time()
[16:01:45.973]             {
[16:01:45.973]                 {
[16:01:45.973]                   {
[16:01:45.973]                     base::local({
[16:01:45.973]                       has_future <- base::requireNamespace("future", 
[16:01:45.973]                         quietly = TRUE)
[16:01:45.973]                       if (has_future) {
[16:01:45.973]                         ns <- base::getNamespace("future")
[16:01:45.973]                         version <- ns[[".package"]][["version"]]
[16:01:45.973]                         if (is.null(version)) 
[16:01:45.973]                           version <- utils::packageVersion("future")
[16:01:45.973]                       }
[16:01:45.973]                       else {
[16:01:45.973]                         version <- NULL
[16:01:45.973]                       }
[16:01:45.973]                       if (!has_future || version < "1.8.0") {
[16:01:45.973]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:45.973]                           "", base::R.version$version.string), 
[16:01:45.973]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:45.973]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:45.973]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:45.973]                             "release", "version")], collapse = " "), 
[16:01:45.973]                           hostname = base::Sys.info()[["nodename"]])
[16:01:45.973]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:45.973]                           info)
[16:01:45.973]                         info <- base::paste(info, collapse = "; ")
[16:01:45.973]                         if (!has_future) {
[16:01:45.973]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:45.973]                             info)
[16:01:45.973]                         }
[16:01:45.973]                         else {
[16:01:45.973]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:45.973]                             info, version)
[16:01:45.973]                         }
[16:01:45.973]                         base::stop(msg)
[16:01:45.973]                       }
[16:01:45.973]                     })
[16:01:45.973]                   }
[16:01:45.973]                   options(future.plan = NULL)
[16:01:45.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:45.973]                 }
[16:01:45.973]                 ...future.workdir <- getwd()
[16:01:45.973]             }
[16:01:45.973]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:45.973]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:45.973]         }
[16:01:45.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:45.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:45.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:45.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:45.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:45.973]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:45.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:45.973]             base::names(...future.oldOptions))
[16:01:45.973]     }
[16:01:45.973]     if (FALSE) {
[16:01:45.973]     }
[16:01:45.973]     else {
[16:01:45.973]         if (TRUE) {
[16:01:45.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:45.973]                 open = "w")
[16:01:45.973]         }
[16:01:45.973]         else {
[16:01:45.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:45.973]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:45.973]         }
[16:01:45.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:45.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:45.973]             base::sink(type = "output", split = FALSE)
[16:01:45.973]             base::close(...future.stdout)
[16:01:45.973]         }, add = TRUE)
[16:01:45.973]     }
[16:01:45.973]     ...future.frame <- base::sys.nframe()
[16:01:45.973]     ...future.conditions <- base::list()
[16:01:45.973]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:45.973]     if (FALSE) {
[16:01:45.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:45.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:45.973]     }
[16:01:45.973]     ...future.result <- base::tryCatch({
[16:01:45.973]         base::withCallingHandlers({
[16:01:45.973]             ...future.value <- base::withVisible(base::local({
[16:01:45.973]                 do.call(function(...) {
[16:01:45.973]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.973]                   if (!identical(...future.globals.maxSize.org, 
[16:01:45.973]                     ...future.globals.maxSize)) {
[16:01:45.973]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.973]                     on.exit(options(oopts), add = TRUE)
[16:01:45.973]                   }
[16:01:45.973]                   {
[16:01:45.973]                     lapply(seq_along(...future.elements_ii), 
[16:01:45.973]                       FUN = function(jj) {
[16:01:45.973]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.973]                         ...future.FUN(...future.X_jj, ...)
[16:01:45.973]                       })
[16:01:45.973]                   }
[16:01:45.973]                 }, args = future.call.arguments)
[16:01:45.973]             }))
[16:01:45.973]             future::FutureResult(value = ...future.value$value, 
[16:01:45.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.973]                   ...future.rng), globalenv = if (FALSE) 
[16:01:45.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:45.973]                     ...future.globalenv.names))
[16:01:45.973]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:45.973]         }, condition = base::local({
[16:01:45.973]             c <- base::c
[16:01:45.973]             inherits <- base::inherits
[16:01:45.973]             invokeRestart <- base::invokeRestart
[16:01:45.973]             length <- base::length
[16:01:45.973]             list <- base::list
[16:01:45.973]             seq.int <- base::seq.int
[16:01:45.973]             signalCondition <- base::signalCondition
[16:01:45.973]             sys.calls <- base::sys.calls
[16:01:45.973]             `[[` <- base::`[[`
[16:01:45.973]             `+` <- base::`+`
[16:01:45.973]             `<<-` <- base::`<<-`
[16:01:45.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:45.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:45.973]                   3L)]
[16:01:45.973]             }
[16:01:45.973]             function(cond) {
[16:01:45.973]                 is_error <- inherits(cond, "error")
[16:01:45.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:45.973]                   NULL)
[16:01:45.973]                 if (is_error) {
[16:01:45.973]                   sessionInformation <- function() {
[16:01:45.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:45.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:45.973]                       search = base::search(), system = base::Sys.info())
[16:01:45.973]                   }
[16:01:45.973]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:45.973]                     cond$call), session = sessionInformation(), 
[16:01:45.973]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:45.973]                   signalCondition(cond)
[16:01:45.973]                 }
[16:01:45.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:45.973]                 "immediateCondition"))) {
[16:01:45.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:45.973]                   ...future.conditions[[length(...future.conditions) + 
[16:01:45.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:45.973]                   if (TRUE && !signal) {
[16:01:45.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.973]                     {
[16:01:45.973]                       inherits <- base::inherits
[16:01:45.973]                       invokeRestart <- base::invokeRestart
[16:01:45.973]                       is.null <- base::is.null
[16:01:45.973]                       muffled <- FALSE
[16:01:45.973]                       if (inherits(cond, "message")) {
[16:01:45.973]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.973]                         if (muffled) 
[16:01:45.973]                           invokeRestart("muffleMessage")
[16:01:45.973]                       }
[16:01:45.973]                       else if (inherits(cond, "warning")) {
[16:01:45.973]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.973]                         if (muffled) 
[16:01:45.973]                           invokeRestart("muffleWarning")
[16:01:45.973]                       }
[16:01:45.973]                       else if (inherits(cond, "condition")) {
[16:01:45.973]                         if (!is.null(pattern)) {
[16:01:45.973]                           computeRestarts <- base::computeRestarts
[16:01:45.973]                           grepl <- base::grepl
[16:01:45.973]                           restarts <- computeRestarts(cond)
[16:01:45.973]                           for (restart in restarts) {
[16:01:45.973]                             name <- restart$name
[16:01:45.973]                             if (is.null(name)) 
[16:01:45.973]                               next
[16:01:45.973]                             if (!grepl(pattern, name)) 
[16:01:45.973]                               next
[16:01:45.973]                             invokeRestart(restart)
[16:01:45.973]                             muffled <- TRUE
[16:01:45.973]                             break
[16:01:45.973]                           }
[16:01:45.973]                         }
[16:01:45.973]                       }
[16:01:45.973]                       invisible(muffled)
[16:01:45.973]                     }
[16:01:45.973]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.973]                   }
[16:01:45.973]                 }
[16:01:45.973]                 else {
[16:01:45.973]                   if (TRUE) {
[16:01:45.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:45.973]                     {
[16:01:45.973]                       inherits <- base::inherits
[16:01:45.973]                       invokeRestart <- base::invokeRestart
[16:01:45.973]                       is.null <- base::is.null
[16:01:45.973]                       muffled <- FALSE
[16:01:45.973]                       if (inherits(cond, "message")) {
[16:01:45.973]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:45.973]                         if (muffled) 
[16:01:45.973]                           invokeRestart("muffleMessage")
[16:01:45.973]                       }
[16:01:45.973]                       else if (inherits(cond, "warning")) {
[16:01:45.973]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:45.973]                         if (muffled) 
[16:01:45.973]                           invokeRestart("muffleWarning")
[16:01:45.973]                       }
[16:01:45.973]                       else if (inherits(cond, "condition")) {
[16:01:45.973]                         if (!is.null(pattern)) {
[16:01:45.973]                           computeRestarts <- base::computeRestarts
[16:01:45.973]                           grepl <- base::grepl
[16:01:45.973]                           restarts <- computeRestarts(cond)
[16:01:45.973]                           for (restart in restarts) {
[16:01:45.973]                             name <- restart$name
[16:01:45.973]                             if (is.null(name)) 
[16:01:45.973]                               next
[16:01:45.973]                             if (!grepl(pattern, name)) 
[16:01:45.973]                               next
[16:01:45.973]                             invokeRestart(restart)
[16:01:45.973]                             muffled <- TRUE
[16:01:45.973]                             break
[16:01:45.973]                           }
[16:01:45.973]                         }
[16:01:45.973]                       }
[16:01:45.973]                       invisible(muffled)
[16:01:45.973]                     }
[16:01:45.973]                     muffleCondition(cond, pattern = "^muffle")
[16:01:45.973]                   }
[16:01:45.973]                 }
[16:01:45.973]             }
[16:01:45.973]         }))
[16:01:45.973]     }, error = function(ex) {
[16:01:45.973]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:45.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:45.973]                 ...future.rng), started = ...future.startTime, 
[16:01:45.973]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:45.973]             version = "1.8"), class = "FutureResult")
[16:01:45.973]     }, finally = {
[16:01:45.973]         if (!identical(...future.workdir, getwd())) 
[16:01:45.973]             setwd(...future.workdir)
[16:01:45.973]         {
[16:01:45.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:45.973]                 ...future.oldOptions$nwarnings <- NULL
[16:01:45.973]             }
[16:01:45.973]             base::options(...future.oldOptions)
[16:01:45.973]             if (.Platform$OS.type == "windows") {
[16:01:45.973]                 old_names <- names(...future.oldEnvVars)
[16:01:45.973]                 envs <- base::Sys.getenv()
[16:01:45.973]                 names <- names(envs)
[16:01:45.973]                 common <- intersect(names, old_names)
[16:01:45.973]                 added <- setdiff(names, old_names)
[16:01:45.973]                 removed <- setdiff(old_names, names)
[16:01:45.973]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:45.973]                   envs[common]]
[16:01:45.973]                 NAMES <- toupper(changed)
[16:01:45.973]                 args <- list()
[16:01:45.973]                 for (kk in seq_along(NAMES)) {
[16:01:45.973]                   name <- changed[[kk]]
[16:01:45.973]                   NAME <- NAMES[[kk]]
[16:01:45.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.973]                     next
[16:01:45.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.973]                 }
[16:01:45.973]                 NAMES <- toupper(added)
[16:01:45.973]                 for (kk in seq_along(NAMES)) {
[16:01:45.973]                   name <- added[[kk]]
[16:01:45.973]                   NAME <- NAMES[[kk]]
[16:01:45.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.973]                     next
[16:01:45.973]                   args[[name]] <- ""
[16:01:45.973]                 }
[16:01:45.973]                 NAMES <- toupper(removed)
[16:01:45.973]                 for (kk in seq_along(NAMES)) {
[16:01:45.973]                   name <- removed[[kk]]
[16:01:45.973]                   NAME <- NAMES[[kk]]
[16:01:45.973]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:45.973]                     next
[16:01:45.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:45.973]                 }
[16:01:45.973]                 if (length(args) > 0) 
[16:01:45.973]                   base::do.call(base::Sys.setenv, args = args)
[16:01:45.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:45.973]             }
[16:01:45.973]             else {
[16:01:45.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:45.973]             }
[16:01:45.973]             {
[16:01:45.973]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:45.973]                   0L) {
[16:01:45.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:45.973]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:45.973]                   base::options(opts)
[16:01:45.973]                 }
[16:01:45.973]                 {
[16:01:45.973]                   {
[16:01:45.973]                     NULL
[16:01:45.973]                     RNGkind("Mersenne-Twister")
[16:01:45.973]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:45.973]                       inherits = FALSE)
[16:01:45.973]                   }
[16:01:45.973]                   options(future.plan = NULL)
[16:01:45.973]                   if (is.na(NA_character_)) 
[16:01:45.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:45.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:45.973]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:45.973]                   {
[16:01:45.973]                     future <- SequentialFuture(..., envir = envir)
[16:01:45.973]                     if (!future$lazy) 
[16:01:45.973]                       future <- run(future)
[16:01:45.973]                     invisible(future)
[16:01:45.973]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:45.973]                 }
[16:01:45.973]             }
[16:01:45.973]         }
[16:01:45.973]     })
[16:01:45.973]     if (TRUE) {
[16:01:45.973]         base::sink(type = "output", split = FALSE)
[16:01:45.973]         if (TRUE) {
[16:01:45.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:45.973]         }
[16:01:45.973]         else {
[16:01:45.973]             ...future.result["stdout"] <- base::list(NULL)
[16:01:45.973]         }
[16:01:45.973]         base::close(...future.stdout)
[16:01:45.973]         ...future.stdout <- NULL
[16:01:45.973]     }
[16:01:45.973]     ...future.result$conditions <- ...future.conditions
[16:01:45.973]     ...future.result$finished <- base::Sys.time()
[16:01:45.973]     ...future.result
[16:01:45.973] }
[16:01:45.975] assign_globals() ...
[16:01:45.975] List of 5
[16:01:45.975]  $ ...future.FUN            :function (object, ...)  
[16:01:45.975]  $ future.call.arguments    : list()
[16:01:45.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:45.975]  $ ...future.elements_ii    :List of 3
[16:01:45.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.975]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:45.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:45.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.975]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:45.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:45.975]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:45.975]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:45.975]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:45.975]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:45.975]  $ ...future.seeds_ii       : NULL
[16:01:45.975]  $ ...future.globals.maxSize: NULL
[16:01:45.975]  - attr(*, "where")=List of 5
[16:01:45.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:45.975]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:45.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:45.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:45.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:45.975]  - attr(*, "resolved")= logi FALSE
[16:01:45.975]  - attr(*, "total_size")= num 1240
[16:01:45.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:45.975]  - attr(*, "already-done")= logi TRUE
[16:01:45.984] - copied ‘...future.FUN’ to environment
[16:01:45.984] - copied ‘future.call.arguments’ to environment
[16:01:45.984] - copied ‘...future.elements_ii’ to environment
[16:01:45.984] - copied ‘...future.seeds_ii’ to environment
[16:01:45.984] - copied ‘...future.globals.maxSize’ to environment
[16:01:45.984] assign_globals() ... done
[16:01:45.985] plan(): Setting new future strategy stack:
[16:01:45.985] List of future strategies:
[16:01:45.985] 1. sequential:
[16:01:45.985]    - args: function (..., envir = parent.frame())
[16:01:45.985]    - tweaked: FALSE
[16:01:45.985]    - call: NULL
[16:01:45.985] plan(): nbrOfWorkers() = 1
[16:01:45.987] plan(): Setting new future strategy stack:
[16:01:45.987] List of future strategies:
[16:01:45.987] 1. sequential:
[16:01:45.987]    - args: function (..., envir = parent.frame())
[16:01:45.987]    - tweaked: FALSE
[16:01:45.987]    - call: plan(strategy)
[16:01:45.988] plan(): nbrOfWorkers() = 1
[16:01:45.988] SequentialFuture started (and completed)
[16:01:45.988] - Launch lazy future ... done
[16:01:45.988] run() for ‘SequentialFuture’ ... done
[16:01:45.990] Created future:
[16:01:45.990] SequentialFuture:
[16:01:45.990] Label: ‘future_by-1’
[16:01:45.990] Expression:
[16:01:45.990] {
[16:01:45.990]     do.call(function(...) {
[16:01:45.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:45.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:45.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:45.990]             on.exit(options(oopts), add = TRUE)
[16:01:45.990]         }
[16:01:45.990]         {
[16:01:45.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:45.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:45.990]                 ...future.FUN(...future.X_jj, ...)
[16:01:45.990]             })
[16:01:45.990]         }
[16:01:45.990]     }, args = future.call.arguments)
[16:01:45.990] }
[16:01:45.990] Lazy evaluation: FALSE
[16:01:45.990] Asynchronous evaluation: FALSE
[16:01:45.990] Local evaluation: TRUE
[16:01:45.990] Environment: 0x55b524746b60
[16:01:45.990] Capture standard output: TRUE
[16:01:45.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:45.990] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:45.990] Packages: <none>
[16:01:45.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:45.990] Resolved: TRUE
[16:01:45.990] Value: 5.37 KiB of class ‘list’
[16:01:45.990] Early signaling: FALSE
[16:01:45.990] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:45.990] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:45.991] Chunk #1 of 1 ... DONE
[16:01:45.992] Launching 1 futures (chunks) ... DONE
[16:01:45.992] Resolving 1 futures (chunks) ...
[16:01:45.992] resolve() on list ...
[16:01:45.992]  recursive: 0
[16:01:45.992]  length: 1
[16:01:45.992] 
[16:01:45.992] resolved() for ‘SequentialFuture’ ...
[16:01:45.992] - state: ‘finished’
[16:01:45.992] - run: TRUE
[16:01:45.993] - result: ‘FutureResult’
[16:01:45.993] resolved() for ‘SequentialFuture’ ... done
[16:01:45.993] Future #1
[16:01:45.993] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:45.993] - nx: 1
[16:01:45.993] - relay: TRUE
[16:01:45.993] - stdout: TRUE
[16:01:45.993] - signal: TRUE
[16:01:45.993] - resignal: FALSE
[16:01:45.994] - force: TRUE
[16:01:45.994] - relayed: [n=1] FALSE
[16:01:45.994] - queued futures: [n=1] FALSE
[16:01:45.994]  - until=1
[16:01:45.994]  - relaying element #1
[16:01:45.994] - relayed: [n=1] TRUE
[16:01:45.994] - queued futures: [n=1] TRUE
[16:01:45.994] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:45.994]  length: 0 (resolved future 1)
[16:01:45.995] Relaying remaining futures
[16:01:45.995] signalConditionsASAP(NULL, pos=0) ...
[16:01:45.995] - nx: 1
[16:01:45.995] - relay: TRUE
[16:01:45.995] - stdout: TRUE
[16:01:45.995] - signal: TRUE
[16:01:45.995] - resignal: FALSE
[16:01:45.995] - force: TRUE
[16:01:45.995] - relayed: [n=1] TRUE
[16:01:45.995] - queued futures: [n=1] TRUE
 - flush all
[16:01:45.996] - relayed: [n=1] TRUE
[16:01:45.996] - queued futures: [n=1] TRUE
[16:01:45.996] signalConditionsASAP(NULL, pos=0) ... done
[16:01:45.996] resolve() on list ... DONE
[16:01:45.996]  - Number of value chunks collected: 1
[16:01:45.996] Resolving 1 futures (chunks) ... DONE
[16:01:45.996] Reducing values from 1 chunks ...
[16:01:45.996]  - Number of values collected after concatenation: 3
[16:01:45.996]  - Number of values expected: 3
[16:01:45.996] Reducing values from 1 chunks ... DONE
[16:01:45.996] future_lapply() ... DONE
[16:01:45.997] future_by_internal() ... DONE
[16:01:45.997] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:01:45.998] future_lapply() ...
[16:01:45.998] Number of chunks: 1
[16:01:45.999] getGlobalsAndPackagesXApply() ...
[16:01:45.999]  - future.globals: TRUE
[16:01:45.999] getGlobalsAndPackages() ...
[16:01:45.999] Searching for globals...
[16:01:46.000] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:46.000] Searching for globals ... DONE
[16:01:46.000] Resolving globals: FALSE
[16:01:46.000] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:46.001] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:46.001] - globals: [1] ‘FUN’
[16:01:46.001] 
[16:01:46.001] getGlobalsAndPackages() ... DONE
[16:01:46.001]  - globals found/used: [n=1] ‘FUN’
[16:01:46.001]  - needed namespaces: [n=0] 
[16:01:46.001] Finding globals ... DONE
[16:01:46.001]  - use_args: TRUE
[16:01:46.002]  - Getting '...' globals ...
[16:01:46.002] resolve() on list ...
[16:01:46.002]  recursive: 0
[16:01:46.002]  length: 1
[16:01:46.002]  elements: ‘...’
[16:01:46.002]  length: 0 (resolved future 1)
[16:01:46.002] resolve() on list ... DONE
[16:01:46.002]    - '...' content: [n=0] 
[16:01:46.003] List of 1
[16:01:46.003]  $ ...: list()
[16:01:46.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.003]  - attr(*, "where")=List of 1
[16:01:46.003]   ..$ ...:<environment: 0x55b523b4f9e8> 
[16:01:46.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.003]  - attr(*, "resolved")= logi TRUE
[16:01:46.003]  - attr(*, "total_size")= num NA
[16:01:46.005]  - Getting '...' globals ... DONE
[16:01:46.005] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:46.005] List of 2
[16:01:46.005]  $ ...future.FUN:function (object, ...)  
[16:01:46.005]  $ ...          : list()
[16:01:46.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.005]  - attr(*, "where")=List of 2
[16:01:46.005]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.005]   ..$ ...          :<environment: 0x55b523b4f9e8> 
[16:01:46.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.005]  - attr(*, "resolved")= logi FALSE
[16:01:46.005]  - attr(*, "total_size")= num 1240
[16:01:46.008] Packages to be attached in all futures: [n=0] 
[16:01:46.008] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.010] Number of futures (= number of chunks): 1
[16:01:46.010] Launching 1 futures (chunks) ...
[16:01:46.010] Chunk #1 of 1 ...
[16:01:46.011]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.011] getGlobalsAndPackages() ...
[16:01:46.011] Searching for globals...
[16:01:46.011] 
[16:01:46.012] Searching for globals ... DONE
[16:01:46.012] - globals: [0] <none>
[16:01:46.012] getGlobalsAndPackages() ... DONE
[16:01:46.012]    + additional globals found: [n=0] 
[16:01:46.012]    + additional namespaces needed: [n=0] 
[16:01:46.012]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.012]  - seeds: <none>
[16:01:46.012]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.013] getGlobalsAndPackages() ...
[16:01:46.013] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.013] Resolving globals: FALSE
[16:01:46.013] Tweak future expression to call with '...' arguments ...
[16:01:46.013] {
[16:01:46.013]     do.call(function(...) {
[16:01:46.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.013]             on.exit(options(oopts), add = TRUE)
[16:01:46.013]         }
[16:01:46.013]         {
[16:01:46.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.013]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.013]             })
[16:01:46.013]         }
[16:01:46.013]     }, args = future.call.arguments)
[16:01:46.013] }
[16:01:46.013] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.014] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.014] 
[16:01:46.014] getGlobalsAndPackages() ... DONE
[16:01:46.014] run() for ‘Future’ ...
[16:01:46.014] - state: ‘created’
[16:01:46.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:46.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:46.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:46.015]   - Field: ‘label’
[16:01:46.015]   - Field: ‘local’
[16:01:46.016]   - Field: ‘owner’
[16:01:46.016]   - Field: ‘envir’
[16:01:46.016]   - Field: ‘packages’
[16:01:46.016]   - Field: ‘gc’
[16:01:46.016]   - Field: ‘conditions’
[16:01:46.016]   - Field: ‘expr’
[16:01:46.016]   - Field: ‘uuid’
[16:01:46.016]   - Field: ‘seed’
[16:01:46.016]   - Field: ‘version’
[16:01:46.016]   - Field: ‘result’
[16:01:46.016]   - Field: ‘asynchronous’
[16:01:46.017]   - Field: ‘calls’
[16:01:46.017]   - Field: ‘globals’
[16:01:46.017]   - Field: ‘stdout’
[16:01:46.017]   - Field: ‘earlySignal’
[16:01:46.017]   - Field: ‘lazy’
[16:01:46.017]   - Field: ‘state’
[16:01:46.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:46.017] - Launch lazy future ...
[16:01:46.017] Packages needed by the future expression (n = 0): <none>
[16:01:46.018] Packages needed by future strategies (n = 0): <none>
[16:01:46.018] {
[16:01:46.018]     {
[16:01:46.018]         {
[16:01:46.018]             ...future.startTime <- base::Sys.time()
[16:01:46.018]             {
[16:01:46.018]                 {
[16:01:46.018]                   {
[16:01:46.018]                     base::local({
[16:01:46.018]                       has_future <- base::requireNamespace("future", 
[16:01:46.018]                         quietly = TRUE)
[16:01:46.018]                       if (has_future) {
[16:01:46.018]                         ns <- base::getNamespace("future")
[16:01:46.018]                         version <- ns[[".package"]][["version"]]
[16:01:46.018]                         if (is.null(version)) 
[16:01:46.018]                           version <- utils::packageVersion("future")
[16:01:46.018]                       }
[16:01:46.018]                       else {
[16:01:46.018]                         version <- NULL
[16:01:46.018]                       }
[16:01:46.018]                       if (!has_future || version < "1.8.0") {
[16:01:46.018]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.018]                           "", base::R.version$version.string), 
[16:01:46.018]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:46.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.018]                             "release", "version")], collapse = " "), 
[16:01:46.018]                           hostname = base::Sys.info()[["nodename"]])
[16:01:46.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.018]                           info)
[16:01:46.018]                         info <- base::paste(info, collapse = "; ")
[16:01:46.018]                         if (!has_future) {
[16:01:46.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.018]                             info)
[16:01:46.018]                         }
[16:01:46.018]                         else {
[16:01:46.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.018]                             info, version)
[16:01:46.018]                         }
[16:01:46.018]                         base::stop(msg)
[16:01:46.018]                       }
[16:01:46.018]                     })
[16:01:46.018]                   }
[16:01:46.018]                   options(future.plan = NULL)
[16:01:46.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.018]                 }
[16:01:46.018]                 ...future.workdir <- getwd()
[16:01:46.018]             }
[16:01:46.018]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.018]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.018]         }
[16:01:46.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:46.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.018]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.018]             base::names(...future.oldOptions))
[16:01:46.018]     }
[16:01:46.018]     if (FALSE) {
[16:01:46.018]     }
[16:01:46.018]     else {
[16:01:46.018]         if (TRUE) {
[16:01:46.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.018]                 open = "w")
[16:01:46.018]         }
[16:01:46.018]         else {
[16:01:46.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.018]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.018]         }
[16:01:46.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.018]             base::sink(type = "output", split = FALSE)
[16:01:46.018]             base::close(...future.stdout)
[16:01:46.018]         }, add = TRUE)
[16:01:46.018]     }
[16:01:46.018]     ...future.frame <- base::sys.nframe()
[16:01:46.018]     ...future.conditions <- base::list()
[16:01:46.018]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.018]     if (FALSE) {
[16:01:46.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.018]     }
[16:01:46.018]     ...future.result <- base::tryCatch({
[16:01:46.018]         base::withCallingHandlers({
[16:01:46.018]             ...future.value <- base::withVisible(base::local({
[16:01:46.018]                 do.call(function(...) {
[16:01:46.018]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.018]                   if (!identical(...future.globals.maxSize.org, 
[16:01:46.018]                     ...future.globals.maxSize)) {
[16:01:46.018]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.018]                     on.exit(options(oopts), add = TRUE)
[16:01:46.018]                   }
[16:01:46.018]                   {
[16:01:46.018]                     lapply(seq_along(...future.elements_ii), 
[16:01:46.018]                       FUN = function(jj) {
[16:01:46.018]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.018]                         ...future.FUN(...future.X_jj, ...)
[16:01:46.018]                       })
[16:01:46.018]                   }
[16:01:46.018]                 }, args = future.call.arguments)
[16:01:46.018]             }))
[16:01:46.018]             future::FutureResult(value = ...future.value$value, 
[16:01:46.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.018]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.018]                     ...future.globalenv.names))
[16:01:46.018]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.018]         }, condition = base::local({
[16:01:46.018]             c <- base::c
[16:01:46.018]             inherits <- base::inherits
[16:01:46.018]             invokeRestart <- base::invokeRestart
[16:01:46.018]             length <- base::length
[16:01:46.018]             list <- base::list
[16:01:46.018]             seq.int <- base::seq.int
[16:01:46.018]             signalCondition <- base::signalCondition
[16:01:46.018]             sys.calls <- base::sys.calls
[16:01:46.018]             `[[` <- base::`[[`
[16:01:46.018]             `+` <- base::`+`
[16:01:46.018]             `<<-` <- base::`<<-`
[16:01:46.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.018]                   3L)]
[16:01:46.018]             }
[16:01:46.018]             function(cond) {
[16:01:46.018]                 is_error <- inherits(cond, "error")
[16:01:46.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.018]                   NULL)
[16:01:46.018]                 if (is_error) {
[16:01:46.018]                   sessionInformation <- function() {
[16:01:46.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.018]                       search = base::search(), system = base::Sys.info())
[16:01:46.018]                   }
[16:01:46.018]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.018]                     cond$call), session = sessionInformation(), 
[16:01:46.018]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.018]                   signalCondition(cond)
[16:01:46.018]                 }
[16:01:46.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.018]                 "immediateCondition"))) {
[16:01:46.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.018]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.018]                   if (TRUE && !signal) {
[16:01:46.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.018]                     {
[16:01:46.018]                       inherits <- base::inherits
[16:01:46.018]                       invokeRestart <- base::invokeRestart
[16:01:46.018]                       is.null <- base::is.null
[16:01:46.018]                       muffled <- FALSE
[16:01:46.018]                       if (inherits(cond, "message")) {
[16:01:46.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.018]                         if (muffled) 
[16:01:46.018]                           invokeRestart("muffleMessage")
[16:01:46.018]                       }
[16:01:46.018]                       else if (inherits(cond, "warning")) {
[16:01:46.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.018]                         if (muffled) 
[16:01:46.018]                           invokeRestart("muffleWarning")
[16:01:46.018]                       }
[16:01:46.018]                       else if (inherits(cond, "condition")) {
[16:01:46.018]                         if (!is.null(pattern)) {
[16:01:46.018]                           computeRestarts <- base::computeRestarts
[16:01:46.018]                           grepl <- base::grepl
[16:01:46.018]                           restarts <- computeRestarts(cond)
[16:01:46.018]                           for (restart in restarts) {
[16:01:46.018]                             name <- restart$name
[16:01:46.018]                             if (is.null(name)) 
[16:01:46.018]                               next
[16:01:46.018]                             if (!grepl(pattern, name)) 
[16:01:46.018]                               next
[16:01:46.018]                             invokeRestart(restart)
[16:01:46.018]                             muffled <- TRUE
[16:01:46.018]                             break
[16:01:46.018]                           }
[16:01:46.018]                         }
[16:01:46.018]                       }
[16:01:46.018]                       invisible(muffled)
[16:01:46.018]                     }
[16:01:46.018]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.018]                   }
[16:01:46.018]                 }
[16:01:46.018]                 else {
[16:01:46.018]                   if (TRUE) {
[16:01:46.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.018]                     {
[16:01:46.018]                       inherits <- base::inherits
[16:01:46.018]                       invokeRestart <- base::invokeRestart
[16:01:46.018]                       is.null <- base::is.null
[16:01:46.018]                       muffled <- FALSE
[16:01:46.018]                       if (inherits(cond, "message")) {
[16:01:46.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.018]                         if (muffled) 
[16:01:46.018]                           invokeRestart("muffleMessage")
[16:01:46.018]                       }
[16:01:46.018]                       else if (inherits(cond, "warning")) {
[16:01:46.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.018]                         if (muffled) 
[16:01:46.018]                           invokeRestart("muffleWarning")
[16:01:46.018]                       }
[16:01:46.018]                       else if (inherits(cond, "condition")) {
[16:01:46.018]                         if (!is.null(pattern)) {
[16:01:46.018]                           computeRestarts <- base::computeRestarts
[16:01:46.018]                           grepl <- base::grepl
[16:01:46.018]                           restarts <- computeRestarts(cond)
[16:01:46.018]                           for (restart in restarts) {
[16:01:46.018]                             name <- restart$name
[16:01:46.018]                             if (is.null(name)) 
[16:01:46.018]                               next
[16:01:46.018]                             if (!grepl(pattern, name)) 
[16:01:46.018]                               next
[16:01:46.018]                             invokeRestart(restart)
[16:01:46.018]                             muffled <- TRUE
[16:01:46.018]                             break
[16:01:46.018]                           }
[16:01:46.018]                         }
[16:01:46.018]                       }
[16:01:46.018]                       invisible(muffled)
[16:01:46.018]                     }
[16:01:46.018]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.018]                   }
[16:01:46.018]                 }
[16:01:46.018]             }
[16:01:46.018]         }))
[16:01:46.018]     }, error = function(ex) {
[16:01:46.018]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.018]                 ...future.rng), started = ...future.startTime, 
[16:01:46.018]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.018]             version = "1.8"), class = "FutureResult")
[16:01:46.018]     }, finally = {
[16:01:46.018]         if (!identical(...future.workdir, getwd())) 
[16:01:46.018]             setwd(...future.workdir)
[16:01:46.018]         {
[16:01:46.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.018]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.018]             }
[16:01:46.018]             base::options(...future.oldOptions)
[16:01:46.018]             if (.Platform$OS.type == "windows") {
[16:01:46.018]                 old_names <- names(...future.oldEnvVars)
[16:01:46.018]                 envs <- base::Sys.getenv()
[16:01:46.018]                 names <- names(envs)
[16:01:46.018]                 common <- intersect(names, old_names)
[16:01:46.018]                 added <- setdiff(names, old_names)
[16:01:46.018]                 removed <- setdiff(old_names, names)
[16:01:46.018]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.018]                   envs[common]]
[16:01:46.018]                 NAMES <- toupper(changed)
[16:01:46.018]                 args <- list()
[16:01:46.018]                 for (kk in seq_along(NAMES)) {
[16:01:46.018]                   name <- changed[[kk]]
[16:01:46.018]                   NAME <- NAMES[[kk]]
[16:01:46.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.018]                     next
[16:01:46.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.018]                 }
[16:01:46.018]                 NAMES <- toupper(added)
[16:01:46.018]                 for (kk in seq_along(NAMES)) {
[16:01:46.018]                   name <- added[[kk]]
[16:01:46.018]                   NAME <- NAMES[[kk]]
[16:01:46.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.018]                     next
[16:01:46.018]                   args[[name]] <- ""
[16:01:46.018]                 }
[16:01:46.018]                 NAMES <- toupper(removed)
[16:01:46.018]                 for (kk in seq_along(NAMES)) {
[16:01:46.018]                   name <- removed[[kk]]
[16:01:46.018]                   NAME <- NAMES[[kk]]
[16:01:46.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.018]                     next
[16:01:46.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.018]                 }
[16:01:46.018]                 if (length(args) > 0) 
[16:01:46.018]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.018]             }
[16:01:46.018]             else {
[16:01:46.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.018]             }
[16:01:46.018]             {
[16:01:46.018]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.018]                   0L) {
[16:01:46.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.018]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.018]                   base::options(opts)
[16:01:46.018]                 }
[16:01:46.018]                 {
[16:01:46.018]                   {
[16:01:46.018]                     NULL
[16:01:46.018]                     RNGkind("Mersenne-Twister")
[16:01:46.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:46.018]                       inherits = FALSE)
[16:01:46.018]                   }
[16:01:46.018]                   options(future.plan = NULL)
[16:01:46.018]                   if (is.na(NA_character_)) 
[16:01:46.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.018]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:46.018]                   {
[16:01:46.018]                     future <- SequentialFuture(..., envir = envir)
[16:01:46.018]                     if (!future$lazy) 
[16:01:46.018]                       future <- run(future)
[16:01:46.018]                     invisible(future)
[16:01:46.018]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.018]                 }
[16:01:46.018]             }
[16:01:46.018]         }
[16:01:46.018]     })
[16:01:46.018]     if (TRUE) {
[16:01:46.018]         base::sink(type = "output", split = FALSE)
[16:01:46.018]         if (TRUE) {
[16:01:46.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.018]         }
[16:01:46.018]         else {
[16:01:46.018]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.018]         }
[16:01:46.018]         base::close(...future.stdout)
[16:01:46.018]         ...future.stdout <- NULL
[16:01:46.018]     }
[16:01:46.018]     ...future.result$conditions <- ...future.conditions
[16:01:46.018]     ...future.result$finished <- base::Sys.time()
[16:01:46.018]     ...future.result
[16:01:46.018] }
[16:01:46.020] assign_globals() ...
[16:01:46.020] List of 5
[16:01:46.020]  $ ...future.FUN            :function (object, ...)  
[16:01:46.020]  $ future.call.arguments    : list()
[16:01:46.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.020]  $ ...future.elements_ii    :List of 3
[16:01:46.020]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.020]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:46.020]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.020]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.020]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.020]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:46.020]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.020]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:46.020]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.020]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:46.020]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.020]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:46.020]  $ ...future.seeds_ii       : NULL
[16:01:46.020]  $ ...future.globals.maxSize: NULL
[16:01:46.020]  - attr(*, "where")=List of 5
[16:01:46.020]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.020]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.020]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.020]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.020]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.020]  - attr(*, "resolved")= logi FALSE
[16:01:46.020]  - attr(*, "total_size")= num 1240
[16:01:46.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.020]  - attr(*, "already-done")= logi TRUE
[16:01:46.029] - copied ‘...future.FUN’ to environment
[16:01:46.029] - copied ‘future.call.arguments’ to environment
[16:01:46.029] - copied ‘...future.elements_ii’ to environment
[16:01:46.029] - copied ‘...future.seeds_ii’ to environment
[16:01:46.029] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.029] assign_globals() ... done
[16:01:46.029] plan(): Setting new future strategy stack:
[16:01:46.029] List of future strategies:
[16:01:46.029] 1. sequential:
[16:01:46.029]    - args: function (..., envir = parent.frame())
[16:01:46.029]    - tweaked: FALSE
[16:01:46.029]    - call: NULL
[16:01:46.030] plan(): nbrOfWorkers() = 1
[16:01:46.035] plan(): Setting new future strategy stack:
[16:01:46.035] List of future strategies:
[16:01:46.035] 1. sequential:
[16:01:46.035]    - args: function (..., envir = parent.frame())
[16:01:46.035]    - tweaked: FALSE
[16:01:46.035]    - call: plan(strategy)
[16:01:46.035] plan(): nbrOfWorkers() = 1
[16:01:46.035] SequentialFuture started (and completed)
[16:01:46.035] - Launch lazy future ... done
[16:01:46.036] run() for ‘SequentialFuture’ ... done
[16:01:46.036] Created future:
[16:01:46.036] SequentialFuture:
[16:01:46.036] Label: ‘future_by-1’
[16:01:46.036] Expression:
[16:01:46.036] {
[16:01:46.036]     do.call(function(...) {
[16:01:46.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.036]             on.exit(options(oopts), add = TRUE)
[16:01:46.036]         }
[16:01:46.036]         {
[16:01:46.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.036]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.036]             })
[16:01:46.036]         }
[16:01:46.036]     }, args = future.call.arguments)
[16:01:46.036] }
[16:01:46.036] Lazy evaluation: FALSE
[16:01:46.036] Asynchronous evaluation: FALSE
[16:01:46.036] Local evaluation: TRUE
[16:01:46.036] Environment: 0x55b52421ac18
[16:01:46.036] Capture standard output: TRUE
[16:01:46.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.036] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.036] Packages: <none>
[16:01:46.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.036] Resolved: TRUE
[16:01:46.036] Value: 5.37 KiB of class ‘list’
[16:01:46.036] Early signaling: FALSE
[16:01:46.036] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.036] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:46.037] Chunk #1 of 1 ... DONE
[16:01:46.038] Launching 1 futures (chunks) ... DONE
[16:01:46.038] Resolving 1 futures (chunks) ...
[16:01:46.038] resolve() on list ...
[16:01:46.038]  recursive: 0
[16:01:46.038]  length: 1
[16:01:46.038] 
[16:01:46.038] resolved() for ‘SequentialFuture’ ...
[16:01:46.038] - state: ‘finished’
[16:01:46.038] - run: TRUE
[16:01:46.039] - result: ‘FutureResult’
[16:01:46.039] resolved() for ‘SequentialFuture’ ... done
[16:01:46.039] Future #1
[16:01:46.039] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:46.039] - nx: 1
[16:01:46.039] - relay: TRUE
[16:01:46.039] - stdout: TRUE
[16:01:46.039] - signal: TRUE
[16:01:46.039] - resignal: FALSE
[16:01:46.039] - force: TRUE
[16:01:46.040] - relayed: [n=1] FALSE
[16:01:46.040] - queued futures: [n=1] FALSE
[16:01:46.040]  - until=1
[16:01:46.040]  - relaying element #1
[16:01:46.040] - relayed: [n=1] TRUE
[16:01:46.040] - queued futures: [n=1] TRUE
[16:01:46.040] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:46.040]  length: 0 (resolved future 1)
[16:01:46.040] Relaying remaining futures
[16:01:46.040] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.041] - nx: 1
[16:01:46.041] - relay: TRUE
[16:01:46.041] - stdout: TRUE
[16:01:46.041] - signal: TRUE
[16:01:46.041] - resignal: FALSE
[16:01:46.041] - force: TRUE
[16:01:46.041] - relayed: [n=1] TRUE
[16:01:46.041] - queued futures: [n=1] TRUE
 - flush all
[16:01:46.041] - relayed: [n=1] TRUE
[16:01:46.041] - queued futures: [n=1] TRUE
[16:01:46.042] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.042] resolve() on list ... DONE
[16:01:46.042]  - Number of value chunks collected: 1
[16:01:46.042] Resolving 1 futures (chunks) ... DONE
[16:01:46.042] Reducing values from 1 chunks ...
[16:01:46.042]  - Number of values collected after concatenation: 3
[16:01:46.042]  - Number of values expected: 3
[16:01:46.042] Reducing values from 1 chunks ... DONE
[16:01:46.042] future_lapply() ... DONE
[16:01:46.042] future_by_internal() ... DONE
[16:01:46.043] future_by_internal() ...
- plan('multicore') ...
[16:01:46.044] plan(): Setting new future strategy stack:
[16:01:46.044] List of future strategies:
[16:01:46.044] 1. multicore:
[16:01:46.044]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.044]    - tweaked: FALSE
[16:01:46.044]    - call: plan(strategy)
[16:01:46.048] plan(): nbrOfWorkers() = 2
[16:01:46.048] future_by_internal() ...
[16:01:46.049] future_lapply() ...
[16:01:46.053] Number of chunks: 2
[16:01:46.053] getGlobalsAndPackagesXApply() ...
[16:01:46.053]  - future.globals: TRUE
[16:01:46.054] getGlobalsAndPackages() ...
[16:01:46.054] Searching for globals...
[16:01:46.055] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:46.055] Searching for globals ... DONE
[16:01:46.055] Resolving globals: FALSE
[16:01:46.055] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:46.056] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:46.056] - globals: [1] ‘FUN’
[16:01:46.056] 
[16:01:46.056] getGlobalsAndPackages() ... DONE
[16:01:46.056]  - globals found/used: [n=1] ‘FUN’
[16:01:46.056]  - needed namespaces: [n=0] 
[16:01:46.056] Finding globals ... DONE
[16:01:46.056]  - use_args: TRUE
[16:01:46.056]  - Getting '...' globals ...
[16:01:46.057] resolve() on list ...
[16:01:46.057]  recursive: 0
[16:01:46.057]  length: 1
[16:01:46.057]  elements: ‘...’
[16:01:46.057]  length: 0 (resolved future 1)
[16:01:46.057] resolve() on list ... DONE
[16:01:46.057]    - '...' content: [n=0] 
[16:01:46.057] List of 1
[16:01:46.057]  $ ...: list()
[16:01:46.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.057]  - attr(*, "where")=List of 1
[16:01:46.057]   ..$ ...:<environment: 0x55b5259934c0> 
[16:01:46.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.057]  - attr(*, "resolved")= logi TRUE
[16:01:46.057]  - attr(*, "total_size")= num NA
[16:01:46.063]  - Getting '...' globals ... DONE
[16:01:46.063] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:46.063] List of 2
[16:01:46.063]  $ ...future.FUN:function (object, ...)  
[16:01:46.063]  $ ...          : list()
[16:01:46.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.063]  - attr(*, "where")=List of 2
[16:01:46.063]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.063]   ..$ ...          :<environment: 0x55b5259934c0> 
[16:01:46.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.063]  - attr(*, "resolved")= logi FALSE
[16:01:46.063]  - attr(*, "total_size")= num 1240
[16:01:46.066] Packages to be attached in all futures: [n=0] 
[16:01:46.066] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.067] Number of futures (= number of chunks): 2
[16:01:46.067] Launching 2 futures (chunks) ...
[16:01:46.067] Chunk #1 of 2 ...
[16:01:46.067]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.067] getGlobalsAndPackages() ...
[16:01:46.067] Searching for globals...
[16:01:46.068] 
[16:01:46.068] Searching for globals ... DONE
[16:01:46.068] - globals: [0] <none>
[16:01:46.068] getGlobalsAndPackages() ... DONE
[16:01:46.068]    + additional globals found: [n=0] 
[16:01:46.068]    + additional namespaces needed: [n=0] 
[16:01:46.068]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.068]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.068]  - seeds: <none>
[16:01:46.068]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.068] getGlobalsAndPackages() ...
[16:01:46.069] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.069] Resolving globals: FALSE
[16:01:46.069] Tweak future expression to call with '...' arguments ...
[16:01:46.069] {
[16:01:46.069]     do.call(function(...) {
[16:01:46.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.069]             on.exit(options(oopts), add = TRUE)
[16:01:46.069]         }
[16:01:46.069]         {
[16:01:46.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.069]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.069]             })
[16:01:46.069]         }
[16:01:46.069]     }, args = future.call.arguments)
[16:01:46.069] }
[16:01:46.069] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.070] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.070] 
[16:01:46.070] getGlobalsAndPackages() ... DONE
[16:01:46.070] run() for ‘Future’ ...
[16:01:46.070] - state: ‘created’
[16:01:46.070] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.074] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.074]   - Field: ‘label’
[16:01:46.075]   - Field: ‘local’
[16:01:46.075]   - Field: ‘owner’
[16:01:46.075]   - Field: ‘envir’
[16:01:46.075]   - Field: ‘workers’
[16:01:46.075]   - Field: ‘packages’
[16:01:46.075]   - Field: ‘gc’
[16:01:46.075]   - Field: ‘job’
[16:01:46.075]   - Field: ‘conditions’
[16:01:46.075]   - Field: ‘expr’
[16:01:46.076]   - Field: ‘uuid’
[16:01:46.076]   - Field: ‘seed’
[16:01:46.076]   - Field: ‘version’
[16:01:46.076]   - Field: ‘result’
[16:01:46.076]   - Field: ‘asynchronous’
[16:01:46.076]   - Field: ‘calls’
[16:01:46.076]   - Field: ‘globals’
[16:01:46.076]   - Field: ‘stdout’
[16:01:46.076]   - Field: ‘earlySignal’
[16:01:46.076]   - Field: ‘lazy’
[16:01:46.076]   - Field: ‘state’
[16:01:46.077] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.077] - Launch lazy future ...
[16:01:46.078] Packages needed by the future expression (n = 0): <none>
[16:01:46.078] Packages needed by future strategies (n = 0): <none>
[16:01:46.078] {
[16:01:46.078]     {
[16:01:46.078]         {
[16:01:46.078]             ...future.startTime <- base::Sys.time()
[16:01:46.078]             {
[16:01:46.078]                 {
[16:01:46.078]                   {
[16:01:46.078]                     {
[16:01:46.078]                       base::local({
[16:01:46.078]                         has_future <- base::requireNamespace("future", 
[16:01:46.078]                           quietly = TRUE)
[16:01:46.078]                         if (has_future) {
[16:01:46.078]                           ns <- base::getNamespace("future")
[16:01:46.078]                           version <- ns[[".package"]][["version"]]
[16:01:46.078]                           if (is.null(version)) 
[16:01:46.078]                             version <- utils::packageVersion("future")
[16:01:46.078]                         }
[16:01:46.078]                         else {
[16:01:46.078]                           version <- NULL
[16:01:46.078]                         }
[16:01:46.078]                         if (!has_future || version < "1.8.0") {
[16:01:46.078]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.078]                             "", base::R.version$version.string), 
[16:01:46.078]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.078]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.078]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.078]                               "release", "version")], collapse = " "), 
[16:01:46.078]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.078]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.078]                             info)
[16:01:46.078]                           info <- base::paste(info, collapse = "; ")
[16:01:46.078]                           if (!has_future) {
[16:01:46.078]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.078]                               info)
[16:01:46.078]                           }
[16:01:46.078]                           else {
[16:01:46.078]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.078]                               info, version)
[16:01:46.078]                           }
[16:01:46.078]                           base::stop(msg)
[16:01:46.078]                         }
[16:01:46.078]                       })
[16:01:46.078]                     }
[16:01:46.078]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.078]                     base::options(mc.cores = 1L)
[16:01:46.078]                   }
[16:01:46.078]                   options(future.plan = NULL)
[16:01:46.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.078]                 }
[16:01:46.078]                 ...future.workdir <- getwd()
[16:01:46.078]             }
[16:01:46.078]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.078]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.078]         }
[16:01:46.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.078]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.078]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.078]             base::names(...future.oldOptions))
[16:01:46.078]     }
[16:01:46.078]     if (FALSE) {
[16:01:46.078]     }
[16:01:46.078]     else {
[16:01:46.078]         if (TRUE) {
[16:01:46.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.078]                 open = "w")
[16:01:46.078]         }
[16:01:46.078]         else {
[16:01:46.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.078]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.078]         }
[16:01:46.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.078]             base::sink(type = "output", split = FALSE)
[16:01:46.078]             base::close(...future.stdout)
[16:01:46.078]         }, add = TRUE)
[16:01:46.078]     }
[16:01:46.078]     ...future.frame <- base::sys.nframe()
[16:01:46.078]     ...future.conditions <- base::list()
[16:01:46.078]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.078]     if (FALSE) {
[16:01:46.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.078]     }
[16:01:46.078]     ...future.result <- base::tryCatch({
[16:01:46.078]         base::withCallingHandlers({
[16:01:46.078]             ...future.value <- base::withVisible(base::local({
[16:01:46.078]                 withCallingHandlers({
[16:01:46.078]                   {
[16:01:46.078]                     do.call(function(...) {
[16:01:46.078]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.078]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.078]                         ...future.globals.maxSize)) {
[16:01:46.078]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.078]                         on.exit(options(oopts), add = TRUE)
[16:01:46.078]                       }
[16:01:46.078]                       {
[16:01:46.078]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.078]                           FUN = function(jj) {
[16:01:46.078]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.078]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.078]                           })
[16:01:46.078]                       }
[16:01:46.078]                     }, args = future.call.arguments)
[16:01:46.078]                   }
[16:01:46.078]                 }, immediateCondition = function(cond) {
[16:01:46.078]                   save_rds <- function (object, pathname, ...) 
[16:01:46.078]                   {
[16:01:46.078]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.078]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.078]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.078]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.078]                         fi_tmp[["mtime"]])
[16:01:46.078]                     }
[16:01:46.078]                     tryCatch({
[16:01:46.078]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.078]                     }, error = function(ex) {
[16:01:46.078]                       msg <- conditionMessage(ex)
[16:01:46.078]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.078]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.078]                         fi_tmp[["mtime"]], msg)
[16:01:46.078]                       ex$message <- msg
[16:01:46.078]                       stop(ex)
[16:01:46.078]                     })
[16:01:46.078]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.078]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.078]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.078]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.078]                       fi <- file.info(pathname)
[16:01:46.078]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.078]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.078]                         fi[["size"]], fi[["mtime"]])
[16:01:46.078]                       stop(msg)
[16:01:46.078]                     }
[16:01:46.078]                     invisible(pathname)
[16:01:46.078]                   }
[16:01:46.078]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.078]                     rootPath = tempdir()) 
[16:01:46.078]                   {
[16:01:46.078]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.078]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.078]                       tmpdir = path, fileext = ".rds")
[16:01:46.078]                     save_rds(obj, file)
[16:01:46.078]                   }
[16:01:46.078]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.078]                   {
[16:01:46.078]                     inherits <- base::inherits
[16:01:46.078]                     invokeRestart <- base::invokeRestart
[16:01:46.078]                     is.null <- base::is.null
[16:01:46.078]                     muffled <- FALSE
[16:01:46.078]                     if (inherits(cond, "message")) {
[16:01:46.078]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.078]                       if (muffled) 
[16:01:46.078]                         invokeRestart("muffleMessage")
[16:01:46.078]                     }
[16:01:46.078]                     else if (inherits(cond, "warning")) {
[16:01:46.078]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.078]                       if (muffled) 
[16:01:46.078]                         invokeRestart("muffleWarning")
[16:01:46.078]                     }
[16:01:46.078]                     else if (inherits(cond, "condition")) {
[16:01:46.078]                       if (!is.null(pattern)) {
[16:01:46.078]                         computeRestarts <- base::computeRestarts
[16:01:46.078]                         grepl <- base::grepl
[16:01:46.078]                         restarts <- computeRestarts(cond)
[16:01:46.078]                         for (restart in restarts) {
[16:01:46.078]                           name <- restart$name
[16:01:46.078]                           if (is.null(name)) 
[16:01:46.078]                             next
[16:01:46.078]                           if (!grepl(pattern, name)) 
[16:01:46.078]                             next
[16:01:46.078]                           invokeRestart(restart)
[16:01:46.078]                           muffled <- TRUE
[16:01:46.078]                           break
[16:01:46.078]                         }
[16:01:46.078]                       }
[16:01:46.078]                     }
[16:01:46.078]                     invisible(muffled)
[16:01:46.078]                   }
[16:01:46.078]                   muffleCondition(cond)
[16:01:46.078]                 })
[16:01:46.078]             }))
[16:01:46.078]             future::FutureResult(value = ...future.value$value, 
[16:01:46.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.078]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.078]                     ...future.globalenv.names))
[16:01:46.078]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.078]         }, condition = base::local({
[16:01:46.078]             c <- base::c
[16:01:46.078]             inherits <- base::inherits
[16:01:46.078]             invokeRestart <- base::invokeRestart
[16:01:46.078]             length <- base::length
[16:01:46.078]             list <- base::list
[16:01:46.078]             seq.int <- base::seq.int
[16:01:46.078]             signalCondition <- base::signalCondition
[16:01:46.078]             sys.calls <- base::sys.calls
[16:01:46.078]             `[[` <- base::`[[`
[16:01:46.078]             `+` <- base::`+`
[16:01:46.078]             `<<-` <- base::`<<-`
[16:01:46.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.078]                   3L)]
[16:01:46.078]             }
[16:01:46.078]             function(cond) {
[16:01:46.078]                 is_error <- inherits(cond, "error")
[16:01:46.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.078]                   NULL)
[16:01:46.078]                 if (is_error) {
[16:01:46.078]                   sessionInformation <- function() {
[16:01:46.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.078]                       search = base::search(), system = base::Sys.info())
[16:01:46.078]                   }
[16:01:46.078]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.078]                     cond$call), session = sessionInformation(), 
[16:01:46.078]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.078]                   signalCondition(cond)
[16:01:46.078]                 }
[16:01:46.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.078]                 "immediateCondition"))) {
[16:01:46.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.078]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.078]                   if (TRUE && !signal) {
[16:01:46.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.078]                     {
[16:01:46.078]                       inherits <- base::inherits
[16:01:46.078]                       invokeRestart <- base::invokeRestart
[16:01:46.078]                       is.null <- base::is.null
[16:01:46.078]                       muffled <- FALSE
[16:01:46.078]                       if (inherits(cond, "message")) {
[16:01:46.078]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.078]                         if (muffled) 
[16:01:46.078]                           invokeRestart("muffleMessage")
[16:01:46.078]                       }
[16:01:46.078]                       else if (inherits(cond, "warning")) {
[16:01:46.078]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.078]                         if (muffled) 
[16:01:46.078]                           invokeRestart("muffleWarning")
[16:01:46.078]                       }
[16:01:46.078]                       else if (inherits(cond, "condition")) {
[16:01:46.078]                         if (!is.null(pattern)) {
[16:01:46.078]                           computeRestarts <- base::computeRestarts
[16:01:46.078]                           grepl <- base::grepl
[16:01:46.078]                           restarts <- computeRestarts(cond)
[16:01:46.078]                           for (restart in restarts) {
[16:01:46.078]                             name <- restart$name
[16:01:46.078]                             if (is.null(name)) 
[16:01:46.078]                               next
[16:01:46.078]                             if (!grepl(pattern, name)) 
[16:01:46.078]                               next
[16:01:46.078]                             invokeRestart(restart)
[16:01:46.078]                             muffled <- TRUE
[16:01:46.078]                             break
[16:01:46.078]                           }
[16:01:46.078]                         }
[16:01:46.078]                       }
[16:01:46.078]                       invisible(muffled)
[16:01:46.078]                     }
[16:01:46.078]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.078]                   }
[16:01:46.078]                 }
[16:01:46.078]                 else {
[16:01:46.078]                   if (TRUE) {
[16:01:46.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.078]                     {
[16:01:46.078]                       inherits <- base::inherits
[16:01:46.078]                       invokeRestart <- base::invokeRestart
[16:01:46.078]                       is.null <- base::is.null
[16:01:46.078]                       muffled <- FALSE
[16:01:46.078]                       if (inherits(cond, "message")) {
[16:01:46.078]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.078]                         if (muffled) 
[16:01:46.078]                           invokeRestart("muffleMessage")
[16:01:46.078]                       }
[16:01:46.078]                       else if (inherits(cond, "warning")) {
[16:01:46.078]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.078]                         if (muffled) 
[16:01:46.078]                           invokeRestart("muffleWarning")
[16:01:46.078]                       }
[16:01:46.078]                       else if (inherits(cond, "condition")) {
[16:01:46.078]                         if (!is.null(pattern)) {
[16:01:46.078]                           computeRestarts <- base::computeRestarts
[16:01:46.078]                           grepl <- base::grepl
[16:01:46.078]                           restarts <- computeRestarts(cond)
[16:01:46.078]                           for (restart in restarts) {
[16:01:46.078]                             name <- restart$name
[16:01:46.078]                             if (is.null(name)) 
[16:01:46.078]                               next
[16:01:46.078]                             if (!grepl(pattern, name)) 
[16:01:46.078]                               next
[16:01:46.078]                             invokeRestart(restart)
[16:01:46.078]                             muffled <- TRUE
[16:01:46.078]                             break
[16:01:46.078]                           }
[16:01:46.078]                         }
[16:01:46.078]                       }
[16:01:46.078]                       invisible(muffled)
[16:01:46.078]                     }
[16:01:46.078]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.078]                   }
[16:01:46.078]                 }
[16:01:46.078]             }
[16:01:46.078]         }))
[16:01:46.078]     }, error = function(ex) {
[16:01:46.078]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.078]                 ...future.rng), started = ...future.startTime, 
[16:01:46.078]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.078]             version = "1.8"), class = "FutureResult")
[16:01:46.078]     }, finally = {
[16:01:46.078]         if (!identical(...future.workdir, getwd())) 
[16:01:46.078]             setwd(...future.workdir)
[16:01:46.078]         {
[16:01:46.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.078]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.078]             }
[16:01:46.078]             base::options(...future.oldOptions)
[16:01:46.078]             if (.Platform$OS.type == "windows") {
[16:01:46.078]                 old_names <- names(...future.oldEnvVars)
[16:01:46.078]                 envs <- base::Sys.getenv()
[16:01:46.078]                 names <- names(envs)
[16:01:46.078]                 common <- intersect(names, old_names)
[16:01:46.078]                 added <- setdiff(names, old_names)
[16:01:46.078]                 removed <- setdiff(old_names, names)
[16:01:46.078]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.078]                   envs[common]]
[16:01:46.078]                 NAMES <- toupper(changed)
[16:01:46.078]                 args <- list()
[16:01:46.078]                 for (kk in seq_along(NAMES)) {
[16:01:46.078]                   name <- changed[[kk]]
[16:01:46.078]                   NAME <- NAMES[[kk]]
[16:01:46.078]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.078]                     next
[16:01:46.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.078]                 }
[16:01:46.078]                 NAMES <- toupper(added)
[16:01:46.078]                 for (kk in seq_along(NAMES)) {
[16:01:46.078]                   name <- added[[kk]]
[16:01:46.078]                   NAME <- NAMES[[kk]]
[16:01:46.078]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.078]                     next
[16:01:46.078]                   args[[name]] <- ""
[16:01:46.078]                 }
[16:01:46.078]                 NAMES <- toupper(removed)
[16:01:46.078]                 for (kk in seq_along(NAMES)) {
[16:01:46.078]                   name <- removed[[kk]]
[16:01:46.078]                   NAME <- NAMES[[kk]]
[16:01:46.078]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.078]                     next
[16:01:46.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.078]                 }
[16:01:46.078]                 if (length(args) > 0) 
[16:01:46.078]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.078]             }
[16:01:46.078]             else {
[16:01:46.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.078]             }
[16:01:46.078]             {
[16:01:46.078]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.078]                   0L) {
[16:01:46.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.078]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.078]                   base::options(opts)
[16:01:46.078]                 }
[16:01:46.078]                 {
[16:01:46.078]                   {
[16:01:46.078]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.078]                     NULL
[16:01:46.078]                   }
[16:01:46.078]                   options(future.plan = NULL)
[16:01:46.078]                   if (is.na(NA_character_)) 
[16:01:46.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.078]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.078]                     envir = parent.frame()) 
[16:01:46.078]                   {
[16:01:46.078]                     default_workers <- missing(workers)
[16:01:46.078]                     if (is.function(workers)) 
[16:01:46.078]                       workers <- workers()
[16:01:46.078]                     workers <- structure(as.integer(workers), 
[16:01:46.078]                       class = class(workers))
[16:01:46.078]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.078]                       1L)
[16:01:46.078]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.078]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.078]                       if (default_workers) 
[16:01:46.078]                         supportsMulticore(warn = TRUE)
[16:01:46.078]                       return(sequential(..., envir = envir))
[16:01:46.078]                     }
[16:01:46.078]                     oopts <- options(mc.cores = workers)
[16:01:46.078]                     on.exit(options(oopts))
[16:01:46.078]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.078]                       envir = envir)
[16:01:46.078]                     if (!future$lazy) 
[16:01:46.078]                       future <- run(future)
[16:01:46.078]                     invisible(future)
[16:01:46.078]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.078]                 }
[16:01:46.078]             }
[16:01:46.078]         }
[16:01:46.078]     })
[16:01:46.078]     if (TRUE) {
[16:01:46.078]         base::sink(type = "output", split = FALSE)
[16:01:46.078]         if (TRUE) {
[16:01:46.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.078]         }
[16:01:46.078]         else {
[16:01:46.078]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.078]         }
[16:01:46.078]         base::close(...future.stdout)
[16:01:46.078]         ...future.stdout <- NULL
[16:01:46.078]     }
[16:01:46.078]     ...future.result$conditions <- ...future.conditions
[16:01:46.078]     ...future.result$finished <- base::Sys.time()
[16:01:46.078]     ...future.result
[16:01:46.078] }
[16:01:46.081] assign_globals() ...
[16:01:46.081] List of 5
[16:01:46.081]  $ ...future.FUN            :function (object, ...)  
[16:01:46.081]  $ future.call.arguments    : list()
[16:01:46.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.081]  $ ...future.elements_ii    :List of 1
[16:01:46.081]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:46.081]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:46.081]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.081]  $ ...future.seeds_ii       : NULL
[16:01:46.081]  $ ...future.globals.maxSize: NULL
[16:01:46.081]  - attr(*, "where")=List of 5
[16:01:46.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.081]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.081]  - attr(*, "resolved")= logi FALSE
[16:01:46.081]  - attr(*, "total_size")= num 1240
[16:01:46.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.081]  - attr(*, "already-done")= logi TRUE
[16:01:46.089] - copied ‘...future.FUN’ to environment
[16:01:46.089] - copied ‘future.call.arguments’ to environment
[16:01:46.089] - copied ‘...future.elements_ii’ to environment
[16:01:46.090] - copied ‘...future.seeds_ii’ to environment
[16:01:46.090] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.090] assign_globals() ... done
[16:01:46.090] requestCore(): workers = 2
[16:01:46.093] MulticoreFuture started
[16:01:46.094] - Launch lazy future ... done
[16:01:46.094] plan(): Setting new future strategy stack:
[16:01:46.095] run() for ‘MulticoreFuture’ ... done
[16:01:46.096] Created future:
[16:01:46.095] List of future strategies:
[16:01:46.095] 1. sequential:
[16:01:46.095]    - args: function (..., envir = parent.frame())
[16:01:46.095]    - tweaked: FALSE
[16:01:46.095]    - call: NULL
[16:01:46.096] plan(): nbrOfWorkers() = 1
[16:01:46.100] plan(): Setting new future strategy stack:
[16:01:46.100] List of future strategies:
[16:01:46.100] 1. multicore:
[16:01:46.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.100]    - tweaked: FALSE
[16:01:46.100]    - call: plan(strategy)
[16:01:46.106] plan(): nbrOfWorkers() = 2
[16:01:46.096] MulticoreFuture:
[16:01:46.096] Label: ‘future_by-1’
[16:01:46.096] Expression:
[16:01:46.096] {
[16:01:46.096]     do.call(function(...) {
[16:01:46.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.096]             on.exit(options(oopts), add = TRUE)
[16:01:46.096]         }
[16:01:46.096]         {
[16:01:46.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.096]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.096]             })
[16:01:46.096]         }
[16:01:46.096]     }, args = future.call.arguments)
[16:01:46.096] }
[16:01:46.096] Lazy evaluation: FALSE
[16:01:46.096] Asynchronous evaluation: TRUE
[16:01:46.096] Local evaluation: TRUE
[16:01:46.096] Environment: R_GlobalEnv
[16:01:46.096] Capture standard output: TRUE
[16:01:46.096] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.096] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.096] Packages: <none>
[16:01:46.096] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.096] Resolved: TRUE
[16:01:46.096] Value: <not collected>
[16:01:46.096] Conditions captured: <none>
[16:01:46.096] Early signaling: FALSE
[16:01:46.096] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.096] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.108] Chunk #1 of 2 ... DONE
[16:01:46.108] Chunk #2 of 2 ...
[16:01:46.108]  - Finding globals in 'X' for chunk #2 ...
[16:01:46.109] getGlobalsAndPackages() ...
[16:01:46.109] Searching for globals...
[16:01:46.110] 
[16:01:46.110] Searching for globals ... DONE
[16:01:46.110] - globals: [0] <none>
[16:01:46.110] getGlobalsAndPackages() ... DONE
[16:01:46.110]    + additional globals found: [n=0] 
[16:01:46.110]    + additional namespaces needed: [n=0] 
[16:01:46.111]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:46.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.111]  - seeds: <none>
[16:01:46.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.111] getGlobalsAndPackages() ...
[16:01:46.111] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.112] Resolving globals: FALSE
[16:01:46.112] Tweak future expression to call with '...' arguments ...
[16:01:46.112] {
[16:01:46.112]     do.call(function(...) {
[16:01:46.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.112]             on.exit(options(oopts), add = TRUE)
[16:01:46.112]         }
[16:01:46.112]         {
[16:01:46.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.112]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.112]             })
[16:01:46.112]         }
[16:01:46.112]     }, args = future.call.arguments)
[16:01:46.112] }
[16:01:46.112] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.113] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.113] 
[16:01:46.113] getGlobalsAndPackages() ... DONE
[16:01:46.114] run() for ‘Future’ ...
[16:01:46.114] - state: ‘created’
[16:01:46.114] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.119] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.120]   - Field: ‘label’
[16:01:46.120]   - Field: ‘local’
[16:01:46.120]   - Field: ‘owner’
[16:01:46.121]   - Field: ‘envir’
[16:01:46.121]   - Field: ‘workers’
[16:01:46.121]   - Field: ‘packages’
[16:01:46.121]   - Field: ‘gc’
[16:01:46.121]   - Field: ‘job’
[16:01:46.121]   - Field: ‘conditions’
[16:01:46.121]   - Field: ‘expr’
[16:01:46.122]   - Field: ‘uuid’
[16:01:46.122]   - Field: ‘seed’
[16:01:46.122]   - Field: ‘version’
[16:01:46.122]   - Field: ‘result’
[16:01:46.122]   - Field: ‘asynchronous’
[16:01:46.122]   - Field: ‘calls’
[16:01:46.122]   - Field: ‘globals’
[16:01:46.123]   - Field: ‘stdout’
[16:01:46.123]   - Field: ‘earlySignal’
[16:01:46.123]   - Field: ‘lazy’
[16:01:46.123]   - Field: ‘state’
[16:01:46.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.123] - Launch lazy future ...
[16:01:46.124] Packages needed by the future expression (n = 0): <none>
[16:01:46.124] Packages needed by future strategies (n = 0): <none>
[16:01:46.125] {
[16:01:46.125]     {
[16:01:46.125]         {
[16:01:46.125]             ...future.startTime <- base::Sys.time()
[16:01:46.125]             {
[16:01:46.125]                 {
[16:01:46.125]                   {
[16:01:46.125]                     {
[16:01:46.125]                       base::local({
[16:01:46.125]                         has_future <- base::requireNamespace("future", 
[16:01:46.125]                           quietly = TRUE)
[16:01:46.125]                         if (has_future) {
[16:01:46.125]                           ns <- base::getNamespace("future")
[16:01:46.125]                           version <- ns[[".package"]][["version"]]
[16:01:46.125]                           if (is.null(version)) 
[16:01:46.125]                             version <- utils::packageVersion("future")
[16:01:46.125]                         }
[16:01:46.125]                         else {
[16:01:46.125]                           version <- NULL
[16:01:46.125]                         }
[16:01:46.125]                         if (!has_future || version < "1.8.0") {
[16:01:46.125]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.125]                             "", base::R.version$version.string), 
[16:01:46.125]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.125]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.125]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.125]                               "release", "version")], collapse = " "), 
[16:01:46.125]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.125]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.125]                             info)
[16:01:46.125]                           info <- base::paste(info, collapse = "; ")
[16:01:46.125]                           if (!has_future) {
[16:01:46.125]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.125]                               info)
[16:01:46.125]                           }
[16:01:46.125]                           else {
[16:01:46.125]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.125]                               info, version)
[16:01:46.125]                           }
[16:01:46.125]                           base::stop(msg)
[16:01:46.125]                         }
[16:01:46.125]                       })
[16:01:46.125]                     }
[16:01:46.125]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.125]                     base::options(mc.cores = 1L)
[16:01:46.125]                   }
[16:01:46.125]                   options(future.plan = NULL)
[16:01:46.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.125]                 }
[16:01:46.125]                 ...future.workdir <- getwd()
[16:01:46.125]             }
[16:01:46.125]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.125]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.125]         }
[16:01:46.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.125]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.125]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.125]             base::names(...future.oldOptions))
[16:01:46.125]     }
[16:01:46.125]     if (FALSE) {
[16:01:46.125]     }
[16:01:46.125]     else {
[16:01:46.125]         if (TRUE) {
[16:01:46.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.125]                 open = "w")
[16:01:46.125]         }
[16:01:46.125]         else {
[16:01:46.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.125]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.125]         }
[16:01:46.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.125]             base::sink(type = "output", split = FALSE)
[16:01:46.125]             base::close(...future.stdout)
[16:01:46.125]         }, add = TRUE)
[16:01:46.125]     }
[16:01:46.125]     ...future.frame <- base::sys.nframe()
[16:01:46.125]     ...future.conditions <- base::list()
[16:01:46.125]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.125]     if (FALSE) {
[16:01:46.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.125]     }
[16:01:46.125]     ...future.result <- base::tryCatch({
[16:01:46.125]         base::withCallingHandlers({
[16:01:46.125]             ...future.value <- base::withVisible(base::local({
[16:01:46.125]                 withCallingHandlers({
[16:01:46.125]                   {
[16:01:46.125]                     do.call(function(...) {
[16:01:46.125]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.125]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.125]                         ...future.globals.maxSize)) {
[16:01:46.125]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.125]                         on.exit(options(oopts), add = TRUE)
[16:01:46.125]                       }
[16:01:46.125]                       {
[16:01:46.125]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.125]                           FUN = function(jj) {
[16:01:46.125]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.125]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.125]                           })
[16:01:46.125]                       }
[16:01:46.125]                     }, args = future.call.arguments)
[16:01:46.125]                   }
[16:01:46.125]                 }, immediateCondition = function(cond) {
[16:01:46.125]                   save_rds <- function (object, pathname, ...) 
[16:01:46.125]                   {
[16:01:46.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.125]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.125]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.125]                         fi_tmp[["mtime"]])
[16:01:46.125]                     }
[16:01:46.125]                     tryCatch({
[16:01:46.125]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.125]                     }, error = function(ex) {
[16:01:46.125]                       msg <- conditionMessage(ex)
[16:01:46.125]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.125]                         fi_tmp[["mtime"]], msg)
[16:01:46.125]                       ex$message <- msg
[16:01:46.125]                       stop(ex)
[16:01:46.125]                     })
[16:01:46.125]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.125]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.125]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.125]                       fi <- file.info(pathname)
[16:01:46.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.125]                         fi[["size"]], fi[["mtime"]])
[16:01:46.125]                       stop(msg)
[16:01:46.125]                     }
[16:01:46.125]                     invisible(pathname)
[16:01:46.125]                   }
[16:01:46.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.125]                     rootPath = tempdir()) 
[16:01:46.125]                   {
[16:01:46.125]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.125]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.125]                       tmpdir = path, fileext = ".rds")
[16:01:46.125]                     save_rds(obj, file)
[16:01:46.125]                   }
[16:01:46.125]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.125]                   {
[16:01:46.125]                     inherits <- base::inherits
[16:01:46.125]                     invokeRestart <- base::invokeRestart
[16:01:46.125]                     is.null <- base::is.null
[16:01:46.125]                     muffled <- FALSE
[16:01:46.125]                     if (inherits(cond, "message")) {
[16:01:46.125]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.125]                       if (muffled) 
[16:01:46.125]                         invokeRestart("muffleMessage")
[16:01:46.125]                     }
[16:01:46.125]                     else if (inherits(cond, "warning")) {
[16:01:46.125]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.125]                       if (muffled) 
[16:01:46.125]                         invokeRestart("muffleWarning")
[16:01:46.125]                     }
[16:01:46.125]                     else if (inherits(cond, "condition")) {
[16:01:46.125]                       if (!is.null(pattern)) {
[16:01:46.125]                         computeRestarts <- base::computeRestarts
[16:01:46.125]                         grepl <- base::grepl
[16:01:46.125]                         restarts <- computeRestarts(cond)
[16:01:46.125]                         for (restart in restarts) {
[16:01:46.125]                           name <- restart$name
[16:01:46.125]                           if (is.null(name)) 
[16:01:46.125]                             next
[16:01:46.125]                           if (!grepl(pattern, name)) 
[16:01:46.125]                             next
[16:01:46.125]                           invokeRestart(restart)
[16:01:46.125]                           muffled <- TRUE
[16:01:46.125]                           break
[16:01:46.125]                         }
[16:01:46.125]                       }
[16:01:46.125]                     }
[16:01:46.125]                     invisible(muffled)
[16:01:46.125]                   }
[16:01:46.125]                   muffleCondition(cond)
[16:01:46.125]                 })
[16:01:46.125]             }))
[16:01:46.125]             future::FutureResult(value = ...future.value$value, 
[16:01:46.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.125]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.125]                     ...future.globalenv.names))
[16:01:46.125]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.125]         }, condition = base::local({
[16:01:46.125]             c <- base::c
[16:01:46.125]             inherits <- base::inherits
[16:01:46.125]             invokeRestart <- base::invokeRestart
[16:01:46.125]             length <- base::length
[16:01:46.125]             list <- base::list
[16:01:46.125]             seq.int <- base::seq.int
[16:01:46.125]             signalCondition <- base::signalCondition
[16:01:46.125]             sys.calls <- base::sys.calls
[16:01:46.125]             `[[` <- base::`[[`
[16:01:46.125]             `+` <- base::`+`
[16:01:46.125]             `<<-` <- base::`<<-`
[16:01:46.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.125]                   3L)]
[16:01:46.125]             }
[16:01:46.125]             function(cond) {
[16:01:46.125]                 is_error <- inherits(cond, "error")
[16:01:46.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.125]                   NULL)
[16:01:46.125]                 if (is_error) {
[16:01:46.125]                   sessionInformation <- function() {
[16:01:46.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.125]                       search = base::search(), system = base::Sys.info())
[16:01:46.125]                   }
[16:01:46.125]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.125]                     cond$call), session = sessionInformation(), 
[16:01:46.125]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.125]                   signalCondition(cond)
[16:01:46.125]                 }
[16:01:46.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.125]                 "immediateCondition"))) {
[16:01:46.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.125]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.125]                   if (TRUE && !signal) {
[16:01:46.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.125]                     {
[16:01:46.125]                       inherits <- base::inherits
[16:01:46.125]                       invokeRestart <- base::invokeRestart
[16:01:46.125]                       is.null <- base::is.null
[16:01:46.125]                       muffled <- FALSE
[16:01:46.125]                       if (inherits(cond, "message")) {
[16:01:46.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.125]                         if (muffled) 
[16:01:46.125]                           invokeRestart("muffleMessage")
[16:01:46.125]                       }
[16:01:46.125]                       else if (inherits(cond, "warning")) {
[16:01:46.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.125]                         if (muffled) 
[16:01:46.125]                           invokeRestart("muffleWarning")
[16:01:46.125]                       }
[16:01:46.125]                       else if (inherits(cond, "condition")) {
[16:01:46.125]                         if (!is.null(pattern)) {
[16:01:46.125]                           computeRestarts <- base::computeRestarts
[16:01:46.125]                           grepl <- base::grepl
[16:01:46.125]                           restarts <- computeRestarts(cond)
[16:01:46.125]                           for (restart in restarts) {
[16:01:46.125]                             name <- restart$name
[16:01:46.125]                             if (is.null(name)) 
[16:01:46.125]                               next
[16:01:46.125]                             if (!grepl(pattern, name)) 
[16:01:46.125]                               next
[16:01:46.125]                             invokeRestart(restart)
[16:01:46.125]                             muffled <- TRUE
[16:01:46.125]                             break
[16:01:46.125]                           }
[16:01:46.125]                         }
[16:01:46.125]                       }
[16:01:46.125]                       invisible(muffled)
[16:01:46.125]                     }
[16:01:46.125]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.125]                   }
[16:01:46.125]                 }
[16:01:46.125]                 else {
[16:01:46.125]                   if (TRUE) {
[16:01:46.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.125]                     {
[16:01:46.125]                       inherits <- base::inherits
[16:01:46.125]                       invokeRestart <- base::invokeRestart
[16:01:46.125]                       is.null <- base::is.null
[16:01:46.125]                       muffled <- FALSE
[16:01:46.125]                       if (inherits(cond, "message")) {
[16:01:46.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.125]                         if (muffled) 
[16:01:46.125]                           invokeRestart("muffleMessage")
[16:01:46.125]                       }
[16:01:46.125]                       else if (inherits(cond, "warning")) {
[16:01:46.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.125]                         if (muffled) 
[16:01:46.125]                           invokeRestart("muffleWarning")
[16:01:46.125]                       }
[16:01:46.125]                       else if (inherits(cond, "condition")) {
[16:01:46.125]                         if (!is.null(pattern)) {
[16:01:46.125]                           computeRestarts <- base::computeRestarts
[16:01:46.125]                           grepl <- base::grepl
[16:01:46.125]                           restarts <- computeRestarts(cond)
[16:01:46.125]                           for (restart in restarts) {
[16:01:46.125]                             name <- restart$name
[16:01:46.125]                             if (is.null(name)) 
[16:01:46.125]                               next
[16:01:46.125]                             if (!grepl(pattern, name)) 
[16:01:46.125]                               next
[16:01:46.125]                             invokeRestart(restart)
[16:01:46.125]                             muffled <- TRUE
[16:01:46.125]                             break
[16:01:46.125]                           }
[16:01:46.125]                         }
[16:01:46.125]                       }
[16:01:46.125]                       invisible(muffled)
[16:01:46.125]                     }
[16:01:46.125]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.125]                   }
[16:01:46.125]                 }
[16:01:46.125]             }
[16:01:46.125]         }))
[16:01:46.125]     }, error = function(ex) {
[16:01:46.125]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.125]                 ...future.rng), started = ...future.startTime, 
[16:01:46.125]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.125]             version = "1.8"), class = "FutureResult")
[16:01:46.125]     }, finally = {
[16:01:46.125]         if (!identical(...future.workdir, getwd())) 
[16:01:46.125]             setwd(...future.workdir)
[16:01:46.125]         {
[16:01:46.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.125]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.125]             }
[16:01:46.125]             base::options(...future.oldOptions)
[16:01:46.125]             if (.Platform$OS.type == "windows") {
[16:01:46.125]                 old_names <- names(...future.oldEnvVars)
[16:01:46.125]                 envs <- base::Sys.getenv()
[16:01:46.125]                 names <- names(envs)
[16:01:46.125]                 common <- intersect(names, old_names)
[16:01:46.125]                 added <- setdiff(names, old_names)
[16:01:46.125]                 removed <- setdiff(old_names, names)
[16:01:46.125]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.125]                   envs[common]]
[16:01:46.125]                 NAMES <- toupper(changed)
[16:01:46.125]                 args <- list()
[16:01:46.125]                 for (kk in seq_along(NAMES)) {
[16:01:46.125]                   name <- changed[[kk]]
[16:01:46.125]                   NAME <- NAMES[[kk]]
[16:01:46.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.125]                     next
[16:01:46.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.125]                 }
[16:01:46.125]                 NAMES <- toupper(added)
[16:01:46.125]                 for (kk in seq_along(NAMES)) {
[16:01:46.125]                   name <- added[[kk]]
[16:01:46.125]                   NAME <- NAMES[[kk]]
[16:01:46.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.125]                     next
[16:01:46.125]                   args[[name]] <- ""
[16:01:46.125]                 }
[16:01:46.125]                 NAMES <- toupper(removed)
[16:01:46.125]                 for (kk in seq_along(NAMES)) {
[16:01:46.125]                   name <- removed[[kk]]
[16:01:46.125]                   NAME <- NAMES[[kk]]
[16:01:46.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.125]                     next
[16:01:46.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.125]                 }
[16:01:46.125]                 if (length(args) > 0) 
[16:01:46.125]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.125]             }
[16:01:46.125]             else {
[16:01:46.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.125]             }
[16:01:46.125]             {
[16:01:46.125]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.125]                   0L) {
[16:01:46.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.125]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.125]                   base::options(opts)
[16:01:46.125]                 }
[16:01:46.125]                 {
[16:01:46.125]                   {
[16:01:46.125]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.125]                     NULL
[16:01:46.125]                   }
[16:01:46.125]                   options(future.plan = NULL)
[16:01:46.125]                   if (is.na(NA_character_)) 
[16:01:46.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.125]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.125]                     envir = parent.frame()) 
[16:01:46.125]                   {
[16:01:46.125]                     default_workers <- missing(workers)
[16:01:46.125]                     if (is.function(workers)) 
[16:01:46.125]                       workers <- workers()
[16:01:46.125]                     workers <- structure(as.integer(workers), 
[16:01:46.125]                       class = class(workers))
[16:01:46.125]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.125]                       1L)
[16:01:46.125]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.125]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.125]                       if (default_workers) 
[16:01:46.125]                         supportsMulticore(warn = TRUE)
[16:01:46.125]                       return(sequential(..., envir = envir))
[16:01:46.125]                     }
[16:01:46.125]                     oopts <- options(mc.cores = workers)
[16:01:46.125]                     on.exit(options(oopts))
[16:01:46.125]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.125]                       envir = envir)
[16:01:46.125]                     if (!future$lazy) 
[16:01:46.125]                       future <- run(future)
[16:01:46.125]                     invisible(future)
[16:01:46.125]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.125]                 }
[16:01:46.125]             }
[16:01:46.125]         }
[16:01:46.125]     })
[16:01:46.125]     if (TRUE) {
[16:01:46.125]         base::sink(type = "output", split = FALSE)
[16:01:46.125]         if (TRUE) {
[16:01:46.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.125]         }
[16:01:46.125]         else {
[16:01:46.125]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.125]         }
[16:01:46.125]         base::close(...future.stdout)
[16:01:46.125]         ...future.stdout <- NULL
[16:01:46.125]     }
[16:01:46.125]     ...future.result$conditions <- ...future.conditions
[16:01:46.125]     ...future.result$finished <- base::Sys.time()
[16:01:46.125]     ...future.result
[16:01:46.125] }
[16:01:46.128] assign_globals() ...
[16:01:46.128] List of 5
[16:01:46.128]  $ ...future.FUN            :function (object, ...)  
[16:01:46.128]  $ future.call.arguments    : list()
[16:01:46.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.128]  $ ...future.elements_ii    :List of 2
[16:01:46.128]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:46.128]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:46.128]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.128]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:01:46.128]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:46.128]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.128]  $ ...future.seeds_ii       : NULL
[16:01:46.128]  $ ...future.globals.maxSize: NULL
[16:01:46.128]  - attr(*, "where")=List of 5
[16:01:46.128]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.128]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.128]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.128]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.128]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.128]  - attr(*, "resolved")= logi FALSE
[16:01:46.128]  - attr(*, "total_size")= num 1240
[16:01:46.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.128]  - attr(*, "already-done")= logi TRUE
[16:01:46.141] - copied ‘...future.FUN’ to environment
[16:01:46.141] - copied ‘future.call.arguments’ to environment
[16:01:46.142] - copied ‘...future.elements_ii’ to environment
[16:01:46.142] - copied ‘...future.seeds_ii’ to environment
[16:01:46.142] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.142] assign_globals() ... done
[16:01:46.142] requestCore(): workers = 2
[16:01:46.147] MulticoreFuture started
[16:01:46.147] - Launch lazy future ... done
[16:01:46.148] run() for ‘MulticoreFuture’ ... done
[16:01:46.148] Created future:
[16:01:46.148] plan(): Setting new future strategy stack:
[16:01:46.149] List of future strategies:
[16:01:46.149] 1. sequential:
[16:01:46.149]    - args: function (..., envir = parent.frame())
[16:01:46.149]    - tweaked: FALSE
[16:01:46.149]    - call: NULL
[16:01:46.149] plan(): nbrOfWorkers() = 1
[16:01:46.153] plan(): Setting new future strategy stack:
[16:01:46.153] List of future strategies:
[16:01:46.153] 1. multicore:
[16:01:46.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.153]    - tweaked: FALSE
[16:01:46.153]    - call: plan(strategy)
[16:01:46.159] plan(): nbrOfWorkers() = 2
[16:01:46.148] MulticoreFuture:
[16:01:46.148] Label: ‘future_by-2’
[16:01:46.148] Expression:
[16:01:46.148] {
[16:01:46.148]     do.call(function(...) {
[16:01:46.148]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.148]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.148]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.148]             on.exit(options(oopts), add = TRUE)
[16:01:46.148]         }
[16:01:46.148]         {
[16:01:46.148]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.148]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.148]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.148]             })
[16:01:46.148]         }
[16:01:46.148]     }, args = future.call.arguments)
[16:01:46.148] }
[16:01:46.148] Lazy evaluation: FALSE
[16:01:46.148] Asynchronous evaluation: TRUE
[16:01:46.148] Local evaluation: TRUE
[16:01:46.148] Environment: R_GlobalEnv
[16:01:46.148] Capture standard output: TRUE
[16:01:46.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.148] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.148] Packages: <none>
[16:01:46.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.148] Resolved: TRUE
[16:01:46.148] Value: <not collected>
[16:01:46.148] Conditions captured: <none>
[16:01:46.148] Early signaling: FALSE
[16:01:46.148] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.148] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.160] Chunk #2 of 2 ... DONE
[16:01:46.160] Launching 2 futures (chunks) ... DONE
[16:01:46.160] Resolving 2 futures (chunks) ...
[16:01:46.160] resolve() on list ...
[16:01:46.160]  recursive: 0
[16:01:46.161]  length: 2
[16:01:46.161] 
[16:01:46.161] Future #1
[16:01:46.162] result() for MulticoreFuture ...
[16:01:46.164] result() for MulticoreFuture ...
[16:01:46.164] result() for MulticoreFuture ... done
[16:01:46.164] result() for MulticoreFuture ... done
[16:01:46.164] result() for MulticoreFuture ...
[16:01:46.164] result() for MulticoreFuture ... done
[16:01:46.164] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:46.165] - nx: 2
[16:01:46.165] - relay: TRUE
[16:01:46.165] - stdout: TRUE
[16:01:46.165] - signal: TRUE
[16:01:46.165] - resignal: FALSE
[16:01:46.165] - force: TRUE
[16:01:46.166] - relayed: [n=2] FALSE, FALSE
[16:01:46.166] - queued futures: [n=2] FALSE, FALSE
[16:01:46.166]  - until=1
[16:01:46.166]  - relaying element #1
[16:01:46.166] result() for MulticoreFuture ...
[16:01:46.166] result() for MulticoreFuture ... done
[16:01:46.167] result() for MulticoreFuture ...
[16:01:46.167] result() for MulticoreFuture ... done
[16:01:46.167] result() for MulticoreFuture ...
[16:01:46.167] result() for MulticoreFuture ... done
[16:01:46.167] result() for MulticoreFuture ...
[16:01:46.167] result() for MulticoreFuture ... done
[16:01:46.168] - relayed: [n=2] TRUE, FALSE
[16:01:46.168] - queued futures: [n=2] TRUE, FALSE
[16:01:46.168] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:46.168]  length: 1 (resolved future 1)
[16:01:46.168] Future #2
[16:01:46.169] result() for MulticoreFuture ...
[16:01:46.169] result() for MulticoreFuture ...
[16:01:46.169] result() for MulticoreFuture ... done
[16:01:46.170] result() for MulticoreFuture ... done
[16:01:46.170] result() for MulticoreFuture ...
[16:01:46.170] result() for MulticoreFuture ... done
[16:01:46.170] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:46.170] - nx: 2
[16:01:46.170] - relay: TRUE
[16:01:46.170] - stdout: TRUE
[16:01:46.171] - signal: TRUE
[16:01:46.171] - resignal: FALSE
[16:01:46.171] - force: TRUE
[16:01:46.171] - relayed: [n=2] TRUE, FALSE
[16:01:46.171] - queued futures: [n=2] TRUE, FALSE
[16:01:46.171]  - until=2
[16:01:46.171]  - relaying element #2
[16:01:46.171] result() for MulticoreFuture ...
[16:01:46.172] result() for MulticoreFuture ... done
[16:01:46.172] result() for MulticoreFuture ...
[16:01:46.172] result() for MulticoreFuture ... done
[16:01:46.172] result() for MulticoreFuture ...
[16:01:46.172] result() for MulticoreFuture ... done
[16:01:46.172] result() for MulticoreFuture ...
[16:01:46.172] result() for MulticoreFuture ... done
[16:01:46.172] - relayed: [n=2] TRUE, TRUE
[16:01:46.172] - queued futures: [n=2] TRUE, TRUE
[16:01:46.173] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:46.173]  length: 0 (resolved future 2)
[16:01:46.173] Relaying remaining futures
[16:01:46.173] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.173] - nx: 2
[16:01:46.173] - relay: TRUE
[16:01:46.173] - stdout: TRUE
[16:01:46.173] - signal: TRUE
[16:01:46.173] - resignal: FALSE
[16:01:46.174] - force: TRUE
[16:01:46.179] - relayed: [n=2] TRUE, TRUE
[16:01:46.179] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:46.179] - relayed: [n=2] TRUE, TRUE
[16:01:46.179] - queued futures: [n=2] TRUE, TRUE
[16:01:46.179] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.179] resolve() on list ... DONE
[16:01:46.180] result() for MulticoreFuture ...
[16:01:46.180] result() for MulticoreFuture ... done
[16:01:46.180] result() for MulticoreFuture ...
[16:01:46.180] result() for MulticoreFuture ... done
[16:01:46.180] result() for MulticoreFuture ...
[16:01:46.180] result() for MulticoreFuture ... done
[16:01:46.180] result() for MulticoreFuture ...
[16:01:46.180] result() for MulticoreFuture ... done
[16:01:46.181]  - Number of value chunks collected: 2
[16:01:46.181] Resolving 2 futures (chunks) ... DONE
[16:01:46.181] Reducing values from 2 chunks ...
[16:01:46.181]  - Number of values collected after concatenation: 3
[16:01:46.181]  - Number of values expected: 3
[16:01:46.181] Reducing values from 2 chunks ... DONE
[16:01:46.181] future_lapply() ... DONE
[16:01:46.181] future_by_internal() ... DONE
[16:01:46.182] future_by_internal() ...
[16:01:46.182] future_lapply() ...
[16:01:46.188] Number of chunks: 2
[16:01:46.188] getGlobalsAndPackagesXApply() ...
[16:01:46.188]  - future.globals: TRUE
[16:01:46.188] getGlobalsAndPackages() ...
[16:01:46.188] Searching for globals...
[16:01:46.190] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:46.190] Searching for globals ... DONE
[16:01:46.190] Resolving globals: FALSE
[16:01:46.191] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:46.191] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:46.191] - globals: [1] ‘FUN’
[16:01:46.191] 
[16:01:46.191] getGlobalsAndPackages() ... DONE
[16:01:46.191]  - globals found/used: [n=1] ‘FUN’
[16:01:46.192]  - needed namespaces: [n=0] 
[16:01:46.192] Finding globals ... DONE
[16:01:46.192]  - use_args: TRUE
[16:01:46.192]  - Getting '...' globals ...
[16:01:46.192] resolve() on list ...
[16:01:46.192]  recursive: 0
[16:01:46.192]  length: 1
[16:01:46.192]  elements: ‘...’
[16:01:46.193]  length: 0 (resolved future 1)
[16:01:46.193] resolve() on list ... DONE
[16:01:46.193]    - '...' content: [n=1] ‘digits’
[16:01:46.193] List of 1
[16:01:46.193]  $ ...:List of 1
[16:01:46.193]   ..$ digits: int 2
[16:01:46.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.193]  - attr(*, "where")=List of 1
[16:01:46.193]   ..$ ...:<environment: 0x55b526128df0> 
[16:01:46.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.193]  - attr(*, "resolved")= logi TRUE
[16:01:46.193]  - attr(*, "total_size")= num NA
[16:01:46.196]  - Getting '...' globals ... DONE
[16:01:46.196] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:46.197] List of 2
[16:01:46.197]  $ ...future.FUN:function (object, ...)  
[16:01:46.197]  $ ...          :List of 1
[16:01:46.197]   ..$ digits: int 2
[16:01:46.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.197]  - attr(*, "where")=List of 2
[16:01:46.197]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.197]   ..$ ...          :<environment: 0x55b526128df0> 
[16:01:46.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.197]  - attr(*, "resolved")= logi FALSE
[16:01:46.197]  - attr(*, "total_size")= num 1296
[16:01:46.200] Packages to be attached in all futures: [n=0] 
[16:01:46.200] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.200] Number of futures (= number of chunks): 2
[16:01:46.200] Launching 2 futures (chunks) ...
[16:01:46.200] Chunk #1 of 2 ...
[16:01:46.200]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.200] getGlobalsAndPackages() ...
[16:01:46.201] Searching for globals...
[16:01:46.201] 
[16:01:46.201] Searching for globals ... DONE
[16:01:46.201] - globals: [0] <none>
[16:01:46.201] getGlobalsAndPackages() ... DONE
[16:01:46.201]    + additional globals found: [n=0] 
[16:01:46.201]    + additional namespaces needed: [n=0] 
[16:01:46.201]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.201]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.202]  - seeds: <none>
[16:01:46.202]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.202] getGlobalsAndPackages() ...
[16:01:46.202] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.202] Resolving globals: FALSE
[16:01:46.202] Tweak future expression to call with '...' arguments ...
[16:01:46.202] {
[16:01:46.202]     do.call(function(...) {
[16:01:46.202]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.202]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.202]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.202]             on.exit(options(oopts), add = TRUE)
[16:01:46.202]         }
[16:01:46.202]         {
[16:01:46.202]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.202]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.202]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.202]             })
[16:01:46.202]         }
[16:01:46.202]     }, args = future.call.arguments)
[16:01:46.202] }
[16:01:46.202] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.205] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.205] 
[16:01:46.205] getGlobalsAndPackages() ... DONE
[16:01:46.205] run() for ‘Future’ ...
[16:01:46.205] - state: ‘created’
[16:01:46.206] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.210] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.210] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.210]   - Field: ‘label’
[16:01:46.210]   - Field: ‘local’
[16:01:46.210]   - Field: ‘owner’
[16:01:46.210]   - Field: ‘envir’
[16:01:46.210]   - Field: ‘workers’
[16:01:46.211]   - Field: ‘packages’
[16:01:46.211]   - Field: ‘gc’
[16:01:46.211]   - Field: ‘job’
[16:01:46.211]   - Field: ‘conditions’
[16:01:46.211]   - Field: ‘expr’
[16:01:46.211]   - Field: ‘uuid’
[16:01:46.211]   - Field: ‘seed’
[16:01:46.211]   - Field: ‘version’
[16:01:46.212]   - Field: ‘result’
[16:01:46.212]   - Field: ‘asynchronous’
[16:01:46.212]   - Field: ‘calls’
[16:01:46.212]   - Field: ‘globals’
[16:01:46.212]   - Field: ‘stdout’
[16:01:46.212]   - Field: ‘earlySignal’
[16:01:46.212]   - Field: ‘lazy’
[16:01:46.212]   - Field: ‘state’
[16:01:46.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.213] - Launch lazy future ...
[16:01:46.213] Packages needed by the future expression (n = 0): <none>
[16:01:46.213] Packages needed by future strategies (n = 0): <none>
[16:01:46.214] {
[16:01:46.214]     {
[16:01:46.214]         {
[16:01:46.214]             ...future.startTime <- base::Sys.time()
[16:01:46.214]             {
[16:01:46.214]                 {
[16:01:46.214]                   {
[16:01:46.214]                     {
[16:01:46.214]                       base::local({
[16:01:46.214]                         has_future <- base::requireNamespace("future", 
[16:01:46.214]                           quietly = TRUE)
[16:01:46.214]                         if (has_future) {
[16:01:46.214]                           ns <- base::getNamespace("future")
[16:01:46.214]                           version <- ns[[".package"]][["version"]]
[16:01:46.214]                           if (is.null(version)) 
[16:01:46.214]                             version <- utils::packageVersion("future")
[16:01:46.214]                         }
[16:01:46.214]                         else {
[16:01:46.214]                           version <- NULL
[16:01:46.214]                         }
[16:01:46.214]                         if (!has_future || version < "1.8.0") {
[16:01:46.214]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.214]                             "", base::R.version$version.string), 
[16:01:46.214]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.214]                               "release", "version")], collapse = " "), 
[16:01:46.214]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.214]                             info)
[16:01:46.214]                           info <- base::paste(info, collapse = "; ")
[16:01:46.214]                           if (!has_future) {
[16:01:46.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.214]                               info)
[16:01:46.214]                           }
[16:01:46.214]                           else {
[16:01:46.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.214]                               info, version)
[16:01:46.214]                           }
[16:01:46.214]                           base::stop(msg)
[16:01:46.214]                         }
[16:01:46.214]                       })
[16:01:46.214]                     }
[16:01:46.214]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.214]                     base::options(mc.cores = 1L)
[16:01:46.214]                   }
[16:01:46.214]                   options(future.plan = NULL)
[16:01:46.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.214]                 }
[16:01:46.214]                 ...future.workdir <- getwd()
[16:01:46.214]             }
[16:01:46.214]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.214]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.214]         }
[16:01:46.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.214]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.214]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.214]             base::names(...future.oldOptions))
[16:01:46.214]     }
[16:01:46.214]     if (FALSE) {
[16:01:46.214]     }
[16:01:46.214]     else {
[16:01:46.214]         if (TRUE) {
[16:01:46.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.214]                 open = "w")
[16:01:46.214]         }
[16:01:46.214]         else {
[16:01:46.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.214]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.214]         }
[16:01:46.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.214]             base::sink(type = "output", split = FALSE)
[16:01:46.214]             base::close(...future.stdout)
[16:01:46.214]         }, add = TRUE)
[16:01:46.214]     }
[16:01:46.214]     ...future.frame <- base::sys.nframe()
[16:01:46.214]     ...future.conditions <- base::list()
[16:01:46.214]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.214]     if (FALSE) {
[16:01:46.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.214]     }
[16:01:46.214]     ...future.result <- base::tryCatch({
[16:01:46.214]         base::withCallingHandlers({
[16:01:46.214]             ...future.value <- base::withVisible(base::local({
[16:01:46.214]                 withCallingHandlers({
[16:01:46.214]                   {
[16:01:46.214]                     do.call(function(...) {
[16:01:46.214]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.214]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.214]                         ...future.globals.maxSize)) {
[16:01:46.214]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.214]                         on.exit(options(oopts), add = TRUE)
[16:01:46.214]                       }
[16:01:46.214]                       {
[16:01:46.214]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.214]                           FUN = function(jj) {
[16:01:46.214]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.214]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.214]                           })
[16:01:46.214]                       }
[16:01:46.214]                     }, args = future.call.arguments)
[16:01:46.214]                   }
[16:01:46.214]                 }, immediateCondition = function(cond) {
[16:01:46.214]                   save_rds <- function (object, pathname, ...) 
[16:01:46.214]                   {
[16:01:46.214]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.214]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.214]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.214]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.214]                         fi_tmp[["mtime"]])
[16:01:46.214]                     }
[16:01:46.214]                     tryCatch({
[16:01:46.214]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.214]                     }, error = function(ex) {
[16:01:46.214]                       msg <- conditionMessage(ex)
[16:01:46.214]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.214]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.214]                         fi_tmp[["mtime"]], msg)
[16:01:46.214]                       ex$message <- msg
[16:01:46.214]                       stop(ex)
[16:01:46.214]                     })
[16:01:46.214]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.214]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.214]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.214]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.214]                       fi <- file.info(pathname)
[16:01:46.214]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.214]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.214]                         fi[["size"]], fi[["mtime"]])
[16:01:46.214]                       stop(msg)
[16:01:46.214]                     }
[16:01:46.214]                     invisible(pathname)
[16:01:46.214]                   }
[16:01:46.214]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.214]                     rootPath = tempdir()) 
[16:01:46.214]                   {
[16:01:46.214]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.214]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.214]                       tmpdir = path, fileext = ".rds")
[16:01:46.214]                     save_rds(obj, file)
[16:01:46.214]                   }
[16:01:46.214]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.214]                   {
[16:01:46.214]                     inherits <- base::inherits
[16:01:46.214]                     invokeRestart <- base::invokeRestart
[16:01:46.214]                     is.null <- base::is.null
[16:01:46.214]                     muffled <- FALSE
[16:01:46.214]                     if (inherits(cond, "message")) {
[16:01:46.214]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.214]                       if (muffled) 
[16:01:46.214]                         invokeRestart("muffleMessage")
[16:01:46.214]                     }
[16:01:46.214]                     else if (inherits(cond, "warning")) {
[16:01:46.214]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.214]                       if (muffled) 
[16:01:46.214]                         invokeRestart("muffleWarning")
[16:01:46.214]                     }
[16:01:46.214]                     else if (inherits(cond, "condition")) {
[16:01:46.214]                       if (!is.null(pattern)) {
[16:01:46.214]                         computeRestarts <- base::computeRestarts
[16:01:46.214]                         grepl <- base::grepl
[16:01:46.214]                         restarts <- computeRestarts(cond)
[16:01:46.214]                         for (restart in restarts) {
[16:01:46.214]                           name <- restart$name
[16:01:46.214]                           if (is.null(name)) 
[16:01:46.214]                             next
[16:01:46.214]                           if (!grepl(pattern, name)) 
[16:01:46.214]                             next
[16:01:46.214]                           invokeRestart(restart)
[16:01:46.214]                           muffled <- TRUE
[16:01:46.214]                           break
[16:01:46.214]                         }
[16:01:46.214]                       }
[16:01:46.214]                     }
[16:01:46.214]                     invisible(muffled)
[16:01:46.214]                   }
[16:01:46.214]                   muffleCondition(cond)
[16:01:46.214]                 })
[16:01:46.214]             }))
[16:01:46.214]             future::FutureResult(value = ...future.value$value, 
[16:01:46.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.214]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.214]                     ...future.globalenv.names))
[16:01:46.214]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.214]         }, condition = base::local({
[16:01:46.214]             c <- base::c
[16:01:46.214]             inherits <- base::inherits
[16:01:46.214]             invokeRestart <- base::invokeRestart
[16:01:46.214]             length <- base::length
[16:01:46.214]             list <- base::list
[16:01:46.214]             seq.int <- base::seq.int
[16:01:46.214]             signalCondition <- base::signalCondition
[16:01:46.214]             sys.calls <- base::sys.calls
[16:01:46.214]             `[[` <- base::`[[`
[16:01:46.214]             `+` <- base::`+`
[16:01:46.214]             `<<-` <- base::`<<-`
[16:01:46.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.214]                   3L)]
[16:01:46.214]             }
[16:01:46.214]             function(cond) {
[16:01:46.214]                 is_error <- inherits(cond, "error")
[16:01:46.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.214]                   NULL)
[16:01:46.214]                 if (is_error) {
[16:01:46.214]                   sessionInformation <- function() {
[16:01:46.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.214]                       search = base::search(), system = base::Sys.info())
[16:01:46.214]                   }
[16:01:46.214]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.214]                     cond$call), session = sessionInformation(), 
[16:01:46.214]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.214]                   signalCondition(cond)
[16:01:46.214]                 }
[16:01:46.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.214]                 "immediateCondition"))) {
[16:01:46.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.214]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.214]                   if (TRUE && !signal) {
[16:01:46.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.214]                     {
[16:01:46.214]                       inherits <- base::inherits
[16:01:46.214]                       invokeRestart <- base::invokeRestart
[16:01:46.214]                       is.null <- base::is.null
[16:01:46.214]                       muffled <- FALSE
[16:01:46.214]                       if (inherits(cond, "message")) {
[16:01:46.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.214]                         if (muffled) 
[16:01:46.214]                           invokeRestart("muffleMessage")
[16:01:46.214]                       }
[16:01:46.214]                       else if (inherits(cond, "warning")) {
[16:01:46.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.214]                         if (muffled) 
[16:01:46.214]                           invokeRestart("muffleWarning")
[16:01:46.214]                       }
[16:01:46.214]                       else if (inherits(cond, "condition")) {
[16:01:46.214]                         if (!is.null(pattern)) {
[16:01:46.214]                           computeRestarts <- base::computeRestarts
[16:01:46.214]                           grepl <- base::grepl
[16:01:46.214]                           restarts <- computeRestarts(cond)
[16:01:46.214]                           for (restart in restarts) {
[16:01:46.214]                             name <- restart$name
[16:01:46.214]                             if (is.null(name)) 
[16:01:46.214]                               next
[16:01:46.214]                             if (!grepl(pattern, name)) 
[16:01:46.214]                               next
[16:01:46.214]                             invokeRestart(restart)
[16:01:46.214]                             muffled <- TRUE
[16:01:46.214]                             break
[16:01:46.214]                           }
[16:01:46.214]                         }
[16:01:46.214]                       }
[16:01:46.214]                       invisible(muffled)
[16:01:46.214]                     }
[16:01:46.214]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.214]                   }
[16:01:46.214]                 }
[16:01:46.214]                 else {
[16:01:46.214]                   if (TRUE) {
[16:01:46.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.214]                     {
[16:01:46.214]                       inherits <- base::inherits
[16:01:46.214]                       invokeRestart <- base::invokeRestart
[16:01:46.214]                       is.null <- base::is.null
[16:01:46.214]                       muffled <- FALSE
[16:01:46.214]                       if (inherits(cond, "message")) {
[16:01:46.214]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.214]                         if (muffled) 
[16:01:46.214]                           invokeRestart("muffleMessage")
[16:01:46.214]                       }
[16:01:46.214]                       else if (inherits(cond, "warning")) {
[16:01:46.214]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.214]                         if (muffled) 
[16:01:46.214]                           invokeRestart("muffleWarning")
[16:01:46.214]                       }
[16:01:46.214]                       else if (inherits(cond, "condition")) {
[16:01:46.214]                         if (!is.null(pattern)) {
[16:01:46.214]                           computeRestarts <- base::computeRestarts
[16:01:46.214]                           grepl <- base::grepl
[16:01:46.214]                           restarts <- computeRestarts(cond)
[16:01:46.214]                           for (restart in restarts) {
[16:01:46.214]                             name <- restart$name
[16:01:46.214]                             if (is.null(name)) 
[16:01:46.214]                               next
[16:01:46.214]                             if (!grepl(pattern, name)) 
[16:01:46.214]                               next
[16:01:46.214]                             invokeRestart(restart)
[16:01:46.214]                             muffled <- TRUE
[16:01:46.214]                             break
[16:01:46.214]                           }
[16:01:46.214]                         }
[16:01:46.214]                       }
[16:01:46.214]                       invisible(muffled)
[16:01:46.214]                     }
[16:01:46.214]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.214]                   }
[16:01:46.214]                 }
[16:01:46.214]             }
[16:01:46.214]         }))
[16:01:46.214]     }, error = function(ex) {
[16:01:46.214]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.214]                 ...future.rng), started = ...future.startTime, 
[16:01:46.214]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.214]             version = "1.8"), class = "FutureResult")
[16:01:46.214]     }, finally = {
[16:01:46.214]         if (!identical(...future.workdir, getwd())) 
[16:01:46.214]             setwd(...future.workdir)
[16:01:46.214]         {
[16:01:46.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.214]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.214]             }
[16:01:46.214]             base::options(...future.oldOptions)
[16:01:46.214]             if (.Platform$OS.type == "windows") {
[16:01:46.214]                 old_names <- names(...future.oldEnvVars)
[16:01:46.214]                 envs <- base::Sys.getenv()
[16:01:46.214]                 names <- names(envs)
[16:01:46.214]                 common <- intersect(names, old_names)
[16:01:46.214]                 added <- setdiff(names, old_names)
[16:01:46.214]                 removed <- setdiff(old_names, names)
[16:01:46.214]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.214]                   envs[common]]
[16:01:46.214]                 NAMES <- toupper(changed)
[16:01:46.214]                 args <- list()
[16:01:46.214]                 for (kk in seq_along(NAMES)) {
[16:01:46.214]                   name <- changed[[kk]]
[16:01:46.214]                   NAME <- NAMES[[kk]]
[16:01:46.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.214]                     next
[16:01:46.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.214]                 }
[16:01:46.214]                 NAMES <- toupper(added)
[16:01:46.214]                 for (kk in seq_along(NAMES)) {
[16:01:46.214]                   name <- added[[kk]]
[16:01:46.214]                   NAME <- NAMES[[kk]]
[16:01:46.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.214]                     next
[16:01:46.214]                   args[[name]] <- ""
[16:01:46.214]                 }
[16:01:46.214]                 NAMES <- toupper(removed)
[16:01:46.214]                 for (kk in seq_along(NAMES)) {
[16:01:46.214]                   name <- removed[[kk]]
[16:01:46.214]                   NAME <- NAMES[[kk]]
[16:01:46.214]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.214]                     next
[16:01:46.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.214]                 }
[16:01:46.214]                 if (length(args) > 0) 
[16:01:46.214]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.214]             }
[16:01:46.214]             else {
[16:01:46.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.214]             }
[16:01:46.214]             {
[16:01:46.214]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.214]                   0L) {
[16:01:46.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.214]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.214]                   base::options(opts)
[16:01:46.214]                 }
[16:01:46.214]                 {
[16:01:46.214]                   {
[16:01:46.214]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.214]                     NULL
[16:01:46.214]                   }
[16:01:46.214]                   options(future.plan = NULL)
[16:01:46.214]                   if (is.na(NA_character_)) 
[16:01:46.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.214]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.214]                     envir = parent.frame()) 
[16:01:46.214]                   {
[16:01:46.214]                     default_workers <- missing(workers)
[16:01:46.214]                     if (is.function(workers)) 
[16:01:46.214]                       workers <- workers()
[16:01:46.214]                     workers <- structure(as.integer(workers), 
[16:01:46.214]                       class = class(workers))
[16:01:46.214]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.214]                       1L)
[16:01:46.214]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.214]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.214]                       if (default_workers) 
[16:01:46.214]                         supportsMulticore(warn = TRUE)
[16:01:46.214]                       return(sequential(..., envir = envir))
[16:01:46.214]                     }
[16:01:46.214]                     oopts <- options(mc.cores = workers)
[16:01:46.214]                     on.exit(options(oopts))
[16:01:46.214]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.214]                       envir = envir)
[16:01:46.214]                     if (!future$lazy) 
[16:01:46.214]                       future <- run(future)
[16:01:46.214]                     invisible(future)
[16:01:46.214]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.214]                 }
[16:01:46.214]             }
[16:01:46.214]         }
[16:01:46.214]     })
[16:01:46.214]     if (TRUE) {
[16:01:46.214]         base::sink(type = "output", split = FALSE)
[16:01:46.214]         if (TRUE) {
[16:01:46.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.214]         }
[16:01:46.214]         else {
[16:01:46.214]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.214]         }
[16:01:46.214]         base::close(...future.stdout)
[16:01:46.214]         ...future.stdout <- NULL
[16:01:46.214]     }
[16:01:46.214]     ...future.result$conditions <- ...future.conditions
[16:01:46.214]     ...future.result$finished <- base::Sys.time()
[16:01:46.214]     ...future.result
[16:01:46.214] }
[16:01:46.216] assign_globals() ...
[16:01:46.216] List of 5
[16:01:46.216]  $ ...future.FUN            :function (object, ...)  
[16:01:46.216]  $ future.call.arguments    :List of 1
[16:01:46.216]   ..$ digits: int 2
[16:01:46.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.216]  $ ...future.elements_ii    :List of 3
[16:01:46.216]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:01:46.216]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:01:46.216]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:01:46.216]  $ ...future.seeds_ii       : NULL
[16:01:46.216]  $ ...future.globals.maxSize: NULL
[16:01:46.216]  - attr(*, "where")=List of 5
[16:01:46.216]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.216]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.216]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.216]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.216]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.216]  - attr(*, "resolved")= logi FALSE
[16:01:46.216]  - attr(*, "total_size")= num 1296
[16:01:46.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.216]  - attr(*, "already-done")= logi TRUE
[16:01:46.222] - copied ‘...future.FUN’ to environment
[16:01:46.222] - copied ‘future.call.arguments’ to environment
[16:01:46.223] - copied ‘...future.elements_ii’ to environment
[16:01:46.223] - copied ‘...future.seeds_ii’ to environment
[16:01:46.223] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.223] assign_globals() ... done
[16:01:46.223] requestCore(): workers = 2
[16:01:46.225] MulticoreFuture started
[16:01:46.226] - Launch lazy future ... done
[16:01:46.226] run() for ‘MulticoreFuture’ ... done
[16:01:46.226] Created future:
[16:01:46.226] plan(): Setting new future strategy stack:
[16:01:46.227] List of future strategies:
[16:01:46.227] 1. sequential:
[16:01:46.227]    - args: function (..., envir = parent.frame())
[16:01:46.227]    - tweaked: FALSE
[16:01:46.227]    - call: NULL
[16:01:46.227] plan(): nbrOfWorkers() = 1
[16:01:46.230] plan(): Setting new future strategy stack:
[16:01:46.230] List of future strategies:
[16:01:46.230] 1. multicore:
[16:01:46.230]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.230]    - tweaked: FALSE
[16:01:46.230]    - call: plan(strategy)
[16:01:46.236] plan(): nbrOfWorkers() = 2
[16:01:46.226] MulticoreFuture:
[16:01:46.226] Label: ‘future_by-1’
[16:01:46.226] Expression:
[16:01:46.226] {
[16:01:46.226]     do.call(function(...) {
[16:01:46.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.226]             on.exit(options(oopts), add = TRUE)
[16:01:46.226]         }
[16:01:46.226]         {
[16:01:46.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.226]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.226]             })
[16:01:46.226]         }
[16:01:46.226]     }, args = future.call.arguments)
[16:01:46.226] }
[16:01:46.226] Lazy evaluation: FALSE
[16:01:46.226] Asynchronous evaluation: TRUE
[16:01:46.226] Local evaluation: TRUE
[16:01:46.226] Environment: R_GlobalEnv
[16:01:46.226] Capture standard output: TRUE
[16:01:46.226] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.226] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.226] Packages: <none>
[16:01:46.226] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.226] Resolved: TRUE
[16:01:46.226] Value: <not collected>
[16:01:46.226] Conditions captured: <none>
[16:01:46.226] Early signaling: FALSE
[16:01:46.226] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.226] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.237] Chunk #1 of 2 ... DONE
[16:01:46.237] Chunk #2 of 2 ...
[16:01:46.237]  - Finding globals in 'X' for chunk #2 ...
[16:01:46.238] getGlobalsAndPackages() ...
[16:01:46.238] Searching for globals...
[16:01:46.238] 
[16:01:46.238] Searching for globals ... DONE
[16:01:46.238] - globals: [0] <none>
[16:01:46.239] getGlobalsAndPackages() ... DONE
[16:01:46.239]    + additional globals found: [n=0] 
[16:01:46.239]    + additional namespaces needed: [n=0] 
[16:01:46.239]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:46.239]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.239]  - seeds: <none>
[16:01:46.239]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.240] getGlobalsAndPackages() ...
[16:01:46.240] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.240] Resolving globals: FALSE
[16:01:46.240] Tweak future expression to call with '...' arguments ...
[16:01:46.240] {
[16:01:46.240]     do.call(function(...) {
[16:01:46.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.240]             on.exit(options(oopts), add = TRUE)
[16:01:46.240]         }
[16:01:46.240]         {
[16:01:46.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.240]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.240]             })
[16:01:46.240]         }
[16:01:46.240]     }, args = future.call.arguments)
[16:01:46.240] }
[16:01:46.241] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.241] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.241] 
[16:01:46.242] getGlobalsAndPackages() ... DONE
[16:01:46.242] run() for ‘Future’ ...
[16:01:46.242] - state: ‘created’
[16:01:46.242] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.251] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.252]   - Field: ‘label’
[16:01:46.252]   - Field: ‘local’
[16:01:46.252]   - Field: ‘owner’
[16:01:46.253]   - Field: ‘envir’
[16:01:46.253]   - Field: ‘workers’
[16:01:46.253]   - Field: ‘packages’
[16:01:46.253]   - Field: ‘gc’
[16:01:46.254]   - Field: ‘job’
[16:01:46.254]   - Field: ‘conditions’
[16:01:46.254]   - Field: ‘expr’
[16:01:46.254]   - Field: ‘uuid’
[16:01:46.254]   - Field: ‘seed’
[16:01:46.255]   - Field: ‘version’
[16:01:46.255]   - Field: ‘result’
[16:01:46.255]   - Field: ‘asynchronous’
[16:01:46.255]   - Field: ‘calls’
[16:01:46.256]   - Field: ‘globals’
[16:01:46.256]   - Field: ‘stdout’
[16:01:46.256]   - Field: ‘earlySignal’
[16:01:46.256]   - Field: ‘lazy’
[16:01:46.256]   - Field: ‘state’
[16:01:46.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.257] - Launch lazy future ...
[16:01:46.257] Packages needed by the future expression (n = 0): <none>
[16:01:46.258] Packages needed by future strategies (n = 0): <none>
[16:01:46.259] {
[16:01:46.259]     {
[16:01:46.259]         {
[16:01:46.259]             ...future.startTime <- base::Sys.time()
[16:01:46.259]             {
[16:01:46.259]                 {
[16:01:46.259]                   {
[16:01:46.259]                     {
[16:01:46.259]                       base::local({
[16:01:46.259]                         has_future <- base::requireNamespace("future", 
[16:01:46.259]                           quietly = TRUE)
[16:01:46.259]                         if (has_future) {
[16:01:46.259]                           ns <- base::getNamespace("future")
[16:01:46.259]                           version <- ns[[".package"]][["version"]]
[16:01:46.259]                           if (is.null(version)) 
[16:01:46.259]                             version <- utils::packageVersion("future")
[16:01:46.259]                         }
[16:01:46.259]                         else {
[16:01:46.259]                           version <- NULL
[16:01:46.259]                         }
[16:01:46.259]                         if (!has_future || version < "1.8.0") {
[16:01:46.259]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.259]                             "", base::R.version$version.string), 
[16:01:46.259]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.259]                               "release", "version")], collapse = " "), 
[16:01:46.259]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.259]                             info)
[16:01:46.259]                           info <- base::paste(info, collapse = "; ")
[16:01:46.259]                           if (!has_future) {
[16:01:46.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.259]                               info)
[16:01:46.259]                           }
[16:01:46.259]                           else {
[16:01:46.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.259]                               info, version)
[16:01:46.259]                           }
[16:01:46.259]                           base::stop(msg)
[16:01:46.259]                         }
[16:01:46.259]                       })
[16:01:46.259]                     }
[16:01:46.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.259]                     base::options(mc.cores = 1L)
[16:01:46.259]                   }
[16:01:46.259]                   options(future.plan = NULL)
[16:01:46.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.259]                 }
[16:01:46.259]                 ...future.workdir <- getwd()
[16:01:46.259]             }
[16:01:46.259]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.259]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.259]         }
[16:01:46.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.259]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.259]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.259]             base::names(...future.oldOptions))
[16:01:46.259]     }
[16:01:46.259]     if (FALSE) {
[16:01:46.259]     }
[16:01:46.259]     else {
[16:01:46.259]         if (TRUE) {
[16:01:46.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.259]                 open = "w")
[16:01:46.259]         }
[16:01:46.259]         else {
[16:01:46.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.259]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.259]         }
[16:01:46.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.259]             base::sink(type = "output", split = FALSE)
[16:01:46.259]             base::close(...future.stdout)
[16:01:46.259]         }, add = TRUE)
[16:01:46.259]     }
[16:01:46.259]     ...future.frame <- base::sys.nframe()
[16:01:46.259]     ...future.conditions <- base::list()
[16:01:46.259]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.259]     if (FALSE) {
[16:01:46.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.259]     }
[16:01:46.259]     ...future.result <- base::tryCatch({
[16:01:46.259]         base::withCallingHandlers({
[16:01:46.259]             ...future.value <- base::withVisible(base::local({
[16:01:46.259]                 withCallingHandlers({
[16:01:46.259]                   {
[16:01:46.259]                     do.call(function(...) {
[16:01:46.259]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.259]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.259]                         ...future.globals.maxSize)) {
[16:01:46.259]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.259]                         on.exit(options(oopts), add = TRUE)
[16:01:46.259]                       }
[16:01:46.259]                       {
[16:01:46.259]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.259]                           FUN = function(jj) {
[16:01:46.259]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.259]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.259]                           })
[16:01:46.259]                       }
[16:01:46.259]                     }, args = future.call.arguments)
[16:01:46.259]                   }
[16:01:46.259]                 }, immediateCondition = function(cond) {
[16:01:46.259]                   save_rds <- function (object, pathname, ...) 
[16:01:46.259]                   {
[16:01:46.259]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.259]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.259]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.259]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.259]                         fi_tmp[["mtime"]])
[16:01:46.259]                     }
[16:01:46.259]                     tryCatch({
[16:01:46.259]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.259]                     }, error = function(ex) {
[16:01:46.259]                       msg <- conditionMessage(ex)
[16:01:46.259]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.259]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.259]                         fi_tmp[["mtime"]], msg)
[16:01:46.259]                       ex$message <- msg
[16:01:46.259]                       stop(ex)
[16:01:46.259]                     })
[16:01:46.259]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.259]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.259]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.259]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.259]                       fi <- file.info(pathname)
[16:01:46.259]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.259]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.259]                         fi[["size"]], fi[["mtime"]])
[16:01:46.259]                       stop(msg)
[16:01:46.259]                     }
[16:01:46.259]                     invisible(pathname)
[16:01:46.259]                   }
[16:01:46.259]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.259]                     rootPath = tempdir()) 
[16:01:46.259]                   {
[16:01:46.259]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.259]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.259]                       tmpdir = path, fileext = ".rds")
[16:01:46.259]                     save_rds(obj, file)
[16:01:46.259]                   }
[16:01:46.259]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.259]                   {
[16:01:46.259]                     inherits <- base::inherits
[16:01:46.259]                     invokeRestart <- base::invokeRestart
[16:01:46.259]                     is.null <- base::is.null
[16:01:46.259]                     muffled <- FALSE
[16:01:46.259]                     if (inherits(cond, "message")) {
[16:01:46.259]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.259]                       if (muffled) 
[16:01:46.259]                         invokeRestart("muffleMessage")
[16:01:46.259]                     }
[16:01:46.259]                     else if (inherits(cond, "warning")) {
[16:01:46.259]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.259]                       if (muffled) 
[16:01:46.259]                         invokeRestart("muffleWarning")
[16:01:46.259]                     }
[16:01:46.259]                     else if (inherits(cond, "condition")) {
[16:01:46.259]                       if (!is.null(pattern)) {
[16:01:46.259]                         computeRestarts <- base::computeRestarts
[16:01:46.259]                         grepl <- base::grepl
[16:01:46.259]                         restarts <- computeRestarts(cond)
[16:01:46.259]                         for (restart in restarts) {
[16:01:46.259]                           name <- restart$name
[16:01:46.259]                           if (is.null(name)) 
[16:01:46.259]                             next
[16:01:46.259]                           if (!grepl(pattern, name)) 
[16:01:46.259]                             next
[16:01:46.259]                           invokeRestart(restart)
[16:01:46.259]                           muffled <- TRUE
[16:01:46.259]                           break
[16:01:46.259]                         }
[16:01:46.259]                       }
[16:01:46.259]                     }
[16:01:46.259]                     invisible(muffled)
[16:01:46.259]                   }
[16:01:46.259]                   muffleCondition(cond)
[16:01:46.259]                 })
[16:01:46.259]             }))
[16:01:46.259]             future::FutureResult(value = ...future.value$value, 
[16:01:46.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.259]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.259]                     ...future.globalenv.names))
[16:01:46.259]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.259]         }, condition = base::local({
[16:01:46.259]             c <- base::c
[16:01:46.259]             inherits <- base::inherits
[16:01:46.259]             invokeRestart <- base::invokeRestart
[16:01:46.259]             length <- base::length
[16:01:46.259]             list <- base::list
[16:01:46.259]             seq.int <- base::seq.int
[16:01:46.259]             signalCondition <- base::signalCondition
[16:01:46.259]             sys.calls <- base::sys.calls
[16:01:46.259]             `[[` <- base::`[[`
[16:01:46.259]             `+` <- base::`+`
[16:01:46.259]             `<<-` <- base::`<<-`
[16:01:46.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.259]                   3L)]
[16:01:46.259]             }
[16:01:46.259]             function(cond) {
[16:01:46.259]                 is_error <- inherits(cond, "error")
[16:01:46.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.259]                   NULL)
[16:01:46.259]                 if (is_error) {
[16:01:46.259]                   sessionInformation <- function() {
[16:01:46.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.259]                       search = base::search(), system = base::Sys.info())
[16:01:46.259]                   }
[16:01:46.259]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.259]                     cond$call), session = sessionInformation(), 
[16:01:46.259]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.259]                   signalCondition(cond)
[16:01:46.259]                 }
[16:01:46.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.259]                 "immediateCondition"))) {
[16:01:46.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.259]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.259]                   if (TRUE && !signal) {
[16:01:46.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.259]                     {
[16:01:46.259]                       inherits <- base::inherits
[16:01:46.259]                       invokeRestart <- base::invokeRestart
[16:01:46.259]                       is.null <- base::is.null
[16:01:46.259]                       muffled <- FALSE
[16:01:46.259]                       if (inherits(cond, "message")) {
[16:01:46.259]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.259]                         if (muffled) 
[16:01:46.259]                           invokeRestart("muffleMessage")
[16:01:46.259]                       }
[16:01:46.259]                       else if (inherits(cond, "warning")) {
[16:01:46.259]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.259]                         if (muffled) 
[16:01:46.259]                           invokeRestart("muffleWarning")
[16:01:46.259]                       }
[16:01:46.259]                       else if (inherits(cond, "condition")) {
[16:01:46.259]                         if (!is.null(pattern)) {
[16:01:46.259]                           computeRestarts <- base::computeRestarts
[16:01:46.259]                           grepl <- base::grepl
[16:01:46.259]                           restarts <- computeRestarts(cond)
[16:01:46.259]                           for (restart in restarts) {
[16:01:46.259]                             name <- restart$name
[16:01:46.259]                             if (is.null(name)) 
[16:01:46.259]                               next
[16:01:46.259]                             if (!grepl(pattern, name)) 
[16:01:46.259]                               next
[16:01:46.259]                             invokeRestart(restart)
[16:01:46.259]                             muffled <- TRUE
[16:01:46.259]                             break
[16:01:46.259]                           }
[16:01:46.259]                         }
[16:01:46.259]                       }
[16:01:46.259]                       invisible(muffled)
[16:01:46.259]                     }
[16:01:46.259]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.259]                   }
[16:01:46.259]                 }
[16:01:46.259]                 else {
[16:01:46.259]                   if (TRUE) {
[16:01:46.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.259]                     {
[16:01:46.259]                       inherits <- base::inherits
[16:01:46.259]                       invokeRestart <- base::invokeRestart
[16:01:46.259]                       is.null <- base::is.null
[16:01:46.259]                       muffled <- FALSE
[16:01:46.259]                       if (inherits(cond, "message")) {
[16:01:46.259]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.259]                         if (muffled) 
[16:01:46.259]                           invokeRestart("muffleMessage")
[16:01:46.259]                       }
[16:01:46.259]                       else if (inherits(cond, "warning")) {
[16:01:46.259]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.259]                         if (muffled) 
[16:01:46.259]                           invokeRestart("muffleWarning")
[16:01:46.259]                       }
[16:01:46.259]                       else if (inherits(cond, "condition")) {
[16:01:46.259]                         if (!is.null(pattern)) {
[16:01:46.259]                           computeRestarts <- base::computeRestarts
[16:01:46.259]                           grepl <- base::grepl
[16:01:46.259]                           restarts <- computeRestarts(cond)
[16:01:46.259]                           for (restart in restarts) {
[16:01:46.259]                             name <- restart$name
[16:01:46.259]                             if (is.null(name)) 
[16:01:46.259]                               next
[16:01:46.259]                             if (!grepl(pattern, name)) 
[16:01:46.259]                               next
[16:01:46.259]                             invokeRestart(restart)
[16:01:46.259]                             muffled <- TRUE
[16:01:46.259]                             break
[16:01:46.259]                           }
[16:01:46.259]                         }
[16:01:46.259]                       }
[16:01:46.259]                       invisible(muffled)
[16:01:46.259]                     }
[16:01:46.259]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.259]                   }
[16:01:46.259]                 }
[16:01:46.259]             }
[16:01:46.259]         }))
[16:01:46.259]     }, error = function(ex) {
[16:01:46.259]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.259]                 ...future.rng), started = ...future.startTime, 
[16:01:46.259]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.259]             version = "1.8"), class = "FutureResult")
[16:01:46.259]     }, finally = {
[16:01:46.259]         if (!identical(...future.workdir, getwd())) 
[16:01:46.259]             setwd(...future.workdir)
[16:01:46.259]         {
[16:01:46.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.259]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.259]             }
[16:01:46.259]             base::options(...future.oldOptions)
[16:01:46.259]             if (.Platform$OS.type == "windows") {
[16:01:46.259]                 old_names <- names(...future.oldEnvVars)
[16:01:46.259]                 envs <- base::Sys.getenv()
[16:01:46.259]                 names <- names(envs)
[16:01:46.259]                 common <- intersect(names, old_names)
[16:01:46.259]                 added <- setdiff(names, old_names)
[16:01:46.259]                 removed <- setdiff(old_names, names)
[16:01:46.259]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.259]                   envs[common]]
[16:01:46.259]                 NAMES <- toupper(changed)
[16:01:46.259]                 args <- list()
[16:01:46.259]                 for (kk in seq_along(NAMES)) {
[16:01:46.259]                   name <- changed[[kk]]
[16:01:46.259]                   NAME <- NAMES[[kk]]
[16:01:46.259]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.259]                     next
[16:01:46.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.259]                 }
[16:01:46.259]                 NAMES <- toupper(added)
[16:01:46.259]                 for (kk in seq_along(NAMES)) {
[16:01:46.259]                   name <- added[[kk]]
[16:01:46.259]                   NAME <- NAMES[[kk]]
[16:01:46.259]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.259]                     next
[16:01:46.259]                   args[[name]] <- ""
[16:01:46.259]                 }
[16:01:46.259]                 NAMES <- toupper(removed)
[16:01:46.259]                 for (kk in seq_along(NAMES)) {
[16:01:46.259]                   name <- removed[[kk]]
[16:01:46.259]                   NAME <- NAMES[[kk]]
[16:01:46.259]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.259]                     next
[16:01:46.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.259]                 }
[16:01:46.259]                 if (length(args) > 0) 
[16:01:46.259]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.259]             }
[16:01:46.259]             else {
[16:01:46.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.259]             }
[16:01:46.259]             {
[16:01:46.259]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.259]                   0L) {
[16:01:46.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.259]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.259]                   base::options(opts)
[16:01:46.259]                 }
[16:01:46.259]                 {
[16:01:46.259]                   {
[16:01:46.259]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.259]                     NULL
[16:01:46.259]                   }
[16:01:46.259]                   options(future.plan = NULL)
[16:01:46.259]                   if (is.na(NA_character_)) 
[16:01:46.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.259]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.259]                     envir = parent.frame()) 
[16:01:46.259]                   {
[16:01:46.259]                     default_workers <- missing(workers)
[16:01:46.259]                     if (is.function(workers)) 
[16:01:46.259]                       workers <- workers()
[16:01:46.259]                     workers <- structure(as.integer(workers), 
[16:01:46.259]                       class = class(workers))
[16:01:46.259]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.259]                       1L)
[16:01:46.259]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.259]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.259]                       if (default_workers) 
[16:01:46.259]                         supportsMulticore(warn = TRUE)
[16:01:46.259]                       return(sequential(..., envir = envir))
[16:01:46.259]                     }
[16:01:46.259]                     oopts <- options(mc.cores = workers)
[16:01:46.259]                     on.exit(options(oopts))
[16:01:46.259]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.259]                       envir = envir)
[16:01:46.259]                     if (!future$lazy) 
[16:01:46.259]                       future <- run(future)
[16:01:46.259]                     invisible(future)
[16:01:46.259]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.259]                 }
[16:01:46.259]             }
[16:01:46.259]         }
[16:01:46.259]     })
[16:01:46.259]     if (TRUE) {
[16:01:46.259]         base::sink(type = "output", split = FALSE)
[16:01:46.259]         if (TRUE) {
[16:01:46.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.259]         }
[16:01:46.259]         else {
[16:01:46.259]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.259]         }
[16:01:46.259]         base::close(...future.stdout)
[16:01:46.259]         ...future.stdout <- NULL
[16:01:46.259]     }
[16:01:46.259]     ...future.result$conditions <- ...future.conditions
[16:01:46.259]     ...future.result$finished <- base::Sys.time()
[16:01:46.259]     ...future.result
[16:01:46.259] }
[16:01:46.262] assign_globals() ...
[16:01:46.262] List of 5
[16:01:46.262]  $ ...future.FUN            :function (object, ...)  
[16:01:46.262]  $ future.call.arguments    :List of 1
[16:01:46.262]   ..$ digits: int 2
[16:01:46.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.262]  $ ...future.elements_ii    :List of 3
[16:01:46.262]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:01:46.262]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:01:46.262]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:01:46.262]  $ ...future.seeds_ii       : NULL
[16:01:46.262]  $ ...future.globals.maxSize: NULL
[16:01:46.262]  - attr(*, "where")=List of 5
[16:01:46.262]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.262]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.262]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.262]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.262]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.262]  - attr(*, "resolved")= logi FALSE
[16:01:46.262]  - attr(*, "total_size")= num 1296
[16:01:46.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.262]  - attr(*, "already-done")= logi TRUE
[16:01:46.271] - copied ‘...future.FUN’ to environment
[16:01:46.271] - copied ‘future.call.arguments’ to environment
[16:01:46.271] - copied ‘...future.elements_ii’ to environment
[16:01:46.271] - copied ‘...future.seeds_ii’ to environment
[16:01:46.271] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.272] assign_globals() ... done
[16:01:46.272] requestCore(): workers = 2
[16:01:46.274] MulticoreFuture started
[16:01:46.274] - Launch lazy future ... done
[16:01:46.275] run() for ‘MulticoreFuture’ ... done
[16:01:46.275] Created future:
[16:01:46.275] plan(): Setting new future strategy stack:
[16:01:46.276] List of future strategies:
[16:01:46.276] 1. sequential:
[16:01:46.276]    - args: function (..., envir = parent.frame())
[16:01:46.276]    - tweaked: FALSE
[16:01:46.276]    - call: NULL
[16:01:46.276] plan(): nbrOfWorkers() = 1
[16:01:46.279] plan(): Setting new future strategy stack:
[16:01:46.279] List of future strategies:
[16:01:46.279] 1. multicore:
[16:01:46.279]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.279]    - tweaked: FALSE
[16:01:46.279]    - call: plan(strategy)
[16:01:46.285] plan(): nbrOfWorkers() = 2
[16:01:46.275] MulticoreFuture:
[16:01:46.275] Label: ‘future_by-2’
[16:01:46.275] Expression:
[16:01:46.275] {
[16:01:46.275]     do.call(function(...) {
[16:01:46.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.275]             on.exit(options(oopts), add = TRUE)
[16:01:46.275]         }
[16:01:46.275]         {
[16:01:46.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.275]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.275]             })
[16:01:46.275]         }
[16:01:46.275]     }, args = future.call.arguments)
[16:01:46.275] }
[16:01:46.275] Lazy evaluation: FALSE
[16:01:46.275] Asynchronous evaluation: TRUE
[16:01:46.275] Local evaluation: TRUE
[16:01:46.275] Environment: R_GlobalEnv
[16:01:46.275] Capture standard output: TRUE
[16:01:46.275] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.275] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.275] Packages: <none>
[16:01:46.275] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.275] Resolved: TRUE
[16:01:46.275] Value: <not collected>
[16:01:46.275] Conditions captured: <none>
[16:01:46.275] Early signaling: FALSE
[16:01:46.275] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.275] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.286] Chunk #2 of 2 ... DONE
[16:01:46.286] Launching 2 futures (chunks) ... DONE
[16:01:46.286] Resolving 2 futures (chunks) ...
[16:01:46.286] resolve() on list ...
[16:01:46.286]  recursive: 0
[16:01:46.286]  length: 2
[16:01:46.287] 
[16:01:46.287] Future #1
[16:01:46.287] result() for MulticoreFuture ...
[16:01:46.288] result() for MulticoreFuture ...
[16:01:46.288] result() for MulticoreFuture ... done
[16:01:46.288] result() for MulticoreFuture ... done
[16:01:46.288] result() for MulticoreFuture ...
[16:01:46.289] result() for MulticoreFuture ... done
[16:01:46.289] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:46.289] - nx: 2
[16:01:46.289] - relay: TRUE
[16:01:46.289] - stdout: TRUE
[16:01:46.289] - signal: TRUE
[16:01:46.289] - resignal: FALSE
[16:01:46.290] - force: TRUE
[16:01:46.290] - relayed: [n=2] FALSE, FALSE
[16:01:46.290] - queued futures: [n=2] FALSE, FALSE
[16:01:46.290]  - until=1
[16:01:46.290]  - relaying element #1
[16:01:46.290] result() for MulticoreFuture ...
[16:01:46.290] result() for MulticoreFuture ... done
[16:01:46.291] result() for MulticoreFuture ...
[16:01:46.291] result() for MulticoreFuture ... done
[16:01:46.291] result() for MulticoreFuture ...
[16:01:46.291] result() for MulticoreFuture ... done
[16:01:46.291] result() for MulticoreFuture ...
[16:01:46.291] result() for MulticoreFuture ... done
[16:01:46.291] - relayed: [n=2] TRUE, FALSE
[16:01:46.292] - queued futures: [n=2] TRUE, FALSE
[16:01:46.292] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:46.292]  length: 1 (resolved future 1)
[16:01:46.292] Future #2
[16:01:46.292] result() for MulticoreFuture ...
[16:01:46.293] result() for MulticoreFuture ...
[16:01:46.293] result() for MulticoreFuture ... done
[16:01:46.293] result() for MulticoreFuture ... done
[16:01:46.293] result() for MulticoreFuture ...
[16:01:46.294] result() for MulticoreFuture ... done
[16:01:46.294] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:46.294] - nx: 2
[16:01:46.294] - relay: TRUE
[16:01:46.294] - stdout: TRUE
[16:01:46.297] - signal: TRUE
[16:01:46.297] - resignal: FALSE
[16:01:46.297] - force: TRUE
[16:01:46.297] - relayed: [n=2] TRUE, FALSE
[16:01:46.298] - queued futures: [n=2] TRUE, FALSE
[16:01:46.298]  - until=2
[16:01:46.298]  - relaying element #2
[16:01:46.298] result() for MulticoreFuture ...
[16:01:46.298] result() for MulticoreFuture ... done
[16:01:46.299] result() for MulticoreFuture ...
[16:01:46.299] result() for MulticoreFuture ... done
[16:01:46.299] result() for MulticoreFuture ...
[16:01:46.299] result() for MulticoreFuture ... done
[16:01:46.299] result() for MulticoreFuture ...
[16:01:46.300] result() for MulticoreFuture ... done
[16:01:46.300] - relayed: [n=2] TRUE, TRUE
[16:01:46.300] - queued futures: [n=2] TRUE, TRUE
[16:01:46.300] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:46.300]  length: 0 (resolved future 2)
[16:01:46.300] Relaying remaining futures
[16:01:46.300] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.301] - nx: 2
[16:01:46.301] - relay: TRUE
[16:01:46.301] - stdout: TRUE
[16:01:46.301] - signal: TRUE
[16:01:46.301] - resignal: FALSE
[16:01:46.301] - force: TRUE
[16:01:46.301] - relayed: [n=2] TRUE, TRUE
[16:01:46.302] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:46.302] - relayed: [n=2] TRUE, TRUE
[16:01:46.302] - queued futures: [n=2] TRUE, TRUE
[16:01:46.302] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.302] resolve() on list ... DONE
[16:01:46.302] result() for MulticoreFuture ...
[16:01:46.303] result() for MulticoreFuture ... done
[16:01:46.303] result() for MulticoreFuture ...
[16:01:46.303] result() for MulticoreFuture ... done
[16:01:46.303] result() for MulticoreFuture ...
[16:01:46.303] result() for MulticoreFuture ... done
[16:01:46.303] result() for MulticoreFuture ...
[16:01:46.304] result() for MulticoreFuture ... done
[16:01:46.304]  - Number of value chunks collected: 2
[16:01:46.304] Resolving 2 futures (chunks) ... DONE
[16:01:46.304] Reducing values from 2 chunks ...
[16:01:46.304]  - Number of values collected after concatenation: 6
[16:01:46.304]  - Number of values expected: 6
[16:01:46.304] Reducing values from 2 chunks ... DONE
[16:01:46.305] future_lapply() ... DONE
[16:01:46.305] future_by_internal() ... DONE
[16:01:46.306] future_by_internal() ...
[16:01:46.307] future_lapply() ...
[16:01:46.313] Number of chunks: 2
[16:01:46.313] getGlobalsAndPackagesXApply() ...
[16:01:46.313]  - future.globals: TRUE
[16:01:46.313] getGlobalsAndPackages() ...
[16:01:46.313] Searching for globals...
[16:01:46.315] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:46.315] Searching for globals ... DONE
[16:01:46.315] Resolving globals: FALSE
[16:01:46.316] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:01:46.316] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:01:46.316] - globals: [1] ‘FUN’
[16:01:46.316] - packages: [1] ‘stats’
[16:01:46.317] getGlobalsAndPackages() ... DONE
[16:01:46.317]  - globals found/used: [n=1] ‘FUN’
[16:01:46.317]  - needed namespaces: [n=1] ‘stats’
[16:01:46.317] Finding globals ... DONE
[16:01:46.317]  - use_args: TRUE
[16:01:46.317]  - Getting '...' globals ...
[16:01:46.317] resolve() on list ...
[16:01:46.317]  recursive: 0
[16:01:46.318]  length: 1
[16:01:46.318]  elements: ‘...’
[16:01:46.318]  length: 0 (resolved future 1)
[16:01:46.318] resolve() on list ... DONE
[16:01:46.318]    - '...' content: [n=1] ‘singular.ok’
[16:01:46.318] List of 1
[16:01:46.318]  $ ...:List of 1
[16:01:46.318]   ..$ singular.ok: logi FALSE
[16:01:46.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.318]  - attr(*, "where")=List of 1
[16:01:46.318]   ..$ ...:<environment: 0x55b5247e6008> 
[16:01:46.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.318]  - attr(*, "resolved")= logi TRUE
[16:01:46.318]  - attr(*, "total_size")= num NA
[16:01:46.321]  - Getting '...' globals ... DONE
[16:01:46.321] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:46.322] List of 2
[16:01:46.322]  $ ...future.FUN:function (x, ...)  
[16:01:46.322]  $ ...          :List of 1
[16:01:46.322]   ..$ singular.ok: logi FALSE
[16:01:46.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.322]  - attr(*, "where")=List of 2
[16:01:46.322]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.322]   ..$ ...          :<environment: 0x55b5247e6008> 
[16:01:46.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.322]  - attr(*, "resolved")= logi FALSE
[16:01:46.322]  - attr(*, "total_size")= num 5384
[16:01:46.327] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:46.328] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.328] Number of futures (= number of chunks): 2
[16:01:46.328] Launching 2 futures (chunks) ...
[16:01:46.328] Chunk #1 of 2 ...
[16:01:46.328]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.328] getGlobalsAndPackages() ...
[16:01:46.328] Searching for globals...
[16:01:46.329] 
[16:01:46.329] Searching for globals ... DONE
[16:01:46.329] - globals: [0] <none>
[16:01:46.329] getGlobalsAndPackages() ... DONE
[16:01:46.329]    + additional globals found: [n=0] 
[16:01:46.329]    + additional namespaces needed: [n=0] 
[16:01:46.330]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.330]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.330]  - seeds: <none>
[16:01:46.330]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.330] getGlobalsAndPackages() ...
[16:01:46.330] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.330] Resolving globals: FALSE
[16:01:46.330] Tweak future expression to call with '...' arguments ...
[16:01:46.331] {
[16:01:46.331]     do.call(function(...) {
[16:01:46.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.331]             on.exit(options(oopts), add = TRUE)
[16:01:46.331]         }
[16:01:46.331]         {
[16:01:46.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.331]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.331]             })
[16:01:46.331]         }
[16:01:46.331]     }, args = future.call.arguments)
[16:01:46.331] }
[16:01:46.331] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.331] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.331] 
[16:01:46.331] getGlobalsAndPackages() ... DONE
[16:01:46.332] run() for ‘Future’ ...
[16:01:46.332] - state: ‘created’
[16:01:46.332] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.336]   - Field: ‘label’
[16:01:46.337]   - Field: ‘local’
[16:01:46.337]   - Field: ‘owner’
[16:01:46.337]   - Field: ‘envir’
[16:01:46.337]   - Field: ‘workers’
[16:01:46.337]   - Field: ‘packages’
[16:01:46.337]   - Field: ‘gc’
[16:01:46.337]   - Field: ‘job’
[16:01:46.337]   - Field: ‘conditions’
[16:01:46.338]   - Field: ‘expr’
[16:01:46.338]   - Field: ‘uuid’
[16:01:46.338]   - Field: ‘seed’
[16:01:46.338]   - Field: ‘version’
[16:01:46.338]   - Field: ‘result’
[16:01:46.338]   - Field: ‘asynchronous’
[16:01:46.338]   - Field: ‘calls’
[16:01:46.338]   - Field: ‘globals’
[16:01:46.338]   - Field: ‘stdout’
[16:01:46.338]   - Field: ‘earlySignal’
[16:01:46.338]   - Field: ‘lazy’
[16:01:46.339]   - Field: ‘state’
[16:01:46.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.339] - Launch lazy future ...
[16:01:46.339] Packages needed by the future expression (n = 1): ‘stats’
[16:01:46.339] Packages needed by future strategies (n = 0): <none>
[16:01:46.340] {
[16:01:46.340]     {
[16:01:46.340]         {
[16:01:46.340]             ...future.startTime <- base::Sys.time()
[16:01:46.340]             {
[16:01:46.340]                 {
[16:01:46.340]                   {
[16:01:46.340]                     {
[16:01:46.340]                       {
[16:01:46.340]                         base::local({
[16:01:46.340]                           has_future <- base::requireNamespace("future", 
[16:01:46.340]                             quietly = TRUE)
[16:01:46.340]                           if (has_future) {
[16:01:46.340]                             ns <- base::getNamespace("future")
[16:01:46.340]                             version <- ns[[".package"]][["version"]]
[16:01:46.340]                             if (is.null(version)) 
[16:01:46.340]                               version <- utils::packageVersion("future")
[16:01:46.340]                           }
[16:01:46.340]                           else {
[16:01:46.340]                             version <- NULL
[16:01:46.340]                           }
[16:01:46.340]                           if (!has_future || version < "1.8.0") {
[16:01:46.340]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.340]                               "", base::R.version$version.string), 
[16:01:46.340]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:46.340]                                 base::R.version$platform, 8 * 
[16:01:46.340]                                   base::.Machine$sizeof.pointer), 
[16:01:46.340]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.340]                                 "release", "version")], collapse = " "), 
[16:01:46.340]                               hostname = base::Sys.info()[["nodename"]])
[16:01:46.340]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.340]                               info)
[16:01:46.340]                             info <- base::paste(info, collapse = "; ")
[16:01:46.340]                             if (!has_future) {
[16:01:46.340]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.340]                                 info)
[16:01:46.340]                             }
[16:01:46.340]                             else {
[16:01:46.340]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.340]                                 info, version)
[16:01:46.340]                             }
[16:01:46.340]                             base::stop(msg)
[16:01:46.340]                           }
[16:01:46.340]                         })
[16:01:46.340]                       }
[16:01:46.340]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.340]                       base::options(mc.cores = 1L)
[16:01:46.340]                     }
[16:01:46.340]                     base::local({
[16:01:46.340]                       for (pkg in "stats") {
[16:01:46.340]                         base::loadNamespace(pkg)
[16:01:46.340]                         base::library(pkg, character.only = TRUE)
[16:01:46.340]                       }
[16:01:46.340]                     })
[16:01:46.340]                   }
[16:01:46.340]                   options(future.plan = NULL)
[16:01:46.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.340]                 }
[16:01:46.340]                 ...future.workdir <- getwd()
[16:01:46.340]             }
[16:01:46.340]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.340]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.340]         }
[16:01:46.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.340]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.340]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.340]             base::names(...future.oldOptions))
[16:01:46.340]     }
[16:01:46.340]     if (FALSE) {
[16:01:46.340]     }
[16:01:46.340]     else {
[16:01:46.340]         if (TRUE) {
[16:01:46.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.340]                 open = "w")
[16:01:46.340]         }
[16:01:46.340]         else {
[16:01:46.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.340]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.340]         }
[16:01:46.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.340]             base::sink(type = "output", split = FALSE)
[16:01:46.340]             base::close(...future.stdout)
[16:01:46.340]         }, add = TRUE)
[16:01:46.340]     }
[16:01:46.340]     ...future.frame <- base::sys.nframe()
[16:01:46.340]     ...future.conditions <- base::list()
[16:01:46.340]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.340]     if (FALSE) {
[16:01:46.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.340]     }
[16:01:46.340]     ...future.result <- base::tryCatch({
[16:01:46.340]         base::withCallingHandlers({
[16:01:46.340]             ...future.value <- base::withVisible(base::local({
[16:01:46.340]                 withCallingHandlers({
[16:01:46.340]                   {
[16:01:46.340]                     do.call(function(...) {
[16:01:46.340]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.340]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.340]                         ...future.globals.maxSize)) {
[16:01:46.340]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.340]                         on.exit(options(oopts), add = TRUE)
[16:01:46.340]                       }
[16:01:46.340]                       {
[16:01:46.340]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.340]                           FUN = function(jj) {
[16:01:46.340]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.340]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.340]                           })
[16:01:46.340]                       }
[16:01:46.340]                     }, args = future.call.arguments)
[16:01:46.340]                   }
[16:01:46.340]                 }, immediateCondition = function(cond) {
[16:01:46.340]                   save_rds <- function (object, pathname, ...) 
[16:01:46.340]                   {
[16:01:46.340]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.340]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.340]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.340]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.340]                         fi_tmp[["mtime"]])
[16:01:46.340]                     }
[16:01:46.340]                     tryCatch({
[16:01:46.340]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.340]                     }, error = function(ex) {
[16:01:46.340]                       msg <- conditionMessage(ex)
[16:01:46.340]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.340]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.340]                         fi_tmp[["mtime"]], msg)
[16:01:46.340]                       ex$message <- msg
[16:01:46.340]                       stop(ex)
[16:01:46.340]                     })
[16:01:46.340]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.340]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.340]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.340]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.340]                       fi <- file.info(pathname)
[16:01:46.340]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.340]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.340]                         fi[["size"]], fi[["mtime"]])
[16:01:46.340]                       stop(msg)
[16:01:46.340]                     }
[16:01:46.340]                     invisible(pathname)
[16:01:46.340]                   }
[16:01:46.340]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.340]                     rootPath = tempdir()) 
[16:01:46.340]                   {
[16:01:46.340]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.340]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.340]                       tmpdir = path, fileext = ".rds")
[16:01:46.340]                     save_rds(obj, file)
[16:01:46.340]                   }
[16:01:46.340]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.340]                   {
[16:01:46.340]                     inherits <- base::inherits
[16:01:46.340]                     invokeRestart <- base::invokeRestart
[16:01:46.340]                     is.null <- base::is.null
[16:01:46.340]                     muffled <- FALSE
[16:01:46.340]                     if (inherits(cond, "message")) {
[16:01:46.340]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.340]                       if (muffled) 
[16:01:46.340]                         invokeRestart("muffleMessage")
[16:01:46.340]                     }
[16:01:46.340]                     else if (inherits(cond, "warning")) {
[16:01:46.340]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.340]                       if (muffled) 
[16:01:46.340]                         invokeRestart("muffleWarning")
[16:01:46.340]                     }
[16:01:46.340]                     else if (inherits(cond, "condition")) {
[16:01:46.340]                       if (!is.null(pattern)) {
[16:01:46.340]                         computeRestarts <- base::computeRestarts
[16:01:46.340]                         grepl <- base::grepl
[16:01:46.340]                         restarts <- computeRestarts(cond)
[16:01:46.340]                         for (restart in restarts) {
[16:01:46.340]                           name <- restart$name
[16:01:46.340]                           if (is.null(name)) 
[16:01:46.340]                             next
[16:01:46.340]                           if (!grepl(pattern, name)) 
[16:01:46.340]                             next
[16:01:46.340]                           invokeRestart(restart)
[16:01:46.340]                           muffled <- TRUE
[16:01:46.340]                           break
[16:01:46.340]                         }
[16:01:46.340]                       }
[16:01:46.340]                     }
[16:01:46.340]                     invisible(muffled)
[16:01:46.340]                   }
[16:01:46.340]                   muffleCondition(cond)
[16:01:46.340]                 })
[16:01:46.340]             }))
[16:01:46.340]             future::FutureResult(value = ...future.value$value, 
[16:01:46.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.340]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.340]                     ...future.globalenv.names))
[16:01:46.340]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.340]         }, condition = base::local({
[16:01:46.340]             c <- base::c
[16:01:46.340]             inherits <- base::inherits
[16:01:46.340]             invokeRestart <- base::invokeRestart
[16:01:46.340]             length <- base::length
[16:01:46.340]             list <- base::list
[16:01:46.340]             seq.int <- base::seq.int
[16:01:46.340]             signalCondition <- base::signalCondition
[16:01:46.340]             sys.calls <- base::sys.calls
[16:01:46.340]             `[[` <- base::`[[`
[16:01:46.340]             `+` <- base::`+`
[16:01:46.340]             `<<-` <- base::`<<-`
[16:01:46.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.340]                   3L)]
[16:01:46.340]             }
[16:01:46.340]             function(cond) {
[16:01:46.340]                 is_error <- inherits(cond, "error")
[16:01:46.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.340]                   NULL)
[16:01:46.340]                 if (is_error) {
[16:01:46.340]                   sessionInformation <- function() {
[16:01:46.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.340]                       search = base::search(), system = base::Sys.info())
[16:01:46.340]                   }
[16:01:46.340]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.340]                     cond$call), session = sessionInformation(), 
[16:01:46.340]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.340]                   signalCondition(cond)
[16:01:46.340]                 }
[16:01:46.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.340]                 "immediateCondition"))) {
[16:01:46.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.340]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.340]                   if (TRUE && !signal) {
[16:01:46.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.340]                     {
[16:01:46.340]                       inherits <- base::inherits
[16:01:46.340]                       invokeRestart <- base::invokeRestart
[16:01:46.340]                       is.null <- base::is.null
[16:01:46.340]                       muffled <- FALSE
[16:01:46.340]                       if (inherits(cond, "message")) {
[16:01:46.340]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.340]                         if (muffled) 
[16:01:46.340]                           invokeRestart("muffleMessage")
[16:01:46.340]                       }
[16:01:46.340]                       else if (inherits(cond, "warning")) {
[16:01:46.340]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.340]                         if (muffled) 
[16:01:46.340]                           invokeRestart("muffleWarning")
[16:01:46.340]                       }
[16:01:46.340]                       else if (inherits(cond, "condition")) {
[16:01:46.340]                         if (!is.null(pattern)) {
[16:01:46.340]                           computeRestarts <- base::computeRestarts
[16:01:46.340]                           grepl <- base::grepl
[16:01:46.340]                           restarts <- computeRestarts(cond)
[16:01:46.340]                           for (restart in restarts) {
[16:01:46.340]                             name <- restart$name
[16:01:46.340]                             if (is.null(name)) 
[16:01:46.340]                               next
[16:01:46.340]                             if (!grepl(pattern, name)) 
[16:01:46.340]                               next
[16:01:46.340]                             invokeRestart(restart)
[16:01:46.340]                             muffled <- TRUE
[16:01:46.340]                             break
[16:01:46.340]                           }
[16:01:46.340]                         }
[16:01:46.340]                       }
[16:01:46.340]                       invisible(muffled)
[16:01:46.340]                     }
[16:01:46.340]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.340]                   }
[16:01:46.340]                 }
[16:01:46.340]                 else {
[16:01:46.340]                   if (TRUE) {
[16:01:46.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.340]                     {
[16:01:46.340]                       inherits <- base::inherits
[16:01:46.340]                       invokeRestart <- base::invokeRestart
[16:01:46.340]                       is.null <- base::is.null
[16:01:46.340]                       muffled <- FALSE
[16:01:46.340]                       if (inherits(cond, "message")) {
[16:01:46.340]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.340]                         if (muffled) 
[16:01:46.340]                           invokeRestart("muffleMessage")
[16:01:46.340]                       }
[16:01:46.340]                       else if (inherits(cond, "warning")) {
[16:01:46.340]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.340]                         if (muffled) 
[16:01:46.340]                           invokeRestart("muffleWarning")
[16:01:46.340]                       }
[16:01:46.340]                       else if (inherits(cond, "condition")) {
[16:01:46.340]                         if (!is.null(pattern)) {
[16:01:46.340]                           computeRestarts <- base::computeRestarts
[16:01:46.340]                           grepl <- base::grepl
[16:01:46.340]                           restarts <- computeRestarts(cond)
[16:01:46.340]                           for (restart in restarts) {
[16:01:46.340]                             name <- restart$name
[16:01:46.340]                             if (is.null(name)) 
[16:01:46.340]                               next
[16:01:46.340]                             if (!grepl(pattern, name)) 
[16:01:46.340]                               next
[16:01:46.340]                             invokeRestart(restart)
[16:01:46.340]                             muffled <- TRUE
[16:01:46.340]                             break
[16:01:46.340]                           }
[16:01:46.340]                         }
[16:01:46.340]                       }
[16:01:46.340]                       invisible(muffled)
[16:01:46.340]                     }
[16:01:46.340]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.340]                   }
[16:01:46.340]                 }
[16:01:46.340]             }
[16:01:46.340]         }))
[16:01:46.340]     }, error = function(ex) {
[16:01:46.340]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.340]                 ...future.rng), started = ...future.startTime, 
[16:01:46.340]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.340]             version = "1.8"), class = "FutureResult")
[16:01:46.340]     }, finally = {
[16:01:46.340]         if (!identical(...future.workdir, getwd())) 
[16:01:46.340]             setwd(...future.workdir)
[16:01:46.340]         {
[16:01:46.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.340]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.340]             }
[16:01:46.340]             base::options(...future.oldOptions)
[16:01:46.340]             if (.Platform$OS.type == "windows") {
[16:01:46.340]                 old_names <- names(...future.oldEnvVars)
[16:01:46.340]                 envs <- base::Sys.getenv()
[16:01:46.340]                 names <- names(envs)
[16:01:46.340]                 common <- intersect(names, old_names)
[16:01:46.340]                 added <- setdiff(names, old_names)
[16:01:46.340]                 removed <- setdiff(old_names, names)
[16:01:46.340]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.340]                   envs[common]]
[16:01:46.340]                 NAMES <- toupper(changed)
[16:01:46.340]                 args <- list()
[16:01:46.340]                 for (kk in seq_along(NAMES)) {
[16:01:46.340]                   name <- changed[[kk]]
[16:01:46.340]                   NAME <- NAMES[[kk]]
[16:01:46.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.340]                     next
[16:01:46.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.340]                 }
[16:01:46.340]                 NAMES <- toupper(added)
[16:01:46.340]                 for (kk in seq_along(NAMES)) {
[16:01:46.340]                   name <- added[[kk]]
[16:01:46.340]                   NAME <- NAMES[[kk]]
[16:01:46.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.340]                     next
[16:01:46.340]                   args[[name]] <- ""
[16:01:46.340]                 }
[16:01:46.340]                 NAMES <- toupper(removed)
[16:01:46.340]                 for (kk in seq_along(NAMES)) {
[16:01:46.340]                   name <- removed[[kk]]
[16:01:46.340]                   NAME <- NAMES[[kk]]
[16:01:46.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.340]                     next
[16:01:46.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.340]                 }
[16:01:46.340]                 if (length(args) > 0) 
[16:01:46.340]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.340]             }
[16:01:46.340]             else {
[16:01:46.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.340]             }
[16:01:46.340]             {
[16:01:46.340]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.340]                   0L) {
[16:01:46.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.340]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.340]                   base::options(opts)
[16:01:46.340]                 }
[16:01:46.340]                 {
[16:01:46.340]                   {
[16:01:46.340]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.340]                     NULL
[16:01:46.340]                   }
[16:01:46.340]                   options(future.plan = NULL)
[16:01:46.340]                   if (is.na(NA_character_)) 
[16:01:46.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.340]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.340]                     envir = parent.frame()) 
[16:01:46.340]                   {
[16:01:46.340]                     default_workers <- missing(workers)
[16:01:46.340]                     if (is.function(workers)) 
[16:01:46.340]                       workers <- workers()
[16:01:46.340]                     workers <- structure(as.integer(workers), 
[16:01:46.340]                       class = class(workers))
[16:01:46.340]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.340]                       1L)
[16:01:46.340]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.340]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.340]                       if (default_workers) 
[16:01:46.340]                         supportsMulticore(warn = TRUE)
[16:01:46.340]                       return(sequential(..., envir = envir))
[16:01:46.340]                     }
[16:01:46.340]                     oopts <- options(mc.cores = workers)
[16:01:46.340]                     on.exit(options(oopts))
[16:01:46.340]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.340]                       envir = envir)
[16:01:46.340]                     if (!future$lazy) 
[16:01:46.340]                       future <- run(future)
[16:01:46.340]                     invisible(future)
[16:01:46.340]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.340]                 }
[16:01:46.340]             }
[16:01:46.340]         }
[16:01:46.340]     })
[16:01:46.340]     if (TRUE) {
[16:01:46.340]         base::sink(type = "output", split = FALSE)
[16:01:46.340]         if (TRUE) {
[16:01:46.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.340]         }
[16:01:46.340]         else {
[16:01:46.340]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.340]         }
[16:01:46.340]         base::close(...future.stdout)
[16:01:46.340]         ...future.stdout <- NULL
[16:01:46.340]     }
[16:01:46.340]     ...future.result$conditions <- ...future.conditions
[16:01:46.340]     ...future.result$finished <- base::Sys.time()
[16:01:46.340]     ...future.result
[16:01:46.340] }
[16:01:46.342] assign_globals() ...
[16:01:46.342] List of 5
[16:01:46.342]  $ ...future.FUN            :function (x, ...)  
[16:01:46.342]  $ future.call.arguments    :List of 1
[16:01:46.342]   ..$ singular.ok: logi FALSE
[16:01:46.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.342]  $ ...future.elements_ii    :List of 1
[16:01:46.342]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.342]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:46.342]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.342]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.342]  $ ...future.seeds_ii       : NULL
[16:01:46.342]  $ ...future.globals.maxSize: NULL
[16:01:46.342]  - attr(*, "where")=List of 5
[16:01:46.342]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.342]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.342]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.342]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.342]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.342]  - attr(*, "resolved")= logi FALSE
[16:01:46.342]  - attr(*, "total_size")= num 5384
[16:01:46.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.342]  - attr(*, "already-done")= logi TRUE
[16:01:46.351] - reassign environment for ‘...future.FUN’
[16:01:46.351] - copied ‘...future.FUN’ to environment
[16:01:46.351] - copied ‘future.call.arguments’ to environment
[16:01:46.351] - copied ‘...future.elements_ii’ to environment
[16:01:46.351] - copied ‘...future.seeds_ii’ to environment
[16:01:46.351] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.351] assign_globals() ... done
[16:01:46.352] requestCore(): workers = 2
[16:01:46.354] MulticoreFuture started
[16:01:46.355] - Launch lazy future ... done
[16:01:46.355] run() for ‘MulticoreFuture’ ... done
[16:01:46.356] Created future:
[16:01:46.356] plan(): Setting new future strategy stack:
[16:01:46.357] List of future strategies:
[16:01:46.357] 1. sequential:
[16:01:46.357]    - args: function (..., envir = parent.frame())
[16:01:46.357]    - tweaked: FALSE
[16:01:46.357]    - call: NULL
[16:01:46.358] plan(): nbrOfWorkers() = 1
[16:01:46.363] plan(): Setting new future strategy stack:
[16:01:46.363] List of future strategies:
[16:01:46.363] 1. multicore:
[16:01:46.363]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.363]    - tweaked: FALSE
[16:01:46.363]    - call: plan(strategy)
[16:01:46.370] plan(): nbrOfWorkers() = 2
[16:01:46.356] MulticoreFuture:
[16:01:46.356] Label: ‘future_by-1’
[16:01:46.356] Expression:
[16:01:46.356] {
[16:01:46.356]     do.call(function(...) {
[16:01:46.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.356]             on.exit(options(oopts), add = TRUE)
[16:01:46.356]         }
[16:01:46.356]         {
[16:01:46.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.356]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.356]             })
[16:01:46.356]         }
[16:01:46.356]     }, args = future.call.arguments)
[16:01:46.356] }
[16:01:46.356] Lazy evaluation: FALSE
[16:01:46.356] Asynchronous evaluation: TRUE
[16:01:46.356] Local evaluation: TRUE
[16:01:46.356] Environment: R_GlobalEnv
[16:01:46.356] Capture standard output: TRUE
[16:01:46.356] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.356] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.356] Packages: 1 packages (‘stats’)
[16:01:46.356] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.356] Resolved: FALSE
[16:01:46.356] Value: <not collected>
[16:01:46.356] Conditions captured: <none>
[16:01:46.356] Early signaling: FALSE
[16:01:46.356] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.356] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.371] Chunk #1 of 2 ... DONE
[16:01:46.371] Chunk #2 of 2 ...
[16:01:46.371]  - Finding globals in 'X' for chunk #2 ...
[16:01:46.372] getGlobalsAndPackages() ...
[16:01:46.372] Searching for globals...
[16:01:46.373] 
[16:01:46.373] Searching for globals ... DONE
[16:01:46.373] - globals: [0] <none>
[16:01:46.373] getGlobalsAndPackages() ... DONE
[16:01:46.374]    + additional globals found: [n=0] 
[16:01:46.374]    + additional namespaces needed: [n=0] 
[16:01:46.374]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:46.374]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.374]  - seeds: <none>
[16:01:46.374]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.375] getGlobalsAndPackages() ...
[16:01:46.375] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.375] Resolving globals: FALSE
[16:01:46.375] Tweak future expression to call with '...' arguments ...
[16:01:46.375] {
[16:01:46.375]     do.call(function(...) {
[16:01:46.375]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.375]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.375]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.375]             on.exit(options(oopts), add = TRUE)
[16:01:46.375]         }
[16:01:46.375]         {
[16:01:46.375]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.375]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.375]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.375]             })
[16:01:46.375]         }
[16:01:46.375]     }, args = future.call.arguments)
[16:01:46.375] }
[16:01:46.376] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.377] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.377] 
[16:01:46.377] getGlobalsAndPackages() ... DONE
[16:01:46.378] run() for ‘Future’ ...
[16:01:46.378] - state: ‘created’
[16:01:46.378] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.383] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.383]   - Field: ‘label’
[16:01:46.383]   - Field: ‘local’
[16:01:46.384]   - Field: ‘owner’
[16:01:46.384]   - Field: ‘envir’
[16:01:46.384]   - Field: ‘workers’
[16:01:46.384]   - Field: ‘packages’
[16:01:46.384]   - Field: ‘gc’
[16:01:46.384]   - Field: ‘job’
[16:01:46.384]   - Field: ‘conditions’
[16:01:46.384]   - Field: ‘expr’
[16:01:46.385]   - Field: ‘uuid’
[16:01:46.385]   - Field: ‘seed’
[16:01:46.385]   - Field: ‘version’
[16:01:46.385]   - Field: ‘result’
[16:01:46.385]   - Field: ‘asynchronous’
[16:01:46.385]   - Field: ‘calls’
[16:01:46.385]   - Field: ‘globals’
[16:01:46.385]   - Field: ‘stdout’
[16:01:46.386]   - Field: ‘earlySignal’
[16:01:46.386]   - Field: ‘lazy’
[16:01:46.386]   - Field: ‘state’
[16:01:46.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.386] - Launch lazy future ...
[16:01:46.386] Packages needed by the future expression (n = 1): ‘stats’
[16:01:46.387] Packages needed by future strategies (n = 0): <none>
[16:01:46.387] {
[16:01:46.387]     {
[16:01:46.387]         {
[16:01:46.387]             ...future.startTime <- base::Sys.time()
[16:01:46.387]             {
[16:01:46.387]                 {
[16:01:46.387]                   {
[16:01:46.387]                     {
[16:01:46.387]                       {
[16:01:46.387]                         base::local({
[16:01:46.387]                           has_future <- base::requireNamespace("future", 
[16:01:46.387]                             quietly = TRUE)
[16:01:46.387]                           if (has_future) {
[16:01:46.387]                             ns <- base::getNamespace("future")
[16:01:46.387]                             version <- ns[[".package"]][["version"]]
[16:01:46.387]                             if (is.null(version)) 
[16:01:46.387]                               version <- utils::packageVersion("future")
[16:01:46.387]                           }
[16:01:46.387]                           else {
[16:01:46.387]                             version <- NULL
[16:01:46.387]                           }
[16:01:46.387]                           if (!has_future || version < "1.8.0") {
[16:01:46.387]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.387]                               "", base::R.version$version.string), 
[16:01:46.387]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:46.387]                                 base::R.version$platform, 8 * 
[16:01:46.387]                                   base::.Machine$sizeof.pointer), 
[16:01:46.387]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.387]                                 "release", "version")], collapse = " "), 
[16:01:46.387]                               hostname = base::Sys.info()[["nodename"]])
[16:01:46.387]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.387]                               info)
[16:01:46.387]                             info <- base::paste(info, collapse = "; ")
[16:01:46.387]                             if (!has_future) {
[16:01:46.387]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.387]                                 info)
[16:01:46.387]                             }
[16:01:46.387]                             else {
[16:01:46.387]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.387]                                 info, version)
[16:01:46.387]                             }
[16:01:46.387]                             base::stop(msg)
[16:01:46.387]                           }
[16:01:46.387]                         })
[16:01:46.387]                       }
[16:01:46.387]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.387]                       base::options(mc.cores = 1L)
[16:01:46.387]                     }
[16:01:46.387]                     base::local({
[16:01:46.387]                       for (pkg in "stats") {
[16:01:46.387]                         base::loadNamespace(pkg)
[16:01:46.387]                         base::library(pkg, character.only = TRUE)
[16:01:46.387]                       }
[16:01:46.387]                     })
[16:01:46.387]                   }
[16:01:46.387]                   options(future.plan = NULL)
[16:01:46.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.387]                 }
[16:01:46.387]                 ...future.workdir <- getwd()
[16:01:46.387]             }
[16:01:46.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.387]         }
[16:01:46.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.387]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.387]             base::names(...future.oldOptions))
[16:01:46.387]     }
[16:01:46.387]     if (FALSE) {
[16:01:46.387]     }
[16:01:46.387]     else {
[16:01:46.387]         if (TRUE) {
[16:01:46.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.387]                 open = "w")
[16:01:46.387]         }
[16:01:46.387]         else {
[16:01:46.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.387]         }
[16:01:46.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.387]             base::sink(type = "output", split = FALSE)
[16:01:46.387]             base::close(...future.stdout)
[16:01:46.387]         }, add = TRUE)
[16:01:46.387]     }
[16:01:46.387]     ...future.frame <- base::sys.nframe()
[16:01:46.387]     ...future.conditions <- base::list()
[16:01:46.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.387]     if (FALSE) {
[16:01:46.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.387]     }
[16:01:46.387]     ...future.result <- base::tryCatch({
[16:01:46.387]         base::withCallingHandlers({
[16:01:46.387]             ...future.value <- base::withVisible(base::local({
[16:01:46.387]                 withCallingHandlers({
[16:01:46.387]                   {
[16:01:46.387]                     do.call(function(...) {
[16:01:46.387]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.387]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.387]                         ...future.globals.maxSize)) {
[16:01:46.387]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.387]                         on.exit(options(oopts), add = TRUE)
[16:01:46.387]                       }
[16:01:46.387]                       {
[16:01:46.387]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.387]                           FUN = function(jj) {
[16:01:46.387]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.387]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.387]                           })
[16:01:46.387]                       }
[16:01:46.387]                     }, args = future.call.arguments)
[16:01:46.387]                   }
[16:01:46.387]                 }, immediateCondition = function(cond) {
[16:01:46.387]                   save_rds <- function (object, pathname, ...) 
[16:01:46.387]                   {
[16:01:46.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.387]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.387]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.387]                         fi_tmp[["mtime"]])
[16:01:46.387]                     }
[16:01:46.387]                     tryCatch({
[16:01:46.387]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.387]                     }, error = function(ex) {
[16:01:46.387]                       msg <- conditionMessage(ex)
[16:01:46.387]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.387]                         fi_tmp[["mtime"]], msg)
[16:01:46.387]                       ex$message <- msg
[16:01:46.387]                       stop(ex)
[16:01:46.387]                     })
[16:01:46.387]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.387]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.387]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.387]                       fi <- file.info(pathname)
[16:01:46.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.387]                         fi[["size"]], fi[["mtime"]])
[16:01:46.387]                       stop(msg)
[16:01:46.387]                     }
[16:01:46.387]                     invisible(pathname)
[16:01:46.387]                   }
[16:01:46.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.387]                     rootPath = tempdir()) 
[16:01:46.387]                   {
[16:01:46.387]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.387]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.387]                       tmpdir = path, fileext = ".rds")
[16:01:46.387]                     save_rds(obj, file)
[16:01:46.387]                   }
[16:01:46.387]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.387]                   {
[16:01:46.387]                     inherits <- base::inherits
[16:01:46.387]                     invokeRestart <- base::invokeRestart
[16:01:46.387]                     is.null <- base::is.null
[16:01:46.387]                     muffled <- FALSE
[16:01:46.387]                     if (inherits(cond, "message")) {
[16:01:46.387]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.387]                       if (muffled) 
[16:01:46.387]                         invokeRestart("muffleMessage")
[16:01:46.387]                     }
[16:01:46.387]                     else if (inherits(cond, "warning")) {
[16:01:46.387]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.387]                       if (muffled) 
[16:01:46.387]                         invokeRestart("muffleWarning")
[16:01:46.387]                     }
[16:01:46.387]                     else if (inherits(cond, "condition")) {
[16:01:46.387]                       if (!is.null(pattern)) {
[16:01:46.387]                         computeRestarts <- base::computeRestarts
[16:01:46.387]                         grepl <- base::grepl
[16:01:46.387]                         restarts <- computeRestarts(cond)
[16:01:46.387]                         for (restart in restarts) {
[16:01:46.387]                           name <- restart$name
[16:01:46.387]                           if (is.null(name)) 
[16:01:46.387]                             next
[16:01:46.387]                           if (!grepl(pattern, name)) 
[16:01:46.387]                             next
[16:01:46.387]                           invokeRestart(restart)
[16:01:46.387]                           muffled <- TRUE
[16:01:46.387]                           break
[16:01:46.387]                         }
[16:01:46.387]                       }
[16:01:46.387]                     }
[16:01:46.387]                     invisible(muffled)
[16:01:46.387]                   }
[16:01:46.387]                   muffleCondition(cond)
[16:01:46.387]                 })
[16:01:46.387]             }))
[16:01:46.387]             future::FutureResult(value = ...future.value$value, 
[16:01:46.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.387]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.387]                     ...future.globalenv.names))
[16:01:46.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.387]         }, condition = base::local({
[16:01:46.387]             c <- base::c
[16:01:46.387]             inherits <- base::inherits
[16:01:46.387]             invokeRestart <- base::invokeRestart
[16:01:46.387]             length <- base::length
[16:01:46.387]             list <- base::list
[16:01:46.387]             seq.int <- base::seq.int
[16:01:46.387]             signalCondition <- base::signalCondition
[16:01:46.387]             sys.calls <- base::sys.calls
[16:01:46.387]             `[[` <- base::`[[`
[16:01:46.387]             `+` <- base::`+`
[16:01:46.387]             `<<-` <- base::`<<-`
[16:01:46.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.387]                   3L)]
[16:01:46.387]             }
[16:01:46.387]             function(cond) {
[16:01:46.387]                 is_error <- inherits(cond, "error")
[16:01:46.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.387]                   NULL)
[16:01:46.387]                 if (is_error) {
[16:01:46.387]                   sessionInformation <- function() {
[16:01:46.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.387]                       search = base::search(), system = base::Sys.info())
[16:01:46.387]                   }
[16:01:46.387]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.387]                     cond$call), session = sessionInformation(), 
[16:01:46.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.387]                   signalCondition(cond)
[16:01:46.387]                 }
[16:01:46.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.387]                 "immediateCondition"))) {
[16:01:46.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.387]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.387]                   if (TRUE && !signal) {
[16:01:46.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.387]                     {
[16:01:46.387]                       inherits <- base::inherits
[16:01:46.387]                       invokeRestart <- base::invokeRestart
[16:01:46.387]                       is.null <- base::is.null
[16:01:46.387]                       muffled <- FALSE
[16:01:46.387]                       if (inherits(cond, "message")) {
[16:01:46.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.387]                         if (muffled) 
[16:01:46.387]                           invokeRestart("muffleMessage")
[16:01:46.387]                       }
[16:01:46.387]                       else if (inherits(cond, "warning")) {
[16:01:46.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.387]                         if (muffled) 
[16:01:46.387]                           invokeRestart("muffleWarning")
[16:01:46.387]                       }
[16:01:46.387]                       else if (inherits(cond, "condition")) {
[16:01:46.387]                         if (!is.null(pattern)) {
[16:01:46.387]                           computeRestarts <- base::computeRestarts
[16:01:46.387]                           grepl <- base::grepl
[16:01:46.387]                           restarts <- computeRestarts(cond)
[16:01:46.387]                           for (restart in restarts) {
[16:01:46.387]                             name <- restart$name
[16:01:46.387]                             if (is.null(name)) 
[16:01:46.387]                               next
[16:01:46.387]                             if (!grepl(pattern, name)) 
[16:01:46.387]                               next
[16:01:46.387]                             invokeRestart(restart)
[16:01:46.387]                             muffled <- TRUE
[16:01:46.387]                             break
[16:01:46.387]                           }
[16:01:46.387]                         }
[16:01:46.387]                       }
[16:01:46.387]                       invisible(muffled)
[16:01:46.387]                     }
[16:01:46.387]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.387]                   }
[16:01:46.387]                 }
[16:01:46.387]                 else {
[16:01:46.387]                   if (TRUE) {
[16:01:46.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.387]                     {
[16:01:46.387]                       inherits <- base::inherits
[16:01:46.387]                       invokeRestart <- base::invokeRestart
[16:01:46.387]                       is.null <- base::is.null
[16:01:46.387]                       muffled <- FALSE
[16:01:46.387]                       if (inherits(cond, "message")) {
[16:01:46.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.387]                         if (muffled) 
[16:01:46.387]                           invokeRestart("muffleMessage")
[16:01:46.387]                       }
[16:01:46.387]                       else if (inherits(cond, "warning")) {
[16:01:46.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.387]                         if (muffled) 
[16:01:46.387]                           invokeRestart("muffleWarning")
[16:01:46.387]                       }
[16:01:46.387]                       else if (inherits(cond, "condition")) {
[16:01:46.387]                         if (!is.null(pattern)) {
[16:01:46.387]                           computeRestarts <- base::computeRestarts
[16:01:46.387]                           grepl <- base::grepl
[16:01:46.387]                           restarts <- computeRestarts(cond)
[16:01:46.387]                           for (restart in restarts) {
[16:01:46.387]                             name <- restart$name
[16:01:46.387]                             if (is.null(name)) 
[16:01:46.387]                               next
[16:01:46.387]                             if (!grepl(pattern, name)) 
[16:01:46.387]                               next
[16:01:46.387]                             invokeRestart(restart)
[16:01:46.387]                             muffled <- TRUE
[16:01:46.387]                             break
[16:01:46.387]                           }
[16:01:46.387]                         }
[16:01:46.387]                       }
[16:01:46.387]                       invisible(muffled)
[16:01:46.387]                     }
[16:01:46.387]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.387]                   }
[16:01:46.387]                 }
[16:01:46.387]             }
[16:01:46.387]         }))
[16:01:46.387]     }, error = function(ex) {
[16:01:46.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.387]                 ...future.rng), started = ...future.startTime, 
[16:01:46.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.387]             version = "1.8"), class = "FutureResult")
[16:01:46.387]     }, finally = {
[16:01:46.387]         if (!identical(...future.workdir, getwd())) 
[16:01:46.387]             setwd(...future.workdir)
[16:01:46.387]         {
[16:01:46.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.387]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.387]             }
[16:01:46.387]             base::options(...future.oldOptions)
[16:01:46.387]             if (.Platform$OS.type == "windows") {
[16:01:46.387]                 old_names <- names(...future.oldEnvVars)
[16:01:46.387]                 envs <- base::Sys.getenv()
[16:01:46.387]                 names <- names(envs)
[16:01:46.387]                 common <- intersect(names, old_names)
[16:01:46.387]                 added <- setdiff(names, old_names)
[16:01:46.387]                 removed <- setdiff(old_names, names)
[16:01:46.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.387]                   envs[common]]
[16:01:46.387]                 NAMES <- toupper(changed)
[16:01:46.387]                 args <- list()
[16:01:46.387]                 for (kk in seq_along(NAMES)) {
[16:01:46.387]                   name <- changed[[kk]]
[16:01:46.387]                   NAME <- NAMES[[kk]]
[16:01:46.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.387]                     next
[16:01:46.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.387]                 }
[16:01:46.387]                 NAMES <- toupper(added)
[16:01:46.387]                 for (kk in seq_along(NAMES)) {
[16:01:46.387]                   name <- added[[kk]]
[16:01:46.387]                   NAME <- NAMES[[kk]]
[16:01:46.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.387]                     next
[16:01:46.387]                   args[[name]] <- ""
[16:01:46.387]                 }
[16:01:46.387]                 NAMES <- toupper(removed)
[16:01:46.387]                 for (kk in seq_along(NAMES)) {
[16:01:46.387]                   name <- removed[[kk]]
[16:01:46.387]                   NAME <- NAMES[[kk]]
[16:01:46.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.387]                     next
[16:01:46.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.387]                 }
[16:01:46.387]                 if (length(args) > 0) 
[16:01:46.387]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.387]             }
[16:01:46.387]             else {
[16:01:46.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.387]             }
[16:01:46.387]             {
[16:01:46.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.387]                   0L) {
[16:01:46.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.387]                   base::options(opts)
[16:01:46.387]                 }
[16:01:46.387]                 {
[16:01:46.387]                   {
[16:01:46.387]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.387]                     NULL
[16:01:46.387]                   }
[16:01:46.387]                   options(future.plan = NULL)
[16:01:46.387]                   if (is.na(NA_character_)) 
[16:01:46.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.387]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.387]                     envir = parent.frame()) 
[16:01:46.387]                   {
[16:01:46.387]                     default_workers <- missing(workers)
[16:01:46.387]                     if (is.function(workers)) 
[16:01:46.387]                       workers <- workers()
[16:01:46.387]                     workers <- structure(as.integer(workers), 
[16:01:46.387]                       class = class(workers))
[16:01:46.387]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.387]                       1L)
[16:01:46.387]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.387]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.387]                       if (default_workers) 
[16:01:46.387]                         supportsMulticore(warn = TRUE)
[16:01:46.387]                       return(sequential(..., envir = envir))
[16:01:46.387]                     }
[16:01:46.387]                     oopts <- options(mc.cores = workers)
[16:01:46.387]                     on.exit(options(oopts))
[16:01:46.387]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.387]                       envir = envir)
[16:01:46.387]                     if (!future$lazy) 
[16:01:46.387]                       future <- run(future)
[16:01:46.387]                     invisible(future)
[16:01:46.387]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.387]                 }
[16:01:46.387]             }
[16:01:46.387]         }
[16:01:46.387]     })
[16:01:46.387]     if (TRUE) {
[16:01:46.387]         base::sink(type = "output", split = FALSE)
[16:01:46.387]         if (TRUE) {
[16:01:46.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.387]         }
[16:01:46.387]         else {
[16:01:46.387]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.387]         }
[16:01:46.387]         base::close(...future.stdout)
[16:01:46.387]         ...future.stdout <- NULL
[16:01:46.387]     }
[16:01:46.387]     ...future.result$conditions <- ...future.conditions
[16:01:46.387]     ...future.result$finished <- base::Sys.time()
[16:01:46.387]     ...future.result
[16:01:46.387] }
[16:01:46.391] assign_globals() ...
[16:01:46.391] List of 5
[16:01:46.391]  $ ...future.FUN            :function (x, ...)  
[16:01:46.391]  $ future.call.arguments    :List of 1
[16:01:46.391]   ..$ singular.ok: logi FALSE
[16:01:46.391]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.391]  $ ...future.elements_ii    :List of 2
[16:01:46.391]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.391]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:46.391]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.391]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:46.391]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.391]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:46.391]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.391]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:46.391]  $ ...future.seeds_ii       : NULL
[16:01:46.391]  $ ...future.globals.maxSize: NULL
[16:01:46.391]  - attr(*, "where")=List of 5
[16:01:46.391]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.391]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.391]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.391]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.391]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.391]  - attr(*, "resolved")= logi FALSE
[16:01:46.391]  - attr(*, "total_size")= num 5384
[16:01:46.391]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.391]  - attr(*, "already-done")= logi TRUE
[16:01:46.403] - reassign environment for ‘...future.FUN’
[16:01:46.403] - copied ‘...future.FUN’ to environment
[16:01:46.403] - copied ‘future.call.arguments’ to environment
[16:01:46.403] - copied ‘...future.elements_ii’ to environment
[16:01:46.403] - copied ‘...future.seeds_ii’ to environment
[16:01:46.403] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.403] assign_globals() ... done
[16:01:46.404] requestCore(): workers = 2
[16:01:46.406] MulticoreFuture started
[16:01:46.407] - Launch lazy future ... done
[16:01:46.407] run() for ‘MulticoreFuture’ ... done
[16:01:46.408] Created future:
[16:01:46.408] plan(): Setting new future strategy stack:
[16:01:46.408] List of future strategies:
[16:01:46.408] 1. sequential:
[16:01:46.408]    - args: function (..., envir = parent.frame())
[16:01:46.408]    - tweaked: FALSE
[16:01:46.408]    - call: NULL
[16:01:46.410] plan(): nbrOfWorkers() = 1
[16:01:46.417] plan(): Setting new future strategy stack:
[16:01:46.417] List of future strategies:
[16:01:46.417] 1. multicore:
[16:01:46.417]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.417]    - tweaked: FALSE
[16:01:46.417]    - call: plan(strategy)
[16:01:46.408] MulticoreFuture:
[16:01:46.408] Label: ‘future_by-2’
[16:01:46.408] Expression:
[16:01:46.408] {
[16:01:46.408]     do.call(function(...) {
[16:01:46.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.408]             on.exit(options(oopts), add = TRUE)
[16:01:46.408]         }
[16:01:46.408]         {
[16:01:46.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.408]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.408]             })
[16:01:46.408]         }
[16:01:46.408]     }, args = future.call.arguments)
[16:01:46.408] }
[16:01:46.408] Lazy evaluation: FALSE
[16:01:46.408] Asynchronous evaluation: TRUE
[16:01:46.408] Local evaluation: TRUE
[16:01:46.408] Environment: R_GlobalEnv
[16:01:46.408] Capture standard output: TRUE
[16:01:46.408] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.408] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.408] Packages: 1 packages (‘stats’)
[16:01:46.408] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.408] Resolved: FALSE
[16:01:46.408] Value: <not collected>
[16:01:46.408] Conditions captured: <none>
[16:01:46.408] Early signaling: FALSE
[16:01:46.408] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.408] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.423] plan(): nbrOfWorkers() = 2
[16:01:46.423] Chunk #2 of 2 ... DONE
[16:01:46.423] Launching 2 futures (chunks) ... DONE
[16:01:46.424] Resolving 2 futures (chunks) ...
[16:01:46.424] resolve() on list ...
[16:01:46.424]  recursive: 0
[16:01:46.424]  length: 2
[16:01:46.424] 
[16:01:46.425] Future #1
[16:01:46.425] result() for MulticoreFuture ...
[16:01:46.427] result() for MulticoreFuture ...
[16:01:46.427] result() for MulticoreFuture ... done
[16:01:46.427] result() for MulticoreFuture ... done
[16:01:46.427] result() for MulticoreFuture ...
[16:01:46.427] result() for MulticoreFuture ... done
[16:01:46.428] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:46.428] - nx: 2
[16:01:46.428] - relay: TRUE
[16:01:46.428] - stdout: TRUE
[16:01:46.428] - signal: TRUE
[16:01:46.428] - resignal: FALSE
[16:01:46.428] - force: TRUE
[16:01:46.428] - relayed: [n=2] FALSE, FALSE
[16:01:46.429] - queued futures: [n=2] FALSE, FALSE
[16:01:46.429]  - until=1
[16:01:46.429]  - relaying element #1
[16:01:46.429] result() for MulticoreFuture ...
[16:01:46.429] result() for MulticoreFuture ... done
[16:01:46.429] result() for MulticoreFuture ...
[16:01:46.430] result() for MulticoreFuture ... done
[16:01:46.430] result() for MulticoreFuture ...
[16:01:46.430] result() for MulticoreFuture ... done
[16:01:46.430] result() for MulticoreFuture ...
[16:01:46.430] result() for MulticoreFuture ... done
[16:01:46.430] - relayed: [n=2] TRUE, FALSE
[16:01:46.431] - queued futures: [n=2] TRUE, FALSE
[16:01:46.431] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:46.431]  length: 1 (resolved future 1)
[16:01:46.431] Future #2
[16:01:46.431] result() for MulticoreFuture ...
[16:01:46.433] result() for MulticoreFuture ...
[16:01:46.433] result() for MulticoreFuture ... done
[16:01:46.433] result() for MulticoreFuture ... done
[16:01:46.433] result() for MulticoreFuture ...
[16:01:46.433] result() for MulticoreFuture ... done
[16:01:46.433] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:46.433] - nx: 2
[16:01:46.433] - relay: TRUE
[16:01:46.434] - stdout: TRUE
[16:01:46.434] - signal: TRUE
[16:01:46.434] - resignal: FALSE
[16:01:46.434] - force: TRUE
[16:01:46.434] - relayed: [n=2] TRUE, FALSE
[16:01:46.434] - queued futures: [n=2] TRUE, FALSE
[16:01:46.434]  - until=2
[16:01:46.434]  - relaying element #2
[16:01:46.435] result() for MulticoreFuture ...
[16:01:46.435] result() for MulticoreFuture ... done
[16:01:46.435] result() for MulticoreFuture ...
[16:01:46.435] result() for MulticoreFuture ... done
[16:01:46.435] result() for MulticoreFuture ...
[16:01:46.435] result() for MulticoreFuture ... done
[16:01:46.435] result() for MulticoreFuture ...
[16:01:46.435] result() for MulticoreFuture ... done
[16:01:46.436] - relayed: [n=2] TRUE, TRUE
[16:01:46.436] - queued futures: [n=2] TRUE, TRUE
[16:01:46.436] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:46.436]  length: 0 (resolved future 2)
[16:01:46.436] Relaying remaining futures
[16:01:46.436] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.436] - nx: 2
[16:01:46.436] - relay: TRUE
[16:01:46.436] - stdout: TRUE
[16:01:46.436] - signal: TRUE
[16:01:46.437] - resignal: FALSE
[16:01:46.437] - force: TRUE
[16:01:46.437] - relayed: [n=2] TRUE, TRUE
[16:01:46.437] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:46.437] - relayed: [n=2] TRUE, TRUE
[16:01:46.437] - queued futures: [n=2] TRUE, TRUE
[16:01:46.437] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.437] resolve() on list ... DONE
[16:01:46.437] result() for MulticoreFuture ...
[16:01:46.438] result() for MulticoreFuture ... done
[16:01:46.438] result() for MulticoreFuture ...
[16:01:46.438] result() for MulticoreFuture ... done
[16:01:46.438] result() for MulticoreFuture ...
[16:01:46.438] result() for MulticoreFuture ... done
[16:01:46.438] result() for MulticoreFuture ...
[16:01:46.438] result() for MulticoreFuture ... done
[16:01:46.438]  - Number of value chunks collected: 2
[16:01:46.438] Resolving 2 futures (chunks) ... DONE
[16:01:46.439] Reducing values from 2 chunks ...
[16:01:46.439]  - Number of values collected after concatenation: 3
[16:01:46.439]  - Number of values expected: 3
[16:01:46.439] Reducing values from 2 chunks ... DONE
[16:01:46.439] future_lapply() ... DONE
[16:01:46.439] future_by_internal() ... DONE
[16:01:46.447] future_by_internal() ...
[16:01:46.447] future_lapply() ...
[16:01:46.453] Number of chunks: 2
[16:01:46.453] getGlobalsAndPackagesXApply() ...
[16:01:46.453]  - future.globals: TRUE
[16:01:46.453] getGlobalsAndPackages() ...
[16:01:46.453] Searching for globals...
[16:01:46.455] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:46.456] Searching for globals ... DONE
[16:01:46.456] Resolving globals: FALSE
[16:01:46.456] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:01:46.457] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:01:46.457] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:46.457] - packages: [1] ‘stats’
[16:01:46.457] getGlobalsAndPackages() ... DONE
[16:01:46.457]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:46.457]  - needed namespaces: [n=1] ‘stats’
[16:01:46.457] Finding globals ... DONE
[16:01:46.457]  - use_args: TRUE
[16:01:46.458]  - Getting '...' globals ...
[16:01:46.458] resolve() on list ...
[16:01:46.458]  recursive: 0
[16:01:46.458]  length: 1
[16:01:46.458]  elements: ‘...’
[16:01:46.458]  length: 0 (resolved future 1)
[16:01:46.458] resolve() on list ... DONE
[16:01:46.458]    - '...' content: [n=0] 
[16:01:46.459] List of 1
[16:01:46.459]  $ ...: list()
[16:01:46.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.459]  - attr(*, "where")=List of 1
[16:01:46.459]   ..$ ...:<environment: 0x55b5239a8518> 
[16:01:46.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.459]  - attr(*, "resolved")= logi TRUE
[16:01:46.459]  - attr(*, "total_size")= num NA
[16:01:46.461]  - Getting '...' globals ... DONE
[16:01:46.461] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:01:46.462] List of 4
[16:01:46.462]  $ ...future.FUN:function (x)  
[16:01:46.462]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:46.462]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.462]  $ ...          : list()
[16:01:46.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.462]  - attr(*, "where")=List of 4
[16:01:46.462]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.462]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:01:46.462]   ..$ wool         :<environment: R_EmptyEnv> 
[16:01:46.462]   ..$ ...          :<environment: 0x55b5239a8518> 
[16:01:46.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.462]  - attr(*, "resolved")= logi FALSE
[16:01:46.462]  - attr(*, "total_size")= num 2320
[16:01:46.468] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:46.468] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.468] Number of futures (= number of chunks): 2
[16:01:46.468] Launching 2 futures (chunks) ...
[16:01:46.468] Chunk #1 of 2 ...
[16:01:46.468]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.469] getGlobalsAndPackages() ...
[16:01:46.469] Searching for globals...
[16:01:46.469] 
[16:01:46.469] Searching for globals ... DONE
[16:01:46.469] - globals: [0] <none>
[16:01:46.469] getGlobalsAndPackages() ... DONE
[16:01:46.470]    + additional globals found: [n=0] 
[16:01:46.470]    + additional namespaces needed: [n=0] 
[16:01:46.470]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.470]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.470]  - seeds: <none>
[16:01:46.470]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.470] getGlobalsAndPackages() ...
[16:01:46.470] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.471] Resolving globals: FALSE
[16:01:46.471] Tweak future expression to call with '...' arguments ...
[16:01:46.471] {
[16:01:46.471]     do.call(function(...) {
[16:01:46.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.471]             on.exit(options(oopts), add = TRUE)
[16:01:46.471]         }
[16:01:46.471]         {
[16:01:46.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.471]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.471]             })
[16:01:46.471]         }
[16:01:46.471]     }, args = future.call.arguments)
[16:01:46.471] }
[16:01:46.471] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.472] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.472] 
[16:01:46.472] getGlobalsAndPackages() ... DONE
[16:01:46.472] run() for ‘Future’ ...
[16:01:46.472] - state: ‘created’
[16:01:46.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.477]   - Field: ‘label’
[16:01:46.477]   - Field: ‘local’
[16:01:46.477]   - Field: ‘owner’
[16:01:46.477]   - Field: ‘envir’
[16:01:46.477]   - Field: ‘workers’
[16:01:46.478]   - Field: ‘packages’
[16:01:46.478]   - Field: ‘gc’
[16:01:46.478]   - Field: ‘job’
[16:01:46.478]   - Field: ‘conditions’
[16:01:46.478]   - Field: ‘expr’
[16:01:46.478]   - Field: ‘uuid’
[16:01:46.478]   - Field: ‘seed’
[16:01:46.478]   - Field: ‘version’
[16:01:46.478]   - Field: ‘result’
[16:01:46.478]   - Field: ‘asynchronous’
[16:01:46.478]   - Field: ‘calls’
[16:01:46.479]   - Field: ‘globals’
[16:01:46.479]   - Field: ‘stdout’
[16:01:46.479]   - Field: ‘earlySignal’
[16:01:46.479]   - Field: ‘lazy’
[16:01:46.479]   - Field: ‘state’
[16:01:46.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.479] - Launch lazy future ...
[16:01:46.480] Packages needed by the future expression (n = 1): ‘stats’
[16:01:46.480] Packages needed by future strategies (n = 0): <none>
[16:01:46.480] {
[16:01:46.480]     {
[16:01:46.480]         {
[16:01:46.480]             ...future.startTime <- base::Sys.time()
[16:01:46.480]             {
[16:01:46.480]                 {
[16:01:46.480]                   {
[16:01:46.480]                     {
[16:01:46.480]                       {
[16:01:46.480]                         base::local({
[16:01:46.480]                           has_future <- base::requireNamespace("future", 
[16:01:46.480]                             quietly = TRUE)
[16:01:46.480]                           if (has_future) {
[16:01:46.480]                             ns <- base::getNamespace("future")
[16:01:46.480]                             version <- ns[[".package"]][["version"]]
[16:01:46.480]                             if (is.null(version)) 
[16:01:46.480]                               version <- utils::packageVersion("future")
[16:01:46.480]                           }
[16:01:46.480]                           else {
[16:01:46.480]                             version <- NULL
[16:01:46.480]                           }
[16:01:46.480]                           if (!has_future || version < "1.8.0") {
[16:01:46.480]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.480]                               "", base::R.version$version.string), 
[16:01:46.480]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:46.480]                                 base::R.version$platform, 8 * 
[16:01:46.480]                                   base::.Machine$sizeof.pointer), 
[16:01:46.480]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.480]                                 "release", "version")], collapse = " "), 
[16:01:46.480]                               hostname = base::Sys.info()[["nodename"]])
[16:01:46.480]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.480]                               info)
[16:01:46.480]                             info <- base::paste(info, collapse = "; ")
[16:01:46.480]                             if (!has_future) {
[16:01:46.480]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.480]                                 info)
[16:01:46.480]                             }
[16:01:46.480]                             else {
[16:01:46.480]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.480]                                 info, version)
[16:01:46.480]                             }
[16:01:46.480]                             base::stop(msg)
[16:01:46.480]                           }
[16:01:46.480]                         })
[16:01:46.480]                       }
[16:01:46.480]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.480]                       base::options(mc.cores = 1L)
[16:01:46.480]                     }
[16:01:46.480]                     base::local({
[16:01:46.480]                       for (pkg in "stats") {
[16:01:46.480]                         base::loadNamespace(pkg)
[16:01:46.480]                         base::library(pkg, character.only = TRUE)
[16:01:46.480]                       }
[16:01:46.480]                     })
[16:01:46.480]                   }
[16:01:46.480]                   options(future.plan = NULL)
[16:01:46.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.480]                 }
[16:01:46.480]                 ...future.workdir <- getwd()
[16:01:46.480]             }
[16:01:46.480]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.480]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.480]         }
[16:01:46.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.480]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.480]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.480]             base::names(...future.oldOptions))
[16:01:46.480]     }
[16:01:46.480]     if (FALSE) {
[16:01:46.480]     }
[16:01:46.480]     else {
[16:01:46.480]         if (TRUE) {
[16:01:46.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.480]                 open = "w")
[16:01:46.480]         }
[16:01:46.480]         else {
[16:01:46.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.480]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.480]         }
[16:01:46.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.480]             base::sink(type = "output", split = FALSE)
[16:01:46.480]             base::close(...future.stdout)
[16:01:46.480]         }, add = TRUE)
[16:01:46.480]     }
[16:01:46.480]     ...future.frame <- base::sys.nframe()
[16:01:46.480]     ...future.conditions <- base::list()
[16:01:46.480]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.480]     if (FALSE) {
[16:01:46.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.480]     }
[16:01:46.480]     ...future.result <- base::tryCatch({
[16:01:46.480]         base::withCallingHandlers({
[16:01:46.480]             ...future.value <- base::withVisible(base::local({
[16:01:46.480]                 withCallingHandlers({
[16:01:46.480]                   {
[16:01:46.480]                     do.call(function(...) {
[16:01:46.480]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.480]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.480]                         ...future.globals.maxSize)) {
[16:01:46.480]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.480]                         on.exit(options(oopts), add = TRUE)
[16:01:46.480]                       }
[16:01:46.480]                       {
[16:01:46.480]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.480]                           FUN = function(jj) {
[16:01:46.480]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.480]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.480]                           })
[16:01:46.480]                       }
[16:01:46.480]                     }, args = future.call.arguments)
[16:01:46.480]                   }
[16:01:46.480]                 }, immediateCondition = function(cond) {
[16:01:46.480]                   save_rds <- function (object, pathname, ...) 
[16:01:46.480]                   {
[16:01:46.480]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.480]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.480]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.480]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.480]                         fi_tmp[["mtime"]])
[16:01:46.480]                     }
[16:01:46.480]                     tryCatch({
[16:01:46.480]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.480]                     }, error = function(ex) {
[16:01:46.480]                       msg <- conditionMessage(ex)
[16:01:46.480]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.480]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.480]                         fi_tmp[["mtime"]], msg)
[16:01:46.480]                       ex$message <- msg
[16:01:46.480]                       stop(ex)
[16:01:46.480]                     })
[16:01:46.480]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.480]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.480]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.480]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.480]                       fi <- file.info(pathname)
[16:01:46.480]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.480]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.480]                         fi[["size"]], fi[["mtime"]])
[16:01:46.480]                       stop(msg)
[16:01:46.480]                     }
[16:01:46.480]                     invisible(pathname)
[16:01:46.480]                   }
[16:01:46.480]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.480]                     rootPath = tempdir()) 
[16:01:46.480]                   {
[16:01:46.480]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.480]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.480]                       tmpdir = path, fileext = ".rds")
[16:01:46.480]                     save_rds(obj, file)
[16:01:46.480]                   }
[16:01:46.480]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.480]                   {
[16:01:46.480]                     inherits <- base::inherits
[16:01:46.480]                     invokeRestart <- base::invokeRestart
[16:01:46.480]                     is.null <- base::is.null
[16:01:46.480]                     muffled <- FALSE
[16:01:46.480]                     if (inherits(cond, "message")) {
[16:01:46.480]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.480]                       if (muffled) 
[16:01:46.480]                         invokeRestart("muffleMessage")
[16:01:46.480]                     }
[16:01:46.480]                     else if (inherits(cond, "warning")) {
[16:01:46.480]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.480]                       if (muffled) 
[16:01:46.480]                         invokeRestart("muffleWarning")
[16:01:46.480]                     }
[16:01:46.480]                     else if (inherits(cond, "condition")) {
[16:01:46.480]                       if (!is.null(pattern)) {
[16:01:46.480]                         computeRestarts <- base::computeRestarts
[16:01:46.480]                         grepl <- base::grepl
[16:01:46.480]                         restarts <- computeRestarts(cond)
[16:01:46.480]                         for (restart in restarts) {
[16:01:46.480]                           name <- restart$name
[16:01:46.480]                           if (is.null(name)) 
[16:01:46.480]                             next
[16:01:46.480]                           if (!grepl(pattern, name)) 
[16:01:46.480]                             next
[16:01:46.480]                           invokeRestart(restart)
[16:01:46.480]                           muffled <- TRUE
[16:01:46.480]                           break
[16:01:46.480]                         }
[16:01:46.480]                       }
[16:01:46.480]                     }
[16:01:46.480]                     invisible(muffled)
[16:01:46.480]                   }
[16:01:46.480]                   muffleCondition(cond)
[16:01:46.480]                 })
[16:01:46.480]             }))
[16:01:46.480]             future::FutureResult(value = ...future.value$value, 
[16:01:46.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.480]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.480]                     ...future.globalenv.names))
[16:01:46.480]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.480]         }, condition = base::local({
[16:01:46.480]             c <- base::c
[16:01:46.480]             inherits <- base::inherits
[16:01:46.480]             invokeRestart <- base::invokeRestart
[16:01:46.480]             length <- base::length
[16:01:46.480]             list <- base::list
[16:01:46.480]             seq.int <- base::seq.int
[16:01:46.480]             signalCondition <- base::signalCondition
[16:01:46.480]             sys.calls <- base::sys.calls
[16:01:46.480]             `[[` <- base::`[[`
[16:01:46.480]             `+` <- base::`+`
[16:01:46.480]             `<<-` <- base::`<<-`
[16:01:46.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.480]                   3L)]
[16:01:46.480]             }
[16:01:46.480]             function(cond) {
[16:01:46.480]                 is_error <- inherits(cond, "error")
[16:01:46.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.480]                   NULL)
[16:01:46.480]                 if (is_error) {
[16:01:46.480]                   sessionInformation <- function() {
[16:01:46.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.480]                       search = base::search(), system = base::Sys.info())
[16:01:46.480]                   }
[16:01:46.480]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.480]                     cond$call), session = sessionInformation(), 
[16:01:46.480]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.480]                   signalCondition(cond)
[16:01:46.480]                 }
[16:01:46.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.480]                 "immediateCondition"))) {
[16:01:46.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.480]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.480]                   if (TRUE && !signal) {
[16:01:46.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.480]                     {
[16:01:46.480]                       inherits <- base::inherits
[16:01:46.480]                       invokeRestart <- base::invokeRestart
[16:01:46.480]                       is.null <- base::is.null
[16:01:46.480]                       muffled <- FALSE
[16:01:46.480]                       if (inherits(cond, "message")) {
[16:01:46.480]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.480]                         if (muffled) 
[16:01:46.480]                           invokeRestart("muffleMessage")
[16:01:46.480]                       }
[16:01:46.480]                       else if (inherits(cond, "warning")) {
[16:01:46.480]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.480]                         if (muffled) 
[16:01:46.480]                           invokeRestart("muffleWarning")
[16:01:46.480]                       }
[16:01:46.480]                       else if (inherits(cond, "condition")) {
[16:01:46.480]                         if (!is.null(pattern)) {
[16:01:46.480]                           computeRestarts <- base::computeRestarts
[16:01:46.480]                           grepl <- base::grepl
[16:01:46.480]                           restarts <- computeRestarts(cond)
[16:01:46.480]                           for (restart in restarts) {
[16:01:46.480]                             name <- restart$name
[16:01:46.480]                             if (is.null(name)) 
[16:01:46.480]                               next
[16:01:46.480]                             if (!grepl(pattern, name)) 
[16:01:46.480]                               next
[16:01:46.480]                             invokeRestart(restart)
[16:01:46.480]                             muffled <- TRUE
[16:01:46.480]                             break
[16:01:46.480]                           }
[16:01:46.480]                         }
[16:01:46.480]                       }
[16:01:46.480]                       invisible(muffled)
[16:01:46.480]                     }
[16:01:46.480]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.480]                   }
[16:01:46.480]                 }
[16:01:46.480]                 else {
[16:01:46.480]                   if (TRUE) {
[16:01:46.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.480]                     {
[16:01:46.480]                       inherits <- base::inherits
[16:01:46.480]                       invokeRestart <- base::invokeRestart
[16:01:46.480]                       is.null <- base::is.null
[16:01:46.480]                       muffled <- FALSE
[16:01:46.480]                       if (inherits(cond, "message")) {
[16:01:46.480]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.480]                         if (muffled) 
[16:01:46.480]                           invokeRestart("muffleMessage")
[16:01:46.480]                       }
[16:01:46.480]                       else if (inherits(cond, "warning")) {
[16:01:46.480]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.480]                         if (muffled) 
[16:01:46.480]                           invokeRestart("muffleWarning")
[16:01:46.480]                       }
[16:01:46.480]                       else if (inherits(cond, "condition")) {
[16:01:46.480]                         if (!is.null(pattern)) {
[16:01:46.480]                           computeRestarts <- base::computeRestarts
[16:01:46.480]                           grepl <- base::grepl
[16:01:46.480]                           restarts <- computeRestarts(cond)
[16:01:46.480]                           for (restart in restarts) {
[16:01:46.480]                             name <- restart$name
[16:01:46.480]                             if (is.null(name)) 
[16:01:46.480]                               next
[16:01:46.480]                             if (!grepl(pattern, name)) 
[16:01:46.480]                               next
[16:01:46.480]                             invokeRestart(restart)
[16:01:46.480]                             muffled <- TRUE
[16:01:46.480]                             break
[16:01:46.480]                           }
[16:01:46.480]                         }
[16:01:46.480]                       }
[16:01:46.480]                       invisible(muffled)
[16:01:46.480]                     }
[16:01:46.480]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.480]                   }
[16:01:46.480]                 }
[16:01:46.480]             }
[16:01:46.480]         }))
[16:01:46.480]     }, error = function(ex) {
[16:01:46.480]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.480]                 ...future.rng), started = ...future.startTime, 
[16:01:46.480]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.480]             version = "1.8"), class = "FutureResult")
[16:01:46.480]     }, finally = {
[16:01:46.480]         if (!identical(...future.workdir, getwd())) 
[16:01:46.480]             setwd(...future.workdir)
[16:01:46.480]         {
[16:01:46.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.480]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.480]             }
[16:01:46.480]             base::options(...future.oldOptions)
[16:01:46.480]             if (.Platform$OS.type == "windows") {
[16:01:46.480]                 old_names <- names(...future.oldEnvVars)
[16:01:46.480]                 envs <- base::Sys.getenv()
[16:01:46.480]                 names <- names(envs)
[16:01:46.480]                 common <- intersect(names, old_names)
[16:01:46.480]                 added <- setdiff(names, old_names)
[16:01:46.480]                 removed <- setdiff(old_names, names)
[16:01:46.480]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.480]                   envs[common]]
[16:01:46.480]                 NAMES <- toupper(changed)
[16:01:46.480]                 args <- list()
[16:01:46.480]                 for (kk in seq_along(NAMES)) {
[16:01:46.480]                   name <- changed[[kk]]
[16:01:46.480]                   NAME <- NAMES[[kk]]
[16:01:46.480]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.480]                     next
[16:01:46.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.480]                 }
[16:01:46.480]                 NAMES <- toupper(added)
[16:01:46.480]                 for (kk in seq_along(NAMES)) {
[16:01:46.480]                   name <- added[[kk]]
[16:01:46.480]                   NAME <- NAMES[[kk]]
[16:01:46.480]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.480]                     next
[16:01:46.480]                   args[[name]] <- ""
[16:01:46.480]                 }
[16:01:46.480]                 NAMES <- toupper(removed)
[16:01:46.480]                 for (kk in seq_along(NAMES)) {
[16:01:46.480]                   name <- removed[[kk]]
[16:01:46.480]                   NAME <- NAMES[[kk]]
[16:01:46.480]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.480]                     next
[16:01:46.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.480]                 }
[16:01:46.480]                 if (length(args) > 0) 
[16:01:46.480]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.480]             }
[16:01:46.480]             else {
[16:01:46.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.480]             }
[16:01:46.480]             {
[16:01:46.480]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.480]                   0L) {
[16:01:46.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.480]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.480]                   base::options(opts)
[16:01:46.480]                 }
[16:01:46.480]                 {
[16:01:46.480]                   {
[16:01:46.480]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.480]                     NULL
[16:01:46.480]                   }
[16:01:46.480]                   options(future.plan = NULL)
[16:01:46.480]                   if (is.na(NA_character_)) 
[16:01:46.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.480]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.480]                     envir = parent.frame()) 
[16:01:46.480]                   {
[16:01:46.480]                     default_workers <- missing(workers)
[16:01:46.480]                     if (is.function(workers)) 
[16:01:46.480]                       workers <- workers()
[16:01:46.480]                     workers <- structure(as.integer(workers), 
[16:01:46.480]                       class = class(workers))
[16:01:46.480]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.480]                       1L)
[16:01:46.480]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.480]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.480]                       if (default_workers) 
[16:01:46.480]                         supportsMulticore(warn = TRUE)
[16:01:46.480]                       return(sequential(..., envir = envir))
[16:01:46.480]                     }
[16:01:46.480]                     oopts <- options(mc.cores = workers)
[16:01:46.480]                     on.exit(options(oopts))
[16:01:46.480]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.480]                       envir = envir)
[16:01:46.480]                     if (!future$lazy) 
[16:01:46.480]                       future <- run(future)
[16:01:46.480]                     invisible(future)
[16:01:46.480]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.480]                 }
[16:01:46.480]             }
[16:01:46.480]         }
[16:01:46.480]     })
[16:01:46.480]     if (TRUE) {
[16:01:46.480]         base::sink(type = "output", split = FALSE)
[16:01:46.480]         if (TRUE) {
[16:01:46.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.480]         }
[16:01:46.480]         else {
[16:01:46.480]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.480]         }
[16:01:46.480]         base::close(...future.stdout)
[16:01:46.480]         ...future.stdout <- NULL
[16:01:46.480]     }
[16:01:46.480]     ...future.result$conditions <- ...future.conditions
[16:01:46.480]     ...future.result$finished <- base::Sys.time()
[16:01:46.480]     ...future.result
[16:01:46.480] }
[16:01:46.483] assign_globals() ...
[16:01:46.483] List of 7
[16:01:46.483]  $ ...future.FUN            :function (x)  
[16:01:46.483]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:46.483]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.483]  $ future.call.arguments    : list()
[16:01:46.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.483]  $ ...future.elements_ii    :List of 1
[16:01:46.483]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.483]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:46.483]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.483]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.483]  $ ...future.seeds_ii       : NULL
[16:01:46.483]  $ ...future.globals.maxSize: NULL
[16:01:46.483]  - attr(*, "where")=List of 7
[16:01:46.483]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.483]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:01:46.483]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:01:46.483]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.483]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.483]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.483]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.483]  - attr(*, "resolved")= logi FALSE
[16:01:46.483]  - attr(*, "total_size")= num 2320
[16:01:46.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.483]  - attr(*, "already-done")= logi TRUE
[16:01:46.493] - reassign environment for ‘...future.FUN’
[16:01:46.493] - copied ‘...future.FUN’ to environment
[16:01:46.493] - copied ‘breaks’ to environment
[16:01:46.493] - copied ‘wool’ to environment
[16:01:46.494] - copied ‘future.call.arguments’ to environment
[16:01:46.494] - copied ‘...future.elements_ii’ to environment
[16:01:46.494] - copied ‘...future.seeds_ii’ to environment
[16:01:46.494] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.494] assign_globals() ... done
[16:01:46.494] requestCore(): workers = 2
[16:01:46.497] MulticoreFuture started
[16:01:46.497] - Launch lazy future ... done
[16:01:46.498] run() for ‘MulticoreFuture’ ... done
[16:01:46.499] Created future:
[16:01:46.499] plan(): Setting new future strategy stack:
[16:01:46.499] List of future strategies:
[16:01:46.499] 1. sequential:
[16:01:46.499]    - args: function (..., envir = parent.frame())
[16:01:46.499]    - tweaked: FALSE
[16:01:46.499]    - call: NULL
[16:01:46.501] plan(): nbrOfWorkers() = 1
[16:01:46.506] plan(): Setting new future strategy stack:
[16:01:46.506] List of future strategies:
[16:01:46.506] 1. multicore:
[16:01:46.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.506]    - tweaked: FALSE
[16:01:46.506]    - call: plan(strategy)
[16:01:46.512] plan(): nbrOfWorkers() = 2
[16:01:46.499] MulticoreFuture:
[16:01:46.499] Label: ‘future_by-1’
[16:01:46.499] Expression:
[16:01:46.499] {
[16:01:46.499]     do.call(function(...) {
[16:01:46.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.499]             on.exit(options(oopts), add = TRUE)
[16:01:46.499]         }
[16:01:46.499]         {
[16:01:46.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.499]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.499]             })
[16:01:46.499]         }
[16:01:46.499]     }, args = future.call.arguments)
[16:01:46.499] }
[16:01:46.499] Lazy evaluation: FALSE
[16:01:46.499] Asynchronous evaluation: TRUE
[16:01:46.499] Local evaluation: TRUE
[16:01:46.499] Environment: 0x55b525fff6e0
[16:01:46.499] Capture standard output: TRUE
[16:01:46.499] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.499] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:01:46.499] Packages: 1 packages (‘stats’)
[16:01:46.499] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.499] Resolved: FALSE
[16:01:46.499] Value: <not collected>
[16:01:46.499] Conditions captured: <none>
[16:01:46.499] Early signaling: FALSE
[16:01:46.499] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.499] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.514] Chunk #1 of 2 ... DONE
[16:01:46.514] Chunk #2 of 2 ...
[16:01:46.515]  - Finding globals in 'X' for chunk #2 ...
[16:01:46.515] getGlobalsAndPackages() ...
[16:01:46.515] Searching for globals...
[16:01:46.516] 
[16:01:46.516] Searching for globals ... DONE
[16:01:46.517] - globals: [0] <none>
[16:01:46.517] getGlobalsAndPackages() ... DONE
[16:01:46.517]    + additional globals found: [n=0] 
[16:01:46.517]    + additional namespaces needed: [n=0] 
[16:01:46.517]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:46.517]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.517]  - seeds: <none>
[16:01:46.518]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.518] getGlobalsAndPackages() ...
[16:01:46.518] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.518] Resolving globals: FALSE
[16:01:46.518] Tweak future expression to call with '...' arguments ...
[16:01:46.519] {
[16:01:46.519]     do.call(function(...) {
[16:01:46.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.519]             on.exit(options(oopts), add = TRUE)
[16:01:46.519]         }
[16:01:46.519]         {
[16:01:46.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.519]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.519]             })
[16:01:46.519]         }
[16:01:46.519]     }, args = future.call.arguments)
[16:01:46.519] }
[16:01:46.519] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.520] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.520] 
[16:01:46.520] getGlobalsAndPackages() ... DONE
[16:01:46.521] run() for ‘Future’ ...
[16:01:46.521] - state: ‘created’
[16:01:46.521] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.526] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.526] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.526]   - Field: ‘label’
[16:01:46.527]   - Field: ‘local’
[16:01:46.527]   - Field: ‘owner’
[16:01:46.527]   - Field: ‘envir’
[16:01:46.527]   - Field: ‘workers’
[16:01:46.527]   - Field: ‘packages’
[16:01:46.527]   - Field: ‘gc’
[16:01:46.527]   - Field: ‘job’
[16:01:46.528]   - Field: ‘conditions’
[16:01:46.528]   - Field: ‘expr’
[16:01:46.528]   - Field: ‘uuid’
[16:01:46.528]   - Field: ‘seed’
[16:01:46.528]   - Field: ‘version’
[16:01:46.528]   - Field: ‘result’
[16:01:46.528]   - Field: ‘asynchronous’
[16:01:46.528]   - Field: ‘calls’
[16:01:46.529]   - Field: ‘globals’
[16:01:46.529]   - Field: ‘stdout’
[16:01:46.529]   - Field: ‘earlySignal’
[16:01:46.529]   - Field: ‘lazy’
[16:01:46.529]   - Field: ‘state’
[16:01:46.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.529] - Launch lazy future ...
[16:01:46.530] Packages needed by the future expression (n = 1): ‘stats’
[16:01:46.530] Packages needed by future strategies (n = 0): <none>
[16:01:46.531] {
[16:01:46.531]     {
[16:01:46.531]         {
[16:01:46.531]             ...future.startTime <- base::Sys.time()
[16:01:46.531]             {
[16:01:46.531]                 {
[16:01:46.531]                   {
[16:01:46.531]                     {
[16:01:46.531]                       {
[16:01:46.531]                         base::local({
[16:01:46.531]                           has_future <- base::requireNamespace("future", 
[16:01:46.531]                             quietly = TRUE)
[16:01:46.531]                           if (has_future) {
[16:01:46.531]                             ns <- base::getNamespace("future")
[16:01:46.531]                             version <- ns[[".package"]][["version"]]
[16:01:46.531]                             if (is.null(version)) 
[16:01:46.531]                               version <- utils::packageVersion("future")
[16:01:46.531]                           }
[16:01:46.531]                           else {
[16:01:46.531]                             version <- NULL
[16:01:46.531]                           }
[16:01:46.531]                           if (!has_future || version < "1.8.0") {
[16:01:46.531]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.531]                               "", base::R.version$version.string), 
[16:01:46.531]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:46.531]                                 base::R.version$platform, 8 * 
[16:01:46.531]                                   base::.Machine$sizeof.pointer), 
[16:01:46.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.531]                                 "release", "version")], collapse = " "), 
[16:01:46.531]                               hostname = base::Sys.info()[["nodename"]])
[16:01:46.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.531]                               info)
[16:01:46.531]                             info <- base::paste(info, collapse = "; ")
[16:01:46.531]                             if (!has_future) {
[16:01:46.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.531]                                 info)
[16:01:46.531]                             }
[16:01:46.531]                             else {
[16:01:46.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.531]                                 info, version)
[16:01:46.531]                             }
[16:01:46.531]                             base::stop(msg)
[16:01:46.531]                           }
[16:01:46.531]                         })
[16:01:46.531]                       }
[16:01:46.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.531]                       base::options(mc.cores = 1L)
[16:01:46.531]                     }
[16:01:46.531]                     base::local({
[16:01:46.531]                       for (pkg in "stats") {
[16:01:46.531]                         base::loadNamespace(pkg)
[16:01:46.531]                         base::library(pkg, character.only = TRUE)
[16:01:46.531]                       }
[16:01:46.531]                     })
[16:01:46.531]                   }
[16:01:46.531]                   options(future.plan = NULL)
[16:01:46.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.531]                 }
[16:01:46.531]                 ...future.workdir <- getwd()
[16:01:46.531]             }
[16:01:46.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.531]         }
[16:01:46.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.531]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.531]             base::names(...future.oldOptions))
[16:01:46.531]     }
[16:01:46.531]     if (FALSE) {
[16:01:46.531]     }
[16:01:46.531]     else {
[16:01:46.531]         if (TRUE) {
[16:01:46.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.531]                 open = "w")
[16:01:46.531]         }
[16:01:46.531]         else {
[16:01:46.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.531]         }
[16:01:46.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.531]             base::sink(type = "output", split = FALSE)
[16:01:46.531]             base::close(...future.stdout)
[16:01:46.531]         }, add = TRUE)
[16:01:46.531]     }
[16:01:46.531]     ...future.frame <- base::sys.nframe()
[16:01:46.531]     ...future.conditions <- base::list()
[16:01:46.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.531]     if (FALSE) {
[16:01:46.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.531]     }
[16:01:46.531]     ...future.result <- base::tryCatch({
[16:01:46.531]         base::withCallingHandlers({
[16:01:46.531]             ...future.value <- base::withVisible(base::local({
[16:01:46.531]                 withCallingHandlers({
[16:01:46.531]                   {
[16:01:46.531]                     do.call(function(...) {
[16:01:46.531]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.531]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.531]                         ...future.globals.maxSize)) {
[16:01:46.531]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.531]                         on.exit(options(oopts), add = TRUE)
[16:01:46.531]                       }
[16:01:46.531]                       {
[16:01:46.531]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.531]                           FUN = function(jj) {
[16:01:46.531]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.531]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.531]                           })
[16:01:46.531]                       }
[16:01:46.531]                     }, args = future.call.arguments)
[16:01:46.531]                   }
[16:01:46.531]                 }, immediateCondition = function(cond) {
[16:01:46.531]                   save_rds <- function (object, pathname, ...) 
[16:01:46.531]                   {
[16:01:46.531]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.531]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.531]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.531]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.531]                         fi_tmp[["mtime"]])
[16:01:46.531]                     }
[16:01:46.531]                     tryCatch({
[16:01:46.531]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.531]                     }, error = function(ex) {
[16:01:46.531]                       msg <- conditionMessage(ex)
[16:01:46.531]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.531]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.531]                         fi_tmp[["mtime"]], msg)
[16:01:46.531]                       ex$message <- msg
[16:01:46.531]                       stop(ex)
[16:01:46.531]                     })
[16:01:46.531]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.531]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.531]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.531]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.531]                       fi <- file.info(pathname)
[16:01:46.531]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.531]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.531]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.531]                         fi[["size"]], fi[["mtime"]])
[16:01:46.531]                       stop(msg)
[16:01:46.531]                     }
[16:01:46.531]                     invisible(pathname)
[16:01:46.531]                   }
[16:01:46.531]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.531]                     rootPath = tempdir()) 
[16:01:46.531]                   {
[16:01:46.531]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.531]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.531]                       tmpdir = path, fileext = ".rds")
[16:01:46.531]                     save_rds(obj, file)
[16:01:46.531]                   }
[16:01:46.531]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.531]                   {
[16:01:46.531]                     inherits <- base::inherits
[16:01:46.531]                     invokeRestart <- base::invokeRestart
[16:01:46.531]                     is.null <- base::is.null
[16:01:46.531]                     muffled <- FALSE
[16:01:46.531]                     if (inherits(cond, "message")) {
[16:01:46.531]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.531]                       if (muffled) 
[16:01:46.531]                         invokeRestart("muffleMessage")
[16:01:46.531]                     }
[16:01:46.531]                     else if (inherits(cond, "warning")) {
[16:01:46.531]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.531]                       if (muffled) 
[16:01:46.531]                         invokeRestart("muffleWarning")
[16:01:46.531]                     }
[16:01:46.531]                     else if (inherits(cond, "condition")) {
[16:01:46.531]                       if (!is.null(pattern)) {
[16:01:46.531]                         computeRestarts <- base::computeRestarts
[16:01:46.531]                         grepl <- base::grepl
[16:01:46.531]                         restarts <- computeRestarts(cond)
[16:01:46.531]                         for (restart in restarts) {
[16:01:46.531]                           name <- restart$name
[16:01:46.531]                           if (is.null(name)) 
[16:01:46.531]                             next
[16:01:46.531]                           if (!grepl(pattern, name)) 
[16:01:46.531]                             next
[16:01:46.531]                           invokeRestart(restart)
[16:01:46.531]                           muffled <- TRUE
[16:01:46.531]                           break
[16:01:46.531]                         }
[16:01:46.531]                       }
[16:01:46.531]                     }
[16:01:46.531]                     invisible(muffled)
[16:01:46.531]                   }
[16:01:46.531]                   muffleCondition(cond)
[16:01:46.531]                 })
[16:01:46.531]             }))
[16:01:46.531]             future::FutureResult(value = ...future.value$value, 
[16:01:46.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.531]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.531]                     ...future.globalenv.names))
[16:01:46.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.531]         }, condition = base::local({
[16:01:46.531]             c <- base::c
[16:01:46.531]             inherits <- base::inherits
[16:01:46.531]             invokeRestart <- base::invokeRestart
[16:01:46.531]             length <- base::length
[16:01:46.531]             list <- base::list
[16:01:46.531]             seq.int <- base::seq.int
[16:01:46.531]             signalCondition <- base::signalCondition
[16:01:46.531]             sys.calls <- base::sys.calls
[16:01:46.531]             `[[` <- base::`[[`
[16:01:46.531]             `+` <- base::`+`
[16:01:46.531]             `<<-` <- base::`<<-`
[16:01:46.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.531]                   3L)]
[16:01:46.531]             }
[16:01:46.531]             function(cond) {
[16:01:46.531]                 is_error <- inherits(cond, "error")
[16:01:46.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.531]                   NULL)
[16:01:46.531]                 if (is_error) {
[16:01:46.531]                   sessionInformation <- function() {
[16:01:46.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.531]                       search = base::search(), system = base::Sys.info())
[16:01:46.531]                   }
[16:01:46.531]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.531]                     cond$call), session = sessionInformation(), 
[16:01:46.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.531]                   signalCondition(cond)
[16:01:46.531]                 }
[16:01:46.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.531]                 "immediateCondition"))) {
[16:01:46.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.531]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.531]                   if (TRUE && !signal) {
[16:01:46.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.531]                     {
[16:01:46.531]                       inherits <- base::inherits
[16:01:46.531]                       invokeRestart <- base::invokeRestart
[16:01:46.531]                       is.null <- base::is.null
[16:01:46.531]                       muffled <- FALSE
[16:01:46.531]                       if (inherits(cond, "message")) {
[16:01:46.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.531]                         if (muffled) 
[16:01:46.531]                           invokeRestart("muffleMessage")
[16:01:46.531]                       }
[16:01:46.531]                       else if (inherits(cond, "warning")) {
[16:01:46.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.531]                         if (muffled) 
[16:01:46.531]                           invokeRestart("muffleWarning")
[16:01:46.531]                       }
[16:01:46.531]                       else if (inherits(cond, "condition")) {
[16:01:46.531]                         if (!is.null(pattern)) {
[16:01:46.531]                           computeRestarts <- base::computeRestarts
[16:01:46.531]                           grepl <- base::grepl
[16:01:46.531]                           restarts <- computeRestarts(cond)
[16:01:46.531]                           for (restart in restarts) {
[16:01:46.531]                             name <- restart$name
[16:01:46.531]                             if (is.null(name)) 
[16:01:46.531]                               next
[16:01:46.531]                             if (!grepl(pattern, name)) 
[16:01:46.531]                               next
[16:01:46.531]                             invokeRestart(restart)
[16:01:46.531]                             muffled <- TRUE
[16:01:46.531]                             break
[16:01:46.531]                           }
[16:01:46.531]                         }
[16:01:46.531]                       }
[16:01:46.531]                       invisible(muffled)
[16:01:46.531]                     }
[16:01:46.531]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.531]                   }
[16:01:46.531]                 }
[16:01:46.531]                 else {
[16:01:46.531]                   if (TRUE) {
[16:01:46.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.531]                     {
[16:01:46.531]                       inherits <- base::inherits
[16:01:46.531]                       invokeRestart <- base::invokeRestart
[16:01:46.531]                       is.null <- base::is.null
[16:01:46.531]                       muffled <- FALSE
[16:01:46.531]                       if (inherits(cond, "message")) {
[16:01:46.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.531]                         if (muffled) 
[16:01:46.531]                           invokeRestart("muffleMessage")
[16:01:46.531]                       }
[16:01:46.531]                       else if (inherits(cond, "warning")) {
[16:01:46.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.531]                         if (muffled) 
[16:01:46.531]                           invokeRestart("muffleWarning")
[16:01:46.531]                       }
[16:01:46.531]                       else if (inherits(cond, "condition")) {
[16:01:46.531]                         if (!is.null(pattern)) {
[16:01:46.531]                           computeRestarts <- base::computeRestarts
[16:01:46.531]                           grepl <- base::grepl
[16:01:46.531]                           restarts <- computeRestarts(cond)
[16:01:46.531]                           for (restart in restarts) {
[16:01:46.531]                             name <- restart$name
[16:01:46.531]                             if (is.null(name)) 
[16:01:46.531]                               next
[16:01:46.531]                             if (!grepl(pattern, name)) 
[16:01:46.531]                               next
[16:01:46.531]                             invokeRestart(restart)
[16:01:46.531]                             muffled <- TRUE
[16:01:46.531]                             break
[16:01:46.531]                           }
[16:01:46.531]                         }
[16:01:46.531]                       }
[16:01:46.531]                       invisible(muffled)
[16:01:46.531]                     }
[16:01:46.531]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.531]                   }
[16:01:46.531]                 }
[16:01:46.531]             }
[16:01:46.531]         }))
[16:01:46.531]     }, error = function(ex) {
[16:01:46.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.531]                 ...future.rng), started = ...future.startTime, 
[16:01:46.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.531]             version = "1.8"), class = "FutureResult")
[16:01:46.531]     }, finally = {
[16:01:46.531]         if (!identical(...future.workdir, getwd())) 
[16:01:46.531]             setwd(...future.workdir)
[16:01:46.531]         {
[16:01:46.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.531]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.531]             }
[16:01:46.531]             base::options(...future.oldOptions)
[16:01:46.531]             if (.Platform$OS.type == "windows") {
[16:01:46.531]                 old_names <- names(...future.oldEnvVars)
[16:01:46.531]                 envs <- base::Sys.getenv()
[16:01:46.531]                 names <- names(envs)
[16:01:46.531]                 common <- intersect(names, old_names)
[16:01:46.531]                 added <- setdiff(names, old_names)
[16:01:46.531]                 removed <- setdiff(old_names, names)
[16:01:46.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.531]                   envs[common]]
[16:01:46.531]                 NAMES <- toupper(changed)
[16:01:46.531]                 args <- list()
[16:01:46.531]                 for (kk in seq_along(NAMES)) {
[16:01:46.531]                   name <- changed[[kk]]
[16:01:46.531]                   NAME <- NAMES[[kk]]
[16:01:46.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.531]                     next
[16:01:46.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.531]                 }
[16:01:46.531]                 NAMES <- toupper(added)
[16:01:46.531]                 for (kk in seq_along(NAMES)) {
[16:01:46.531]                   name <- added[[kk]]
[16:01:46.531]                   NAME <- NAMES[[kk]]
[16:01:46.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.531]                     next
[16:01:46.531]                   args[[name]] <- ""
[16:01:46.531]                 }
[16:01:46.531]                 NAMES <- toupper(removed)
[16:01:46.531]                 for (kk in seq_along(NAMES)) {
[16:01:46.531]                   name <- removed[[kk]]
[16:01:46.531]                   NAME <- NAMES[[kk]]
[16:01:46.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.531]                     next
[16:01:46.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.531]                 }
[16:01:46.531]                 if (length(args) > 0) 
[16:01:46.531]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.531]             }
[16:01:46.531]             else {
[16:01:46.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.531]             }
[16:01:46.531]             {
[16:01:46.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.531]                   0L) {
[16:01:46.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.531]                   base::options(opts)
[16:01:46.531]                 }
[16:01:46.531]                 {
[16:01:46.531]                   {
[16:01:46.531]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.531]                     NULL
[16:01:46.531]                   }
[16:01:46.531]                   options(future.plan = NULL)
[16:01:46.531]                   if (is.na(NA_character_)) 
[16:01:46.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.531]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.531]                     envir = parent.frame()) 
[16:01:46.531]                   {
[16:01:46.531]                     default_workers <- missing(workers)
[16:01:46.531]                     if (is.function(workers)) 
[16:01:46.531]                       workers <- workers()
[16:01:46.531]                     workers <- structure(as.integer(workers), 
[16:01:46.531]                       class = class(workers))
[16:01:46.531]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.531]                       1L)
[16:01:46.531]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.531]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.531]                       if (default_workers) 
[16:01:46.531]                         supportsMulticore(warn = TRUE)
[16:01:46.531]                       return(sequential(..., envir = envir))
[16:01:46.531]                     }
[16:01:46.531]                     oopts <- options(mc.cores = workers)
[16:01:46.531]                     on.exit(options(oopts))
[16:01:46.531]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.531]                       envir = envir)
[16:01:46.531]                     if (!future$lazy) 
[16:01:46.531]                       future <- run(future)
[16:01:46.531]                     invisible(future)
[16:01:46.531]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.531]                 }
[16:01:46.531]             }
[16:01:46.531]         }
[16:01:46.531]     })
[16:01:46.531]     if (TRUE) {
[16:01:46.531]         base::sink(type = "output", split = FALSE)
[16:01:46.531]         if (TRUE) {
[16:01:46.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.531]         }
[16:01:46.531]         else {
[16:01:46.531]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.531]         }
[16:01:46.531]         base::close(...future.stdout)
[16:01:46.531]         ...future.stdout <- NULL
[16:01:46.531]     }
[16:01:46.531]     ...future.result$conditions <- ...future.conditions
[16:01:46.531]     ...future.result$finished <- base::Sys.time()
[16:01:46.531]     ...future.result
[16:01:46.531] }
[16:01:46.534] assign_globals() ...
[16:01:46.534] List of 7
[16:01:46.534]  $ ...future.FUN            :function (x)  
[16:01:46.534]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:46.534]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.534]  $ future.call.arguments    : list()
[16:01:46.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.534]  $ ...future.elements_ii    :List of 2
[16:01:46.534]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.534]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:46.534]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.534]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:46.534]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.534]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:46.534]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.534]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:46.534]  $ ...future.seeds_ii       : NULL
[16:01:46.534]  $ ...future.globals.maxSize: NULL
[16:01:46.534]  - attr(*, "where")=List of 7
[16:01:46.534]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.534]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:01:46.534]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:01:46.534]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.534]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.534]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.534]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.534]  - attr(*, "resolved")= logi FALSE
[16:01:46.534]  - attr(*, "total_size")= num 2320
[16:01:46.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.534]  - attr(*, "already-done")= logi TRUE
[16:01:46.547] - reassign environment for ‘...future.FUN’
[16:01:46.547] - copied ‘...future.FUN’ to environment
[16:01:46.547] - copied ‘breaks’ to environment
[16:01:46.548] - copied ‘wool’ to environment
[16:01:46.548] - copied ‘future.call.arguments’ to environment
[16:01:46.548] - copied ‘...future.elements_ii’ to environment
[16:01:46.548] - copied ‘...future.seeds_ii’ to environment
[16:01:46.548] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.548] assign_globals() ... done
[16:01:46.548] requestCore(): workers = 2
[16:01:46.551] MulticoreFuture started
[16:01:46.552] - Launch lazy future ... done
[16:01:46.552] run() for ‘MulticoreFuture’ ... done
[16:01:46.553] Created future:
[16:01:46.553] plan(): Setting new future strategy stack:
[16:01:46.553] List of future strategies:
[16:01:46.553] 1. sequential:
[16:01:46.553]    - args: function (..., envir = parent.frame())
[16:01:46.553]    - tweaked: FALSE
[16:01:46.553]    - call: NULL
[16:01:46.554] plan(): nbrOfWorkers() = 1
[16:01:46.560] plan(): Setting new future strategy stack:
[16:01:46.560] List of future strategies:
[16:01:46.560] 1. multicore:
[16:01:46.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.560]    - tweaked: FALSE
[16:01:46.560]    - call: plan(strategy)
[16:01:46.565] plan(): nbrOfWorkers() = 2
[16:01:46.553] MulticoreFuture:
[16:01:46.553] Label: ‘future_by-2’
[16:01:46.553] Expression:
[16:01:46.553] {
[16:01:46.553]     do.call(function(...) {
[16:01:46.553]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.553]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.553]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.553]             on.exit(options(oopts), add = TRUE)
[16:01:46.553]         }
[16:01:46.553]         {
[16:01:46.553]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.553]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.553]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.553]             })
[16:01:46.553]         }
[16:01:46.553]     }, args = future.call.arguments)
[16:01:46.553] }
[16:01:46.553] Lazy evaluation: FALSE
[16:01:46.553] Asynchronous evaluation: TRUE
[16:01:46.553] Local evaluation: TRUE
[16:01:46.553] Environment: 0x55b525fff6e0
[16:01:46.553] Capture standard output: TRUE
[16:01:46.553] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.553] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:01:46.553] Packages: 1 packages (‘stats’)
[16:01:46.553] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.553] Resolved: FALSE
[16:01:46.553] Value: <not collected>
[16:01:46.553] Conditions captured: <none>
[16:01:46.553] Early signaling: FALSE
[16:01:46.553] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.553] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.567] Chunk #2 of 2 ... DONE
[16:01:46.567] Launching 2 futures (chunks) ... DONE
[16:01:46.567] Resolving 2 futures (chunks) ...
[16:01:46.568] resolve() on list ...
[16:01:46.568]  recursive: 0
[16:01:46.568]  length: 2
[16:01:46.568] 
[16:01:46.568] Future #1
[16:01:46.569] result() for MulticoreFuture ...
[16:01:46.570] result() for MulticoreFuture ...
[16:01:46.570] result() for MulticoreFuture ... done
[16:01:46.570] result() for MulticoreFuture ... done
[16:01:46.571] result() for MulticoreFuture ...
[16:01:46.571] result() for MulticoreFuture ... done
[16:01:46.571] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:46.571] - nx: 2
[16:01:46.571] - relay: TRUE
[16:01:46.572] - stdout: TRUE
[16:01:46.572] - signal: TRUE
[16:01:46.572] - resignal: FALSE
[16:01:46.572] - force: TRUE
[16:01:46.572] - relayed: [n=2] FALSE, FALSE
[16:01:46.572] - queued futures: [n=2] FALSE, FALSE
[16:01:46.573]  - until=1
[16:01:46.573]  - relaying element #1
[16:01:46.573] result() for MulticoreFuture ...
[16:01:46.573] result() for MulticoreFuture ... done
[16:01:46.573] result() for MulticoreFuture ...
[16:01:46.574] result() for MulticoreFuture ... done
[16:01:46.574] result() for MulticoreFuture ...
[16:01:46.574] result() for MulticoreFuture ... done
[16:01:46.574] result() for MulticoreFuture ...
[16:01:46.575] result() for MulticoreFuture ... done
[16:01:46.575] - relayed: [n=2] TRUE, FALSE
[16:01:46.575] - queued futures: [n=2] TRUE, FALSE
[16:01:46.575] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:46.575]  length: 1 (resolved future 1)
[16:01:46.576] Future #2
[16:01:46.576] result() for MulticoreFuture ...
[16:01:46.577] result() for MulticoreFuture ...
[16:01:46.577] result() for MulticoreFuture ... done
[16:01:46.578] result() for MulticoreFuture ... done
[16:01:46.578] result() for MulticoreFuture ...
[16:01:46.578] result() for MulticoreFuture ... done
[16:01:46.578] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:46.578] - nx: 2
[16:01:46.579] - relay: TRUE
[16:01:46.579] - stdout: TRUE
[16:01:46.579] - signal: TRUE
[16:01:46.579] - resignal: FALSE
[16:01:46.579] - force: TRUE
[16:01:46.579] - relayed: [n=2] TRUE, FALSE
[16:01:46.579] - queued futures: [n=2] TRUE, FALSE
[16:01:46.580]  - until=2
[16:01:46.580]  - relaying element #2
[16:01:46.580] result() for MulticoreFuture ...
[16:01:46.580] result() for MulticoreFuture ... done
[16:01:46.580] result() for MulticoreFuture ...
[16:01:46.580] result() for MulticoreFuture ... done
[16:01:46.581] result() for MulticoreFuture ...
[16:01:46.581] result() for MulticoreFuture ... done
[16:01:46.581] result() for MulticoreFuture ...
[16:01:46.581] result() for MulticoreFuture ... done
[16:01:46.581] - relayed: [n=2] TRUE, TRUE
[16:01:46.581] - queued futures: [n=2] TRUE, TRUE
[16:01:46.581] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:46.581]  length: 0 (resolved future 2)
[16:01:46.582] Relaying remaining futures
[16:01:46.582] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.582] - nx: 2
[16:01:46.582] - relay: TRUE
[16:01:46.582] - stdout: TRUE
[16:01:46.582] - signal: TRUE
[16:01:46.582] - resignal: FALSE
[16:01:46.582] - force: TRUE
[16:01:46.582] - relayed: [n=2] TRUE, TRUE
[16:01:46.582] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:46.583] - relayed: [n=2] TRUE, TRUE
[16:01:46.583] - queued futures: [n=2] TRUE, TRUE
[16:01:46.583] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.583] resolve() on list ... DONE
[16:01:46.583] result() for MulticoreFuture ...
[16:01:46.583] result() for MulticoreFuture ... done
[16:01:46.583] result() for MulticoreFuture ...
[16:01:46.583] result() for MulticoreFuture ... done
[16:01:46.584] result() for MulticoreFuture ...
[16:01:46.584] result() for MulticoreFuture ... done
[16:01:46.584] result() for MulticoreFuture ...
[16:01:46.586] result() for MulticoreFuture ... done
[16:01:46.586]  - Number of value chunks collected: 2
[16:01:46.587] Resolving 2 futures (chunks) ... DONE
[16:01:46.587] Reducing values from 2 chunks ...
[16:01:46.587]  - Number of values collected after concatenation: 3
[16:01:46.587]  - Number of values expected: 3
[16:01:46.587] Reducing values from 2 chunks ... DONE
[16:01:46.587] future_lapply() ... DONE
[16:01:46.587] future_by_internal() ... DONE
[16:01:46.588] future_by_internal() ...
[16:01:46.589] future_lapply() ...
[16:01:46.594] Number of chunks: 2
[16:01:46.594] getGlobalsAndPackagesXApply() ...
[16:01:46.594]  - future.globals: TRUE
[16:01:46.594] getGlobalsAndPackages() ...
[16:01:46.594] Searching for globals...
[16:01:46.596] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:46.596] Searching for globals ... DONE
[16:01:46.596] Resolving globals: FALSE
[16:01:46.597] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:46.597] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:46.597] - globals: [1] ‘FUN’
[16:01:46.597] 
[16:01:46.598] getGlobalsAndPackages() ... DONE
[16:01:46.598]  - globals found/used: [n=1] ‘FUN’
[16:01:46.598]  - needed namespaces: [n=0] 
[16:01:46.598] Finding globals ... DONE
[16:01:46.598]  - use_args: TRUE
[16:01:46.598]  - Getting '...' globals ...
[16:01:46.598] resolve() on list ...
[16:01:46.598]  recursive: 0
[16:01:46.599]  length: 1
[16:01:46.599]  elements: ‘...’
[16:01:46.599]  length: 0 (resolved future 1)
[16:01:46.599] resolve() on list ... DONE
[16:01:46.599]    - '...' content: [n=0] 
[16:01:46.599] List of 1
[16:01:46.599]  $ ...: list()
[16:01:46.599]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.599]  - attr(*, "where")=List of 1
[16:01:46.599]   ..$ ...:<environment: 0x55b524522ed8> 
[16:01:46.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.599]  - attr(*, "resolved")= logi TRUE
[16:01:46.599]  - attr(*, "total_size")= num NA
[16:01:46.602]  - Getting '...' globals ... DONE
[16:01:46.602] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:46.602] List of 2
[16:01:46.602]  $ ...future.FUN:function (object, ...)  
[16:01:46.602]  $ ...          : list()
[16:01:46.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.602]  - attr(*, "where")=List of 2
[16:01:46.602]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.602]   ..$ ...          :<environment: 0x55b524522ed8> 
[16:01:46.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.602]  - attr(*, "resolved")= logi FALSE
[16:01:46.602]  - attr(*, "total_size")= num 1240
[16:01:46.605] Packages to be attached in all futures: [n=0] 
[16:01:46.605] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.605] Number of futures (= number of chunks): 2
[16:01:46.605] Launching 2 futures (chunks) ...
[16:01:46.605] Chunk #1 of 2 ...
[16:01:46.606]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.606] getGlobalsAndPackages() ...
[16:01:46.606] Searching for globals...
[16:01:46.606] 
[16:01:46.606] Searching for globals ... DONE
[16:01:46.606] - globals: [0] <none>
[16:01:46.606] getGlobalsAndPackages() ... DONE
[16:01:46.607]    + additional globals found: [n=0] 
[16:01:46.607]    + additional namespaces needed: [n=0] 
[16:01:46.607]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.607]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.607]  - seeds: <none>
[16:01:46.607]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.607] getGlobalsAndPackages() ...
[16:01:46.607] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.607] Resolving globals: FALSE
[16:01:46.608] Tweak future expression to call with '...' arguments ...
[16:01:46.608] {
[16:01:46.608]     do.call(function(...) {
[16:01:46.608]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.608]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.608]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.608]             on.exit(options(oopts), add = TRUE)
[16:01:46.608]         }
[16:01:46.608]         {
[16:01:46.608]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.608]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.608]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.608]             })
[16:01:46.608]         }
[16:01:46.608]     }, args = future.call.arguments)
[16:01:46.608] }
[16:01:46.608] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.608] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.648] 
[16:01:46.648] getGlobalsAndPackages() ... DONE
[16:01:46.648] run() for ‘Future’ ...
[16:01:46.648] - state: ‘created’
[16:01:46.648] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.652] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.652]   - Field: ‘label’
[16:01:46.653]   - Field: ‘local’
[16:01:46.653]   - Field: ‘owner’
[16:01:46.653]   - Field: ‘envir’
[16:01:46.653]   - Field: ‘workers’
[16:01:46.653]   - Field: ‘packages’
[16:01:46.653]   - Field: ‘gc’
[16:01:46.653]   - Field: ‘job’
[16:01:46.653]   - Field: ‘conditions’
[16:01:46.653]   - Field: ‘expr’
[16:01:46.653]   - Field: ‘uuid’
[16:01:46.654]   - Field: ‘seed’
[16:01:46.654]   - Field: ‘version’
[16:01:46.654]   - Field: ‘result’
[16:01:46.654]   - Field: ‘asynchronous’
[16:01:46.654]   - Field: ‘calls’
[16:01:46.654]   - Field: ‘globals’
[16:01:46.654]   - Field: ‘stdout’
[16:01:46.654]   - Field: ‘earlySignal’
[16:01:46.654]   - Field: ‘lazy’
[16:01:46.654]   - Field: ‘state’
[16:01:46.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.655] - Launch lazy future ...
[16:01:46.655] Packages needed by the future expression (n = 0): <none>
[16:01:46.655] Packages needed by future strategies (n = 0): <none>
[16:01:46.655] {
[16:01:46.655]     {
[16:01:46.655]         {
[16:01:46.655]             ...future.startTime <- base::Sys.time()
[16:01:46.655]             {
[16:01:46.655]                 {
[16:01:46.655]                   {
[16:01:46.655]                     {
[16:01:46.655]                       base::local({
[16:01:46.655]                         has_future <- base::requireNamespace("future", 
[16:01:46.655]                           quietly = TRUE)
[16:01:46.655]                         if (has_future) {
[16:01:46.655]                           ns <- base::getNamespace("future")
[16:01:46.655]                           version <- ns[[".package"]][["version"]]
[16:01:46.655]                           if (is.null(version)) 
[16:01:46.655]                             version <- utils::packageVersion("future")
[16:01:46.655]                         }
[16:01:46.655]                         else {
[16:01:46.655]                           version <- NULL
[16:01:46.655]                         }
[16:01:46.655]                         if (!has_future || version < "1.8.0") {
[16:01:46.655]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.655]                             "", base::R.version$version.string), 
[16:01:46.655]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.655]                               "release", "version")], collapse = " "), 
[16:01:46.655]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.655]                             info)
[16:01:46.655]                           info <- base::paste(info, collapse = "; ")
[16:01:46.655]                           if (!has_future) {
[16:01:46.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.655]                               info)
[16:01:46.655]                           }
[16:01:46.655]                           else {
[16:01:46.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.655]                               info, version)
[16:01:46.655]                           }
[16:01:46.655]                           base::stop(msg)
[16:01:46.655]                         }
[16:01:46.655]                       })
[16:01:46.655]                     }
[16:01:46.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.655]                     base::options(mc.cores = 1L)
[16:01:46.655]                   }
[16:01:46.655]                   options(future.plan = NULL)
[16:01:46.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.655]                 }
[16:01:46.655]                 ...future.workdir <- getwd()
[16:01:46.655]             }
[16:01:46.655]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.655]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.655]         }
[16:01:46.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.655]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.655]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.655]             base::names(...future.oldOptions))
[16:01:46.655]     }
[16:01:46.655]     if (FALSE) {
[16:01:46.655]     }
[16:01:46.655]     else {
[16:01:46.655]         if (TRUE) {
[16:01:46.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.655]                 open = "w")
[16:01:46.655]         }
[16:01:46.655]         else {
[16:01:46.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.655]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.655]         }
[16:01:46.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.655]             base::sink(type = "output", split = FALSE)
[16:01:46.655]             base::close(...future.stdout)
[16:01:46.655]         }, add = TRUE)
[16:01:46.655]     }
[16:01:46.655]     ...future.frame <- base::sys.nframe()
[16:01:46.655]     ...future.conditions <- base::list()
[16:01:46.655]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.655]     if (FALSE) {
[16:01:46.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.655]     }
[16:01:46.655]     ...future.result <- base::tryCatch({
[16:01:46.655]         base::withCallingHandlers({
[16:01:46.655]             ...future.value <- base::withVisible(base::local({
[16:01:46.655]                 withCallingHandlers({
[16:01:46.655]                   {
[16:01:46.655]                     do.call(function(...) {
[16:01:46.655]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.655]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.655]                         ...future.globals.maxSize)) {
[16:01:46.655]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.655]                         on.exit(options(oopts), add = TRUE)
[16:01:46.655]                       }
[16:01:46.655]                       {
[16:01:46.655]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.655]                           FUN = function(jj) {
[16:01:46.655]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.655]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.655]                           })
[16:01:46.655]                       }
[16:01:46.655]                     }, args = future.call.arguments)
[16:01:46.655]                   }
[16:01:46.655]                 }, immediateCondition = function(cond) {
[16:01:46.655]                   save_rds <- function (object, pathname, ...) 
[16:01:46.655]                   {
[16:01:46.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.655]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.655]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.655]                         fi_tmp[["mtime"]])
[16:01:46.655]                     }
[16:01:46.655]                     tryCatch({
[16:01:46.655]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.655]                     }, error = function(ex) {
[16:01:46.655]                       msg <- conditionMessage(ex)
[16:01:46.655]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.655]                         fi_tmp[["mtime"]], msg)
[16:01:46.655]                       ex$message <- msg
[16:01:46.655]                       stop(ex)
[16:01:46.655]                     })
[16:01:46.655]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.655]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.655]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.655]                       fi <- file.info(pathname)
[16:01:46.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.655]                         fi[["size"]], fi[["mtime"]])
[16:01:46.655]                       stop(msg)
[16:01:46.655]                     }
[16:01:46.655]                     invisible(pathname)
[16:01:46.655]                   }
[16:01:46.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.655]                     rootPath = tempdir()) 
[16:01:46.655]                   {
[16:01:46.655]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.655]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.655]                       tmpdir = path, fileext = ".rds")
[16:01:46.655]                     save_rds(obj, file)
[16:01:46.655]                   }
[16:01:46.655]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.655]                   {
[16:01:46.655]                     inherits <- base::inherits
[16:01:46.655]                     invokeRestart <- base::invokeRestart
[16:01:46.655]                     is.null <- base::is.null
[16:01:46.655]                     muffled <- FALSE
[16:01:46.655]                     if (inherits(cond, "message")) {
[16:01:46.655]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.655]                       if (muffled) 
[16:01:46.655]                         invokeRestart("muffleMessage")
[16:01:46.655]                     }
[16:01:46.655]                     else if (inherits(cond, "warning")) {
[16:01:46.655]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.655]                       if (muffled) 
[16:01:46.655]                         invokeRestart("muffleWarning")
[16:01:46.655]                     }
[16:01:46.655]                     else if (inherits(cond, "condition")) {
[16:01:46.655]                       if (!is.null(pattern)) {
[16:01:46.655]                         computeRestarts <- base::computeRestarts
[16:01:46.655]                         grepl <- base::grepl
[16:01:46.655]                         restarts <- computeRestarts(cond)
[16:01:46.655]                         for (restart in restarts) {
[16:01:46.655]                           name <- restart$name
[16:01:46.655]                           if (is.null(name)) 
[16:01:46.655]                             next
[16:01:46.655]                           if (!grepl(pattern, name)) 
[16:01:46.655]                             next
[16:01:46.655]                           invokeRestart(restart)
[16:01:46.655]                           muffled <- TRUE
[16:01:46.655]                           break
[16:01:46.655]                         }
[16:01:46.655]                       }
[16:01:46.655]                     }
[16:01:46.655]                     invisible(muffled)
[16:01:46.655]                   }
[16:01:46.655]                   muffleCondition(cond)
[16:01:46.655]                 })
[16:01:46.655]             }))
[16:01:46.655]             future::FutureResult(value = ...future.value$value, 
[16:01:46.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.655]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.655]                     ...future.globalenv.names))
[16:01:46.655]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.655]         }, condition = base::local({
[16:01:46.655]             c <- base::c
[16:01:46.655]             inherits <- base::inherits
[16:01:46.655]             invokeRestart <- base::invokeRestart
[16:01:46.655]             length <- base::length
[16:01:46.655]             list <- base::list
[16:01:46.655]             seq.int <- base::seq.int
[16:01:46.655]             signalCondition <- base::signalCondition
[16:01:46.655]             sys.calls <- base::sys.calls
[16:01:46.655]             `[[` <- base::`[[`
[16:01:46.655]             `+` <- base::`+`
[16:01:46.655]             `<<-` <- base::`<<-`
[16:01:46.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.655]                   3L)]
[16:01:46.655]             }
[16:01:46.655]             function(cond) {
[16:01:46.655]                 is_error <- inherits(cond, "error")
[16:01:46.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.655]                   NULL)
[16:01:46.655]                 if (is_error) {
[16:01:46.655]                   sessionInformation <- function() {
[16:01:46.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.655]                       search = base::search(), system = base::Sys.info())
[16:01:46.655]                   }
[16:01:46.655]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.655]                     cond$call), session = sessionInformation(), 
[16:01:46.655]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.655]                   signalCondition(cond)
[16:01:46.655]                 }
[16:01:46.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.655]                 "immediateCondition"))) {
[16:01:46.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.655]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.655]                   if (TRUE && !signal) {
[16:01:46.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.655]                     {
[16:01:46.655]                       inherits <- base::inherits
[16:01:46.655]                       invokeRestart <- base::invokeRestart
[16:01:46.655]                       is.null <- base::is.null
[16:01:46.655]                       muffled <- FALSE
[16:01:46.655]                       if (inherits(cond, "message")) {
[16:01:46.655]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.655]                         if (muffled) 
[16:01:46.655]                           invokeRestart("muffleMessage")
[16:01:46.655]                       }
[16:01:46.655]                       else if (inherits(cond, "warning")) {
[16:01:46.655]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.655]                         if (muffled) 
[16:01:46.655]                           invokeRestart("muffleWarning")
[16:01:46.655]                       }
[16:01:46.655]                       else if (inherits(cond, "condition")) {
[16:01:46.655]                         if (!is.null(pattern)) {
[16:01:46.655]                           computeRestarts <- base::computeRestarts
[16:01:46.655]                           grepl <- base::grepl
[16:01:46.655]                           restarts <- computeRestarts(cond)
[16:01:46.655]                           for (restart in restarts) {
[16:01:46.655]                             name <- restart$name
[16:01:46.655]                             if (is.null(name)) 
[16:01:46.655]                               next
[16:01:46.655]                             if (!grepl(pattern, name)) 
[16:01:46.655]                               next
[16:01:46.655]                             invokeRestart(restart)
[16:01:46.655]                             muffled <- TRUE
[16:01:46.655]                             break
[16:01:46.655]                           }
[16:01:46.655]                         }
[16:01:46.655]                       }
[16:01:46.655]                       invisible(muffled)
[16:01:46.655]                     }
[16:01:46.655]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.655]                   }
[16:01:46.655]                 }
[16:01:46.655]                 else {
[16:01:46.655]                   if (TRUE) {
[16:01:46.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.655]                     {
[16:01:46.655]                       inherits <- base::inherits
[16:01:46.655]                       invokeRestart <- base::invokeRestart
[16:01:46.655]                       is.null <- base::is.null
[16:01:46.655]                       muffled <- FALSE
[16:01:46.655]                       if (inherits(cond, "message")) {
[16:01:46.655]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.655]                         if (muffled) 
[16:01:46.655]                           invokeRestart("muffleMessage")
[16:01:46.655]                       }
[16:01:46.655]                       else if (inherits(cond, "warning")) {
[16:01:46.655]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.655]                         if (muffled) 
[16:01:46.655]                           invokeRestart("muffleWarning")
[16:01:46.655]                       }
[16:01:46.655]                       else if (inherits(cond, "condition")) {
[16:01:46.655]                         if (!is.null(pattern)) {
[16:01:46.655]                           computeRestarts <- base::computeRestarts
[16:01:46.655]                           grepl <- base::grepl
[16:01:46.655]                           restarts <- computeRestarts(cond)
[16:01:46.655]                           for (restart in restarts) {
[16:01:46.655]                             name <- restart$name
[16:01:46.655]                             if (is.null(name)) 
[16:01:46.655]                               next
[16:01:46.655]                             if (!grepl(pattern, name)) 
[16:01:46.655]                               next
[16:01:46.655]                             invokeRestart(restart)
[16:01:46.655]                             muffled <- TRUE
[16:01:46.655]                             break
[16:01:46.655]                           }
[16:01:46.655]                         }
[16:01:46.655]                       }
[16:01:46.655]                       invisible(muffled)
[16:01:46.655]                     }
[16:01:46.655]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.655]                   }
[16:01:46.655]                 }
[16:01:46.655]             }
[16:01:46.655]         }))
[16:01:46.655]     }, error = function(ex) {
[16:01:46.655]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.655]                 ...future.rng), started = ...future.startTime, 
[16:01:46.655]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.655]             version = "1.8"), class = "FutureResult")
[16:01:46.655]     }, finally = {
[16:01:46.655]         if (!identical(...future.workdir, getwd())) 
[16:01:46.655]             setwd(...future.workdir)
[16:01:46.655]         {
[16:01:46.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.655]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.655]             }
[16:01:46.655]             base::options(...future.oldOptions)
[16:01:46.655]             if (.Platform$OS.type == "windows") {
[16:01:46.655]                 old_names <- names(...future.oldEnvVars)
[16:01:46.655]                 envs <- base::Sys.getenv()
[16:01:46.655]                 names <- names(envs)
[16:01:46.655]                 common <- intersect(names, old_names)
[16:01:46.655]                 added <- setdiff(names, old_names)
[16:01:46.655]                 removed <- setdiff(old_names, names)
[16:01:46.655]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.655]                   envs[common]]
[16:01:46.655]                 NAMES <- toupper(changed)
[16:01:46.655]                 args <- list()
[16:01:46.655]                 for (kk in seq_along(NAMES)) {
[16:01:46.655]                   name <- changed[[kk]]
[16:01:46.655]                   NAME <- NAMES[[kk]]
[16:01:46.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.655]                     next
[16:01:46.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.655]                 }
[16:01:46.655]                 NAMES <- toupper(added)
[16:01:46.655]                 for (kk in seq_along(NAMES)) {
[16:01:46.655]                   name <- added[[kk]]
[16:01:46.655]                   NAME <- NAMES[[kk]]
[16:01:46.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.655]                     next
[16:01:46.655]                   args[[name]] <- ""
[16:01:46.655]                 }
[16:01:46.655]                 NAMES <- toupper(removed)
[16:01:46.655]                 for (kk in seq_along(NAMES)) {
[16:01:46.655]                   name <- removed[[kk]]
[16:01:46.655]                   NAME <- NAMES[[kk]]
[16:01:46.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.655]                     next
[16:01:46.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.655]                 }
[16:01:46.655]                 if (length(args) > 0) 
[16:01:46.655]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.655]             }
[16:01:46.655]             else {
[16:01:46.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.655]             }
[16:01:46.655]             {
[16:01:46.655]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.655]                   0L) {
[16:01:46.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.655]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.655]                   base::options(opts)
[16:01:46.655]                 }
[16:01:46.655]                 {
[16:01:46.655]                   {
[16:01:46.655]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.655]                     NULL
[16:01:46.655]                   }
[16:01:46.655]                   options(future.plan = NULL)
[16:01:46.655]                   if (is.na(NA_character_)) 
[16:01:46.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.655]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.655]                     envir = parent.frame()) 
[16:01:46.655]                   {
[16:01:46.655]                     default_workers <- missing(workers)
[16:01:46.655]                     if (is.function(workers)) 
[16:01:46.655]                       workers <- workers()
[16:01:46.655]                     workers <- structure(as.integer(workers), 
[16:01:46.655]                       class = class(workers))
[16:01:46.655]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.655]                       1L)
[16:01:46.655]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.655]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.655]                       if (default_workers) 
[16:01:46.655]                         supportsMulticore(warn = TRUE)
[16:01:46.655]                       return(sequential(..., envir = envir))
[16:01:46.655]                     }
[16:01:46.655]                     oopts <- options(mc.cores = workers)
[16:01:46.655]                     on.exit(options(oopts))
[16:01:46.655]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.655]                       envir = envir)
[16:01:46.655]                     if (!future$lazy) 
[16:01:46.655]                       future <- run(future)
[16:01:46.655]                     invisible(future)
[16:01:46.655]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.655]                 }
[16:01:46.655]             }
[16:01:46.655]         }
[16:01:46.655]     })
[16:01:46.655]     if (TRUE) {
[16:01:46.655]         base::sink(type = "output", split = FALSE)
[16:01:46.655]         if (TRUE) {
[16:01:46.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.655]         }
[16:01:46.655]         else {
[16:01:46.655]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.655]         }
[16:01:46.655]         base::close(...future.stdout)
[16:01:46.655]         ...future.stdout <- NULL
[16:01:46.655]     }
[16:01:46.655]     ...future.result$conditions <- ...future.conditions
[16:01:46.655]     ...future.result$finished <- base::Sys.time()
[16:01:46.655]     ...future.result
[16:01:46.655] }
[16:01:46.658] assign_globals() ...
[16:01:46.658] List of 5
[16:01:46.658]  $ ...future.FUN            :function (object, ...)  
[16:01:46.658]  $ future.call.arguments    : list()
[16:01:46.658]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.658]  $ ...future.elements_ii    :List of 1
[16:01:46.658]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.658]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:46.658]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.658]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.658]  $ ...future.seeds_ii       : NULL
[16:01:46.658]  $ ...future.globals.maxSize: NULL
[16:01:46.658]  - attr(*, "where")=List of 5
[16:01:46.658]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.658]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.658]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.658]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.658]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.658]  - attr(*, "resolved")= logi FALSE
[16:01:46.658]  - attr(*, "total_size")= num 1240
[16:01:46.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.658]  - attr(*, "already-done")= logi TRUE
[16:01:46.664] - copied ‘...future.FUN’ to environment
[16:01:46.664] - copied ‘future.call.arguments’ to environment
[16:01:46.664] - copied ‘...future.elements_ii’ to environment
[16:01:46.664] - copied ‘...future.seeds_ii’ to environment
[16:01:46.664] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.664] assign_globals() ... done
[16:01:46.664] requestCore(): workers = 2
[16:01:46.667] MulticoreFuture started
[16:01:46.667] - Launch lazy future ... done
[16:01:46.667] run() for ‘MulticoreFuture’ ... done
[16:01:46.668] Created future:
[16:01:46.668] plan(): Setting new future strategy stack:
[16:01:46.668] List of future strategies:
[16:01:46.668] 1. sequential:
[16:01:46.668]    - args: function (..., envir = parent.frame())
[16:01:46.668]    - tweaked: FALSE
[16:01:46.668]    - call: NULL
[16:01:46.669] plan(): nbrOfWorkers() = 1
[16:01:46.673] plan(): Setting new future strategy stack:
[16:01:46.673] List of future strategies:
[16:01:46.673] 1. multicore:
[16:01:46.673]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.673]    - tweaked: FALSE
[16:01:46.673]    - call: plan(strategy)
[16:01:46.678] plan(): nbrOfWorkers() = 2
[16:01:46.668] MulticoreFuture:
[16:01:46.668] Label: ‘future_by-1’
[16:01:46.668] Expression:
[16:01:46.668] {
[16:01:46.668]     do.call(function(...) {
[16:01:46.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.668]             on.exit(options(oopts), add = TRUE)
[16:01:46.668]         }
[16:01:46.668]         {
[16:01:46.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.668]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.668]             })
[16:01:46.668]         }
[16:01:46.668]     }, args = future.call.arguments)
[16:01:46.668] }
[16:01:46.668] Lazy evaluation: FALSE
[16:01:46.668] Asynchronous evaluation: TRUE
[16:01:46.668] Local evaluation: TRUE
[16:01:46.668] Environment: 0x55b5260ec3f0
[16:01:46.668] Capture standard output: TRUE
[16:01:46.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.668] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.668] Packages: <none>
[16:01:46.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.668] Resolved: TRUE
[16:01:46.668] Value: <not collected>
[16:01:46.668] Conditions captured: <none>
[16:01:46.668] Early signaling: FALSE
[16:01:46.668] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.668] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.679] Chunk #1 of 2 ... DONE
[16:01:46.679] Chunk #2 of 2 ...
[16:01:46.680]  - Finding globals in 'X' for chunk #2 ...
[16:01:46.680] getGlobalsAndPackages() ...
[16:01:46.680] Searching for globals...
[16:01:46.681] 
[16:01:46.681] Searching for globals ... DONE
[16:01:46.681] - globals: [0] <none>
[16:01:46.681] getGlobalsAndPackages() ... DONE
[16:01:46.681]    + additional globals found: [n=0] 
[16:01:46.681]    + additional namespaces needed: [n=0] 
[16:01:46.681]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:46.682]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.682]  - seeds: <none>
[16:01:46.682]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.682] getGlobalsAndPackages() ...
[16:01:46.682] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.682] Resolving globals: FALSE
[16:01:46.683] Tweak future expression to call with '...' arguments ...
[16:01:46.683] {
[16:01:46.683]     do.call(function(...) {
[16:01:46.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.683]             on.exit(options(oopts), add = TRUE)
[16:01:46.683]         }
[16:01:46.683]         {
[16:01:46.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.683]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.683]             })
[16:01:46.683]         }
[16:01:46.683]     }, args = future.call.arguments)
[16:01:46.683] }
[16:01:46.683] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.684] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.684] 
[16:01:46.685] getGlobalsAndPackages() ... DONE
[16:01:46.685] run() for ‘Future’ ...
[16:01:46.685] - state: ‘created’
[16:01:46.685] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.691] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.691] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.691]   - Field: ‘label’
[16:01:46.692]   - Field: ‘local’
[16:01:46.692]   - Field: ‘owner’
[16:01:46.692]   - Field: ‘envir’
[16:01:46.692]   - Field: ‘workers’
[16:01:46.692]   - Field: ‘packages’
[16:01:46.693]   - Field: ‘gc’
[16:01:46.693]   - Field: ‘job’
[16:01:46.693]   - Field: ‘conditions’
[16:01:46.693]   - Field: ‘expr’
[16:01:46.694]   - Field: ‘uuid’
[16:01:46.694]   - Field: ‘seed’
[16:01:46.694]   - Field: ‘version’
[16:01:46.694]   - Field: ‘result’
[16:01:46.694]   - Field: ‘asynchronous’
[16:01:46.695]   - Field: ‘calls’
[16:01:46.695]   - Field: ‘globals’
[16:01:46.695]   - Field: ‘stdout’
[16:01:46.695]   - Field: ‘earlySignal’
[16:01:46.695]   - Field: ‘lazy’
[16:01:46.696]   - Field: ‘state’
[16:01:46.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.696] - Launch lazy future ...
[16:01:46.696] Packages needed by the future expression (n = 0): <none>
[16:01:46.697] Packages needed by future strategies (n = 0): <none>
[16:01:46.698] {
[16:01:46.698]     {
[16:01:46.698]         {
[16:01:46.698]             ...future.startTime <- base::Sys.time()
[16:01:46.698]             {
[16:01:46.698]                 {
[16:01:46.698]                   {
[16:01:46.698]                     {
[16:01:46.698]                       base::local({
[16:01:46.698]                         has_future <- base::requireNamespace("future", 
[16:01:46.698]                           quietly = TRUE)
[16:01:46.698]                         if (has_future) {
[16:01:46.698]                           ns <- base::getNamespace("future")
[16:01:46.698]                           version <- ns[[".package"]][["version"]]
[16:01:46.698]                           if (is.null(version)) 
[16:01:46.698]                             version <- utils::packageVersion("future")
[16:01:46.698]                         }
[16:01:46.698]                         else {
[16:01:46.698]                           version <- NULL
[16:01:46.698]                         }
[16:01:46.698]                         if (!has_future || version < "1.8.0") {
[16:01:46.698]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.698]                             "", base::R.version$version.string), 
[16:01:46.698]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.698]                               "release", "version")], collapse = " "), 
[16:01:46.698]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.698]                             info)
[16:01:46.698]                           info <- base::paste(info, collapse = "; ")
[16:01:46.698]                           if (!has_future) {
[16:01:46.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.698]                               info)
[16:01:46.698]                           }
[16:01:46.698]                           else {
[16:01:46.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.698]                               info, version)
[16:01:46.698]                           }
[16:01:46.698]                           base::stop(msg)
[16:01:46.698]                         }
[16:01:46.698]                       })
[16:01:46.698]                     }
[16:01:46.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.698]                     base::options(mc.cores = 1L)
[16:01:46.698]                   }
[16:01:46.698]                   options(future.plan = NULL)
[16:01:46.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.698]                 }
[16:01:46.698]                 ...future.workdir <- getwd()
[16:01:46.698]             }
[16:01:46.698]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.698]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.698]         }
[16:01:46.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.698]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.698]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.698]             base::names(...future.oldOptions))
[16:01:46.698]     }
[16:01:46.698]     if (FALSE) {
[16:01:46.698]     }
[16:01:46.698]     else {
[16:01:46.698]         if (TRUE) {
[16:01:46.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.698]                 open = "w")
[16:01:46.698]         }
[16:01:46.698]         else {
[16:01:46.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.698]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.698]         }
[16:01:46.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.698]             base::sink(type = "output", split = FALSE)
[16:01:46.698]             base::close(...future.stdout)
[16:01:46.698]         }, add = TRUE)
[16:01:46.698]     }
[16:01:46.698]     ...future.frame <- base::sys.nframe()
[16:01:46.698]     ...future.conditions <- base::list()
[16:01:46.698]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.698]     if (FALSE) {
[16:01:46.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.698]     }
[16:01:46.698]     ...future.result <- base::tryCatch({
[16:01:46.698]         base::withCallingHandlers({
[16:01:46.698]             ...future.value <- base::withVisible(base::local({
[16:01:46.698]                 withCallingHandlers({
[16:01:46.698]                   {
[16:01:46.698]                     do.call(function(...) {
[16:01:46.698]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.698]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.698]                         ...future.globals.maxSize)) {
[16:01:46.698]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.698]                         on.exit(options(oopts), add = TRUE)
[16:01:46.698]                       }
[16:01:46.698]                       {
[16:01:46.698]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.698]                           FUN = function(jj) {
[16:01:46.698]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.698]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.698]                           })
[16:01:46.698]                       }
[16:01:46.698]                     }, args = future.call.arguments)
[16:01:46.698]                   }
[16:01:46.698]                 }, immediateCondition = function(cond) {
[16:01:46.698]                   save_rds <- function (object, pathname, ...) 
[16:01:46.698]                   {
[16:01:46.698]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.698]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.698]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.698]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.698]                         fi_tmp[["mtime"]])
[16:01:46.698]                     }
[16:01:46.698]                     tryCatch({
[16:01:46.698]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.698]                     }, error = function(ex) {
[16:01:46.698]                       msg <- conditionMessage(ex)
[16:01:46.698]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.698]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.698]                         fi_tmp[["mtime"]], msg)
[16:01:46.698]                       ex$message <- msg
[16:01:46.698]                       stop(ex)
[16:01:46.698]                     })
[16:01:46.698]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.698]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.698]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.698]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.698]                       fi <- file.info(pathname)
[16:01:46.698]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.698]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.698]                         fi[["size"]], fi[["mtime"]])
[16:01:46.698]                       stop(msg)
[16:01:46.698]                     }
[16:01:46.698]                     invisible(pathname)
[16:01:46.698]                   }
[16:01:46.698]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.698]                     rootPath = tempdir()) 
[16:01:46.698]                   {
[16:01:46.698]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.698]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.698]                       tmpdir = path, fileext = ".rds")
[16:01:46.698]                     save_rds(obj, file)
[16:01:46.698]                   }
[16:01:46.698]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.698]                   {
[16:01:46.698]                     inherits <- base::inherits
[16:01:46.698]                     invokeRestart <- base::invokeRestart
[16:01:46.698]                     is.null <- base::is.null
[16:01:46.698]                     muffled <- FALSE
[16:01:46.698]                     if (inherits(cond, "message")) {
[16:01:46.698]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.698]                       if (muffled) 
[16:01:46.698]                         invokeRestart("muffleMessage")
[16:01:46.698]                     }
[16:01:46.698]                     else if (inherits(cond, "warning")) {
[16:01:46.698]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.698]                       if (muffled) 
[16:01:46.698]                         invokeRestart("muffleWarning")
[16:01:46.698]                     }
[16:01:46.698]                     else if (inherits(cond, "condition")) {
[16:01:46.698]                       if (!is.null(pattern)) {
[16:01:46.698]                         computeRestarts <- base::computeRestarts
[16:01:46.698]                         grepl <- base::grepl
[16:01:46.698]                         restarts <- computeRestarts(cond)
[16:01:46.698]                         for (restart in restarts) {
[16:01:46.698]                           name <- restart$name
[16:01:46.698]                           if (is.null(name)) 
[16:01:46.698]                             next
[16:01:46.698]                           if (!grepl(pattern, name)) 
[16:01:46.698]                             next
[16:01:46.698]                           invokeRestart(restart)
[16:01:46.698]                           muffled <- TRUE
[16:01:46.698]                           break
[16:01:46.698]                         }
[16:01:46.698]                       }
[16:01:46.698]                     }
[16:01:46.698]                     invisible(muffled)
[16:01:46.698]                   }
[16:01:46.698]                   muffleCondition(cond)
[16:01:46.698]                 })
[16:01:46.698]             }))
[16:01:46.698]             future::FutureResult(value = ...future.value$value, 
[16:01:46.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.698]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.698]                     ...future.globalenv.names))
[16:01:46.698]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.698]         }, condition = base::local({
[16:01:46.698]             c <- base::c
[16:01:46.698]             inherits <- base::inherits
[16:01:46.698]             invokeRestart <- base::invokeRestart
[16:01:46.698]             length <- base::length
[16:01:46.698]             list <- base::list
[16:01:46.698]             seq.int <- base::seq.int
[16:01:46.698]             signalCondition <- base::signalCondition
[16:01:46.698]             sys.calls <- base::sys.calls
[16:01:46.698]             `[[` <- base::`[[`
[16:01:46.698]             `+` <- base::`+`
[16:01:46.698]             `<<-` <- base::`<<-`
[16:01:46.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.698]                   3L)]
[16:01:46.698]             }
[16:01:46.698]             function(cond) {
[16:01:46.698]                 is_error <- inherits(cond, "error")
[16:01:46.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.698]                   NULL)
[16:01:46.698]                 if (is_error) {
[16:01:46.698]                   sessionInformation <- function() {
[16:01:46.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.698]                       search = base::search(), system = base::Sys.info())
[16:01:46.698]                   }
[16:01:46.698]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.698]                     cond$call), session = sessionInformation(), 
[16:01:46.698]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.698]                   signalCondition(cond)
[16:01:46.698]                 }
[16:01:46.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.698]                 "immediateCondition"))) {
[16:01:46.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.698]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.698]                   if (TRUE && !signal) {
[16:01:46.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.698]                     {
[16:01:46.698]                       inherits <- base::inherits
[16:01:46.698]                       invokeRestart <- base::invokeRestart
[16:01:46.698]                       is.null <- base::is.null
[16:01:46.698]                       muffled <- FALSE
[16:01:46.698]                       if (inherits(cond, "message")) {
[16:01:46.698]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.698]                         if (muffled) 
[16:01:46.698]                           invokeRestart("muffleMessage")
[16:01:46.698]                       }
[16:01:46.698]                       else if (inherits(cond, "warning")) {
[16:01:46.698]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.698]                         if (muffled) 
[16:01:46.698]                           invokeRestart("muffleWarning")
[16:01:46.698]                       }
[16:01:46.698]                       else if (inherits(cond, "condition")) {
[16:01:46.698]                         if (!is.null(pattern)) {
[16:01:46.698]                           computeRestarts <- base::computeRestarts
[16:01:46.698]                           grepl <- base::grepl
[16:01:46.698]                           restarts <- computeRestarts(cond)
[16:01:46.698]                           for (restart in restarts) {
[16:01:46.698]                             name <- restart$name
[16:01:46.698]                             if (is.null(name)) 
[16:01:46.698]                               next
[16:01:46.698]                             if (!grepl(pattern, name)) 
[16:01:46.698]                               next
[16:01:46.698]                             invokeRestart(restart)
[16:01:46.698]                             muffled <- TRUE
[16:01:46.698]                             break
[16:01:46.698]                           }
[16:01:46.698]                         }
[16:01:46.698]                       }
[16:01:46.698]                       invisible(muffled)
[16:01:46.698]                     }
[16:01:46.698]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.698]                   }
[16:01:46.698]                 }
[16:01:46.698]                 else {
[16:01:46.698]                   if (TRUE) {
[16:01:46.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.698]                     {
[16:01:46.698]                       inherits <- base::inherits
[16:01:46.698]                       invokeRestart <- base::invokeRestart
[16:01:46.698]                       is.null <- base::is.null
[16:01:46.698]                       muffled <- FALSE
[16:01:46.698]                       if (inherits(cond, "message")) {
[16:01:46.698]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.698]                         if (muffled) 
[16:01:46.698]                           invokeRestart("muffleMessage")
[16:01:46.698]                       }
[16:01:46.698]                       else if (inherits(cond, "warning")) {
[16:01:46.698]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.698]                         if (muffled) 
[16:01:46.698]                           invokeRestart("muffleWarning")
[16:01:46.698]                       }
[16:01:46.698]                       else if (inherits(cond, "condition")) {
[16:01:46.698]                         if (!is.null(pattern)) {
[16:01:46.698]                           computeRestarts <- base::computeRestarts
[16:01:46.698]                           grepl <- base::grepl
[16:01:46.698]                           restarts <- computeRestarts(cond)
[16:01:46.698]                           for (restart in restarts) {
[16:01:46.698]                             name <- restart$name
[16:01:46.698]                             if (is.null(name)) 
[16:01:46.698]                               next
[16:01:46.698]                             if (!grepl(pattern, name)) 
[16:01:46.698]                               next
[16:01:46.698]                             invokeRestart(restart)
[16:01:46.698]                             muffled <- TRUE
[16:01:46.698]                             break
[16:01:46.698]                           }
[16:01:46.698]                         }
[16:01:46.698]                       }
[16:01:46.698]                       invisible(muffled)
[16:01:46.698]                     }
[16:01:46.698]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.698]                   }
[16:01:46.698]                 }
[16:01:46.698]             }
[16:01:46.698]         }))
[16:01:46.698]     }, error = function(ex) {
[16:01:46.698]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.698]                 ...future.rng), started = ...future.startTime, 
[16:01:46.698]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.698]             version = "1.8"), class = "FutureResult")
[16:01:46.698]     }, finally = {
[16:01:46.698]         if (!identical(...future.workdir, getwd())) 
[16:01:46.698]             setwd(...future.workdir)
[16:01:46.698]         {
[16:01:46.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.698]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.698]             }
[16:01:46.698]             base::options(...future.oldOptions)
[16:01:46.698]             if (.Platform$OS.type == "windows") {
[16:01:46.698]                 old_names <- names(...future.oldEnvVars)
[16:01:46.698]                 envs <- base::Sys.getenv()
[16:01:46.698]                 names <- names(envs)
[16:01:46.698]                 common <- intersect(names, old_names)
[16:01:46.698]                 added <- setdiff(names, old_names)
[16:01:46.698]                 removed <- setdiff(old_names, names)
[16:01:46.698]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.698]                   envs[common]]
[16:01:46.698]                 NAMES <- toupper(changed)
[16:01:46.698]                 args <- list()
[16:01:46.698]                 for (kk in seq_along(NAMES)) {
[16:01:46.698]                   name <- changed[[kk]]
[16:01:46.698]                   NAME <- NAMES[[kk]]
[16:01:46.698]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.698]                     next
[16:01:46.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.698]                 }
[16:01:46.698]                 NAMES <- toupper(added)
[16:01:46.698]                 for (kk in seq_along(NAMES)) {
[16:01:46.698]                   name <- added[[kk]]
[16:01:46.698]                   NAME <- NAMES[[kk]]
[16:01:46.698]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.698]                     next
[16:01:46.698]                   args[[name]] <- ""
[16:01:46.698]                 }
[16:01:46.698]                 NAMES <- toupper(removed)
[16:01:46.698]                 for (kk in seq_along(NAMES)) {
[16:01:46.698]                   name <- removed[[kk]]
[16:01:46.698]                   NAME <- NAMES[[kk]]
[16:01:46.698]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.698]                     next
[16:01:46.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.698]                 }
[16:01:46.698]                 if (length(args) > 0) 
[16:01:46.698]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.698]             }
[16:01:46.698]             else {
[16:01:46.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.698]             }
[16:01:46.698]             {
[16:01:46.698]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.698]                   0L) {
[16:01:46.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.698]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.698]                   base::options(opts)
[16:01:46.698]                 }
[16:01:46.698]                 {
[16:01:46.698]                   {
[16:01:46.698]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.698]                     NULL
[16:01:46.698]                   }
[16:01:46.698]                   options(future.plan = NULL)
[16:01:46.698]                   if (is.na(NA_character_)) 
[16:01:46.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.698]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.698]                     envir = parent.frame()) 
[16:01:46.698]                   {
[16:01:46.698]                     default_workers <- missing(workers)
[16:01:46.698]                     if (is.function(workers)) 
[16:01:46.698]                       workers <- workers()
[16:01:46.698]                     workers <- structure(as.integer(workers), 
[16:01:46.698]                       class = class(workers))
[16:01:46.698]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.698]                       1L)
[16:01:46.698]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.698]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.698]                       if (default_workers) 
[16:01:46.698]                         supportsMulticore(warn = TRUE)
[16:01:46.698]                       return(sequential(..., envir = envir))
[16:01:46.698]                     }
[16:01:46.698]                     oopts <- options(mc.cores = workers)
[16:01:46.698]                     on.exit(options(oopts))
[16:01:46.698]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.698]                       envir = envir)
[16:01:46.698]                     if (!future$lazy) 
[16:01:46.698]                       future <- run(future)
[16:01:46.698]                     invisible(future)
[16:01:46.698]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.698]                 }
[16:01:46.698]             }
[16:01:46.698]         }
[16:01:46.698]     })
[16:01:46.698]     if (TRUE) {
[16:01:46.698]         base::sink(type = "output", split = FALSE)
[16:01:46.698]         if (TRUE) {
[16:01:46.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.698]         }
[16:01:46.698]         else {
[16:01:46.698]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.698]         }
[16:01:46.698]         base::close(...future.stdout)
[16:01:46.698]         ...future.stdout <- NULL
[16:01:46.698]     }
[16:01:46.698]     ...future.result$conditions <- ...future.conditions
[16:01:46.698]     ...future.result$finished <- base::Sys.time()
[16:01:46.698]     ...future.result
[16:01:46.698] }
[16:01:46.701] assign_globals() ...
[16:01:46.701] List of 5
[16:01:46.701]  $ ...future.FUN            :function (object, ...)  
[16:01:46.701]  $ future.call.arguments    : list()
[16:01:46.701]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.701]  $ ...future.elements_ii    :List of 2
[16:01:46.701]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.701]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:46.701]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.701]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:46.701]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.701]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:46.701]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.701]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:46.701]  $ ...future.seeds_ii       : NULL
[16:01:46.701]  $ ...future.globals.maxSize: NULL
[16:01:46.701]  - attr(*, "where")=List of 5
[16:01:46.701]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.701]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.701]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.701]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.701]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.701]  - attr(*, "resolved")= logi FALSE
[16:01:46.701]  - attr(*, "total_size")= num 1240
[16:01:46.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.701]  - attr(*, "already-done")= logi TRUE
[16:01:46.712] - copied ‘...future.FUN’ to environment
[16:01:46.712] - copied ‘future.call.arguments’ to environment
[16:01:46.712] - copied ‘...future.elements_ii’ to environment
[16:01:46.713] - copied ‘...future.seeds_ii’ to environment
[16:01:46.713] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.713] assign_globals() ... done
[16:01:46.713] requestCore(): workers = 2
[16:01:46.715] MulticoreFuture started
[16:01:46.716] - Launch lazy future ... done
[16:01:46.716] run() for ‘MulticoreFuture’ ... done
[16:01:46.716] Created future:
[16:01:46.717] plan(): Setting new future strategy stack:
[16:01:46.717] List of future strategies:
[16:01:46.717] 1. sequential:
[16:01:46.717]    - args: function (..., envir = parent.frame())
[16:01:46.717]    - tweaked: FALSE
[16:01:46.717]    - call: NULL
[16:01:46.718] plan(): nbrOfWorkers() = 1
[16:01:46.722] plan(): Setting new future strategy stack:
[16:01:46.722] List of future strategies:
[16:01:46.722] 1. multicore:
[16:01:46.722]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.722]    - tweaked: FALSE
[16:01:46.722]    - call: plan(strategy)
[16:01:46.727] plan(): nbrOfWorkers() = 2
[16:01:46.716] MulticoreFuture:
[16:01:46.716] Label: ‘future_by-2’
[16:01:46.716] Expression:
[16:01:46.716] {
[16:01:46.716]     do.call(function(...) {
[16:01:46.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.716]             on.exit(options(oopts), add = TRUE)
[16:01:46.716]         }
[16:01:46.716]         {
[16:01:46.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.716]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.716]             })
[16:01:46.716]         }
[16:01:46.716]     }, args = future.call.arguments)
[16:01:46.716] }
[16:01:46.716] Lazy evaluation: FALSE
[16:01:46.716] Asynchronous evaluation: TRUE
[16:01:46.716] Local evaluation: TRUE
[16:01:46.716] Environment: 0x55b5260ec3f0
[16:01:46.716] Capture standard output: TRUE
[16:01:46.716] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.716] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.716] Packages: <none>
[16:01:46.716] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.716] Resolved: TRUE
[16:01:46.716] Value: <not collected>
[16:01:46.716] Conditions captured: <none>
[16:01:46.716] Early signaling: FALSE
[16:01:46.716] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.716] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.728] Chunk #2 of 2 ... DONE
[16:01:46.728] Launching 2 futures (chunks) ... DONE
[16:01:46.728] Resolving 2 futures (chunks) ...
[16:01:46.728] resolve() on list ...
[16:01:46.729]  recursive: 0
[16:01:46.729]  length: 2
[16:01:46.729] 
[16:01:46.729] Future #1
[16:01:46.729] result() for MulticoreFuture ...
[16:01:46.730] result() for MulticoreFuture ...
[16:01:46.730] result() for MulticoreFuture ... done
[16:01:46.731] result() for MulticoreFuture ... done
[16:01:46.731] result() for MulticoreFuture ...
[16:01:46.731] result() for MulticoreFuture ... done
[16:01:46.731] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:46.731] - nx: 2
[16:01:46.731] - relay: TRUE
[16:01:46.731] - stdout: TRUE
[16:01:46.732] - signal: TRUE
[16:01:46.732] - resignal: FALSE
[16:01:46.732] - force: TRUE
[16:01:46.732] - relayed: [n=2] FALSE, FALSE
[16:01:46.732] - queued futures: [n=2] FALSE, FALSE
[16:01:46.732]  - until=1
[16:01:46.732]  - relaying element #1
[16:01:46.732] result() for MulticoreFuture ...
[16:01:46.733] result() for MulticoreFuture ... done
[16:01:46.733] result() for MulticoreFuture ...
[16:01:46.733] result() for MulticoreFuture ... done
[16:01:46.733] result() for MulticoreFuture ...
[16:01:46.733] result() for MulticoreFuture ... done
[16:01:46.733] result() for MulticoreFuture ...
[16:01:46.733] result() for MulticoreFuture ... done
[16:01:46.734] - relayed: [n=2] TRUE, FALSE
[16:01:46.734] - queued futures: [n=2] TRUE, FALSE
[16:01:46.734] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:46.734]  length: 1 (resolved future 1)
[16:01:46.734] Future #2
[16:01:46.734] result() for MulticoreFuture ...
[16:01:46.735] result() for MulticoreFuture ...
[16:01:46.735] result() for MulticoreFuture ... done
[16:01:46.735] result() for MulticoreFuture ... done
[16:01:46.735] result() for MulticoreFuture ...
[16:01:46.736] result() for MulticoreFuture ... done
[16:01:46.736] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:46.736] - nx: 2
[16:01:46.736] - relay: TRUE
[16:01:46.736] - stdout: TRUE
[16:01:46.736] - signal: TRUE
[16:01:46.736] - resignal: FALSE
[16:01:46.736] - force: TRUE
[16:01:46.736] - relayed: [n=2] TRUE, FALSE
[16:01:46.737] - queued futures: [n=2] TRUE, FALSE
[16:01:46.737]  - until=2
[16:01:46.737]  - relaying element #2
[16:01:46.737] result() for MulticoreFuture ...
[16:01:46.737] result() for MulticoreFuture ... done
[16:01:46.737] result() for MulticoreFuture ...
[16:01:46.737] result() for MulticoreFuture ... done
[16:01:46.738] result() for MulticoreFuture ...
[16:01:46.738] result() for MulticoreFuture ... done
[16:01:46.738] result() for MulticoreFuture ...
[16:01:46.738] result() for MulticoreFuture ... done
[16:01:46.738] - relayed: [n=2] TRUE, TRUE
[16:01:46.738] - queued futures: [n=2] TRUE, TRUE
[16:01:46.738] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:46.738]  length: 0 (resolved future 2)
[16:01:46.739] Relaying remaining futures
[16:01:46.739] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.739] - nx: 2
[16:01:46.739] - relay: TRUE
[16:01:46.739] - stdout: TRUE
[16:01:46.739] - signal: TRUE
[16:01:46.739] - resignal: FALSE
[16:01:46.739] - force: TRUE
[16:01:46.739] - relayed: [n=2] TRUE, TRUE
[16:01:46.740] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:46.740] - relayed: [n=2] TRUE, TRUE
[16:01:46.740] - queued futures: [n=2] TRUE, TRUE
[16:01:46.740] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.740] resolve() on list ... DONE
[16:01:46.740] result() for MulticoreFuture ...
[16:01:46.740] result() for MulticoreFuture ... done
[16:01:46.740] result() for MulticoreFuture ...
[16:01:46.741] result() for MulticoreFuture ... done
[16:01:46.741] result() for MulticoreFuture ...
[16:01:46.741] result() for MulticoreFuture ... done
[16:01:46.741] result() for MulticoreFuture ...
[16:01:46.741] result() for MulticoreFuture ... done
[16:01:46.741]  - Number of value chunks collected: 2
[16:01:46.741] Resolving 2 futures (chunks) ... DONE
[16:01:46.741] Reducing values from 2 chunks ...
[16:01:46.742]  - Number of values collected after concatenation: 3
[16:01:46.742]  - Number of values expected: 3
[16:01:46.742] Reducing values from 2 chunks ... DONE
[16:01:46.742] future_lapply() ... DONE
[16:01:46.742] future_by_internal() ... DONE
[16:01:46.743] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:01:46.744] future_lapply() ...
[16:01:46.749] Number of chunks: 2
[16:01:46.750] getGlobalsAndPackagesXApply() ...
[16:01:46.750]  - future.globals: TRUE
[16:01:46.750] getGlobalsAndPackages() ...
[16:01:46.750] Searching for globals...
[16:01:46.752] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:46.752] Searching for globals ... DONE
[16:01:46.752] Resolving globals: FALSE
[16:01:46.752] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:46.753] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:46.753] - globals: [1] ‘FUN’
[16:01:46.753] 
[16:01:46.753] getGlobalsAndPackages() ... DONE
[16:01:46.753]  - globals found/used: [n=1] ‘FUN’
[16:01:46.754]  - needed namespaces: [n=0] 
[16:01:46.754] Finding globals ... DONE
[16:01:46.754]  - use_args: TRUE
[16:01:46.754]  - Getting '...' globals ...
[16:01:46.754] resolve() on list ...
[16:01:46.754]  recursive: 0
[16:01:46.754]  length: 1
[16:01:46.755]  elements: ‘...’
[16:01:46.755]  length: 0 (resolved future 1)
[16:01:46.755] resolve() on list ... DONE
[16:01:46.755]    - '...' content: [n=0] 
[16:01:46.755] List of 1
[16:01:46.755]  $ ...: list()
[16:01:46.755]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.755]  - attr(*, "where")=List of 1
[16:01:46.755]   ..$ ...:<environment: 0x55b5271a89e8> 
[16:01:46.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.755]  - attr(*, "resolved")= logi TRUE
[16:01:46.755]  - attr(*, "total_size")= num NA
[16:01:46.759]  - Getting '...' globals ... DONE
[16:01:46.759] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:46.759] List of 2
[16:01:46.759]  $ ...future.FUN:function (object, ...)  
[16:01:46.759]  $ ...          : list()
[16:01:46.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.759]  - attr(*, "where")=List of 2
[16:01:46.759]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:46.759]   ..$ ...          :<environment: 0x55b5271a89e8> 
[16:01:46.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.759]  - attr(*, "resolved")= logi FALSE
[16:01:46.759]  - attr(*, "total_size")= num 1240
[16:01:46.762] Packages to be attached in all futures: [n=0] 
[16:01:46.762] getGlobalsAndPackagesXApply() ... DONE
[16:01:46.763] Number of futures (= number of chunks): 2
[16:01:46.763] Launching 2 futures (chunks) ...
[16:01:46.763] Chunk #1 of 2 ...
[16:01:46.763]  - Finding globals in 'X' for chunk #1 ...
[16:01:46.763] getGlobalsAndPackages() ...
[16:01:46.763] Searching for globals...
[16:01:46.764] 
[16:01:46.764] Searching for globals ... DONE
[16:01:46.764] - globals: [0] <none>
[16:01:46.764] getGlobalsAndPackages() ... DONE
[16:01:46.764]    + additional globals found: [n=0] 
[16:01:46.764]    + additional namespaces needed: [n=0] 
[16:01:46.765]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:46.765]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.765]  - seeds: <none>
[16:01:46.765]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.765] getGlobalsAndPackages() ...
[16:01:46.765] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.765] Resolving globals: FALSE
[16:01:46.765] Tweak future expression to call with '...' arguments ...
[16:01:46.766] {
[16:01:46.766]     do.call(function(...) {
[16:01:46.766]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.766]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.766]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.766]             on.exit(options(oopts), add = TRUE)
[16:01:46.766]         }
[16:01:46.766]         {
[16:01:46.766]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.766]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.766]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.766]             })
[16:01:46.766]         }
[16:01:46.766]     }, args = future.call.arguments)
[16:01:46.766] }
[16:01:46.766] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.766] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.767] 
[16:01:46.767] getGlobalsAndPackages() ... DONE
[16:01:46.767] run() for ‘Future’ ...
[16:01:46.767] - state: ‘created’
[16:01:46.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.772] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.772]   - Field: ‘label’
[16:01:46.772]   - Field: ‘local’
[16:01:46.772]   - Field: ‘owner’
[16:01:46.772]   - Field: ‘envir’
[16:01:46.772]   - Field: ‘workers’
[16:01:46.773]   - Field: ‘packages’
[16:01:46.773]   - Field: ‘gc’
[16:01:46.773]   - Field: ‘job’
[16:01:46.773]   - Field: ‘conditions’
[16:01:46.773]   - Field: ‘expr’
[16:01:46.773]   - Field: ‘uuid’
[16:01:46.773]   - Field: ‘seed’
[16:01:46.773]   - Field: ‘version’
[16:01:46.774]   - Field: ‘result’
[16:01:46.774]   - Field: ‘asynchronous’
[16:01:46.774]   - Field: ‘calls’
[16:01:46.774]   - Field: ‘globals’
[16:01:46.774]   - Field: ‘stdout’
[16:01:46.774]   - Field: ‘earlySignal’
[16:01:46.774]   - Field: ‘lazy’
[16:01:46.774]   - Field: ‘state’
[16:01:46.774] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.775] - Launch lazy future ...
[16:01:46.775] Packages needed by the future expression (n = 0): <none>
[16:01:46.775] Packages needed by future strategies (n = 0): <none>
[16:01:46.776] {
[16:01:46.776]     {
[16:01:46.776]         {
[16:01:46.776]             ...future.startTime <- base::Sys.time()
[16:01:46.776]             {
[16:01:46.776]                 {
[16:01:46.776]                   {
[16:01:46.776]                     {
[16:01:46.776]                       base::local({
[16:01:46.776]                         has_future <- base::requireNamespace("future", 
[16:01:46.776]                           quietly = TRUE)
[16:01:46.776]                         if (has_future) {
[16:01:46.776]                           ns <- base::getNamespace("future")
[16:01:46.776]                           version <- ns[[".package"]][["version"]]
[16:01:46.776]                           if (is.null(version)) 
[16:01:46.776]                             version <- utils::packageVersion("future")
[16:01:46.776]                         }
[16:01:46.776]                         else {
[16:01:46.776]                           version <- NULL
[16:01:46.776]                         }
[16:01:46.776]                         if (!has_future || version < "1.8.0") {
[16:01:46.776]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.776]                             "", base::R.version$version.string), 
[16:01:46.776]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.776]                               "release", "version")], collapse = " "), 
[16:01:46.776]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.776]                             info)
[16:01:46.776]                           info <- base::paste(info, collapse = "; ")
[16:01:46.776]                           if (!has_future) {
[16:01:46.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.776]                               info)
[16:01:46.776]                           }
[16:01:46.776]                           else {
[16:01:46.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.776]                               info, version)
[16:01:46.776]                           }
[16:01:46.776]                           base::stop(msg)
[16:01:46.776]                         }
[16:01:46.776]                       })
[16:01:46.776]                     }
[16:01:46.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.776]                     base::options(mc.cores = 1L)
[16:01:46.776]                   }
[16:01:46.776]                   options(future.plan = NULL)
[16:01:46.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.776]                 }
[16:01:46.776]                 ...future.workdir <- getwd()
[16:01:46.776]             }
[16:01:46.776]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.776]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.776]         }
[16:01:46.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.776]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.776]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.776]             base::names(...future.oldOptions))
[16:01:46.776]     }
[16:01:46.776]     if (FALSE) {
[16:01:46.776]     }
[16:01:46.776]     else {
[16:01:46.776]         if (TRUE) {
[16:01:46.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.776]                 open = "w")
[16:01:46.776]         }
[16:01:46.776]         else {
[16:01:46.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.776]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.776]         }
[16:01:46.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.776]             base::sink(type = "output", split = FALSE)
[16:01:46.776]             base::close(...future.stdout)
[16:01:46.776]         }, add = TRUE)
[16:01:46.776]     }
[16:01:46.776]     ...future.frame <- base::sys.nframe()
[16:01:46.776]     ...future.conditions <- base::list()
[16:01:46.776]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.776]     if (FALSE) {
[16:01:46.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.776]     }
[16:01:46.776]     ...future.result <- base::tryCatch({
[16:01:46.776]         base::withCallingHandlers({
[16:01:46.776]             ...future.value <- base::withVisible(base::local({
[16:01:46.776]                 withCallingHandlers({
[16:01:46.776]                   {
[16:01:46.776]                     do.call(function(...) {
[16:01:46.776]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.776]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.776]                         ...future.globals.maxSize)) {
[16:01:46.776]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.776]                         on.exit(options(oopts), add = TRUE)
[16:01:46.776]                       }
[16:01:46.776]                       {
[16:01:46.776]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.776]                           FUN = function(jj) {
[16:01:46.776]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.776]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.776]                           })
[16:01:46.776]                       }
[16:01:46.776]                     }, args = future.call.arguments)
[16:01:46.776]                   }
[16:01:46.776]                 }, immediateCondition = function(cond) {
[16:01:46.776]                   save_rds <- function (object, pathname, ...) 
[16:01:46.776]                   {
[16:01:46.776]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.776]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.776]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.776]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.776]                         fi_tmp[["mtime"]])
[16:01:46.776]                     }
[16:01:46.776]                     tryCatch({
[16:01:46.776]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.776]                     }, error = function(ex) {
[16:01:46.776]                       msg <- conditionMessage(ex)
[16:01:46.776]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.776]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.776]                         fi_tmp[["mtime"]], msg)
[16:01:46.776]                       ex$message <- msg
[16:01:46.776]                       stop(ex)
[16:01:46.776]                     })
[16:01:46.776]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.776]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.776]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.776]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.776]                       fi <- file.info(pathname)
[16:01:46.776]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.776]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.776]                         fi[["size"]], fi[["mtime"]])
[16:01:46.776]                       stop(msg)
[16:01:46.776]                     }
[16:01:46.776]                     invisible(pathname)
[16:01:46.776]                   }
[16:01:46.776]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.776]                     rootPath = tempdir()) 
[16:01:46.776]                   {
[16:01:46.776]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.776]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.776]                       tmpdir = path, fileext = ".rds")
[16:01:46.776]                     save_rds(obj, file)
[16:01:46.776]                   }
[16:01:46.776]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.776]                   {
[16:01:46.776]                     inherits <- base::inherits
[16:01:46.776]                     invokeRestart <- base::invokeRestart
[16:01:46.776]                     is.null <- base::is.null
[16:01:46.776]                     muffled <- FALSE
[16:01:46.776]                     if (inherits(cond, "message")) {
[16:01:46.776]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.776]                       if (muffled) 
[16:01:46.776]                         invokeRestart("muffleMessage")
[16:01:46.776]                     }
[16:01:46.776]                     else if (inherits(cond, "warning")) {
[16:01:46.776]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.776]                       if (muffled) 
[16:01:46.776]                         invokeRestart("muffleWarning")
[16:01:46.776]                     }
[16:01:46.776]                     else if (inherits(cond, "condition")) {
[16:01:46.776]                       if (!is.null(pattern)) {
[16:01:46.776]                         computeRestarts <- base::computeRestarts
[16:01:46.776]                         grepl <- base::grepl
[16:01:46.776]                         restarts <- computeRestarts(cond)
[16:01:46.776]                         for (restart in restarts) {
[16:01:46.776]                           name <- restart$name
[16:01:46.776]                           if (is.null(name)) 
[16:01:46.776]                             next
[16:01:46.776]                           if (!grepl(pattern, name)) 
[16:01:46.776]                             next
[16:01:46.776]                           invokeRestart(restart)
[16:01:46.776]                           muffled <- TRUE
[16:01:46.776]                           break
[16:01:46.776]                         }
[16:01:46.776]                       }
[16:01:46.776]                     }
[16:01:46.776]                     invisible(muffled)
[16:01:46.776]                   }
[16:01:46.776]                   muffleCondition(cond)
[16:01:46.776]                 })
[16:01:46.776]             }))
[16:01:46.776]             future::FutureResult(value = ...future.value$value, 
[16:01:46.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.776]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.776]                     ...future.globalenv.names))
[16:01:46.776]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.776]         }, condition = base::local({
[16:01:46.776]             c <- base::c
[16:01:46.776]             inherits <- base::inherits
[16:01:46.776]             invokeRestart <- base::invokeRestart
[16:01:46.776]             length <- base::length
[16:01:46.776]             list <- base::list
[16:01:46.776]             seq.int <- base::seq.int
[16:01:46.776]             signalCondition <- base::signalCondition
[16:01:46.776]             sys.calls <- base::sys.calls
[16:01:46.776]             `[[` <- base::`[[`
[16:01:46.776]             `+` <- base::`+`
[16:01:46.776]             `<<-` <- base::`<<-`
[16:01:46.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.776]                   3L)]
[16:01:46.776]             }
[16:01:46.776]             function(cond) {
[16:01:46.776]                 is_error <- inherits(cond, "error")
[16:01:46.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.776]                   NULL)
[16:01:46.776]                 if (is_error) {
[16:01:46.776]                   sessionInformation <- function() {
[16:01:46.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.776]                       search = base::search(), system = base::Sys.info())
[16:01:46.776]                   }
[16:01:46.776]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.776]                     cond$call), session = sessionInformation(), 
[16:01:46.776]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.776]                   signalCondition(cond)
[16:01:46.776]                 }
[16:01:46.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.776]                 "immediateCondition"))) {
[16:01:46.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.776]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.776]                   if (TRUE && !signal) {
[16:01:46.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.776]                     {
[16:01:46.776]                       inherits <- base::inherits
[16:01:46.776]                       invokeRestart <- base::invokeRestart
[16:01:46.776]                       is.null <- base::is.null
[16:01:46.776]                       muffled <- FALSE
[16:01:46.776]                       if (inherits(cond, "message")) {
[16:01:46.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.776]                         if (muffled) 
[16:01:46.776]                           invokeRestart("muffleMessage")
[16:01:46.776]                       }
[16:01:46.776]                       else if (inherits(cond, "warning")) {
[16:01:46.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.776]                         if (muffled) 
[16:01:46.776]                           invokeRestart("muffleWarning")
[16:01:46.776]                       }
[16:01:46.776]                       else if (inherits(cond, "condition")) {
[16:01:46.776]                         if (!is.null(pattern)) {
[16:01:46.776]                           computeRestarts <- base::computeRestarts
[16:01:46.776]                           grepl <- base::grepl
[16:01:46.776]                           restarts <- computeRestarts(cond)
[16:01:46.776]                           for (restart in restarts) {
[16:01:46.776]                             name <- restart$name
[16:01:46.776]                             if (is.null(name)) 
[16:01:46.776]                               next
[16:01:46.776]                             if (!grepl(pattern, name)) 
[16:01:46.776]                               next
[16:01:46.776]                             invokeRestart(restart)
[16:01:46.776]                             muffled <- TRUE
[16:01:46.776]                             break
[16:01:46.776]                           }
[16:01:46.776]                         }
[16:01:46.776]                       }
[16:01:46.776]                       invisible(muffled)
[16:01:46.776]                     }
[16:01:46.776]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.776]                   }
[16:01:46.776]                 }
[16:01:46.776]                 else {
[16:01:46.776]                   if (TRUE) {
[16:01:46.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.776]                     {
[16:01:46.776]                       inherits <- base::inherits
[16:01:46.776]                       invokeRestart <- base::invokeRestart
[16:01:46.776]                       is.null <- base::is.null
[16:01:46.776]                       muffled <- FALSE
[16:01:46.776]                       if (inherits(cond, "message")) {
[16:01:46.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.776]                         if (muffled) 
[16:01:46.776]                           invokeRestart("muffleMessage")
[16:01:46.776]                       }
[16:01:46.776]                       else if (inherits(cond, "warning")) {
[16:01:46.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.776]                         if (muffled) 
[16:01:46.776]                           invokeRestart("muffleWarning")
[16:01:46.776]                       }
[16:01:46.776]                       else if (inherits(cond, "condition")) {
[16:01:46.776]                         if (!is.null(pattern)) {
[16:01:46.776]                           computeRestarts <- base::computeRestarts
[16:01:46.776]                           grepl <- base::grepl
[16:01:46.776]                           restarts <- computeRestarts(cond)
[16:01:46.776]                           for (restart in restarts) {
[16:01:46.776]                             name <- restart$name
[16:01:46.776]                             if (is.null(name)) 
[16:01:46.776]                               next
[16:01:46.776]                             if (!grepl(pattern, name)) 
[16:01:46.776]                               next
[16:01:46.776]                             invokeRestart(restart)
[16:01:46.776]                             muffled <- TRUE
[16:01:46.776]                             break
[16:01:46.776]                           }
[16:01:46.776]                         }
[16:01:46.776]                       }
[16:01:46.776]                       invisible(muffled)
[16:01:46.776]                     }
[16:01:46.776]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.776]                   }
[16:01:46.776]                 }
[16:01:46.776]             }
[16:01:46.776]         }))
[16:01:46.776]     }, error = function(ex) {
[16:01:46.776]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.776]                 ...future.rng), started = ...future.startTime, 
[16:01:46.776]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.776]             version = "1.8"), class = "FutureResult")
[16:01:46.776]     }, finally = {
[16:01:46.776]         if (!identical(...future.workdir, getwd())) 
[16:01:46.776]             setwd(...future.workdir)
[16:01:46.776]         {
[16:01:46.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.776]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.776]             }
[16:01:46.776]             base::options(...future.oldOptions)
[16:01:46.776]             if (.Platform$OS.type == "windows") {
[16:01:46.776]                 old_names <- names(...future.oldEnvVars)
[16:01:46.776]                 envs <- base::Sys.getenv()
[16:01:46.776]                 names <- names(envs)
[16:01:46.776]                 common <- intersect(names, old_names)
[16:01:46.776]                 added <- setdiff(names, old_names)
[16:01:46.776]                 removed <- setdiff(old_names, names)
[16:01:46.776]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.776]                   envs[common]]
[16:01:46.776]                 NAMES <- toupper(changed)
[16:01:46.776]                 args <- list()
[16:01:46.776]                 for (kk in seq_along(NAMES)) {
[16:01:46.776]                   name <- changed[[kk]]
[16:01:46.776]                   NAME <- NAMES[[kk]]
[16:01:46.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.776]                     next
[16:01:46.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.776]                 }
[16:01:46.776]                 NAMES <- toupper(added)
[16:01:46.776]                 for (kk in seq_along(NAMES)) {
[16:01:46.776]                   name <- added[[kk]]
[16:01:46.776]                   NAME <- NAMES[[kk]]
[16:01:46.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.776]                     next
[16:01:46.776]                   args[[name]] <- ""
[16:01:46.776]                 }
[16:01:46.776]                 NAMES <- toupper(removed)
[16:01:46.776]                 for (kk in seq_along(NAMES)) {
[16:01:46.776]                   name <- removed[[kk]]
[16:01:46.776]                   NAME <- NAMES[[kk]]
[16:01:46.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.776]                     next
[16:01:46.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.776]                 }
[16:01:46.776]                 if (length(args) > 0) 
[16:01:46.776]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.776]             }
[16:01:46.776]             else {
[16:01:46.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.776]             }
[16:01:46.776]             {
[16:01:46.776]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.776]                   0L) {
[16:01:46.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.776]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.776]                   base::options(opts)
[16:01:46.776]                 }
[16:01:46.776]                 {
[16:01:46.776]                   {
[16:01:46.776]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.776]                     NULL
[16:01:46.776]                   }
[16:01:46.776]                   options(future.plan = NULL)
[16:01:46.776]                   if (is.na(NA_character_)) 
[16:01:46.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.776]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.776]                     envir = parent.frame()) 
[16:01:46.776]                   {
[16:01:46.776]                     default_workers <- missing(workers)
[16:01:46.776]                     if (is.function(workers)) 
[16:01:46.776]                       workers <- workers()
[16:01:46.776]                     workers <- structure(as.integer(workers), 
[16:01:46.776]                       class = class(workers))
[16:01:46.776]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.776]                       1L)
[16:01:46.776]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.776]                       if (default_workers) 
[16:01:46.776]                         supportsMulticore(warn = TRUE)
[16:01:46.776]                       return(sequential(..., envir = envir))
[16:01:46.776]                     }
[16:01:46.776]                     oopts <- options(mc.cores = workers)
[16:01:46.776]                     on.exit(options(oopts))
[16:01:46.776]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.776]                       envir = envir)
[16:01:46.776]                     if (!future$lazy) 
[16:01:46.776]                       future <- run(future)
[16:01:46.776]                     invisible(future)
[16:01:46.776]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.776]                 }
[16:01:46.776]             }
[16:01:46.776]         }
[16:01:46.776]     })
[16:01:46.776]     if (TRUE) {
[16:01:46.776]         base::sink(type = "output", split = FALSE)
[16:01:46.776]         if (TRUE) {
[16:01:46.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.776]         }
[16:01:46.776]         else {
[16:01:46.776]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.776]         }
[16:01:46.776]         base::close(...future.stdout)
[16:01:46.776]         ...future.stdout <- NULL
[16:01:46.776]     }
[16:01:46.776]     ...future.result$conditions <- ...future.conditions
[16:01:46.776]     ...future.result$finished <- base::Sys.time()
[16:01:46.776]     ...future.result
[16:01:46.776] }
[16:01:46.779] assign_globals() ...
[16:01:46.779] List of 5
[16:01:46.779]  $ ...future.FUN            :function (object, ...)  
[16:01:46.779]  $ future.call.arguments    : list()
[16:01:46.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.779]  $ ...future.elements_ii    :List of 1
[16:01:46.779]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.779]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:01:46.779]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.779]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:46.779]  $ ...future.seeds_ii       : NULL
[16:01:46.779]  $ ...future.globals.maxSize: NULL
[16:01:46.779]  - attr(*, "where")=List of 5
[16:01:46.779]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.779]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.779]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.779]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.779]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.779]  - attr(*, "resolved")= logi FALSE
[16:01:46.779]  - attr(*, "total_size")= num 1240
[16:01:46.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.779]  - attr(*, "already-done")= logi TRUE
[16:01:46.786] - copied ‘...future.FUN’ to environment
[16:01:46.786] - copied ‘future.call.arguments’ to environment
[16:01:46.786] - copied ‘...future.elements_ii’ to environment
[16:01:46.786] - copied ‘...future.seeds_ii’ to environment
[16:01:46.787] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.787] assign_globals() ... done
[16:01:46.787] requestCore(): workers = 2
[16:01:46.789] MulticoreFuture started
[16:01:46.790] - Launch lazy future ... done
[16:01:46.790] run() for ‘MulticoreFuture’ ... done
[16:01:46.790] Created future:
[16:01:46.790] plan(): Setting new future strategy stack:
[16:01:46.791] List of future strategies:
[16:01:46.791] 1. sequential:
[16:01:46.791]    - args: function (..., envir = parent.frame())
[16:01:46.791]    - tweaked: FALSE
[16:01:46.791]    - call: NULL
[16:01:46.791] plan(): nbrOfWorkers() = 1
[16:01:46.795] plan(): Setting new future strategy stack:
[16:01:46.795] List of future strategies:
[16:01:46.795] 1. multicore:
[16:01:46.795]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.795]    - tweaked: FALSE
[16:01:46.795]    - call: plan(strategy)
[16:01:46.800] plan(): nbrOfWorkers() = 2
[16:01:46.790] MulticoreFuture:
[16:01:46.790] Label: ‘future_by-1’
[16:01:46.790] Expression:
[16:01:46.790] {
[16:01:46.790]     do.call(function(...) {
[16:01:46.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.790]             on.exit(options(oopts), add = TRUE)
[16:01:46.790]         }
[16:01:46.790]         {
[16:01:46.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.790]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.790]             })
[16:01:46.790]         }
[16:01:46.790]     }, args = future.call.arguments)
[16:01:46.790] }
[16:01:46.790] Lazy evaluation: FALSE
[16:01:46.790] Asynchronous evaluation: TRUE
[16:01:46.790] Local evaluation: TRUE
[16:01:46.790] Environment: 0x55b527175a50
[16:01:46.790] Capture standard output: TRUE
[16:01:46.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.790] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.790] Packages: <none>
[16:01:46.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.790] Resolved: TRUE
[16:01:46.790] Value: <not collected>
[16:01:46.790] Conditions captured: <none>
[16:01:46.790] Early signaling: FALSE
[16:01:46.790] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.790] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.801] Chunk #1 of 2 ... DONE
[16:01:46.801] Chunk #2 of 2 ...
[16:01:46.801]  - Finding globals in 'X' for chunk #2 ...
[16:01:46.801] getGlobalsAndPackages() ...
[16:01:46.802] Searching for globals...
[16:01:46.802] 
[16:01:46.802] Searching for globals ... DONE
[16:01:46.802] - globals: [0] <none>
[16:01:46.803] getGlobalsAndPackages() ... DONE
[16:01:46.803]    + additional globals found: [n=0] 
[16:01:46.803]    + additional namespaces needed: [n=0] 
[16:01:46.803]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:46.803]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:46.803]  - seeds: <none>
[16:01:46.803]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.804] getGlobalsAndPackages() ...
[16:01:46.804] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.804] Resolving globals: FALSE
[16:01:46.804] Tweak future expression to call with '...' arguments ...
[16:01:46.804] {
[16:01:46.804]     do.call(function(...) {
[16:01:46.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.804]             on.exit(options(oopts), add = TRUE)
[16:01:46.804]         }
[16:01:46.804]         {
[16:01:46.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.804]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.804]             })
[16:01:46.804]         }
[16:01:46.804]     }, args = future.call.arguments)
[16:01:46.804] }
[16:01:46.805] Tweak future expression to call with '...' arguments ... DONE
[16:01:46.805] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:46.805] 
[16:01:46.805] getGlobalsAndPackages() ... DONE
[16:01:46.806] run() for ‘Future’ ...
[16:01:46.806] - state: ‘created’
[16:01:46.806] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:46.810] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.816] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:46.816]   - Field: ‘label’
[16:01:46.816]   - Field: ‘local’
[16:01:46.816]   - Field: ‘owner’
[16:01:46.817]   - Field: ‘envir’
[16:01:46.817]   - Field: ‘workers’
[16:01:46.817]   - Field: ‘packages’
[16:01:46.817]   - Field: ‘gc’
[16:01:46.817]   - Field: ‘job’
[16:01:46.817]   - Field: ‘conditions’
[16:01:46.817]   - Field: ‘expr’
[16:01:46.818]   - Field: ‘uuid’
[16:01:46.818]   - Field: ‘seed’
[16:01:46.818]   - Field: ‘version’
[16:01:46.818]   - Field: ‘result’
[16:01:46.818]   - Field: ‘asynchronous’
[16:01:46.818]   - Field: ‘calls’
[16:01:46.818]   - Field: ‘globals’
[16:01:46.818]   - Field: ‘stdout’
[16:01:46.818]   - Field: ‘earlySignal’
[16:01:46.819]   - Field: ‘lazy’
[16:01:46.819]   - Field: ‘state’
[16:01:46.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:46.819] - Launch lazy future ...
[16:01:46.819] Packages needed by the future expression (n = 0): <none>
[16:01:46.820] Packages needed by future strategies (n = 0): <none>
[16:01:46.820] {
[16:01:46.820]     {
[16:01:46.820]         {
[16:01:46.820]             ...future.startTime <- base::Sys.time()
[16:01:46.820]             {
[16:01:46.820]                 {
[16:01:46.820]                   {
[16:01:46.820]                     {
[16:01:46.820]                       base::local({
[16:01:46.820]                         has_future <- base::requireNamespace("future", 
[16:01:46.820]                           quietly = TRUE)
[16:01:46.820]                         if (has_future) {
[16:01:46.820]                           ns <- base::getNamespace("future")
[16:01:46.820]                           version <- ns[[".package"]][["version"]]
[16:01:46.820]                           if (is.null(version)) 
[16:01:46.820]                             version <- utils::packageVersion("future")
[16:01:46.820]                         }
[16:01:46.820]                         else {
[16:01:46.820]                           version <- NULL
[16:01:46.820]                         }
[16:01:46.820]                         if (!has_future || version < "1.8.0") {
[16:01:46.820]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:46.820]                             "", base::R.version$version.string), 
[16:01:46.820]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:46.820]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:46.820]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:46.820]                               "release", "version")], collapse = " "), 
[16:01:46.820]                             hostname = base::Sys.info()[["nodename"]])
[16:01:46.820]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:46.820]                             info)
[16:01:46.820]                           info <- base::paste(info, collapse = "; ")
[16:01:46.820]                           if (!has_future) {
[16:01:46.820]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:46.820]                               info)
[16:01:46.820]                           }
[16:01:46.820]                           else {
[16:01:46.820]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:46.820]                               info, version)
[16:01:46.820]                           }
[16:01:46.820]                           base::stop(msg)
[16:01:46.820]                         }
[16:01:46.820]                       })
[16:01:46.820]                     }
[16:01:46.820]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:46.820]                     base::options(mc.cores = 1L)
[16:01:46.820]                   }
[16:01:46.820]                   options(future.plan = NULL)
[16:01:46.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:46.820]                 }
[16:01:46.820]                 ...future.workdir <- getwd()
[16:01:46.820]             }
[16:01:46.820]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:46.820]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:46.820]         }
[16:01:46.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:46.820]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:46.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:46.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:46.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:46.820]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:46.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:46.820]             base::names(...future.oldOptions))
[16:01:46.820]     }
[16:01:46.820]     if (FALSE) {
[16:01:46.820]     }
[16:01:46.820]     else {
[16:01:46.820]         if (TRUE) {
[16:01:46.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:46.820]                 open = "w")
[16:01:46.820]         }
[16:01:46.820]         else {
[16:01:46.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:46.820]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:46.820]         }
[16:01:46.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:46.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:46.820]             base::sink(type = "output", split = FALSE)
[16:01:46.820]             base::close(...future.stdout)
[16:01:46.820]         }, add = TRUE)
[16:01:46.820]     }
[16:01:46.820]     ...future.frame <- base::sys.nframe()
[16:01:46.820]     ...future.conditions <- base::list()
[16:01:46.820]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:46.820]     if (FALSE) {
[16:01:46.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:46.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:46.820]     }
[16:01:46.820]     ...future.result <- base::tryCatch({
[16:01:46.820]         base::withCallingHandlers({
[16:01:46.820]             ...future.value <- base::withVisible(base::local({
[16:01:46.820]                 withCallingHandlers({
[16:01:46.820]                   {
[16:01:46.820]                     do.call(function(...) {
[16:01:46.820]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.820]                       if (!identical(...future.globals.maxSize.org, 
[16:01:46.820]                         ...future.globals.maxSize)) {
[16:01:46.820]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.820]                         on.exit(options(oopts), add = TRUE)
[16:01:46.820]                       }
[16:01:46.820]                       {
[16:01:46.820]                         lapply(seq_along(...future.elements_ii), 
[16:01:46.820]                           FUN = function(jj) {
[16:01:46.820]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.820]                             ...future.FUN(...future.X_jj, ...)
[16:01:46.820]                           })
[16:01:46.820]                       }
[16:01:46.820]                     }, args = future.call.arguments)
[16:01:46.820]                   }
[16:01:46.820]                 }, immediateCondition = function(cond) {
[16:01:46.820]                   save_rds <- function (object, pathname, ...) 
[16:01:46.820]                   {
[16:01:46.820]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:46.820]                     if (file_test("-f", pathname_tmp)) {
[16:01:46.820]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.820]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:46.820]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.820]                         fi_tmp[["mtime"]])
[16:01:46.820]                     }
[16:01:46.820]                     tryCatch({
[16:01:46.820]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:46.820]                     }, error = function(ex) {
[16:01:46.820]                       msg <- conditionMessage(ex)
[16:01:46.820]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.820]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:46.820]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.820]                         fi_tmp[["mtime"]], msg)
[16:01:46.820]                       ex$message <- msg
[16:01:46.820]                       stop(ex)
[16:01:46.820]                     })
[16:01:46.820]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:46.820]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:46.820]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:46.820]                       fi_tmp <- file.info(pathname_tmp)
[16:01:46.820]                       fi <- file.info(pathname)
[16:01:46.820]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:46.820]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:46.820]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:46.820]                         fi[["size"]], fi[["mtime"]])
[16:01:46.820]                       stop(msg)
[16:01:46.820]                     }
[16:01:46.820]                     invisible(pathname)
[16:01:46.820]                   }
[16:01:46.820]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:46.820]                     rootPath = tempdir()) 
[16:01:46.820]                   {
[16:01:46.820]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:46.820]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:46.820]                       tmpdir = path, fileext = ".rds")
[16:01:46.820]                     save_rds(obj, file)
[16:01:46.820]                   }
[16:01:46.820]                   saveImmediateCondition(cond, path = "/tmp/RtmpbSQElW/.future/immediateConditions")
[16:01:46.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.820]                   {
[16:01:46.820]                     inherits <- base::inherits
[16:01:46.820]                     invokeRestart <- base::invokeRestart
[16:01:46.820]                     is.null <- base::is.null
[16:01:46.820]                     muffled <- FALSE
[16:01:46.820]                     if (inherits(cond, "message")) {
[16:01:46.820]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:46.820]                       if (muffled) 
[16:01:46.820]                         invokeRestart("muffleMessage")
[16:01:46.820]                     }
[16:01:46.820]                     else if (inherits(cond, "warning")) {
[16:01:46.820]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:46.820]                       if (muffled) 
[16:01:46.820]                         invokeRestart("muffleWarning")
[16:01:46.820]                     }
[16:01:46.820]                     else if (inherits(cond, "condition")) {
[16:01:46.820]                       if (!is.null(pattern)) {
[16:01:46.820]                         computeRestarts <- base::computeRestarts
[16:01:46.820]                         grepl <- base::grepl
[16:01:46.820]                         restarts <- computeRestarts(cond)
[16:01:46.820]                         for (restart in restarts) {
[16:01:46.820]                           name <- restart$name
[16:01:46.820]                           if (is.null(name)) 
[16:01:46.820]                             next
[16:01:46.820]                           if (!grepl(pattern, name)) 
[16:01:46.820]                             next
[16:01:46.820]                           invokeRestart(restart)
[16:01:46.820]                           muffled <- TRUE
[16:01:46.820]                           break
[16:01:46.820]                         }
[16:01:46.820]                       }
[16:01:46.820]                     }
[16:01:46.820]                     invisible(muffled)
[16:01:46.820]                   }
[16:01:46.820]                   muffleCondition(cond)
[16:01:46.820]                 })
[16:01:46.820]             }))
[16:01:46.820]             future::FutureResult(value = ...future.value$value, 
[16:01:46.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.820]                   ...future.rng), globalenv = if (FALSE) 
[16:01:46.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:46.820]                     ...future.globalenv.names))
[16:01:46.820]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:46.820]         }, condition = base::local({
[16:01:46.820]             c <- base::c
[16:01:46.820]             inherits <- base::inherits
[16:01:46.820]             invokeRestart <- base::invokeRestart
[16:01:46.820]             length <- base::length
[16:01:46.820]             list <- base::list
[16:01:46.820]             seq.int <- base::seq.int
[16:01:46.820]             signalCondition <- base::signalCondition
[16:01:46.820]             sys.calls <- base::sys.calls
[16:01:46.820]             `[[` <- base::`[[`
[16:01:46.820]             `+` <- base::`+`
[16:01:46.820]             `<<-` <- base::`<<-`
[16:01:46.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:46.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:46.820]                   3L)]
[16:01:46.820]             }
[16:01:46.820]             function(cond) {
[16:01:46.820]                 is_error <- inherits(cond, "error")
[16:01:46.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:46.820]                   NULL)
[16:01:46.820]                 if (is_error) {
[16:01:46.820]                   sessionInformation <- function() {
[16:01:46.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:46.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:46.820]                       search = base::search(), system = base::Sys.info())
[16:01:46.820]                   }
[16:01:46.820]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:46.820]                     cond$call), session = sessionInformation(), 
[16:01:46.820]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:46.820]                   signalCondition(cond)
[16:01:46.820]                 }
[16:01:46.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:46.820]                 "immediateCondition"))) {
[16:01:46.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:46.820]                   ...future.conditions[[length(...future.conditions) + 
[16:01:46.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:46.820]                   if (TRUE && !signal) {
[16:01:46.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.820]                     {
[16:01:46.820]                       inherits <- base::inherits
[16:01:46.820]                       invokeRestart <- base::invokeRestart
[16:01:46.820]                       is.null <- base::is.null
[16:01:46.820]                       muffled <- FALSE
[16:01:46.820]                       if (inherits(cond, "message")) {
[16:01:46.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.820]                         if (muffled) 
[16:01:46.820]                           invokeRestart("muffleMessage")
[16:01:46.820]                       }
[16:01:46.820]                       else if (inherits(cond, "warning")) {
[16:01:46.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.820]                         if (muffled) 
[16:01:46.820]                           invokeRestart("muffleWarning")
[16:01:46.820]                       }
[16:01:46.820]                       else if (inherits(cond, "condition")) {
[16:01:46.820]                         if (!is.null(pattern)) {
[16:01:46.820]                           computeRestarts <- base::computeRestarts
[16:01:46.820]                           grepl <- base::grepl
[16:01:46.820]                           restarts <- computeRestarts(cond)
[16:01:46.820]                           for (restart in restarts) {
[16:01:46.820]                             name <- restart$name
[16:01:46.820]                             if (is.null(name)) 
[16:01:46.820]                               next
[16:01:46.820]                             if (!grepl(pattern, name)) 
[16:01:46.820]                               next
[16:01:46.820]                             invokeRestart(restart)
[16:01:46.820]                             muffled <- TRUE
[16:01:46.820]                             break
[16:01:46.820]                           }
[16:01:46.820]                         }
[16:01:46.820]                       }
[16:01:46.820]                       invisible(muffled)
[16:01:46.820]                     }
[16:01:46.820]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.820]                   }
[16:01:46.820]                 }
[16:01:46.820]                 else {
[16:01:46.820]                   if (TRUE) {
[16:01:46.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:46.820]                     {
[16:01:46.820]                       inherits <- base::inherits
[16:01:46.820]                       invokeRestart <- base::invokeRestart
[16:01:46.820]                       is.null <- base::is.null
[16:01:46.820]                       muffled <- FALSE
[16:01:46.820]                       if (inherits(cond, "message")) {
[16:01:46.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:46.820]                         if (muffled) 
[16:01:46.820]                           invokeRestart("muffleMessage")
[16:01:46.820]                       }
[16:01:46.820]                       else if (inherits(cond, "warning")) {
[16:01:46.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:46.820]                         if (muffled) 
[16:01:46.820]                           invokeRestart("muffleWarning")
[16:01:46.820]                       }
[16:01:46.820]                       else if (inherits(cond, "condition")) {
[16:01:46.820]                         if (!is.null(pattern)) {
[16:01:46.820]                           computeRestarts <- base::computeRestarts
[16:01:46.820]                           grepl <- base::grepl
[16:01:46.820]                           restarts <- computeRestarts(cond)
[16:01:46.820]                           for (restart in restarts) {
[16:01:46.820]                             name <- restart$name
[16:01:46.820]                             if (is.null(name)) 
[16:01:46.820]                               next
[16:01:46.820]                             if (!grepl(pattern, name)) 
[16:01:46.820]                               next
[16:01:46.820]                             invokeRestart(restart)
[16:01:46.820]                             muffled <- TRUE
[16:01:46.820]                             break
[16:01:46.820]                           }
[16:01:46.820]                         }
[16:01:46.820]                       }
[16:01:46.820]                       invisible(muffled)
[16:01:46.820]                     }
[16:01:46.820]                     muffleCondition(cond, pattern = "^muffle")
[16:01:46.820]                   }
[16:01:46.820]                 }
[16:01:46.820]             }
[16:01:46.820]         }))
[16:01:46.820]     }, error = function(ex) {
[16:01:46.820]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:46.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:46.820]                 ...future.rng), started = ...future.startTime, 
[16:01:46.820]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:46.820]             version = "1.8"), class = "FutureResult")
[16:01:46.820]     }, finally = {
[16:01:46.820]         if (!identical(...future.workdir, getwd())) 
[16:01:46.820]             setwd(...future.workdir)
[16:01:46.820]         {
[16:01:46.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:46.820]                 ...future.oldOptions$nwarnings <- NULL
[16:01:46.820]             }
[16:01:46.820]             base::options(...future.oldOptions)
[16:01:46.820]             if (.Platform$OS.type == "windows") {
[16:01:46.820]                 old_names <- names(...future.oldEnvVars)
[16:01:46.820]                 envs <- base::Sys.getenv()
[16:01:46.820]                 names <- names(envs)
[16:01:46.820]                 common <- intersect(names, old_names)
[16:01:46.820]                 added <- setdiff(names, old_names)
[16:01:46.820]                 removed <- setdiff(old_names, names)
[16:01:46.820]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:46.820]                   envs[common]]
[16:01:46.820]                 NAMES <- toupper(changed)
[16:01:46.820]                 args <- list()
[16:01:46.820]                 for (kk in seq_along(NAMES)) {
[16:01:46.820]                   name <- changed[[kk]]
[16:01:46.820]                   NAME <- NAMES[[kk]]
[16:01:46.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.820]                     next
[16:01:46.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.820]                 }
[16:01:46.820]                 NAMES <- toupper(added)
[16:01:46.820]                 for (kk in seq_along(NAMES)) {
[16:01:46.820]                   name <- added[[kk]]
[16:01:46.820]                   NAME <- NAMES[[kk]]
[16:01:46.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.820]                     next
[16:01:46.820]                   args[[name]] <- ""
[16:01:46.820]                 }
[16:01:46.820]                 NAMES <- toupper(removed)
[16:01:46.820]                 for (kk in seq_along(NAMES)) {
[16:01:46.820]                   name <- removed[[kk]]
[16:01:46.820]                   NAME <- NAMES[[kk]]
[16:01:46.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:46.820]                     next
[16:01:46.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:46.820]                 }
[16:01:46.820]                 if (length(args) > 0) 
[16:01:46.820]                   base::do.call(base::Sys.setenv, args = args)
[16:01:46.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:46.820]             }
[16:01:46.820]             else {
[16:01:46.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:46.820]             }
[16:01:46.820]             {
[16:01:46.820]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:46.820]                   0L) {
[16:01:46.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:46.820]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:46.820]                   base::options(opts)
[16:01:46.820]                 }
[16:01:46.820]                 {
[16:01:46.820]                   {
[16:01:46.820]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:46.820]                     NULL
[16:01:46.820]                   }
[16:01:46.820]                   options(future.plan = NULL)
[16:01:46.820]                   if (is.na(NA_character_)) 
[16:01:46.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:46.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:46.820]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:46.820]                     envir = parent.frame()) 
[16:01:46.820]                   {
[16:01:46.820]                     default_workers <- missing(workers)
[16:01:46.820]                     if (is.function(workers)) 
[16:01:46.820]                       workers <- workers()
[16:01:46.820]                     workers <- structure(as.integer(workers), 
[16:01:46.820]                       class = class(workers))
[16:01:46.820]                     stop_if_not(is.finite(workers), workers >= 
[16:01:46.820]                       1L)
[16:01:46.820]                     if ((workers == 1L && !inherits(workers, 
[16:01:46.820]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:46.820]                       if (default_workers) 
[16:01:46.820]                         supportsMulticore(warn = TRUE)
[16:01:46.820]                       return(sequential(..., envir = envir))
[16:01:46.820]                     }
[16:01:46.820]                     oopts <- options(mc.cores = workers)
[16:01:46.820]                     on.exit(options(oopts))
[16:01:46.820]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:46.820]                       envir = envir)
[16:01:46.820]                     if (!future$lazy) 
[16:01:46.820]                       future <- run(future)
[16:01:46.820]                     invisible(future)
[16:01:46.820]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:46.820]                 }
[16:01:46.820]             }
[16:01:46.820]         }
[16:01:46.820]     })
[16:01:46.820]     if (TRUE) {
[16:01:46.820]         base::sink(type = "output", split = FALSE)
[16:01:46.820]         if (TRUE) {
[16:01:46.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:46.820]         }
[16:01:46.820]         else {
[16:01:46.820]             ...future.result["stdout"] <- base::list(NULL)
[16:01:46.820]         }
[16:01:46.820]         base::close(...future.stdout)
[16:01:46.820]         ...future.stdout <- NULL
[16:01:46.820]     }
[16:01:46.820]     ...future.result$conditions <- ...future.conditions
[16:01:46.820]     ...future.result$finished <- base::Sys.time()
[16:01:46.820]     ...future.result
[16:01:46.820] }
[16:01:46.823] assign_globals() ...
[16:01:46.823] List of 5
[16:01:46.823]  $ ...future.FUN            :function (object, ...)  
[16:01:46.823]  $ future.call.arguments    : list()
[16:01:46.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:46.823]  $ ...future.elements_ii    :List of 2
[16:01:46.823]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.823]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:01:46.823]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.823]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:01:46.823]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:01:46.823]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:01:46.823]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:01:46.823]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:01:46.823]  $ ...future.seeds_ii       : NULL
[16:01:46.823]  $ ...future.globals.maxSize: NULL
[16:01:46.823]  - attr(*, "where")=List of 5
[16:01:46.823]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:46.823]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:46.823]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:46.823]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:46.823]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:46.823]  - attr(*, "resolved")= logi FALSE
[16:01:46.823]  - attr(*, "total_size")= num 1240
[16:01:46.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:46.823]  - attr(*, "already-done")= logi TRUE
[16:01:46.833] - copied ‘...future.FUN’ to environment
[16:01:46.833] - copied ‘future.call.arguments’ to environment
[16:01:46.833] - copied ‘...future.elements_ii’ to environment
[16:01:46.834] - copied ‘...future.seeds_ii’ to environment
[16:01:46.834] - copied ‘...future.globals.maxSize’ to environment
[16:01:46.834] assign_globals() ... done
[16:01:46.834] requestCore(): workers = 2
[16:01:46.837] MulticoreFuture started
[16:01:46.837] - Launch lazy future ... done
[16:01:46.838] run() for ‘MulticoreFuture’ ... done
[16:01:46.838] Created future:
[16:01:46.838] plan(): Setting new future strategy stack:
[16:01:46.838] List of future strategies:
[16:01:46.838] 1. sequential:
[16:01:46.838]    - args: function (..., envir = parent.frame())
[16:01:46.838]    - tweaked: FALSE
[16:01:46.838]    - call: NULL
[16:01:46.839] plan(): nbrOfWorkers() = 1
[16:01:46.843] plan(): Setting new future strategy stack:
[16:01:46.844] List of future strategies:
[16:01:46.844] 1. multicore:
[16:01:46.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:46.844]    - tweaked: FALSE
[16:01:46.844]    - call: plan(strategy)
[16:01:46.849] plan(): nbrOfWorkers() = 2
[16:01:46.838] MulticoreFuture:
[16:01:46.838] Label: ‘future_by-2’
[16:01:46.838] Expression:
[16:01:46.838] {
[16:01:46.838]     do.call(function(...) {
[16:01:46.838]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:46.838]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:46.838]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:46.838]             on.exit(options(oopts), add = TRUE)
[16:01:46.838]         }
[16:01:46.838]         {
[16:01:46.838]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:46.838]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:46.838]                 ...future.FUN(...future.X_jj, ...)
[16:01:46.838]             })
[16:01:46.838]         }
[16:01:46.838]     }, args = future.call.arguments)
[16:01:46.838] }
[16:01:46.838] Lazy evaluation: FALSE
[16:01:46.838] Asynchronous evaluation: TRUE
[16:01:46.838] Local evaluation: TRUE
[16:01:46.838] Environment: 0x55b527175a50
[16:01:46.838] Capture standard output: TRUE
[16:01:46.838] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:46.838] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:46.838] Packages: <none>
[16:01:46.838] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:46.838] Resolved: TRUE
[16:01:46.838] Value: <not collected>
[16:01:46.838] Conditions captured: <none>
[16:01:46.838] Early signaling: FALSE
[16:01:46.838] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:46.838] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:46.850] Chunk #2 of 2 ... DONE
[16:01:46.850] Launching 2 futures (chunks) ... DONE
[16:01:46.850] Resolving 2 futures (chunks) ...
[16:01:46.851] resolve() on list ...
[16:01:46.851]  recursive: 0
[16:01:46.851]  length: 2
[16:01:46.851] 
[16:01:46.851] Future #1
[16:01:46.852] result() for MulticoreFuture ...
[16:01:46.853] result() for MulticoreFuture ...
[16:01:46.853] result() for MulticoreFuture ... done
[16:01:46.853] result() for MulticoreFuture ... done
[16:01:46.853] result() for MulticoreFuture ...
[16:01:46.853] result() for MulticoreFuture ... done
[16:01:46.853] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:46.853] - nx: 2
[16:01:46.853] - relay: TRUE
[16:01:46.854] - stdout: TRUE
[16:01:46.854] - signal: TRUE
[16:01:46.854] - resignal: FALSE
[16:01:46.854] - force: TRUE
[16:01:46.854] - relayed: [n=2] FALSE, FALSE
[16:01:46.854] - queued futures: [n=2] FALSE, FALSE
[16:01:46.854]  - until=1
[16:01:46.855]  - relaying element #1
[16:01:46.855] result() for MulticoreFuture ...
[16:01:46.855] result() for MulticoreFuture ... done
[16:01:46.855] result() for MulticoreFuture ...
[16:01:46.855] result() for MulticoreFuture ... done
[16:01:46.856] result() for MulticoreFuture ...
[16:01:46.856] result() for MulticoreFuture ... done
[16:01:46.856] result() for MulticoreFuture ...
[16:01:46.856] result() for MulticoreFuture ... done
[16:01:46.856] - relayed: [n=2] TRUE, FALSE
[16:01:46.856] - queued futures: [n=2] TRUE, FALSE
[16:01:46.857] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:46.857]  length: 1 (resolved future 1)
[16:01:46.857] Future #2
[16:01:46.857] result() for MulticoreFuture ...
[16:01:46.858] result() for MulticoreFuture ...
[16:01:46.858] result() for MulticoreFuture ... done
[16:01:46.859] result() for MulticoreFuture ... done
[16:01:46.859] result() for MulticoreFuture ...
[16:01:46.859] result() for MulticoreFuture ... done
[16:01:46.859] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:46.859] - nx: 2
[16:01:46.859] - relay: TRUE
[16:01:46.860] - stdout: TRUE
[16:01:46.860] - signal: TRUE
[16:01:46.860] - resignal: FALSE
[16:01:46.860] - force: TRUE
[16:01:46.860] - relayed: [n=2] TRUE, FALSE
[16:01:46.860] - queued futures: [n=2] TRUE, FALSE
[16:01:46.860]  - until=2
[16:01:46.860]  - relaying element #2
[16:01:46.861] result() for MulticoreFuture ...
[16:01:46.861] result() for MulticoreFuture ... done
[16:01:46.861] result() for MulticoreFuture ...
[16:01:46.861] result() for MulticoreFuture ... done
[16:01:46.861] result() for MulticoreFuture ...
[16:01:46.861] result() for MulticoreFuture ... done
[16:01:46.862] result() for MulticoreFuture ...
[16:01:46.862] result() for MulticoreFuture ... done
[16:01:46.862] - relayed: [n=2] TRUE, TRUE
[16:01:46.862] - queued futures: [n=2] TRUE, TRUE
[16:01:46.862] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:46.862]  length: 0 (resolved future 2)
[16:01:46.862] Relaying remaining futures
[16:01:46.862] signalConditionsASAP(NULL, pos=0) ...
[16:01:46.863] - nx: 2
[16:01:46.863] - relay: TRUE
[16:01:46.863] - stdout: TRUE
[16:01:46.863] - signal: TRUE
[16:01:46.863] - resignal: FALSE
[16:01:46.863] - force: TRUE
[16:01:46.863] - relayed: [n=2] TRUE, TRUE
[16:01:46.863] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:46.864] - relayed: [n=2] TRUE, TRUE
[16:01:46.864] - queued futures: [n=2] TRUE, TRUE
[16:01:46.864] signalConditionsASAP(NULL, pos=0) ... done
[16:01:46.864] resolve() on list ... DONE
[16:01:46.864] result() for MulticoreFuture ...
[16:01:46.864] result() for MulticoreFuture ... done
[16:01:46.864] result() for MulticoreFuture ...
[16:01:46.864] result() for MulticoreFuture ... done
[16:01:46.865] result() for MulticoreFuture ...
[16:01:46.865] result() for MulticoreFuture ... done
[16:01:46.865] result() for MulticoreFuture ...
[16:01:46.865] result() for MulticoreFuture ... done
[16:01:46.865]  - Number of value chunks collected: 2
[16:01:46.865] Resolving 2 futures (chunks) ... DONE
[16:01:46.865] Reducing values from 2 chunks ...
[16:01:46.865]  - Number of values collected after concatenation: 3
[16:01:46.866]  - Number of values expected: 3
[16:01:46.866] Reducing values from 2 chunks ... DONE
[16:01:46.866] future_lapply() ... DONE
[16:01:46.866] future_by_internal() ... DONE
[16:01:46.867] future_by_internal() ...
- plan('multisession') ...
[16:01:46.868] plan(): Setting new future strategy stack:
[16:01:46.868] List of future strategies:
[16:01:46.868] 1. multisession:
[16:01:46.868]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:46.868]    - tweaked: FALSE
[16:01:46.868]    - call: plan(strategy)
[16:01:46.868] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:01:46.868] multisession:
[16:01:46.868] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:46.868] - tweaked: FALSE
[16:01:46.868] - call: plan(strategy)
[16:01:46.875] getGlobalsAndPackages() ...
[16:01:46.875] Not searching for globals
[16:01:46.875] - globals: [0] <none>
[16:01:46.875] getGlobalsAndPackages() ... DONE
[16:01:46.876] [local output] makeClusterPSOCK() ...
[16:01:46.925] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:01:46.927] [local output] Base port: 11332
[16:01:46.927] [local output] Getting setup options for 2 cluster nodes ...
[16:01:46.927] [local output]  - Node 1 of 2 ...
[16:01:46.927] [local output] localMachine=TRUE => revtunnel=FALSE

[16:01:46.928] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpbSQElW/worker.rank=1.parallelly.parent=68602.10bfa38fc1295.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpbSQElW/worker.rank=1.parallelly.parent=68602.10bfa38fc1295.pid")'’
[16:01:47.118] - Possible to infer worker's PID: TRUE
[16:01:47.118] [local output] Rscript port: 11332

[16:01:47.118] [local output]  - Node 2 of 2 ...
[16:01:47.119] [local output] localMachine=TRUE => revtunnel=FALSE

[16:01:47.120] [local output] Rscript port: 11332

[16:01:47.120] [local output] Getting setup options for 2 cluster nodes ... done
[16:01:47.120] [local output]  - Parallel setup requested for some PSOCK nodes
[16:01:47.121] [local output] Setting up PSOCK nodes in parallel
[16:01:47.121] List of 36
[16:01:47.121]  $ worker          : chr "localhost"
[16:01:47.121]   ..- attr(*, "localhost")= logi TRUE
[16:01:47.121]  $ master          : chr "localhost"
[16:01:47.121]  $ port            : int 11332
[16:01:47.121]  $ connectTimeout  : num 120
[16:01:47.121]  $ timeout         : num 2592000
[16:01:47.121]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:01:47.121]  $ homogeneous     : logi TRUE
[16:01:47.121]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:01:47.121]  $ rscript_envs    : NULL
[16:01:47.121]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:01:47.121]  $ rscript_startup : NULL
[16:01:47.121]  $ rscript_sh      : chr "sh"
[16:01:47.121]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:01:47.121]  $ methods         : logi TRUE
[16:01:47.121]  $ socketOptions   : chr "no-delay"
[16:01:47.121]  $ useXDR          : logi FALSE
[16:01:47.121]  $ outfile         : chr "/dev/null"
[16:01:47.121]  $ renice          : int NA
[16:01:47.121]  $ rshcmd          : NULL
[16:01:47.121]  $ user            : chr(0) 
[16:01:47.121]  $ revtunnel       : logi FALSE
[16:01:47.121]  $ rshlogfile      : NULL
[16:01:47.121]  $ rshopts         : chr(0) 
[16:01:47.121]  $ rank            : int 1
[16:01:47.121]  $ manual          : logi FALSE
[16:01:47.121]  $ dryrun          : logi FALSE
[16:01:47.121]  $ quiet           : logi FALSE
[16:01:47.121]  $ setup_strategy  : chr "parallel"
[16:01:47.121]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:01:47.121]  $ pidfile         : chr "/tmp/RtmpbSQElW/worker.rank=1.parallelly.parent=68602.10bfa38fc1295.pid"
[16:01:47.121]  $ rshcmd_label    : NULL
[16:01:47.121]  $ rsh_call        : NULL
[16:01:47.121]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:01:47.121]  $ localMachine    : logi TRUE
[16:01:47.121]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:01:47.121]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:01:47.121]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:01:47.121]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:01:47.121]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:01:47.121]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:01:47.121]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:01:47.121]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:01:47.121]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:01:47.121]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:01:47.121]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:01:47.121]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:01:47.121]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:01:47.121]  $ arguments       :List of 28
[16:01:47.121]   ..$ worker          : chr "localhost"
[16:01:47.121]   ..$ master          : NULL
[16:01:47.121]   ..$ port            : int 11332
[16:01:47.121]   ..$ connectTimeout  : num 120
[16:01:47.121]   ..$ timeout         : num 2592000
[16:01:47.121]   ..$ rscript         : NULL
[16:01:47.121]   ..$ homogeneous     : NULL
[16:01:47.121]   ..$ rscript_args    : NULL
[16:01:47.121]   ..$ rscript_envs    : NULL
[16:01:47.121]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:01:47.121]   ..$ rscript_startup : NULL
[16:01:47.121]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:01:47.121]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:01:47.121]   ..$ methods         : logi TRUE
[16:01:47.121]   ..$ socketOptions   : chr "no-delay"
[16:01:47.121]   ..$ useXDR          : logi FALSE
[16:01:47.121]   ..$ outfile         : chr "/dev/null"
[16:01:47.121]   ..$ renice          : int NA
[16:01:47.121]   ..$ rshcmd          : NULL
[16:01:47.121]   ..$ user            : NULL
[16:01:47.121]   ..$ revtunnel       : logi NA
[16:01:47.121]   ..$ rshlogfile      : NULL
[16:01:47.121]   ..$ rshopts         : NULL
[16:01:47.121]   ..$ rank            : int 1
[16:01:47.121]   ..$ manual          : logi FALSE
[16:01:47.121]   ..$ dryrun          : logi FALSE
[16:01:47.121]   ..$ quiet           : logi FALSE
[16:01:47.121]   ..$ setup_strategy  : chr "parallel"
[16:01:47.121]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:01:47.137] [local output] System call to launch all workers:
[16:01:47.137] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpbSQElW/worker.rank=1.parallelly.parent=68602.10bfa38fc1295.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11332 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:01:47.137] [local output] Starting PSOCK main server
[16:01:47.143] [local output] Workers launched
[16:01:47.143] [local output] Waiting for workers to connect back
[16:01:47.143]  - [local output] 0 workers out of 2 ready
[16:01:47.392]  - [local output] 0 workers out of 2 ready
[16:01:47.392]  - [local output] 1 workers out of 2 ready
[16:01:47.393]  - [local output] 2 workers out of 2 ready
[16:01:47.393] [local output] Launching of workers completed
[16:01:47.393] [local output] Collecting session information from workers
[16:01:47.394] [local output]  - Worker #1 of 2
[16:01:47.394] [local output]  - Worker #2 of 2
[16:01:47.394] [local output] makeClusterPSOCK() ... done
[16:01:47.405] Packages needed by the future expression (n = 0): <none>
[16:01:47.405] Packages needed by future strategies (n = 0): <none>
[16:01:47.406] {
[16:01:47.406]     {
[16:01:47.406]         {
[16:01:47.406]             ...future.startTime <- base::Sys.time()
[16:01:47.406]             {
[16:01:47.406]                 {
[16:01:47.406]                   {
[16:01:47.406]                     {
[16:01:47.406]                       base::local({
[16:01:47.406]                         has_future <- base::requireNamespace("future", 
[16:01:47.406]                           quietly = TRUE)
[16:01:47.406]                         if (has_future) {
[16:01:47.406]                           ns <- base::getNamespace("future")
[16:01:47.406]                           version <- ns[[".package"]][["version"]]
[16:01:47.406]                           if (is.null(version)) 
[16:01:47.406]                             version <- utils::packageVersion("future")
[16:01:47.406]                         }
[16:01:47.406]                         else {
[16:01:47.406]                           version <- NULL
[16:01:47.406]                         }
[16:01:47.406]                         if (!has_future || version < "1.8.0") {
[16:01:47.406]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.406]                             "", base::R.version$version.string), 
[16:01:47.406]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:47.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:47.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.406]                               "release", "version")], collapse = " "), 
[16:01:47.406]                             hostname = base::Sys.info()[["nodename"]])
[16:01:47.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.406]                             info)
[16:01:47.406]                           info <- base::paste(info, collapse = "; ")
[16:01:47.406]                           if (!has_future) {
[16:01:47.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.406]                               info)
[16:01:47.406]                           }
[16:01:47.406]                           else {
[16:01:47.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.406]                               info, version)
[16:01:47.406]                           }
[16:01:47.406]                           base::stop(msg)
[16:01:47.406]                         }
[16:01:47.406]                       })
[16:01:47.406]                     }
[16:01:47.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.406]                     base::options(mc.cores = 1L)
[16:01:47.406]                   }
[16:01:47.406]                   options(future.plan = NULL)
[16:01:47.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.406]                 }
[16:01:47.406]                 ...future.workdir <- getwd()
[16:01:47.406]             }
[16:01:47.406]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.406]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.406]         }
[16:01:47.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:47.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.406]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.406]             base::names(...future.oldOptions))
[16:01:47.406]     }
[16:01:47.406]     if (FALSE) {
[16:01:47.406]     }
[16:01:47.406]     else {
[16:01:47.406]         if (TRUE) {
[16:01:47.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.406]                 open = "w")
[16:01:47.406]         }
[16:01:47.406]         else {
[16:01:47.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.406]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.406]         }
[16:01:47.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.406]             base::sink(type = "output", split = FALSE)
[16:01:47.406]             base::close(...future.stdout)
[16:01:47.406]         }, add = TRUE)
[16:01:47.406]     }
[16:01:47.406]     ...future.frame <- base::sys.nframe()
[16:01:47.406]     ...future.conditions <- base::list()
[16:01:47.406]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.406]     if (FALSE) {
[16:01:47.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.406]     }
[16:01:47.406]     ...future.result <- base::tryCatch({
[16:01:47.406]         base::withCallingHandlers({
[16:01:47.406]             ...future.value <- base::withVisible(base::local({
[16:01:47.406]                 ...future.makeSendCondition <- base::local({
[16:01:47.406]                   sendCondition <- NULL
[16:01:47.406]                   function(frame = 1L) {
[16:01:47.406]                     if (is.function(sendCondition)) 
[16:01:47.406]                       return(sendCondition)
[16:01:47.406]                     ns <- getNamespace("parallel")
[16:01:47.406]                     if (exists("sendData", mode = "function", 
[16:01:47.406]                       envir = ns)) {
[16:01:47.406]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.406]                         envir = ns)
[16:01:47.406]                       envir <- sys.frame(frame)
[16:01:47.406]                       master <- NULL
[16:01:47.406]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.406]                         !identical(envir, emptyenv())) {
[16:01:47.406]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.406]                           inherits = FALSE)) {
[16:01:47.406]                           master <- get("master", mode = "list", 
[16:01:47.406]                             envir = envir, inherits = FALSE)
[16:01:47.406]                           if (inherits(master, c("SOCKnode", 
[16:01:47.406]                             "SOCK0node"))) {
[16:01:47.406]                             sendCondition <<- function(cond) {
[16:01:47.406]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.406]                                 success = TRUE)
[16:01:47.406]                               parallel_sendData(master, data)
[16:01:47.406]                             }
[16:01:47.406]                             return(sendCondition)
[16:01:47.406]                           }
[16:01:47.406]                         }
[16:01:47.406]                         frame <- frame + 1L
[16:01:47.406]                         envir <- sys.frame(frame)
[16:01:47.406]                       }
[16:01:47.406]                     }
[16:01:47.406]                     sendCondition <<- function(cond) NULL
[16:01:47.406]                   }
[16:01:47.406]                 })
[16:01:47.406]                 withCallingHandlers({
[16:01:47.406]                   NA
[16:01:47.406]                 }, immediateCondition = function(cond) {
[16:01:47.406]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.406]                   sendCondition(cond)
[16:01:47.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.406]                   {
[16:01:47.406]                     inherits <- base::inherits
[16:01:47.406]                     invokeRestart <- base::invokeRestart
[16:01:47.406]                     is.null <- base::is.null
[16:01:47.406]                     muffled <- FALSE
[16:01:47.406]                     if (inherits(cond, "message")) {
[16:01:47.406]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.406]                       if (muffled) 
[16:01:47.406]                         invokeRestart("muffleMessage")
[16:01:47.406]                     }
[16:01:47.406]                     else if (inherits(cond, "warning")) {
[16:01:47.406]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.406]                       if (muffled) 
[16:01:47.406]                         invokeRestart("muffleWarning")
[16:01:47.406]                     }
[16:01:47.406]                     else if (inherits(cond, "condition")) {
[16:01:47.406]                       if (!is.null(pattern)) {
[16:01:47.406]                         computeRestarts <- base::computeRestarts
[16:01:47.406]                         grepl <- base::grepl
[16:01:47.406]                         restarts <- computeRestarts(cond)
[16:01:47.406]                         for (restart in restarts) {
[16:01:47.406]                           name <- restart$name
[16:01:47.406]                           if (is.null(name)) 
[16:01:47.406]                             next
[16:01:47.406]                           if (!grepl(pattern, name)) 
[16:01:47.406]                             next
[16:01:47.406]                           invokeRestart(restart)
[16:01:47.406]                           muffled <- TRUE
[16:01:47.406]                           break
[16:01:47.406]                         }
[16:01:47.406]                       }
[16:01:47.406]                     }
[16:01:47.406]                     invisible(muffled)
[16:01:47.406]                   }
[16:01:47.406]                   muffleCondition(cond)
[16:01:47.406]                 })
[16:01:47.406]             }))
[16:01:47.406]             future::FutureResult(value = ...future.value$value, 
[16:01:47.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.406]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.406]                     ...future.globalenv.names))
[16:01:47.406]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.406]         }, condition = base::local({
[16:01:47.406]             c <- base::c
[16:01:47.406]             inherits <- base::inherits
[16:01:47.406]             invokeRestart <- base::invokeRestart
[16:01:47.406]             length <- base::length
[16:01:47.406]             list <- base::list
[16:01:47.406]             seq.int <- base::seq.int
[16:01:47.406]             signalCondition <- base::signalCondition
[16:01:47.406]             sys.calls <- base::sys.calls
[16:01:47.406]             `[[` <- base::`[[`
[16:01:47.406]             `+` <- base::`+`
[16:01:47.406]             `<<-` <- base::`<<-`
[16:01:47.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.406]                   3L)]
[16:01:47.406]             }
[16:01:47.406]             function(cond) {
[16:01:47.406]                 is_error <- inherits(cond, "error")
[16:01:47.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.406]                   NULL)
[16:01:47.406]                 if (is_error) {
[16:01:47.406]                   sessionInformation <- function() {
[16:01:47.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.406]                       search = base::search(), system = base::Sys.info())
[16:01:47.406]                   }
[16:01:47.406]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.406]                     cond$call), session = sessionInformation(), 
[16:01:47.406]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.406]                   signalCondition(cond)
[16:01:47.406]                 }
[16:01:47.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.406]                 "immediateCondition"))) {
[16:01:47.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.406]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.406]                   if (TRUE && !signal) {
[16:01:47.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.406]                     {
[16:01:47.406]                       inherits <- base::inherits
[16:01:47.406]                       invokeRestart <- base::invokeRestart
[16:01:47.406]                       is.null <- base::is.null
[16:01:47.406]                       muffled <- FALSE
[16:01:47.406]                       if (inherits(cond, "message")) {
[16:01:47.406]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.406]                         if (muffled) 
[16:01:47.406]                           invokeRestart("muffleMessage")
[16:01:47.406]                       }
[16:01:47.406]                       else if (inherits(cond, "warning")) {
[16:01:47.406]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.406]                         if (muffled) 
[16:01:47.406]                           invokeRestart("muffleWarning")
[16:01:47.406]                       }
[16:01:47.406]                       else if (inherits(cond, "condition")) {
[16:01:47.406]                         if (!is.null(pattern)) {
[16:01:47.406]                           computeRestarts <- base::computeRestarts
[16:01:47.406]                           grepl <- base::grepl
[16:01:47.406]                           restarts <- computeRestarts(cond)
[16:01:47.406]                           for (restart in restarts) {
[16:01:47.406]                             name <- restart$name
[16:01:47.406]                             if (is.null(name)) 
[16:01:47.406]                               next
[16:01:47.406]                             if (!grepl(pattern, name)) 
[16:01:47.406]                               next
[16:01:47.406]                             invokeRestart(restart)
[16:01:47.406]                             muffled <- TRUE
[16:01:47.406]                             break
[16:01:47.406]                           }
[16:01:47.406]                         }
[16:01:47.406]                       }
[16:01:47.406]                       invisible(muffled)
[16:01:47.406]                     }
[16:01:47.406]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.406]                   }
[16:01:47.406]                 }
[16:01:47.406]                 else {
[16:01:47.406]                   if (TRUE) {
[16:01:47.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.406]                     {
[16:01:47.406]                       inherits <- base::inherits
[16:01:47.406]                       invokeRestart <- base::invokeRestart
[16:01:47.406]                       is.null <- base::is.null
[16:01:47.406]                       muffled <- FALSE
[16:01:47.406]                       if (inherits(cond, "message")) {
[16:01:47.406]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.406]                         if (muffled) 
[16:01:47.406]                           invokeRestart("muffleMessage")
[16:01:47.406]                       }
[16:01:47.406]                       else if (inherits(cond, "warning")) {
[16:01:47.406]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.406]                         if (muffled) 
[16:01:47.406]                           invokeRestart("muffleWarning")
[16:01:47.406]                       }
[16:01:47.406]                       else if (inherits(cond, "condition")) {
[16:01:47.406]                         if (!is.null(pattern)) {
[16:01:47.406]                           computeRestarts <- base::computeRestarts
[16:01:47.406]                           grepl <- base::grepl
[16:01:47.406]                           restarts <- computeRestarts(cond)
[16:01:47.406]                           for (restart in restarts) {
[16:01:47.406]                             name <- restart$name
[16:01:47.406]                             if (is.null(name)) 
[16:01:47.406]                               next
[16:01:47.406]                             if (!grepl(pattern, name)) 
[16:01:47.406]                               next
[16:01:47.406]                             invokeRestart(restart)
[16:01:47.406]                             muffled <- TRUE
[16:01:47.406]                             break
[16:01:47.406]                           }
[16:01:47.406]                         }
[16:01:47.406]                       }
[16:01:47.406]                       invisible(muffled)
[16:01:47.406]                     }
[16:01:47.406]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.406]                   }
[16:01:47.406]                 }
[16:01:47.406]             }
[16:01:47.406]         }))
[16:01:47.406]     }, error = function(ex) {
[16:01:47.406]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.406]                 ...future.rng), started = ...future.startTime, 
[16:01:47.406]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.406]             version = "1.8"), class = "FutureResult")
[16:01:47.406]     }, finally = {
[16:01:47.406]         if (!identical(...future.workdir, getwd())) 
[16:01:47.406]             setwd(...future.workdir)
[16:01:47.406]         {
[16:01:47.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.406]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.406]             }
[16:01:47.406]             base::options(...future.oldOptions)
[16:01:47.406]             if (.Platform$OS.type == "windows") {
[16:01:47.406]                 old_names <- names(...future.oldEnvVars)
[16:01:47.406]                 envs <- base::Sys.getenv()
[16:01:47.406]                 names <- names(envs)
[16:01:47.406]                 common <- intersect(names, old_names)
[16:01:47.406]                 added <- setdiff(names, old_names)
[16:01:47.406]                 removed <- setdiff(old_names, names)
[16:01:47.406]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.406]                   envs[common]]
[16:01:47.406]                 NAMES <- toupper(changed)
[16:01:47.406]                 args <- list()
[16:01:47.406]                 for (kk in seq_along(NAMES)) {
[16:01:47.406]                   name <- changed[[kk]]
[16:01:47.406]                   NAME <- NAMES[[kk]]
[16:01:47.406]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.406]                     next
[16:01:47.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.406]                 }
[16:01:47.406]                 NAMES <- toupper(added)
[16:01:47.406]                 for (kk in seq_along(NAMES)) {
[16:01:47.406]                   name <- added[[kk]]
[16:01:47.406]                   NAME <- NAMES[[kk]]
[16:01:47.406]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.406]                     next
[16:01:47.406]                   args[[name]] <- ""
[16:01:47.406]                 }
[16:01:47.406]                 NAMES <- toupper(removed)
[16:01:47.406]                 for (kk in seq_along(NAMES)) {
[16:01:47.406]                   name <- removed[[kk]]
[16:01:47.406]                   NAME <- NAMES[[kk]]
[16:01:47.406]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.406]                     next
[16:01:47.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.406]                 }
[16:01:47.406]                 if (length(args) > 0) 
[16:01:47.406]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.406]             }
[16:01:47.406]             else {
[16:01:47.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.406]             }
[16:01:47.406]             {
[16:01:47.406]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.406]                   0L) {
[16:01:47.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.406]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.406]                   base::options(opts)
[16:01:47.406]                 }
[16:01:47.406]                 {
[16:01:47.406]                   {
[16:01:47.406]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.406]                     NULL
[16:01:47.406]                   }
[16:01:47.406]                   options(future.plan = NULL)
[16:01:47.406]                   if (is.na(NA_character_)) 
[16:01:47.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.406]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.406]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.406]                     envir = parent.frame()) 
[16:01:47.406]                   {
[16:01:47.406]                     if (is.function(workers)) 
[16:01:47.406]                       workers <- workers()
[16:01:47.406]                     workers <- structure(as.integer(workers), 
[16:01:47.406]                       class = class(workers))
[16:01:47.406]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.406]                       workers >= 1)
[16:01:47.406]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.406]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.406]                     }
[16:01:47.406]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.406]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.406]                       envir = envir)
[16:01:47.406]                     if (!future$lazy) 
[16:01:47.406]                       future <- run(future)
[16:01:47.406]                     invisible(future)
[16:01:47.406]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.406]                 }
[16:01:47.406]             }
[16:01:47.406]         }
[16:01:47.406]     })
[16:01:47.406]     if (TRUE) {
[16:01:47.406]         base::sink(type = "output", split = FALSE)
[16:01:47.406]         if (TRUE) {
[16:01:47.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.406]         }
[16:01:47.406]         else {
[16:01:47.406]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.406]         }
[16:01:47.406]         base::close(...future.stdout)
[16:01:47.406]         ...future.stdout <- NULL
[16:01:47.406]     }
[16:01:47.406]     ...future.result$conditions <- ...future.conditions
[16:01:47.406]     ...future.result$finished <- base::Sys.time()
[16:01:47.406]     ...future.result
[16:01:47.406] }
[16:01:47.460] MultisessionFuture started
[16:01:47.460] result() for ClusterFuture ...
[16:01:47.461] receiveMessageFromWorker() for ClusterFuture ...
[16:01:47.461] - Validating connection of MultisessionFuture
[16:01:47.506] - received message: FutureResult
[16:01:47.506] - Received FutureResult
[16:01:47.506] - Erased future from FutureRegistry
[16:01:47.507] result() for ClusterFuture ...
[16:01:47.507] - result already collected: FutureResult
[16:01:47.507] result() for ClusterFuture ... done
[16:01:47.507] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:47.507] result() for ClusterFuture ... done
[16:01:47.507] result() for ClusterFuture ...
[16:01:47.507] - result already collected: FutureResult
[16:01:47.507] result() for ClusterFuture ... done
[16:01:47.507] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:01:47.511] plan(): nbrOfWorkers() = 2
[16:01:47.511] future_by_internal() ...
[16:01:47.511] future_lapply() ...
[16:01:47.515] Number of chunks: 2
[16:01:47.515] getGlobalsAndPackagesXApply() ...
[16:01:47.515]  - future.globals: TRUE
[16:01:47.515] getGlobalsAndPackages() ...
[16:01:47.515] Searching for globals...
[16:01:47.517] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:47.517] Searching for globals ... DONE
[16:01:47.517] Resolving globals: FALSE
[16:01:47.517] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:47.517] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:47.518] - globals: [1] ‘FUN’
[16:01:47.518] 
[16:01:47.518] getGlobalsAndPackages() ... DONE
[16:01:47.518]  - globals found/used: [n=1] ‘FUN’
[16:01:47.518]  - needed namespaces: [n=0] 
[16:01:47.518] Finding globals ... DONE
[16:01:47.518]  - use_args: TRUE
[16:01:47.518]  - Getting '...' globals ...
[16:01:47.519] resolve() on list ...
[16:01:47.519]  recursive: 0
[16:01:47.519]  length: 1
[16:01:47.519]  elements: ‘...’
[16:01:47.519]  length: 0 (resolved future 1)
[16:01:47.519] resolve() on list ... DONE
[16:01:47.519]    - '...' content: [n=0] 
[16:01:47.519] List of 1
[16:01:47.519]  $ ...: list()
[16:01:47.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:47.519]  - attr(*, "where")=List of 1
[16:01:47.519]   ..$ ...:<environment: 0x55b527136738> 
[16:01:47.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:47.519]  - attr(*, "resolved")= logi TRUE
[16:01:47.519]  - attr(*, "total_size")= num NA
[16:01:47.522]  - Getting '...' globals ... DONE
[16:01:47.522] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:47.522] List of 2
[16:01:47.522]  $ ...future.FUN:function (object, ...)  
[16:01:47.522]  $ ...          : list()
[16:01:47.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:47.522]  - attr(*, "where")=List of 2
[16:01:47.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:47.522]   ..$ ...          :<environment: 0x55b527136738> 
[16:01:47.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:47.522]  - attr(*, "resolved")= logi FALSE
[16:01:47.522]  - attr(*, "total_size")= num 1240
[16:01:47.524] Packages to be attached in all futures: [n=0] 
[16:01:47.525] getGlobalsAndPackagesXApply() ... DONE
[16:01:47.525] Number of futures (= number of chunks): 2
[16:01:47.525] Launching 2 futures (chunks) ...
[16:01:47.525] Chunk #1 of 2 ...
[16:01:47.525]  - Finding globals in 'X' for chunk #1 ...
[16:01:47.525] getGlobalsAndPackages() ...
[16:01:47.525] Searching for globals...
[16:01:47.526] 
[16:01:47.526] Searching for globals ... DONE
[16:01:47.526] - globals: [0] <none>
[16:01:47.526] getGlobalsAndPackages() ... DONE
[16:01:47.526]    + additional globals found: [n=0] 
[16:01:47.526]    + additional namespaces needed: [n=0] 
[16:01:47.526]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:47.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:47.526]  - seeds: <none>
[16:01:47.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.526] getGlobalsAndPackages() ...
[16:01:47.527] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.527] Resolving globals: FALSE
[16:01:47.527] Tweak future expression to call with '...' arguments ...
[16:01:47.527] {
[16:01:47.527]     do.call(function(...) {
[16:01:47.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.527]             on.exit(options(oopts), add = TRUE)
[16:01:47.527]         }
[16:01:47.527]         {
[16:01:47.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.527]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.527]             })
[16:01:47.527]         }
[16:01:47.527]     }, args = future.call.arguments)
[16:01:47.527] }
[16:01:47.527] Tweak future expression to call with '...' arguments ... DONE
[16:01:47.528] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.528] 
[16:01:47.528] getGlobalsAndPackages() ... DONE
[16:01:47.528] run() for ‘Future’ ...
[16:01:47.528] - state: ‘created’
[16:01:47.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:47.542] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:47.542]   - Field: ‘node’
[16:01:47.542]   - Field: ‘label’
[16:01:47.542]   - Field: ‘local’
[16:01:47.542]   - Field: ‘owner’
[16:01:47.542]   - Field: ‘envir’
[16:01:47.543]   - Field: ‘workers’
[16:01:47.543]   - Field: ‘packages’
[16:01:47.543]   - Field: ‘gc’
[16:01:47.543]   - Field: ‘conditions’
[16:01:47.543]   - Field: ‘persistent’
[16:01:47.543]   - Field: ‘expr’
[16:01:47.543]   - Field: ‘uuid’
[16:01:47.543]   - Field: ‘seed’
[16:01:47.543]   - Field: ‘version’
[16:01:47.543]   - Field: ‘result’
[16:01:47.543]   - Field: ‘asynchronous’
[16:01:47.544]   - Field: ‘calls’
[16:01:47.544]   - Field: ‘globals’
[16:01:47.544]   - Field: ‘stdout’
[16:01:47.544]   - Field: ‘earlySignal’
[16:01:47.544]   - Field: ‘lazy’
[16:01:47.544]   - Field: ‘state’
[16:01:47.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:47.544] - Launch lazy future ...
[16:01:47.545] Packages needed by the future expression (n = 0): <none>
[16:01:47.545] Packages needed by future strategies (n = 0): <none>
[16:01:47.545] {
[16:01:47.545]     {
[16:01:47.545]         {
[16:01:47.545]             ...future.startTime <- base::Sys.time()
[16:01:47.545]             {
[16:01:47.545]                 {
[16:01:47.545]                   {
[16:01:47.545]                     {
[16:01:47.545]                       base::local({
[16:01:47.545]                         has_future <- base::requireNamespace("future", 
[16:01:47.545]                           quietly = TRUE)
[16:01:47.545]                         if (has_future) {
[16:01:47.545]                           ns <- base::getNamespace("future")
[16:01:47.545]                           version <- ns[[".package"]][["version"]]
[16:01:47.545]                           if (is.null(version)) 
[16:01:47.545]                             version <- utils::packageVersion("future")
[16:01:47.545]                         }
[16:01:47.545]                         else {
[16:01:47.545]                           version <- NULL
[16:01:47.545]                         }
[16:01:47.545]                         if (!has_future || version < "1.8.0") {
[16:01:47.545]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.545]                             "", base::R.version$version.string), 
[16:01:47.545]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:47.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:47.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.545]                               "release", "version")], collapse = " "), 
[16:01:47.545]                             hostname = base::Sys.info()[["nodename"]])
[16:01:47.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.545]                             info)
[16:01:47.545]                           info <- base::paste(info, collapse = "; ")
[16:01:47.545]                           if (!has_future) {
[16:01:47.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.545]                               info)
[16:01:47.545]                           }
[16:01:47.545]                           else {
[16:01:47.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.545]                               info, version)
[16:01:47.545]                           }
[16:01:47.545]                           base::stop(msg)
[16:01:47.545]                         }
[16:01:47.545]                       })
[16:01:47.545]                     }
[16:01:47.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.545]                     base::options(mc.cores = 1L)
[16:01:47.545]                   }
[16:01:47.545]                   options(future.plan = NULL)
[16:01:47.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.545]                 }
[16:01:47.545]                 ...future.workdir <- getwd()
[16:01:47.545]             }
[16:01:47.545]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.545]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.545]         }
[16:01:47.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.545]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:47.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.545]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.545]             base::names(...future.oldOptions))
[16:01:47.545]     }
[16:01:47.545]     if (FALSE) {
[16:01:47.545]     }
[16:01:47.545]     else {
[16:01:47.545]         if (TRUE) {
[16:01:47.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.545]                 open = "w")
[16:01:47.545]         }
[16:01:47.545]         else {
[16:01:47.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.545]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.545]         }
[16:01:47.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.545]             base::sink(type = "output", split = FALSE)
[16:01:47.545]             base::close(...future.stdout)
[16:01:47.545]         }, add = TRUE)
[16:01:47.545]     }
[16:01:47.545]     ...future.frame <- base::sys.nframe()
[16:01:47.545]     ...future.conditions <- base::list()
[16:01:47.545]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.545]     if (FALSE) {
[16:01:47.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.545]     }
[16:01:47.545]     ...future.result <- base::tryCatch({
[16:01:47.545]         base::withCallingHandlers({
[16:01:47.545]             ...future.value <- base::withVisible(base::local({
[16:01:47.545]                 ...future.makeSendCondition <- base::local({
[16:01:47.545]                   sendCondition <- NULL
[16:01:47.545]                   function(frame = 1L) {
[16:01:47.545]                     if (is.function(sendCondition)) 
[16:01:47.545]                       return(sendCondition)
[16:01:47.545]                     ns <- getNamespace("parallel")
[16:01:47.545]                     if (exists("sendData", mode = "function", 
[16:01:47.545]                       envir = ns)) {
[16:01:47.545]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.545]                         envir = ns)
[16:01:47.545]                       envir <- sys.frame(frame)
[16:01:47.545]                       master <- NULL
[16:01:47.545]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.545]                         !identical(envir, emptyenv())) {
[16:01:47.545]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.545]                           inherits = FALSE)) {
[16:01:47.545]                           master <- get("master", mode = "list", 
[16:01:47.545]                             envir = envir, inherits = FALSE)
[16:01:47.545]                           if (inherits(master, c("SOCKnode", 
[16:01:47.545]                             "SOCK0node"))) {
[16:01:47.545]                             sendCondition <<- function(cond) {
[16:01:47.545]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.545]                                 success = TRUE)
[16:01:47.545]                               parallel_sendData(master, data)
[16:01:47.545]                             }
[16:01:47.545]                             return(sendCondition)
[16:01:47.545]                           }
[16:01:47.545]                         }
[16:01:47.545]                         frame <- frame + 1L
[16:01:47.545]                         envir <- sys.frame(frame)
[16:01:47.545]                       }
[16:01:47.545]                     }
[16:01:47.545]                     sendCondition <<- function(cond) NULL
[16:01:47.545]                   }
[16:01:47.545]                 })
[16:01:47.545]                 withCallingHandlers({
[16:01:47.545]                   {
[16:01:47.545]                     do.call(function(...) {
[16:01:47.545]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.545]                       if (!identical(...future.globals.maxSize.org, 
[16:01:47.545]                         ...future.globals.maxSize)) {
[16:01:47.545]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.545]                         on.exit(options(oopts), add = TRUE)
[16:01:47.545]                       }
[16:01:47.545]                       {
[16:01:47.545]                         lapply(seq_along(...future.elements_ii), 
[16:01:47.545]                           FUN = function(jj) {
[16:01:47.545]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.545]                             ...future.FUN(...future.X_jj, ...)
[16:01:47.545]                           })
[16:01:47.545]                       }
[16:01:47.545]                     }, args = future.call.arguments)
[16:01:47.545]                   }
[16:01:47.545]                 }, immediateCondition = function(cond) {
[16:01:47.545]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.545]                   sendCondition(cond)
[16:01:47.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.545]                   {
[16:01:47.545]                     inherits <- base::inherits
[16:01:47.545]                     invokeRestart <- base::invokeRestart
[16:01:47.545]                     is.null <- base::is.null
[16:01:47.545]                     muffled <- FALSE
[16:01:47.545]                     if (inherits(cond, "message")) {
[16:01:47.545]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.545]                       if (muffled) 
[16:01:47.545]                         invokeRestart("muffleMessage")
[16:01:47.545]                     }
[16:01:47.545]                     else if (inherits(cond, "warning")) {
[16:01:47.545]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.545]                       if (muffled) 
[16:01:47.545]                         invokeRestart("muffleWarning")
[16:01:47.545]                     }
[16:01:47.545]                     else if (inherits(cond, "condition")) {
[16:01:47.545]                       if (!is.null(pattern)) {
[16:01:47.545]                         computeRestarts <- base::computeRestarts
[16:01:47.545]                         grepl <- base::grepl
[16:01:47.545]                         restarts <- computeRestarts(cond)
[16:01:47.545]                         for (restart in restarts) {
[16:01:47.545]                           name <- restart$name
[16:01:47.545]                           if (is.null(name)) 
[16:01:47.545]                             next
[16:01:47.545]                           if (!grepl(pattern, name)) 
[16:01:47.545]                             next
[16:01:47.545]                           invokeRestart(restart)
[16:01:47.545]                           muffled <- TRUE
[16:01:47.545]                           break
[16:01:47.545]                         }
[16:01:47.545]                       }
[16:01:47.545]                     }
[16:01:47.545]                     invisible(muffled)
[16:01:47.545]                   }
[16:01:47.545]                   muffleCondition(cond)
[16:01:47.545]                 })
[16:01:47.545]             }))
[16:01:47.545]             future::FutureResult(value = ...future.value$value, 
[16:01:47.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.545]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.545]                     ...future.globalenv.names))
[16:01:47.545]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.545]         }, condition = base::local({
[16:01:47.545]             c <- base::c
[16:01:47.545]             inherits <- base::inherits
[16:01:47.545]             invokeRestart <- base::invokeRestart
[16:01:47.545]             length <- base::length
[16:01:47.545]             list <- base::list
[16:01:47.545]             seq.int <- base::seq.int
[16:01:47.545]             signalCondition <- base::signalCondition
[16:01:47.545]             sys.calls <- base::sys.calls
[16:01:47.545]             `[[` <- base::`[[`
[16:01:47.545]             `+` <- base::`+`
[16:01:47.545]             `<<-` <- base::`<<-`
[16:01:47.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.545]                   3L)]
[16:01:47.545]             }
[16:01:47.545]             function(cond) {
[16:01:47.545]                 is_error <- inherits(cond, "error")
[16:01:47.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.545]                   NULL)
[16:01:47.545]                 if (is_error) {
[16:01:47.545]                   sessionInformation <- function() {
[16:01:47.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.545]                       search = base::search(), system = base::Sys.info())
[16:01:47.545]                   }
[16:01:47.545]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.545]                     cond$call), session = sessionInformation(), 
[16:01:47.545]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.545]                   signalCondition(cond)
[16:01:47.545]                 }
[16:01:47.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.545]                 "immediateCondition"))) {
[16:01:47.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.545]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.545]                   if (TRUE && !signal) {
[16:01:47.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.545]                     {
[16:01:47.545]                       inherits <- base::inherits
[16:01:47.545]                       invokeRestart <- base::invokeRestart
[16:01:47.545]                       is.null <- base::is.null
[16:01:47.545]                       muffled <- FALSE
[16:01:47.545]                       if (inherits(cond, "message")) {
[16:01:47.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.545]                         if (muffled) 
[16:01:47.545]                           invokeRestart("muffleMessage")
[16:01:47.545]                       }
[16:01:47.545]                       else if (inherits(cond, "warning")) {
[16:01:47.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.545]                         if (muffled) 
[16:01:47.545]                           invokeRestart("muffleWarning")
[16:01:47.545]                       }
[16:01:47.545]                       else if (inherits(cond, "condition")) {
[16:01:47.545]                         if (!is.null(pattern)) {
[16:01:47.545]                           computeRestarts <- base::computeRestarts
[16:01:47.545]                           grepl <- base::grepl
[16:01:47.545]                           restarts <- computeRestarts(cond)
[16:01:47.545]                           for (restart in restarts) {
[16:01:47.545]                             name <- restart$name
[16:01:47.545]                             if (is.null(name)) 
[16:01:47.545]                               next
[16:01:47.545]                             if (!grepl(pattern, name)) 
[16:01:47.545]                               next
[16:01:47.545]                             invokeRestart(restart)
[16:01:47.545]                             muffled <- TRUE
[16:01:47.545]                             break
[16:01:47.545]                           }
[16:01:47.545]                         }
[16:01:47.545]                       }
[16:01:47.545]                       invisible(muffled)
[16:01:47.545]                     }
[16:01:47.545]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.545]                   }
[16:01:47.545]                 }
[16:01:47.545]                 else {
[16:01:47.545]                   if (TRUE) {
[16:01:47.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.545]                     {
[16:01:47.545]                       inherits <- base::inherits
[16:01:47.545]                       invokeRestart <- base::invokeRestart
[16:01:47.545]                       is.null <- base::is.null
[16:01:47.545]                       muffled <- FALSE
[16:01:47.545]                       if (inherits(cond, "message")) {
[16:01:47.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.545]                         if (muffled) 
[16:01:47.545]                           invokeRestart("muffleMessage")
[16:01:47.545]                       }
[16:01:47.545]                       else if (inherits(cond, "warning")) {
[16:01:47.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.545]                         if (muffled) 
[16:01:47.545]                           invokeRestart("muffleWarning")
[16:01:47.545]                       }
[16:01:47.545]                       else if (inherits(cond, "condition")) {
[16:01:47.545]                         if (!is.null(pattern)) {
[16:01:47.545]                           computeRestarts <- base::computeRestarts
[16:01:47.545]                           grepl <- base::grepl
[16:01:47.545]                           restarts <- computeRestarts(cond)
[16:01:47.545]                           for (restart in restarts) {
[16:01:47.545]                             name <- restart$name
[16:01:47.545]                             if (is.null(name)) 
[16:01:47.545]                               next
[16:01:47.545]                             if (!grepl(pattern, name)) 
[16:01:47.545]                               next
[16:01:47.545]                             invokeRestart(restart)
[16:01:47.545]                             muffled <- TRUE
[16:01:47.545]                             break
[16:01:47.545]                           }
[16:01:47.545]                         }
[16:01:47.545]                       }
[16:01:47.545]                       invisible(muffled)
[16:01:47.545]                     }
[16:01:47.545]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.545]                   }
[16:01:47.545]                 }
[16:01:47.545]             }
[16:01:47.545]         }))
[16:01:47.545]     }, error = function(ex) {
[16:01:47.545]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.545]                 ...future.rng), started = ...future.startTime, 
[16:01:47.545]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.545]             version = "1.8"), class = "FutureResult")
[16:01:47.545]     }, finally = {
[16:01:47.545]         if (!identical(...future.workdir, getwd())) 
[16:01:47.545]             setwd(...future.workdir)
[16:01:47.545]         {
[16:01:47.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.545]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.545]             }
[16:01:47.545]             base::options(...future.oldOptions)
[16:01:47.545]             if (.Platform$OS.type == "windows") {
[16:01:47.545]                 old_names <- names(...future.oldEnvVars)
[16:01:47.545]                 envs <- base::Sys.getenv()
[16:01:47.545]                 names <- names(envs)
[16:01:47.545]                 common <- intersect(names, old_names)
[16:01:47.545]                 added <- setdiff(names, old_names)
[16:01:47.545]                 removed <- setdiff(old_names, names)
[16:01:47.545]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.545]                   envs[common]]
[16:01:47.545]                 NAMES <- toupper(changed)
[16:01:47.545]                 args <- list()
[16:01:47.545]                 for (kk in seq_along(NAMES)) {
[16:01:47.545]                   name <- changed[[kk]]
[16:01:47.545]                   NAME <- NAMES[[kk]]
[16:01:47.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.545]                     next
[16:01:47.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.545]                 }
[16:01:47.545]                 NAMES <- toupper(added)
[16:01:47.545]                 for (kk in seq_along(NAMES)) {
[16:01:47.545]                   name <- added[[kk]]
[16:01:47.545]                   NAME <- NAMES[[kk]]
[16:01:47.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.545]                     next
[16:01:47.545]                   args[[name]] <- ""
[16:01:47.545]                 }
[16:01:47.545]                 NAMES <- toupper(removed)
[16:01:47.545]                 for (kk in seq_along(NAMES)) {
[16:01:47.545]                   name <- removed[[kk]]
[16:01:47.545]                   NAME <- NAMES[[kk]]
[16:01:47.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.545]                     next
[16:01:47.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.545]                 }
[16:01:47.545]                 if (length(args) > 0) 
[16:01:47.545]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.545]             }
[16:01:47.545]             else {
[16:01:47.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.545]             }
[16:01:47.545]             {
[16:01:47.545]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.545]                   0L) {
[16:01:47.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.545]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.545]                   base::options(opts)
[16:01:47.545]                 }
[16:01:47.545]                 {
[16:01:47.545]                   {
[16:01:47.545]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.545]                     NULL
[16:01:47.545]                   }
[16:01:47.545]                   options(future.plan = NULL)
[16:01:47.545]                   if (is.na(NA_character_)) 
[16:01:47.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.545]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.545]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.545]                     envir = parent.frame()) 
[16:01:47.545]                   {
[16:01:47.545]                     if (is.function(workers)) 
[16:01:47.545]                       workers <- workers()
[16:01:47.545]                     workers <- structure(as.integer(workers), 
[16:01:47.545]                       class = class(workers))
[16:01:47.545]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.545]                       workers >= 1)
[16:01:47.545]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.545]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.545]                     }
[16:01:47.545]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.545]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.545]                       envir = envir)
[16:01:47.545]                     if (!future$lazy) 
[16:01:47.545]                       future <- run(future)
[16:01:47.545]                     invisible(future)
[16:01:47.545]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.545]                 }
[16:01:47.545]             }
[16:01:47.545]         }
[16:01:47.545]     })
[16:01:47.545]     if (TRUE) {
[16:01:47.545]         base::sink(type = "output", split = FALSE)
[16:01:47.545]         if (TRUE) {
[16:01:47.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.545]         }
[16:01:47.545]         else {
[16:01:47.545]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.545]         }
[16:01:47.545]         base::close(...future.stdout)
[16:01:47.545]         ...future.stdout <- NULL
[16:01:47.545]     }
[16:01:47.545]     ...future.result$conditions <- ...future.conditions
[16:01:47.545]     ...future.result$finished <- base::Sys.time()
[16:01:47.545]     ...future.result
[16:01:47.545] }
[16:01:47.548] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:01:47.548] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:01:47.549] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:01:47.549] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:47.549] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.550] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[16:01:47.550] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[16:01:47.550] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:47.550] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.551] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:47.551] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.551] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:01:47.552] MultisessionFuture started
[16:01:47.552] - Launch lazy future ... done
[16:01:47.552] run() for ‘MultisessionFuture’ ... done
[16:01:47.552] Created future:
[16:01:47.552] MultisessionFuture:
[16:01:47.552] Label: ‘future_by-1’
[16:01:47.552] Expression:
[16:01:47.552] {
[16:01:47.552]     do.call(function(...) {
[16:01:47.552]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.552]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.552]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.552]             on.exit(options(oopts), add = TRUE)
[16:01:47.552]         }
[16:01:47.552]         {
[16:01:47.552]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.552]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.552]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.552]             })
[16:01:47.552]         }
[16:01:47.552]     }, args = future.call.arguments)
[16:01:47.552] }
[16:01:47.552] Lazy evaluation: FALSE
[16:01:47.552] Asynchronous evaluation: TRUE
[16:01:47.552] Local evaluation: TRUE
[16:01:47.552] Environment: R_GlobalEnv
[16:01:47.552] Capture standard output: TRUE
[16:01:47.552] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:47.552] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:47.552] Packages: <none>
[16:01:47.552] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:47.552] Resolved: FALSE
[16:01:47.552] Value: <not collected>
[16:01:47.552] Conditions captured: <none>
[16:01:47.552] Early signaling: FALSE
[16:01:47.552] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:47.552] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.564] Chunk #1 of 2 ... DONE
[16:01:47.564] Chunk #2 of 2 ...
[16:01:47.564]  - Finding globals in 'X' for chunk #2 ...
[16:01:47.564] getGlobalsAndPackages() ...
[16:01:47.565] Searching for globals...
[16:01:47.565] 
[16:01:47.565] Searching for globals ... DONE
[16:01:47.565] - globals: [0] <none>
[16:01:47.565] getGlobalsAndPackages() ... DONE
[16:01:47.565]    + additional globals found: [n=0] 
[16:01:47.565]    + additional namespaces needed: [n=0] 
[16:01:47.566]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:47.566]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:47.566]  - seeds: <none>
[16:01:47.566]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.566] getGlobalsAndPackages() ...
[16:01:47.566] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.566] Resolving globals: FALSE
[16:01:47.566] Tweak future expression to call with '...' arguments ...
[16:01:47.566] {
[16:01:47.566]     do.call(function(...) {
[16:01:47.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.566]             on.exit(options(oopts), add = TRUE)
[16:01:47.566]         }
[16:01:47.566]         {
[16:01:47.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.566]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.566]             })
[16:01:47.566]         }
[16:01:47.566]     }, args = future.call.arguments)
[16:01:47.566] }
[16:01:47.567] Tweak future expression to call with '...' arguments ... DONE
[16:01:47.567] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.567] 
[16:01:47.567] getGlobalsAndPackages() ... DONE
[16:01:47.568] run() for ‘Future’ ...
[16:01:47.568] - state: ‘created’
[16:01:47.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:47.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:47.582]   - Field: ‘node’
[16:01:47.582]   - Field: ‘label’
[16:01:47.582]   - Field: ‘local’
[16:01:47.582]   - Field: ‘owner’
[16:01:47.582]   - Field: ‘envir’
[16:01:47.583]   - Field: ‘workers’
[16:01:47.583]   - Field: ‘packages’
[16:01:47.583]   - Field: ‘gc’
[16:01:47.583]   - Field: ‘conditions’
[16:01:47.583]   - Field: ‘persistent’
[16:01:47.583]   - Field: ‘expr’
[16:01:47.583]   - Field: ‘uuid’
[16:01:47.583]   - Field: ‘seed’
[16:01:47.583]   - Field: ‘version’
[16:01:47.583]   - Field: ‘result’
[16:01:47.583]   - Field: ‘asynchronous’
[16:01:47.584]   - Field: ‘calls’
[16:01:47.584]   - Field: ‘globals’
[16:01:47.584]   - Field: ‘stdout’
[16:01:47.584]   - Field: ‘earlySignal’
[16:01:47.584]   - Field: ‘lazy’
[16:01:47.584]   - Field: ‘state’
[16:01:47.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:47.584] - Launch lazy future ...
[16:01:47.585] Packages needed by the future expression (n = 0): <none>
[16:01:47.585] Packages needed by future strategies (n = 0): <none>
[16:01:47.585] {
[16:01:47.585]     {
[16:01:47.585]         {
[16:01:47.585]             ...future.startTime <- base::Sys.time()
[16:01:47.585]             {
[16:01:47.585]                 {
[16:01:47.585]                   {
[16:01:47.585]                     {
[16:01:47.585]                       base::local({
[16:01:47.585]                         has_future <- base::requireNamespace("future", 
[16:01:47.585]                           quietly = TRUE)
[16:01:47.585]                         if (has_future) {
[16:01:47.585]                           ns <- base::getNamespace("future")
[16:01:47.585]                           version <- ns[[".package"]][["version"]]
[16:01:47.585]                           if (is.null(version)) 
[16:01:47.585]                             version <- utils::packageVersion("future")
[16:01:47.585]                         }
[16:01:47.585]                         else {
[16:01:47.585]                           version <- NULL
[16:01:47.585]                         }
[16:01:47.585]                         if (!has_future || version < "1.8.0") {
[16:01:47.585]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.585]                             "", base::R.version$version.string), 
[16:01:47.585]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:47.585]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:47.585]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.585]                               "release", "version")], collapse = " "), 
[16:01:47.585]                             hostname = base::Sys.info()[["nodename"]])
[16:01:47.585]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.585]                             info)
[16:01:47.585]                           info <- base::paste(info, collapse = "; ")
[16:01:47.585]                           if (!has_future) {
[16:01:47.585]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.585]                               info)
[16:01:47.585]                           }
[16:01:47.585]                           else {
[16:01:47.585]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.585]                               info, version)
[16:01:47.585]                           }
[16:01:47.585]                           base::stop(msg)
[16:01:47.585]                         }
[16:01:47.585]                       })
[16:01:47.585]                     }
[16:01:47.585]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.585]                     base::options(mc.cores = 1L)
[16:01:47.585]                   }
[16:01:47.585]                   options(future.plan = NULL)
[16:01:47.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.585]                 }
[16:01:47.585]                 ...future.workdir <- getwd()
[16:01:47.585]             }
[16:01:47.585]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.585]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.585]         }
[16:01:47.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.585]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:47.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.585]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.585]             base::names(...future.oldOptions))
[16:01:47.585]     }
[16:01:47.585]     if (FALSE) {
[16:01:47.585]     }
[16:01:47.585]     else {
[16:01:47.585]         if (TRUE) {
[16:01:47.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.585]                 open = "w")
[16:01:47.585]         }
[16:01:47.585]         else {
[16:01:47.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.585]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.585]         }
[16:01:47.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.585]             base::sink(type = "output", split = FALSE)
[16:01:47.585]             base::close(...future.stdout)
[16:01:47.585]         }, add = TRUE)
[16:01:47.585]     }
[16:01:47.585]     ...future.frame <- base::sys.nframe()
[16:01:47.585]     ...future.conditions <- base::list()
[16:01:47.585]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.585]     if (FALSE) {
[16:01:47.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.585]     }
[16:01:47.585]     ...future.result <- base::tryCatch({
[16:01:47.585]         base::withCallingHandlers({
[16:01:47.585]             ...future.value <- base::withVisible(base::local({
[16:01:47.585]                 ...future.makeSendCondition <- base::local({
[16:01:47.585]                   sendCondition <- NULL
[16:01:47.585]                   function(frame = 1L) {
[16:01:47.585]                     if (is.function(sendCondition)) 
[16:01:47.585]                       return(sendCondition)
[16:01:47.585]                     ns <- getNamespace("parallel")
[16:01:47.585]                     if (exists("sendData", mode = "function", 
[16:01:47.585]                       envir = ns)) {
[16:01:47.585]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.585]                         envir = ns)
[16:01:47.585]                       envir <- sys.frame(frame)
[16:01:47.585]                       master <- NULL
[16:01:47.585]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.585]                         !identical(envir, emptyenv())) {
[16:01:47.585]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.585]                           inherits = FALSE)) {
[16:01:47.585]                           master <- get("master", mode = "list", 
[16:01:47.585]                             envir = envir, inherits = FALSE)
[16:01:47.585]                           if (inherits(master, c("SOCKnode", 
[16:01:47.585]                             "SOCK0node"))) {
[16:01:47.585]                             sendCondition <<- function(cond) {
[16:01:47.585]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.585]                                 success = TRUE)
[16:01:47.585]                               parallel_sendData(master, data)
[16:01:47.585]                             }
[16:01:47.585]                             return(sendCondition)
[16:01:47.585]                           }
[16:01:47.585]                         }
[16:01:47.585]                         frame <- frame + 1L
[16:01:47.585]                         envir <- sys.frame(frame)
[16:01:47.585]                       }
[16:01:47.585]                     }
[16:01:47.585]                     sendCondition <<- function(cond) NULL
[16:01:47.585]                   }
[16:01:47.585]                 })
[16:01:47.585]                 withCallingHandlers({
[16:01:47.585]                   {
[16:01:47.585]                     do.call(function(...) {
[16:01:47.585]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.585]                       if (!identical(...future.globals.maxSize.org, 
[16:01:47.585]                         ...future.globals.maxSize)) {
[16:01:47.585]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.585]                         on.exit(options(oopts), add = TRUE)
[16:01:47.585]                       }
[16:01:47.585]                       {
[16:01:47.585]                         lapply(seq_along(...future.elements_ii), 
[16:01:47.585]                           FUN = function(jj) {
[16:01:47.585]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.585]                             ...future.FUN(...future.X_jj, ...)
[16:01:47.585]                           })
[16:01:47.585]                       }
[16:01:47.585]                     }, args = future.call.arguments)
[16:01:47.585]                   }
[16:01:47.585]                 }, immediateCondition = function(cond) {
[16:01:47.585]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.585]                   sendCondition(cond)
[16:01:47.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.585]                   {
[16:01:47.585]                     inherits <- base::inherits
[16:01:47.585]                     invokeRestart <- base::invokeRestart
[16:01:47.585]                     is.null <- base::is.null
[16:01:47.585]                     muffled <- FALSE
[16:01:47.585]                     if (inherits(cond, "message")) {
[16:01:47.585]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.585]                       if (muffled) 
[16:01:47.585]                         invokeRestart("muffleMessage")
[16:01:47.585]                     }
[16:01:47.585]                     else if (inherits(cond, "warning")) {
[16:01:47.585]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.585]                       if (muffled) 
[16:01:47.585]                         invokeRestart("muffleWarning")
[16:01:47.585]                     }
[16:01:47.585]                     else if (inherits(cond, "condition")) {
[16:01:47.585]                       if (!is.null(pattern)) {
[16:01:47.585]                         computeRestarts <- base::computeRestarts
[16:01:47.585]                         grepl <- base::grepl
[16:01:47.585]                         restarts <- computeRestarts(cond)
[16:01:47.585]                         for (restart in restarts) {
[16:01:47.585]                           name <- restart$name
[16:01:47.585]                           if (is.null(name)) 
[16:01:47.585]                             next
[16:01:47.585]                           if (!grepl(pattern, name)) 
[16:01:47.585]                             next
[16:01:47.585]                           invokeRestart(restart)
[16:01:47.585]                           muffled <- TRUE
[16:01:47.585]                           break
[16:01:47.585]                         }
[16:01:47.585]                       }
[16:01:47.585]                     }
[16:01:47.585]                     invisible(muffled)
[16:01:47.585]                   }
[16:01:47.585]                   muffleCondition(cond)
[16:01:47.585]                 })
[16:01:47.585]             }))
[16:01:47.585]             future::FutureResult(value = ...future.value$value, 
[16:01:47.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.585]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.585]                     ...future.globalenv.names))
[16:01:47.585]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.585]         }, condition = base::local({
[16:01:47.585]             c <- base::c
[16:01:47.585]             inherits <- base::inherits
[16:01:47.585]             invokeRestart <- base::invokeRestart
[16:01:47.585]             length <- base::length
[16:01:47.585]             list <- base::list
[16:01:47.585]             seq.int <- base::seq.int
[16:01:47.585]             signalCondition <- base::signalCondition
[16:01:47.585]             sys.calls <- base::sys.calls
[16:01:47.585]             `[[` <- base::`[[`
[16:01:47.585]             `+` <- base::`+`
[16:01:47.585]             `<<-` <- base::`<<-`
[16:01:47.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.585]                   3L)]
[16:01:47.585]             }
[16:01:47.585]             function(cond) {
[16:01:47.585]                 is_error <- inherits(cond, "error")
[16:01:47.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.585]                   NULL)
[16:01:47.585]                 if (is_error) {
[16:01:47.585]                   sessionInformation <- function() {
[16:01:47.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.585]                       search = base::search(), system = base::Sys.info())
[16:01:47.585]                   }
[16:01:47.585]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.585]                     cond$call), session = sessionInformation(), 
[16:01:47.585]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.585]                   signalCondition(cond)
[16:01:47.585]                 }
[16:01:47.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.585]                 "immediateCondition"))) {
[16:01:47.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.585]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.585]                   if (TRUE && !signal) {
[16:01:47.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.585]                     {
[16:01:47.585]                       inherits <- base::inherits
[16:01:47.585]                       invokeRestart <- base::invokeRestart
[16:01:47.585]                       is.null <- base::is.null
[16:01:47.585]                       muffled <- FALSE
[16:01:47.585]                       if (inherits(cond, "message")) {
[16:01:47.585]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.585]                         if (muffled) 
[16:01:47.585]                           invokeRestart("muffleMessage")
[16:01:47.585]                       }
[16:01:47.585]                       else if (inherits(cond, "warning")) {
[16:01:47.585]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.585]                         if (muffled) 
[16:01:47.585]                           invokeRestart("muffleWarning")
[16:01:47.585]                       }
[16:01:47.585]                       else if (inherits(cond, "condition")) {
[16:01:47.585]                         if (!is.null(pattern)) {
[16:01:47.585]                           computeRestarts <- base::computeRestarts
[16:01:47.585]                           grepl <- base::grepl
[16:01:47.585]                           restarts <- computeRestarts(cond)
[16:01:47.585]                           for (restart in restarts) {
[16:01:47.585]                             name <- restart$name
[16:01:47.585]                             if (is.null(name)) 
[16:01:47.585]                               next
[16:01:47.585]                             if (!grepl(pattern, name)) 
[16:01:47.585]                               next
[16:01:47.585]                             invokeRestart(restart)
[16:01:47.585]                             muffled <- TRUE
[16:01:47.585]                             break
[16:01:47.585]                           }
[16:01:47.585]                         }
[16:01:47.585]                       }
[16:01:47.585]                       invisible(muffled)
[16:01:47.585]                     }
[16:01:47.585]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.585]                   }
[16:01:47.585]                 }
[16:01:47.585]                 else {
[16:01:47.585]                   if (TRUE) {
[16:01:47.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.585]                     {
[16:01:47.585]                       inherits <- base::inherits
[16:01:47.585]                       invokeRestart <- base::invokeRestart
[16:01:47.585]                       is.null <- base::is.null
[16:01:47.585]                       muffled <- FALSE
[16:01:47.585]                       if (inherits(cond, "message")) {
[16:01:47.585]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.585]                         if (muffled) 
[16:01:47.585]                           invokeRestart("muffleMessage")
[16:01:47.585]                       }
[16:01:47.585]                       else if (inherits(cond, "warning")) {
[16:01:47.585]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.585]                         if (muffled) 
[16:01:47.585]                           invokeRestart("muffleWarning")
[16:01:47.585]                       }
[16:01:47.585]                       else if (inherits(cond, "condition")) {
[16:01:47.585]                         if (!is.null(pattern)) {
[16:01:47.585]                           computeRestarts <- base::computeRestarts
[16:01:47.585]                           grepl <- base::grepl
[16:01:47.585]                           restarts <- computeRestarts(cond)
[16:01:47.585]                           for (restart in restarts) {
[16:01:47.585]                             name <- restart$name
[16:01:47.585]                             if (is.null(name)) 
[16:01:47.585]                               next
[16:01:47.585]                             if (!grepl(pattern, name)) 
[16:01:47.585]                               next
[16:01:47.585]                             invokeRestart(restart)
[16:01:47.585]                             muffled <- TRUE
[16:01:47.585]                             break
[16:01:47.585]                           }
[16:01:47.585]                         }
[16:01:47.585]                       }
[16:01:47.585]                       invisible(muffled)
[16:01:47.585]                     }
[16:01:47.585]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.585]                   }
[16:01:47.585]                 }
[16:01:47.585]             }
[16:01:47.585]         }))
[16:01:47.585]     }, error = function(ex) {
[16:01:47.585]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.585]                 ...future.rng), started = ...future.startTime, 
[16:01:47.585]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.585]             version = "1.8"), class = "FutureResult")
[16:01:47.585]     }, finally = {
[16:01:47.585]         if (!identical(...future.workdir, getwd())) 
[16:01:47.585]             setwd(...future.workdir)
[16:01:47.585]         {
[16:01:47.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.585]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.585]             }
[16:01:47.585]             base::options(...future.oldOptions)
[16:01:47.585]             if (.Platform$OS.type == "windows") {
[16:01:47.585]                 old_names <- names(...future.oldEnvVars)
[16:01:47.585]                 envs <- base::Sys.getenv()
[16:01:47.585]                 names <- names(envs)
[16:01:47.585]                 common <- intersect(names, old_names)
[16:01:47.585]                 added <- setdiff(names, old_names)
[16:01:47.585]                 removed <- setdiff(old_names, names)
[16:01:47.585]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.585]                   envs[common]]
[16:01:47.585]                 NAMES <- toupper(changed)
[16:01:47.585]                 args <- list()
[16:01:47.585]                 for (kk in seq_along(NAMES)) {
[16:01:47.585]                   name <- changed[[kk]]
[16:01:47.585]                   NAME <- NAMES[[kk]]
[16:01:47.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.585]                     next
[16:01:47.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.585]                 }
[16:01:47.585]                 NAMES <- toupper(added)
[16:01:47.585]                 for (kk in seq_along(NAMES)) {
[16:01:47.585]                   name <- added[[kk]]
[16:01:47.585]                   NAME <- NAMES[[kk]]
[16:01:47.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.585]                     next
[16:01:47.585]                   args[[name]] <- ""
[16:01:47.585]                 }
[16:01:47.585]                 NAMES <- toupper(removed)
[16:01:47.585]                 for (kk in seq_along(NAMES)) {
[16:01:47.585]                   name <- removed[[kk]]
[16:01:47.585]                   NAME <- NAMES[[kk]]
[16:01:47.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.585]                     next
[16:01:47.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.585]                 }
[16:01:47.585]                 if (length(args) > 0) 
[16:01:47.585]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.585]             }
[16:01:47.585]             else {
[16:01:47.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.585]             }
[16:01:47.585]             {
[16:01:47.585]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.585]                   0L) {
[16:01:47.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.585]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.585]                   base::options(opts)
[16:01:47.585]                 }
[16:01:47.585]                 {
[16:01:47.585]                   {
[16:01:47.585]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.585]                     NULL
[16:01:47.585]                   }
[16:01:47.585]                   options(future.plan = NULL)
[16:01:47.585]                   if (is.na(NA_character_)) 
[16:01:47.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.585]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.585]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.585]                     envir = parent.frame()) 
[16:01:47.585]                   {
[16:01:47.585]                     if (is.function(workers)) 
[16:01:47.585]                       workers <- workers()
[16:01:47.585]                     workers <- structure(as.integer(workers), 
[16:01:47.585]                       class = class(workers))
[16:01:47.585]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.585]                       workers >= 1)
[16:01:47.585]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.585]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.585]                     }
[16:01:47.585]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.585]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.585]                       envir = envir)
[16:01:47.585]                     if (!future$lazy) 
[16:01:47.585]                       future <- run(future)
[16:01:47.585]                     invisible(future)
[16:01:47.585]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.585]                 }
[16:01:47.585]             }
[16:01:47.585]         }
[16:01:47.585]     })
[16:01:47.585]     if (TRUE) {
[16:01:47.585]         base::sink(type = "output", split = FALSE)
[16:01:47.585]         if (TRUE) {
[16:01:47.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.585]         }
[16:01:47.585]         else {
[16:01:47.585]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.585]         }
[16:01:47.585]         base::close(...future.stdout)
[16:01:47.585]         ...future.stdout <- NULL
[16:01:47.585]     }
[16:01:47.585]     ...future.result$conditions <- ...future.conditions
[16:01:47.585]     ...future.result$finished <- base::Sys.time()
[16:01:47.585]     ...future.result
[16:01:47.585] }
[16:01:47.640] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:01:47.641] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:01:47.641] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:01:47.642] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:47.642] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.642] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[16:01:47.642] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[16:01:47.643] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:47.643] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.643] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:47.643] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.643] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:01:47.644] MultisessionFuture started
[16:01:47.644] - Launch lazy future ... done
[16:01:47.644] run() for ‘MultisessionFuture’ ... done
[16:01:47.644] Created future:
[16:01:47.645] MultisessionFuture:
[16:01:47.645] Label: ‘future_by-2’
[16:01:47.645] Expression:
[16:01:47.645] {
[16:01:47.645]     do.call(function(...) {
[16:01:47.645]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.645]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.645]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.645]             on.exit(options(oopts), add = TRUE)
[16:01:47.645]         }
[16:01:47.645]         {
[16:01:47.645]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.645]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.645]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.645]             })
[16:01:47.645]         }
[16:01:47.645]     }, args = future.call.arguments)
[16:01:47.645] }
[16:01:47.645] Lazy evaluation: FALSE
[16:01:47.645] Asynchronous evaluation: TRUE
[16:01:47.645] Local evaluation: TRUE
[16:01:47.645] Environment: R_GlobalEnv
[16:01:47.645] Capture standard output: TRUE
[16:01:47.645] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:47.645] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:47.645] Packages: <none>
[16:01:47.645] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:47.645] Resolved: FALSE
[16:01:47.645] Value: <not collected>
[16:01:47.645] Conditions captured: <none>
[16:01:47.645] Early signaling: FALSE
[16:01:47.645] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:47.645] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.656] Chunk #2 of 2 ... DONE
[16:01:47.657] Launching 2 futures (chunks) ... DONE
[16:01:47.657] Resolving 2 futures (chunks) ...
[16:01:47.657] resolve() on list ...
[16:01:47.657]  recursive: 0
[16:01:47.657]  length: 2
[16:01:47.657] 
[16:01:47.658] receiveMessageFromWorker() for ClusterFuture ...
[16:01:47.658] - Validating connection of MultisessionFuture
[16:01:47.658] - received message: FutureResult
[16:01:47.658] - Received FutureResult
[16:01:47.658] - Erased future from FutureRegistry
[16:01:47.658] result() for ClusterFuture ...
[16:01:47.659] - result already collected: FutureResult
[16:01:47.659] result() for ClusterFuture ... done
[16:01:47.659] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:47.659] Future #1
[16:01:47.659] result() for ClusterFuture ...
[16:01:47.659] - result already collected: FutureResult
[16:01:47.659] result() for ClusterFuture ... done
[16:01:47.659] result() for ClusterFuture ...
[16:01:47.659] - result already collected: FutureResult
[16:01:47.659] result() for ClusterFuture ... done
[16:01:47.660] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:47.660] - nx: 2
[16:01:47.660] - relay: TRUE
[16:01:47.660] - stdout: TRUE
[16:01:47.660] - signal: TRUE
[16:01:47.660] - resignal: FALSE
[16:01:47.660] - force: TRUE
[16:01:47.662] - relayed: [n=2] FALSE, FALSE
[16:01:47.663] - queued futures: [n=2] FALSE, FALSE
[16:01:47.663]  - until=1
[16:01:47.663]  - relaying element #1
[16:01:47.663] result() for ClusterFuture ...
[16:01:47.663] - result already collected: FutureResult
[16:01:47.663] result() for ClusterFuture ... done
[16:01:47.663] result() for ClusterFuture ...
[16:01:47.663] - result already collected: FutureResult
[16:01:47.663] result() for ClusterFuture ... done
[16:01:47.663] result() for ClusterFuture ...
[16:01:47.663] - result already collected: FutureResult
[16:01:47.664] result() for ClusterFuture ... done
[16:01:47.664] result() for ClusterFuture ...
[16:01:47.664] - result already collected: FutureResult
[16:01:47.664] result() for ClusterFuture ... done
[16:01:47.664] - relayed: [n=2] TRUE, FALSE
[16:01:47.664] - queued futures: [n=2] TRUE, FALSE
[16:01:47.664] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:47.664]  length: 1 (resolved future 1)
[16:01:47.747] receiveMessageFromWorker() for ClusterFuture ...
[16:01:47.747] - Validating connection of MultisessionFuture
[16:01:47.748] - received message: FutureResult
[16:01:47.748] - Received FutureResult
[16:01:47.748] - Erased future from FutureRegistry
[16:01:47.748] result() for ClusterFuture ...
[16:01:47.748] - result already collected: FutureResult
[16:01:47.748] result() for ClusterFuture ... done
[16:01:47.748] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:47.748] Future #2
[16:01:47.748] result() for ClusterFuture ...
[16:01:47.749] - result already collected: FutureResult
[16:01:47.749] result() for ClusterFuture ... done
[16:01:47.749] result() for ClusterFuture ...
[16:01:47.749] - result already collected: FutureResult
[16:01:47.749] result() for ClusterFuture ... done
[16:01:47.749] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:47.749] - nx: 2
[16:01:47.749] - relay: TRUE
[16:01:47.749] - stdout: TRUE
[16:01:47.749] - signal: TRUE
[16:01:47.749] - resignal: FALSE
[16:01:47.750] - force: TRUE
[16:01:47.750] - relayed: [n=2] TRUE, FALSE
[16:01:47.750] - queued futures: [n=2] TRUE, FALSE
[16:01:47.750]  - until=2
[16:01:47.750]  - relaying element #2
[16:01:47.750] result() for ClusterFuture ...
[16:01:47.750] - result already collected: FutureResult
[16:01:47.750] result() for ClusterFuture ... done
[16:01:47.750] result() for ClusterFuture ...
[16:01:47.750] - result already collected: FutureResult
[16:01:47.750] result() for ClusterFuture ... done
[16:01:47.751] result() for ClusterFuture ...
[16:01:47.751] - result already collected: FutureResult
[16:01:47.751] result() for ClusterFuture ... done
[16:01:47.751] result() for ClusterFuture ...
[16:01:47.751] - result already collected: FutureResult
[16:01:47.751] result() for ClusterFuture ... done
[16:01:47.751] - relayed: [n=2] TRUE, TRUE
[16:01:47.751] - queued futures: [n=2] TRUE, TRUE
[16:01:47.751] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:47.751]  length: 0 (resolved future 2)
[16:01:47.751] Relaying remaining futures
[16:01:47.752] signalConditionsASAP(NULL, pos=0) ...
[16:01:47.752] - nx: 2
[16:01:47.752] - relay: TRUE
[16:01:47.752] - stdout: TRUE
[16:01:47.752] - signal: TRUE
[16:01:47.752] - resignal: FALSE
[16:01:47.752] - force: TRUE
[16:01:47.752] - relayed: [n=2] TRUE, TRUE
[16:01:47.752] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:47.752] - relayed: [n=2] TRUE, TRUE
[16:01:47.752] - queued futures: [n=2] TRUE, TRUE
[16:01:47.752] signalConditionsASAP(NULL, pos=0) ... done
[16:01:47.753] resolve() on list ... DONE
[16:01:47.753] result() for ClusterFuture ...
[16:01:47.753] - result already collected: FutureResult
[16:01:47.753] result() for ClusterFuture ... done
[16:01:47.753] result() for ClusterFuture ...
[16:01:47.753] - result already collected: FutureResult
[16:01:47.753] result() for ClusterFuture ... done
[16:01:47.753] result() for ClusterFuture ...
[16:01:47.753] - result already collected: FutureResult
[16:01:47.753] result() for ClusterFuture ... done
[16:01:47.753] result() for ClusterFuture ...
[16:01:47.753] - result already collected: FutureResult
[16:01:47.754] result() for ClusterFuture ... done
[16:01:47.754]  - Number of value chunks collected: 2
[16:01:47.754] Resolving 2 futures (chunks) ... DONE
[16:01:47.754] Reducing values from 2 chunks ...
[16:01:47.754]  - Number of values collected after concatenation: 3
[16:01:47.754]  - Number of values expected: 3
[16:01:47.754] Reducing values from 2 chunks ... DONE
[16:01:47.754] future_lapply() ... DONE
[16:01:47.754] future_by_internal() ... DONE
[16:01:47.755] future_by_internal() ...
[16:01:47.755] future_lapply() ...
[16:01:47.759] Number of chunks: 2
[16:01:47.759] getGlobalsAndPackagesXApply() ...
[16:01:47.759]  - future.globals: TRUE
[16:01:47.759] getGlobalsAndPackages() ...
[16:01:47.759] Searching for globals...
[16:01:47.760] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:47.761] Searching for globals ... DONE
[16:01:47.761] Resolving globals: FALSE
[16:01:47.761] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:47.761] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:47.761] - globals: [1] ‘FUN’
[16:01:47.762] 
[16:01:47.762] getGlobalsAndPackages() ... DONE
[16:01:47.762]  - globals found/used: [n=1] ‘FUN’
[16:01:47.762]  - needed namespaces: [n=0] 
[16:01:47.762] Finding globals ... DONE
[16:01:47.762]  - use_args: TRUE
[16:01:47.762]  - Getting '...' globals ...
[16:01:47.762] resolve() on list ...
[16:01:47.763]  recursive: 0
[16:01:47.763]  length: 1
[16:01:47.763]  elements: ‘...’
[16:01:47.763]  length: 0 (resolved future 1)
[16:01:47.763] resolve() on list ... DONE
[16:01:47.763]    - '...' content: [n=1] ‘digits’
[16:01:47.763] List of 1
[16:01:47.763]  $ ...:List of 1
[16:01:47.763]   ..$ digits: int 2
[16:01:47.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:47.763]  - attr(*, "where")=List of 1
[16:01:47.763]   ..$ ...:<environment: 0x55b527bcba40> 
[16:01:47.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:47.763]  - attr(*, "resolved")= logi TRUE
[16:01:47.763]  - attr(*, "total_size")= num NA
[16:01:47.766]  - Getting '...' globals ... DONE
[16:01:47.766] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:47.766] List of 2
[16:01:47.766]  $ ...future.FUN:function (object, ...)  
[16:01:47.766]  $ ...          :List of 1
[16:01:47.766]   ..$ digits: int 2
[16:01:47.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:47.766]  - attr(*, "where")=List of 2
[16:01:47.766]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:47.766]   ..$ ...          :<environment: 0x55b527bcba40> 
[16:01:47.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:47.766]  - attr(*, "resolved")= logi FALSE
[16:01:47.766]  - attr(*, "total_size")= num 1296
[16:01:47.769] Packages to be attached in all futures: [n=0] 
[16:01:47.769] getGlobalsAndPackagesXApply() ... DONE
[16:01:47.769] Number of futures (= number of chunks): 2
[16:01:47.770] Launching 2 futures (chunks) ...
[16:01:47.770] Chunk #1 of 2 ...
[16:01:47.770]  - Finding globals in 'X' for chunk #1 ...
[16:01:47.770] getGlobalsAndPackages() ...
[16:01:47.770] Searching for globals...
[16:01:47.770] 
[16:01:47.770] Searching for globals ... DONE
[16:01:47.770] - globals: [0] <none>
[16:01:47.770] getGlobalsAndPackages() ... DONE
[16:01:47.771]    + additional globals found: [n=0] 
[16:01:47.771]    + additional namespaces needed: [n=0] 
[16:01:47.771]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:47.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:47.771]  - seeds: <none>
[16:01:47.771]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.771] getGlobalsAndPackages() ...
[16:01:47.771] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.771] Resolving globals: FALSE
[16:01:47.771] Tweak future expression to call with '...' arguments ...
[16:01:47.772] {
[16:01:47.772]     do.call(function(...) {
[16:01:47.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.772]             on.exit(options(oopts), add = TRUE)
[16:01:47.772]         }
[16:01:47.772]         {
[16:01:47.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.772]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.772]             })
[16:01:47.772]         }
[16:01:47.772]     }, args = future.call.arguments)
[16:01:47.772] }
[16:01:47.772] Tweak future expression to call with '...' arguments ... DONE
[16:01:47.772] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.772] 
[16:01:47.772] getGlobalsAndPackages() ... DONE
[16:01:47.773] run() for ‘Future’ ...
[16:01:47.773] - state: ‘created’
[16:01:47.773] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:47.786] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:47.786]   - Field: ‘node’
[16:01:47.787]   - Field: ‘label’
[16:01:47.787]   - Field: ‘local’
[16:01:47.787]   - Field: ‘owner’
[16:01:47.787]   - Field: ‘envir’
[16:01:47.787]   - Field: ‘workers’
[16:01:47.787]   - Field: ‘packages’
[16:01:47.787]   - Field: ‘gc’
[16:01:47.787]   - Field: ‘conditions’
[16:01:47.787]   - Field: ‘persistent’
[16:01:47.787]   - Field: ‘expr’
[16:01:47.788]   - Field: ‘uuid’
[16:01:47.788]   - Field: ‘seed’
[16:01:47.788]   - Field: ‘version’
[16:01:47.788]   - Field: ‘result’
[16:01:47.788]   - Field: ‘asynchronous’
[16:01:47.788]   - Field: ‘calls’
[16:01:47.788]   - Field: ‘globals’
[16:01:47.788]   - Field: ‘stdout’
[16:01:47.788]   - Field: ‘earlySignal’
[16:01:47.788]   - Field: ‘lazy’
[16:01:47.788]   - Field: ‘state’
[16:01:47.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:47.789] - Launch lazy future ...
[16:01:47.789] Packages needed by the future expression (n = 0): <none>
[16:01:47.789] Packages needed by future strategies (n = 0): <none>
[16:01:47.789] {
[16:01:47.789]     {
[16:01:47.789]         {
[16:01:47.789]             ...future.startTime <- base::Sys.time()
[16:01:47.789]             {
[16:01:47.789]                 {
[16:01:47.789]                   {
[16:01:47.789]                     {
[16:01:47.789]                       base::local({
[16:01:47.789]                         has_future <- base::requireNamespace("future", 
[16:01:47.789]                           quietly = TRUE)
[16:01:47.789]                         if (has_future) {
[16:01:47.789]                           ns <- base::getNamespace("future")
[16:01:47.789]                           version <- ns[[".package"]][["version"]]
[16:01:47.789]                           if (is.null(version)) 
[16:01:47.789]                             version <- utils::packageVersion("future")
[16:01:47.789]                         }
[16:01:47.789]                         else {
[16:01:47.789]                           version <- NULL
[16:01:47.789]                         }
[16:01:47.789]                         if (!has_future || version < "1.8.0") {
[16:01:47.789]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.789]                             "", base::R.version$version.string), 
[16:01:47.789]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:47.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:47.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.789]                               "release", "version")], collapse = " "), 
[16:01:47.789]                             hostname = base::Sys.info()[["nodename"]])
[16:01:47.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.789]                             info)
[16:01:47.789]                           info <- base::paste(info, collapse = "; ")
[16:01:47.789]                           if (!has_future) {
[16:01:47.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.789]                               info)
[16:01:47.789]                           }
[16:01:47.789]                           else {
[16:01:47.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.789]                               info, version)
[16:01:47.789]                           }
[16:01:47.789]                           base::stop(msg)
[16:01:47.789]                         }
[16:01:47.789]                       })
[16:01:47.789]                     }
[16:01:47.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.789]                     base::options(mc.cores = 1L)
[16:01:47.789]                   }
[16:01:47.789]                   options(future.plan = NULL)
[16:01:47.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.789]                 }
[16:01:47.789]                 ...future.workdir <- getwd()
[16:01:47.789]             }
[16:01:47.789]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.789]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.789]         }
[16:01:47.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.789]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:47.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.789]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.789]             base::names(...future.oldOptions))
[16:01:47.789]     }
[16:01:47.789]     if (FALSE) {
[16:01:47.789]     }
[16:01:47.789]     else {
[16:01:47.789]         if (TRUE) {
[16:01:47.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.789]                 open = "w")
[16:01:47.789]         }
[16:01:47.789]         else {
[16:01:47.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.789]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.789]         }
[16:01:47.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.789]             base::sink(type = "output", split = FALSE)
[16:01:47.789]             base::close(...future.stdout)
[16:01:47.789]         }, add = TRUE)
[16:01:47.789]     }
[16:01:47.789]     ...future.frame <- base::sys.nframe()
[16:01:47.789]     ...future.conditions <- base::list()
[16:01:47.789]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.789]     if (FALSE) {
[16:01:47.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.789]     }
[16:01:47.789]     ...future.result <- base::tryCatch({
[16:01:47.789]         base::withCallingHandlers({
[16:01:47.789]             ...future.value <- base::withVisible(base::local({
[16:01:47.789]                 ...future.makeSendCondition <- base::local({
[16:01:47.789]                   sendCondition <- NULL
[16:01:47.789]                   function(frame = 1L) {
[16:01:47.789]                     if (is.function(sendCondition)) 
[16:01:47.789]                       return(sendCondition)
[16:01:47.789]                     ns <- getNamespace("parallel")
[16:01:47.789]                     if (exists("sendData", mode = "function", 
[16:01:47.789]                       envir = ns)) {
[16:01:47.789]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.789]                         envir = ns)
[16:01:47.789]                       envir <- sys.frame(frame)
[16:01:47.789]                       master <- NULL
[16:01:47.789]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.789]                         !identical(envir, emptyenv())) {
[16:01:47.789]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.789]                           inherits = FALSE)) {
[16:01:47.789]                           master <- get("master", mode = "list", 
[16:01:47.789]                             envir = envir, inherits = FALSE)
[16:01:47.789]                           if (inherits(master, c("SOCKnode", 
[16:01:47.789]                             "SOCK0node"))) {
[16:01:47.789]                             sendCondition <<- function(cond) {
[16:01:47.789]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.789]                                 success = TRUE)
[16:01:47.789]                               parallel_sendData(master, data)
[16:01:47.789]                             }
[16:01:47.789]                             return(sendCondition)
[16:01:47.789]                           }
[16:01:47.789]                         }
[16:01:47.789]                         frame <- frame + 1L
[16:01:47.789]                         envir <- sys.frame(frame)
[16:01:47.789]                       }
[16:01:47.789]                     }
[16:01:47.789]                     sendCondition <<- function(cond) NULL
[16:01:47.789]                   }
[16:01:47.789]                 })
[16:01:47.789]                 withCallingHandlers({
[16:01:47.789]                   {
[16:01:47.789]                     do.call(function(...) {
[16:01:47.789]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.789]                       if (!identical(...future.globals.maxSize.org, 
[16:01:47.789]                         ...future.globals.maxSize)) {
[16:01:47.789]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.789]                         on.exit(options(oopts), add = TRUE)
[16:01:47.789]                       }
[16:01:47.789]                       {
[16:01:47.789]                         lapply(seq_along(...future.elements_ii), 
[16:01:47.789]                           FUN = function(jj) {
[16:01:47.789]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.789]                             ...future.FUN(...future.X_jj, ...)
[16:01:47.789]                           })
[16:01:47.789]                       }
[16:01:47.789]                     }, args = future.call.arguments)
[16:01:47.789]                   }
[16:01:47.789]                 }, immediateCondition = function(cond) {
[16:01:47.789]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.789]                   sendCondition(cond)
[16:01:47.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.789]                   {
[16:01:47.789]                     inherits <- base::inherits
[16:01:47.789]                     invokeRestart <- base::invokeRestart
[16:01:47.789]                     is.null <- base::is.null
[16:01:47.789]                     muffled <- FALSE
[16:01:47.789]                     if (inherits(cond, "message")) {
[16:01:47.789]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.789]                       if (muffled) 
[16:01:47.789]                         invokeRestart("muffleMessage")
[16:01:47.789]                     }
[16:01:47.789]                     else if (inherits(cond, "warning")) {
[16:01:47.789]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.789]                       if (muffled) 
[16:01:47.789]                         invokeRestart("muffleWarning")
[16:01:47.789]                     }
[16:01:47.789]                     else if (inherits(cond, "condition")) {
[16:01:47.789]                       if (!is.null(pattern)) {
[16:01:47.789]                         computeRestarts <- base::computeRestarts
[16:01:47.789]                         grepl <- base::grepl
[16:01:47.789]                         restarts <- computeRestarts(cond)
[16:01:47.789]                         for (restart in restarts) {
[16:01:47.789]                           name <- restart$name
[16:01:47.789]                           if (is.null(name)) 
[16:01:47.789]                             next
[16:01:47.789]                           if (!grepl(pattern, name)) 
[16:01:47.789]                             next
[16:01:47.789]                           invokeRestart(restart)
[16:01:47.789]                           muffled <- TRUE
[16:01:47.789]                           break
[16:01:47.789]                         }
[16:01:47.789]                       }
[16:01:47.789]                     }
[16:01:47.789]                     invisible(muffled)
[16:01:47.789]                   }
[16:01:47.789]                   muffleCondition(cond)
[16:01:47.789]                 })
[16:01:47.789]             }))
[16:01:47.789]             future::FutureResult(value = ...future.value$value, 
[16:01:47.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.789]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.789]                     ...future.globalenv.names))
[16:01:47.789]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.789]         }, condition = base::local({
[16:01:47.789]             c <- base::c
[16:01:47.789]             inherits <- base::inherits
[16:01:47.789]             invokeRestart <- base::invokeRestart
[16:01:47.789]             length <- base::length
[16:01:47.789]             list <- base::list
[16:01:47.789]             seq.int <- base::seq.int
[16:01:47.789]             signalCondition <- base::signalCondition
[16:01:47.789]             sys.calls <- base::sys.calls
[16:01:47.789]             `[[` <- base::`[[`
[16:01:47.789]             `+` <- base::`+`
[16:01:47.789]             `<<-` <- base::`<<-`
[16:01:47.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.789]                   3L)]
[16:01:47.789]             }
[16:01:47.789]             function(cond) {
[16:01:47.789]                 is_error <- inherits(cond, "error")
[16:01:47.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.789]                   NULL)
[16:01:47.789]                 if (is_error) {
[16:01:47.789]                   sessionInformation <- function() {
[16:01:47.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.789]                       search = base::search(), system = base::Sys.info())
[16:01:47.789]                   }
[16:01:47.789]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.789]                     cond$call), session = sessionInformation(), 
[16:01:47.789]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.789]                   signalCondition(cond)
[16:01:47.789]                 }
[16:01:47.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.789]                 "immediateCondition"))) {
[16:01:47.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.789]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.789]                   if (TRUE && !signal) {
[16:01:47.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.789]                     {
[16:01:47.789]                       inherits <- base::inherits
[16:01:47.789]                       invokeRestart <- base::invokeRestart
[16:01:47.789]                       is.null <- base::is.null
[16:01:47.789]                       muffled <- FALSE
[16:01:47.789]                       if (inherits(cond, "message")) {
[16:01:47.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.789]                         if (muffled) 
[16:01:47.789]                           invokeRestart("muffleMessage")
[16:01:47.789]                       }
[16:01:47.789]                       else if (inherits(cond, "warning")) {
[16:01:47.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.789]                         if (muffled) 
[16:01:47.789]                           invokeRestart("muffleWarning")
[16:01:47.789]                       }
[16:01:47.789]                       else if (inherits(cond, "condition")) {
[16:01:47.789]                         if (!is.null(pattern)) {
[16:01:47.789]                           computeRestarts <- base::computeRestarts
[16:01:47.789]                           grepl <- base::grepl
[16:01:47.789]                           restarts <- computeRestarts(cond)
[16:01:47.789]                           for (restart in restarts) {
[16:01:47.789]                             name <- restart$name
[16:01:47.789]                             if (is.null(name)) 
[16:01:47.789]                               next
[16:01:47.789]                             if (!grepl(pattern, name)) 
[16:01:47.789]                               next
[16:01:47.789]                             invokeRestart(restart)
[16:01:47.789]                             muffled <- TRUE
[16:01:47.789]                             break
[16:01:47.789]                           }
[16:01:47.789]                         }
[16:01:47.789]                       }
[16:01:47.789]                       invisible(muffled)
[16:01:47.789]                     }
[16:01:47.789]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.789]                   }
[16:01:47.789]                 }
[16:01:47.789]                 else {
[16:01:47.789]                   if (TRUE) {
[16:01:47.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.789]                     {
[16:01:47.789]                       inherits <- base::inherits
[16:01:47.789]                       invokeRestart <- base::invokeRestart
[16:01:47.789]                       is.null <- base::is.null
[16:01:47.789]                       muffled <- FALSE
[16:01:47.789]                       if (inherits(cond, "message")) {
[16:01:47.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.789]                         if (muffled) 
[16:01:47.789]                           invokeRestart("muffleMessage")
[16:01:47.789]                       }
[16:01:47.789]                       else if (inherits(cond, "warning")) {
[16:01:47.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.789]                         if (muffled) 
[16:01:47.789]                           invokeRestart("muffleWarning")
[16:01:47.789]                       }
[16:01:47.789]                       else if (inherits(cond, "condition")) {
[16:01:47.789]                         if (!is.null(pattern)) {
[16:01:47.789]                           computeRestarts <- base::computeRestarts
[16:01:47.789]                           grepl <- base::grepl
[16:01:47.789]                           restarts <- computeRestarts(cond)
[16:01:47.789]                           for (restart in restarts) {
[16:01:47.789]                             name <- restart$name
[16:01:47.789]                             if (is.null(name)) 
[16:01:47.789]                               next
[16:01:47.789]                             if (!grepl(pattern, name)) 
[16:01:47.789]                               next
[16:01:47.789]                             invokeRestart(restart)
[16:01:47.789]                             muffled <- TRUE
[16:01:47.789]                             break
[16:01:47.789]                           }
[16:01:47.789]                         }
[16:01:47.789]                       }
[16:01:47.789]                       invisible(muffled)
[16:01:47.789]                     }
[16:01:47.789]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.789]                   }
[16:01:47.789]                 }
[16:01:47.789]             }
[16:01:47.789]         }))
[16:01:47.789]     }, error = function(ex) {
[16:01:47.789]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.789]                 ...future.rng), started = ...future.startTime, 
[16:01:47.789]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.789]             version = "1.8"), class = "FutureResult")
[16:01:47.789]     }, finally = {
[16:01:47.789]         if (!identical(...future.workdir, getwd())) 
[16:01:47.789]             setwd(...future.workdir)
[16:01:47.789]         {
[16:01:47.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.789]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.789]             }
[16:01:47.789]             base::options(...future.oldOptions)
[16:01:47.789]             if (.Platform$OS.type == "windows") {
[16:01:47.789]                 old_names <- names(...future.oldEnvVars)
[16:01:47.789]                 envs <- base::Sys.getenv()
[16:01:47.789]                 names <- names(envs)
[16:01:47.789]                 common <- intersect(names, old_names)
[16:01:47.789]                 added <- setdiff(names, old_names)
[16:01:47.789]                 removed <- setdiff(old_names, names)
[16:01:47.789]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.789]                   envs[common]]
[16:01:47.789]                 NAMES <- toupper(changed)
[16:01:47.789]                 args <- list()
[16:01:47.789]                 for (kk in seq_along(NAMES)) {
[16:01:47.789]                   name <- changed[[kk]]
[16:01:47.789]                   NAME <- NAMES[[kk]]
[16:01:47.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.789]                     next
[16:01:47.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.789]                 }
[16:01:47.789]                 NAMES <- toupper(added)
[16:01:47.789]                 for (kk in seq_along(NAMES)) {
[16:01:47.789]                   name <- added[[kk]]
[16:01:47.789]                   NAME <- NAMES[[kk]]
[16:01:47.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.789]                     next
[16:01:47.789]                   args[[name]] <- ""
[16:01:47.789]                 }
[16:01:47.789]                 NAMES <- toupper(removed)
[16:01:47.789]                 for (kk in seq_along(NAMES)) {
[16:01:47.789]                   name <- removed[[kk]]
[16:01:47.789]                   NAME <- NAMES[[kk]]
[16:01:47.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.789]                     next
[16:01:47.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.789]                 }
[16:01:47.789]                 if (length(args) > 0) 
[16:01:47.789]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.789]             }
[16:01:47.789]             else {
[16:01:47.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.789]             }
[16:01:47.789]             {
[16:01:47.789]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.789]                   0L) {
[16:01:47.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.789]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.789]                   base::options(opts)
[16:01:47.789]                 }
[16:01:47.789]                 {
[16:01:47.789]                   {
[16:01:47.789]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.789]                     NULL
[16:01:47.789]                   }
[16:01:47.789]                   options(future.plan = NULL)
[16:01:47.789]                   if (is.na(NA_character_)) 
[16:01:47.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.789]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.789]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.789]                     envir = parent.frame()) 
[16:01:47.789]                   {
[16:01:47.789]                     if (is.function(workers)) 
[16:01:47.789]                       workers <- workers()
[16:01:47.789]                     workers <- structure(as.integer(workers), 
[16:01:47.789]                       class = class(workers))
[16:01:47.789]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.789]                       workers >= 1)
[16:01:47.789]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.789]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.789]                     }
[16:01:47.789]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.789]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.789]                       envir = envir)
[16:01:47.789]                     if (!future$lazy) 
[16:01:47.789]                       future <- run(future)
[16:01:47.789]                     invisible(future)
[16:01:47.789]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.789]                 }
[16:01:47.789]             }
[16:01:47.789]         }
[16:01:47.789]     })
[16:01:47.789]     if (TRUE) {
[16:01:47.789]         base::sink(type = "output", split = FALSE)
[16:01:47.789]         if (TRUE) {
[16:01:47.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.789]         }
[16:01:47.789]         else {
[16:01:47.789]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.789]         }
[16:01:47.789]         base::close(...future.stdout)
[16:01:47.789]         ...future.stdout <- NULL
[16:01:47.789]     }
[16:01:47.789]     ...future.result$conditions <- ...future.conditions
[16:01:47.789]     ...future.result$finished <- base::Sys.time()
[16:01:47.789]     ...future.result
[16:01:47.789] }
[16:01:47.792] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[16:01:47.792] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:01:47.793] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:01:47.793] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:01:47.793] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:01:47.793] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[16:01:47.794] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[16:01:47.794] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:47.794] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.794] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:47.795] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.795] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[16:01:47.795] MultisessionFuture started
[16:01:47.795] - Launch lazy future ... done
[16:01:47.795] run() for ‘MultisessionFuture’ ... done
[16:01:47.796] Created future:
[16:01:47.796] MultisessionFuture:
[16:01:47.796] Label: ‘future_by-1’
[16:01:47.796] Expression:
[16:01:47.796] {
[16:01:47.796]     do.call(function(...) {
[16:01:47.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.796]             on.exit(options(oopts), add = TRUE)
[16:01:47.796]         }
[16:01:47.796]         {
[16:01:47.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.796]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.796]             })
[16:01:47.796]         }
[16:01:47.796]     }, args = future.call.arguments)
[16:01:47.796] }
[16:01:47.796] Lazy evaluation: FALSE
[16:01:47.796] Asynchronous evaluation: TRUE
[16:01:47.796] Local evaluation: TRUE
[16:01:47.796] Environment: R_GlobalEnv
[16:01:47.796] Capture standard output: TRUE
[16:01:47.796] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:47.796] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:47.796] Packages: <none>
[16:01:47.796] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:47.796] Resolved: FALSE
[16:01:47.796] Value: <not collected>
[16:01:47.796] Conditions captured: <none>
[16:01:47.796] Early signaling: FALSE
[16:01:47.796] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:47.796] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.807] Chunk #1 of 2 ... DONE
[16:01:47.807] Chunk #2 of 2 ...
[16:01:47.807]  - Finding globals in 'X' for chunk #2 ...
[16:01:47.808] getGlobalsAndPackages() ...
[16:01:47.808] Searching for globals...
[16:01:47.808] 
[16:01:47.808] Searching for globals ... DONE
[16:01:47.808] - globals: [0] <none>
[16:01:47.808] getGlobalsAndPackages() ... DONE
[16:01:47.808]    + additional globals found: [n=0] 
[16:01:47.808]    + additional namespaces needed: [n=0] 
[16:01:47.808]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:47.808]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:47.809]  - seeds: <none>
[16:01:47.809]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.809] getGlobalsAndPackages() ...
[16:01:47.809] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.809] Resolving globals: FALSE
[16:01:47.809] Tweak future expression to call with '...' arguments ...
[16:01:47.809] {
[16:01:47.809]     do.call(function(...) {
[16:01:47.809]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.809]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.809]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.809]             on.exit(options(oopts), add = TRUE)
[16:01:47.809]         }
[16:01:47.809]         {
[16:01:47.809]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.809]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.809]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.809]             })
[16:01:47.809]         }
[16:01:47.809]     }, args = future.call.arguments)
[16:01:47.809] }
[16:01:47.809] Tweak future expression to call with '...' arguments ... DONE
[16:01:47.810] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.810] 
[16:01:47.810] getGlobalsAndPackages() ... DONE
[16:01:47.810] run() for ‘Future’ ...
[16:01:47.810] - state: ‘created’
[16:01:47.810] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:47.824] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:47.824]   - Field: ‘node’
[16:01:47.824]   - Field: ‘label’
[16:01:47.824]   - Field: ‘local’
[16:01:47.824]   - Field: ‘owner’
[16:01:47.824]   - Field: ‘envir’
[16:01:47.825]   - Field: ‘workers’
[16:01:47.825]   - Field: ‘packages’
[16:01:47.825]   - Field: ‘gc’
[16:01:47.825]   - Field: ‘conditions’
[16:01:47.825]   - Field: ‘persistent’
[16:01:47.825]   - Field: ‘expr’
[16:01:47.825]   - Field: ‘uuid’
[16:01:47.825]   - Field: ‘seed’
[16:01:47.825]   - Field: ‘version’
[16:01:47.825]   - Field: ‘result’
[16:01:47.825]   - Field: ‘asynchronous’
[16:01:47.826]   - Field: ‘calls’
[16:01:47.826]   - Field: ‘globals’
[16:01:47.826]   - Field: ‘stdout’
[16:01:47.826]   - Field: ‘earlySignal’
[16:01:47.826]   - Field: ‘lazy’
[16:01:47.826]   - Field: ‘state’
[16:01:47.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:47.826] - Launch lazy future ...
[16:01:47.826] Packages needed by the future expression (n = 0): <none>
[16:01:47.827] Packages needed by future strategies (n = 0): <none>
[16:01:47.827] {
[16:01:47.827]     {
[16:01:47.827]         {
[16:01:47.827]             ...future.startTime <- base::Sys.time()
[16:01:47.827]             {
[16:01:47.827]                 {
[16:01:47.827]                   {
[16:01:47.827]                     {
[16:01:47.827]                       base::local({
[16:01:47.827]                         has_future <- base::requireNamespace("future", 
[16:01:47.827]                           quietly = TRUE)
[16:01:47.827]                         if (has_future) {
[16:01:47.827]                           ns <- base::getNamespace("future")
[16:01:47.827]                           version <- ns[[".package"]][["version"]]
[16:01:47.827]                           if (is.null(version)) 
[16:01:47.827]                             version <- utils::packageVersion("future")
[16:01:47.827]                         }
[16:01:47.827]                         else {
[16:01:47.827]                           version <- NULL
[16:01:47.827]                         }
[16:01:47.827]                         if (!has_future || version < "1.8.0") {
[16:01:47.827]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.827]                             "", base::R.version$version.string), 
[16:01:47.827]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:47.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:47.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.827]                               "release", "version")], collapse = " "), 
[16:01:47.827]                             hostname = base::Sys.info()[["nodename"]])
[16:01:47.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.827]                             info)
[16:01:47.827]                           info <- base::paste(info, collapse = "; ")
[16:01:47.827]                           if (!has_future) {
[16:01:47.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.827]                               info)
[16:01:47.827]                           }
[16:01:47.827]                           else {
[16:01:47.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.827]                               info, version)
[16:01:47.827]                           }
[16:01:47.827]                           base::stop(msg)
[16:01:47.827]                         }
[16:01:47.827]                       })
[16:01:47.827]                     }
[16:01:47.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.827]                     base::options(mc.cores = 1L)
[16:01:47.827]                   }
[16:01:47.827]                   options(future.plan = NULL)
[16:01:47.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.827]                 }
[16:01:47.827]                 ...future.workdir <- getwd()
[16:01:47.827]             }
[16:01:47.827]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.827]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.827]         }
[16:01:47.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.827]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:47.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.827]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.827]             base::names(...future.oldOptions))
[16:01:47.827]     }
[16:01:47.827]     if (FALSE) {
[16:01:47.827]     }
[16:01:47.827]     else {
[16:01:47.827]         if (TRUE) {
[16:01:47.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.827]                 open = "w")
[16:01:47.827]         }
[16:01:47.827]         else {
[16:01:47.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.827]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.827]         }
[16:01:47.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.827]             base::sink(type = "output", split = FALSE)
[16:01:47.827]             base::close(...future.stdout)
[16:01:47.827]         }, add = TRUE)
[16:01:47.827]     }
[16:01:47.827]     ...future.frame <- base::sys.nframe()
[16:01:47.827]     ...future.conditions <- base::list()
[16:01:47.827]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.827]     if (FALSE) {
[16:01:47.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.827]     }
[16:01:47.827]     ...future.result <- base::tryCatch({
[16:01:47.827]         base::withCallingHandlers({
[16:01:47.827]             ...future.value <- base::withVisible(base::local({
[16:01:47.827]                 ...future.makeSendCondition <- base::local({
[16:01:47.827]                   sendCondition <- NULL
[16:01:47.827]                   function(frame = 1L) {
[16:01:47.827]                     if (is.function(sendCondition)) 
[16:01:47.827]                       return(sendCondition)
[16:01:47.827]                     ns <- getNamespace("parallel")
[16:01:47.827]                     if (exists("sendData", mode = "function", 
[16:01:47.827]                       envir = ns)) {
[16:01:47.827]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.827]                         envir = ns)
[16:01:47.827]                       envir <- sys.frame(frame)
[16:01:47.827]                       master <- NULL
[16:01:47.827]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.827]                         !identical(envir, emptyenv())) {
[16:01:47.827]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.827]                           inherits = FALSE)) {
[16:01:47.827]                           master <- get("master", mode = "list", 
[16:01:47.827]                             envir = envir, inherits = FALSE)
[16:01:47.827]                           if (inherits(master, c("SOCKnode", 
[16:01:47.827]                             "SOCK0node"))) {
[16:01:47.827]                             sendCondition <<- function(cond) {
[16:01:47.827]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.827]                                 success = TRUE)
[16:01:47.827]                               parallel_sendData(master, data)
[16:01:47.827]                             }
[16:01:47.827]                             return(sendCondition)
[16:01:47.827]                           }
[16:01:47.827]                         }
[16:01:47.827]                         frame <- frame + 1L
[16:01:47.827]                         envir <- sys.frame(frame)
[16:01:47.827]                       }
[16:01:47.827]                     }
[16:01:47.827]                     sendCondition <<- function(cond) NULL
[16:01:47.827]                   }
[16:01:47.827]                 })
[16:01:47.827]                 withCallingHandlers({
[16:01:47.827]                   {
[16:01:47.827]                     do.call(function(...) {
[16:01:47.827]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.827]                       if (!identical(...future.globals.maxSize.org, 
[16:01:47.827]                         ...future.globals.maxSize)) {
[16:01:47.827]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.827]                         on.exit(options(oopts), add = TRUE)
[16:01:47.827]                       }
[16:01:47.827]                       {
[16:01:47.827]                         lapply(seq_along(...future.elements_ii), 
[16:01:47.827]                           FUN = function(jj) {
[16:01:47.827]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.827]                             ...future.FUN(...future.X_jj, ...)
[16:01:47.827]                           })
[16:01:47.827]                       }
[16:01:47.827]                     }, args = future.call.arguments)
[16:01:47.827]                   }
[16:01:47.827]                 }, immediateCondition = function(cond) {
[16:01:47.827]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.827]                   sendCondition(cond)
[16:01:47.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.827]                   {
[16:01:47.827]                     inherits <- base::inherits
[16:01:47.827]                     invokeRestart <- base::invokeRestart
[16:01:47.827]                     is.null <- base::is.null
[16:01:47.827]                     muffled <- FALSE
[16:01:47.827]                     if (inherits(cond, "message")) {
[16:01:47.827]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.827]                       if (muffled) 
[16:01:47.827]                         invokeRestart("muffleMessage")
[16:01:47.827]                     }
[16:01:47.827]                     else if (inherits(cond, "warning")) {
[16:01:47.827]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.827]                       if (muffled) 
[16:01:47.827]                         invokeRestart("muffleWarning")
[16:01:47.827]                     }
[16:01:47.827]                     else if (inherits(cond, "condition")) {
[16:01:47.827]                       if (!is.null(pattern)) {
[16:01:47.827]                         computeRestarts <- base::computeRestarts
[16:01:47.827]                         grepl <- base::grepl
[16:01:47.827]                         restarts <- computeRestarts(cond)
[16:01:47.827]                         for (restart in restarts) {
[16:01:47.827]                           name <- restart$name
[16:01:47.827]                           if (is.null(name)) 
[16:01:47.827]                             next
[16:01:47.827]                           if (!grepl(pattern, name)) 
[16:01:47.827]                             next
[16:01:47.827]                           invokeRestart(restart)
[16:01:47.827]                           muffled <- TRUE
[16:01:47.827]                           break
[16:01:47.827]                         }
[16:01:47.827]                       }
[16:01:47.827]                     }
[16:01:47.827]                     invisible(muffled)
[16:01:47.827]                   }
[16:01:47.827]                   muffleCondition(cond)
[16:01:47.827]                 })
[16:01:47.827]             }))
[16:01:47.827]             future::FutureResult(value = ...future.value$value, 
[16:01:47.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.827]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.827]                     ...future.globalenv.names))
[16:01:47.827]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.827]         }, condition = base::local({
[16:01:47.827]             c <- base::c
[16:01:47.827]             inherits <- base::inherits
[16:01:47.827]             invokeRestart <- base::invokeRestart
[16:01:47.827]             length <- base::length
[16:01:47.827]             list <- base::list
[16:01:47.827]             seq.int <- base::seq.int
[16:01:47.827]             signalCondition <- base::signalCondition
[16:01:47.827]             sys.calls <- base::sys.calls
[16:01:47.827]             `[[` <- base::`[[`
[16:01:47.827]             `+` <- base::`+`
[16:01:47.827]             `<<-` <- base::`<<-`
[16:01:47.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.827]                   3L)]
[16:01:47.827]             }
[16:01:47.827]             function(cond) {
[16:01:47.827]                 is_error <- inherits(cond, "error")
[16:01:47.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.827]                   NULL)
[16:01:47.827]                 if (is_error) {
[16:01:47.827]                   sessionInformation <- function() {
[16:01:47.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.827]                       search = base::search(), system = base::Sys.info())
[16:01:47.827]                   }
[16:01:47.827]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.827]                     cond$call), session = sessionInformation(), 
[16:01:47.827]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.827]                   signalCondition(cond)
[16:01:47.827]                 }
[16:01:47.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.827]                 "immediateCondition"))) {
[16:01:47.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.827]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.827]                   if (TRUE && !signal) {
[16:01:47.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.827]                     {
[16:01:47.827]                       inherits <- base::inherits
[16:01:47.827]                       invokeRestart <- base::invokeRestart
[16:01:47.827]                       is.null <- base::is.null
[16:01:47.827]                       muffled <- FALSE
[16:01:47.827]                       if (inherits(cond, "message")) {
[16:01:47.827]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.827]                         if (muffled) 
[16:01:47.827]                           invokeRestart("muffleMessage")
[16:01:47.827]                       }
[16:01:47.827]                       else if (inherits(cond, "warning")) {
[16:01:47.827]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.827]                         if (muffled) 
[16:01:47.827]                           invokeRestart("muffleWarning")
[16:01:47.827]                       }
[16:01:47.827]                       else if (inherits(cond, "condition")) {
[16:01:47.827]                         if (!is.null(pattern)) {
[16:01:47.827]                           computeRestarts <- base::computeRestarts
[16:01:47.827]                           grepl <- base::grepl
[16:01:47.827]                           restarts <- computeRestarts(cond)
[16:01:47.827]                           for (restart in restarts) {
[16:01:47.827]                             name <- restart$name
[16:01:47.827]                             if (is.null(name)) 
[16:01:47.827]                               next
[16:01:47.827]                             if (!grepl(pattern, name)) 
[16:01:47.827]                               next
[16:01:47.827]                             invokeRestart(restart)
[16:01:47.827]                             muffled <- TRUE
[16:01:47.827]                             break
[16:01:47.827]                           }
[16:01:47.827]                         }
[16:01:47.827]                       }
[16:01:47.827]                       invisible(muffled)
[16:01:47.827]                     }
[16:01:47.827]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.827]                   }
[16:01:47.827]                 }
[16:01:47.827]                 else {
[16:01:47.827]                   if (TRUE) {
[16:01:47.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.827]                     {
[16:01:47.827]                       inherits <- base::inherits
[16:01:47.827]                       invokeRestart <- base::invokeRestart
[16:01:47.827]                       is.null <- base::is.null
[16:01:47.827]                       muffled <- FALSE
[16:01:47.827]                       if (inherits(cond, "message")) {
[16:01:47.827]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.827]                         if (muffled) 
[16:01:47.827]                           invokeRestart("muffleMessage")
[16:01:47.827]                       }
[16:01:47.827]                       else if (inherits(cond, "warning")) {
[16:01:47.827]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.827]                         if (muffled) 
[16:01:47.827]                           invokeRestart("muffleWarning")
[16:01:47.827]                       }
[16:01:47.827]                       else if (inherits(cond, "condition")) {
[16:01:47.827]                         if (!is.null(pattern)) {
[16:01:47.827]                           computeRestarts <- base::computeRestarts
[16:01:47.827]                           grepl <- base::grepl
[16:01:47.827]                           restarts <- computeRestarts(cond)
[16:01:47.827]                           for (restart in restarts) {
[16:01:47.827]                             name <- restart$name
[16:01:47.827]                             if (is.null(name)) 
[16:01:47.827]                               next
[16:01:47.827]                             if (!grepl(pattern, name)) 
[16:01:47.827]                               next
[16:01:47.827]                             invokeRestart(restart)
[16:01:47.827]                             muffled <- TRUE
[16:01:47.827]                             break
[16:01:47.827]                           }
[16:01:47.827]                         }
[16:01:47.827]                       }
[16:01:47.827]                       invisible(muffled)
[16:01:47.827]                     }
[16:01:47.827]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.827]                   }
[16:01:47.827]                 }
[16:01:47.827]             }
[16:01:47.827]         }))
[16:01:47.827]     }, error = function(ex) {
[16:01:47.827]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.827]                 ...future.rng), started = ...future.startTime, 
[16:01:47.827]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.827]             version = "1.8"), class = "FutureResult")
[16:01:47.827]     }, finally = {
[16:01:47.827]         if (!identical(...future.workdir, getwd())) 
[16:01:47.827]             setwd(...future.workdir)
[16:01:47.827]         {
[16:01:47.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.827]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.827]             }
[16:01:47.827]             base::options(...future.oldOptions)
[16:01:47.827]             if (.Platform$OS.type == "windows") {
[16:01:47.827]                 old_names <- names(...future.oldEnvVars)
[16:01:47.827]                 envs <- base::Sys.getenv()
[16:01:47.827]                 names <- names(envs)
[16:01:47.827]                 common <- intersect(names, old_names)
[16:01:47.827]                 added <- setdiff(names, old_names)
[16:01:47.827]                 removed <- setdiff(old_names, names)
[16:01:47.827]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.827]                   envs[common]]
[16:01:47.827]                 NAMES <- toupper(changed)
[16:01:47.827]                 args <- list()
[16:01:47.827]                 for (kk in seq_along(NAMES)) {
[16:01:47.827]                   name <- changed[[kk]]
[16:01:47.827]                   NAME <- NAMES[[kk]]
[16:01:47.827]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.827]                     next
[16:01:47.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.827]                 }
[16:01:47.827]                 NAMES <- toupper(added)
[16:01:47.827]                 for (kk in seq_along(NAMES)) {
[16:01:47.827]                   name <- added[[kk]]
[16:01:47.827]                   NAME <- NAMES[[kk]]
[16:01:47.827]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.827]                     next
[16:01:47.827]                   args[[name]] <- ""
[16:01:47.827]                 }
[16:01:47.827]                 NAMES <- toupper(removed)
[16:01:47.827]                 for (kk in seq_along(NAMES)) {
[16:01:47.827]                   name <- removed[[kk]]
[16:01:47.827]                   NAME <- NAMES[[kk]]
[16:01:47.827]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.827]                     next
[16:01:47.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.827]                 }
[16:01:47.827]                 if (length(args) > 0) 
[16:01:47.827]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.827]             }
[16:01:47.827]             else {
[16:01:47.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.827]             }
[16:01:47.827]             {
[16:01:47.827]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.827]                   0L) {
[16:01:47.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.827]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.827]                   base::options(opts)
[16:01:47.827]                 }
[16:01:47.827]                 {
[16:01:47.827]                   {
[16:01:47.827]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.827]                     NULL
[16:01:47.827]                   }
[16:01:47.827]                   options(future.plan = NULL)
[16:01:47.827]                   if (is.na(NA_character_)) 
[16:01:47.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.827]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.827]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.827]                     envir = parent.frame()) 
[16:01:47.827]                   {
[16:01:47.827]                     if (is.function(workers)) 
[16:01:47.827]                       workers <- workers()
[16:01:47.827]                     workers <- structure(as.integer(workers), 
[16:01:47.827]                       class = class(workers))
[16:01:47.827]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.827]                       workers >= 1)
[16:01:47.827]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.827]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.827]                     }
[16:01:47.827]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.827]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.827]                       envir = envir)
[16:01:47.827]                     if (!future$lazy) 
[16:01:47.827]                       future <- run(future)
[16:01:47.827]                     invisible(future)
[16:01:47.827]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.827]                 }
[16:01:47.827]             }
[16:01:47.827]         }
[16:01:47.827]     })
[16:01:47.827]     if (TRUE) {
[16:01:47.827]         base::sink(type = "output", split = FALSE)
[16:01:47.827]         if (TRUE) {
[16:01:47.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.827]         }
[16:01:47.827]         else {
[16:01:47.827]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.827]         }
[16:01:47.827]         base::close(...future.stdout)
[16:01:47.827]         ...future.stdout <- NULL
[16:01:47.827]     }
[16:01:47.827]     ...future.result$conditions <- ...future.conditions
[16:01:47.827]     ...future.result$finished <- base::Sys.time()
[16:01:47.827]     ...future.result
[16:01:47.827] }
[16:01:47.830] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[16:01:47.830] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:01:47.830] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:01:47.831] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:01:47.831] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:01:47.831] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[16:01:47.831] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[16:01:47.832] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:47.832] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.832] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:47.832] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.833] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[16:01:47.833] MultisessionFuture started
[16:01:47.833] - Launch lazy future ... done
[16:01:47.833] run() for ‘MultisessionFuture’ ... done
[16:01:47.834] Created future:
[16:01:47.834] MultisessionFuture:
[16:01:47.834] Label: ‘future_by-2’
[16:01:47.834] Expression:
[16:01:47.834] {
[16:01:47.834]     do.call(function(...) {
[16:01:47.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.834]             on.exit(options(oopts), add = TRUE)
[16:01:47.834]         }
[16:01:47.834]         {
[16:01:47.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.834]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.834]             })
[16:01:47.834]         }
[16:01:47.834]     }, args = future.call.arguments)
[16:01:47.834] }
[16:01:47.834] Lazy evaluation: FALSE
[16:01:47.834] Asynchronous evaluation: TRUE
[16:01:47.834] Local evaluation: TRUE
[16:01:47.834] Environment: R_GlobalEnv
[16:01:47.834] Capture standard output: TRUE
[16:01:47.834] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:47.834] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:47.834] Packages: <none>
[16:01:47.834] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:47.834] Resolved: FALSE
[16:01:47.834] Value: <not collected>
[16:01:47.834] Conditions captured: <none>
[16:01:47.834] Early signaling: FALSE
[16:01:47.834] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:47.834] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.845] Chunk #2 of 2 ... DONE
[16:01:47.845] Launching 2 futures (chunks) ... DONE
[16:01:47.845] Resolving 2 futures (chunks) ...
[16:01:47.846] resolve() on list ...
[16:01:47.846]  recursive: 0
[16:01:47.846]  length: 2
[16:01:47.846] 
[16:01:47.846] receiveMessageFromWorker() for ClusterFuture ...
[16:01:47.846] - Validating connection of MultisessionFuture
[16:01:47.847] - received message: FutureResult
[16:01:47.847] - Received FutureResult
[16:01:47.847] - Erased future from FutureRegistry
[16:01:47.847] result() for ClusterFuture ...
[16:01:47.847] - result already collected: FutureResult
[16:01:47.847] result() for ClusterFuture ... done
[16:01:47.847] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:47.847] Future #1
[16:01:47.847] result() for ClusterFuture ...
[16:01:47.847] - result already collected: FutureResult
[16:01:47.848] result() for ClusterFuture ... done
[16:01:47.848] result() for ClusterFuture ...
[16:01:47.848] - result already collected: FutureResult
[16:01:47.848] result() for ClusterFuture ... done
[16:01:47.848] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:47.848] - nx: 2
[16:01:47.848] - relay: TRUE
[16:01:47.848] - stdout: TRUE
[16:01:47.848] - signal: TRUE
[16:01:47.848] - resignal: FALSE
[16:01:47.848] - force: TRUE
[16:01:47.848] - relayed: [n=2] FALSE, FALSE
[16:01:47.849] - queued futures: [n=2] FALSE, FALSE
[16:01:47.849]  - until=1
[16:01:47.849]  - relaying element #1
[16:01:47.849] result() for ClusterFuture ...
[16:01:47.849] - result already collected: FutureResult
[16:01:47.849] result() for ClusterFuture ... done
[16:01:47.849] result() for ClusterFuture ...
[16:01:47.849] - result already collected: FutureResult
[16:01:47.849] result() for ClusterFuture ... done
[16:01:47.849] result() for ClusterFuture ...
[16:01:47.849] - result already collected: FutureResult
[16:01:47.850] result() for ClusterFuture ... done
[16:01:47.850] result() for ClusterFuture ...
[16:01:47.850] - result already collected: FutureResult
[16:01:47.850] result() for ClusterFuture ... done
[16:01:47.850] - relayed: [n=2] TRUE, FALSE
[16:01:47.850] - queued futures: [n=2] TRUE, FALSE
[16:01:47.850] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:47.850]  length: 1 (resolved future 1)
[16:01:47.880] receiveMessageFromWorker() for ClusterFuture ...
[16:01:47.880] - Validating connection of MultisessionFuture
[16:01:47.881] - received message: FutureResult
[16:01:47.881] - Received FutureResult
[16:01:47.881] - Erased future from FutureRegistry
[16:01:47.881] result() for ClusterFuture ...
[16:01:47.881] - result already collected: FutureResult
[16:01:47.881] result() for ClusterFuture ... done
[16:01:47.881] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:47.882] Future #2
[16:01:47.882] result() for ClusterFuture ...
[16:01:47.882] - result already collected: FutureResult
[16:01:47.882] result() for ClusterFuture ... done
[16:01:47.882] result() for ClusterFuture ...
[16:01:47.882] - result already collected: FutureResult
[16:01:47.882] result() for ClusterFuture ... done
[16:01:47.882] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:47.882] - nx: 2
[16:01:47.883] - relay: TRUE
[16:01:47.883] - stdout: TRUE
[16:01:47.883] - signal: TRUE
[16:01:47.883] - resignal: FALSE
[16:01:47.883] - force: TRUE
[16:01:47.883] - relayed: [n=2] TRUE, FALSE
[16:01:47.883] - queued futures: [n=2] TRUE, FALSE
[16:01:47.883]  - until=2
[16:01:47.883]  - relaying element #2
[16:01:47.883] result() for ClusterFuture ...
[16:01:47.884] - result already collected: FutureResult
[16:01:47.884] result() for ClusterFuture ... done
[16:01:47.884] result() for ClusterFuture ...
[16:01:47.884] - result already collected: FutureResult
[16:01:47.884] result() for ClusterFuture ... done
[16:01:47.884] result() for ClusterFuture ...
[16:01:47.884] - result already collected: FutureResult
[16:01:47.884] result() for ClusterFuture ... done
[16:01:47.884] result() for ClusterFuture ...
[16:01:47.884] - result already collected: FutureResult
[16:01:47.884] result() for ClusterFuture ... done
[16:01:47.885] - relayed: [n=2] TRUE, TRUE
[16:01:47.885] - queued futures: [n=2] TRUE, TRUE
[16:01:47.885] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:47.885]  length: 0 (resolved future 2)
[16:01:47.885] Relaying remaining futures
[16:01:47.885] signalConditionsASAP(NULL, pos=0) ...
[16:01:47.885] - nx: 2
[16:01:47.885] - relay: TRUE
[16:01:47.885] - stdout: TRUE
[16:01:47.885] - signal: TRUE
[16:01:47.885] - resignal: FALSE
[16:01:47.886] - force: TRUE
[16:01:47.886] - relayed: [n=2] TRUE, TRUE
[16:01:47.886] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:47.886] - relayed: [n=2] TRUE, TRUE
[16:01:47.886] - queued futures: [n=2] TRUE, TRUE
[16:01:47.886] signalConditionsASAP(NULL, pos=0) ... done
[16:01:47.886] resolve() on list ... DONE
[16:01:47.886] result() for ClusterFuture ...
[16:01:47.886] - result already collected: FutureResult
[16:01:47.886] result() for ClusterFuture ... done
[16:01:47.886] result() for ClusterFuture ...
[16:01:47.887] - result already collected: FutureResult
[16:01:47.887] result() for ClusterFuture ... done
[16:01:47.887] result() for ClusterFuture ...
[16:01:47.887] - result already collected: FutureResult
[16:01:47.887] result() for ClusterFuture ... done
[16:01:47.887] result() for ClusterFuture ...
[16:01:47.887] - result already collected: FutureResult
[16:01:47.887] result() for ClusterFuture ... done
[16:01:47.887]  - Number of value chunks collected: 2
[16:01:47.887] Resolving 2 futures (chunks) ... DONE
[16:01:47.888] Reducing values from 2 chunks ...
[16:01:47.888]  - Number of values collected after concatenation: 6
[16:01:47.888]  - Number of values expected: 6
[16:01:47.888] Reducing values from 2 chunks ... DONE
[16:01:47.888] future_lapply() ... DONE
[16:01:47.888] future_by_internal() ... DONE
[16:01:47.889] future_by_internal() ...
[16:01:47.889] future_lapply() ...
[16:01:47.894] Number of chunks: 2
[16:01:47.894] getGlobalsAndPackagesXApply() ...
[16:01:47.894]  - future.globals: TRUE
[16:01:47.894] getGlobalsAndPackages() ...
[16:01:47.894] Searching for globals...
[16:01:47.896] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:47.896] Searching for globals ... DONE
[16:01:47.896] Resolving globals: FALSE
[16:01:47.897] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:01:47.897] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:01:47.897] - globals: [1] ‘FUN’
[16:01:47.897] - packages: [1] ‘stats’
[16:01:47.897] getGlobalsAndPackages() ... DONE
[16:01:47.897]  - globals found/used: [n=1] ‘FUN’
[16:01:47.897]  - needed namespaces: [n=1] ‘stats’
[16:01:47.898] Finding globals ... DONE
[16:01:47.898]  - use_args: TRUE
[16:01:47.898]  - Getting '...' globals ...
[16:01:47.898] resolve() on list ...
[16:01:47.898]  recursive: 0
[16:01:47.898]  length: 1
[16:01:47.898]  elements: ‘...’
[16:01:47.898]  length: 0 (resolved future 1)
[16:01:47.899] resolve() on list ... DONE
[16:01:47.899]    - '...' content: [n=1] ‘singular.ok’
[16:01:47.899] List of 1
[16:01:47.899]  $ ...:List of 1
[16:01:47.899]   ..$ singular.ok: logi FALSE
[16:01:47.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:47.899]  - attr(*, "where")=List of 1
[16:01:47.899]   ..$ ...:<environment: 0x55b525c52090> 
[16:01:47.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:47.899]  - attr(*, "resolved")= logi TRUE
[16:01:47.899]  - attr(*, "total_size")= num NA
[16:01:47.904]  - Getting '...' globals ... DONE
[16:01:47.904] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:47.904] List of 2
[16:01:47.904]  $ ...future.FUN:function (x, ...)  
[16:01:47.904]  $ ...          :List of 1
[16:01:47.904]   ..$ singular.ok: logi FALSE
[16:01:47.904]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:47.904]  - attr(*, "where")=List of 2
[16:01:47.904]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:47.904]   ..$ ...          :<environment: 0x55b525c52090> 
[16:01:47.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:47.904]  - attr(*, "resolved")= logi FALSE
[16:01:47.904]  - attr(*, "total_size")= num 5384
[16:01:47.907] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:47.907] getGlobalsAndPackagesXApply() ... DONE
[16:01:47.907] Number of futures (= number of chunks): 2
[16:01:47.907] Launching 2 futures (chunks) ...
[16:01:47.907] Chunk #1 of 2 ...
[16:01:47.907]  - Finding globals in 'X' for chunk #1 ...
[16:01:47.907] getGlobalsAndPackages() ...
[16:01:47.908] Searching for globals...
[16:01:47.908] 
[16:01:47.908] Searching for globals ... DONE
[16:01:47.908] - globals: [0] <none>
[16:01:47.908] getGlobalsAndPackages() ... DONE
[16:01:47.908]    + additional globals found: [n=0] 
[16:01:47.908]    + additional namespaces needed: [n=0] 
[16:01:47.908]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:47.909]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:47.909]  - seeds: <none>
[16:01:47.909]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.909] getGlobalsAndPackages() ...
[16:01:47.909] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.909] Resolving globals: FALSE
[16:01:47.909] Tweak future expression to call with '...' arguments ...
[16:01:47.909] {
[16:01:47.909]     do.call(function(...) {
[16:01:47.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.909]             on.exit(options(oopts), add = TRUE)
[16:01:47.909]         }
[16:01:47.909]         {
[16:01:47.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.909]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.909]             })
[16:01:47.909]         }
[16:01:47.909]     }, args = future.call.arguments)
[16:01:47.909] }
[16:01:47.909] Tweak future expression to call with '...' arguments ... DONE
[16:01:47.910] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.910] 
[16:01:47.910] getGlobalsAndPackages() ... DONE
[16:01:47.910] run() for ‘Future’ ...
[16:01:47.910] - state: ‘created’
[16:01:47.911] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:47.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:47.925]   - Field: ‘node’
[16:01:47.925]   - Field: ‘label’
[16:01:47.925]   - Field: ‘local’
[16:01:47.925]   - Field: ‘owner’
[16:01:47.925]   - Field: ‘envir’
[16:01:47.925]   - Field: ‘workers’
[16:01:47.925]   - Field: ‘packages’
[16:01:47.925]   - Field: ‘gc’
[16:01:47.925]   - Field: ‘conditions’
[16:01:47.925]   - Field: ‘persistent’
[16:01:47.925]   - Field: ‘expr’
[16:01:47.926]   - Field: ‘uuid’
[16:01:47.926]   - Field: ‘seed’
[16:01:47.926]   - Field: ‘version’
[16:01:47.926]   - Field: ‘result’
[16:01:47.926]   - Field: ‘asynchronous’
[16:01:47.926]   - Field: ‘calls’
[16:01:47.926]   - Field: ‘globals’
[16:01:47.926]   - Field: ‘stdout’
[16:01:47.926]   - Field: ‘earlySignal’
[16:01:47.926]   - Field: ‘lazy’
[16:01:47.926]   - Field: ‘state’
[16:01:47.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:47.927] - Launch lazy future ...
[16:01:47.927] Packages needed by the future expression (n = 1): ‘stats’
[16:01:47.927] Packages needed by future strategies (n = 0): <none>
[16:01:47.928] {
[16:01:47.928]     {
[16:01:47.928]         {
[16:01:47.928]             ...future.startTime <- base::Sys.time()
[16:01:47.928]             {
[16:01:47.928]                 {
[16:01:47.928]                   {
[16:01:47.928]                     {
[16:01:47.928]                       {
[16:01:47.928]                         base::local({
[16:01:47.928]                           has_future <- base::requireNamespace("future", 
[16:01:47.928]                             quietly = TRUE)
[16:01:47.928]                           if (has_future) {
[16:01:47.928]                             ns <- base::getNamespace("future")
[16:01:47.928]                             version <- ns[[".package"]][["version"]]
[16:01:47.928]                             if (is.null(version)) 
[16:01:47.928]                               version <- utils::packageVersion("future")
[16:01:47.928]                           }
[16:01:47.928]                           else {
[16:01:47.928]                             version <- NULL
[16:01:47.928]                           }
[16:01:47.928]                           if (!has_future || version < "1.8.0") {
[16:01:47.928]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.928]                               "", base::R.version$version.string), 
[16:01:47.928]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:47.928]                                 base::R.version$platform, 8 * 
[16:01:47.928]                                   base::.Machine$sizeof.pointer), 
[16:01:47.928]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.928]                                 "release", "version")], collapse = " "), 
[16:01:47.928]                               hostname = base::Sys.info()[["nodename"]])
[16:01:47.928]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.928]                               info)
[16:01:47.928]                             info <- base::paste(info, collapse = "; ")
[16:01:47.928]                             if (!has_future) {
[16:01:47.928]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.928]                                 info)
[16:01:47.928]                             }
[16:01:47.928]                             else {
[16:01:47.928]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.928]                                 info, version)
[16:01:47.928]                             }
[16:01:47.928]                             base::stop(msg)
[16:01:47.928]                           }
[16:01:47.928]                         })
[16:01:47.928]                       }
[16:01:47.928]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.928]                       base::options(mc.cores = 1L)
[16:01:47.928]                     }
[16:01:47.928]                     base::local({
[16:01:47.928]                       for (pkg in "stats") {
[16:01:47.928]                         base::loadNamespace(pkg)
[16:01:47.928]                         base::library(pkg, character.only = TRUE)
[16:01:47.928]                       }
[16:01:47.928]                     })
[16:01:47.928]                   }
[16:01:47.928]                   options(future.plan = NULL)
[16:01:47.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.928]                 }
[16:01:47.928]                 ...future.workdir <- getwd()
[16:01:47.928]             }
[16:01:47.928]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.928]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.928]         }
[16:01:47.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.928]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:47.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.928]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.928]             base::names(...future.oldOptions))
[16:01:47.928]     }
[16:01:47.928]     if (FALSE) {
[16:01:47.928]     }
[16:01:47.928]     else {
[16:01:47.928]         if (TRUE) {
[16:01:47.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.928]                 open = "w")
[16:01:47.928]         }
[16:01:47.928]         else {
[16:01:47.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.928]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.928]         }
[16:01:47.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.928]             base::sink(type = "output", split = FALSE)
[16:01:47.928]             base::close(...future.stdout)
[16:01:47.928]         }, add = TRUE)
[16:01:47.928]     }
[16:01:47.928]     ...future.frame <- base::sys.nframe()
[16:01:47.928]     ...future.conditions <- base::list()
[16:01:47.928]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.928]     if (FALSE) {
[16:01:47.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.928]     }
[16:01:47.928]     ...future.result <- base::tryCatch({
[16:01:47.928]         base::withCallingHandlers({
[16:01:47.928]             ...future.value <- base::withVisible(base::local({
[16:01:47.928]                 ...future.makeSendCondition <- base::local({
[16:01:47.928]                   sendCondition <- NULL
[16:01:47.928]                   function(frame = 1L) {
[16:01:47.928]                     if (is.function(sendCondition)) 
[16:01:47.928]                       return(sendCondition)
[16:01:47.928]                     ns <- getNamespace("parallel")
[16:01:47.928]                     if (exists("sendData", mode = "function", 
[16:01:47.928]                       envir = ns)) {
[16:01:47.928]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.928]                         envir = ns)
[16:01:47.928]                       envir <- sys.frame(frame)
[16:01:47.928]                       master <- NULL
[16:01:47.928]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.928]                         !identical(envir, emptyenv())) {
[16:01:47.928]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.928]                           inherits = FALSE)) {
[16:01:47.928]                           master <- get("master", mode = "list", 
[16:01:47.928]                             envir = envir, inherits = FALSE)
[16:01:47.928]                           if (inherits(master, c("SOCKnode", 
[16:01:47.928]                             "SOCK0node"))) {
[16:01:47.928]                             sendCondition <<- function(cond) {
[16:01:47.928]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.928]                                 success = TRUE)
[16:01:47.928]                               parallel_sendData(master, data)
[16:01:47.928]                             }
[16:01:47.928]                             return(sendCondition)
[16:01:47.928]                           }
[16:01:47.928]                         }
[16:01:47.928]                         frame <- frame + 1L
[16:01:47.928]                         envir <- sys.frame(frame)
[16:01:47.928]                       }
[16:01:47.928]                     }
[16:01:47.928]                     sendCondition <<- function(cond) NULL
[16:01:47.928]                   }
[16:01:47.928]                 })
[16:01:47.928]                 withCallingHandlers({
[16:01:47.928]                   {
[16:01:47.928]                     do.call(function(...) {
[16:01:47.928]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.928]                       if (!identical(...future.globals.maxSize.org, 
[16:01:47.928]                         ...future.globals.maxSize)) {
[16:01:47.928]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.928]                         on.exit(options(oopts), add = TRUE)
[16:01:47.928]                       }
[16:01:47.928]                       {
[16:01:47.928]                         lapply(seq_along(...future.elements_ii), 
[16:01:47.928]                           FUN = function(jj) {
[16:01:47.928]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.928]                             ...future.FUN(...future.X_jj, ...)
[16:01:47.928]                           })
[16:01:47.928]                       }
[16:01:47.928]                     }, args = future.call.arguments)
[16:01:47.928]                   }
[16:01:47.928]                 }, immediateCondition = function(cond) {
[16:01:47.928]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.928]                   sendCondition(cond)
[16:01:47.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.928]                   {
[16:01:47.928]                     inherits <- base::inherits
[16:01:47.928]                     invokeRestart <- base::invokeRestart
[16:01:47.928]                     is.null <- base::is.null
[16:01:47.928]                     muffled <- FALSE
[16:01:47.928]                     if (inherits(cond, "message")) {
[16:01:47.928]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.928]                       if (muffled) 
[16:01:47.928]                         invokeRestart("muffleMessage")
[16:01:47.928]                     }
[16:01:47.928]                     else if (inherits(cond, "warning")) {
[16:01:47.928]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.928]                       if (muffled) 
[16:01:47.928]                         invokeRestart("muffleWarning")
[16:01:47.928]                     }
[16:01:47.928]                     else if (inherits(cond, "condition")) {
[16:01:47.928]                       if (!is.null(pattern)) {
[16:01:47.928]                         computeRestarts <- base::computeRestarts
[16:01:47.928]                         grepl <- base::grepl
[16:01:47.928]                         restarts <- computeRestarts(cond)
[16:01:47.928]                         for (restart in restarts) {
[16:01:47.928]                           name <- restart$name
[16:01:47.928]                           if (is.null(name)) 
[16:01:47.928]                             next
[16:01:47.928]                           if (!grepl(pattern, name)) 
[16:01:47.928]                             next
[16:01:47.928]                           invokeRestart(restart)
[16:01:47.928]                           muffled <- TRUE
[16:01:47.928]                           break
[16:01:47.928]                         }
[16:01:47.928]                       }
[16:01:47.928]                     }
[16:01:47.928]                     invisible(muffled)
[16:01:47.928]                   }
[16:01:47.928]                   muffleCondition(cond)
[16:01:47.928]                 })
[16:01:47.928]             }))
[16:01:47.928]             future::FutureResult(value = ...future.value$value, 
[16:01:47.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.928]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.928]                     ...future.globalenv.names))
[16:01:47.928]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.928]         }, condition = base::local({
[16:01:47.928]             c <- base::c
[16:01:47.928]             inherits <- base::inherits
[16:01:47.928]             invokeRestart <- base::invokeRestart
[16:01:47.928]             length <- base::length
[16:01:47.928]             list <- base::list
[16:01:47.928]             seq.int <- base::seq.int
[16:01:47.928]             signalCondition <- base::signalCondition
[16:01:47.928]             sys.calls <- base::sys.calls
[16:01:47.928]             `[[` <- base::`[[`
[16:01:47.928]             `+` <- base::`+`
[16:01:47.928]             `<<-` <- base::`<<-`
[16:01:47.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.928]                   3L)]
[16:01:47.928]             }
[16:01:47.928]             function(cond) {
[16:01:47.928]                 is_error <- inherits(cond, "error")
[16:01:47.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.928]                   NULL)
[16:01:47.928]                 if (is_error) {
[16:01:47.928]                   sessionInformation <- function() {
[16:01:47.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.928]                       search = base::search(), system = base::Sys.info())
[16:01:47.928]                   }
[16:01:47.928]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.928]                     cond$call), session = sessionInformation(), 
[16:01:47.928]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.928]                   signalCondition(cond)
[16:01:47.928]                 }
[16:01:47.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.928]                 "immediateCondition"))) {
[16:01:47.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.928]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.928]                   if (TRUE && !signal) {
[16:01:47.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.928]                     {
[16:01:47.928]                       inherits <- base::inherits
[16:01:47.928]                       invokeRestart <- base::invokeRestart
[16:01:47.928]                       is.null <- base::is.null
[16:01:47.928]                       muffled <- FALSE
[16:01:47.928]                       if (inherits(cond, "message")) {
[16:01:47.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.928]                         if (muffled) 
[16:01:47.928]                           invokeRestart("muffleMessage")
[16:01:47.928]                       }
[16:01:47.928]                       else if (inherits(cond, "warning")) {
[16:01:47.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.928]                         if (muffled) 
[16:01:47.928]                           invokeRestart("muffleWarning")
[16:01:47.928]                       }
[16:01:47.928]                       else if (inherits(cond, "condition")) {
[16:01:47.928]                         if (!is.null(pattern)) {
[16:01:47.928]                           computeRestarts <- base::computeRestarts
[16:01:47.928]                           grepl <- base::grepl
[16:01:47.928]                           restarts <- computeRestarts(cond)
[16:01:47.928]                           for (restart in restarts) {
[16:01:47.928]                             name <- restart$name
[16:01:47.928]                             if (is.null(name)) 
[16:01:47.928]                               next
[16:01:47.928]                             if (!grepl(pattern, name)) 
[16:01:47.928]                               next
[16:01:47.928]                             invokeRestart(restart)
[16:01:47.928]                             muffled <- TRUE
[16:01:47.928]                             break
[16:01:47.928]                           }
[16:01:47.928]                         }
[16:01:47.928]                       }
[16:01:47.928]                       invisible(muffled)
[16:01:47.928]                     }
[16:01:47.928]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.928]                   }
[16:01:47.928]                 }
[16:01:47.928]                 else {
[16:01:47.928]                   if (TRUE) {
[16:01:47.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.928]                     {
[16:01:47.928]                       inherits <- base::inherits
[16:01:47.928]                       invokeRestart <- base::invokeRestart
[16:01:47.928]                       is.null <- base::is.null
[16:01:47.928]                       muffled <- FALSE
[16:01:47.928]                       if (inherits(cond, "message")) {
[16:01:47.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.928]                         if (muffled) 
[16:01:47.928]                           invokeRestart("muffleMessage")
[16:01:47.928]                       }
[16:01:47.928]                       else if (inherits(cond, "warning")) {
[16:01:47.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.928]                         if (muffled) 
[16:01:47.928]                           invokeRestart("muffleWarning")
[16:01:47.928]                       }
[16:01:47.928]                       else if (inherits(cond, "condition")) {
[16:01:47.928]                         if (!is.null(pattern)) {
[16:01:47.928]                           computeRestarts <- base::computeRestarts
[16:01:47.928]                           grepl <- base::grepl
[16:01:47.928]                           restarts <- computeRestarts(cond)
[16:01:47.928]                           for (restart in restarts) {
[16:01:47.928]                             name <- restart$name
[16:01:47.928]                             if (is.null(name)) 
[16:01:47.928]                               next
[16:01:47.928]                             if (!grepl(pattern, name)) 
[16:01:47.928]                               next
[16:01:47.928]                             invokeRestart(restart)
[16:01:47.928]                             muffled <- TRUE
[16:01:47.928]                             break
[16:01:47.928]                           }
[16:01:47.928]                         }
[16:01:47.928]                       }
[16:01:47.928]                       invisible(muffled)
[16:01:47.928]                     }
[16:01:47.928]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.928]                   }
[16:01:47.928]                 }
[16:01:47.928]             }
[16:01:47.928]         }))
[16:01:47.928]     }, error = function(ex) {
[16:01:47.928]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.928]                 ...future.rng), started = ...future.startTime, 
[16:01:47.928]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.928]             version = "1.8"), class = "FutureResult")
[16:01:47.928]     }, finally = {
[16:01:47.928]         if (!identical(...future.workdir, getwd())) 
[16:01:47.928]             setwd(...future.workdir)
[16:01:47.928]         {
[16:01:47.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.928]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.928]             }
[16:01:47.928]             base::options(...future.oldOptions)
[16:01:47.928]             if (.Platform$OS.type == "windows") {
[16:01:47.928]                 old_names <- names(...future.oldEnvVars)
[16:01:47.928]                 envs <- base::Sys.getenv()
[16:01:47.928]                 names <- names(envs)
[16:01:47.928]                 common <- intersect(names, old_names)
[16:01:47.928]                 added <- setdiff(names, old_names)
[16:01:47.928]                 removed <- setdiff(old_names, names)
[16:01:47.928]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.928]                   envs[common]]
[16:01:47.928]                 NAMES <- toupper(changed)
[16:01:47.928]                 args <- list()
[16:01:47.928]                 for (kk in seq_along(NAMES)) {
[16:01:47.928]                   name <- changed[[kk]]
[16:01:47.928]                   NAME <- NAMES[[kk]]
[16:01:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.928]                     next
[16:01:47.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.928]                 }
[16:01:47.928]                 NAMES <- toupper(added)
[16:01:47.928]                 for (kk in seq_along(NAMES)) {
[16:01:47.928]                   name <- added[[kk]]
[16:01:47.928]                   NAME <- NAMES[[kk]]
[16:01:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.928]                     next
[16:01:47.928]                   args[[name]] <- ""
[16:01:47.928]                 }
[16:01:47.928]                 NAMES <- toupper(removed)
[16:01:47.928]                 for (kk in seq_along(NAMES)) {
[16:01:47.928]                   name <- removed[[kk]]
[16:01:47.928]                   NAME <- NAMES[[kk]]
[16:01:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.928]                     next
[16:01:47.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.928]                 }
[16:01:47.928]                 if (length(args) > 0) 
[16:01:47.928]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.928]             }
[16:01:47.928]             else {
[16:01:47.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.928]             }
[16:01:47.928]             {
[16:01:47.928]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.928]                   0L) {
[16:01:47.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.928]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.928]                   base::options(opts)
[16:01:47.928]                 }
[16:01:47.928]                 {
[16:01:47.928]                   {
[16:01:47.928]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.928]                     NULL
[16:01:47.928]                   }
[16:01:47.928]                   options(future.plan = NULL)
[16:01:47.928]                   if (is.na(NA_character_)) 
[16:01:47.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.928]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.928]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.928]                     envir = parent.frame()) 
[16:01:47.928]                   {
[16:01:47.928]                     if (is.function(workers)) 
[16:01:47.928]                       workers <- workers()
[16:01:47.928]                     workers <- structure(as.integer(workers), 
[16:01:47.928]                       class = class(workers))
[16:01:47.928]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.928]                       workers >= 1)
[16:01:47.928]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.928]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.928]                     }
[16:01:47.928]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.928]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.928]                       envir = envir)
[16:01:47.928]                     if (!future$lazy) 
[16:01:47.928]                       future <- run(future)
[16:01:47.928]                     invisible(future)
[16:01:47.928]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.928]                 }
[16:01:47.928]             }
[16:01:47.928]         }
[16:01:47.928]     })
[16:01:47.928]     if (TRUE) {
[16:01:47.928]         base::sink(type = "output", split = FALSE)
[16:01:47.928]         if (TRUE) {
[16:01:47.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.928]         }
[16:01:47.928]         else {
[16:01:47.928]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.928]         }
[16:01:47.928]         base::close(...future.stdout)
[16:01:47.928]         ...future.stdout <- NULL
[16:01:47.928]     }
[16:01:47.928]     ...future.result$conditions <- ...future.conditions
[16:01:47.928]     ...future.result$finished <- base::Sys.time()
[16:01:47.928]     ...future.result
[16:01:47.928] }
[16:01:47.930] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[16:01:47.931] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[16:01:47.931] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[16:01:47.931] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:01:47.931] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:01:47.932] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:01:47.932] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:01:47.932] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:47.932] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.933] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:47.933] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:47.933] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[16:01:47.933] MultisessionFuture started
[16:01:47.934] - Launch lazy future ... done
[16:01:47.934] run() for ‘MultisessionFuture’ ... done
[16:01:47.934] Created future:
[16:01:47.934] MultisessionFuture:
[16:01:47.934] Label: ‘future_by-1’
[16:01:47.934] Expression:
[16:01:47.934] {
[16:01:47.934]     do.call(function(...) {
[16:01:47.934]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.934]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.934]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.934]             on.exit(options(oopts), add = TRUE)
[16:01:47.934]         }
[16:01:47.934]         {
[16:01:47.934]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.934]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.934]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.934]             })
[16:01:47.934]         }
[16:01:47.934]     }, args = future.call.arguments)
[16:01:47.934] }
[16:01:47.934] Lazy evaluation: FALSE
[16:01:47.934] Asynchronous evaluation: TRUE
[16:01:47.934] Local evaluation: TRUE
[16:01:47.934] Environment: R_GlobalEnv
[16:01:47.934] Capture standard output: TRUE
[16:01:47.934] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:47.934] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:47.934] Packages: 1 packages (‘stats’)
[16:01:47.934] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:47.934] Resolved: FALSE
[16:01:47.934] Value: <not collected>
[16:01:47.934] Conditions captured: <none>
[16:01:47.934] Early signaling: FALSE
[16:01:47.934] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:47.934] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.945] Chunk #1 of 2 ... DONE
[16:01:47.946] Chunk #2 of 2 ...
[16:01:47.946]  - Finding globals in 'X' for chunk #2 ...
[16:01:47.946] getGlobalsAndPackages() ...
[16:01:47.946] Searching for globals...
[16:01:47.946] 
[16:01:47.946] Searching for globals ... DONE
[16:01:47.946] - globals: [0] <none>
[16:01:47.947] getGlobalsAndPackages() ... DONE
[16:01:47.947]    + additional globals found: [n=0] 
[16:01:47.947]    + additional namespaces needed: [n=0] 
[16:01:47.947]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:47.947]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:47.947]  - seeds: <none>
[16:01:47.947]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.947] getGlobalsAndPackages() ...
[16:01:47.947] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.947] Resolving globals: FALSE
[16:01:47.948] Tweak future expression to call with '...' arguments ...
[16:01:47.948] {
[16:01:47.948]     do.call(function(...) {
[16:01:47.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.948]             on.exit(options(oopts), add = TRUE)
[16:01:47.948]         }
[16:01:47.948]         {
[16:01:47.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.948]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.948]             })
[16:01:47.948]         }
[16:01:47.948]     }, args = future.call.arguments)
[16:01:47.948] }
[16:01:47.948] Tweak future expression to call with '...' arguments ... DONE
[16:01:47.948] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:47.948] 
[16:01:47.948] getGlobalsAndPackages() ... DONE
[16:01:47.949] run() for ‘Future’ ...
[16:01:47.949] - state: ‘created’
[16:01:47.949] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:47.963] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:47.963]   - Field: ‘node’
[16:01:47.963]   - Field: ‘label’
[16:01:47.963]   - Field: ‘local’
[16:01:47.963]   - Field: ‘owner’
[16:01:47.963]   - Field: ‘envir’
[16:01:47.964]   - Field: ‘workers’
[16:01:47.964]   - Field: ‘packages’
[16:01:47.964]   - Field: ‘gc’
[16:01:47.964]   - Field: ‘conditions’
[16:01:47.964]   - Field: ‘persistent’
[16:01:47.964]   - Field: ‘expr’
[16:01:47.964]   - Field: ‘uuid’
[16:01:47.964]   - Field: ‘seed’
[16:01:47.964]   - Field: ‘version’
[16:01:47.964]   - Field: ‘result’
[16:01:47.964]   - Field: ‘asynchronous’
[16:01:47.965]   - Field: ‘calls’
[16:01:47.965]   - Field: ‘globals’
[16:01:47.965]   - Field: ‘stdout’
[16:01:47.965]   - Field: ‘earlySignal’
[16:01:47.965]   - Field: ‘lazy’
[16:01:47.965]   - Field: ‘state’
[16:01:47.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:47.965] - Launch lazy future ...
[16:01:47.965] Packages needed by the future expression (n = 1): ‘stats’
[16:01:47.966] Packages needed by future strategies (n = 0): <none>
[16:01:47.966] {
[16:01:47.966]     {
[16:01:47.966]         {
[16:01:47.966]             ...future.startTime <- base::Sys.time()
[16:01:47.966]             {
[16:01:47.966]                 {
[16:01:47.966]                   {
[16:01:47.966]                     {
[16:01:47.966]                       {
[16:01:47.966]                         base::local({
[16:01:47.966]                           has_future <- base::requireNamespace("future", 
[16:01:47.966]                             quietly = TRUE)
[16:01:47.966]                           if (has_future) {
[16:01:47.966]                             ns <- base::getNamespace("future")
[16:01:47.966]                             version <- ns[[".package"]][["version"]]
[16:01:47.966]                             if (is.null(version)) 
[16:01:47.966]                               version <- utils::packageVersion("future")
[16:01:47.966]                           }
[16:01:47.966]                           else {
[16:01:47.966]                             version <- NULL
[16:01:47.966]                           }
[16:01:47.966]                           if (!has_future || version < "1.8.0") {
[16:01:47.966]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:47.966]                               "", base::R.version$version.string), 
[16:01:47.966]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:47.966]                                 base::R.version$platform, 8 * 
[16:01:47.966]                                   base::.Machine$sizeof.pointer), 
[16:01:47.966]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:47.966]                                 "release", "version")], collapse = " "), 
[16:01:47.966]                               hostname = base::Sys.info()[["nodename"]])
[16:01:47.966]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:47.966]                               info)
[16:01:47.966]                             info <- base::paste(info, collapse = "; ")
[16:01:47.966]                             if (!has_future) {
[16:01:47.966]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:47.966]                                 info)
[16:01:47.966]                             }
[16:01:47.966]                             else {
[16:01:47.966]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:47.966]                                 info, version)
[16:01:47.966]                             }
[16:01:47.966]                             base::stop(msg)
[16:01:47.966]                           }
[16:01:47.966]                         })
[16:01:47.966]                       }
[16:01:47.966]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:47.966]                       base::options(mc.cores = 1L)
[16:01:47.966]                     }
[16:01:47.966]                     base::local({
[16:01:47.966]                       for (pkg in "stats") {
[16:01:47.966]                         base::loadNamespace(pkg)
[16:01:47.966]                         base::library(pkg, character.only = TRUE)
[16:01:47.966]                       }
[16:01:47.966]                     })
[16:01:47.966]                   }
[16:01:47.966]                   options(future.plan = NULL)
[16:01:47.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:47.966]                 }
[16:01:47.966]                 ...future.workdir <- getwd()
[16:01:47.966]             }
[16:01:47.966]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:47.966]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:47.966]         }
[16:01:47.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:47.966]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:47.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:47.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:47.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:47.966]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:47.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:47.966]             base::names(...future.oldOptions))
[16:01:47.966]     }
[16:01:47.966]     if (FALSE) {
[16:01:47.966]     }
[16:01:47.966]     else {
[16:01:47.966]         if (TRUE) {
[16:01:47.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:47.966]                 open = "w")
[16:01:47.966]         }
[16:01:47.966]         else {
[16:01:47.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:47.966]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:47.966]         }
[16:01:47.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:47.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:47.966]             base::sink(type = "output", split = FALSE)
[16:01:47.966]             base::close(...future.stdout)
[16:01:47.966]         }, add = TRUE)
[16:01:47.966]     }
[16:01:47.966]     ...future.frame <- base::sys.nframe()
[16:01:47.966]     ...future.conditions <- base::list()
[16:01:47.966]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:47.966]     if (FALSE) {
[16:01:47.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:47.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:47.966]     }
[16:01:47.966]     ...future.result <- base::tryCatch({
[16:01:47.966]         base::withCallingHandlers({
[16:01:47.966]             ...future.value <- base::withVisible(base::local({
[16:01:47.966]                 ...future.makeSendCondition <- base::local({
[16:01:47.966]                   sendCondition <- NULL
[16:01:47.966]                   function(frame = 1L) {
[16:01:47.966]                     if (is.function(sendCondition)) 
[16:01:47.966]                       return(sendCondition)
[16:01:47.966]                     ns <- getNamespace("parallel")
[16:01:47.966]                     if (exists("sendData", mode = "function", 
[16:01:47.966]                       envir = ns)) {
[16:01:47.966]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:47.966]                         envir = ns)
[16:01:47.966]                       envir <- sys.frame(frame)
[16:01:47.966]                       master <- NULL
[16:01:47.966]                       while (!identical(envir, .GlobalEnv) && 
[16:01:47.966]                         !identical(envir, emptyenv())) {
[16:01:47.966]                         if (exists("master", mode = "list", envir = envir, 
[16:01:47.966]                           inherits = FALSE)) {
[16:01:47.966]                           master <- get("master", mode = "list", 
[16:01:47.966]                             envir = envir, inherits = FALSE)
[16:01:47.966]                           if (inherits(master, c("SOCKnode", 
[16:01:47.966]                             "SOCK0node"))) {
[16:01:47.966]                             sendCondition <<- function(cond) {
[16:01:47.966]                               data <- list(type = "VALUE", value = cond, 
[16:01:47.966]                                 success = TRUE)
[16:01:47.966]                               parallel_sendData(master, data)
[16:01:47.966]                             }
[16:01:47.966]                             return(sendCondition)
[16:01:47.966]                           }
[16:01:47.966]                         }
[16:01:47.966]                         frame <- frame + 1L
[16:01:47.966]                         envir <- sys.frame(frame)
[16:01:47.966]                       }
[16:01:47.966]                     }
[16:01:47.966]                     sendCondition <<- function(cond) NULL
[16:01:47.966]                   }
[16:01:47.966]                 })
[16:01:47.966]                 withCallingHandlers({
[16:01:47.966]                   {
[16:01:47.966]                     do.call(function(...) {
[16:01:47.966]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.966]                       if (!identical(...future.globals.maxSize.org, 
[16:01:47.966]                         ...future.globals.maxSize)) {
[16:01:47.966]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.966]                         on.exit(options(oopts), add = TRUE)
[16:01:47.966]                       }
[16:01:47.966]                       {
[16:01:47.966]                         lapply(seq_along(...future.elements_ii), 
[16:01:47.966]                           FUN = function(jj) {
[16:01:47.966]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.966]                             ...future.FUN(...future.X_jj, ...)
[16:01:47.966]                           })
[16:01:47.966]                       }
[16:01:47.966]                     }, args = future.call.arguments)
[16:01:47.966]                   }
[16:01:47.966]                 }, immediateCondition = function(cond) {
[16:01:47.966]                   sendCondition <- ...future.makeSendCondition()
[16:01:47.966]                   sendCondition(cond)
[16:01:47.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.966]                   {
[16:01:47.966]                     inherits <- base::inherits
[16:01:47.966]                     invokeRestart <- base::invokeRestart
[16:01:47.966]                     is.null <- base::is.null
[16:01:47.966]                     muffled <- FALSE
[16:01:47.966]                     if (inherits(cond, "message")) {
[16:01:47.966]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:47.966]                       if (muffled) 
[16:01:47.966]                         invokeRestart("muffleMessage")
[16:01:47.966]                     }
[16:01:47.966]                     else if (inherits(cond, "warning")) {
[16:01:47.966]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:47.966]                       if (muffled) 
[16:01:47.966]                         invokeRestart("muffleWarning")
[16:01:47.966]                     }
[16:01:47.966]                     else if (inherits(cond, "condition")) {
[16:01:47.966]                       if (!is.null(pattern)) {
[16:01:47.966]                         computeRestarts <- base::computeRestarts
[16:01:47.966]                         grepl <- base::grepl
[16:01:47.966]                         restarts <- computeRestarts(cond)
[16:01:47.966]                         for (restart in restarts) {
[16:01:47.966]                           name <- restart$name
[16:01:47.966]                           if (is.null(name)) 
[16:01:47.966]                             next
[16:01:47.966]                           if (!grepl(pattern, name)) 
[16:01:47.966]                             next
[16:01:47.966]                           invokeRestart(restart)
[16:01:47.966]                           muffled <- TRUE
[16:01:47.966]                           break
[16:01:47.966]                         }
[16:01:47.966]                       }
[16:01:47.966]                     }
[16:01:47.966]                     invisible(muffled)
[16:01:47.966]                   }
[16:01:47.966]                   muffleCondition(cond)
[16:01:47.966]                 })
[16:01:47.966]             }))
[16:01:47.966]             future::FutureResult(value = ...future.value$value, 
[16:01:47.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.966]                   ...future.rng), globalenv = if (FALSE) 
[16:01:47.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:47.966]                     ...future.globalenv.names))
[16:01:47.966]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:47.966]         }, condition = base::local({
[16:01:47.966]             c <- base::c
[16:01:47.966]             inherits <- base::inherits
[16:01:47.966]             invokeRestart <- base::invokeRestart
[16:01:47.966]             length <- base::length
[16:01:47.966]             list <- base::list
[16:01:47.966]             seq.int <- base::seq.int
[16:01:47.966]             signalCondition <- base::signalCondition
[16:01:47.966]             sys.calls <- base::sys.calls
[16:01:47.966]             `[[` <- base::`[[`
[16:01:47.966]             `+` <- base::`+`
[16:01:47.966]             `<<-` <- base::`<<-`
[16:01:47.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:47.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:47.966]                   3L)]
[16:01:47.966]             }
[16:01:47.966]             function(cond) {
[16:01:47.966]                 is_error <- inherits(cond, "error")
[16:01:47.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:47.966]                   NULL)
[16:01:47.966]                 if (is_error) {
[16:01:47.966]                   sessionInformation <- function() {
[16:01:47.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:47.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:47.966]                       search = base::search(), system = base::Sys.info())
[16:01:47.966]                   }
[16:01:47.966]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:47.966]                     cond$call), session = sessionInformation(), 
[16:01:47.966]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:47.966]                   signalCondition(cond)
[16:01:47.966]                 }
[16:01:47.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:47.966]                 "immediateCondition"))) {
[16:01:47.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:47.966]                   ...future.conditions[[length(...future.conditions) + 
[16:01:47.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:47.966]                   if (TRUE && !signal) {
[16:01:47.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.966]                     {
[16:01:47.966]                       inherits <- base::inherits
[16:01:47.966]                       invokeRestart <- base::invokeRestart
[16:01:47.966]                       is.null <- base::is.null
[16:01:47.966]                       muffled <- FALSE
[16:01:47.966]                       if (inherits(cond, "message")) {
[16:01:47.966]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.966]                         if (muffled) 
[16:01:47.966]                           invokeRestart("muffleMessage")
[16:01:47.966]                       }
[16:01:47.966]                       else if (inherits(cond, "warning")) {
[16:01:47.966]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.966]                         if (muffled) 
[16:01:47.966]                           invokeRestart("muffleWarning")
[16:01:47.966]                       }
[16:01:47.966]                       else if (inherits(cond, "condition")) {
[16:01:47.966]                         if (!is.null(pattern)) {
[16:01:47.966]                           computeRestarts <- base::computeRestarts
[16:01:47.966]                           grepl <- base::grepl
[16:01:47.966]                           restarts <- computeRestarts(cond)
[16:01:47.966]                           for (restart in restarts) {
[16:01:47.966]                             name <- restart$name
[16:01:47.966]                             if (is.null(name)) 
[16:01:47.966]                               next
[16:01:47.966]                             if (!grepl(pattern, name)) 
[16:01:47.966]                               next
[16:01:47.966]                             invokeRestart(restart)
[16:01:47.966]                             muffled <- TRUE
[16:01:47.966]                             break
[16:01:47.966]                           }
[16:01:47.966]                         }
[16:01:47.966]                       }
[16:01:47.966]                       invisible(muffled)
[16:01:47.966]                     }
[16:01:47.966]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.966]                   }
[16:01:47.966]                 }
[16:01:47.966]                 else {
[16:01:47.966]                   if (TRUE) {
[16:01:47.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:47.966]                     {
[16:01:47.966]                       inherits <- base::inherits
[16:01:47.966]                       invokeRestart <- base::invokeRestart
[16:01:47.966]                       is.null <- base::is.null
[16:01:47.966]                       muffled <- FALSE
[16:01:47.966]                       if (inherits(cond, "message")) {
[16:01:47.966]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:47.966]                         if (muffled) 
[16:01:47.966]                           invokeRestart("muffleMessage")
[16:01:47.966]                       }
[16:01:47.966]                       else if (inherits(cond, "warning")) {
[16:01:47.966]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:47.966]                         if (muffled) 
[16:01:47.966]                           invokeRestart("muffleWarning")
[16:01:47.966]                       }
[16:01:47.966]                       else if (inherits(cond, "condition")) {
[16:01:47.966]                         if (!is.null(pattern)) {
[16:01:47.966]                           computeRestarts <- base::computeRestarts
[16:01:47.966]                           grepl <- base::grepl
[16:01:47.966]                           restarts <- computeRestarts(cond)
[16:01:47.966]                           for (restart in restarts) {
[16:01:47.966]                             name <- restart$name
[16:01:47.966]                             if (is.null(name)) 
[16:01:47.966]                               next
[16:01:47.966]                             if (!grepl(pattern, name)) 
[16:01:47.966]                               next
[16:01:47.966]                             invokeRestart(restart)
[16:01:47.966]                             muffled <- TRUE
[16:01:47.966]                             break
[16:01:47.966]                           }
[16:01:47.966]                         }
[16:01:47.966]                       }
[16:01:47.966]                       invisible(muffled)
[16:01:47.966]                     }
[16:01:47.966]                     muffleCondition(cond, pattern = "^muffle")
[16:01:47.966]                   }
[16:01:47.966]                 }
[16:01:47.966]             }
[16:01:47.966]         }))
[16:01:47.966]     }, error = function(ex) {
[16:01:47.966]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:47.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:47.966]                 ...future.rng), started = ...future.startTime, 
[16:01:47.966]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:47.966]             version = "1.8"), class = "FutureResult")
[16:01:47.966]     }, finally = {
[16:01:47.966]         if (!identical(...future.workdir, getwd())) 
[16:01:47.966]             setwd(...future.workdir)
[16:01:47.966]         {
[16:01:47.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:47.966]                 ...future.oldOptions$nwarnings <- NULL
[16:01:47.966]             }
[16:01:47.966]             base::options(...future.oldOptions)
[16:01:47.966]             if (.Platform$OS.type == "windows") {
[16:01:47.966]                 old_names <- names(...future.oldEnvVars)
[16:01:47.966]                 envs <- base::Sys.getenv()
[16:01:47.966]                 names <- names(envs)
[16:01:47.966]                 common <- intersect(names, old_names)
[16:01:47.966]                 added <- setdiff(names, old_names)
[16:01:47.966]                 removed <- setdiff(old_names, names)
[16:01:47.966]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:47.966]                   envs[common]]
[16:01:47.966]                 NAMES <- toupper(changed)
[16:01:47.966]                 args <- list()
[16:01:47.966]                 for (kk in seq_along(NAMES)) {
[16:01:47.966]                   name <- changed[[kk]]
[16:01:47.966]                   NAME <- NAMES[[kk]]
[16:01:47.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.966]                     next
[16:01:47.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.966]                 }
[16:01:47.966]                 NAMES <- toupper(added)
[16:01:47.966]                 for (kk in seq_along(NAMES)) {
[16:01:47.966]                   name <- added[[kk]]
[16:01:47.966]                   NAME <- NAMES[[kk]]
[16:01:47.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.966]                     next
[16:01:47.966]                   args[[name]] <- ""
[16:01:47.966]                 }
[16:01:47.966]                 NAMES <- toupper(removed)
[16:01:47.966]                 for (kk in seq_along(NAMES)) {
[16:01:47.966]                   name <- removed[[kk]]
[16:01:47.966]                   NAME <- NAMES[[kk]]
[16:01:47.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:47.966]                     next
[16:01:47.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:47.966]                 }
[16:01:47.966]                 if (length(args) > 0) 
[16:01:47.966]                   base::do.call(base::Sys.setenv, args = args)
[16:01:47.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:47.966]             }
[16:01:47.966]             else {
[16:01:47.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:47.966]             }
[16:01:47.966]             {
[16:01:47.966]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:47.966]                   0L) {
[16:01:47.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:47.966]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:47.966]                   base::options(opts)
[16:01:47.966]                 }
[16:01:47.966]                 {
[16:01:47.966]                   {
[16:01:47.966]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:47.966]                     NULL
[16:01:47.966]                   }
[16:01:47.966]                   options(future.plan = NULL)
[16:01:47.966]                   if (is.na(NA_character_)) 
[16:01:47.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:47.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:47.966]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:47.966]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:47.966]                     envir = parent.frame()) 
[16:01:47.966]                   {
[16:01:47.966]                     if (is.function(workers)) 
[16:01:47.966]                       workers <- workers()
[16:01:47.966]                     workers <- structure(as.integer(workers), 
[16:01:47.966]                       class = class(workers))
[16:01:47.966]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:47.966]                       workers >= 1)
[16:01:47.966]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:47.966]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:47.966]                     }
[16:01:47.966]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:47.966]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:47.966]                       envir = envir)
[16:01:47.966]                     if (!future$lazy) 
[16:01:47.966]                       future <- run(future)
[16:01:47.966]                     invisible(future)
[16:01:47.966]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:47.966]                 }
[16:01:47.966]             }
[16:01:47.966]         }
[16:01:47.966]     })
[16:01:47.966]     if (TRUE) {
[16:01:47.966]         base::sink(type = "output", split = FALSE)
[16:01:47.966]         if (TRUE) {
[16:01:47.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:47.966]         }
[16:01:47.966]         else {
[16:01:47.966]             ...future.result["stdout"] <- base::list(NULL)
[16:01:47.966]         }
[16:01:47.966]         base::close(...future.stdout)
[16:01:47.966]         ...future.stdout <- NULL
[16:01:47.966]     }
[16:01:47.966]     ...future.result$conditions <- ...future.conditions
[16:01:47.966]     ...future.result$finished <- base::Sys.time()
[16:01:47.966]     ...future.result
[16:01:47.966] }
[16:01:47.969] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[16:01:47.969] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[16:01:47.969] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[16:01:47.970] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:01:47.970] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:01:47.970] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:01:47.971] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:01:47.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:47.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.971] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:47.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:47.972] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[16:01:47.972] MultisessionFuture started
[16:01:47.973] - Launch lazy future ... done
[16:01:47.973] run() for ‘MultisessionFuture’ ... done
[16:01:47.973] Created future:
[16:01:47.973] MultisessionFuture:
[16:01:47.973] Label: ‘future_by-2’
[16:01:47.973] Expression:
[16:01:47.973] {
[16:01:47.973]     do.call(function(...) {
[16:01:47.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:47.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:47.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:47.973]             on.exit(options(oopts), add = TRUE)
[16:01:47.973]         }
[16:01:47.973]         {
[16:01:47.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:47.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:47.973]                 ...future.FUN(...future.X_jj, ...)
[16:01:47.973]             })
[16:01:47.973]         }
[16:01:47.973]     }, args = future.call.arguments)
[16:01:47.973] }
[16:01:47.973] Lazy evaluation: FALSE
[16:01:47.973] Asynchronous evaluation: TRUE
[16:01:47.973] Local evaluation: TRUE
[16:01:47.973] Environment: R_GlobalEnv
[16:01:47.973] Capture standard output: TRUE
[16:01:47.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:47.973] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:47.973] Packages: 1 packages (‘stats’)
[16:01:47.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:47.973] Resolved: FALSE
[16:01:47.973] Value: <not collected>
[16:01:47.973] Conditions captured: <none>
[16:01:47.973] Early signaling: FALSE
[16:01:47.973] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:47.973] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:47.985] Chunk #2 of 2 ... DONE
[16:01:47.985] Launching 2 futures (chunks) ... DONE
[16:01:47.985] Resolving 2 futures (chunks) ...
[16:01:47.985] resolve() on list ...
[16:01:47.985]  recursive: 0
[16:01:47.985]  length: 2
[16:01:47.985] 
[16:01:47.986] receiveMessageFromWorker() for ClusterFuture ...
[16:01:47.986] - Validating connection of MultisessionFuture
[16:01:47.986] - received message: FutureResult
[16:01:47.986] - Received FutureResult
[16:01:47.986] - Erased future from FutureRegistry
[16:01:47.986] result() for ClusterFuture ...
[16:01:47.986] - result already collected: FutureResult
[16:01:47.986] result() for ClusterFuture ... done
[16:01:47.987] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:47.987] Future #1
[16:01:47.987] result() for ClusterFuture ...
[16:01:47.987] - result already collected: FutureResult
[16:01:47.987] result() for ClusterFuture ... done
[16:01:47.987] result() for ClusterFuture ...
[16:01:47.987] - result already collected: FutureResult
[16:01:47.987] result() for ClusterFuture ... done
[16:01:47.987] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:47.987] - nx: 2
[16:01:47.987] - relay: TRUE
[16:01:47.988] - stdout: TRUE
[16:01:47.988] - signal: TRUE
[16:01:47.988] - resignal: FALSE
[16:01:47.988] - force: TRUE
[16:01:47.988] - relayed: [n=2] FALSE, FALSE
[16:01:47.988] - queued futures: [n=2] FALSE, FALSE
[16:01:47.988]  - until=1
[16:01:47.988]  - relaying element #1
[16:01:47.988] result() for ClusterFuture ...
[16:01:47.988] - result already collected: FutureResult
[16:01:47.988] result() for ClusterFuture ... done
[16:01:47.988] result() for ClusterFuture ...
[16:01:47.989] - result already collected: FutureResult
[16:01:47.989] result() for ClusterFuture ... done
[16:01:47.989] result() for ClusterFuture ...
[16:01:47.989] - result already collected: FutureResult
[16:01:47.989] result() for ClusterFuture ... done
[16:01:47.989] result() for ClusterFuture ...
[16:01:47.989] - result already collected: FutureResult
[16:01:47.989] result() for ClusterFuture ... done
[16:01:47.989] - relayed: [n=2] TRUE, FALSE
[16:01:47.989] - queued futures: [n=2] TRUE, FALSE
[16:01:47.989] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:47.990]  length: 1 (resolved future 1)
[16:01:48.031] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.031] - Validating connection of MultisessionFuture
[16:01:48.032] - received message: FutureResult
[16:01:48.032] - Received FutureResult
[16:01:48.032] - Erased future from FutureRegistry
[16:01:48.032] result() for ClusterFuture ...
[16:01:48.032] - result already collected: FutureResult
[16:01:48.032] result() for ClusterFuture ... done
[16:01:48.032] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.032] Future #2
[16:01:48.033] result() for ClusterFuture ...
[16:01:48.033] - result already collected: FutureResult
[16:01:48.033] result() for ClusterFuture ... done
[16:01:48.033] result() for ClusterFuture ...
[16:01:48.033] - result already collected: FutureResult
[16:01:48.033] result() for ClusterFuture ... done
[16:01:48.033] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:48.033] - nx: 2
[16:01:48.033] - relay: TRUE
[16:01:48.033] - stdout: TRUE
[16:01:48.033] - signal: TRUE
[16:01:48.033] - resignal: FALSE
[16:01:48.034] - force: TRUE
[16:01:48.034] - relayed: [n=2] TRUE, FALSE
[16:01:48.034] - queued futures: [n=2] TRUE, FALSE
[16:01:48.034]  - until=2
[16:01:48.034]  - relaying element #2
[16:01:48.034] result() for ClusterFuture ...
[16:01:48.034] - result already collected: FutureResult
[16:01:48.034] result() for ClusterFuture ... done
[16:01:48.034] result() for ClusterFuture ...
[16:01:48.034] - result already collected: FutureResult
[16:01:48.034] result() for ClusterFuture ... done
[16:01:48.035] result() for ClusterFuture ...
[16:01:48.035] - result already collected: FutureResult
[16:01:48.035] result() for ClusterFuture ... done
[16:01:48.035] result() for ClusterFuture ...
[16:01:48.035] - result already collected: FutureResult
[16:01:48.035] result() for ClusterFuture ... done
[16:01:48.035] - relayed: [n=2] TRUE, TRUE
[16:01:48.035] - queued futures: [n=2] TRUE, TRUE
[16:01:48.035] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:48.035]  length: 0 (resolved future 2)
[16:01:48.035] Relaying remaining futures
[16:01:48.036] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.036] - nx: 2
[16:01:48.036] - relay: TRUE
[16:01:48.036] - stdout: TRUE
[16:01:48.036] - signal: TRUE
[16:01:48.036] - resignal: FALSE
[16:01:48.036] - force: TRUE
[16:01:48.036] - relayed: [n=2] TRUE, TRUE
[16:01:48.036] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:48.036] - relayed: [n=2] TRUE, TRUE
[16:01:48.036] - queued futures: [n=2] TRUE, TRUE
[16:01:48.036] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.037] resolve() on list ... DONE
[16:01:48.037] result() for ClusterFuture ...
[16:01:48.037] - result already collected: FutureResult
[16:01:48.037] result() for ClusterFuture ... done
[16:01:48.037] result() for ClusterFuture ...
[16:01:48.037] - result already collected: FutureResult
[16:01:48.037] result() for ClusterFuture ... done
[16:01:48.037] result() for ClusterFuture ...
[16:01:48.037] - result already collected: FutureResult
[16:01:48.037] result() for ClusterFuture ... done
[16:01:48.037] result() for ClusterFuture ...
[16:01:48.037] - result already collected: FutureResult
[16:01:48.038] result() for ClusterFuture ... done
[16:01:48.038]  - Number of value chunks collected: 2
[16:01:48.038] Resolving 2 futures (chunks) ... DONE
[16:01:48.038] Reducing values from 2 chunks ...
[16:01:48.038]  - Number of values collected after concatenation: 3
[16:01:48.038]  - Number of values expected: 3
[16:01:48.038] Reducing values from 2 chunks ... DONE
[16:01:48.038] future_lapply() ... DONE
[16:01:48.038] future_by_internal() ... DONE
[16:01:48.042] future_by_internal() ...
[16:01:48.043] future_lapply() ...
[16:01:48.047] Number of chunks: 2
[16:01:48.047] getGlobalsAndPackagesXApply() ...
[16:01:48.047]  - future.globals: TRUE
[16:01:48.047] getGlobalsAndPackages() ...
[16:01:48.047] Searching for globals...
[16:01:48.049] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:01:48.049] Searching for globals ... DONE
[16:01:48.049] Resolving globals: FALSE
[16:01:48.050] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:01:48.050] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:01:48.050] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:48.050] - packages: [1] ‘stats’
[16:01:48.050] getGlobalsAndPackages() ... DONE
[16:01:48.051]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:01:48.051]  - needed namespaces: [n=1] ‘stats’
[16:01:48.051] Finding globals ... DONE
[16:01:48.051]  - use_args: TRUE
[16:01:48.051]  - Getting '...' globals ...
[16:01:48.051] resolve() on list ...
[16:01:48.051]  recursive: 0
[16:01:48.051]  length: 1
[16:01:48.052]  elements: ‘...’
[16:01:48.052]  length: 0 (resolved future 1)
[16:01:48.052] resolve() on list ... DONE
[16:01:48.052]    - '...' content: [n=0] 
[16:01:48.052] List of 1
[16:01:48.052]  $ ...: list()
[16:01:48.052]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.052]  - attr(*, "where")=List of 1
[16:01:48.052]   ..$ ...:<environment: 0x55b5269a3c40> 
[16:01:48.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.052]  - attr(*, "resolved")= logi TRUE
[16:01:48.052]  - attr(*, "total_size")= num NA
[16:01:48.054]  - Getting '...' globals ... DONE
[16:01:48.055] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:01:48.055] List of 4
[16:01:48.055]  $ ...future.FUN:function (x)  
[16:01:48.055]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:01:48.055]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:01:48.055]  $ ...          : list()
[16:01:48.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.055]  - attr(*, "where")=List of 4
[16:01:48.055]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.055]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:01:48.055]   ..$ wool         :<environment: R_EmptyEnv> 
[16:01:48.055]   ..$ ...          :<environment: 0x55b5269a3c40> 
[16:01:48.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.055]  - attr(*, "resolved")= logi FALSE
[16:01:48.055]  - attr(*, "total_size")= num 2320
[16:01:48.059] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:48.059] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.059] Number of futures (= number of chunks): 2
[16:01:48.059] Launching 2 futures (chunks) ...
[16:01:48.059] Chunk #1 of 2 ...
[16:01:48.059]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.059] getGlobalsAndPackages() ...
[16:01:48.059] Searching for globals...
[16:01:48.060] 
[16:01:48.060] Searching for globals ... DONE
[16:01:48.060] - globals: [0] <none>
[16:01:48.060] getGlobalsAndPackages() ... DONE
[16:01:48.060]    + additional globals found: [n=0] 
[16:01:48.060]    + additional namespaces needed: [n=0] 
[16:01:48.060]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.060]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:48.061]  - seeds: <none>
[16:01:48.061]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.061] getGlobalsAndPackages() ...
[16:01:48.061] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.061] Resolving globals: FALSE
[16:01:48.061] Tweak future expression to call with '...' arguments ...
[16:01:48.061] {
[16:01:48.061]     do.call(function(...) {
[16:01:48.061]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.061]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.061]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.061]             on.exit(options(oopts), add = TRUE)
[16:01:48.061]         }
[16:01:48.061]         {
[16:01:48.061]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.061]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.061]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.061]             })
[16:01:48.061]         }
[16:01:48.061]     }, args = future.call.arguments)
[16:01:48.061] }
[16:01:48.062] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.062] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.062] 
[16:01:48.062] getGlobalsAndPackages() ... DONE
[16:01:48.062] run() for ‘Future’ ...
[16:01:48.063] - state: ‘created’
[16:01:48.063] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:48.077] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.077] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:48.077]   - Field: ‘node’
[16:01:48.078]   - Field: ‘label’
[16:01:48.078]   - Field: ‘local’
[16:01:48.078]   - Field: ‘owner’
[16:01:48.078]   - Field: ‘envir’
[16:01:48.078]   - Field: ‘workers’
[16:01:48.078]   - Field: ‘packages’
[16:01:48.078]   - Field: ‘gc’
[16:01:48.078]   - Field: ‘conditions’
[16:01:48.078]   - Field: ‘persistent’
[16:01:48.078]   - Field: ‘expr’
[16:01:48.079]   - Field: ‘uuid’
[16:01:48.079]   - Field: ‘seed’
[16:01:48.079]   - Field: ‘version’
[16:01:48.079]   - Field: ‘result’
[16:01:48.079]   - Field: ‘asynchronous’
[16:01:48.081]   - Field: ‘calls’
[16:01:48.081]   - Field: ‘globals’
[16:01:48.081]   - Field: ‘stdout’
[16:01:48.081]   - Field: ‘earlySignal’
[16:01:48.081]   - Field: ‘lazy’
[16:01:48.081]   - Field: ‘state’
[16:01:48.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:48.082] - Launch lazy future ...
[16:01:48.082] Packages needed by the future expression (n = 1): ‘stats’
[16:01:48.082] Packages needed by future strategies (n = 0): <none>
[16:01:48.083] {
[16:01:48.083]     {
[16:01:48.083]         {
[16:01:48.083]             ...future.startTime <- base::Sys.time()
[16:01:48.083]             {
[16:01:48.083]                 {
[16:01:48.083]                   {
[16:01:48.083]                     {
[16:01:48.083]                       {
[16:01:48.083]                         base::local({
[16:01:48.083]                           has_future <- base::requireNamespace("future", 
[16:01:48.083]                             quietly = TRUE)
[16:01:48.083]                           if (has_future) {
[16:01:48.083]                             ns <- base::getNamespace("future")
[16:01:48.083]                             version <- ns[[".package"]][["version"]]
[16:01:48.083]                             if (is.null(version)) 
[16:01:48.083]                               version <- utils::packageVersion("future")
[16:01:48.083]                           }
[16:01:48.083]                           else {
[16:01:48.083]                             version <- NULL
[16:01:48.083]                           }
[16:01:48.083]                           if (!has_future || version < "1.8.0") {
[16:01:48.083]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.083]                               "", base::R.version$version.string), 
[16:01:48.083]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:48.083]                                 base::R.version$platform, 8 * 
[16:01:48.083]                                   base::.Machine$sizeof.pointer), 
[16:01:48.083]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.083]                                 "release", "version")], collapse = " "), 
[16:01:48.083]                               hostname = base::Sys.info()[["nodename"]])
[16:01:48.083]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.083]                               info)
[16:01:48.083]                             info <- base::paste(info, collapse = "; ")
[16:01:48.083]                             if (!has_future) {
[16:01:48.083]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.083]                                 info)
[16:01:48.083]                             }
[16:01:48.083]                             else {
[16:01:48.083]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.083]                                 info, version)
[16:01:48.083]                             }
[16:01:48.083]                             base::stop(msg)
[16:01:48.083]                           }
[16:01:48.083]                         })
[16:01:48.083]                       }
[16:01:48.083]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:48.083]                       base::options(mc.cores = 1L)
[16:01:48.083]                     }
[16:01:48.083]                     base::local({
[16:01:48.083]                       for (pkg in "stats") {
[16:01:48.083]                         base::loadNamespace(pkg)
[16:01:48.083]                         base::library(pkg, character.only = TRUE)
[16:01:48.083]                       }
[16:01:48.083]                     })
[16:01:48.083]                   }
[16:01:48.083]                   options(future.plan = NULL)
[16:01:48.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.083]                 }
[16:01:48.083]                 ...future.workdir <- getwd()
[16:01:48.083]             }
[16:01:48.083]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.083]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.083]         }
[16:01:48.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.083]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:48.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.083]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.083]             base::names(...future.oldOptions))
[16:01:48.083]     }
[16:01:48.083]     if (FALSE) {
[16:01:48.083]     }
[16:01:48.083]     else {
[16:01:48.083]         if (TRUE) {
[16:01:48.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.083]                 open = "w")
[16:01:48.083]         }
[16:01:48.083]         else {
[16:01:48.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.083]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.083]         }
[16:01:48.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.083]             base::sink(type = "output", split = FALSE)
[16:01:48.083]             base::close(...future.stdout)
[16:01:48.083]         }, add = TRUE)
[16:01:48.083]     }
[16:01:48.083]     ...future.frame <- base::sys.nframe()
[16:01:48.083]     ...future.conditions <- base::list()
[16:01:48.083]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.083]     if (FALSE) {
[16:01:48.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.083]     }
[16:01:48.083]     ...future.result <- base::tryCatch({
[16:01:48.083]         base::withCallingHandlers({
[16:01:48.083]             ...future.value <- base::withVisible(base::local({
[16:01:48.083]                 ...future.makeSendCondition <- base::local({
[16:01:48.083]                   sendCondition <- NULL
[16:01:48.083]                   function(frame = 1L) {
[16:01:48.083]                     if (is.function(sendCondition)) 
[16:01:48.083]                       return(sendCondition)
[16:01:48.083]                     ns <- getNamespace("parallel")
[16:01:48.083]                     if (exists("sendData", mode = "function", 
[16:01:48.083]                       envir = ns)) {
[16:01:48.083]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:48.083]                         envir = ns)
[16:01:48.083]                       envir <- sys.frame(frame)
[16:01:48.083]                       master <- NULL
[16:01:48.083]                       while (!identical(envir, .GlobalEnv) && 
[16:01:48.083]                         !identical(envir, emptyenv())) {
[16:01:48.083]                         if (exists("master", mode = "list", envir = envir, 
[16:01:48.083]                           inherits = FALSE)) {
[16:01:48.083]                           master <- get("master", mode = "list", 
[16:01:48.083]                             envir = envir, inherits = FALSE)
[16:01:48.083]                           if (inherits(master, c("SOCKnode", 
[16:01:48.083]                             "SOCK0node"))) {
[16:01:48.083]                             sendCondition <<- function(cond) {
[16:01:48.083]                               data <- list(type = "VALUE", value = cond, 
[16:01:48.083]                                 success = TRUE)
[16:01:48.083]                               parallel_sendData(master, data)
[16:01:48.083]                             }
[16:01:48.083]                             return(sendCondition)
[16:01:48.083]                           }
[16:01:48.083]                         }
[16:01:48.083]                         frame <- frame + 1L
[16:01:48.083]                         envir <- sys.frame(frame)
[16:01:48.083]                       }
[16:01:48.083]                     }
[16:01:48.083]                     sendCondition <<- function(cond) NULL
[16:01:48.083]                   }
[16:01:48.083]                 })
[16:01:48.083]                 withCallingHandlers({
[16:01:48.083]                   {
[16:01:48.083]                     do.call(function(...) {
[16:01:48.083]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.083]                       if (!identical(...future.globals.maxSize.org, 
[16:01:48.083]                         ...future.globals.maxSize)) {
[16:01:48.083]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.083]                         on.exit(options(oopts), add = TRUE)
[16:01:48.083]                       }
[16:01:48.083]                       {
[16:01:48.083]                         lapply(seq_along(...future.elements_ii), 
[16:01:48.083]                           FUN = function(jj) {
[16:01:48.083]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.083]                             ...future.FUN(...future.X_jj, ...)
[16:01:48.083]                           })
[16:01:48.083]                       }
[16:01:48.083]                     }, args = future.call.arguments)
[16:01:48.083]                   }
[16:01:48.083]                 }, immediateCondition = function(cond) {
[16:01:48.083]                   sendCondition <- ...future.makeSendCondition()
[16:01:48.083]                   sendCondition(cond)
[16:01:48.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.083]                   {
[16:01:48.083]                     inherits <- base::inherits
[16:01:48.083]                     invokeRestart <- base::invokeRestart
[16:01:48.083]                     is.null <- base::is.null
[16:01:48.083]                     muffled <- FALSE
[16:01:48.083]                     if (inherits(cond, "message")) {
[16:01:48.083]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:48.083]                       if (muffled) 
[16:01:48.083]                         invokeRestart("muffleMessage")
[16:01:48.083]                     }
[16:01:48.083]                     else if (inherits(cond, "warning")) {
[16:01:48.083]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:48.083]                       if (muffled) 
[16:01:48.083]                         invokeRestart("muffleWarning")
[16:01:48.083]                     }
[16:01:48.083]                     else if (inherits(cond, "condition")) {
[16:01:48.083]                       if (!is.null(pattern)) {
[16:01:48.083]                         computeRestarts <- base::computeRestarts
[16:01:48.083]                         grepl <- base::grepl
[16:01:48.083]                         restarts <- computeRestarts(cond)
[16:01:48.083]                         for (restart in restarts) {
[16:01:48.083]                           name <- restart$name
[16:01:48.083]                           if (is.null(name)) 
[16:01:48.083]                             next
[16:01:48.083]                           if (!grepl(pattern, name)) 
[16:01:48.083]                             next
[16:01:48.083]                           invokeRestart(restart)
[16:01:48.083]                           muffled <- TRUE
[16:01:48.083]                           break
[16:01:48.083]                         }
[16:01:48.083]                       }
[16:01:48.083]                     }
[16:01:48.083]                     invisible(muffled)
[16:01:48.083]                   }
[16:01:48.083]                   muffleCondition(cond)
[16:01:48.083]                 })
[16:01:48.083]             }))
[16:01:48.083]             future::FutureResult(value = ...future.value$value, 
[16:01:48.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.083]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.083]                     ...future.globalenv.names))
[16:01:48.083]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.083]         }, condition = base::local({
[16:01:48.083]             c <- base::c
[16:01:48.083]             inherits <- base::inherits
[16:01:48.083]             invokeRestart <- base::invokeRestart
[16:01:48.083]             length <- base::length
[16:01:48.083]             list <- base::list
[16:01:48.083]             seq.int <- base::seq.int
[16:01:48.083]             signalCondition <- base::signalCondition
[16:01:48.083]             sys.calls <- base::sys.calls
[16:01:48.083]             `[[` <- base::`[[`
[16:01:48.083]             `+` <- base::`+`
[16:01:48.083]             `<<-` <- base::`<<-`
[16:01:48.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.083]                   3L)]
[16:01:48.083]             }
[16:01:48.083]             function(cond) {
[16:01:48.083]                 is_error <- inherits(cond, "error")
[16:01:48.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.083]                   NULL)
[16:01:48.083]                 if (is_error) {
[16:01:48.083]                   sessionInformation <- function() {
[16:01:48.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.083]                       search = base::search(), system = base::Sys.info())
[16:01:48.083]                   }
[16:01:48.083]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.083]                     cond$call), session = sessionInformation(), 
[16:01:48.083]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.083]                   signalCondition(cond)
[16:01:48.083]                 }
[16:01:48.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.083]                 "immediateCondition"))) {
[16:01:48.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.083]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.083]                   if (TRUE && !signal) {
[16:01:48.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.083]                     {
[16:01:48.083]                       inherits <- base::inherits
[16:01:48.083]                       invokeRestart <- base::invokeRestart
[16:01:48.083]                       is.null <- base::is.null
[16:01:48.083]                       muffled <- FALSE
[16:01:48.083]                       if (inherits(cond, "message")) {
[16:01:48.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.083]                         if (muffled) 
[16:01:48.083]                           invokeRestart("muffleMessage")
[16:01:48.083]                       }
[16:01:48.083]                       else if (inherits(cond, "warning")) {
[16:01:48.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.083]                         if (muffled) 
[16:01:48.083]                           invokeRestart("muffleWarning")
[16:01:48.083]                       }
[16:01:48.083]                       else if (inherits(cond, "condition")) {
[16:01:48.083]                         if (!is.null(pattern)) {
[16:01:48.083]                           computeRestarts <- base::computeRestarts
[16:01:48.083]                           grepl <- base::grepl
[16:01:48.083]                           restarts <- computeRestarts(cond)
[16:01:48.083]                           for (restart in restarts) {
[16:01:48.083]                             name <- restart$name
[16:01:48.083]                             if (is.null(name)) 
[16:01:48.083]                               next
[16:01:48.083]                             if (!grepl(pattern, name)) 
[16:01:48.083]                               next
[16:01:48.083]                             invokeRestart(restart)
[16:01:48.083]                             muffled <- TRUE
[16:01:48.083]                             break
[16:01:48.083]                           }
[16:01:48.083]                         }
[16:01:48.083]                       }
[16:01:48.083]                       invisible(muffled)
[16:01:48.083]                     }
[16:01:48.083]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.083]                   }
[16:01:48.083]                 }
[16:01:48.083]                 else {
[16:01:48.083]                   if (TRUE) {
[16:01:48.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.083]                     {
[16:01:48.083]                       inherits <- base::inherits
[16:01:48.083]                       invokeRestart <- base::invokeRestart
[16:01:48.083]                       is.null <- base::is.null
[16:01:48.083]                       muffled <- FALSE
[16:01:48.083]                       if (inherits(cond, "message")) {
[16:01:48.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.083]                         if (muffled) 
[16:01:48.083]                           invokeRestart("muffleMessage")
[16:01:48.083]                       }
[16:01:48.083]                       else if (inherits(cond, "warning")) {
[16:01:48.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.083]                         if (muffled) 
[16:01:48.083]                           invokeRestart("muffleWarning")
[16:01:48.083]                       }
[16:01:48.083]                       else if (inherits(cond, "condition")) {
[16:01:48.083]                         if (!is.null(pattern)) {
[16:01:48.083]                           computeRestarts <- base::computeRestarts
[16:01:48.083]                           grepl <- base::grepl
[16:01:48.083]                           restarts <- computeRestarts(cond)
[16:01:48.083]                           for (restart in restarts) {
[16:01:48.083]                             name <- restart$name
[16:01:48.083]                             if (is.null(name)) 
[16:01:48.083]                               next
[16:01:48.083]                             if (!grepl(pattern, name)) 
[16:01:48.083]                               next
[16:01:48.083]                             invokeRestart(restart)
[16:01:48.083]                             muffled <- TRUE
[16:01:48.083]                             break
[16:01:48.083]                           }
[16:01:48.083]                         }
[16:01:48.083]                       }
[16:01:48.083]                       invisible(muffled)
[16:01:48.083]                     }
[16:01:48.083]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.083]                   }
[16:01:48.083]                 }
[16:01:48.083]             }
[16:01:48.083]         }))
[16:01:48.083]     }, error = function(ex) {
[16:01:48.083]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.083]                 ...future.rng), started = ...future.startTime, 
[16:01:48.083]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.083]             version = "1.8"), class = "FutureResult")
[16:01:48.083]     }, finally = {
[16:01:48.083]         if (!identical(...future.workdir, getwd())) 
[16:01:48.083]             setwd(...future.workdir)
[16:01:48.083]         {
[16:01:48.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.083]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.083]             }
[16:01:48.083]             base::options(...future.oldOptions)
[16:01:48.083]             if (.Platform$OS.type == "windows") {
[16:01:48.083]                 old_names <- names(...future.oldEnvVars)
[16:01:48.083]                 envs <- base::Sys.getenv()
[16:01:48.083]                 names <- names(envs)
[16:01:48.083]                 common <- intersect(names, old_names)
[16:01:48.083]                 added <- setdiff(names, old_names)
[16:01:48.083]                 removed <- setdiff(old_names, names)
[16:01:48.083]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.083]                   envs[common]]
[16:01:48.083]                 NAMES <- toupper(changed)
[16:01:48.083]                 args <- list()
[16:01:48.083]                 for (kk in seq_along(NAMES)) {
[16:01:48.083]                   name <- changed[[kk]]
[16:01:48.083]                   NAME <- NAMES[[kk]]
[16:01:48.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.083]                     next
[16:01:48.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.083]                 }
[16:01:48.083]                 NAMES <- toupper(added)
[16:01:48.083]                 for (kk in seq_along(NAMES)) {
[16:01:48.083]                   name <- added[[kk]]
[16:01:48.083]                   NAME <- NAMES[[kk]]
[16:01:48.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.083]                     next
[16:01:48.083]                   args[[name]] <- ""
[16:01:48.083]                 }
[16:01:48.083]                 NAMES <- toupper(removed)
[16:01:48.083]                 for (kk in seq_along(NAMES)) {
[16:01:48.083]                   name <- removed[[kk]]
[16:01:48.083]                   NAME <- NAMES[[kk]]
[16:01:48.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.083]                     next
[16:01:48.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.083]                 }
[16:01:48.083]                 if (length(args) > 0) 
[16:01:48.083]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.083]             }
[16:01:48.083]             else {
[16:01:48.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.083]             }
[16:01:48.083]             {
[16:01:48.083]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.083]                   0L) {
[16:01:48.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.083]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.083]                   base::options(opts)
[16:01:48.083]                 }
[16:01:48.083]                 {
[16:01:48.083]                   {
[16:01:48.083]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:48.083]                     NULL
[16:01:48.083]                   }
[16:01:48.083]                   options(future.plan = NULL)
[16:01:48.083]                   if (is.na(NA_character_)) 
[16:01:48.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.083]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:48.083]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:48.083]                     envir = parent.frame()) 
[16:01:48.083]                   {
[16:01:48.083]                     if (is.function(workers)) 
[16:01:48.083]                       workers <- workers()
[16:01:48.083]                     workers <- structure(as.integer(workers), 
[16:01:48.083]                       class = class(workers))
[16:01:48.083]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:48.083]                       workers >= 1)
[16:01:48.083]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:48.083]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:48.083]                     }
[16:01:48.083]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:48.083]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:48.083]                       envir = envir)
[16:01:48.083]                     if (!future$lazy) 
[16:01:48.083]                       future <- run(future)
[16:01:48.083]                     invisible(future)
[16:01:48.083]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.083]                 }
[16:01:48.083]             }
[16:01:48.083]         }
[16:01:48.083]     })
[16:01:48.083]     if (TRUE) {
[16:01:48.083]         base::sink(type = "output", split = FALSE)
[16:01:48.083]         if (TRUE) {
[16:01:48.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.083]         }
[16:01:48.083]         else {
[16:01:48.083]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.083]         }
[16:01:48.083]         base::close(...future.stdout)
[16:01:48.083]         ...future.stdout <- NULL
[16:01:48.083]     }
[16:01:48.083]     ...future.result$conditions <- ...future.conditions
[16:01:48.083]     ...future.result$finished <- base::Sys.time()
[16:01:48.083]     ...future.result
[16:01:48.083] }
[16:01:48.086] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[16:01:48.086] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[16:01:48.086] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[16:01:48.086] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[16:01:48.087] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[16:01:48.087] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[16:01:48.087] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[16:01:48.087] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:48.088] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.088] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:01:48.088] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:01:48.089] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:48.089] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.089] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:48.089] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.090] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[16:01:48.090] MultisessionFuture started
[16:01:48.090] - Launch lazy future ... done
[16:01:48.090] run() for ‘MultisessionFuture’ ... done
[16:01:48.091] Created future:
[16:01:48.091] MultisessionFuture:
[16:01:48.091] Label: ‘future_by-1’
[16:01:48.091] Expression:
[16:01:48.091] {
[16:01:48.091]     do.call(function(...) {
[16:01:48.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.091]             on.exit(options(oopts), add = TRUE)
[16:01:48.091]         }
[16:01:48.091]         {
[16:01:48.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.091]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.091]             })
[16:01:48.091]         }
[16:01:48.091]     }, args = future.call.arguments)
[16:01:48.091] }
[16:01:48.091] Lazy evaluation: FALSE
[16:01:48.091] Asynchronous evaluation: TRUE
[16:01:48.091] Local evaluation: TRUE
[16:01:48.091] Environment: 0x55b526a27e38
[16:01:48.091] Capture standard output: TRUE
[16:01:48.091] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.091] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:01:48.091] Packages: 1 packages (‘stats’)
[16:01:48.091] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.091] Resolved: FALSE
[16:01:48.091] Value: <not collected>
[16:01:48.091] Conditions captured: <none>
[16:01:48.091] Early signaling: FALSE
[16:01:48.091] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:48.091] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.103] Chunk #1 of 2 ... DONE
[16:01:48.103] Chunk #2 of 2 ...
[16:01:48.103]  - Finding globals in 'X' for chunk #2 ...
[16:01:48.103] getGlobalsAndPackages() ...
[16:01:48.103] Searching for globals...
[16:01:48.104] 
[16:01:48.104] Searching for globals ... DONE
[16:01:48.104] - globals: [0] <none>
[16:01:48.104] getGlobalsAndPackages() ... DONE
[16:01:48.104]    + additional globals found: [n=0] 
[16:01:48.104]    + additional namespaces needed: [n=0] 
[16:01:48.104]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:48.104]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:48.104]  - seeds: <none>
[16:01:48.104]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.105] getGlobalsAndPackages() ...
[16:01:48.105] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.105] Resolving globals: FALSE
[16:01:48.105] Tweak future expression to call with '...' arguments ...
[16:01:48.105] {
[16:01:48.105]     do.call(function(...) {
[16:01:48.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.105]             on.exit(options(oopts), add = TRUE)
[16:01:48.105]         }
[16:01:48.105]         {
[16:01:48.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.105]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.105]             })
[16:01:48.105]         }
[16:01:48.105]     }, args = future.call.arguments)
[16:01:48.105] }
[16:01:48.105] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.106] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.106] 
[16:01:48.106] getGlobalsAndPackages() ... DONE
[16:01:48.106] run() for ‘Future’ ...
[16:01:48.106] - state: ‘created’
[16:01:48.106] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:48.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:48.120]   - Field: ‘node’
[16:01:48.120]   - Field: ‘label’
[16:01:48.121]   - Field: ‘local’
[16:01:48.121]   - Field: ‘owner’
[16:01:48.121]   - Field: ‘envir’
[16:01:48.121]   - Field: ‘workers’
[16:01:48.121]   - Field: ‘packages’
[16:01:48.121]   - Field: ‘gc’
[16:01:48.121]   - Field: ‘conditions’
[16:01:48.121]   - Field: ‘persistent’
[16:01:48.121]   - Field: ‘expr’
[16:01:48.121]   - Field: ‘uuid’
[16:01:48.121]   - Field: ‘seed’
[16:01:48.121]   - Field: ‘version’
[16:01:48.122]   - Field: ‘result’
[16:01:48.122]   - Field: ‘asynchronous’
[16:01:48.122]   - Field: ‘calls’
[16:01:48.122]   - Field: ‘globals’
[16:01:48.122]   - Field: ‘stdout’
[16:01:48.122]   - Field: ‘earlySignal’
[16:01:48.122]   - Field: ‘lazy’
[16:01:48.122]   - Field: ‘state’
[16:01:48.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:48.122] - Launch lazy future ...
[16:01:48.123] Packages needed by the future expression (n = 1): ‘stats’
[16:01:48.123] Packages needed by future strategies (n = 0): <none>
[16:01:48.124] {
[16:01:48.124]     {
[16:01:48.124]         {
[16:01:48.124]             ...future.startTime <- base::Sys.time()
[16:01:48.124]             {
[16:01:48.124]                 {
[16:01:48.124]                   {
[16:01:48.124]                     {
[16:01:48.124]                       {
[16:01:48.124]                         base::local({
[16:01:48.124]                           has_future <- base::requireNamespace("future", 
[16:01:48.124]                             quietly = TRUE)
[16:01:48.124]                           if (has_future) {
[16:01:48.124]                             ns <- base::getNamespace("future")
[16:01:48.124]                             version <- ns[[".package"]][["version"]]
[16:01:48.124]                             if (is.null(version)) 
[16:01:48.124]                               version <- utils::packageVersion("future")
[16:01:48.124]                           }
[16:01:48.124]                           else {
[16:01:48.124]                             version <- NULL
[16:01:48.124]                           }
[16:01:48.124]                           if (!has_future || version < "1.8.0") {
[16:01:48.124]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.124]                               "", base::R.version$version.string), 
[16:01:48.124]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:48.124]                                 base::R.version$platform, 8 * 
[16:01:48.124]                                   base::.Machine$sizeof.pointer), 
[16:01:48.124]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.124]                                 "release", "version")], collapse = " "), 
[16:01:48.124]                               hostname = base::Sys.info()[["nodename"]])
[16:01:48.124]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.124]                               info)
[16:01:48.124]                             info <- base::paste(info, collapse = "; ")
[16:01:48.124]                             if (!has_future) {
[16:01:48.124]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.124]                                 info)
[16:01:48.124]                             }
[16:01:48.124]                             else {
[16:01:48.124]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.124]                                 info, version)
[16:01:48.124]                             }
[16:01:48.124]                             base::stop(msg)
[16:01:48.124]                           }
[16:01:48.124]                         })
[16:01:48.124]                       }
[16:01:48.124]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:48.124]                       base::options(mc.cores = 1L)
[16:01:48.124]                     }
[16:01:48.124]                     base::local({
[16:01:48.124]                       for (pkg in "stats") {
[16:01:48.124]                         base::loadNamespace(pkg)
[16:01:48.124]                         base::library(pkg, character.only = TRUE)
[16:01:48.124]                       }
[16:01:48.124]                     })
[16:01:48.124]                   }
[16:01:48.124]                   options(future.plan = NULL)
[16:01:48.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.124]                 }
[16:01:48.124]                 ...future.workdir <- getwd()
[16:01:48.124]             }
[16:01:48.124]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.124]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.124]         }
[16:01:48.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.124]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:48.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.124]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.124]             base::names(...future.oldOptions))
[16:01:48.124]     }
[16:01:48.124]     if (FALSE) {
[16:01:48.124]     }
[16:01:48.124]     else {
[16:01:48.124]         if (TRUE) {
[16:01:48.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.124]                 open = "w")
[16:01:48.124]         }
[16:01:48.124]         else {
[16:01:48.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.124]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.124]         }
[16:01:48.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.124]             base::sink(type = "output", split = FALSE)
[16:01:48.124]             base::close(...future.stdout)
[16:01:48.124]         }, add = TRUE)
[16:01:48.124]     }
[16:01:48.124]     ...future.frame <- base::sys.nframe()
[16:01:48.124]     ...future.conditions <- base::list()
[16:01:48.124]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.124]     if (FALSE) {
[16:01:48.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.124]     }
[16:01:48.124]     ...future.result <- base::tryCatch({
[16:01:48.124]         base::withCallingHandlers({
[16:01:48.124]             ...future.value <- base::withVisible(base::local({
[16:01:48.124]                 ...future.makeSendCondition <- base::local({
[16:01:48.124]                   sendCondition <- NULL
[16:01:48.124]                   function(frame = 1L) {
[16:01:48.124]                     if (is.function(sendCondition)) 
[16:01:48.124]                       return(sendCondition)
[16:01:48.124]                     ns <- getNamespace("parallel")
[16:01:48.124]                     if (exists("sendData", mode = "function", 
[16:01:48.124]                       envir = ns)) {
[16:01:48.124]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:48.124]                         envir = ns)
[16:01:48.124]                       envir <- sys.frame(frame)
[16:01:48.124]                       master <- NULL
[16:01:48.124]                       while (!identical(envir, .GlobalEnv) && 
[16:01:48.124]                         !identical(envir, emptyenv())) {
[16:01:48.124]                         if (exists("master", mode = "list", envir = envir, 
[16:01:48.124]                           inherits = FALSE)) {
[16:01:48.124]                           master <- get("master", mode = "list", 
[16:01:48.124]                             envir = envir, inherits = FALSE)
[16:01:48.124]                           if (inherits(master, c("SOCKnode", 
[16:01:48.124]                             "SOCK0node"))) {
[16:01:48.124]                             sendCondition <<- function(cond) {
[16:01:48.124]                               data <- list(type = "VALUE", value = cond, 
[16:01:48.124]                                 success = TRUE)
[16:01:48.124]                               parallel_sendData(master, data)
[16:01:48.124]                             }
[16:01:48.124]                             return(sendCondition)
[16:01:48.124]                           }
[16:01:48.124]                         }
[16:01:48.124]                         frame <- frame + 1L
[16:01:48.124]                         envir <- sys.frame(frame)
[16:01:48.124]                       }
[16:01:48.124]                     }
[16:01:48.124]                     sendCondition <<- function(cond) NULL
[16:01:48.124]                   }
[16:01:48.124]                 })
[16:01:48.124]                 withCallingHandlers({
[16:01:48.124]                   {
[16:01:48.124]                     do.call(function(...) {
[16:01:48.124]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.124]                       if (!identical(...future.globals.maxSize.org, 
[16:01:48.124]                         ...future.globals.maxSize)) {
[16:01:48.124]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.124]                         on.exit(options(oopts), add = TRUE)
[16:01:48.124]                       }
[16:01:48.124]                       {
[16:01:48.124]                         lapply(seq_along(...future.elements_ii), 
[16:01:48.124]                           FUN = function(jj) {
[16:01:48.124]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.124]                             ...future.FUN(...future.X_jj, ...)
[16:01:48.124]                           })
[16:01:48.124]                       }
[16:01:48.124]                     }, args = future.call.arguments)
[16:01:48.124]                   }
[16:01:48.124]                 }, immediateCondition = function(cond) {
[16:01:48.124]                   sendCondition <- ...future.makeSendCondition()
[16:01:48.124]                   sendCondition(cond)
[16:01:48.124]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.124]                   {
[16:01:48.124]                     inherits <- base::inherits
[16:01:48.124]                     invokeRestart <- base::invokeRestart
[16:01:48.124]                     is.null <- base::is.null
[16:01:48.124]                     muffled <- FALSE
[16:01:48.124]                     if (inherits(cond, "message")) {
[16:01:48.124]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:48.124]                       if (muffled) 
[16:01:48.124]                         invokeRestart("muffleMessage")
[16:01:48.124]                     }
[16:01:48.124]                     else if (inherits(cond, "warning")) {
[16:01:48.124]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:48.124]                       if (muffled) 
[16:01:48.124]                         invokeRestart("muffleWarning")
[16:01:48.124]                     }
[16:01:48.124]                     else if (inherits(cond, "condition")) {
[16:01:48.124]                       if (!is.null(pattern)) {
[16:01:48.124]                         computeRestarts <- base::computeRestarts
[16:01:48.124]                         grepl <- base::grepl
[16:01:48.124]                         restarts <- computeRestarts(cond)
[16:01:48.124]                         for (restart in restarts) {
[16:01:48.124]                           name <- restart$name
[16:01:48.124]                           if (is.null(name)) 
[16:01:48.124]                             next
[16:01:48.124]                           if (!grepl(pattern, name)) 
[16:01:48.124]                             next
[16:01:48.124]                           invokeRestart(restart)
[16:01:48.124]                           muffled <- TRUE
[16:01:48.124]                           break
[16:01:48.124]                         }
[16:01:48.124]                       }
[16:01:48.124]                     }
[16:01:48.124]                     invisible(muffled)
[16:01:48.124]                   }
[16:01:48.124]                   muffleCondition(cond)
[16:01:48.124]                 })
[16:01:48.124]             }))
[16:01:48.124]             future::FutureResult(value = ...future.value$value, 
[16:01:48.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.124]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.124]                     ...future.globalenv.names))
[16:01:48.124]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.124]         }, condition = base::local({
[16:01:48.124]             c <- base::c
[16:01:48.124]             inherits <- base::inherits
[16:01:48.124]             invokeRestart <- base::invokeRestart
[16:01:48.124]             length <- base::length
[16:01:48.124]             list <- base::list
[16:01:48.124]             seq.int <- base::seq.int
[16:01:48.124]             signalCondition <- base::signalCondition
[16:01:48.124]             sys.calls <- base::sys.calls
[16:01:48.124]             `[[` <- base::`[[`
[16:01:48.124]             `+` <- base::`+`
[16:01:48.124]             `<<-` <- base::`<<-`
[16:01:48.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.124]                   3L)]
[16:01:48.124]             }
[16:01:48.124]             function(cond) {
[16:01:48.124]                 is_error <- inherits(cond, "error")
[16:01:48.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.124]                   NULL)
[16:01:48.124]                 if (is_error) {
[16:01:48.124]                   sessionInformation <- function() {
[16:01:48.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.124]                       search = base::search(), system = base::Sys.info())
[16:01:48.124]                   }
[16:01:48.124]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.124]                     cond$call), session = sessionInformation(), 
[16:01:48.124]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.124]                   signalCondition(cond)
[16:01:48.124]                 }
[16:01:48.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.124]                 "immediateCondition"))) {
[16:01:48.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.124]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.124]                   if (TRUE && !signal) {
[16:01:48.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.124]                     {
[16:01:48.124]                       inherits <- base::inherits
[16:01:48.124]                       invokeRestart <- base::invokeRestart
[16:01:48.124]                       is.null <- base::is.null
[16:01:48.124]                       muffled <- FALSE
[16:01:48.124]                       if (inherits(cond, "message")) {
[16:01:48.124]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.124]                         if (muffled) 
[16:01:48.124]                           invokeRestart("muffleMessage")
[16:01:48.124]                       }
[16:01:48.124]                       else if (inherits(cond, "warning")) {
[16:01:48.124]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.124]                         if (muffled) 
[16:01:48.124]                           invokeRestart("muffleWarning")
[16:01:48.124]                       }
[16:01:48.124]                       else if (inherits(cond, "condition")) {
[16:01:48.124]                         if (!is.null(pattern)) {
[16:01:48.124]                           computeRestarts <- base::computeRestarts
[16:01:48.124]                           grepl <- base::grepl
[16:01:48.124]                           restarts <- computeRestarts(cond)
[16:01:48.124]                           for (restart in restarts) {
[16:01:48.124]                             name <- restart$name
[16:01:48.124]                             if (is.null(name)) 
[16:01:48.124]                               next
[16:01:48.124]                             if (!grepl(pattern, name)) 
[16:01:48.124]                               next
[16:01:48.124]                             invokeRestart(restart)
[16:01:48.124]                             muffled <- TRUE
[16:01:48.124]                             break
[16:01:48.124]                           }
[16:01:48.124]                         }
[16:01:48.124]                       }
[16:01:48.124]                       invisible(muffled)
[16:01:48.124]                     }
[16:01:48.124]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.124]                   }
[16:01:48.124]                 }
[16:01:48.124]                 else {
[16:01:48.124]                   if (TRUE) {
[16:01:48.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.124]                     {
[16:01:48.124]                       inherits <- base::inherits
[16:01:48.124]                       invokeRestart <- base::invokeRestart
[16:01:48.124]                       is.null <- base::is.null
[16:01:48.124]                       muffled <- FALSE
[16:01:48.124]                       if (inherits(cond, "message")) {
[16:01:48.124]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.124]                         if (muffled) 
[16:01:48.124]                           invokeRestart("muffleMessage")
[16:01:48.124]                       }
[16:01:48.124]                       else if (inherits(cond, "warning")) {
[16:01:48.124]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.124]                         if (muffled) 
[16:01:48.124]                           invokeRestart("muffleWarning")
[16:01:48.124]                       }
[16:01:48.124]                       else if (inherits(cond, "condition")) {
[16:01:48.124]                         if (!is.null(pattern)) {
[16:01:48.124]                           computeRestarts <- base::computeRestarts
[16:01:48.124]                           grepl <- base::grepl
[16:01:48.124]                           restarts <- computeRestarts(cond)
[16:01:48.124]                           for (restart in restarts) {
[16:01:48.124]                             name <- restart$name
[16:01:48.124]                             if (is.null(name)) 
[16:01:48.124]                               next
[16:01:48.124]                             if (!grepl(pattern, name)) 
[16:01:48.124]                               next
[16:01:48.124]                             invokeRestart(restart)
[16:01:48.124]                             muffled <- TRUE
[16:01:48.124]                             break
[16:01:48.124]                           }
[16:01:48.124]                         }
[16:01:48.124]                       }
[16:01:48.124]                       invisible(muffled)
[16:01:48.124]                     }
[16:01:48.124]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.124]                   }
[16:01:48.124]                 }
[16:01:48.124]             }
[16:01:48.124]         }))
[16:01:48.124]     }, error = function(ex) {
[16:01:48.124]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.124]                 ...future.rng), started = ...future.startTime, 
[16:01:48.124]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.124]             version = "1.8"), class = "FutureResult")
[16:01:48.124]     }, finally = {
[16:01:48.124]         if (!identical(...future.workdir, getwd())) 
[16:01:48.124]             setwd(...future.workdir)
[16:01:48.124]         {
[16:01:48.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.124]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.124]             }
[16:01:48.124]             base::options(...future.oldOptions)
[16:01:48.124]             if (.Platform$OS.type == "windows") {
[16:01:48.124]                 old_names <- names(...future.oldEnvVars)
[16:01:48.124]                 envs <- base::Sys.getenv()
[16:01:48.124]                 names <- names(envs)
[16:01:48.124]                 common <- intersect(names, old_names)
[16:01:48.124]                 added <- setdiff(names, old_names)
[16:01:48.124]                 removed <- setdiff(old_names, names)
[16:01:48.124]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.124]                   envs[common]]
[16:01:48.124]                 NAMES <- toupper(changed)
[16:01:48.124]                 args <- list()
[16:01:48.124]                 for (kk in seq_along(NAMES)) {
[16:01:48.124]                   name <- changed[[kk]]
[16:01:48.124]                   NAME <- NAMES[[kk]]
[16:01:48.124]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.124]                     next
[16:01:48.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.124]                 }
[16:01:48.124]                 NAMES <- toupper(added)
[16:01:48.124]                 for (kk in seq_along(NAMES)) {
[16:01:48.124]                   name <- added[[kk]]
[16:01:48.124]                   NAME <- NAMES[[kk]]
[16:01:48.124]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.124]                     next
[16:01:48.124]                   args[[name]] <- ""
[16:01:48.124]                 }
[16:01:48.124]                 NAMES <- toupper(removed)
[16:01:48.124]                 for (kk in seq_along(NAMES)) {
[16:01:48.124]                   name <- removed[[kk]]
[16:01:48.124]                   NAME <- NAMES[[kk]]
[16:01:48.124]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.124]                     next
[16:01:48.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.124]                 }
[16:01:48.124]                 if (length(args) > 0) 
[16:01:48.124]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.124]             }
[16:01:48.124]             else {
[16:01:48.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.124]             }
[16:01:48.124]             {
[16:01:48.124]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.124]                   0L) {
[16:01:48.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.124]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.124]                   base::options(opts)
[16:01:48.124]                 }
[16:01:48.124]                 {
[16:01:48.124]                   {
[16:01:48.124]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:48.124]                     NULL
[16:01:48.124]                   }
[16:01:48.124]                   options(future.plan = NULL)
[16:01:48.124]                   if (is.na(NA_character_)) 
[16:01:48.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.124]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:48.124]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:48.124]                     envir = parent.frame()) 
[16:01:48.124]                   {
[16:01:48.124]                     if (is.function(workers)) 
[16:01:48.124]                       workers <- workers()
[16:01:48.124]                     workers <- structure(as.integer(workers), 
[16:01:48.124]                       class = class(workers))
[16:01:48.124]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:48.124]                       workers >= 1)
[16:01:48.124]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:48.124]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:48.124]                     }
[16:01:48.124]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:48.124]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:48.124]                       envir = envir)
[16:01:48.124]                     if (!future$lazy) 
[16:01:48.124]                       future <- run(future)
[16:01:48.124]                     invisible(future)
[16:01:48.124]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.124]                 }
[16:01:48.124]             }
[16:01:48.124]         }
[16:01:48.124]     })
[16:01:48.124]     if (TRUE) {
[16:01:48.124]         base::sink(type = "output", split = FALSE)
[16:01:48.124]         if (TRUE) {
[16:01:48.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.124]         }
[16:01:48.124]         else {
[16:01:48.124]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.124]         }
[16:01:48.124]         base::close(...future.stdout)
[16:01:48.124]         ...future.stdout <- NULL
[16:01:48.124]     }
[16:01:48.124]     ...future.result$conditions <- ...future.conditions
[16:01:48.124]     ...future.result$finished <- base::Sys.time()
[16:01:48.124]     ...future.result
[16:01:48.124] }
[16:01:48.127] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[16:01:48.127] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[16:01:48.127] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[16:01:48.127] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[16:01:48.128] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[16:01:48.128] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[16:01:48.128] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[16:01:48.128] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:48.129] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.129] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:01:48.129] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:01:48.130] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:48.130] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.130] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:48.130] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.131] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[16:01:48.131] MultisessionFuture started
[16:01:48.131] - Launch lazy future ... done
[16:01:48.132] run() for ‘MultisessionFuture’ ... done
[16:01:48.132] Created future:
[16:01:48.132] MultisessionFuture:
[16:01:48.132] Label: ‘future_by-2’
[16:01:48.132] Expression:
[16:01:48.132] {
[16:01:48.132]     do.call(function(...) {
[16:01:48.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.132]             on.exit(options(oopts), add = TRUE)
[16:01:48.132]         }
[16:01:48.132]         {
[16:01:48.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.132]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.132]             })
[16:01:48.132]         }
[16:01:48.132]     }, args = future.call.arguments)
[16:01:48.132] }
[16:01:48.132] Lazy evaluation: FALSE
[16:01:48.132] Asynchronous evaluation: TRUE
[16:01:48.132] Local evaluation: TRUE
[16:01:48.132] Environment: 0x55b526a27e38
[16:01:48.132] Capture standard output: TRUE
[16:01:48.132] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.132] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:01:48.132] Packages: 1 packages (‘stats’)
[16:01:48.132] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.132] Resolved: FALSE
[16:01:48.132] Value: <not collected>
[16:01:48.132] Conditions captured: <none>
[16:01:48.132] Early signaling: FALSE
[16:01:48.132] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:48.132] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.144] Chunk #2 of 2 ... DONE
[16:01:48.144] Launching 2 futures (chunks) ... DONE
[16:01:48.144] Resolving 2 futures (chunks) ...
[16:01:48.144] resolve() on list ...
[16:01:48.144]  recursive: 0
[16:01:48.144]  length: 2
[16:01:48.144] 
[16:01:48.145] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.145] - Validating connection of MultisessionFuture
[16:01:48.145] - received message: FutureResult
[16:01:48.145] - Received FutureResult
[16:01:48.145] - Erased future from FutureRegistry
[16:01:48.145] result() for ClusterFuture ...
[16:01:48.145] - result already collected: FutureResult
[16:01:48.146] result() for ClusterFuture ... done
[16:01:48.146] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.146] Future #1
[16:01:48.146] result() for ClusterFuture ...
[16:01:48.146] - result already collected: FutureResult
[16:01:48.146] result() for ClusterFuture ... done
[16:01:48.146] result() for ClusterFuture ...
[16:01:48.146] - result already collected: FutureResult
[16:01:48.146] result() for ClusterFuture ... done
[16:01:48.146] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:48.146] - nx: 2
[16:01:48.147] - relay: TRUE
[16:01:48.147] - stdout: TRUE
[16:01:48.147] - signal: TRUE
[16:01:48.147] - resignal: FALSE
[16:01:48.147] - force: TRUE
[16:01:48.147] - relayed: [n=2] FALSE, FALSE
[16:01:48.147] - queued futures: [n=2] FALSE, FALSE
[16:01:48.147]  - until=1
[16:01:48.147]  - relaying element #1
[16:01:48.147] result() for ClusterFuture ...
[16:01:48.147] - result already collected: FutureResult
[16:01:48.147] result() for ClusterFuture ... done
[16:01:48.148] result() for ClusterFuture ...
[16:01:48.148] - result already collected: FutureResult
[16:01:48.148] result() for ClusterFuture ... done
[16:01:48.148] result() for ClusterFuture ...
[16:01:48.148] - result already collected: FutureResult
[16:01:48.148] result() for ClusterFuture ... done
[16:01:48.148] result() for ClusterFuture ...
[16:01:48.148] - result already collected: FutureResult
[16:01:48.148] result() for ClusterFuture ... done
[16:01:48.148] - relayed: [n=2] TRUE, FALSE
[16:01:48.148] - queued futures: [n=2] TRUE, FALSE
[16:01:48.149] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:48.149]  length: 1 (resolved future 1)
[16:01:48.191] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.191] - Validating connection of MultisessionFuture
[16:01:48.191] - received message: FutureResult
[16:01:48.191] - Received FutureResult
[16:01:48.191] - Erased future from FutureRegistry
[16:01:48.191] result() for ClusterFuture ...
[16:01:48.192] - result already collected: FutureResult
[16:01:48.192] result() for ClusterFuture ... done
[16:01:48.192] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.192] Future #2
[16:01:48.192] result() for ClusterFuture ...
[16:01:48.192] - result already collected: FutureResult
[16:01:48.192] result() for ClusterFuture ... done
[16:01:48.192] result() for ClusterFuture ...
[16:01:48.192] - result already collected: FutureResult
[16:01:48.192] result() for ClusterFuture ... done
[16:01:48.192] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:48.193] - nx: 2
[16:01:48.193] - relay: TRUE
[16:01:48.193] - stdout: TRUE
[16:01:48.193] - signal: TRUE
[16:01:48.193] - resignal: FALSE
[16:01:48.193] - force: TRUE
[16:01:48.193] - relayed: [n=2] TRUE, FALSE
[16:01:48.193] - queued futures: [n=2] TRUE, FALSE
[16:01:48.193]  - until=2
[16:01:48.193]  - relaying element #2
[16:01:48.193] result() for ClusterFuture ...
[16:01:48.193] - result already collected: FutureResult
[16:01:48.194] result() for ClusterFuture ... done
[16:01:48.194] result() for ClusterFuture ...
[16:01:48.194] - result already collected: FutureResult
[16:01:48.194] result() for ClusterFuture ... done
[16:01:48.194] result() for ClusterFuture ...
[16:01:48.194] - result already collected: FutureResult
[16:01:48.194] result() for ClusterFuture ... done
[16:01:48.194] result() for ClusterFuture ...
[16:01:48.194] - result already collected: FutureResult
[16:01:48.194] result() for ClusterFuture ... done
[16:01:48.194] - relayed: [n=2] TRUE, TRUE
[16:01:48.195] - queued futures: [n=2] TRUE, TRUE
[16:01:48.195] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:48.195]  length: 0 (resolved future 2)
[16:01:48.195] Relaying remaining futures
[16:01:48.195] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.195] - nx: 2
[16:01:48.195] - relay: TRUE
[16:01:48.195] - stdout: TRUE
[16:01:48.195] - signal: TRUE
[16:01:48.195] - resignal: FALSE
[16:01:48.195] - force: TRUE
[16:01:48.196] - relayed: [n=2] TRUE, TRUE
[16:01:48.196] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:48.196] - relayed: [n=2] TRUE, TRUE
[16:01:48.196] - queued futures: [n=2] TRUE, TRUE
[16:01:48.196] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.196] resolve() on list ... DONE
[16:01:48.196] result() for ClusterFuture ...
[16:01:48.196] - result already collected: FutureResult
[16:01:48.196] result() for ClusterFuture ... done
[16:01:48.196] result() for ClusterFuture ...
[16:01:48.196] - result already collected: FutureResult
[16:01:48.197] result() for ClusterFuture ... done
[16:01:48.197] result() for ClusterFuture ...
[16:01:48.197] - result already collected: FutureResult
[16:01:48.197] result() for ClusterFuture ... done
[16:01:48.197] result() for ClusterFuture ...
[16:01:48.197] - result already collected: FutureResult
[16:01:48.197] result() for ClusterFuture ... done
[16:01:48.197]  - Number of value chunks collected: 2
[16:01:48.197] Resolving 2 futures (chunks) ... DONE
[16:01:48.197] Reducing values from 2 chunks ...
[16:01:48.197]  - Number of values collected after concatenation: 3
[16:01:48.198]  - Number of values expected: 3
[16:01:48.198] Reducing values from 2 chunks ... DONE
[16:01:48.198] future_lapply() ... DONE
[16:01:48.198] future_by_internal() ... DONE
[16:01:48.198] future_by_internal() ...
[16:01:48.199] future_lapply() ...
[16:01:48.203] Number of chunks: 2
[16:01:48.203] getGlobalsAndPackagesXApply() ...
[16:01:48.203]  - future.globals: TRUE
[16:01:48.203] getGlobalsAndPackages() ...
[16:01:48.203] Searching for globals...
[16:01:48.205] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.205] Searching for globals ... DONE
[16:01:48.205] Resolving globals: FALSE
[16:01:48.205] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:48.205] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:48.206] - globals: [1] ‘FUN’
[16:01:48.206] 
[16:01:48.206] getGlobalsAndPackages() ... DONE
[16:01:48.206]  - globals found/used: [n=1] ‘FUN’
[16:01:48.206]  - needed namespaces: [n=0] 
[16:01:48.206] Finding globals ... DONE
[16:01:48.206]  - use_args: TRUE
[16:01:48.206]  - Getting '...' globals ...
[16:01:48.207] resolve() on list ...
[16:01:48.207]  recursive: 0
[16:01:48.207]  length: 1
[16:01:48.207]  elements: ‘...’
[16:01:48.207]  length: 0 (resolved future 1)
[16:01:48.207] resolve() on list ... DONE
[16:01:48.207]    - '...' content: [n=0] 
[16:01:48.207] List of 1
[16:01:48.207]  $ ...: list()
[16:01:48.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.207]  - attr(*, "where")=List of 1
[16:01:48.207]   ..$ ...:<environment: 0x55b5270a6a28> 
[16:01:48.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.207]  - attr(*, "resolved")= logi TRUE
[16:01:48.207]  - attr(*, "total_size")= num NA
[16:01:48.210]  - Getting '...' globals ... DONE
[16:01:48.210] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:48.210] List of 2
[16:01:48.210]  $ ...future.FUN:function (object, ...)  
[16:01:48.210]  $ ...          : list()
[16:01:48.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.210]  - attr(*, "where")=List of 2
[16:01:48.210]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.210]   ..$ ...          :<environment: 0x55b5270a6a28> 
[16:01:48.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.210]  - attr(*, "resolved")= logi FALSE
[16:01:48.210]  - attr(*, "total_size")= num 1240
[16:01:48.213] Packages to be attached in all futures: [n=0] 
[16:01:48.213] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.213] Number of futures (= number of chunks): 2
[16:01:48.213] Launching 2 futures (chunks) ...
[16:01:48.213] Chunk #1 of 2 ...
[16:01:48.213]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.213] getGlobalsAndPackages() ...
[16:01:48.213] Searching for globals...
[16:01:48.214] 
[16:01:48.214] Searching for globals ... DONE
[16:01:48.214] - globals: [0] <none>
[16:01:48.214] getGlobalsAndPackages() ... DONE
[16:01:48.214]    + additional globals found: [n=0] 
[16:01:48.214]    + additional namespaces needed: [n=0] 
[16:01:48.214]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.214]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:48.215]  - seeds: <none>
[16:01:48.215]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.215] getGlobalsAndPackages() ...
[16:01:48.215] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.215] Resolving globals: FALSE
[16:01:48.215] Tweak future expression to call with '...' arguments ...
[16:01:48.215] {
[16:01:48.215]     do.call(function(...) {
[16:01:48.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.215]             on.exit(options(oopts), add = TRUE)
[16:01:48.215]         }
[16:01:48.215]         {
[16:01:48.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.215]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.215]             })
[16:01:48.215]         }
[16:01:48.215]     }, args = future.call.arguments)
[16:01:48.215] }
[16:01:48.215] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.216] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.216] 
[16:01:48.216] getGlobalsAndPackages() ... DONE
[16:01:48.216] run() for ‘Future’ ...
[16:01:48.216] - state: ‘created’
[16:01:48.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:48.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:48.230]   - Field: ‘node’
[16:01:48.231]   - Field: ‘label’
[16:01:48.231]   - Field: ‘local’
[16:01:48.231]   - Field: ‘owner’
[16:01:48.231]   - Field: ‘envir’
[16:01:48.231]   - Field: ‘workers’
[16:01:48.231]   - Field: ‘packages’
[16:01:48.231]   - Field: ‘gc’
[16:01:48.231]   - Field: ‘conditions’
[16:01:48.231]   - Field: ‘persistent’
[16:01:48.231]   - Field: ‘expr’
[16:01:48.232]   - Field: ‘uuid’
[16:01:48.232]   - Field: ‘seed’
[16:01:48.232]   - Field: ‘version’
[16:01:48.232]   - Field: ‘result’
[16:01:48.232]   - Field: ‘asynchronous’
[16:01:48.232]   - Field: ‘calls’
[16:01:48.232]   - Field: ‘globals’
[16:01:48.232]   - Field: ‘stdout’
[16:01:48.232]   - Field: ‘earlySignal’
[16:01:48.232]   - Field: ‘lazy’
[16:01:48.233]   - Field: ‘state’
[16:01:48.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:48.233] - Launch lazy future ...
[16:01:48.233] Packages needed by the future expression (n = 0): <none>
[16:01:48.233] Packages needed by future strategies (n = 0): <none>
[16:01:48.234] {
[16:01:48.234]     {
[16:01:48.234]         {
[16:01:48.234]             ...future.startTime <- base::Sys.time()
[16:01:48.234]             {
[16:01:48.234]                 {
[16:01:48.234]                   {
[16:01:48.234]                     {
[16:01:48.234]                       base::local({
[16:01:48.234]                         has_future <- base::requireNamespace("future", 
[16:01:48.234]                           quietly = TRUE)
[16:01:48.234]                         if (has_future) {
[16:01:48.234]                           ns <- base::getNamespace("future")
[16:01:48.234]                           version <- ns[[".package"]][["version"]]
[16:01:48.234]                           if (is.null(version)) 
[16:01:48.234]                             version <- utils::packageVersion("future")
[16:01:48.234]                         }
[16:01:48.234]                         else {
[16:01:48.234]                           version <- NULL
[16:01:48.234]                         }
[16:01:48.234]                         if (!has_future || version < "1.8.0") {
[16:01:48.234]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.234]                             "", base::R.version$version.string), 
[16:01:48.234]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.234]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.234]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.234]                               "release", "version")], collapse = " "), 
[16:01:48.234]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.234]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.234]                             info)
[16:01:48.234]                           info <- base::paste(info, collapse = "; ")
[16:01:48.234]                           if (!has_future) {
[16:01:48.234]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.234]                               info)
[16:01:48.234]                           }
[16:01:48.234]                           else {
[16:01:48.234]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.234]                               info, version)
[16:01:48.234]                           }
[16:01:48.234]                           base::stop(msg)
[16:01:48.234]                         }
[16:01:48.234]                       })
[16:01:48.234]                     }
[16:01:48.234]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:48.234]                     base::options(mc.cores = 1L)
[16:01:48.234]                   }
[16:01:48.234]                   options(future.plan = NULL)
[16:01:48.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.234]                 }
[16:01:48.234]                 ...future.workdir <- getwd()
[16:01:48.234]             }
[16:01:48.234]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.234]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.234]         }
[16:01:48.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.234]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:48.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.234]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.234]             base::names(...future.oldOptions))
[16:01:48.234]     }
[16:01:48.234]     if (FALSE) {
[16:01:48.234]     }
[16:01:48.234]     else {
[16:01:48.234]         if (TRUE) {
[16:01:48.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.234]                 open = "w")
[16:01:48.234]         }
[16:01:48.234]         else {
[16:01:48.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.234]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.234]         }
[16:01:48.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.234]             base::sink(type = "output", split = FALSE)
[16:01:48.234]             base::close(...future.stdout)
[16:01:48.234]         }, add = TRUE)
[16:01:48.234]     }
[16:01:48.234]     ...future.frame <- base::sys.nframe()
[16:01:48.234]     ...future.conditions <- base::list()
[16:01:48.234]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.234]     if (FALSE) {
[16:01:48.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.234]     }
[16:01:48.234]     ...future.result <- base::tryCatch({
[16:01:48.234]         base::withCallingHandlers({
[16:01:48.234]             ...future.value <- base::withVisible(base::local({
[16:01:48.234]                 ...future.makeSendCondition <- base::local({
[16:01:48.234]                   sendCondition <- NULL
[16:01:48.234]                   function(frame = 1L) {
[16:01:48.234]                     if (is.function(sendCondition)) 
[16:01:48.234]                       return(sendCondition)
[16:01:48.234]                     ns <- getNamespace("parallel")
[16:01:48.234]                     if (exists("sendData", mode = "function", 
[16:01:48.234]                       envir = ns)) {
[16:01:48.234]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:48.234]                         envir = ns)
[16:01:48.234]                       envir <- sys.frame(frame)
[16:01:48.234]                       master <- NULL
[16:01:48.234]                       while (!identical(envir, .GlobalEnv) && 
[16:01:48.234]                         !identical(envir, emptyenv())) {
[16:01:48.234]                         if (exists("master", mode = "list", envir = envir, 
[16:01:48.234]                           inherits = FALSE)) {
[16:01:48.234]                           master <- get("master", mode = "list", 
[16:01:48.234]                             envir = envir, inherits = FALSE)
[16:01:48.234]                           if (inherits(master, c("SOCKnode", 
[16:01:48.234]                             "SOCK0node"))) {
[16:01:48.234]                             sendCondition <<- function(cond) {
[16:01:48.234]                               data <- list(type = "VALUE", value = cond, 
[16:01:48.234]                                 success = TRUE)
[16:01:48.234]                               parallel_sendData(master, data)
[16:01:48.234]                             }
[16:01:48.234]                             return(sendCondition)
[16:01:48.234]                           }
[16:01:48.234]                         }
[16:01:48.234]                         frame <- frame + 1L
[16:01:48.234]                         envir <- sys.frame(frame)
[16:01:48.234]                       }
[16:01:48.234]                     }
[16:01:48.234]                     sendCondition <<- function(cond) NULL
[16:01:48.234]                   }
[16:01:48.234]                 })
[16:01:48.234]                 withCallingHandlers({
[16:01:48.234]                   {
[16:01:48.234]                     do.call(function(...) {
[16:01:48.234]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.234]                       if (!identical(...future.globals.maxSize.org, 
[16:01:48.234]                         ...future.globals.maxSize)) {
[16:01:48.234]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.234]                         on.exit(options(oopts), add = TRUE)
[16:01:48.234]                       }
[16:01:48.234]                       {
[16:01:48.234]                         lapply(seq_along(...future.elements_ii), 
[16:01:48.234]                           FUN = function(jj) {
[16:01:48.234]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.234]                             ...future.FUN(...future.X_jj, ...)
[16:01:48.234]                           })
[16:01:48.234]                       }
[16:01:48.234]                     }, args = future.call.arguments)
[16:01:48.234]                   }
[16:01:48.234]                 }, immediateCondition = function(cond) {
[16:01:48.234]                   sendCondition <- ...future.makeSendCondition()
[16:01:48.234]                   sendCondition(cond)
[16:01:48.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.234]                   {
[16:01:48.234]                     inherits <- base::inherits
[16:01:48.234]                     invokeRestart <- base::invokeRestart
[16:01:48.234]                     is.null <- base::is.null
[16:01:48.234]                     muffled <- FALSE
[16:01:48.234]                     if (inherits(cond, "message")) {
[16:01:48.234]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:48.234]                       if (muffled) 
[16:01:48.234]                         invokeRestart("muffleMessage")
[16:01:48.234]                     }
[16:01:48.234]                     else if (inherits(cond, "warning")) {
[16:01:48.234]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:48.234]                       if (muffled) 
[16:01:48.234]                         invokeRestart("muffleWarning")
[16:01:48.234]                     }
[16:01:48.234]                     else if (inherits(cond, "condition")) {
[16:01:48.234]                       if (!is.null(pattern)) {
[16:01:48.234]                         computeRestarts <- base::computeRestarts
[16:01:48.234]                         grepl <- base::grepl
[16:01:48.234]                         restarts <- computeRestarts(cond)
[16:01:48.234]                         for (restart in restarts) {
[16:01:48.234]                           name <- restart$name
[16:01:48.234]                           if (is.null(name)) 
[16:01:48.234]                             next
[16:01:48.234]                           if (!grepl(pattern, name)) 
[16:01:48.234]                             next
[16:01:48.234]                           invokeRestart(restart)
[16:01:48.234]                           muffled <- TRUE
[16:01:48.234]                           break
[16:01:48.234]                         }
[16:01:48.234]                       }
[16:01:48.234]                     }
[16:01:48.234]                     invisible(muffled)
[16:01:48.234]                   }
[16:01:48.234]                   muffleCondition(cond)
[16:01:48.234]                 })
[16:01:48.234]             }))
[16:01:48.234]             future::FutureResult(value = ...future.value$value, 
[16:01:48.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.234]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.234]                     ...future.globalenv.names))
[16:01:48.234]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.234]         }, condition = base::local({
[16:01:48.234]             c <- base::c
[16:01:48.234]             inherits <- base::inherits
[16:01:48.234]             invokeRestart <- base::invokeRestart
[16:01:48.234]             length <- base::length
[16:01:48.234]             list <- base::list
[16:01:48.234]             seq.int <- base::seq.int
[16:01:48.234]             signalCondition <- base::signalCondition
[16:01:48.234]             sys.calls <- base::sys.calls
[16:01:48.234]             `[[` <- base::`[[`
[16:01:48.234]             `+` <- base::`+`
[16:01:48.234]             `<<-` <- base::`<<-`
[16:01:48.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.234]                   3L)]
[16:01:48.234]             }
[16:01:48.234]             function(cond) {
[16:01:48.234]                 is_error <- inherits(cond, "error")
[16:01:48.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.234]                   NULL)
[16:01:48.234]                 if (is_error) {
[16:01:48.234]                   sessionInformation <- function() {
[16:01:48.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.234]                       search = base::search(), system = base::Sys.info())
[16:01:48.234]                   }
[16:01:48.234]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.234]                     cond$call), session = sessionInformation(), 
[16:01:48.234]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.234]                   signalCondition(cond)
[16:01:48.234]                 }
[16:01:48.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.234]                 "immediateCondition"))) {
[16:01:48.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.234]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.234]                   if (TRUE && !signal) {
[16:01:48.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.234]                     {
[16:01:48.234]                       inherits <- base::inherits
[16:01:48.234]                       invokeRestart <- base::invokeRestart
[16:01:48.234]                       is.null <- base::is.null
[16:01:48.234]                       muffled <- FALSE
[16:01:48.234]                       if (inherits(cond, "message")) {
[16:01:48.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.234]                         if (muffled) 
[16:01:48.234]                           invokeRestart("muffleMessage")
[16:01:48.234]                       }
[16:01:48.234]                       else if (inherits(cond, "warning")) {
[16:01:48.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.234]                         if (muffled) 
[16:01:48.234]                           invokeRestart("muffleWarning")
[16:01:48.234]                       }
[16:01:48.234]                       else if (inherits(cond, "condition")) {
[16:01:48.234]                         if (!is.null(pattern)) {
[16:01:48.234]                           computeRestarts <- base::computeRestarts
[16:01:48.234]                           grepl <- base::grepl
[16:01:48.234]                           restarts <- computeRestarts(cond)
[16:01:48.234]                           for (restart in restarts) {
[16:01:48.234]                             name <- restart$name
[16:01:48.234]                             if (is.null(name)) 
[16:01:48.234]                               next
[16:01:48.234]                             if (!grepl(pattern, name)) 
[16:01:48.234]                               next
[16:01:48.234]                             invokeRestart(restart)
[16:01:48.234]                             muffled <- TRUE
[16:01:48.234]                             break
[16:01:48.234]                           }
[16:01:48.234]                         }
[16:01:48.234]                       }
[16:01:48.234]                       invisible(muffled)
[16:01:48.234]                     }
[16:01:48.234]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.234]                   }
[16:01:48.234]                 }
[16:01:48.234]                 else {
[16:01:48.234]                   if (TRUE) {
[16:01:48.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.234]                     {
[16:01:48.234]                       inherits <- base::inherits
[16:01:48.234]                       invokeRestart <- base::invokeRestart
[16:01:48.234]                       is.null <- base::is.null
[16:01:48.234]                       muffled <- FALSE
[16:01:48.234]                       if (inherits(cond, "message")) {
[16:01:48.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.234]                         if (muffled) 
[16:01:48.234]                           invokeRestart("muffleMessage")
[16:01:48.234]                       }
[16:01:48.234]                       else if (inherits(cond, "warning")) {
[16:01:48.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.234]                         if (muffled) 
[16:01:48.234]                           invokeRestart("muffleWarning")
[16:01:48.234]                       }
[16:01:48.234]                       else if (inherits(cond, "condition")) {
[16:01:48.234]                         if (!is.null(pattern)) {
[16:01:48.234]                           computeRestarts <- base::computeRestarts
[16:01:48.234]                           grepl <- base::grepl
[16:01:48.234]                           restarts <- computeRestarts(cond)
[16:01:48.234]                           for (restart in restarts) {
[16:01:48.234]                             name <- restart$name
[16:01:48.234]                             if (is.null(name)) 
[16:01:48.234]                               next
[16:01:48.234]                             if (!grepl(pattern, name)) 
[16:01:48.234]                               next
[16:01:48.234]                             invokeRestart(restart)
[16:01:48.234]                             muffled <- TRUE
[16:01:48.234]                             break
[16:01:48.234]                           }
[16:01:48.234]                         }
[16:01:48.234]                       }
[16:01:48.234]                       invisible(muffled)
[16:01:48.234]                     }
[16:01:48.234]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.234]                   }
[16:01:48.234]                 }
[16:01:48.234]             }
[16:01:48.234]         }))
[16:01:48.234]     }, error = function(ex) {
[16:01:48.234]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.234]                 ...future.rng), started = ...future.startTime, 
[16:01:48.234]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.234]             version = "1.8"), class = "FutureResult")
[16:01:48.234]     }, finally = {
[16:01:48.234]         if (!identical(...future.workdir, getwd())) 
[16:01:48.234]             setwd(...future.workdir)
[16:01:48.234]         {
[16:01:48.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.234]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.234]             }
[16:01:48.234]             base::options(...future.oldOptions)
[16:01:48.234]             if (.Platform$OS.type == "windows") {
[16:01:48.234]                 old_names <- names(...future.oldEnvVars)
[16:01:48.234]                 envs <- base::Sys.getenv()
[16:01:48.234]                 names <- names(envs)
[16:01:48.234]                 common <- intersect(names, old_names)
[16:01:48.234]                 added <- setdiff(names, old_names)
[16:01:48.234]                 removed <- setdiff(old_names, names)
[16:01:48.234]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.234]                   envs[common]]
[16:01:48.234]                 NAMES <- toupper(changed)
[16:01:48.234]                 args <- list()
[16:01:48.234]                 for (kk in seq_along(NAMES)) {
[16:01:48.234]                   name <- changed[[kk]]
[16:01:48.234]                   NAME <- NAMES[[kk]]
[16:01:48.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.234]                     next
[16:01:48.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.234]                 }
[16:01:48.234]                 NAMES <- toupper(added)
[16:01:48.234]                 for (kk in seq_along(NAMES)) {
[16:01:48.234]                   name <- added[[kk]]
[16:01:48.234]                   NAME <- NAMES[[kk]]
[16:01:48.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.234]                     next
[16:01:48.234]                   args[[name]] <- ""
[16:01:48.234]                 }
[16:01:48.234]                 NAMES <- toupper(removed)
[16:01:48.234]                 for (kk in seq_along(NAMES)) {
[16:01:48.234]                   name <- removed[[kk]]
[16:01:48.234]                   NAME <- NAMES[[kk]]
[16:01:48.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.234]                     next
[16:01:48.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.234]                 }
[16:01:48.234]                 if (length(args) > 0) 
[16:01:48.234]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.234]             }
[16:01:48.234]             else {
[16:01:48.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.234]             }
[16:01:48.234]             {
[16:01:48.234]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.234]                   0L) {
[16:01:48.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.234]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.234]                   base::options(opts)
[16:01:48.234]                 }
[16:01:48.234]                 {
[16:01:48.234]                   {
[16:01:48.234]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:48.234]                     NULL
[16:01:48.234]                   }
[16:01:48.234]                   options(future.plan = NULL)
[16:01:48.234]                   if (is.na(NA_character_)) 
[16:01:48.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.234]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:48.234]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:48.234]                     envir = parent.frame()) 
[16:01:48.234]                   {
[16:01:48.234]                     if (is.function(workers)) 
[16:01:48.234]                       workers <- workers()
[16:01:48.234]                     workers <- structure(as.integer(workers), 
[16:01:48.234]                       class = class(workers))
[16:01:48.234]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:48.234]                       workers >= 1)
[16:01:48.234]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:48.234]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:48.234]                     }
[16:01:48.234]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:48.234]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:48.234]                       envir = envir)
[16:01:48.234]                     if (!future$lazy) 
[16:01:48.234]                       future <- run(future)
[16:01:48.234]                     invisible(future)
[16:01:48.234]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.234]                 }
[16:01:48.234]             }
[16:01:48.234]         }
[16:01:48.234]     })
[16:01:48.234]     if (TRUE) {
[16:01:48.234]         base::sink(type = "output", split = FALSE)
[16:01:48.234]         if (TRUE) {
[16:01:48.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.234]         }
[16:01:48.234]         else {
[16:01:48.234]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.234]         }
[16:01:48.234]         base::close(...future.stdout)
[16:01:48.234]         ...future.stdout <- NULL
[16:01:48.234]     }
[16:01:48.234]     ...future.result$conditions <- ...future.conditions
[16:01:48.234]     ...future.result$finished <- base::Sys.time()
[16:01:48.234]     ...future.result
[16:01:48.234] }
[16:01:48.236] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:01:48.237] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:01:48.237] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:01:48.237] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:48.238] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.238] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:01:48.238] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:01:48.238] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:48.238] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:48.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.239] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:01:48.240] MultisessionFuture started
[16:01:48.240] - Launch lazy future ... done
[16:01:48.240] run() for ‘MultisessionFuture’ ... done
[16:01:48.240] Created future:
[16:01:48.240] MultisessionFuture:
[16:01:48.240] Label: ‘future_by-1’
[16:01:48.240] Expression:
[16:01:48.240] {
[16:01:48.240]     do.call(function(...) {
[16:01:48.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.240]             on.exit(options(oopts), add = TRUE)
[16:01:48.240]         }
[16:01:48.240]         {
[16:01:48.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.240]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.240]             })
[16:01:48.240]         }
[16:01:48.240]     }, args = future.call.arguments)
[16:01:48.240] }
[16:01:48.240] Lazy evaluation: FALSE
[16:01:48.240] Asynchronous evaluation: TRUE
[16:01:48.240] Local evaluation: TRUE
[16:01:48.240] Environment: 0x55b5270d5138
[16:01:48.240] Capture standard output: TRUE
[16:01:48.240] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.240] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.240] Packages: <none>
[16:01:48.240] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.240] Resolved: FALSE
[16:01:48.240] Value: <not collected>
[16:01:48.240] Conditions captured: <none>
[16:01:48.240] Early signaling: FALSE
[16:01:48.240] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:48.240] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.252] Chunk #1 of 2 ... DONE
[16:01:48.252] Chunk #2 of 2 ...
[16:01:48.252]  - Finding globals in 'X' for chunk #2 ...
[16:01:48.252] getGlobalsAndPackages() ...
[16:01:48.252] Searching for globals...
[16:01:48.253] 
[16:01:48.253] Searching for globals ... DONE
[16:01:48.253] - globals: [0] <none>
[16:01:48.253] getGlobalsAndPackages() ... DONE
[16:01:48.253]    + additional globals found: [n=0] 
[16:01:48.253]    + additional namespaces needed: [n=0] 
[16:01:48.253]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:48.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:48.253]  - seeds: <none>
[16:01:48.253]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.254] getGlobalsAndPackages() ...
[16:01:48.254] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.254] Resolving globals: FALSE
[16:01:48.254] Tweak future expression to call with '...' arguments ...
[16:01:48.254] {
[16:01:48.254]     do.call(function(...) {
[16:01:48.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.254]             on.exit(options(oopts), add = TRUE)
[16:01:48.254]         }
[16:01:48.254]         {
[16:01:48.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.254]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.254]             })
[16:01:48.254]         }
[16:01:48.254]     }, args = future.call.arguments)
[16:01:48.254] }
[16:01:48.254] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.255] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.255] 
[16:01:48.255] getGlobalsAndPackages() ... DONE
[16:01:48.255] run() for ‘Future’ ...
[16:01:48.255] - state: ‘created’
[16:01:48.255] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:48.271] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:48.271]   - Field: ‘node’
[16:01:48.272]   - Field: ‘label’
[16:01:48.272]   - Field: ‘local’
[16:01:48.272]   - Field: ‘owner’
[16:01:48.272]   - Field: ‘envir’
[16:01:48.272]   - Field: ‘workers’
[16:01:48.272]   - Field: ‘packages’
[16:01:48.272]   - Field: ‘gc’
[16:01:48.272]   - Field: ‘conditions’
[16:01:48.272]   - Field: ‘persistent’
[16:01:48.272]   - Field: ‘expr’
[16:01:48.273]   - Field: ‘uuid’
[16:01:48.273]   - Field: ‘seed’
[16:01:48.273]   - Field: ‘version’
[16:01:48.273]   - Field: ‘result’
[16:01:48.273]   - Field: ‘asynchronous’
[16:01:48.273]   - Field: ‘calls’
[16:01:48.273]   - Field: ‘globals’
[16:01:48.273]   - Field: ‘stdout’
[16:01:48.273]   - Field: ‘earlySignal’
[16:01:48.273]   - Field: ‘lazy’
[16:01:48.273]   - Field: ‘state’
[16:01:48.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:48.274] - Launch lazy future ...
[16:01:48.274] Packages needed by the future expression (n = 0): <none>
[16:01:48.274] Packages needed by future strategies (n = 0): <none>
[16:01:48.274] {
[16:01:48.274]     {
[16:01:48.274]         {
[16:01:48.274]             ...future.startTime <- base::Sys.time()
[16:01:48.274]             {
[16:01:48.274]                 {
[16:01:48.274]                   {
[16:01:48.274]                     {
[16:01:48.274]                       base::local({
[16:01:48.274]                         has_future <- base::requireNamespace("future", 
[16:01:48.274]                           quietly = TRUE)
[16:01:48.274]                         if (has_future) {
[16:01:48.274]                           ns <- base::getNamespace("future")
[16:01:48.274]                           version <- ns[[".package"]][["version"]]
[16:01:48.274]                           if (is.null(version)) 
[16:01:48.274]                             version <- utils::packageVersion("future")
[16:01:48.274]                         }
[16:01:48.274]                         else {
[16:01:48.274]                           version <- NULL
[16:01:48.274]                         }
[16:01:48.274]                         if (!has_future || version < "1.8.0") {
[16:01:48.274]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.274]                             "", base::R.version$version.string), 
[16:01:48.274]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.274]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.274]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.274]                               "release", "version")], collapse = " "), 
[16:01:48.274]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.274]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.274]                             info)
[16:01:48.274]                           info <- base::paste(info, collapse = "; ")
[16:01:48.274]                           if (!has_future) {
[16:01:48.274]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.274]                               info)
[16:01:48.274]                           }
[16:01:48.274]                           else {
[16:01:48.274]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.274]                               info, version)
[16:01:48.274]                           }
[16:01:48.274]                           base::stop(msg)
[16:01:48.274]                         }
[16:01:48.274]                       })
[16:01:48.274]                     }
[16:01:48.274]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:48.274]                     base::options(mc.cores = 1L)
[16:01:48.274]                   }
[16:01:48.274]                   options(future.plan = NULL)
[16:01:48.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.274]                 }
[16:01:48.274]                 ...future.workdir <- getwd()
[16:01:48.274]             }
[16:01:48.274]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.274]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.274]         }
[16:01:48.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.274]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:48.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.274]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.274]             base::names(...future.oldOptions))
[16:01:48.274]     }
[16:01:48.274]     if (FALSE) {
[16:01:48.274]     }
[16:01:48.274]     else {
[16:01:48.274]         if (TRUE) {
[16:01:48.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.274]                 open = "w")
[16:01:48.274]         }
[16:01:48.274]         else {
[16:01:48.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.274]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.274]         }
[16:01:48.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.274]             base::sink(type = "output", split = FALSE)
[16:01:48.274]             base::close(...future.stdout)
[16:01:48.274]         }, add = TRUE)
[16:01:48.274]     }
[16:01:48.274]     ...future.frame <- base::sys.nframe()
[16:01:48.274]     ...future.conditions <- base::list()
[16:01:48.274]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.274]     if (FALSE) {
[16:01:48.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.274]     }
[16:01:48.274]     ...future.result <- base::tryCatch({
[16:01:48.274]         base::withCallingHandlers({
[16:01:48.274]             ...future.value <- base::withVisible(base::local({
[16:01:48.274]                 ...future.makeSendCondition <- base::local({
[16:01:48.274]                   sendCondition <- NULL
[16:01:48.274]                   function(frame = 1L) {
[16:01:48.274]                     if (is.function(sendCondition)) 
[16:01:48.274]                       return(sendCondition)
[16:01:48.274]                     ns <- getNamespace("parallel")
[16:01:48.274]                     if (exists("sendData", mode = "function", 
[16:01:48.274]                       envir = ns)) {
[16:01:48.274]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:48.274]                         envir = ns)
[16:01:48.274]                       envir <- sys.frame(frame)
[16:01:48.274]                       master <- NULL
[16:01:48.274]                       while (!identical(envir, .GlobalEnv) && 
[16:01:48.274]                         !identical(envir, emptyenv())) {
[16:01:48.274]                         if (exists("master", mode = "list", envir = envir, 
[16:01:48.274]                           inherits = FALSE)) {
[16:01:48.274]                           master <- get("master", mode = "list", 
[16:01:48.274]                             envir = envir, inherits = FALSE)
[16:01:48.274]                           if (inherits(master, c("SOCKnode", 
[16:01:48.274]                             "SOCK0node"))) {
[16:01:48.274]                             sendCondition <<- function(cond) {
[16:01:48.274]                               data <- list(type = "VALUE", value = cond, 
[16:01:48.274]                                 success = TRUE)
[16:01:48.274]                               parallel_sendData(master, data)
[16:01:48.274]                             }
[16:01:48.274]                             return(sendCondition)
[16:01:48.274]                           }
[16:01:48.274]                         }
[16:01:48.274]                         frame <- frame + 1L
[16:01:48.274]                         envir <- sys.frame(frame)
[16:01:48.274]                       }
[16:01:48.274]                     }
[16:01:48.274]                     sendCondition <<- function(cond) NULL
[16:01:48.274]                   }
[16:01:48.274]                 })
[16:01:48.274]                 withCallingHandlers({
[16:01:48.274]                   {
[16:01:48.274]                     do.call(function(...) {
[16:01:48.274]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.274]                       if (!identical(...future.globals.maxSize.org, 
[16:01:48.274]                         ...future.globals.maxSize)) {
[16:01:48.274]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.274]                         on.exit(options(oopts), add = TRUE)
[16:01:48.274]                       }
[16:01:48.274]                       {
[16:01:48.274]                         lapply(seq_along(...future.elements_ii), 
[16:01:48.274]                           FUN = function(jj) {
[16:01:48.274]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.274]                             ...future.FUN(...future.X_jj, ...)
[16:01:48.274]                           })
[16:01:48.274]                       }
[16:01:48.274]                     }, args = future.call.arguments)
[16:01:48.274]                   }
[16:01:48.274]                 }, immediateCondition = function(cond) {
[16:01:48.274]                   sendCondition <- ...future.makeSendCondition()
[16:01:48.274]                   sendCondition(cond)
[16:01:48.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.274]                   {
[16:01:48.274]                     inherits <- base::inherits
[16:01:48.274]                     invokeRestart <- base::invokeRestart
[16:01:48.274]                     is.null <- base::is.null
[16:01:48.274]                     muffled <- FALSE
[16:01:48.274]                     if (inherits(cond, "message")) {
[16:01:48.274]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:48.274]                       if (muffled) 
[16:01:48.274]                         invokeRestart("muffleMessage")
[16:01:48.274]                     }
[16:01:48.274]                     else if (inherits(cond, "warning")) {
[16:01:48.274]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:48.274]                       if (muffled) 
[16:01:48.274]                         invokeRestart("muffleWarning")
[16:01:48.274]                     }
[16:01:48.274]                     else if (inherits(cond, "condition")) {
[16:01:48.274]                       if (!is.null(pattern)) {
[16:01:48.274]                         computeRestarts <- base::computeRestarts
[16:01:48.274]                         grepl <- base::grepl
[16:01:48.274]                         restarts <- computeRestarts(cond)
[16:01:48.274]                         for (restart in restarts) {
[16:01:48.274]                           name <- restart$name
[16:01:48.274]                           if (is.null(name)) 
[16:01:48.274]                             next
[16:01:48.274]                           if (!grepl(pattern, name)) 
[16:01:48.274]                             next
[16:01:48.274]                           invokeRestart(restart)
[16:01:48.274]                           muffled <- TRUE
[16:01:48.274]                           break
[16:01:48.274]                         }
[16:01:48.274]                       }
[16:01:48.274]                     }
[16:01:48.274]                     invisible(muffled)
[16:01:48.274]                   }
[16:01:48.274]                   muffleCondition(cond)
[16:01:48.274]                 })
[16:01:48.274]             }))
[16:01:48.274]             future::FutureResult(value = ...future.value$value, 
[16:01:48.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.274]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.274]                     ...future.globalenv.names))
[16:01:48.274]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.274]         }, condition = base::local({
[16:01:48.274]             c <- base::c
[16:01:48.274]             inherits <- base::inherits
[16:01:48.274]             invokeRestart <- base::invokeRestart
[16:01:48.274]             length <- base::length
[16:01:48.274]             list <- base::list
[16:01:48.274]             seq.int <- base::seq.int
[16:01:48.274]             signalCondition <- base::signalCondition
[16:01:48.274]             sys.calls <- base::sys.calls
[16:01:48.274]             `[[` <- base::`[[`
[16:01:48.274]             `+` <- base::`+`
[16:01:48.274]             `<<-` <- base::`<<-`
[16:01:48.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.274]                   3L)]
[16:01:48.274]             }
[16:01:48.274]             function(cond) {
[16:01:48.274]                 is_error <- inherits(cond, "error")
[16:01:48.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.274]                   NULL)
[16:01:48.274]                 if (is_error) {
[16:01:48.274]                   sessionInformation <- function() {
[16:01:48.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.274]                       search = base::search(), system = base::Sys.info())
[16:01:48.274]                   }
[16:01:48.274]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.274]                     cond$call), session = sessionInformation(), 
[16:01:48.274]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.274]                   signalCondition(cond)
[16:01:48.274]                 }
[16:01:48.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.274]                 "immediateCondition"))) {
[16:01:48.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.274]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.274]                   if (TRUE && !signal) {
[16:01:48.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.274]                     {
[16:01:48.274]                       inherits <- base::inherits
[16:01:48.274]                       invokeRestart <- base::invokeRestart
[16:01:48.274]                       is.null <- base::is.null
[16:01:48.274]                       muffled <- FALSE
[16:01:48.274]                       if (inherits(cond, "message")) {
[16:01:48.274]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.274]                         if (muffled) 
[16:01:48.274]                           invokeRestart("muffleMessage")
[16:01:48.274]                       }
[16:01:48.274]                       else if (inherits(cond, "warning")) {
[16:01:48.274]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.274]                         if (muffled) 
[16:01:48.274]                           invokeRestart("muffleWarning")
[16:01:48.274]                       }
[16:01:48.274]                       else if (inherits(cond, "condition")) {
[16:01:48.274]                         if (!is.null(pattern)) {
[16:01:48.274]                           computeRestarts <- base::computeRestarts
[16:01:48.274]                           grepl <- base::grepl
[16:01:48.274]                           restarts <- computeRestarts(cond)
[16:01:48.274]                           for (restart in restarts) {
[16:01:48.274]                             name <- restart$name
[16:01:48.274]                             if (is.null(name)) 
[16:01:48.274]                               next
[16:01:48.274]                             if (!grepl(pattern, name)) 
[16:01:48.274]                               next
[16:01:48.274]                             invokeRestart(restart)
[16:01:48.274]                             muffled <- TRUE
[16:01:48.274]                             break
[16:01:48.274]                           }
[16:01:48.274]                         }
[16:01:48.274]                       }
[16:01:48.274]                       invisible(muffled)
[16:01:48.274]                     }
[16:01:48.274]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.274]                   }
[16:01:48.274]                 }
[16:01:48.274]                 else {
[16:01:48.274]                   if (TRUE) {
[16:01:48.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.274]                     {
[16:01:48.274]                       inherits <- base::inherits
[16:01:48.274]                       invokeRestart <- base::invokeRestart
[16:01:48.274]                       is.null <- base::is.null
[16:01:48.274]                       muffled <- FALSE
[16:01:48.274]                       if (inherits(cond, "message")) {
[16:01:48.274]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.274]                         if (muffled) 
[16:01:48.274]                           invokeRestart("muffleMessage")
[16:01:48.274]                       }
[16:01:48.274]                       else if (inherits(cond, "warning")) {
[16:01:48.274]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.274]                         if (muffled) 
[16:01:48.274]                           invokeRestart("muffleWarning")
[16:01:48.274]                       }
[16:01:48.274]                       else if (inherits(cond, "condition")) {
[16:01:48.274]                         if (!is.null(pattern)) {
[16:01:48.274]                           computeRestarts <- base::computeRestarts
[16:01:48.274]                           grepl <- base::grepl
[16:01:48.274]                           restarts <- computeRestarts(cond)
[16:01:48.274]                           for (restart in restarts) {
[16:01:48.274]                             name <- restart$name
[16:01:48.274]                             if (is.null(name)) 
[16:01:48.274]                               next
[16:01:48.274]                             if (!grepl(pattern, name)) 
[16:01:48.274]                               next
[16:01:48.274]                             invokeRestart(restart)
[16:01:48.274]                             muffled <- TRUE
[16:01:48.274]                             break
[16:01:48.274]                           }
[16:01:48.274]                         }
[16:01:48.274]                       }
[16:01:48.274]                       invisible(muffled)
[16:01:48.274]                     }
[16:01:48.274]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.274]                   }
[16:01:48.274]                 }
[16:01:48.274]             }
[16:01:48.274]         }))
[16:01:48.274]     }, error = function(ex) {
[16:01:48.274]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.274]                 ...future.rng), started = ...future.startTime, 
[16:01:48.274]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.274]             version = "1.8"), class = "FutureResult")
[16:01:48.274]     }, finally = {
[16:01:48.274]         if (!identical(...future.workdir, getwd())) 
[16:01:48.274]             setwd(...future.workdir)
[16:01:48.274]         {
[16:01:48.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.274]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.274]             }
[16:01:48.274]             base::options(...future.oldOptions)
[16:01:48.274]             if (.Platform$OS.type == "windows") {
[16:01:48.274]                 old_names <- names(...future.oldEnvVars)
[16:01:48.274]                 envs <- base::Sys.getenv()
[16:01:48.274]                 names <- names(envs)
[16:01:48.274]                 common <- intersect(names, old_names)
[16:01:48.274]                 added <- setdiff(names, old_names)
[16:01:48.274]                 removed <- setdiff(old_names, names)
[16:01:48.274]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.274]                   envs[common]]
[16:01:48.274]                 NAMES <- toupper(changed)
[16:01:48.274]                 args <- list()
[16:01:48.274]                 for (kk in seq_along(NAMES)) {
[16:01:48.274]                   name <- changed[[kk]]
[16:01:48.274]                   NAME <- NAMES[[kk]]
[16:01:48.274]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.274]                     next
[16:01:48.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.274]                 }
[16:01:48.274]                 NAMES <- toupper(added)
[16:01:48.274]                 for (kk in seq_along(NAMES)) {
[16:01:48.274]                   name <- added[[kk]]
[16:01:48.274]                   NAME <- NAMES[[kk]]
[16:01:48.274]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.274]                     next
[16:01:48.274]                   args[[name]] <- ""
[16:01:48.274]                 }
[16:01:48.274]                 NAMES <- toupper(removed)
[16:01:48.274]                 for (kk in seq_along(NAMES)) {
[16:01:48.274]                   name <- removed[[kk]]
[16:01:48.274]                   NAME <- NAMES[[kk]]
[16:01:48.274]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.274]                     next
[16:01:48.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.274]                 }
[16:01:48.274]                 if (length(args) > 0) 
[16:01:48.274]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.274]             }
[16:01:48.274]             else {
[16:01:48.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.274]             }
[16:01:48.274]             {
[16:01:48.274]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.274]                   0L) {
[16:01:48.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.274]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.274]                   base::options(opts)
[16:01:48.274]                 }
[16:01:48.274]                 {
[16:01:48.274]                   {
[16:01:48.274]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:48.274]                     NULL
[16:01:48.274]                   }
[16:01:48.274]                   options(future.plan = NULL)
[16:01:48.274]                   if (is.na(NA_character_)) 
[16:01:48.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.274]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:48.274]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:48.274]                     envir = parent.frame()) 
[16:01:48.274]                   {
[16:01:48.274]                     if (is.function(workers)) 
[16:01:48.274]                       workers <- workers()
[16:01:48.274]                     workers <- structure(as.integer(workers), 
[16:01:48.274]                       class = class(workers))
[16:01:48.274]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:48.274]                       workers >= 1)
[16:01:48.274]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:48.274]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:48.274]                     }
[16:01:48.274]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:48.274]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:48.274]                       envir = envir)
[16:01:48.274]                     if (!future$lazy) 
[16:01:48.274]                       future <- run(future)
[16:01:48.274]                     invisible(future)
[16:01:48.274]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.274]                 }
[16:01:48.274]             }
[16:01:48.274]         }
[16:01:48.274]     })
[16:01:48.274]     if (TRUE) {
[16:01:48.274]         base::sink(type = "output", split = FALSE)
[16:01:48.274]         if (TRUE) {
[16:01:48.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.274]         }
[16:01:48.274]         else {
[16:01:48.274]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.274]         }
[16:01:48.274]         base::close(...future.stdout)
[16:01:48.274]         ...future.stdout <- NULL
[16:01:48.274]     }
[16:01:48.274]     ...future.result$conditions <- ...future.conditions
[16:01:48.274]     ...future.result$finished <- base::Sys.time()
[16:01:48.274]     ...future.result
[16:01:48.274] }
[16:01:48.278] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:01:48.278] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:01:48.278] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:01:48.278] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:48.279] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.279] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:01:48.279] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:01:48.279] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:48.280] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.280] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:48.280] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.280] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:01:48.281] MultisessionFuture started
[16:01:48.281] - Launch lazy future ... done
[16:01:48.281] run() for ‘MultisessionFuture’ ... done
[16:01:48.281] Created future:
[16:01:48.281] MultisessionFuture:
[16:01:48.281] Label: ‘future_by-2’
[16:01:48.281] Expression:
[16:01:48.281] {
[16:01:48.281]     do.call(function(...) {
[16:01:48.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.281]             on.exit(options(oopts), add = TRUE)
[16:01:48.281]         }
[16:01:48.281]         {
[16:01:48.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.281]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.281]             })
[16:01:48.281]         }
[16:01:48.281]     }, args = future.call.arguments)
[16:01:48.281] }
[16:01:48.281] Lazy evaluation: FALSE
[16:01:48.281] Asynchronous evaluation: TRUE
[16:01:48.281] Local evaluation: TRUE
[16:01:48.281] Environment: 0x55b5270d5138
[16:01:48.281] Capture standard output: TRUE
[16:01:48.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.281] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.281] Packages: <none>
[16:01:48.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.281] Resolved: FALSE
[16:01:48.281] Value: <not collected>
[16:01:48.281] Conditions captured: <none>
[16:01:48.281] Early signaling: FALSE
[16:01:48.281] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:48.281] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.296] Chunk #2 of 2 ... DONE
[16:01:48.296] Launching 2 futures (chunks) ... DONE
[16:01:48.296] Resolving 2 futures (chunks) ...
[16:01:48.296] resolve() on list ...
[16:01:48.296]  recursive: 0
[16:01:48.296]  length: 2
[16:01:48.296] 
[16:01:48.297] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.297] - Validating connection of MultisessionFuture
[16:01:48.297] - received message: FutureResult
[16:01:48.297] - Received FutureResult
[16:01:48.297] - Erased future from FutureRegistry
[16:01:48.297] result() for ClusterFuture ...
[16:01:48.297] - result already collected: FutureResult
[16:01:48.298] result() for ClusterFuture ... done
[16:01:48.298] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.298] Future #1
[16:01:48.298] result() for ClusterFuture ...
[16:01:48.298] - result already collected: FutureResult
[16:01:48.298] result() for ClusterFuture ... done
[16:01:48.298] result() for ClusterFuture ...
[16:01:48.298] - result already collected: FutureResult
[16:01:48.298] result() for ClusterFuture ... done
[16:01:48.298] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:48.298] - nx: 2
[16:01:48.299] - relay: TRUE
[16:01:48.299] - stdout: TRUE
[16:01:48.299] - signal: TRUE
[16:01:48.299] - resignal: FALSE
[16:01:48.299] - force: TRUE
[16:01:48.299] - relayed: [n=2] FALSE, FALSE
[16:01:48.299] - queued futures: [n=2] FALSE, FALSE
[16:01:48.299]  - until=1
[16:01:48.299]  - relaying element #1
[16:01:48.299] result() for ClusterFuture ...
[16:01:48.299] - result already collected: FutureResult
[16:01:48.300] result() for ClusterFuture ... done
[16:01:48.300] result() for ClusterFuture ...
[16:01:48.300] - result already collected: FutureResult
[16:01:48.300] result() for ClusterFuture ... done
[16:01:48.300] result() for ClusterFuture ...
[16:01:48.300] - result already collected: FutureResult
[16:01:48.300] result() for ClusterFuture ... done
[16:01:48.300] result() for ClusterFuture ...
[16:01:48.300] - result already collected: FutureResult
[16:01:48.300] result() for ClusterFuture ... done
[16:01:48.300] - relayed: [n=2] TRUE, FALSE
[16:01:48.300] - queued futures: [n=2] TRUE, FALSE
[16:01:48.301] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:48.301]  length: 1 (resolved future 1)
[16:01:48.329] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.329] - Validating connection of MultisessionFuture
[16:01:48.329] - received message: FutureResult
[16:01:48.329] - Received FutureResult
[16:01:48.329] - Erased future from FutureRegistry
[16:01:48.329] result() for ClusterFuture ...
[16:01:48.329] - result already collected: FutureResult
[16:01:48.330] result() for ClusterFuture ... done
[16:01:48.330] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.330] Future #2
[16:01:48.330] result() for ClusterFuture ...
[16:01:48.330] - result already collected: FutureResult
[16:01:48.330] result() for ClusterFuture ... done
[16:01:48.330] result() for ClusterFuture ...
[16:01:48.330] - result already collected: FutureResult
[16:01:48.330] result() for ClusterFuture ... done
[16:01:48.330] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:48.330] - nx: 2
[16:01:48.331] - relay: TRUE
[16:01:48.331] - stdout: TRUE
[16:01:48.331] - signal: TRUE
[16:01:48.331] - resignal: FALSE
[16:01:48.331] - force: TRUE
[16:01:48.331] - relayed: [n=2] TRUE, FALSE
[16:01:48.331] - queued futures: [n=2] TRUE, FALSE
[16:01:48.331]  - until=2
[16:01:48.331]  - relaying element #2
[16:01:48.331] result() for ClusterFuture ...
[16:01:48.331] - result already collected: FutureResult
[16:01:48.332] result() for ClusterFuture ... done
[16:01:48.332] result() for ClusterFuture ...
[16:01:48.332] - result already collected: FutureResult
[16:01:48.332] result() for ClusterFuture ... done
[16:01:48.332] result() for ClusterFuture ...
[16:01:48.332] - result already collected: FutureResult
[16:01:48.332] result() for ClusterFuture ... done
[16:01:48.332] result() for ClusterFuture ...
[16:01:48.332] - result already collected: FutureResult
[16:01:48.332] result() for ClusterFuture ... done
[16:01:48.332] - relayed: [n=2] TRUE, TRUE
[16:01:48.332] - queued futures: [n=2] TRUE, TRUE
[16:01:48.333] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:48.333]  length: 0 (resolved future 2)
[16:01:48.333] Relaying remaining futures
[16:01:48.333] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.333] - nx: 2
[16:01:48.333] - relay: TRUE
[16:01:48.333] - stdout: TRUE
[16:01:48.333] - signal: TRUE
[16:01:48.333] - resignal: FALSE
[16:01:48.333] - force: TRUE
[16:01:48.333] - relayed: [n=2] TRUE, TRUE
[16:01:48.333] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:48.334] - relayed: [n=2] TRUE, TRUE
[16:01:48.334] - queued futures: [n=2] TRUE, TRUE
[16:01:48.334] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.334] resolve() on list ... DONE
[16:01:48.334] result() for ClusterFuture ...
[16:01:48.334] - result already collected: FutureResult
[16:01:48.334] result() for ClusterFuture ... done
[16:01:48.334] result() for ClusterFuture ...
[16:01:48.334] - result already collected: FutureResult
[16:01:48.334] result() for ClusterFuture ... done
[16:01:48.334] result() for ClusterFuture ...
[16:01:48.335] - result already collected: FutureResult
[16:01:48.335] result() for ClusterFuture ... done
[16:01:48.335] result() for ClusterFuture ...
[16:01:48.335] - result already collected: FutureResult
[16:01:48.335] result() for ClusterFuture ... done
[16:01:48.335]  - Number of value chunks collected: 2
[16:01:48.335] Resolving 2 futures (chunks) ... DONE
[16:01:48.335] Reducing values from 2 chunks ...
[16:01:48.335]  - Number of values collected after concatenation: 3
[16:01:48.335]  - Number of values expected: 3
[16:01:48.335] Reducing values from 2 chunks ... DONE
[16:01:48.336] future_lapply() ... DONE
[16:01:48.336] future_by_internal() ... DONE
[16:01:48.336] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:01:48.337] future_lapply() ...
[16:01:48.341] Number of chunks: 2
[16:01:48.341] getGlobalsAndPackagesXApply() ...
[16:01:48.341]  - future.globals: TRUE
[16:01:48.341] getGlobalsAndPackages() ...
[16:01:48.341] Searching for globals...
[16:01:48.342] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:48.342] Searching for globals ... DONE
[16:01:48.342] Resolving globals: FALSE
[16:01:48.343] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:01:48.343] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:01:48.343] - globals: [1] ‘FUN’
[16:01:48.343] 
[16:01:48.343] getGlobalsAndPackages() ... DONE
[16:01:48.344]  - globals found/used: [n=1] ‘FUN’
[16:01:48.344]  - needed namespaces: [n=0] 
[16:01:48.344] Finding globals ... DONE
[16:01:48.344]  - use_args: TRUE
[16:01:48.344]  - Getting '...' globals ...
[16:01:48.344] resolve() on list ...
[16:01:48.344]  recursive: 0
[16:01:48.344]  length: 1
[16:01:48.344]  elements: ‘...’
[16:01:48.345]  length: 0 (resolved future 1)
[16:01:48.345] resolve() on list ... DONE
[16:01:48.345]    - '...' content: [n=0] 
[16:01:48.345] List of 1
[16:01:48.345]  $ ...: list()
[16:01:48.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.345]  - attr(*, "where")=List of 1
[16:01:48.345]   ..$ ...:<environment: 0x55b52795d610> 
[16:01:48.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.345]  - attr(*, "resolved")= logi TRUE
[16:01:48.345]  - attr(*, "total_size")= num NA
[16:01:48.347]  - Getting '...' globals ... DONE
[16:01:48.348] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:48.348] List of 2
[16:01:48.348]  $ ...future.FUN:function (object, ...)  
[16:01:48.348]  $ ...          : list()
[16:01:48.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:48.348]  - attr(*, "where")=List of 2
[16:01:48.348]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:48.348]   ..$ ...          :<environment: 0x55b52795d610> 
[16:01:48.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:48.348]  - attr(*, "resolved")= logi FALSE
[16:01:48.348]  - attr(*, "total_size")= num 1240
[16:01:48.350] Packages to be attached in all futures: [n=0] 
[16:01:48.350] getGlobalsAndPackagesXApply() ... DONE
[16:01:48.350] Number of futures (= number of chunks): 2
[16:01:48.351] Launching 2 futures (chunks) ...
[16:01:48.351] Chunk #1 of 2 ...
[16:01:48.351]  - Finding globals in 'X' for chunk #1 ...
[16:01:48.351] getGlobalsAndPackages() ...
[16:01:48.351] Searching for globals...
[16:01:48.351] 
[16:01:48.351] Searching for globals ... DONE
[16:01:48.352] - globals: [0] <none>
[16:01:48.352] getGlobalsAndPackages() ... DONE
[16:01:48.352]    + additional globals found: [n=0] 
[16:01:48.352]    + additional namespaces needed: [n=0] 
[16:01:48.352]  - Finding globals in 'X' for chunk #1 ... DONE
[16:01:48.352]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:48.352]  - seeds: <none>
[16:01:48.352]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.352] getGlobalsAndPackages() ...
[16:01:48.352] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.352] Resolving globals: FALSE
[16:01:48.353] Tweak future expression to call with '...' arguments ...
[16:01:48.353] {
[16:01:48.353]     do.call(function(...) {
[16:01:48.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.353]             on.exit(options(oopts), add = TRUE)
[16:01:48.353]         }
[16:01:48.353]         {
[16:01:48.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.353]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.353]             })
[16:01:48.353]         }
[16:01:48.353]     }, args = future.call.arguments)
[16:01:48.353] }
[16:01:48.353] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.353] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.353] 
[16:01:48.353] getGlobalsAndPackages() ... DONE
[16:01:48.354] run() for ‘Future’ ...
[16:01:48.354] - state: ‘created’
[16:01:48.354] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:48.367] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:48.368]   - Field: ‘node’
[16:01:48.368]   - Field: ‘label’
[16:01:48.368]   - Field: ‘local’
[16:01:48.368]   - Field: ‘owner’
[16:01:48.368]   - Field: ‘envir’
[16:01:48.368]   - Field: ‘workers’
[16:01:48.368]   - Field: ‘packages’
[16:01:48.368]   - Field: ‘gc’
[16:01:48.368]   - Field: ‘conditions’
[16:01:48.368]   - Field: ‘persistent’
[16:01:48.368]   - Field: ‘expr’
[16:01:48.369]   - Field: ‘uuid’
[16:01:48.369]   - Field: ‘seed’
[16:01:48.369]   - Field: ‘version’
[16:01:48.369]   - Field: ‘result’
[16:01:48.369]   - Field: ‘asynchronous’
[16:01:48.369]   - Field: ‘calls’
[16:01:48.369]   - Field: ‘globals’
[16:01:48.369]   - Field: ‘stdout’
[16:01:48.369]   - Field: ‘earlySignal’
[16:01:48.369]   - Field: ‘lazy’
[16:01:48.369]   - Field: ‘state’
[16:01:48.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:48.370] - Launch lazy future ...
[16:01:48.370] Packages needed by the future expression (n = 0): <none>
[16:01:48.370] Packages needed by future strategies (n = 0): <none>
[16:01:48.370] {
[16:01:48.370]     {
[16:01:48.370]         {
[16:01:48.370]             ...future.startTime <- base::Sys.time()
[16:01:48.370]             {
[16:01:48.370]                 {
[16:01:48.370]                   {
[16:01:48.370]                     {
[16:01:48.370]                       base::local({
[16:01:48.370]                         has_future <- base::requireNamespace("future", 
[16:01:48.370]                           quietly = TRUE)
[16:01:48.370]                         if (has_future) {
[16:01:48.370]                           ns <- base::getNamespace("future")
[16:01:48.370]                           version <- ns[[".package"]][["version"]]
[16:01:48.370]                           if (is.null(version)) 
[16:01:48.370]                             version <- utils::packageVersion("future")
[16:01:48.370]                         }
[16:01:48.370]                         else {
[16:01:48.370]                           version <- NULL
[16:01:48.370]                         }
[16:01:48.370]                         if (!has_future || version < "1.8.0") {
[16:01:48.370]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.370]                             "", base::R.version$version.string), 
[16:01:48.370]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.370]                               "release", "version")], collapse = " "), 
[16:01:48.370]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.370]                             info)
[16:01:48.370]                           info <- base::paste(info, collapse = "; ")
[16:01:48.370]                           if (!has_future) {
[16:01:48.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.370]                               info)
[16:01:48.370]                           }
[16:01:48.370]                           else {
[16:01:48.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.370]                               info, version)
[16:01:48.370]                           }
[16:01:48.370]                           base::stop(msg)
[16:01:48.370]                         }
[16:01:48.370]                       })
[16:01:48.370]                     }
[16:01:48.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:48.370]                     base::options(mc.cores = 1L)
[16:01:48.370]                   }
[16:01:48.370]                   options(future.plan = NULL)
[16:01:48.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.370]                 }
[16:01:48.370]                 ...future.workdir <- getwd()
[16:01:48.370]             }
[16:01:48.370]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.370]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.370]         }
[16:01:48.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.370]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:48.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.370]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.370]             base::names(...future.oldOptions))
[16:01:48.370]     }
[16:01:48.370]     if (FALSE) {
[16:01:48.370]     }
[16:01:48.370]     else {
[16:01:48.370]         if (TRUE) {
[16:01:48.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.370]                 open = "w")
[16:01:48.370]         }
[16:01:48.370]         else {
[16:01:48.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.370]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.370]         }
[16:01:48.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.370]             base::sink(type = "output", split = FALSE)
[16:01:48.370]             base::close(...future.stdout)
[16:01:48.370]         }, add = TRUE)
[16:01:48.370]     }
[16:01:48.370]     ...future.frame <- base::sys.nframe()
[16:01:48.370]     ...future.conditions <- base::list()
[16:01:48.370]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.370]     if (FALSE) {
[16:01:48.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.370]     }
[16:01:48.370]     ...future.result <- base::tryCatch({
[16:01:48.370]         base::withCallingHandlers({
[16:01:48.370]             ...future.value <- base::withVisible(base::local({
[16:01:48.370]                 ...future.makeSendCondition <- base::local({
[16:01:48.370]                   sendCondition <- NULL
[16:01:48.370]                   function(frame = 1L) {
[16:01:48.370]                     if (is.function(sendCondition)) 
[16:01:48.370]                       return(sendCondition)
[16:01:48.370]                     ns <- getNamespace("parallel")
[16:01:48.370]                     if (exists("sendData", mode = "function", 
[16:01:48.370]                       envir = ns)) {
[16:01:48.370]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:48.370]                         envir = ns)
[16:01:48.370]                       envir <- sys.frame(frame)
[16:01:48.370]                       master <- NULL
[16:01:48.370]                       while (!identical(envir, .GlobalEnv) && 
[16:01:48.370]                         !identical(envir, emptyenv())) {
[16:01:48.370]                         if (exists("master", mode = "list", envir = envir, 
[16:01:48.370]                           inherits = FALSE)) {
[16:01:48.370]                           master <- get("master", mode = "list", 
[16:01:48.370]                             envir = envir, inherits = FALSE)
[16:01:48.370]                           if (inherits(master, c("SOCKnode", 
[16:01:48.370]                             "SOCK0node"))) {
[16:01:48.370]                             sendCondition <<- function(cond) {
[16:01:48.370]                               data <- list(type = "VALUE", value = cond, 
[16:01:48.370]                                 success = TRUE)
[16:01:48.370]                               parallel_sendData(master, data)
[16:01:48.370]                             }
[16:01:48.370]                             return(sendCondition)
[16:01:48.370]                           }
[16:01:48.370]                         }
[16:01:48.370]                         frame <- frame + 1L
[16:01:48.370]                         envir <- sys.frame(frame)
[16:01:48.370]                       }
[16:01:48.370]                     }
[16:01:48.370]                     sendCondition <<- function(cond) NULL
[16:01:48.370]                   }
[16:01:48.370]                 })
[16:01:48.370]                 withCallingHandlers({
[16:01:48.370]                   {
[16:01:48.370]                     do.call(function(...) {
[16:01:48.370]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.370]                       if (!identical(...future.globals.maxSize.org, 
[16:01:48.370]                         ...future.globals.maxSize)) {
[16:01:48.370]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.370]                         on.exit(options(oopts), add = TRUE)
[16:01:48.370]                       }
[16:01:48.370]                       {
[16:01:48.370]                         lapply(seq_along(...future.elements_ii), 
[16:01:48.370]                           FUN = function(jj) {
[16:01:48.370]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.370]                             ...future.FUN(...future.X_jj, ...)
[16:01:48.370]                           })
[16:01:48.370]                       }
[16:01:48.370]                     }, args = future.call.arguments)
[16:01:48.370]                   }
[16:01:48.370]                 }, immediateCondition = function(cond) {
[16:01:48.370]                   sendCondition <- ...future.makeSendCondition()
[16:01:48.370]                   sendCondition(cond)
[16:01:48.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.370]                   {
[16:01:48.370]                     inherits <- base::inherits
[16:01:48.370]                     invokeRestart <- base::invokeRestart
[16:01:48.370]                     is.null <- base::is.null
[16:01:48.370]                     muffled <- FALSE
[16:01:48.370]                     if (inherits(cond, "message")) {
[16:01:48.370]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:48.370]                       if (muffled) 
[16:01:48.370]                         invokeRestart("muffleMessage")
[16:01:48.370]                     }
[16:01:48.370]                     else if (inherits(cond, "warning")) {
[16:01:48.370]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:48.370]                       if (muffled) 
[16:01:48.370]                         invokeRestart("muffleWarning")
[16:01:48.370]                     }
[16:01:48.370]                     else if (inherits(cond, "condition")) {
[16:01:48.370]                       if (!is.null(pattern)) {
[16:01:48.370]                         computeRestarts <- base::computeRestarts
[16:01:48.370]                         grepl <- base::grepl
[16:01:48.370]                         restarts <- computeRestarts(cond)
[16:01:48.370]                         for (restart in restarts) {
[16:01:48.370]                           name <- restart$name
[16:01:48.370]                           if (is.null(name)) 
[16:01:48.370]                             next
[16:01:48.370]                           if (!grepl(pattern, name)) 
[16:01:48.370]                             next
[16:01:48.370]                           invokeRestart(restart)
[16:01:48.370]                           muffled <- TRUE
[16:01:48.370]                           break
[16:01:48.370]                         }
[16:01:48.370]                       }
[16:01:48.370]                     }
[16:01:48.370]                     invisible(muffled)
[16:01:48.370]                   }
[16:01:48.370]                   muffleCondition(cond)
[16:01:48.370]                 })
[16:01:48.370]             }))
[16:01:48.370]             future::FutureResult(value = ...future.value$value, 
[16:01:48.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.370]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.370]                     ...future.globalenv.names))
[16:01:48.370]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.370]         }, condition = base::local({
[16:01:48.370]             c <- base::c
[16:01:48.370]             inherits <- base::inherits
[16:01:48.370]             invokeRestart <- base::invokeRestart
[16:01:48.370]             length <- base::length
[16:01:48.370]             list <- base::list
[16:01:48.370]             seq.int <- base::seq.int
[16:01:48.370]             signalCondition <- base::signalCondition
[16:01:48.370]             sys.calls <- base::sys.calls
[16:01:48.370]             `[[` <- base::`[[`
[16:01:48.370]             `+` <- base::`+`
[16:01:48.370]             `<<-` <- base::`<<-`
[16:01:48.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.370]                   3L)]
[16:01:48.370]             }
[16:01:48.370]             function(cond) {
[16:01:48.370]                 is_error <- inherits(cond, "error")
[16:01:48.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.370]                   NULL)
[16:01:48.370]                 if (is_error) {
[16:01:48.370]                   sessionInformation <- function() {
[16:01:48.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.370]                       search = base::search(), system = base::Sys.info())
[16:01:48.370]                   }
[16:01:48.370]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.370]                     cond$call), session = sessionInformation(), 
[16:01:48.370]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.370]                   signalCondition(cond)
[16:01:48.370]                 }
[16:01:48.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.370]                 "immediateCondition"))) {
[16:01:48.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.370]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.370]                   if (TRUE && !signal) {
[16:01:48.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.370]                     {
[16:01:48.370]                       inherits <- base::inherits
[16:01:48.370]                       invokeRestart <- base::invokeRestart
[16:01:48.370]                       is.null <- base::is.null
[16:01:48.370]                       muffled <- FALSE
[16:01:48.370]                       if (inherits(cond, "message")) {
[16:01:48.370]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.370]                         if (muffled) 
[16:01:48.370]                           invokeRestart("muffleMessage")
[16:01:48.370]                       }
[16:01:48.370]                       else if (inherits(cond, "warning")) {
[16:01:48.370]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.370]                         if (muffled) 
[16:01:48.370]                           invokeRestart("muffleWarning")
[16:01:48.370]                       }
[16:01:48.370]                       else if (inherits(cond, "condition")) {
[16:01:48.370]                         if (!is.null(pattern)) {
[16:01:48.370]                           computeRestarts <- base::computeRestarts
[16:01:48.370]                           grepl <- base::grepl
[16:01:48.370]                           restarts <- computeRestarts(cond)
[16:01:48.370]                           for (restart in restarts) {
[16:01:48.370]                             name <- restart$name
[16:01:48.370]                             if (is.null(name)) 
[16:01:48.370]                               next
[16:01:48.370]                             if (!grepl(pattern, name)) 
[16:01:48.370]                               next
[16:01:48.370]                             invokeRestart(restart)
[16:01:48.370]                             muffled <- TRUE
[16:01:48.370]                             break
[16:01:48.370]                           }
[16:01:48.370]                         }
[16:01:48.370]                       }
[16:01:48.370]                       invisible(muffled)
[16:01:48.370]                     }
[16:01:48.370]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.370]                   }
[16:01:48.370]                 }
[16:01:48.370]                 else {
[16:01:48.370]                   if (TRUE) {
[16:01:48.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.370]                     {
[16:01:48.370]                       inherits <- base::inherits
[16:01:48.370]                       invokeRestart <- base::invokeRestart
[16:01:48.370]                       is.null <- base::is.null
[16:01:48.370]                       muffled <- FALSE
[16:01:48.370]                       if (inherits(cond, "message")) {
[16:01:48.370]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.370]                         if (muffled) 
[16:01:48.370]                           invokeRestart("muffleMessage")
[16:01:48.370]                       }
[16:01:48.370]                       else if (inherits(cond, "warning")) {
[16:01:48.370]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.370]                         if (muffled) 
[16:01:48.370]                           invokeRestart("muffleWarning")
[16:01:48.370]                       }
[16:01:48.370]                       else if (inherits(cond, "condition")) {
[16:01:48.370]                         if (!is.null(pattern)) {
[16:01:48.370]                           computeRestarts <- base::computeRestarts
[16:01:48.370]                           grepl <- base::grepl
[16:01:48.370]                           restarts <- computeRestarts(cond)
[16:01:48.370]                           for (restart in restarts) {
[16:01:48.370]                             name <- restart$name
[16:01:48.370]                             if (is.null(name)) 
[16:01:48.370]                               next
[16:01:48.370]                             if (!grepl(pattern, name)) 
[16:01:48.370]                               next
[16:01:48.370]                             invokeRestart(restart)
[16:01:48.370]                             muffled <- TRUE
[16:01:48.370]                             break
[16:01:48.370]                           }
[16:01:48.370]                         }
[16:01:48.370]                       }
[16:01:48.370]                       invisible(muffled)
[16:01:48.370]                     }
[16:01:48.370]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.370]                   }
[16:01:48.370]                 }
[16:01:48.370]             }
[16:01:48.370]         }))
[16:01:48.370]     }, error = function(ex) {
[16:01:48.370]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.370]                 ...future.rng), started = ...future.startTime, 
[16:01:48.370]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.370]             version = "1.8"), class = "FutureResult")
[16:01:48.370]     }, finally = {
[16:01:48.370]         if (!identical(...future.workdir, getwd())) 
[16:01:48.370]             setwd(...future.workdir)
[16:01:48.370]         {
[16:01:48.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.370]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.370]             }
[16:01:48.370]             base::options(...future.oldOptions)
[16:01:48.370]             if (.Platform$OS.type == "windows") {
[16:01:48.370]                 old_names <- names(...future.oldEnvVars)
[16:01:48.370]                 envs <- base::Sys.getenv()
[16:01:48.370]                 names <- names(envs)
[16:01:48.370]                 common <- intersect(names, old_names)
[16:01:48.370]                 added <- setdiff(names, old_names)
[16:01:48.370]                 removed <- setdiff(old_names, names)
[16:01:48.370]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.370]                   envs[common]]
[16:01:48.370]                 NAMES <- toupper(changed)
[16:01:48.370]                 args <- list()
[16:01:48.370]                 for (kk in seq_along(NAMES)) {
[16:01:48.370]                   name <- changed[[kk]]
[16:01:48.370]                   NAME <- NAMES[[kk]]
[16:01:48.370]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.370]                     next
[16:01:48.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.370]                 }
[16:01:48.370]                 NAMES <- toupper(added)
[16:01:48.370]                 for (kk in seq_along(NAMES)) {
[16:01:48.370]                   name <- added[[kk]]
[16:01:48.370]                   NAME <- NAMES[[kk]]
[16:01:48.370]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.370]                     next
[16:01:48.370]                   args[[name]] <- ""
[16:01:48.370]                 }
[16:01:48.370]                 NAMES <- toupper(removed)
[16:01:48.370]                 for (kk in seq_along(NAMES)) {
[16:01:48.370]                   name <- removed[[kk]]
[16:01:48.370]                   NAME <- NAMES[[kk]]
[16:01:48.370]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.370]                     next
[16:01:48.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.370]                 }
[16:01:48.370]                 if (length(args) > 0) 
[16:01:48.370]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.370]             }
[16:01:48.370]             else {
[16:01:48.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.370]             }
[16:01:48.370]             {
[16:01:48.370]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.370]                   0L) {
[16:01:48.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.370]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.370]                   base::options(opts)
[16:01:48.370]                 }
[16:01:48.370]                 {
[16:01:48.370]                   {
[16:01:48.370]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:48.370]                     NULL
[16:01:48.370]                   }
[16:01:48.370]                   options(future.plan = NULL)
[16:01:48.370]                   if (is.na(NA_character_)) 
[16:01:48.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.370]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:48.370]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:48.370]                     envir = parent.frame()) 
[16:01:48.370]                   {
[16:01:48.370]                     if (is.function(workers)) 
[16:01:48.370]                       workers <- workers()
[16:01:48.370]                     workers <- structure(as.integer(workers), 
[16:01:48.370]                       class = class(workers))
[16:01:48.370]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:48.370]                       workers >= 1)
[16:01:48.370]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:48.370]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:48.370]                     }
[16:01:48.370]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:48.370]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:48.370]                       envir = envir)
[16:01:48.370]                     if (!future$lazy) 
[16:01:48.370]                       future <- run(future)
[16:01:48.370]                     invisible(future)
[16:01:48.370]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.370]                 }
[16:01:48.370]             }
[16:01:48.370]         }
[16:01:48.370]     })
[16:01:48.370]     if (TRUE) {
[16:01:48.370]         base::sink(type = "output", split = FALSE)
[16:01:48.370]         if (TRUE) {
[16:01:48.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.370]         }
[16:01:48.370]         else {
[16:01:48.370]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.370]         }
[16:01:48.370]         base::close(...future.stdout)
[16:01:48.370]         ...future.stdout <- NULL
[16:01:48.370]     }
[16:01:48.370]     ...future.result$conditions <- ...future.conditions
[16:01:48.370]     ...future.result$finished <- base::Sys.time()
[16:01:48.370]     ...future.result
[16:01:48.370] }
[16:01:48.373] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:01:48.373] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:01:48.374] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:01:48.374] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:48.374] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.375] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:01:48.375] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:01:48.375] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:48.376] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.376] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:01:48.376] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:01:48.376] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:01:48.377] MultisessionFuture started
[16:01:48.377] - Launch lazy future ... done
[16:01:48.377] run() for ‘MultisessionFuture’ ... done
[16:01:48.377] Created future:
[16:01:48.377] MultisessionFuture:
[16:01:48.377] Label: ‘future_by-1’
[16:01:48.377] Expression:
[16:01:48.377] {
[16:01:48.377]     do.call(function(...) {
[16:01:48.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.377]             on.exit(options(oopts), add = TRUE)
[16:01:48.377]         }
[16:01:48.377]         {
[16:01:48.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.377]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.377]             })
[16:01:48.377]         }
[16:01:48.377]     }, args = future.call.arguments)
[16:01:48.377] }
[16:01:48.377] Lazy evaluation: FALSE
[16:01:48.377] Asynchronous evaluation: TRUE
[16:01:48.377] Local evaluation: TRUE
[16:01:48.377] Environment: 0x55b527992490
[16:01:48.377] Capture standard output: TRUE
[16:01:48.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.377] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.377] Packages: <none>
[16:01:48.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.377] Resolved: FALSE
[16:01:48.377] Value: <not collected>
[16:01:48.377] Conditions captured: <none>
[16:01:48.377] Early signaling: FALSE
[16:01:48.377] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:48.377] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.389] Chunk #1 of 2 ... DONE
[16:01:48.389] Chunk #2 of 2 ...
[16:01:48.389]  - Finding globals in 'X' for chunk #2 ...
[16:01:48.389] getGlobalsAndPackages() ...
[16:01:48.390] Searching for globals...
[16:01:48.390] 
[16:01:48.390] Searching for globals ... DONE
[16:01:48.390] - globals: [0] <none>
[16:01:48.390] getGlobalsAndPackages() ... DONE
[16:01:48.390]    + additional globals found: [n=0] 
[16:01:48.390]    + additional namespaces needed: [n=0] 
[16:01:48.391]  - Finding globals in 'X' for chunk #2 ... DONE
[16:01:48.391]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:01:48.391]  - seeds: <none>
[16:01:48.391]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.391] getGlobalsAndPackages() ...
[16:01:48.391] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.391] Resolving globals: FALSE
[16:01:48.391] Tweak future expression to call with '...' arguments ...
[16:01:48.391] {
[16:01:48.391]     do.call(function(...) {
[16:01:48.391]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.391]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.391]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.391]             on.exit(options(oopts), add = TRUE)
[16:01:48.391]         }
[16:01:48.391]         {
[16:01:48.391]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.391]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.391]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.391]             })
[16:01:48.391]         }
[16:01:48.391]     }, args = future.call.arguments)
[16:01:48.391] }
[16:01:48.392] Tweak future expression to call with '...' arguments ... DONE
[16:01:48.392] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:48.392] 
[16:01:48.392] getGlobalsAndPackages() ... DONE
[16:01:48.392] run() for ‘Future’ ...
[16:01:48.393] - state: ‘created’
[16:01:48.393] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:48.406] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:48.407]   - Field: ‘node’
[16:01:48.407]   - Field: ‘label’
[16:01:48.407]   - Field: ‘local’
[16:01:48.407]   - Field: ‘owner’
[16:01:48.407]   - Field: ‘envir’
[16:01:48.407]   - Field: ‘workers’
[16:01:48.407]   - Field: ‘packages’
[16:01:48.407]   - Field: ‘gc’
[16:01:48.408]   - Field: ‘conditions’
[16:01:48.408]   - Field: ‘persistent’
[16:01:48.408]   - Field: ‘expr’
[16:01:48.408]   - Field: ‘uuid’
[16:01:48.408]   - Field: ‘seed’
[16:01:48.408]   - Field: ‘version’
[16:01:48.408]   - Field: ‘result’
[16:01:48.408]   - Field: ‘asynchronous’
[16:01:48.408]   - Field: ‘calls’
[16:01:48.408]   - Field: ‘globals’
[16:01:48.408]   - Field: ‘stdout’
[16:01:48.408]   - Field: ‘earlySignal’
[16:01:48.409]   - Field: ‘lazy’
[16:01:48.409]   - Field: ‘state’
[16:01:48.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:48.409] - Launch lazy future ...
[16:01:48.409] Packages needed by the future expression (n = 0): <none>
[16:01:48.409] Packages needed by future strategies (n = 0): <none>
[16:01:48.410] {
[16:01:48.410]     {
[16:01:48.410]         {
[16:01:48.410]             ...future.startTime <- base::Sys.time()
[16:01:48.410]             {
[16:01:48.410]                 {
[16:01:48.410]                   {
[16:01:48.410]                     {
[16:01:48.410]                       base::local({
[16:01:48.410]                         has_future <- base::requireNamespace("future", 
[16:01:48.410]                           quietly = TRUE)
[16:01:48.410]                         if (has_future) {
[16:01:48.410]                           ns <- base::getNamespace("future")
[16:01:48.410]                           version <- ns[[".package"]][["version"]]
[16:01:48.410]                           if (is.null(version)) 
[16:01:48.410]                             version <- utils::packageVersion("future")
[16:01:48.410]                         }
[16:01:48.410]                         else {
[16:01:48.410]                           version <- NULL
[16:01:48.410]                         }
[16:01:48.410]                         if (!has_future || version < "1.8.0") {
[16:01:48.410]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:48.410]                             "", base::R.version$version.string), 
[16:01:48.410]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:48.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:48.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:48.410]                               "release", "version")], collapse = " "), 
[16:01:48.410]                             hostname = base::Sys.info()[["nodename"]])
[16:01:48.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:48.410]                             info)
[16:01:48.410]                           info <- base::paste(info, collapse = "; ")
[16:01:48.410]                           if (!has_future) {
[16:01:48.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:48.410]                               info)
[16:01:48.410]                           }
[16:01:48.410]                           else {
[16:01:48.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:48.410]                               info, version)
[16:01:48.410]                           }
[16:01:48.410]                           base::stop(msg)
[16:01:48.410]                         }
[16:01:48.410]                       })
[16:01:48.410]                     }
[16:01:48.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:48.410]                     base::options(mc.cores = 1L)
[16:01:48.410]                   }
[16:01:48.410]                   options(future.plan = NULL)
[16:01:48.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:48.410]                 }
[16:01:48.410]                 ...future.workdir <- getwd()
[16:01:48.410]             }
[16:01:48.410]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:48.410]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:48.410]         }
[16:01:48.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:48.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:01:48.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:48.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:48.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:48.410]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:48.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:48.410]             base::names(...future.oldOptions))
[16:01:48.410]     }
[16:01:48.410]     if (FALSE) {
[16:01:48.410]     }
[16:01:48.410]     else {
[16:01:48.410]         if (TRUE) {
[16:01:48.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:48.410]                 open = "w")
[16:01:48.410]         }
[16:01:48.410]         else {
[16:01:48.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:48.410]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:48.410]         }
[16:01:48.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:48.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:48.410]             base::sink(type = "output", split = FALSE)
[16:01:48.410]             base::close(...future.stdout)
[16:01:48.410]         }, add = TRUE)
[16:01:48.410]     }
[16:01:48.410]     ...future.frame <- base::sys.nframe()
[16:01:48.410]     ...future.conditions <- base::list()
[16:01:48.410]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:48.410]     if (FALSE) {
[16:01:48.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:48.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:48.410]     }
[16:01:48.410]     ...future.result <- base::tryCatch({
[16:01:48.410]         base::withCallingHandlers({
[16:01:48.410]             ...future.value <- base::withVisible(base::local({
[16:01:48.410]                 ...future.makeSendCondition <- base::local({
[16:01:48.410]                   sendCondition <- NULL
[16:01:48.410]                   function(frame = 1L) {
[16:01:48.410]                     if (is.function(sendCondition)) 
[16:01:48.410]                       return(sendCondition)
[16:01:48.410]                     ns <- getNamespace("parallel")
[16:01:48.410]                     if (exists("sendData", mode = "function", 
[16:01:48.410]                       envir = ns)) {
[16:01:48.410]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:48.410]                         envir = ns)
[16:01:48.410]                       envir <- sys.frame(frame)
[16:01:48.410]                       master <- NULL
[16:01:48.410]                       while (!identical(envir, .GlobalEnv) && 
[16:01:48.410]                         !identical(envir, emptyenv())) {
[16:01:48.410]                         if (exists("master", mode = "list", envir = envir, 
[16:01:48.410]                           inherits = FALSE)) {
[16:01:48.410]                           master <- get("master", mode = "list", 
[16:01:48.410]                             envir = envir, inherits = FALSE)
[16:01:48.410]                           if (inherits(master, c("SOCKnode", 
[16:01:48.410]                             "SOCK0node"))) {
[16:01:48.410]                             sendCondition <<- function(cond) {
[16:01:48.410]                               data <- list(type = "VALUE", value = cond, 
[16:01:48.410]                                 success = TRUE)
[16:01:48.410]                               parallel_sendData(master, data)
[16:01:48.410]                             }
[16:01:48.410]                             return(sendCondition)
[16:01:48.410]                           }
[16:01:48.410]                         }
[16:01:48.410]                         frame <- frame + 1L
[16:01:48.410]                         envir <- sys.frame(frame)
[16:01:48.410]                       }
[16:01:48.410]                     }
[16:01:48.410]                     sendCondition <<- function(cond) NULL
[16:01:48.410]                   }
[16:01:48.410]                 })
[16:01:48.410]                 withCallingHandlers({
[16:01:48.410]                   {
[16:01:48.410]                     do.call(function(...) {
[16:01:48.410]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.410]                       if (!identical(...future.globals.maxSize.org, 
[16:01:48.410]                         ...future.globals.maxSize)) {
[16:01:48.410]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.410]                         on.exit(options(oopts), add = TRUE)
[16:01:48.410]                       }
[16:01:48.410]                       {
[16:01:48.410]                         lapply(seq_along(...future.elements_ii), 
[16:01:48.410]                           FUN = function(jj) {
[16:01:48.410]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.410]                             ...future.FUN(...future.X_jj, ...)
[16:01:48.410]                           })
[16:01:48.410]                       }
[16:01:48.410]                     }, args = future.call.arguments)
[16:01:48.410]                   }
[16:01:48.410]                 }, immediateCondition = function(cond) {
[16:01:48.410]                   sendCondition <- ...future.makeSendCondition()
[16:01:48.410]                   sendCondition(cond)
[16:01:48.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.410]                   {
[16:01:48.410]                     inherits <- base::inherits
[16:01:48.410]                     invokeRestart <- base::invokeRestart
[16:01:48.410]                     is.null <- base::is.null
[16:01:48.410]                     muffled <- FALSE
[16:01:48.410]                     if (inherits(cond, "message")) {
[16:01:48.410]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:48.410]                       if (muffled) 
[16:01:48.410]                         invokeRestart("muffleMessage")
[16:01:48.410]                     }
[16:01:48.410]                     else if (inherits(cond, "warning")) {
[16:01:48.410]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:48.410]                       if (muffled) 
[16:01:48.410]                         invokeRestart("muffleWarning")
[16:01:48.410]                     }
[16:01:48.410]                     else if (inherits(cond, "condition")) {
[16:01:48.410]                       if (!is.null(pattern)) {
[16:01:48.410]                         computeRestarts <- base::computeRestarts
[16:01:48.410]                         grepl <- base::grepl
[16:01:48.410]                         restarts <- computeRestarts(cond)
[16:01:48.410]                         for (restart in restarts) {
[16:01:48.410]                           name <- restart$name
[16:01:48.410]                           if (is.null(name)) 
[16:01:48.410]                             next
[16:01:48.410]                           if (!grepl(pattern, name)) 
[16:01:48.410]                             next
[16:01:48.410]                           invokeRestart(restart)
[16:01:48.410]                           muffled <- TRUE
[16:01:48.410]                           break
[16:01:48.410]                         }
[16:01:48.410]                       }
[16:01:48.410]                     }
[16:01:48.410]                     invisible(muffled)
[16:01:48.410]                   }
[16:01:48.410]                   muffleCondition(cond)
[16:01:48.410]                 })
[16:01:48.410]             }))
[16:01:48.410]             future::FutureResult(value = ...future.value$value, 
[16:01:48.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.410]                   ...future.rng), globalenv = if (FALSE) 
[16:01:48.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:48.410]                     ...future.globalenv.names))
[16:01:48.410]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:48.410]         }, condition = base::local({
[16:01:48.410]             c <- base::c
[16:01:48.410]             inherits <- base::inherits
[16:01:48.410]             invokeRestart <- base::invokeRestart
[16:01:48.410]             length <- base::length
[16:01:48.410]             list <- base::list
[16:01:48.410]             seq.int <- base::seq.int
[16:01:48.410]             signalCondition <- base::signalCondition
[16:01:48.410]             sys.calls <- base::sys.calls
[16:01:48.410]             `[[` <- base::`[[`
[16:01:48.410]             `+` <- base::`+`
[16:01:48.410]             `<<-` <- base::`<<-`
[16:01:48.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:48.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:48.410]                   3L)]
[16:01:48.410]             }
[16:01:48.410]             function(cond) {
[16:01:48.410]                 is_error <- inherits(cond, "error")
[16:01:48.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:48.410]                   NULL)
[16:01:48.410]                 if (is_error) {
[16:01:48.410]                   sessionInformation <- function() {
[16:01:48.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:48.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:48.410]                       search = base::search(), system = base::Sys.info())
[16:01:48.410]                   }
[16:01:48.410]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:48.410]                     cond$call), session = sessionInformation(), 
[16:01:48.410]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:48.410]                   signalCondition(cond)
[16:01:48.410]                 }
[16:01:48.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:48.410]                 "immediateCondition"))) {
[16:01:48.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:48.410]                   ...future.conditions[[length(...future.conditions) + 
[16:01:48.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:48.410]                   if (TRUE && !signal) {
[16:01:48.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.410]                     {
[16:01:48.410]                       inherits <- base::inherits
[16:01:48.410]                       invokeRestart <- base::invokeRestart
[16:01:48.410]                       is.null <- base::is.null
[16:01:48.410]                       muffled <- FALSE
[16:01:48.410]                       if (inherits(cond, "message")) {
[16:01:48.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.410]                         if (muffled) 
[16:01:48.410]                           invokeRestart("muffleMessage")
[16:01:48.410]                       }
[16:01:48.410]                       else if (inherits(cond, "warning")) {
[16:01:48.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.410]                         if (muffled) 
[16:01:48.410]                           invokeRestart("muffleWarning")
[16:01:48.410]                       }
[16:01:48.410]                       else if (inherits(cond, "condition")) {
[16:01:48.410]                         if (!is.null(pattern)) {
[16:01:48.410]                           computeRestarts <- base::computeRestarts
[16:01:48.410]                           grepl <- base::grepl
[16:01:48.410]                           restarts <- computeRestarts(cond)
[16:01:48.410]                           for (restart in restarts) {
[16:01:48.410]                             name <- restart$name
[16:01:48.410]                             if (is.null(name)) 
[16:01:48.410]                               next
[16:01:48.410]                             if (!grepl(pattern, name)) 
[16:01:48.410]                               next
[16:01:48.410]                             invokeRestart(restart)
[16:01:48.410]                             muffled <- TRUE
[16:01:48.410]                             break
[16:01:48.410]                           }
[16:01:48.410]                         }
[16:01:48.410]                       }
[16:01:48.410]                       invisible(muffled)
[16:01:48.410]                     }
[16:01:48.410]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.410]                   }
[16:01:48.410]                 }
[16:01:48.410]                 else {
[16:01:48.410]                   if (TRUE) {
[16:01:48.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:48.410]                     {
[16:01:48.410]                       inherits <- base::inherits
[16:01:48.410]                       invokeRestart <- base::invokeRestart
[16:01:48.410]                       is.null <- base::is.null
[16:01:48.410]                       muffled <- FALSE
[16:01:48.410]                       if (inherits(cond, "message")) {
[16:01:48.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:48.410]                         if (muffled) 
[16:01:48.410]                           invokeRestart("muffleMessage")
[16:01:48.410]                       }
[16:01:48.410]                       else if (inherits(cond, "warning")) {
[16:01:48.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:48.410]                         if (muffled) 
[16:01:48.410]                           invokeRestart("muffleWarning")
[16:01:48.410]                       }
[16:01:48.410]                       else if (inherits(cond, "condition")) {
[16:01:48.410]                         if (!is.null(pattern)) {
[16:01:48.410]                           computeRestarts <- base::computeRestarts
[16:01:48.410]                           grepl <- base::grepl
[16:01:48.410]                           restarts <- computeRestarts(cond)
[16:01:48.410]                           for (restart in restarts) {
[16:01:48.410]                             name <- restart$name
[16:01:48.410]                             if (is.null(name)) 
[16:01:48.410]                               next
[16:01:48.410]                             if (!grepl(pattern, name)) 
[16:01:48.410]                               next
[16:01:48.410]                             invokeRestart(restart)
[16:01:48.410]                             muffled <- TRUE
[16:01:48.410]                             break
[16:01:48.410]                           }
[16:01:48.410]                         }
[16:01:48.410]                       }
[16:01:48.410]                       invisible(muffled)
[16:01:48.410]                     }
[16:01:48.410]                     muffleCondition(cond, pattern = "^muffle")
[16:01:48.410]                   }
[16:01:48.410]                 }
[16:01:48.410]             }
[16:01:48.410]         }))
[16:01:48.410]     }, error = function(ex) {
[16:01:48.410]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:48.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:48.410]                 ...future.rng), started = ...future.startTime, 
[16:01:48.410]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:48.410]             version = "1.8"), class = "FutureResult")
[16:01:48.410]     }, finally = {
[16:01:48.410]         if (!identical(...future.workdir, getwd())) 
[16:01:48.410]             setwd(...future.workdir)
[16:01:48.410]         {
[16:01:48.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:48.410]                 ...future.oldOptions$nwarnings <- NULL
[16:01:48.410]             }
[16:01:48.410]             base::options(...future.oldOptions)
[16:01:48.410]             if (.Platform$OS.type == "windows") {
[16:01:48.410]                 old_names <- names(...future.oldEnvVars)
[16:01:48.410]                 envs <- base::Sys.getenv()
[16:01:48.410]                 names <- names(envs)
[16:01:48.410]                 common <- intersect(names, old_names)
[16:01:48.410]                 added <- setdiff(names, old_names)
[16:01:48.410]                 removed <- setdiff(old_names, names)
[16:01:48.410]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:48.410]                   envs[common]]
[16:01:48.410]                 NAMES <- toupper(changed)
[16:01:48.410]                 args <- list()
[16:01:48.410]                 for (kk in seq_along(NAMES)) {
[16:01:48.410]                   name <- changed[[kk]]
[16:01:48.410]                   NAME <- NAMES[[kk]]
[16:01:48.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.410]                     next
[16:01:48.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.410]                 }
[16:01:48.410]                 NAMES <- toupper(added)
[16:01:48.410]                 for (kk in seq_along(NAMES)) {
[16:01:48.410]                   name <- added[[kk]]
[16:01:48.410]                   NAME <- NAMES[[kk]]
[16:01:48.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.410]                     next
[16:01:48.410]                   args[[name]] <- ""
[16:01:48.410]                 }
[16:01:48.410]                 NAMES <- toupper(removed)
[16:01:48.410]                 for (kk in seq_along(NAMES)) {
[16:01:48.410]                   name <- removed[[kk]]
[16:01:48.410]                   NAME <- NAMES[[kk]]
[16:01:48.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:48.410]                     next
[16:01:48.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:48.410]                 }
[16:01:48.410]                 if (length(args) > 0) 
[16:01:48.410]                   base::do.call(base::Sys.setenv, args = args)
[16:01:48.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:48.410]             }
[16:01:48.410]             else {
[16:01:48.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:48.410]             }
[16:01:48.410]             {
[16:01:48.410]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:48.410]                   0L) {
[16:01:48.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:48.410]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:48.410]                   base::options(opts)
[16:01:48.410]                 }
[16:01:48.410]                 {
[16:01:48.410]                   {
[16:01:48.410]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:48.410]                     NULL
[16:01:48.410]                   }
[16:01:48.410]                   options(future.plan = NULL)
[16:01:48.410]                   if (is.na(NA_character_)) 
[16:01:48.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:48.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:48.410]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:48.410]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:48.410]                     envir = parent.frame()) 
[16:01:48.410]                   {
[16:01:48.410]                     if (is.function(workers)) 
[16:01:48.410]                       workers <- workers()
[16:01:48.410]                     workers <- structure(as.integer(workers), 
[16:01:48.410]                       class = class(workers))
[16:01:48.410]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:48.410]                       workers >= 1)
[16:01:48.410]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:48.410]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:48.410]                     }
[16:01:48.410]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:48.410]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:48.410]                       envir = envir)
[16:01:48.410]                     if (!future$lazy) 
[16:01:48.410]                       future <- run(future)
[16:01:48.410]                     invisible(future)
[16:01:48.410]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:48.410]                 }
[16:01:48.410]             }
[16:01:48.410]         }
[16:01:48.410]     })
[16:01:48.410]     if (TRUE) {
[16:01:48.410]         base::sink(type = "output", split = FALSE)
[16:01:48.410]         if (TRUE) {
[16:01:48.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:48.410]         }
[16:01:48.410]         else {
[16:01:48.410]             ...future.result["stdout"] <- base::list(NULL)
[16:01:48.410]         }
[16:01:48.410]         base::close(...future.stdout)
[16:01:48.410]         ...future.stdout <- NULL
[16:01:48.410]     }
[16:01:48.410]     ...future.result$conditions <- ...future.conditions
[16:01:48.410]     ...future.result$finished <- base::Sys.time()
[16:01:48.410]     ...future.result
[16:01:48.410] }
[16:01:48.413] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:01:48.413] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:01:48.413] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:01:48.413] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:48.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.414] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:01:48.414] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:01:48.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:48.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.415] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:01:48.415] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:01:48.416] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:01:48.416] MultisessionFuture started
[16:01:48.416] - Launch lazy future ... done
[16:01:48.416] run() for ‘MultisessionFuture’ ... done
[16:01:48.417] Created future:
[16:01:48.417] MultisessionFuture:
[16:01:48.417] Label: ‘future_by-2’
[16:01:48.417] Expression:
[16:01:48.417] {
[16:01:48.417]     do.call(function(...) {
[16:01:48.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:48.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:48.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:48.417]             on.exit(options(oopts), add = TRUE)
[16:01:48.417]         }
[16:01:48.417]         {
[16:01:48.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:48.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:48.417]                 ...future.FUN(...future.X_jj, ...)
[16:01:48.417]             })
[16:01:48.417]         }
[16:01:48.417]     }, args = future.call.arguments)
[16:01:48.417] }
[16:01:48.417] Lazy evaluation: FALSE
[16:01:48.417] Asynchronous evaluation: TRUE
[16:01:48.417] Local evaluation: TRUE
[16:01:48.417] Environment: 0x55b527992490
[16:01:48.417] Capture standard output: TRUE
[16:01:48.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:48.417] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:01:48.417] Packages: <none>
[16:01:48.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:48.417] Resolved: FALSE
[16:01:48.417] Value: <not collected>
[16:01:48.417] Conditions captured: <none>
[16:01:48.417] Early signaling: FALSE
[16:01:48.417] Owner process: 1e96d463-a261-4160-e87c-a35d7366aff6
[16:01:48.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:48.428] Chunk #2 of 2 ... DONE
[16:01:48.429] Launching 2 futures (chunks) ... DONE
[16:01:48.429] Resolving 2 futures (chunks) ...
[16:01:48.429] resolve() on list ...
[16:01:48.429]  recursive: 0
[16:01:48.429]  length: 2
[16:01:48.429] 
[16:01:48.430] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.430] - Validating connection of MultisessionFuture
[16:01:48.430] - received message: FutureResult
[16:01:48.430] - Received FutureResult
[16:01:48.430] - Erased future from FutureRegistry
[16:01:48.430] result() for ClusterFuture ...
[16:01:48.430] - result already collected: FutureResult
[16:01:48.430] result() for ClusterFuture ... done
[16:01:48.430] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.431] Future #1
[16:01:48.431] result() for ClusterFuture ...
[16:01:48.431] - result already collected: FutureResult
[16:01:48.431] result() for ClusterFuture ... done
[16:01:48.431] result() for ClusterFuture ...
[16:01:48.431] - result already collected: FutureResult
[16:01:48.431] result() for ClusterFuture ... done
[16:01:48.431] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:48.431] - nx: 2
[16:01:48.431] - relay: TRUE
[16:01:48.431] - stdout: TRUE
[16:01:48.432] - signal: TRUE
[16:01:48.432] - resignal: FALSE
[16:01:48.432] - force: TRUE
[16:01:48.432] - relayed: [n=2] FALSE, FALSE
[16:01:48.432] - queued futures: [n=2] FALSE, FALSE
[16:01:48.432]  - until=1
[16:01:48.432]  - relaying element #1
[16:01:48.432] result() for ClusterFuture ...
[16:01:48.432] - result already collected: FutureResult
[16:01:48.432] result() for ClusterFuture ... done
[16:01:48.432] result() for ClusterFuture ...
[16:01:48.433] - result already collected: FutureResult
[16:01:48.433] result() for ClusterFuture ... done
[16:01:48.433] result() for ClusterFuture ...
[16:01:48.433] - result already collected: FutureResult
[16:01:48.433] result() for ClusterFuture ... done
[16:01:48.433] result() for ClusterFuture ...
[16:01:48.433] - result already collected: FutureResult
[16:01:48.433] result() for ClusterFuture ... done
[16:01:48.433] - relayed: [n=2] TRUE, FALSE
[16:01:48.433] - queued futures: [n=2] TRUE, FALSE
[16:01:48.433] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:48.434]  length: 1 (resolved future 1)
[16:01:48.475] receiveMessageFromWorker() for ClusterFuture ...
[16:01:48.476] - Validating connection of MultisessionFuture
[16:01:48.476] - received message: FutureResult
[16:01:48.476] - Received FutureResult
[16:01:48.476] - Erased future from FutureRegistry
[16:01:48.476] result() for ClusterFuture ...
[16:01:48.476] - result already collected: FutureResult
[16:01:48.476] result() for ClusterFuture ... done
[16:01:48.476] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:48.477] Future #2
[16:01:48.477] result() for ClusterFuture ...
[16:01:48.477] - result already collected: FutureResult
[16:01:48.477] result() for ClusterFuture ... done
[16:01:48.477] result() for ClusterFuture ...
[16:01:48.477] - result already collected: FutureResult
[16:01:48.477] result() for ClusterFuture ... done
[16:01:48.477] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:48.477] - nx: 2
[16:01:48.477] - relay: TRUE
[16:01:48.477] - stdout: TRUE
[16:01:48.478] - signal: TRUE
[16:01:48.478] - resignal: FALSE
[16:01:48.478] - force: TRUE
[16:01:48.478] - relayed: [n=2] TRUE, FALSE
[16:01:48.478] - queued futures: [n=2] TRUE, FALSE
[16:01:48.478]  - until=2
[16:01:48.478]  - relaying element #2
[16:01:48.478] result() for ClusterFuture ...
[16:01:48.478] - result already collected: FutureResult
[16:01:48.478] result() for ClusterFuture ... done
[16:01:48.478] result() for ClusterFuture ...
[16:01:48.479] - result already collected: FutureResult
[16:01:48.479] result() for ClusterFuture ... done
[16:01:48.479] result() for ClusterFuture ...
[16:01:48.479] - result already collected: FutureResult
[16:01:48.479] result() for ClusterFuture ... done
[16:01:48.479] result() for ClusterFuture ...
[16:01:48.479] - result already collected: FutureResult
[16:01:48.479] result() for ClusterFuture ... done
[16:01:48.479] - relayed: [n=2] TRUE, TRUE
[16:01:48.479] - queued futures: [n=2] TRUE, TRUE
[16:01:48.479] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:48.480]  length: 0 (resolved future 2)
[16:01:48.480] Relaying remaining futures
[16:01:48.480] signalConditionsASAP(NULL, pos=0) ...
[16:01:48.480] - nx: 2
[16:01:48.480] - relay: TRUE
[16:01:48.480] - stdout: TRUE
[16:01:48.480] - signal: TRUE
[16:01:48.480] - resignal: FALSE
[16:01:48.480] - force: TRUE
[16:01:48.480] - relayed: [n=2] TRUE, TRUE
[16:01:48.480] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:48.481] - relayed: [n=2] TRUE, TRUE
[16:01:48.481] - queued futures: [n=2] TRUE, TRUE
[16:01:48.481] signalConditionsASAP(NULL, pos=0) ... done
[16:01:48.481] resolve() on list ... DONE
[16:01:48.481] result() for ClusterFuture ...
[16:01:48.481] - result already collected: FutureResult
[16:01:48.481] result() for ClusterFuture ... done
[16:01:48.481] result() for ClusterFuture ...
[16:01:48.481] - result already collected: FutureResult
[16:01:48.481] result() for ClusterFuture ... done
[16:01:48.481] result() for ClusterFuture ...
[16:01:48.482] - result already collected: FutureResult
[16:01:48.482] result() for ClusterFuture ... done
[16:01:48.482] result() for ClusterFuture ...
[16:01:48.482] - result already collected: FutureResult
[16:01:48.482] result() for ClusterFuture ... done
[16:01:48.482]  - Number of value chunks collected: 2
[16:01:48.482] Resolving 2 futures (chunks) ... DONE
[16:01:48.482] Reducing values from 2 chunks ...
[16:01:48.482]  - Number of values collected after concatenation: 3
[16:01:48.482]  - Number of values expected: 3
[16:01:48.482] Reducing values from 2 chunks ... DONE
[16:01:48.483] future_lapply() ... DONE
[16:01:48.483] future_by_internal() ... DONE
[16:01:48.484] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[16:01:48.484] plan(): Setting new future strategy stack:
[16:01:48.485] List of future strategies:
[16:01:48.485] 1. FutureStrategy:
[16:01:48.485]    - args: function (..., envir = parent.frame())
[16:01:48.485]    - tweaked: FALSE
[16:01:48.485]    - call: future::plan(oplan)
[16:01:48.485] plan(): nbrOfWorkers() = 1
> 
