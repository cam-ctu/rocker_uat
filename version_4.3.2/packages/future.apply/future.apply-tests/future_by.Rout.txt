
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:22:48.478] plan(): Setting new future strategy stack:
[10:22:48.478] List of future strategies:
[10:22:48.478] 1. sequential:
[10:22:48.478]    - args: function (..., envir = parent.frame())
[10:22:48.478]    - tweaked: FALSE
[10:22:48.478]    - call: future::plan("sequential")
[10:22:48.492] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[10:22:48.547] plan(): Setting new future strategy stack:
[10:22:48.547] List of future strategies:
[10:22:48.547] 1. sequential:
[10:22:48.547]    - args: function (..., envir = parent.frame())
[10:22:48.547]    - tweaked: FALSE
[10:22:48.547]    - call: plan(strategy)
[10:22:48.558] plan(): nbrOfWorkers() = 1
[10:22:48.559] future_by_internal() ...
[10:22:48.559] future_lapply() ...
[10:22:48.563] Number of chunks: 1
[10:22:48.564] getGlobalsAndPackagesXApply() ...
[10:22:48.564]  - future.globals: TRUE
[10:22:48.565] getGlobalsAndPackages() ...
[10:22:48.565] Searching for globals...
[10:22:48.567] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:48.567] Searching for globals ... DONE
[10:22:48.567] Resolving globals: FALSE
[10:22:48.568] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:48.568] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:48.568] - globals: [1] ‘FUN’
[10:22:48.569] 
[10:22:48.569] getGlobalsAndPackages() ... DONE
[10:22:48.569]  - globals found/used: [n=1] ‘FUN’
[10:22:48.569]  - needed namespaces: [n=0] 
[10:22:48.569] Finding globals ... DONE
[10:22:48.569]  - use_args: TRUE
[10:22:48.569]  - Getting '...' globals ...
[10:22:48.570] resolve() on list ...
[10:22:48.570]  recursive: 0
[10:22:48.570]  length: 1
[10:22:48.570]  elements: ‘...’
[10:22:48.571]  length: 0 (resolved future 1)
[10:22:48.571] resolve() on list ... DONE
[10:22:48.571]    - '...' content: [n=0] 
[10:22:48.571] List of 1
[10:22:48.571]  $ ...: list()
[10:22:48.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.571]  - attr(*, "where")=List of 1
[10:22:48.571]   ..$ ...:<environment: 0x55f637bc14d8> 
[10:22:48.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.571]  - attr(*, "resolved")= logi TRUE
[10:22:48.571]  - attr(*, "total_size")= num NA
[10:22:48.575]  - Getting '...' globals ... DONE
[10:22:48.575] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.575] List of 2
[10:22:48.575]  $ ...future.FUN:function (object, ...)  
[10:22:48.575]  $ ...          : list()
[10:22:48.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.575]  - attr(*, "where")=List of 2
[10:22:48.575]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.575]   ..$ ...          :<environment: 0x55f637bc14d8> 
[10:22:48.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.575]  - attr(*, "resolved")= logi FALSE
[10:22:48.575]  - attr(*, "total_size")= num 1240
[10:22:48.578] Packages to be attached in all futures: [n=0] 
[10:22:48.578] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.578] Number of futures (= number of chunks): 1
[10:22:48.578] Launching 1 futures (chunks) ...
[10:22:48.578] Chunk #1 of 1 ...
[10:22:48.579]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.579] getGlobalsAndPackages() ...
[10:22:48.579] Searching for globals...
[10:22:48.579] 
[10:22:48.580] Searching for globals ... DONE
[10:22:48.580] - globals: [0] <none>
[10:22:48.580] getGlobalsAndPackages() ... DONE
[10:22:48.580]    + additional globals found: [n=0] 
[10:22:48.580]    + additional namespaces needed: [n=0] 
[10:22:48.580]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.580]  - seeds: <none>
[10:22:48.580]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.580] getGlobalsAndPackages() ...
[10:22:48.580] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.581] Resolving globals: FALSE
[10:22:48.581] Tweak future expression to call with '...' arguments ...
[10:22:48.581] {
[10:22:48.581]     do.call(function(...) {
[10:22:48.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.581]             on.exit(options(oopts), add = TRUE)
[10:22:48.581]         }
[10:22:48.581]         {
[10:22:48.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.581]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.581]             })
[10:22:48.581]         }
[10:22:48.581]     }, args = future.call.arguments)
[10:22:48.581] }
[10:22:48.581] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.581] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.581] 
[10:22:48.582] getGlobalsAndPackages() ... DONE
[10:22:48.582] run() for ‘Future’ ...
[10:22:48.582] - state: ‘created’
[10:22:48.583] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:48.583] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.583]   - Field: ‘label’
[10:22:48.583]   - Field: ‘local’
[10:22:48.583]   - Field: ‘owner’
[10:22:48.585]   - Field: ‘envir’
[10:22:48.585]   - Field: ‘packages’
[10:22:48.585]   - Field: ‘gc’
[10:22:48.585]   - Field: ‘conditions’
[10:22:48.586]   - Field: ‘expr’
[10:22:48.586]   - Field: ‘uuid’
[10:22:48.586]   - Field: ‘seed’
[10:22:48.586]   - Field: ‘version’
[10:22:48.586]   - Field: ‘result’
[10:22:48.586]   - Field: ‘asynchronous’
[10:22:48.586]   - Field: ‘calls’
[10:22:48.586]   - Field: ‘globals’
[10:22:48.586]   - Field: ‘stdout’
[10:22:48.586]   - Field: ‘earlySignal’
[10:22:48.586]   - Field: ‘lazy’
[10:22:48.587]   - Field: ‘state’
[10:22:48.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.587] - Launch lazy future ...
[10:22:48.588] Packages needed by the future expression (n = 0): <none>
[10:22:48.588] Packages needed by future strategies (n = 0): <none>
[10:22:48.588] {
[10:22:48.588]     {
[10:22:48.588]         {
[10:22:48.588]             ...future.startTime <- base::Sys.time()
[10:22:48.588]             {
[10:22:48.588]                 {
[10:22:48.588]                   {
[10:22:48.588]                     base::local({
[10:22:48.588]                       has_future <- base::requireNamespace("future", 
[10:22:48.588]                         quietly = TRUE)
[10:22:48.588]                       if (has_future) {
[10:22:48.588]                         ns <- base::getNamespace("future")
[10:22:48.588]                         version <- ns[[".package"]][["version"]]
[10:22:48.588]                         if (is.null(version)) 
[10:22:48.588]                           version <- utils::packageVersion("future")
[10:22:48.588]                       }
[10:22:48.588]                       else {
[10:22:48.588]                         version <- NULL
[10:22:48.588]                       }
[10:22:48.588]                       if (!has_future || version < "1.8.0") {
[10:22:48.588]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.588]                           "", base::R.version$version.string), 
[10:22:48.588]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:48.588]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.588]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.588]                             "release", "version")], collapse = " "), 
[10:22:48.588]                           hostname = base::Sys.info()[["nodename"]])
[10:22:48.588]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.588]                           info)
[10:22:48.588]                         info <- base::paste(info, collapse = "; ")
[10:22:48.588]                         if (!has_future) {
[10:22:48.588]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.588]                             info)
[10:22:48.588]                         }
[10:22:48.588]                         else {
[10:22:48.588]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.588]                             info, version)
[10:22:48.588]                         }
[10:22:48.588]                         base::stop(msg)
[10:22:48.588]                       }
[10:22:48.588]                     })
[10:22:48.588]                   }
[10:22:48.588]                   options(future.plan = NULL)
[10:22:48.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.588]                 }
[10:22:48.588]                 ...future.workdir <- getwd()
[10:22:48.588]             }
[10:22:48.588]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.588]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.588]         }
[10:22:48.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.588]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.588]             base::names(...future.oldOptions))
[10:22:48.588]     }
[10:22:48.588]     if (FALSE) {
[10:22:48.588]     }
[10:22:48.588]     else {
[10:22:48.588]         if (TRUE) {
[10:22:48.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.588]                 open = "w")
[10:22:48.588]         }
[10:22:48.588]         else {
[10:22:48.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.588]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.588]         }
[10:22:48.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.588]             base::sink(type = "output", split = FALSE)
[10:22:48.588]             base::close(...future.stdout)
[10:22:48.588]         }, add = TRUE)
[10:22:48.588]     }
[10:22:48.588]     ...future.frame <- base::sys.nframe()
[10:22:48.588]     ...future.conditions <- base::list()
[10:22:48.588]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.588]     if (FALSE) {
[10:22:48.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.588]     }
[10:22:48.588]     ...future.result <- base::tryCatch({
[10:22:48.588]         base::withCallingHandlers({
[10:22:48.588]             ...future.value <- base::withVisible(base::local({
[10:22:48.588]                 do.call(function(...) {
[10:22:48.588]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.588]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.588]                     ...future.globals.maxSize)) {
[10:22:48.588]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.588]                     on.exit(options(oopts), add = TRUE)
[10:22:48.588]                   }
[10:22:48.588]                   {
[10:22:48.588]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.588]                       FUN = function(jj) {
[10:22:48.588]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.588]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.588]                       })
[10:22:48.588]                   }
[10:22:48.588]                 }, args = future.call.arguments)
[10:22:48.588]             }))
[10:22:48.588]             future::FutureResult(value = ...future.value$value, 
[10:22:48.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.588]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.588]                     ...future.globalenv.names))
[10:22:48.588]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.588]         }, condition = base::local({
[10:22:48.588]             c <- base::c
[10:22:48.588]             inherits <- base::inherits
[10:22:48.588]             invokeRestart <- base::invokeRestart
[10:22:48.588]             length <- base::length
[10:22:48.588]             list <- base::list
[10:22:48.588]             seq.int <- base::seq.int
[10:22:48.588]             signalCondition <- base::signalCondition
[10:22:48.588]             sys.calls <- base::sys.calls
[10:22:48.588]             `[[` <- base::`[[`
[10:22:48.588]             `+` <- base::`+`
[10:22:48.588]             `<<-` <- base::`<<-`
[10:22:48.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.588]                   3L)]
[10:22:48.588]             }
[10:22:48.588]             function(cond) {
[10:22:48.588]                 is_error <- inherits(cond, "error")
[10:22:48.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.588]                   NULL)
[10:22:48.588]                 if (is_error) {
[10:22:48.588]                   sessionInformation <- function() {
[10:22:48.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.588]                       search = base::search(), system = base::Sys.info())
[10:22:48.588]                   }
[10:22:48.588]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.588]                     cond$call), session = sessionInformation(), 
[10:22:48.588]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.588]                   signalCondition(cond)
[10:22:48.588]                 }
[10:22:48.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.588]                 "immediateCondition"))) {
[10:22:48.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.588]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.588]                   if (TRUE && !signal) {
[10:22:48.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.588]                     {
[10:22:48.588]                       inherits <- base::inherits
[10:22:48.588]                       invokeRestart <- base::invokeRestart
[10:22:48.588]                       is.null <- base::is.null
[10:22:48.588]                       muffled <- FALSE
[10:22:48.588]                       if (inherits(cond, "message")) {
[10:22:48.588]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.588]                         if (muffled) 
[10:22:48.588]                           invokeRestart("muffleMessage")
[10:22:48.588]                       }
[10:22:48.588]                       else if (inherits(cond, "warning")) {
[10:22:48.588]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.588]                         if (muffled) 
[10:22:48.588]                           invokeRestart("muffleWarning")
[10:22:48.588]                       }
[10:22:48.588]                       else if (inherits(cond, "condition")) {
[10:22:48.588]                         if (!is.null(pattern)) {
[10:22:48.588]                           computeRestarts <- base::computeRestarts
[10:22:48.588]                           grepl <- base::grepl
[10:22:48.588]                           restarts <- computeRestarts(cond)
[10:22:48.588]                           for (restart in restarts) {
[10:22:48.588]                             name <- restart$name
[10:22:48.588]                             if (is.null(name)) 
[10:22:48.588]                               next
[10:22:48.588]                             if (!grepl(pattern, name)) 
[10:22:48.588]                               next
[10:22:48.588]                             invokeRestart(restart)
[10:22:48.588]                             muffled <- TRUE
[10:22:48.588]                             break
[10:22:48.588]                           }
[10:22:48.588]                         }
[10:22:48.588]                       }
[10:22:48.588]                       invisible(muffled)
[10:22:48.588]                     }
[10:22:48.588]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.588]                   }
[10:22:48.588]                 }
[10:22:48.588]                 else {
[10:22:48.588]                   if (TRUE) {
[10:22:48.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.588]                     {
[10:22:48.588]                       inherits <- base::inherits
[10:22:48.588]                       invokeRestart <- base::invokeRestart
[10:22:48.588]                       is.null <- base::is.null
[10:22:48.588]                       muffled <- FALSE
[10:22:48.588]                       if (inherits(cond, "message")) {
[10:22:48.588]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.588]                         if (muffled) 
[10:22:48.588]                           invokeRestart("muffleMessage")
[10:22:48.588]                       }
[10:22:48.588]                       else if (inherits(cond, "warning")) {
[10:22:48.588]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.588]                         if (muffled) 
[10:22:48.588]                           invokeRestart("muffleWarning")
[10:22:48.588]                       }
[10:22:48.588]                       else if (inherits(cond, "condition")) {
[10:22:48.588]                         if (!is.null(pattern)) {
[10:22:48.588]                           computeRestarts <- base::computeRestarts
[10:22:48.588]                           grepl <- base::grepl
[10:22:48.588]                           restarts <- computeRestarts(cond)
[10:22:48.588]                           for (restart in restarts) {
[10:22:48.588]                             name <- restart$name
[10:22:48.588]                             if (is.null(name)) 
[10:22:48.588]                               next
[10:22:48.588]                             if (!grepl(pattern, name)) 
[10:22:48.588]                               next
[10:22:48.588]                             invokeRestart(restart)
[10:22:48.588]                             muffled <- TRUE
[10:22:48.588]                             break
[10:22:48.588]                           }
[10:22:48.588]                         }
[10:22:48.588]                       }
[10:22:48.588]                       invisible(muffled)
[10:22:48.588]                     }
[10:22:48.588]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.588]                   }
[10:22:48.588]                 }
[10:22:48.588]             }
[10:22:48.588]         }))
[10:22:48.588]     }, error = function(ex) {
[10:22:48.588]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.588]                 ...future.rng), started = ...future.startTime, 
[10:22:48.588]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.588]             version = "1.8"), class = "FutureResult")
[10:22:48.588]     }, finally = {
[10:22:48.588]         if (!identical(...future.workdir, getwd())) 
[10:22:48.588]             setwd(...future.workdir)
[10:22:48.588]         {
[10:22:48.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.588]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.588]             }
[10:22:48.588]             base::options(...future.oldOptions)
[10:22:48.588]             if (.Platform$OS.type == "windows") {
[10:22:48.588]                 old_names <- names(...future.oldEnvVars)
[10:22:48.588]                 envs <- base::Sys.getenv()
[10:22:48.588]                 names <- names(envs)
[10:22:48.588]                 common <- intersect(names, old_names)
[10:22:48.588]                 added <- setdiff(names, old_names)
[10:22:48.588]                 removed <- setdiff(old_names, names)
[10:22:48.588]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.588]                   envs[common]]
[10:22:48.588]                 NAMES <- toupper(changed)
[10:22:48.588]                 args <- list()
[10:22:48.588]                 for (kk in seq_along(NAMES)) {
[10:22:48.588]                   name <- changed[[kk]]
[10:22:48.588]                   NAME <- NAMES[[kk]]
[10:22:48.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.588]                     next
[10:22:48.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.588]                 }
[10:22:48.588]                 NAMES <- toupper(added)
[10:22:48.588]                 for (kk in seq_along(NAMES)) {
[10:22:48.588]                   name <- added[[kk]]
[10:22:48.588]                   NAME <- NAMES[[kk]]
[10:22:48.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.588]                     next
[10:22:48.588]                   args[[name]] <- ""
[10:22:48.588]                 }
[10:22:48.588]                 NAMES <- toupper(removed)
[10:22:48.588]                 for (kk in seq_along(NAMES)) {
[10:22:48.588]                   name <- removed[[kk]]
[10:22:48.588]                   NAME <- NAMES[[kk]]
[10:22:48.588]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.588]                     next
[10:22:48.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.588]                 }
[10:22:48.588]                 if (length(args) > 0) 
[10:22:48.588]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.588]             }
[10:22:48.588]             else {
[10:22:48.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.588]             }
[10:22:48.588]             {
[10:22:48.588]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.588]                   0L) {
[10:22:48.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.588]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.588]                   base::options(opts)
[10:22:48.588]                 }
[10:22:48.588]                 {
[10:22:48.588]                   {
[10:22:48.588]                     NULL
[10:22:48.588]                     RNGkind("Mersenne-Twister")
[10:22:48.588]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.588]                       inherits = FALSE)
[10:22:48.588]                   }
[10:22:48.588]                   options(future.plan = NULL)
[10:22:48.588]                   if (is.na(NA_character_)) 
[10:22:48.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.588]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:48.588]                   {
[10:22:48.588]                     future <- SequentialFuture(..., envir = envir)
[10:22:48.588]                     if (!future$lazy) 
[10:22:48.588]                       future <- run(future)
[10:22:48.588]                     invisible(future)
[10:22:48.588]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.588]                 }
[10:22:48.588]             }
[10:22:48.588]         }
[10:22:48.588]     })
[10:22:48.588]     if (TRUE) {
[10:22:48.588]         base::sink(type = "output", split = FALSE)
[10:22:48.588]         if (TRUE) {
[10:22:48.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.588]         }
[10:22:48.588]         else {
[10:22:48.588]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.588]         }
[10:22:48.588]         base::close(...future.stdout)
[10:22:48.588]         ...future.stdout <- NULL
[10:22:48.588]     }
[10:22:48.588]     ...future.result$conditions <- ...future.conditions
[10:22:48.588]     ...future.result$finished <- base::Sys.time()
[10:22:48.588]     ...future.result
[10:22:48.588] }
[10:22:48.590] assign_globals() ...
[10:22:48.590] List of 5
[10:22:48.590]  $ ...future.FUN            :function (object, ...)  
[10:22:48.590]  $ future.call.arguments    : list()
[10:22:48.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.590]  $ ...future.elements_ii    :List of 3
[10:22:48.590]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:48.590]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.590]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.590]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:48.590]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.590]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.590]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:48.590]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.590]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.590]  $ ...future.seeds_ii       : NULL
[10:22:48.590]  $ ...future.globals.maxSize: NULL
[10:22:48.590]  - attr(*, "where")=List of 5
[10:22:48.590]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.590]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.590]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.590]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.590]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.590]  - attr(*, "resolved")= logi FALSE
[10:22:48.590]  - attr(*, "total_size")= num 1240
[10:22:48.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.590]  - attr(*, "already-done")= logi TRUE
[10:22:48.598] - copied ‘...future.FUN’ to environment
[10:22:48.598] - copied ‘future.call.arguments’ to environment
[10:22:48.598] - copied ‘...future.elements_ii’ to environment
[10:22:48.598] - copied ‘...future.seeds_ii’ to environment
[10:22:48.598] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.598] assign_globals() ... done
[10:22:48.598] plan(): Setting new future strategy stack:
[10:22:48.598] List of future strategies:
[10:22:48.598] 1. sequential:
[10:22:48.598]    - args: function (..., envir = parent.frame())
[10:22:48.598]    - tweaked: FALSE
[10:22:48.598]    - call: NULL
[10:22:48.599] plan(): nbrOfWorkers() = 1
[10:22:48.601] plan(): Setting new future strategy stack:
[10:22:48.601] List of future strategies:
[10:22:48.601] 1. sequential:
[10:22:48.601]    - args: function (..., envir = parent.frame())
[10:22:48.601]    - tweaked: FALSE
[10:22:48.601]    - call: plan(strategy)
[10:22:48.601] plan(): nbrOfWorkers() = 1
[10:22:48.602] SequentialFuture started (and completed)
[10:22:48.602] - Launch lazy future ... done
[10:22:48.602] run() for ‘SequentialFuture’ ... done
[10:22:48.602] Created future:
[10:22:48.602] SequentialFuture:
[10:22:48.602] Label: ‘future_by-1’
[10:22:48.602] Expression:
[10:22:48.602] {
[10:22:48.602]     do.call(function(...) {
[10:22:48.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.602]             on.exit(options(oopts), add = TRUE)
[10:22:48.602]         }
[10:22:48.602]         {
[10:22:48.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.602]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.602]             })
[10:22:48.602]         }
[10:22:48.602]     }, args = future.call.arguments)
[10:22:48.602] }
[10:22:48.602] Lazy evaluation: FALSE
[10:22:48.602] Asynchronous evaluation: FALSE
[10:22:48.602] Local evaluation: TRUE
[10:22:48.602] Environment: R_GlobalEnv
[10:22:48.602] Capture standard output: TRUE
[10:22:48.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.602] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.602] Packages: <none>
[10:22:48.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.602] Resolved: TRUE
[10:22:48.602] Value: 4.62 KiB of class ‘list’
[10:22:48.602] Early signaling: FALSE
[10:22:48.602] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.602] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.604] Chunk #1 of 1 ... DONE
[10:22:48.604] Launching 1 futures (chunks) ... DONE
[10:22:48.604] Resolving 1 futures (chunks) ...
[10:22:48.604] resolve() on list ...
[10:22:48.604]  recursive: 0
[10:22:48.604]  length: 1
[10:22:48.604] 
[10:22:48.605] resolved() for ‘SequentialFuture’ ...
[10:22:48.605] - state: ‘finished’
[10:22:48.605] - run: TRUE
[10:22:48.605] - result: ‘FutureResult’
[10:22:48.605] resolved() for ‘SequentialFuture’ ... done
[10:22:48.605] Future #1
[10:22:48.606] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.606] - nx: 1
[10:22:48.606] - relay: TRUE
[10:22:48.606] - stdout: TRUE
[10:22:48.606] - signal: TRUE
[10:22:48.606] - resignal: FALSE
[10:22:48.606] - force: TRUE
[10:22:48.606] - relayed: [n=1] FALSE
[10:22:48.606] - queued futures: [n=1] FALSE
[10:22:48.606]  - until=1
[10:22:48.606]  - relaying element #1
[10:22:48.607] - relayed: [n=1] TRUE
[10:22:48.607] - queued futures: [n=1] TRUE
[10:22:48.607] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.607]  length: 0 (resolved future 1)
[10:22:48.607] Relaying remaining futures
[10:22:48.607] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.607] - nx: 1
[10:22:48.607] - relay: TRUE
[10:22:48.607] - stdout: TRUE
[10:22:48.607] - signal: TRUE
[10:22:48.608] - resignal: FALSE
[10:22:48.608] - force: TRUE
[10:22:48.608] - relayed: [n=1] TRUE
[10:22:48.608] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.608] - relayed: [n=1] TRUE
[10:22:48.608] - queued futures: [n=1] TRUE
[10:22:48.608] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.608] resolve() on list ... DONE
[10:22:48.608]  - Number of value chunks collected: 1
[10:22:48.608] Resolving 1 futures (chunks) ... DONE
[10:22:48.608] Reducing values from 1 chunks ...
[10:22:48.609]  - Number of values collected after concatenation: 3
[10:22:48.609]  - Number of values expected: 3
[10:22:48.609] Reducing values from 1 chunks ... DONE
[10:22:48.609] future_lapply() ... DONE
[10:22:48.609] future_by_internal() ... DONE
[10:22:48.611] future_by_internal() ...
[10:22:48.611] future_lapply() ...
[10:22:48.612] Number of chunks: 1
[10:22:48.612] getGlobalsAndPackagesXApply() ...
[10:22:48.612]  - future.globals: TRUE
[10:22:48.612] getGlobalsAndPackages() ...
[10:22:48.612] Searching for globals...
[10:22:48.613] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:48.613] Searching for globals ... DONE
[10:22:48.613] Resolving globals: FALSE
[10:22:48.613] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:48.614] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:48.614] - globals: [1] ‘FUN’
[10:22:48.614] 
[10:22:48.614] getGlobalsAndPackages() ... DONE
[10:22:48.614]  - globals found/used: [n=1] ‘FUN’
[10:22:48.614]  - needed namespaces: [n=0] 
[10:22:48.614] Finding globals ... DONE
[10:22:48.614]  - use_args: TRUE
[10:22:48.615]  - Getting '...' globals ...
[10:22:48.615] resolve() on list ...
[10:22:48.615]  recursive: 0
[10:22:48.615]  length: 1
[10:22:48.615]  elements: ‘...’
[10:22:48.615]  length: 0 (resolved future 1)
[10:22:48.615] resolve() on list ... DONE
[10:22:48.615]    - '...' content: [n=1] ‘digits’
[10:22:48.615] List of 1
[10:22:48.615]  $ ...:List of 1
[10:22:48.615]   ..$ digits: int 2
[10:22:48.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.615]  - attr(*, "where")=List of 1
[10:22:48.615]   ..$ ...:<environment: 0x55f63914b3a0> 
[10:22:48.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.615]  - attr(*, "resolved")= logi TRUE
[10:22:48.615]  - attr(*, "total_size")= num NA
[10:22:48.618]  - Getting '...' globals ... DONE
[10:22:48.618] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.618] List of 2
[10:22:48.618]  $ ...future.FUN:function (object, ...)  
[10:22:48.618]  $ ...          :List of 1
[10:22:48.618]   ..$ digits: int 2
[10:22:48.618]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.618]  - attr(*, "where")=List of 2
[10:22:48.618]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.618]   ..$ ...          :<environment: 0x55f63914b3a0> 
[10:22:48.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.618]  - attr(*, "resolved")= logi FALSE
[10:22:48.618]  - attr(*, "total_size")= num 1296
[10:22:48.621] Packages to be attached in all futures: [n=0] 
[10:22:48.621] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.622] Number of futures (= number of chunks): 1
[10:22:48.622] Launching 1 futures (chunks) ...
[10:22:48.622] Chunk #1 of 1 ...
[10:22:48.622]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.622] getGlobalsAndPackages() ...
[10:22:48.622] Searching for globals...
[10:22:48.622] 
[10:22:48.622] Searching for globals ... DONE
[10:22:48.622] - globals: [0] <none>
[10:22:48.623] getGlobalsAndPackages() ... DONE
[10:22:48.623]    + additional globals found: [n=0] 
[10:22:48.623]    + additional namespaces needed: [n=0] 
[10:22:48.623]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.623]  - seeds: <none>
[10:22:48.623]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.623] getGlobalsAndPackages() ...
[10:22:48.623] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.623] Resolving globals: FALSE
[10:22:48.623] Tweak future expression to call with '...' arguments ...
[10:22:48.623] {
[10:22:48.623]     do.call(function(...) {
[10:22:48.623]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.623]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.623]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.623]             on.exit(options(oopts), add = TRUE)
[10:22:48.623]         }
[10:22:48.623]         {
[10:22:48.623]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.623]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.623]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.623]             })
[10:22:48.623]         }
[10:22:48.623]     }, args = future.call.arguments)
[10:22:48.623] }
[10:22:48.624] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.624] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.624] 
[10:22:48.624] getGlobalsAndPackages() ... DONE
[10:22:48.624] run() for ‘Future’ ...
[10:22:48.625] - state: ‘created’
[10:22:48.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:48.625] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.625]   - Field: ‘label’
[10:22:48.625]   - Field: ‘local’
[10:22:48.625]   - Field: ‘owner’
[10:22:48.625]   - Field: ‘envir’
[10:22:48.626]   - Field: ‘packages’
[10:22:48.626]   - Field: ‘gc’
[10:22:48.626]   - Field: ‘conditions’
[10:22:48.626]   - Field: ‘expr’
[10:22:48.626]   - Field: ‘uuid’
[10:22:48.626]   - Field: ‘seed’
[10:22:48.626]   - Field: ‘version’
[10:22:48.626]   - Field: ‘result’
[10:22:48.626]   - Field: ‘asynchronous’
[10:22:48.626]   - Field: ‘calls’
[10:22:48.626]   - Field: ‘globals’
[10:22:48.626]   - Field: ‘stdout’
[10:22:48.627]   - Field: ‘earlySignal’
[10:22:48.627]   - Field: ‘lazy’
[10:22:48.627]   - Field: ‘state’
[10:22:48.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.627] - Launch lazy future ...
[10:22:48.627] Packages needed by the future expression (n = 0): <none>
[10:22:48.627] Packages needed by future strategies (n = 0): <none>
[10:22:48.628] {
[10:22:48.628]     {
[10:22:48.628]         {
[10:22:48.628]             ...future.startTime <- base::Sys.time()
[10:22:48.628]             {
[10:22:48.628]                 {
[10:22:48.628]                   {
[10:22:48.628]                     base::local({
[10:22:48.628]                       has_future <- base::requireNamespace("future", 
[10:22:48.628]                         quietly = TRUE)
[10:22:48.628]                       if (has_future) {
[10:22:48.628]                         ns <- base::getNamespace("future")
[10:22:48.628]                         version <- ns[[".package"]][["version"]]
[10:22:48.628]                         if (is.null(version)) 
[10:22:48.628]                           version <- utils::packageVersion("future")
[10:22:48.628]                       }
[10:22:48.628]                       else {
[10:22:48.628]                         version <- NULL
[10:22:48.628]                       }
[10:22:48.628]                       if (!has_future || version < "1.8.0") {
[10:22:48.628]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.628]                           "", base::R.version$version.string), 
[10:22:48.628]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:48.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.628]                             "release", "version")], collapse = " "), 
[10:22:48.628]                           hostname = base::Sys.info()[["nodename"]])
[10:22:48.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.628]                           info)
[10:22:48.628]                         info <- base::paste(info, collapse = "; ")
[10:22:48.628]                         if (!has_future) {
[10:22:48.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.628]                             info)
[10:22:48.628]                         }
[10:22:48.628]                         else {
[10:22:48.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.628]                             info, version)
[10:22:48.628]                         }
[10:22:48.628]                         base::stop(msg)
[10:22:48.628]                       }
[10:22:48.628]                     })
[10:22:48.628]                   }
[10:22:48.628]                   options(future.plan = NULL)
[10:22:48.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.628]                 }
[10:22:48.628]                 ...future.workdir <- getwd()
[10:22:48.628]             }
[10:22:48.628]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.628]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.628]         }
[10:22:48.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.628]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.628]             base::names(...future.oldOptions))
[10:22:48.628]     }
[10:22:48.628]     if (FALSE) {
[10:22:48.628]     }
[10:22:48.628]     else {
[10:22:48.628]         if (TRUE) {
[10:22:48.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.628]                 open = "w")
[10:22:48.628]         }
[10:22:48.628]         else {
[10:22:48.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.628]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.628]         }
[10:22:48.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.628]             base::sink(type = "output", split = FALSE)
[10:22:48.628]             base::close(...future.stdout)
[10:22:48.628]         }, add = TRUE)
[10:22:48.628]     }
[10:22:48.628]     ...future.frame <- base::sys.nframe()
[10:22:48.628]     ...future.conditions <- base::list()
[10:22:48.628]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.628]     if (FALSE) {
[10:22:48.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.628]     }
[10:22:48.628]     ...future.result <- base::tryCatch({
[10:22:48.628]         base::withCallingHandlers({
[10:22:48.628]             ...future.value <- base::withVisible(base::local({
[10:22:48.628]                 do.call(function(...) {
[10:22:48.628]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.628]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.628]                     ...future.globals.maxSize)) {
[10:22:48.628]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.628]                     on.exit(options(oopts), add = TRUE)
[10:22:48.628]                   }
[10:22:48.628]                   {
[10:22:48.628]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.628]                       FUN = function(jj) {
[10:22:48.628]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.628]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.628]                       })
[10:22:48.628]                   }
[10:22:48.628]                 }, args = future.call.arguments)
[10:22:48.628]             }))
[10:22:48.628]             future::FutureResult(value = ...future.value$value, 
[10:22:48.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.628]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.628]                     ...future.globalenv.names))
[10:22:48.628]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.628]         }, condition = base::local({
[10:22:48.628]             c <- base::c
[10:22:48.628]             inherits <- base::inherits
[10:22:48.628]             invokeRestart <- base::invokeRestart
[10:22:48.628]             length <- base::length
[10:22:48.628]             list <- base::list
[10:22:48.628]             seq.int <- base::seq.int
[10:22:48.628]             signalCondition <- base::signalCondition
[10:22:48.628]             sys.calls <- base::sys.calls
[10:22:48.628]             `[[` <- base::`[[`
[10:22:48.628]             `+` <- base::`+`
[10:22:48.628]             `<<-` <- base::`<<-`
[10:22:48.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.628]                   3L)]
[10:22:48.628]             }
[10:22:48.628]             function(cond) {
[10:22:48.628]                 is_error <- inherits(cond, "error")
[10:22:48.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.628]                   NULL)
[10:22:48.628]                 if (is_error) {
[10:22:48.628]                   sessionInformation <- function() {
[10:22:48.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.628]                       search = base::search(), system = base::Sys.info())
[10:22:48.628]                   }
[10:22:48.628]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.628]                     cond$call), session = sessionInformation(), 
[10:22:48.628]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.628]                   signalCondition(cond)
[10:22:48.628]                 }
[10:22:48.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.628]                 "immediateCondition"))) {
[10:22:48.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.628]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.628]                   if (TRUE && !signal) {
[10:22:48.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.628]                     {
[10:22:48.628]                       inherits <- base::inherits
[10:22:48.628]                       invokeRestart <- base::invokeRestart
[10:22:48.628]                       is.null <- base::is.null
[10:22:48.628]                       muffled <- FALSE
[10:22:48.628]                       if (inherits(cond, "message")) {
[10:22:48.628]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.628]                         if (muffled) 
[10:22:48.628]                           invokeRestart("muffleMessage")
[10:22:48.628]                       }
[10:22:48.628]                       else if (inherits(cond, "warning")) {
[10:22:48.628]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.628]                         if (muffled) 
[10:22:48.628]                           invokeRestart("muffleWarning")
[10:22:48.628]                       }
[10:22:48.628]                       else if (inherits(cond, "condition")) {
[10:22:48.628]                         if (!is.null(pattern)) {
[10:22:48.628]                           computeRestarts <- base::computeRestarts
[10:22:48.628]                           grepl <- base::grepl
[10:22:48.628]                           restarts <- computeRestarts(cond)
[10:22:48.628]                           for (restart in restarts) {
[10:22:48.628]                             name <- restart$name
[10:22:48.628]                             if (is.null(name)) 
[10:22:48.628]                               next
[10:22:48.628]                             if (!grepl(pattern, name)) 
[10:22:48.628]                               next
[10:22:48.628]                             invokeRestart(restart)
[10:22:48.628]                             muffled <- TRUE
[10:22:48.628]                             break
[10:22:48.628]                           }
[10:22:48.628]                         }
[10:22:48.628]                       }
[10:22:48.628]                       invisible(muffled)
[10:22:48.628]                     }
[10:22:48.628]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.628]                   }
[10:22:48.628]                 }
[10:22:48.628]                 else {
[10:22:48.628]                   if (TRUE) {
[10:22:48.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.628]                     {
[10:22:48.628]                       inherits <- base::inherits
[10:22:48.628]                       invokeRestart <- base::invokeRestart
[10:22:48.628]                       is.null <- base::is.null
[10:22:48.628]                       muffled <- FALSE
[10:22:48.628]                       if (inherits(cond, "message")) {
[10:22:48.628]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.628]                         if (muffled) 
[10:22:48.628]                           invokeRestart("muffleMessage")
[10:22:48.628]                       }
[10:22:48.628]                       else if (inherits(cond, "warning")) {
[10:22:48.628]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.628]                         if (muffled) 
[10:22:48.628]                           invokeRestart("muffleWarning")
[10:22:48.628]                       }
[10:22:48.628]                       else if (inherits(cond, "condition")) {
[10:22:48.628]                         if (!is.null(pattern)) {
[10:22:48.628]                           computeRestarts <- base::computeRestarts
[10:22:48.628]                           grepl <- base::grepl
[10:22:48.628]                           restarts <- computeRestarts(cond)
[10:22:48.628]                           for (restart in restarts) {
[10:22:48.628]                             name <- restart$name
[10:22:48.628]                             if (is.null(name)) 
[10:22:48.628]                               next
[10:22:48.628]                             if (!grepl(pattern, name)) 
[10:22:48.628]                               next
[10:22:48.628]                             invokeRestart(restart)
[10:22:48.628]                             muffled <- TRUE
[10:22:48.628]                             break
[10:22:48.628]                           }
[10:22:48.628]                         }
[10:22:48.628]                       }
[10:22:48.628]                       invisible(muffled)
[10:22:48.628]                     }
[10:22:48.628]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.628]                   }
[10:22:48.628]                 }
[10:22:48.628]             }
[10:22:48.628]         }))
[10:22:48.628]     }, error = function(ex) {
[10:22:48.628]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.628]                 ...future.rng), started = ...future.startTime, 
[10:22:48.628]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.628]             version = "1.8"), class = "FutureResult")
[10:22:48.628]     }, finally = {
[10:22:48.628]         if (!identical(...future.workdir, getwd())) 
[10:22:48.628]             setwd(...future.workdir)
[10:22:48.628]         {
[10:22:48.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.628]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.628]             }
[10:22:48.628]             base::options(...future.oldOptions)
[10:22:48.628]             if (.Platform$OS.type == "windows") {
[10:22:48.628]                 old_names <- names(...future.oldEnvVars)
[10:22:48.628]                 envs <- base::Sys.getenv()
[10:22:48.628]                 names <- names(envs)
[10:22:48.628]                 common <- intersect(names, old_names)
[10:22:48.628]                 added <- setdiff(names, old_names)
[10:22:48.628]                 removed <- setdiff(old_names, names)
[10:22:48.628]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.628]                   envs[common]]
[10:22:48.628]                 NAMES <- toupper(changed)
[10:22:48.628]                 args <- list()
[10:22:48.628]                 for (kk in seq_along(NAMES)) {
[10:22:48.628]                   name <- changed[[kk]]
[10:22:48.628]                   NAME <- NAMES[[kk]]
[10:22:48.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.628]                     next
[10:22:48.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.628]                 }
[10:22:48.628]                 NAMES <- toupper(added)
[10:22:48.628]                 for (kk in seq_along(NAMES)) {
[10:22:48.628]                   name <- added[[kk]]
[10:22:48.628]                   NAME <- NAMES[[kk]]
[10:22:48.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.628]                     next
[10:22:48.628]                   args[[name]] <- ""
[10:22:48.628]                 }
[10:22:48.628]                 NAMES <- toupper(removed)
[10:22:48.628]                 for (kk in seq_along(NAMES)) {
[10:22:48.628]                   name <- removed[[kk]]
[10:22:48.628]                   NAME <- NAMES[[kk]]
[10:22:48.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.628]                     next
[10:22:48.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.628]                 }
[10:22:48.628]                 if (length(args) > 0) 
[10:22:48.628]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.628]             }
[10:22:48.628]             else {
[10:22:48.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.628]             }
[10:22:48.628]             {
[10:22:48.628]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.628]                   0L) {
[10:22:48.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.628]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.628]                   base::options(opts)
[10:22:48.628]                 }
[10:22:48.628]                 {
[10:22:48.628]                   {
[10:22:48.628]                     NULL
[10:22:48.628]                     RNGkind("Mersenne-Twister")
[10:22:48.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.628]                       inherits = FALSE)
[10:22:48.628]                   }
[10:22:48.628]                   options(future.plan = NULL)
[10:22:48.628]                   if (is.na(NA_character_)) 
[10:22:48.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.628]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:48.628]                   {
[10:22:48.628]                     future <- SequentialFuture(..., envir = envir)
[10:22:48.628]                     if (!future$lazy) 
[10:22:48.628]                       future <- run(future)
[10:22:48.628]                     invisible(future)
[10:22:48.628]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.628]                 }
[10:22:48.628]             }
[10:22:48.628]         }
[10:22:48.628]     })
[10:22:48.628]     if (TRUE) {
[10:22:48.628]         base::sink(type = "output", split = FALSE)
[10:22:48.628]         if (TRUE) {
[10:22:48.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.628]         }
[10:22:48.628]         else {
[10:22:48.628]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.628]         }
[10:22:48.628]         base::close(...future.stdout)
[10:22:48.628]         ...future.stdout <- NULL
[10:22:48.628]     }
[10:22:48.628]     ...future.result$conditions <- ...future.conditions
[10:22:48.628]     ...future.result$finished <- base::Sys.time()
[10:22:48.628]     ...future.result
[10:22:48.628] }
[10:22:48.629] assign_globals() ...
[10:22:48.629] List of 5
[10:22:48.629]  $ ...future.FUN            :function (object, ...)  
[10:22:48.629]  $ future.call.arguments    :List of 1
[10:22:48.629]   ..$ digits: int 2
[10:22:48.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.629]  $ ...future.elements_ii    :List of 6
[10:22:48.629]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:22:48.629]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:22:48.629]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:22:48.629]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:22:48.629]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:22:48.629]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:22:48.629]  $ ...future.seeds_ii       : NULL
[10:22:48.629]  $ ...future.globals.maxSize: NULL
[10:22:48.629]  - attr(*, "where")=List of 5
[10:22:48.629]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.629]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.629]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.629]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.629]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.629]  - attr(*, "resolved")= logi FALSE
[10:22:48.629]  - attr(*, "total_size")= num 1296
[10:22:48.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.629]  - attr(*, "already-done")= logi TRUE
[10:22:48.636] - copied ‘...future.FUN’ to environment
[10:22:48.637] - copied ‘future.call.arguments’ to environment
[10:22:48.637] - copied ‘...future.elements_ii’ to environment
[10:22:48.637] - copied ‘...future.seeds_ii’ to environment
[10:22:48.637] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.637] assign_globals() ... done
[10:22:48.637] plan(): Setting new future strategy stack:
[10:22:48.637] List of future strategies:
[10:22:48.637] 1. sequential:
[10:22:48.637]    - args: function (..., envir = parent.frame())
[10:22:48.637]    - tweaked: FALSE
[10:22:48.637]    - call: NULL
[10:22:48.638] plan(): nbrOfWorkers() = 1
[10:22:48.639] plan(): Setting new future strategy stack:
[10:22:48.639] List of future strategies:
[10:22:48.639] 1. sequential:
[10:22:48.639]    - args: function (..., envir = parent.frame())
[10:22:48.639]    - tweaked: FALSE
[10:22:48.639]    - call: plan(strategy)
[10:22:48.639] plan(): nbrOfWorkers() = 1
[10:22:48.640] SequentialFuture started (and completed)
[10:22:48.640] - Launch lazy future ... done
[10:22:48.640] run() for ‘SequentialFuture’ ... done
[10:22:48.640] Created future:
[10:22:48.640] SequentialFuture:
[10:22:48.640] Label: ‘future_by-1’
[10:22:48.640] Expression:
[10:22:48.640] {
[10:22:48.640]     do.call(function(...) {
[10:22:48.640]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.640]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.640]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.640]             on.exit(options(oopts), add = TRUE)
[10:22:48.640]         }
[10:22:48.640]         {
[10:22:48.640]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.640]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.640]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.640]             })
[10:22:48.640]         }
[10:22:48.640]     }, args = future.call.arguments)
[10:22:48.640] }
[10:22:48.640] Lazy evaluation: FALSE
[10:22:48.640] Asynchronous evaluation: FALSE
[10:22:48.640] Local evaluation: TRUE
[10:22:48.640] Environment: R_GlobalEnv
[10:22:48.640] Capture standard output: TRUE
[10:22:48.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.640] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.640] Packages: <none>
[10:22:48.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.640] Resolved: TRUE
[10:22:48.640] Value: 5.48 KiB of class ‘list’
[10:22:48.640] Early signaling: FALSE
[10:22:48.640] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.640] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.641] Chunk #1 of 1 ... DONE
[10:22:48.641] Launching 1 futures (chunks) ... DONE
[10:22:48.641] Resolving 1 futures (chunks) ...
[10:22:48.641] resolve() on list ...
[10:22:48.641]  recursive: 0
[10:22:48.641]  length: 1
[10:22:48.641] 
[10:22:48.641] resolved() for ‘SequentialFuture’ ...
[10:22:48.642] - state: ‘finished’
[10:22:48.642] - run: TRUE
[10:22:48.642] - result: ‘FutureResult’
[10:22:48.642] resolved() for ‘SequentialFuture’ ... done
[10:22:48.642] Future #1
[10:22:48.642] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.642] - nx: 1
[10:22:48.642] - relay: TRUE
[10:22:48.642] - stdout: TRUE
[10:22:48.642] - signal: TRUE
[10:22:48.642] - resignal: FALSE
[10:22:48.642] - force: TRUE
[10:22:48.643] - relayed: [n=1] FALSE
[10:22:48.643] - queued futures: [n=1] FALSE
[10:22:48.643]  - until=1
[10:22:48.643]  - relaying element #1
[10:22:48.643] - relayed: [n=1] TRUE
[10:22:48.643] - queued futures: [n=1] TRUE
[10:22:48.643] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.643]  length: 0 (resolved future 1)
[10:22:48.643] Relaying remaining futures
[10:22:48.643] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.644] - nx: 1
[10:22:48.644] - relay: TRUE
[10:22:48.644] - stdout: TRUE
[10:22:48.644] - signal: TRUE
[10:22:48.644] - resignal: FALSE
[10:22:48.644] - force: TRUE
[10:22:48.644] - relayed: [n=1] TRUE
[10:22:48.644] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.644] - relayed: [n=1] TRUE
[10:22:48.644] - queued futures: [n=1] TRUE
[10:22:48.644] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.644] resolve() on list ... DONE
[10:22:48.645]  - Number of value chunks collected: 1
[10:22:48.645] Resolving 1 futures (chunks) ... DONE
[10:22:48.645] Reducing values from 1 chunks ...
[10:22:48.645]  - Number of values collected after concatenation: 6
[10:22:48.645]  - Number of values expected: 6
[10:22:48.645] Reducing values from 1 chunks ... DONE
[10:22:48.645] future_lapply() ... DONE
[10:22:48.645] future_by_internal() ... DONE
[10:22:48.648] future_by_internal() ...
[10:22:48.648] future_lapply() ...
[10:22:48.649] Number of chunks: 1
[10:22:48.649] getGlobalsAndPackagesXApply() ...
[10:22:48.649]  - future.globals: TRUE
[10:22:48.650] getGlobalsAndPackages() ...
[10:22:48.650] Searching for globals...
[10:22:48.652] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:48.652] Searching for globals ... DONE
[10:22:48.652] Resolving globals: FALSE
[10:22:48.653] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:22:48.653] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:22:48.653] - globals: [1] ‘FUN’
[10:22:48.653] - packages: [1] ‘stats’
[10:22:48.653] getGlobalsAndPackages() ... DONE
[10:22:48.653]  - globals found/used: [n=1] ‘FUN’
[10:22:48.653]  - needed namespaces: [n=1] ‘stats’
[10:22:48.653] Finding globals ... DONE
[10:22:48.654]  - use_args: TRUE
[10:22:48.654]  - Getting '...' globals ...
[10:22:48.654] resolve() on list ...
[10:22:48.654]  recursive: 0
[10:22:48.654]  length: 1
[10:22:48.654]  elements: ‘...’
[10:22:48.654]  length: 0 (resolved future 1)
[10:22:48.654] resolve() on list ... DONE
[10:22:48.654]    - '...' content: [n=1] ‘singular.ok’
[10:22:48.655] List of 1
[10:22:48.655]  $ ...:List of 1
[10:22:48.655]   ..$ singular.ok: logi FALSE
[10:22:48.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.655]  - attr(*, "where")=List of 1
[10:22:48.655]   ..$ ...:<environment: 0x55f63a1d49f8> 
[10:22:48.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.655]  - attr(*, "resolved")= logi TRUE
[10:22:48.655]  - attr(*, "total_size")= num NA
[10:22:48.657]  - Getting '...' globals ... DONE
[10:22:48.657] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.657] List of 2
[10:22:48.657]  $ ...future.FUN:function (x, ...)  
[10:22:48.657]  $ ...          :List of 1
[10:22:48.657]   ..$ singular.ok: logi FALSE
[10:22:48.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.657]  - attr(*, "where")=List of 2
[10:22:48.657]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.657]   ..$ ...          :<environment: 0x55f63a1d49f8> 
[10:22:48.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.657]  - attr(*, "resolved")= logi FALSE
[10:22:48.657]  - attr(*, "total_size")= num 5384
[10:22:48.660] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:48.660] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.661] Number of futures (= number of chunks): 1
[10:22:48.661] Launching 1 futures (chunks) ...
[10:22:48.661] Chunk #1 of 1 ...
[10:22:48.661]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.661] getGlobalsAndPackages() ...
[10:22:48.661] Searching for globals...
[10:22:48.662] 
[10:22:48.662] Searching for globals ... DONE
[10:22:48.662] - globals: [0] <none>
[10:22:48.662] getGlobalsAndPackages() ... DONE
[10:22:48.662]    + additional globals found: [n=0] 
[10:22:48.662]    + additional namespaces needed: [n=0] 
[10:22:48.662]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.662]  - seeds: <none>
[10:22:48.662]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.662] getGlobalsAndPackages() ...
[10:22:48.662] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.663] Resolving globals: FALSE
[10:22:48.663] Tweak future expression to call with '...' arguments ...
[10:22:48.663] {
[10:22:48.663]     do.call(function(...) {
[10:22:48.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.663]             on.exit(options(oopts), add = TRUE)
[10:22:48.663]         }
[10:22:48.663]         {
[10:22:48.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.663]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.663]             })
[10:22:48.663]         }
[10:22:48.663]     }, args = future.call.arguments)
[10:22:48.663] }
[10:22:48.663] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.663] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.663] 
[10:22:48.663] getGlobalsAndPackages() ... DONE
[10:22:48.664] run() for ‘Future’ ...
[10:22:48.664] - state: ‘created’
[10:22:48.664] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:48.664] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.664]   - Field: ‘label’
[10:22:48.664]   - Field: ‘local’
[10:22:48.665]   - Field: ‘owner’
[10:22:48.665]   - Field: ‘envir’
[10:22:48.665]   - Field: ‘packages’
[10:22:48.665]   - Field: ‘gc’
[10:22:48.665]   - Field: ‘conditions’
[10:22:48.665]   - Field: ‘expr’
[10:22:48.665]   - Field: ‘uuid’
[10:22:48.665]   - Field: ‘seed’
[10:22:48.665]   - Field: ‘version’
[10:22:48.665]   - Field: ‘result’
[10:22:48.665]   - Field: ‘asynchronous’
[10:22:48.666]   - Field: ‘calls’
[10:22:48.666]   - Field: ‘globals’
[10:22:48.666]   - Field: ‘stdout’
[10:22:48.666]   - Field: ‘earlySignal’
[10:22:48.666]   - Field: ‘lazy’
[10:22:48.666]   - Field: ‘state’
[10:22:48.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.666] - Launch lazy future ...
[10:22:48.666] Packages needed by the future expression (n = 1): ‘stats’
[10:22:48.666] Packages needed by future strategies (n = 0): <none>
[10:22:48.667] {
[10:22:48.667]     {
[10:22:48.667]         {
[10:22:48.667]             ...future.startTime <- base::Sys.time()
[10:22:48.667]             {
[10:22:48.667]                 {
[10:22:48.667]                   {
[10:22:48.667]                     {
[10:22:48.667]                       base::local({
[10:22:48.667]                         has_future <- base::requireNamespace("future", 
[10:22:48.667]                           quietly = TRUE)
[10:22:48.667]                         if (has_future) {
[10:22:48.667]                           ns <- base::getNamespace("future")
[10:22:48.667]                           version <- ns[[".package"]][["version"]]
[10:22:48.667]                           if (is.null(version)) 
[10:22:48.667]                             version <- utils::packageVersion("future")
[10:22:48.667]                         }
[10:22:48.667]                         else {
[10:22:48.667]                           version <- NULL
[10:22:48.667]                         }
[10:22:48.667]                         if (!has_future || version < "1.8.0") {
[10:22:48.667]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.667]                             "", base::R.version$version.string), 
[10:22:48.667]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.667]                               "release", "version")], collapse = " "), 
[10:22:48.667]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.667]                             info)
[10:22:48.667]                           info <- base::paste(info, collapse = "; ")
[10:22:48.667]                           if (!has_future) {
[10:22:48.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.667]                               info)
[10:22:48.667]                           }
[10:22:48.667]                           else {
[10:22:48.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.667]                               info, version)
[10:22:48.667]                           }
[10:22:48.667]                           base::stop(msg)
[10:22:48.667]                         }
[10:22:48.667]                       })
[10:22:48.667]                     }
[10:22:48.667]                     base::local({
[10:22:48.667]                       for (pkg in "stats") {
[10:22:48.667]                         base::loadNamespace(pkg)
[10:22:48.667]                         base::library(pkg, character.only = TRUE)
[10:22:48.667]                       }
[10:22:48.667]                     })
[10:22:48.667]                   }
[10:22:48.667]                   options(future.plan = NULL)
[10:22:48.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.667]                 }
[10:22:48.667]                 ...future.workdir <- getwd()
[10:22:48.667]             }
[10:22:48.667]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.667]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.667]         }
[10:22:48.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.667]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.667]             base::names(...future.oldOptions))
[10:22:48.667]     }
[10:22:48.667]     if (FALSE) {
[10:22:48.667]     }
[10:22:48.667]     else {
[10:22:48.667]         if (TRUE) {
[10:22:48.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.667]                 open = "w")
[10:22:48.667]         }
[10:22:48.667]         else {
[10:22:48.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.667]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.667]         }
[10:22:48.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.667]             base::sink(type = "output", split = FALSE)
[10:22:48.667]             base::close(...future.stdout)
[10:22:48.667]         }, add = TRUE)
[10:22:48.667]     }
[10:22:48.667]     ...future.frame <- base::sys.nframe()
[10:22:48.667]     ...future.conditions <- base::list()
[10:22:48.667]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.667]     if (FALSE) {
[10:22:48.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.667]     }
[10:22:48.667]     ...future.result <- base::tryCatch({
[10:22:48.667]         base::withCallingHandlers({
[10:22:48.667]             ...future.value <- base::withVisible(base::local({
[10:22:48.667]                 do.call(function(...) {
[10:22:48.667]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.667]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.667]                     ...future.globals.maxSize)) {
[10:22:48.667]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.667]                     on.exit(options(oopts), add = TRUE)
[10:22:48.667]                   }
[10:22:48.667]                   {
[10:22:48.667]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.667]                       FUN = function(jj) {
[10:22:48.667]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.667]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.667]                       })
[10:22:48.667]                   }
[10:22:48.667]                 }, args = future.call.arguments)
[10:22:48.667]             }))
[10:22:48.667]             future::FutureResult(value = ...future.value$value, 
[10:22:48.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.667]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.667]                     ...future.globalenv.names))
[10:22:48.667]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.667]         }, condition = base::local({
[10:22:48.667]             c <- base::c
[10:22:48.667]             inherits <- base::inherits
[10:22:48.667]             invokeRestart <- base::invokeRestart
[10:22:48.667]             length <- base::length
[10:22:48.667]             list <- base::list
[10:22:48.667]             seq.int <- base::seq.int
[10:22:48.667]             signalCondition <- base::signalCondition
[10:22:48.667]             sys.calls <- base::sys.calls
[10:22:48.667]             `[[` <- base::`[[`
[10:22:48.667]             `+` <- base::`+`
[10:22:48.667]             `<<-` <- base::`<<-`
[10:22:48.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.667]                   3L)]
[10:22:48.667]             }
[10:22:48.667]             function(cond) {
[10:22:48.667]                 is_error <- inherits(cond, "error")
[10:22:48.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.667]                   NULL)
[10:22:48.667]                 if (is_error) {
[10:22:48.667]                   sessionInformation <- function() {
[10:22:48.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.667]                       search = base::search(), system = base::Sys.info())
[10:22:48.667]                   }
[10:22:48.667]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.667]                     cond$call), session = sessionInformation(), 
[10:22:48.667]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.667]                   signalCondition(cond)
[10:22:48.667]                 }
[10:22:48.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.667]                 "immediateCondition"))) {
[10:22:48.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.667]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.667]                   if (TRUE && !signal) {
[10:22:48.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.667]                     {
[10:22:48.667]                       inherits <- base::inherits
[10:22:48.667]                       invokeRestart <- base::invokeRestart
[10:22:48.667]                       is.null <- base::is.null
[10:22:48.667]                       muffled <- FALSE
[10:22:48.667]                       if (inherits(cond, "message")) {
[10:22:48.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.667]                         if (muffled) 
[10:22:48.667]                           invokeRestart("muffleMessage")
[10:22:48.667]                       }
[10:22:48.667]                       else if (inherits(cond, "warning")) {
[10:22:48.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.667]                         if (muffled) 
[10:22:48.667]                           invokeRestart("muffleWarning")
[10:22:48.667]                       }
[10:22:48.667]                       else if (inherits(cond, "condition")) {
[10:22:48.667]                         if (!is.null(pattern)) {
[10:22:48.667]                           computeRestarts <- base::computeRestarts
[10:22:48.667]                           grepl <- base::grepl
[10:22:48.667]                           restarts <- computeRestarts(cond)
[10:22:48.667]                           for (restart in restarts) {
[10:22:48.667]                             name <- restart$name
[10:22:48.667]                             if (is.null(name)) 
[10:22:48.667]                               next
[10:22:48.667]                             if (!grepl(pattern, name)) 
[10:22:48.667]                               next
[10:22:48.667]                             invokeRestart(restart)
[10:22:48.667]                             muffled <- TRUE
[10:22:48.667]                             break
[10:22:48.667]                           }
[10:22:48.667]                         }
[10:22:48.667]                       }
[10:22:48.667]                       invisible(muffled)
[10:22:48.667]                     }
[10:22:48.667]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.667]                   }
[10:22:48.667]                 }
[10:22:48.667]                 else {
[10:22:48.667]                   if (TRUE) {
[10:22:48.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.667]                     {
[10:22:48.667]                       inherits <- base::inherits
[10:22:48.667]                       invokeRestart <- base::invokeRestart
[10:22:48.667]                       is.null <- base::is.null
[10:22:48.667]                       muffled <- FALSE
[10:22:48.667]                       if (inherits(cond, "message")) {
[10:22:48.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.667]                         if (muffled) 
[10:22:48.667]                           invokeRestart("muffleMessage")
[10:22:48.667]                       }
[10:22:48.667]                       else if (inherits(cond, "warning")) {
[10:22:48.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.667]                         if (muffled) 
[10:22:48.667]                           invokeRestart("muffleWarning")
[10:22:48.667]                       }
[10:22:48.667]                       else if (inherits(cond, "condition")) {
[10:22:48.667]                         if (!is.null(pattern)) {
[10:22:48.667]                           computeRestarts <- base::computeRestarts
[10:22:48.667]                           grepl <- base::grepl
[10:22:48.667]                           restarts <- computeRestarts(cond)
[10:22:48.667]                           for (restart in restarts) {
[10:22:48.667]                             name <- restart$name
[10:22:48.667]                             if (is.null(name)) 
[10:22:48.667]                               next
[10:22:48.667]                             if (!grepl(pattern, name)) 
[10:22:48.667]                               next
[10:22:48.667]                             invokeRestart(restart)
[10:22:48.667]                             muffled <- TRUE
[10:22:48.667]                             break
[10:22:48.667]                           }
[10:22:48.667]                         }
[10:22:48.667]                       }
[10:22:48.667]                       invisible(muffled)
[10:22:48.667]                     }
[10:22:48.667]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.667]                   }
[10:22:48.667]                 }
[10:22:48.667]             }
[10:22:48.667]         }))
[10:22:48.667]     }, error = function(ex) {
[10:22:48.667]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.667]                 ...future.rng), started = ...future.startTime, 
[10:22:48.667]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.667]             version = "1.8"), class = "FutureResult")
[10:22:48.667]     }, finally = {
[10:22:48.667]         if (!identical(...future.workdir, getwd())) 
[10:22:48.667]             setwd(...future.workdir)
[10:22:48.667]         {
[10:22:48.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.667]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.667]             }
[10:22:48.667]             base::options(...future.oldOptions)
[10:22:48.667]             if (.Platform$OS.type == "windows") {
[10:22:48.667]                 old_names <- names(...future.oldEnvVars)
[10:22:48.667]                 envs <- base::Sys.getenv()
[10:22:48.667]                 names <- names(envs)
[10:22:48.667]                 common <- intersect(names, old_names)
[10:22:48.667]                 added <- setdiff(names, old_names)
[10:22:48.667]                 removed <- setdiff(old_names, names)
[10:22:48.667]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.667]                   envs[common]]
[10:22:48.667]                 NAMES <- toupper(changed)
[10:22:48.667]                 args <- list()
[10:22:48.667]                 for (kk in seq_along(NAMES)) {
[10:22:48.667]                   name <- changed[[kk]]
[10:22:48.667]                   NAME <- NAMES[[kk]]
[10:22:48.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.667]                     next
[10:22:48.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.667]                 }
[10:22:48.667]                 NAMES <- toupper(added)
[10:22:48.667]                 for (kk in seq_along(NAMES)) {
[10:22:48.667]                   name <- added[[kk]]
[10:22:48.667]                   NAME <- NAMES[[kk]]
[10:22:48.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.667]                     next
[10:22:48.667]                   args[[name]] <- ""
[10:22:48.667]                 }
[10:22:48.667]                 NAMES <- toupper(removed)
[10:22:48.667]                 for (kk in seq_along(NAMES)) {
[10:22:48.667]                   name <- removed[[kk]]
[10:22:48.667]                   NAME <- NAMES[[kk]]
[10:22:48.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.667]                     next
[10:22:48.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.667]                 }
[10:22:48.667]                 if (length(args) > 0) 
[10:22:48.667]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.667]             }
[10:22:48.667]             else {
[10:22:48.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.667]             }
[10:22:48.667]             {
[10:22:48.667]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.667]                   0L) {
[10:22:48.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.667]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.667]                   base::options(opts)
[10:22:48.667]                 }
[10:22:48.667]                 {
[10:22:48.667]                   {
[10:22:48.667]                     NULL
[10:22:48.667]                     RNGkind("Mersenne-Twister")
[10:22:48.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.667]                       inherits = FALSE)
[10:22:48.667]                   }
[10:22:48.667]                   options(future.plan = NULL)
[10:22:48.667]                   if (is.na(NA_character_)) 
[10:22:48.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.667]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:48.667]                   {
[10:22:48.667]                     future <- SequentialFuture(..., envir = envir)
[10:22:48.667]                     if (!future$lazy) 
[10:22:48.667]                       future <- run(future)
[10:22:48.667]                     invisible(future)
[10:22:48.667]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.667]                 }
[10:22:48.667]             }
[10:22:48.667]         }
[10:22:48.667]     })
[10:22:48.667]     if (TRUE) {
[10:22:48.667]         base::sink(type = "output", split = FALSE)
[10:22:48.667]         if (TRUE) {
[10:22:48.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.667]         }
[10:22:48.667]         else {
[10:22:48.667]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.667]         }
[10:22:48.667]         base::close(...future.stdout)
[10:22:48.667]         ...future.stdout <- NULL
[10:22:48.667]     }
[10:22:48.667]     ...future.result$conditions <- ...future.conditions
[10:22:48.667]     ...future.result$finished <- base::Sys.time()
[10:22:48.667]     ...future.result
[10:22:48.667] }
[10:22:48.669] assign_globals() ...
[10:22:48.669] List of 5
[10:22:48.669]  $ ...future.FUN            :function (x, ...)  
[10:22:48.669]  $ future.call.arguments    :List of 1
[10:22:48.669]   ..$ singular.ok: logi FALSE
[10:22:48.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.669]  $ ...future.elements_ii    :List of 3
[10:22:48.669]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.669]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.669]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.669]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.669]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.669]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.669]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.669]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:48.669]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.669]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.669]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.669]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:48.669]  $ ...future.seeds_ii       : NULL
[10:22:48.669]  $ ...future.globals.maxSize: NULL
[10:22:48.669]  - attr(*, "where")=List of 5
[10:22:48.669]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.669]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.669]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.669]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.669]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.669]  - attr(*, "resolved")= logi FALSE
[10:22:48.669]  - attr(*, "total_size")= num 5384
[10:22:48.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.669]  - attr(*, "already-done")= logi TRUE
[10:22:48.678] - reassign environment for ‘...future.FUN’
[10:22:48.678] - copied ‘...future.FUN’ to environment
[10:22:48.678] - copied ‘future.call.arguments’ to environment
[10:22:48.678] - copied ‘...future.elements_ii’ to environment
[10:22:48.678] - copied ‘...future.seeds_ii’ to environment
[10:22:48.679] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.679] assign_globals() ... done
[10:22:48.679] plan(): Setting new future strategy stack:
[10:22:48.679] List of future strategies:
[10:22:48.679] 1. sequential:
[10:22:48.679]    - args: function (..., envir = parent.frame())
[10:22:48.679]    - tweaked: FALSE
[10:22:48.679]    - call: NULL
[10:22:48.679] plan(): nbrOfWorkers() = 1
[10:22:48.682] plan(): Setting new future strategy stack:
[10:22:48.682] List of future strategies:
[10:22:48.682] 1. sequential:
[10:22:48.682]    - args: function (..., envir = parent.frame())
[10:22:48.682]    - tweaked: FALSE
[10:22:48.682]    - call: plan(strategy)
[10:22:48.682] plan(): nbrOfWorkers() = 1
[10:22:48.683] SequentialFuture started (and completed)
[10:22:48.683] - Launch lazy future ... done
[10:22:48.683] run() for ‘SequentialFuture’ ... done
[10:22:48.683] Created future:
[10:22:48.683] SequentialFuture:
[10:22:48.683] Label: ‘future_by-1’
[10:22:48.683] Expression:
[10:22:48.683] {
[10:22:48.683]     do.call(function(...) {
[10:22:48.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.683]             on.exit(options(oopts), add = TRUE)
[10:22:48.683]         }
[10:22:48.683]         {
[10:22:48.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.683]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.683]             })
[10:22:48.683]         }
[10:22:48.683]     }, args = future.call.arguments)
[10:22:48.683] }
[10:22:48.683] Lazy evaluation: FALSE
[10:22:48.683] Asynchronous evaluation: FALSE
[10:22:48.683] Local evaluation: TRUE
[10:22:48.683] Environment: R_GlobalEnv
[10:22:48.683] Capture standard output: TRUE
[10:22:48.683] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.683] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.683] Packages: 1 packages (‘stats’)
[10:22:48.683] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.683] Resolved: TRUE
[10:22:48.683] Value: 26.06 KiB of class ‘list’
[10:22:48.683] Early signaling: FALSE
[10:22:48.683] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.683] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.684] Chunk #1 of 1 ... DONE
[10:22:48.684] Launching 1 futures (chunks) ... DONE
[10:22:48.684] Resolving 1 futures (chunks) ...
[10:22:48.685] resolve() on list ...
[10:22:48.685]  recursive: 0
[10:22:48.685]  length: 1
[10:22:48.685] 
[10:22:48.685] resolved() for ‘SequentialFuture’ ...
[10:22:48.685] - state: ‘finished’
[10:22:48.685] - run: TRUE
[10:22:48.685] - result: ‘FutureResult’
[10:22:48.685] resolved() for ‘SequentialFuture’ ... done
[10:22:48.685] Future #1
[10:22:48.686] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.686] - nx: 1
[10:22:48.686] - relay: TRUE
[10:22:48.686] - stdout: TRUE
[10:22:48.686] - signal: TRUE
[10:22:48.686] - resignal: FALSE
[10:22:48.686] - force: TRUE
[10:22:48.686] - relayed: [n=1] FALSE
[10:22:48.686] - queued futures: [n=1] FALSE
[10:22:48.686]  - until=1
[10:22:48.686]  - relaying element #1
[10:22:48.687] - relayed: [n=1] TRUE
[10:22:48.687] - queued futures: [n=1] TRUE
[10:22:48.687] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.687]  length: 0 (resolved future 1)
[10:22:48.687] Relaying remaining futures
[10:22:48.687] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.687] - nx: 1
[10:22:48.687] - relay: TRUE
[10:22:48.687] - stdout: TRUE
[10:22:48.687] - signal: TRUE
[10:22:48.687] - resignal: FALSE
[10:22:48.687] - force: TRUE
[10:22:48.687] - relayed: [n=1] TRUE
[10:22:48.688] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.688] - relayed: [n=1] TRUE
[10:22:48.688] - queued futures: [n=1] TRUE
[10:22:48.688] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.688] resolve() on list ... DONE
[10:22:48.688]  - Number of value chunks collected: 1
[10:22:48.688] Resolving 1 futures (chunks) ... DONE
[10:22:48.688] Reducing values from 1 chunks ...
[10:22:48.688]  - Number of values collected after concatenation: 3
[10:22:48.688]  - Number of values expected: 3
[10:22:48.688] Reducing values from 1 chunks ... DONE
[10:22:48.689] future_lapply() ... DONE
[10:22:48.689] future_by_internal() ... DONE
[10:22:48.694] future_by_internal() ...
[10:22:48.694] future_lapply() ...
[10:22:48.695] Number of chunks: 1
[10:22:48.695] getGlobalsAndPackagesXApply() ...
[10:22:48.695]  - future.globals: TRUE
[10:22:48.695] getGlobalsAndPackages() ...
[10:22:48.695] Searching for globals...
[10:22:48.697] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:48.697] Searching for globals ... DONE
[10:22:48.697] Resolving globals: FALSE
[10:22:48.697] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:22:48.698] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:22:48.698] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:48.698] - packages: [1] ‘stats’
[10:22:48.698] getGlobalsAndPackages() ... DONE
[10:22:48.698]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:48.698]  - needed namespaces: [n=1] ‘stats’
[10:22:48.698] Finding globals ... DONE
[10:22:48.698]  - use_args: TRUE
[10:22:48.698]  - Getting '...' globals ...
[10:22:48.699] resolve() on list ...
[10:22:48.699]  recursive: 0
[10:22:48.699]  length: 1
[10:22:48.699]  elements: ‘...’
[10:22:48.699]  length: 0 (resolved future 1)
[10:22:48.699] resolve() on list ... DONE
[10:22:48.699]    - '...' content: [n=0] 
[10:22:48.699] List of 1
[10:22:48.699]  $ ...: list()
[10:22:48.699]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.699]  - attr(*, "where")=List of 1
[10:22:48.699]   ..$ ...:<environment: 0x55f6387ce5a8> 
[10:22:48.699]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.699]  - attr(*, "resolved")= logi TRUE
[10:22:48.699]  - attr(*, "total_size")= num NA
[10:22:48.702]  - Getting '...' globals ... DONE
[10:22:48.702] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:22:48.702] List of 4
[10:22:48.702]  $ ...future.FUN:function (x)  
[10:22:48.702]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:48.702]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.702]  $ ...          : list()
[10:22:48.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.702]  - attr(*, "where")=List of 4
[10:22:48.702]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.702]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:22:48.702]   ..$ wool         :<environment: R_EmptyEnv> 
[10:22:48.702]   ..$ ...          :<environment: 0x55f6387ce5a8> 
[10:22:48.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.702]  - attr(*, "resolved")= logi FALSE
[10:22:48.702]  - attr(*, "total_size")= num 2320
[10:22:48.705] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:48.706] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.706] Number of futures (= number of chunks): 1
[10:22:48.707] Launching 1 futures (chunks) ...
[10:22:48.707] Chunk #1 of 1 ...
[10:22:48.707]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.707] getGlobalsAndPackages() ...
[10:22:48.707] Searching for globals...
[10:22:48.708] 
[10:22:48.708] Searching for globals ... DONE
[10:22:48.708] - globals: [0] <none>
[10:22:48.708] getGlobalsAndPackages() ... DONE
[10:22:48.708]    + additional globals found: [n=0] 
[10:22:48.708]    + additional namespaces needed: [n=0] 
[10:22:48.708]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.708]  - seeds: <none>
[10:22:48.708]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.708] getGlobalsAndPackages() ...
[10:22:48.708] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.709] Resolving globals: FALSE
[10:22:48.709] Tweak future expression to call with '...' arguments ...
[10:22:48.709] {
[10:22:48.709]     do.call(function(...) {
[10:22:48.709]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.709]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.709]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.709]             on.exit(options(oopts), add = TRUE)
[10:22:48.709]         }
[10:22:48.709]         {
[10:22:48.709]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.709]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.709]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.709]             })
[10:22:48.709]         }
[10:22:48.709]     }, args = future.call.arguments)
[10:22:48.709] }
[10:22:48.709] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.709] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.710] 
[10:22:48.710] getGlobalsAndPackages() ... DONE
[10:22:48.710] run() for ‘Future’ ...
[10:22:48.710] - state: ‘created’
[10:22:48.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:48.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.711]   - Field: ‘label’
[10:22:48.711]   - Field: ‘local’
[10:22:48.711]   - Field: ‘owner’
[10:22:48.711]   - Field: ‘envir’
[10:22:48.711]   - Field: ‘packages’
[10:22:48.711]   - Field: ‘gc’
[10:22:48.711]   - Field: ‘conditions’
[10:22:48.711]   - Field: ‘expr’
[10:22:48.711]   - Field: ‘uuid’
[10:22:48.711]   - Field: ‘seed’
[10:22:48.711]   - Field: ‘version’
[10:22:48.712]   - Field: ‘result’
[10:22:48.712]   - Field: ‘asynchronous’
[10:22:48.712]   - Field: ‘calls’
[10:22:48.712]   - Field: ‘globals’
[10:22:48.712]   - Field: ‘stdout’
[10:22:48.712]   - Field: ‘earlySignal’
[10:22:48.712]   - Field: ‘lazy’
[10:22:48.712]   - Field: ‘state’
[10:22:48.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.712] - Launch lazy future ...
[10:22:48.713] Packages needed by the future expression (n = 1): ‘stats’
[10:22:48.713] Packages needed by future strategies (n = 0): <none>
[10:22:48.713] {
[10:22:48.713]     {
[10:22:48.713]         {
[10:22:48.713]             ...future.startTime <- base::Sys.time()
[10:22:48.713]             {
[10:22:48.713]                 {
[10:22:48.713]                   {
[10:22:48.713]                     {
[10:22:48.713]                       base::local({
[10:22:48.713]                         has_future <- base::requireNamespace("future", 
[10:22:48.713]                           quietly = TRUE)
[10:22:48.713]                         if (has_future) {
[10:22:48.713]                           ns <- base::getNamespace("future")
[10:22:48.713]                           version <- ns[[".package"]][["version"]]
[10:22:48.713]                           if (is.null(version)) 
[10:22:48.713]                             version <- utils::packageVersion("future")
[10:22:48.713]                         }
[10:22:48.713]                         else {
[10:22:48.713]                           version <- NULL
[10:22:48.713]                         }
[10:22:48.713]                         if (!has_future || version < "1.8.0") {
[10:22:48.713]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.713]                             "", base::R.version$version.string), 
[10:22:48.713]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.713]                               "release", "version")], collapse = " "), 
[10:22:48.713]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.713]                             info)
[10:22:48.713]                           info <- base::paste(info, collapse = "; ")
[10:22:48.713]                           if (!has_future) {
[10:22:48.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.713]                               info)
[10:22:48.713]                           }
[10:22:48.713]                           else {
[10:22:48.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.713]                               info, version)
[10:22:48.713]                           }
[10:22:48.713]                           base::stop(msg)
[10:22:48.713]                         }
[10:22:48.713]                       })
[10:22:48.713]                     }
[10:22:48.713]                     base::local({
[10:22:48.713]                       for (pkg in "stats") {
[10:22:48.713]                         base::loadNamespace(pkg)
[10:22:48.713]                         base::library(pkg, character.only = TRUE)
[10:22:48.713]                       }
[10:22:48.713]                     })
[10:22:48.713]                   }
[10:22:48.713]                   options(future.plan = NULL)
[10:22:48.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.713]                 }
[10:22:48.713]                 ...future.workdir <- getwd()
[10:22:48.713]             }
[10:22:48.713]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.713]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.713]         }
[10:22:48.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.713]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.713]             base::names(...future.oldOptions))
[10:22:48.713]     }
[10:22:48.713]     if (FALSE) {
[10:22:48.713]     }
[10:22:48.713]     else {
[10:22:48.713]         if (TRUE) {
[10:22:48.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.713]                 open = "w")
[10:22:48.713]         }
[10:22:48.713]         else {
[10:22:48.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.713]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.713]         }
[10:22:48.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.713]             base::sink(type = "output", split = FALSE)
[10:22:48.713]             base::close(...future.stdout)
[10:22:48.713]         }, add = TRUE)
[10:22:48.713]     }
[10:22:48.713]     ...future.frame <- base::sys.nframe()
[10:22:48.713]     ...future.conditions <- base::list()
[10:22:48.713]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.713]     if (FALSE) {
[10:22:48.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.713]     }
[10:22:48.713]     ...future.result <- base::tryCatch({
[10:22:48.713]         base::withCallingHandlers({
[10:22:48.713]             ...future.value <- base::withVisible(base::local({
[10:22:48.713]                 do.call(function(...) {
[10:22:48.713]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.713]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.713]                     ...future.globals.maxSize)) {
[10:22:48.713]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.713]                     on.exit(options(oopts), add = TRUE)
[10:22:48.713]                   }
[10:22:48.713]                   {
[10:22:48.713]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.713]                       FUN = function(jj) {
[10:22:48.713]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.713]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.713]                       })
[10:22:48.713]                   }
[10:22:48.713]                 }, args = future.call.arguments)
[10:22:48.713]             }))
[10:22:48.713]             future::FutureResult(value = ...future.value$value, 
[10:22:48.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.713]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.713]                     ...future.globalenv.names))
[10:22:48.713]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.713]         }, condition = base::local({
[10:22:48.713]             c <- base::c
[10:22:48.713]             inherits <- base::inherits
[10:22:48.713]             invokeRestart <- base::invokeRestart
[10:22:48.713]             length <- base::length
[10:22:48.713]             list <- base::list
[10:22:48.713]             seq.int <- base::seq.int
[10:22:48.713]             signalCondition <- base::signalCondition
[10:22:48.713]             sys.calls <- base::sys.calls
[10:22:48.713]             `[[` <- base::`[[`
[10:22:48.713]             `+` <- base::`+`
[10:22:48.713]             `<<-` <- base::`<<-`
[10:22:48.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.713]                   3L)]
[10:22:48.713]             }
[10:22:48.713]             function(cond) {
[10:22:48.713]                 is_error <- inherits(cond, "error")
[10:22:48.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.713]                   NULL)
[10:22:48.713]                 if (is_error) {
[10:22:48.713]                   sessionInformation <- function() {
[10:22:48.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.713]                       search = base::search(), system = base::Sys.info())
[10:22:48.713]                   }
[10:22:48.713]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.713]                     cond$call), session = sessionInformation(), 
[10:22:48.713]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.713]                   signalCondition(cond)
[10:22:48.713]                 }
[10:22:48.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.713]                 "immediateCondition"))) {
[10:22:48.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.713]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.713]                   if (TRUE && !signal) {
[10:22:48.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.713]                     {
[10:22:48.713]                       inherits <- base::inherits
[10:22:48.713]                       invokeRestart <- base::invokeRestart
[10:22:48.713]                       is.null <- base::is.null
[10:22:48.713]                       muffled <- FALSE
[10:22:48.713]                       if (inherits(cond, "message")) {
[10:22:48.713]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.713]                         if (muffled) 
[10:22:48.713]                           invokeRestart("muffleMessage")
[10:22:48.713]                       }
[10:22:48.713]                       else if (inherits(cond, "warning")) {
[10:22:48.713]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.713]                         if (muffled) 
[10:22:48.713]                           invokeRestart("muffleWarning")
[10:22:48.713]                       }
[10:22:48.713]                       else if (inherits(cond, "condition")) {
[10:22:48.713]                         if (!is.null(pattern)) {
[10:22:48.713]                           computeRestarts <- base::computeRestarts
[10:22:48.713]                           grepl <- base::grepl
[10:22:48.713]                           restarts <- computeRestarts(cond)
[10:22:48.713]                           for (restart in restarts) {
[10:22:48.713]                             name <- restart$name
[10:22:48.713]                             if (is.null(name)) 
[10:22:48.713]                               next
[10:22:48.713]                             if (!grepl(pattern, name)) 
[10:22:48.713]                               next
[10:22:48.713]                             invokeRestart(restart)
[10:22:48.713]                             muffled <- TRUE
[10:22:48.713]                             break
[10:22:48.713]                           }
[10:22:48.713]                         }
[10:22:48.713]                       }
[10:22:48.713]                       invisible(muffled)
[10:22:48.713]                     }
[10:22:48.713]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.713]                   }
[10:22:48.713]                 }
[10:22:48.713]                 else {
[10:22:48.713]                   if (TRUE) {
[10:22:48.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.713]                     {
[10:22:48.713]                       inherits <- base::inherits
[10:22:48.713]                       invokeRestart <- base::invokeRestart
[10:22:48.713]                       is.null <- base::is.null
[10:22:48.713]                       muffled <- FALSE
[10:22:48.713]                       if (inherits(cond, "message")) {
[10:22:48.713]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.713]                         if (muffled) 
[10:22:48.713]                           invokeRestart("muffleMessage")
[10:22:48.713]                       }
[10:22:48.713]                       else if (inherits(cond, "warning")) {
[10:22:48.713]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.713]                         if (muffled) 
[10:22:48.713]                           invokeRestart("muffleWarning")
[10:22:48.713]                       }
[10:22:48.713]                       else if (inherits(cond, "condition")) {
[10:22:48.713]                         if (!is.null(pattern)) {
[10:22:48.713]                           computeRestarts <- base::computeRestarts
[10:22:48.713]                           grepl <- base::grepl
[10:22:48.713]                           restarts <- computeRestarts(cond)
[10:22:48.713]                           for (restart in restarts) {
[10:22:48.713]                             name <- restart$name
[10:22:48.713]                             if (is.null(name)) 
[10:22:48.713]                               next
[10:22:48.713]                             if (!grepl(pattern, name)) 
[10:22:48.713]                               next
[10:22:48.713]                             invokeRestart(restart)
[10:22:48.713]                             muffled <- TRUE
[10:22:48.713]                             break
[10:22:48.713]                           }
[10:22:48.713]                         }
[10:22:48.713]                       }
[10:22:48.713]                       invisible(muffled)
[10:22:48.713]                     }
[10:22:48.713]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.713]                   }
[10:22:48.713]                 }
[10:22:48.713]             }
[10:22:48.713]         }))
[10:22:48.713]     }, error = function(ex) {
[10:22:48.713]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.713]                 ...future.rng), started = ...future.startTime, 
[10:22:48.713]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.713]             version = "1.8"), class = "FutureResult")
[10:22:48.713]     }, finally = {
[10:22:48.713]         if (!identical(...future.workdir, getwd())) 
[10:22:48.713]             setwd(...future.workdir)
[10:22:48.713]         {
[10:22:48.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.713]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.713]             }
[10:22:48.713]             base::options(...future.oldOptions)
[10:22:48.713]             if (.Platform$OS.type == "windows") {
[10:22:48.713]                 old_names <- names(...future.oldEnvVars)
[10:22:48.713]                 envs <- base::Sys.getenv()
[10:22:48.713]                 names <- names(envs)
[10:22:48.713]                 common <- intersect(names, old_names)
[10:22:48.713]                 added <- setdiff(names, old_names)
[10:22:48.713]                 removed <- setdiff(old_names, names)
[10:22:48.713]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.713]                   envs[common]]
[10:22:48.713]                 NAMES <- toupper(changed)
[10:22:48.713]                 args <- list()
[10:22:48.713]                 for (kk in seq_along(NAMES)) {
[10:22:48.713]                   name <- changed[[kk]]
[10:22:48.713]                   NAME <- NAMES[[kk]]
[10:22:48.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.713]                     next
[10:22:48.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.713]                 }
[10:22:48.713]                 NAMES <- toupper(added)
[10:22:48.713]                 for (kk in seq_along(NAMES)) {
[10:22:48.713]                   name <- added[[kk]]
[10:22:48.713]                   NAME <- NAMES[[kk]]
[10:22:48.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.713]                     next
[10:22:48.713]                   args[[name]] <- ""
[10:22:48.713]                 }
[10:22:48.713]                 NAMES <- toupper(removed)
[10:22:48.713]                 for (kk in seq_along(NAMES)) {
[10:22:48.713]                   name <- removed[[kk]]
[10:22:48.713]                   NAME <- NAMES[[kk]]
[10:22:48.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.713]                     next
[10:22:48.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.713]                 }
[10:22:48.713]                 if (length(args) > 0) 
[10:22:48.713]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.713]             }
[10:22:48.713]             else {
[10:22:48.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.713]             }
[10:22:48.713]             {
[10:22:48.713]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.713]                   0L) {
[10:22:48.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.713]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.713]                   base::options(opts)
[10:22:48.713]                 }
[10:22:48.713]                 {
[10:22:48.713]                   {
[10:22:48.713]                     NULL
[10:22:48.713]                     RNGkind("Mersenne-Twister")
[10:22:48.713]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.713]                       inherits = FALSE)
[10:22:48.713]                   }
[10:22:48.713]                   options(future.plan = NULL)
[10:22:48.713]                   if (is.na(NA_character_)) 
[10:22:48.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.713]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:48.713]                   {
[10:22:48.713]                     future <- SequentialFuture(..., envir = envir)
[10:22:48.713]                     if (!future$lazy) 
[10:22:48.713]                       future <- run(future)
[10:22:48.713]                     invisible(future)
[10:22:48.713]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.713]                 }
[10:22:48.713]             }
[10:22:48.713]         }
[10:22:48.713]     })
[10:22:48.713]     if (TRUE) {
[10:22:48.713]         base::sink(type = "output", split = FALSE)
[10:22:48.713]         if (TRUE) {
[10:22:48.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.713]         }
[10:22:48.713]         else {
[10:22:48.713]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.713]         }
[10:22:48.713]         base::close(...future.stdout)
[10:22:48.713]         ...future.stdout <- NULL
[10:22:48.713]     }
[10:22:48.713]     ...future.result$conditions <- ...future.conditions
[10:22:48.713]     ...future.result$finished <- base::Sys.time()
[10:22:48.713]     ...future.result
[10:22:48.713] }
[10:22:48.715] assign_globals() ...
[10:22:48.715] List of 7
[10:22:48.715]  $ ...future.FUN            :function (x)  
[10:22:48.715]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:48.715]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.715]  $ future.call.arguments    : list()
[10:22:48.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.715]  $ ...future.elements_ii    :List of 3
[10:22:48.715]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.715]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.715]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.715]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.715]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.715]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.715]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.715]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:48.715]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.715]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.715]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.715]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:48.715]  $ ...future.seeds_ii       : NULL
[10:22:48.715]  $ ...future.globals.maxSize: NULL
[10:22:48.715]  - attr(*, "where")=List of 7
[10:22:48.715]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.715]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:22:48.715]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:22:48.715]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.715]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.715]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.715]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.715]  - attr(*, "resolved")= logi FALSE
[10:22:48.715]  - attr(*, "total_size")= num 2320
[10:22:48.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.715]  - attr(*, "already-done")= logi TRUE
[10:22:48.724] - reassign environment for ‘...future.FUN’
[10:22:48.724] - copied ‘...future.FUN’ to environment
[10:22:48.724] - copied ‘breaks’ to environment
[10:22:48.725] - copied ‘wool’ to environment
[10:22:48.725] - copied ‘future.call.arguments’ to environment
[10:22:48.725] - copied ‘...future.elements_ii’ to environment
[10:22:48.725] - copied ‘...future.seeds_ii’ to environment
[10:22:48.725] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.725] assign_globals() ... done
[10:22:48.725] plan(): Setting new future strategy stack:
[10:22:48.725] List of future strategies:
[10:22:48.725] 1. sequential:
[10:22:48.725]    - args: function (..., envir = parent.frame())
[10:22:48.725]    - tweaked: FALSE
[10:22:48.725]    - call: NULL
[10:22:48.726] plan(): nbrOfWorkers() = 1
[10:22:48.730] plan(): Setting new future strategy stack:
[10:22:48.730] List of future strategies:
[10:22:48.730] 1. sequential:
[10:22:48.730]    - args: function (..., envir = parent.frame())
[10:22:48.730]    - tweaked: FALSE
[10:22:48.730]    - call: plan(strategy)
[10:22:48.730] plan(): nbrOfWorkers() = 1
[10:22:48.730] SequentialFuture started (and completed)
[10:22:48.730] - Launch lazy future ... done
[10:22:48.730] run() for ‘SequentialFuture’ ... done
[10:22:48.730] Created future:
[10:22:48.731] SequentialFuture:
[10:22:48.731] Label: ‘future_by-1’
[10:22:48.731] Expression:
[10:22:48.731] {
[10:22:48.731]     do.call(function(...) {
[10:22:48.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.731]             on.exit(options(oopts), add = TRUE)
[10:22:48.731]         }
[10:22:48.731]         {
[10:22:48.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.731]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.731]             })
[10:22:48.731]         }
[10:22:48.731]     }, args = future.call.arguments)
[10:22:48.731] }
[10:22:48.731] Lazy evaluation: FALSE
[10:22:48.731] Asynchronous evaluation: FALSE
[10:22:48.731] Local evaluation: TRUE
[10:22:48.731] Environment: 0x55f6378662d8
[10:22:48.731] Capture standard output: TRUE
[10:22:48.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.731] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:22:48.731] Packages: 1 packages (‘stats’)
[10:22:48.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.731] Resolved: TRUE
[10:22:48.731] Value: 25.57 KiB of class ‘list’
[10:22:48.731] Early signaling: FALSE
[10:22:48.731] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.731] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.732] Chunk #1 of 1 ... DONE
[10:22:48.732] Launching 1 futures (chunks) ... DONE
[10:22:48.732] Resolving 1 futures (chunks) ...
[10:22:48.732] resolve() on list ...
[10:22:48.732]  recursive: 0
[10:22:48.733]  length: 1
[10:22:48.733] 
[10:22:48.733] resolved() for ‘SequentialFuture’ ...
[10:22:48.733] - state: ‘finished’
[10:22:48.733] - run: TRUE
[10:22:48.733] - result: ‘FutureResult’
[10:22:48.733] resolved() for ‘SequentialFuture’ ... done
[10:22:48.733] Future #1
[10:22:48.733] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.733] - nx: 1
[10:22:48.733] - relay: TRUE
[10:22:48.734] - stdout: TRUE
[10:22:48.734] - signal: TRUE
[10:22:48.734] - resignal: FALSE
[10:22:48.734] - force: TRUE
[10:22:48.734] - relayed: [n=1] FALSE
[10:22:48.734] - queued futures: [n=1] FALSE
[10:22:48.734]  - until=1
[10:22:48.734]  - relaying element #1
[10:22:48.734] - relayed: [n=1] TRUE
[10:22:48.734] - queued futures: [n=1] TRUE
[10:22:48.734] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.735]  length: 0 (resolved future 1)
[10:22:48.735] Relaying remaining futures
[10:22:48.735] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.735] - nx: 1
[10:22:48.735] - relay: TRUE
[10:22:48.735] - stdout: TRUE
[10:22:48.735] - signal: TRUE
[10:22:48.735] - resignal: FALSE
[10:22:48.735] - force: TRUE
[10:22:48.735] - relayed: [n=1] TRUE
[10:22:48.735] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.736] - relayed: [n=1] TRUE
[10:22:48.736] - queued futures: [n=1] TRUE
[10:22:48.736] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.736] resolve() on list ... DONE
[10:22:48.736]  - Number of value chunks collected: 1
[10:22:48.736] Resolving 1 futures (chunks) ... DONE
[10:22:48.736] Reducing values from 1 chunks ...
[10:22:48.736]  - Number of values collected after concatenation: 3
[10:22:48.736]  - Number of values expected: 3
[10:22:48.736] Reducing values from 1 chunks ... DONE
[10:22:48.736] future_lapply() ... DONE
[10:22:48.736] future_by_internal() ... DONE
[10:22:48.737] future_by_internal() ...
[10:22:48.737] future_lapply() ...
[10:22:48.738] Number of chunks: 1
[10:22:48.738] getGlobalsAndPackagesXApply() ...
[10:22:48.738]  - future.globals: TRUE
[10:22:48.738] getGlobalsAndPackages() ...
[10:22:48.738] Searching for globals...
[10:22:48.739] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:48.739] Searching for globals ... DONE
[10:22:48.739] Resolving globals: FALSE
[10:22:48.740] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:48.740] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:48.740] - globals: [1] ‘FUN’
[10:22:48.740] 
[10:22:48.740] getGlobalsAndPackages() ... DONE
[10:22:48.740]  - globals found/used: [n=1] ‘FUN’
[10:22:48.740]  - needed namespaces: [n=0] 
[10:22:48.740] Finding globals ... DONE
[10:22:48.740]  - use_args: TRUE
[10:22:48.741]  - Getting '...' globals ...
[10:22:48.741] resolve() on list ...
[10:22:48.741]  recursive: 0
[10:22:48.741]  length: 1
[10:22:48.741]  elements: ‘...’
[10:22:48.741]  length: 0 (resolved future 1)
[10:22:48.741] resolve() on list ... DONE
[10:22:48.741]    - '...' content: [n=0] 
[10:22:48.741] List of 1
[10:22:48.741]  $ ...: list()
[10:22:48.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.741]  - attr(*, "where")=List of 1
[10:22:48.741]   ..$ ...:<environment: 0x55f639bc6f20> 
[10:22:48.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.741]  - attr(*, "resolved")= logi TRUE
[10:22:48.741]  - attr(*, "total_size")= num NA
[10:22:48.744]  - Getting '...' globals ... DONE
[10:22:48.744] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.744] List of 2
[10:22:48.744]  $ ...future.FUN:function (object, ...)  
[10:22:48.744]  $ ...          : list()
[10:22:48.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.744]  - attr(*, "where")=List of 2
[10:22:48.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.744]   ..$ ...          :<environment: 0x55f639bc6f20> 
[10:22:48.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.744]  - attr(*, "resolved")= logi FALSE
[10:22:48.744]  - attr(*, "total_size")= num 1240
[10:22:48.748] Packages to be attached in all futures: [n=0] 
[10:22:48.748] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.748] Number of futures (= number of chunks): 1
[10:22:48.748] Launching 1 futures (chunks) ...
[10:22:48.748] Chunk #1 of 1 ...
[10:22:48.748]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.748] getGlobalsAndPackages() ...
[10:22:48.749] Searching for globals...
[10:22:48.749] 
[10:22:48.749] Searching for globals ... DONE
[10:22:48.749] - globals: [0] <none>
[10:22:48.749] getGlobalsAndPackages() ... DONE
[10:22:48.749]    + additional globals found: [n=0] 
[10:22:48.749]    + additional namespaces needed: [n=0] 
[10:22:48.750]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.750]  - seeds: <none>
[10:22:48.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.750] getGlobalsAndPackages() ...
[10:22:48.750] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.750] Resolving globals: FALSE
[10:22:48.750] Tweak future expression to call with '...' arguments ...
[10:22:48.750] {
[10:22:48.750]     do.call(function(...) {
[10:22:48.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.750]             on.exit(options(oopts), add = TRUE)
[10:22:48.750]         }
[10:22:48.750]         {
[10:22:48.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.750]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.750]             })
[10:22:48.750]         }
[10:22:48.750]     }, args = future.call.arguments)
[10:22:48.750] }
[10:22:48.750] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.751] 
[10:22:48.751] getGlobalsAndPackages() ... DONE
[10:22:48.751] run() for ‘Future’ ...
[10:22:48.751] - state: ‘created’
[10:22:48.751] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:48.752] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.752]   - Field: ‘label’
[10:22:48.752]   - Field: ‘local’
[10:22:48.752]   - Field: ‘owner’
[10:22:48.752]   - Field: ‘envir’
[10:22:48.752]   - Field: ‘packages’
[10:22:48.752]   - Field: ‘gc’
[10:22:48.752]   - Field: ‘conditions’
[10:22:48.753]   - Field: ‘expr’
[10:22:48.753]   - Field: ‘uuid’
[10:22:48.753]   - Field: ‘seed’
[10:22:48.753]   - Field: ‘version’
[10:22:48.753]   - Field: ‘result’
[10:22:48.753]   - Field: ‘asynchronous’
[10:22:48.753]   - Field: ‘calls’
[10:22:48.753]   - Field: ‘globals’
[10:22:48.753]   - Field: ‘stdout’
[10:22:48.753]   - Field: ‘earlySignal’
[10:22:48.753]   - Field: ‘lazy’
[10:22:48.754]   - Field: ‘state’
[10:22:48.754] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.754] - Launch lazy future ...
[10:22:48.754] Packages needed by the future expression (n = 0): <none>
[10:22:48.754] Packages needed by future strategies (n = 0): <none>
[10:22:48.754] {
[10:22:48.754]     {
[10:22:48.754]         {
[10:22:48.754]             ...future.startTime <- base::Sys.time()
[10:22:48.754]             {
[10:22:48.754]                 {
[10:22:48.754]                   {
[10:22:48.754]                     base::local({
[10:22:48.754]                       has_future <- base::requireNamespace("future", 
[10:22:48.754]                         quietly = TRUE)
[10:22:48.754]                       if (has_future) {
[10:22:48.754]                         ns <- base::getNamespace("future")
[10:22:48.754]                         version <- ns[[".package"]][["version"]]
[10:22:48.754]                         if (is.null(version)) 
[10:22:48.754]                           version <- utils::packageVersion("future")
[10:22:48.754]                       }
[10:22:48.754]                       else {
[10:22:48.754]                         version <- NULL
[10:22:48.754]                       }
[10:22:48.754]                       if (!has_future || version < "1.8.0") {
[10:22:48.754]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.754]                           "", base::R.version$version.string), 
[10:22:48.754]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:48.754]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.754]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.754]                             "release", "version")], collapse = " "), 
[10:22:48.754]                           hostname = base::Sys.info()[["nodename"]])
[10:22:48.754]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.754]                           info)
[10:22:48.754]                         info <- base::paste(info, collapse = "; ")
[10:22:48.754]                         if (!has_future) {
[10:22:48.754]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.754]                             info)
[10:22:48.754]                         }
[10:22:48.754]                         else {
[10:22:48.754]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.754]                             info, version)
[10:22:48.754]                         }
[10:22:48.754]                         base::stop(msg)
[10:22:48.754]                       }
[10:22:48.754]                     })
[10:22:48.754]                   }
[10:22:48.754]                   options(future.plan = NULL)
[10:22:48.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.754]                 }
[10:22:48.754]                 ...future.workdir <- getwd()
[10:22:48.754]             }
[10:22:48.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.754]         }
[10:22:48.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.754]             base::names(...future.oldOptions))
[10:22:48.754]     }
[10:22:48.754]     if (FALSE) {
[10:22:48.754]     }
[10:22:48.754]     else {
[10:22:48.754]         if (TRUE) {
[10:22:48.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.754]                 open = "w")
[10:22:48.754]         }
[10:22:48.754]         else {
[10:22:48.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.754]         }
[10:22:48.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.754]             base::sink(type = "output", split = FALSE)
[10:22:48.754]             base::close(...future.stdout)
[10:22:48.754]         }, add = TRUE)
[10:22:48.754]     }
[10:22:48.754]     ...future.frame <- base::sys.nframe()
[10:22:48.754]     ...future.conditions <- base::list()
[10:22:48.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.754]     if (FALSE) {
[10:22:48.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.754]     }
[10:22:48.754]     ...future.result <- base::tryCatch({
[10:22:48.754]         base::withCallingHandlers({
[10:22:48.754]             ...future.value <- base::withVisible(base::local({
[10:22:48.754]                 do.call(function(...) {
[10:22:48.754]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.754]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.754]                     ...future.globals.maxSize)) {
[10:22:48.754]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.754]                     on.exit(options(oopts), add = TRUE)
[10:22:48.754]                   }
[10:22:48.754]                   {
[10:22:48.754]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.754]                       FUN = function(jj) {
[10:22:48.754]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.754]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.754]                       })
[10:22:48.754]                   }
[10:22:48.754]                 }, args = future.call.arguments)
[10:22:48.754]             }))
[10:22:48.754]             future::FutureResult(value = ...future.value$value, 
[10:22:48.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.754]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.754]                     ...future.globalenv.names))
[10:22:48.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.754]         }, condition = base::local({
[10:22:48.754]             c <- base::c
[10:22:48.754]             inherits <- base::inherits
[10:22:48.754]             invokeRestart <- base::invokeRestart
[10:22:48.754]             length <- base::length
[10:22:48.754]             list <- base::list
[10:22:48.754]             seq.int <- base::seq.int
[10:22:48.754]             signalCondition <- base::signalCondition
[10:22:48.754]             sys.calls <- base::sys.calls
[10:22:48.754]             `[[` <- base::`[[`
[10:22:48.754]             `+` <- base::`+`
[10:22:48.754]             `<<-` <- base::`<<-`
[10:22:48.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.754]                   3L)]
[10:22:48.754]             }
[10:22:48.754]             function(cond) {
[10:22:48.754]                 is_error <- inherits(cond, "error")
[10:22:48.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.754]                   NULL)
[10:22:48.754]                 if (is_error) {
[10:22:48.754]                   sessionInformation <- function() {
[10:22:48.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.754]                       search = base::search(), system = base::Sys.info())
[10:22:48.754]                   }
[10:22:48.754]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.754]                     cond$call), session = sessionInformation(), 
[10:22:48.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.754]                   signalCondition(cond)
[10:22:48.754]                 }
[10:22:48.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.754]                 "immediateCondition"))) {
[10:22:48.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.754]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.754]                   if (TRUE && !signal) {
[10:22:48.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.754]                     {
[10:22:48.754]                       inherits <- base::inherits
[10:22:48.754]                       invokeRestart <- base::invokeRestart
[10:22:48.754]                       is.null <- base::is.null
[10:22:48.754]                       muffled <- FALSE
[10:22:48.754]                       if (inherits(cond, "message")) {
[10:22:48.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.754]                         if (muffled) 
[10:22:48.754]                           invokeRestart("muffleMessage")
[10:22:48.754]                       }
[10:22:48.754]                       else if (inherits(cond, "warning")) {
[10:22:48.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.754]                         if (muffled) 
[10:22:48.754]                           invokeRestart("muffleWarning")
[10:22:48.754]                       }
[10:22:48.754]                       else if (inherits(cond, "condition")) {
[10:22:48.754]                         if (!is.null(pattern)) {
[10:22:48.754]                           computeRestarts <- base::computeRestarts
[10:22:48.754]                           grepl <- base::grepl
[10:22:48.754]                           restarts <- computeRestarts(cond)
[10:22:48.754]                           for (restart in restarts) {
[10:22:48.754]                             name <- restart$name
[10:22:48.754]                             if (is.null(name)) 
[10:22:48.754]                               next
[10:22:48.754]                             if (!grepl(pattern, name)) 
[10:22:48.754]                               next
[10:22:48.754]                             invokeRestart(restart)
[10:22:48.754]                             muffled <- TRUE
[10:22:48.754]                             break
[10:22:48.754]                           }
[10:22:48.754]                         }
[10:22:48.754]                       }
[10:22:48.754]                       invisible(muffled)
[10:22:48.754]                     }
[10:22:48.754]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.754]                   }
[10:22:48.754]                 }
[10:22:48.754]                 else {
[10:22:48.754]                   if (TRUE) {
[10:22:48.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.754]                     {
[10:22:48.754]                       inherits <- base::inherits
[10:22:48.754]                       invokeRestart <- base::invokeRestart
[10:22:48.754]                       is.null <- base::is.null
[10:22:48.754]                       muffled <- FALSE
[10:22:48.754]                       if (inherits(cond, "message")) {
[10:22:48.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.754]                         if (muffled) 
[10:22:48.754]                           invokeRestart("muffleMessage")
[10:22:48.754]                       }
[10:22:48.754]                       else if (inherits(cond, "warning")) {
[10:22:48.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.754]                         if (muffled) 
[10:22:48.754]                           invokeRestart("muffleWarning")
[10:22:48.754]                       }
[10:22:48.754]                       else if (inherits(cond, "condition")) {
[10:22:48.754]                         if (!is.null(pattern)) {
[10:22:48.754]                           computeRestarts <- base::computeRestarts
[10:22:48.754]                           grepl <- base::grepl
[10:22:48.754]                           restarts <- computeRestarts(cond)
[10:22:48.754]                           for (restart in restarts) {
[10:22:48.754]                             name <- restart$name
[10:22:48.754]                             if (is.null(name)) 
[10:22:48.754]                               next
[10:22:48.754]                             if (!grepl(pattern, name)) 
[10:22:48.754]                               next
[10:22:48.754]                             invokeRestart(restart)
[10:22:48.754]                             muffled <- TRUE
[10:22:48.754]                             break
[10:22:48.754]                           }
[10:22:48.754]                         }
[10:22:48.754]                       }
[10:22:48.754]                       invisible(muffled)
[10:22:48.754]                     }
[10:22:48.754]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.754]                   }
[10:22:48.754]                 }
[10:22:48.754]             }
[10:22:48.754]         }))
[10:22:48.754]     }, error = function(ex) {
[10:22:48.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.754]                 ...future.rng), started = ...future.startTime, 
[10:22:48.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.754]             version = "1.8"), class = "FutureResult")
[10:22:48.754]     }, finally = {
[10:22:48.754]         if (!identical(...future.workdir, getwd())) 
[10:22:48.754]             setwd(...future.workdir)
[10:22:48.754]         {
[10:22:48.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.754]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.754]             }
[10:22:48.754]             base::options(...future.oldOptions)
[10:22:48.754]             if (.Platform$OS.type == "windows") {
[10:22:48.754]                 old_names <- names(...future.oldEnvVars)
[10:22:48.754]                 envs <- base::Sys.getenv()
[10:22:48.754]                 names <- names(envs)
[10:22:48.754]                 common <- intersect(names, old_names)
[10:22:48.754]                 added <- setdiff(names, old_names)
[10:22:48.754]                 removed <- setdiff(old_names, names)
[10:22:48.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.754]                   envs[common]]
[10:22:48.754]                 NAMES <- toupper(changed)
[10:22:48.754]                 args <- list()
[10:22:48.754]                 for (kk in seq_along(NAMES)) {
[10:22:48.754]                   name <- changed[[kk]]
[10:22:48.754]                   NAME <- NAMES[[kk]]
[10:22:48.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.754]                     next
[10:22:48.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.754]                 }
[10:22:48.754]                 NAMES <- toupper(added)
[10:22:48.754]                 for (kk in seq_along(NAMES)) {
[10:22:48.754]                   name <- added[[kk]]
[10:22:48.754]                   NAME <- NAMES[[kk]]
[10:22:48.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.754]                     next
[10:22:48.754]                   args[[name]] <- ""
[10:22:48.754]                 }
[10:22:48.754]                 NAMES <- toupper(removed)
[10:22:48.754]                 for (kk in seq_along(NAMES)) {
[10:22:48.754]                   name <- removed[[kk]]
[10:22:48.754]                   NAME <- NAMES[[kk]]
[10:22:48.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.754]                     next
[10:22:48.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.754]                 }
[10:22:48.754]                 if (length(args) > 0) 
[10:22:48.754]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.754]             }
[10:22:48.754]             else {
[10:22:48.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.754]             }
[10:22:48.754]             {
[10:22:48.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.754]                   0L) {
[10:22:48.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.754]                   base::options(opts)
[10:22:48.754]                 }
[10:22:48.754]                 {
[10:22:48.754]                   {
[10:22:48.754]                     NULL
[10:22:48.754]                     RNGkind("Mersenne-Twister")
[10:22:48.754]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.754]                       inherits = FALSE)
[10:22:48.754]                   }
[10:22:48.754]                   options(future.plan = NULL)
[10:22:48.754]                   if (is.na(NA_character_)) 
[10:22:48.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.754]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:48.754]                   {
[10:22:48.754]                     future <- SequentialFuture(..., envir = envir)
[10:22:48.754]                     if (!future$lazy) 
[10:22:48.754]                       future <- run(future)
[10:22:48.754]                     invisible(future)
[10:22:48.754]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.754]                 }
[10:22:48.754]             }
[10:22:48.754]         }
[10:22:48.754]     })
[10:22:48.754]     if (TRUE) {
[10:22:48.754]         base::sink(type = "output", split = FALSE)
[10:22:48.754]         if (TRUE) {
[10:22:48.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.754]         }
[10:22:48.754]         else {
[10:22:48.754]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.754]         }
[10:22:48.754]         base::close(...future.stdout)
[10:22:48.754]         ...future.stdout <- NULL
[10:22:48.754]     }
[10:22:48.754]     ...future.result$conditions <- ...future.conditions
[10:22:48.754]     ...future.result$finished <- base::Sys.time()
[10:22:48.754]     ...future.result
[10:22:48.754] }
[10:22:48.756] assign_globals() ...
[10:22:48.756] List of 5
[10:22:48.756]  $ ...future.FUN            :function (object, ...)  
[10:22:48.756]  $ future.call.arguments    : list()
[10:22:48.756]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.756]  $ ...future.elements_ii    :List of 3
[10:22:48.756]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.756]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.756]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.756]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.756]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.756]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.756]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.756]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:48.756]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.756]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.756]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.756]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:48.756]  $ ...future.seeds_ii       : NULL
[10:22:48.756]  $ ...future.globals.maxSize: NULL
[10:22:48.756]  - attr(*, "where")=List of 5
[10:22:48.756]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.756]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.756]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.756]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.756]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.756]  - attr(*, "resolved")= logi FALSE
[10:22:48.756]  - attr(*, "total_size")= num 1240
[10:22:48.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.756]  - attr(*, "already-done")= logi TRUE
[10:22:48.764] - copied ‘...future.FUN’ to environment
[10:22:48.764] - copied ‘future.call.arguments’ to environment
[10:22:48.764] - copied ‘...future.elements_ii’ to environment
[10:22:48.764] - copied ‘...future.seeds_ii’ to environment
[10:22:48.764] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.765] assign_globals() ... done
[10:22:48.765] plan(): Setting new future strategy stack:
[10:22:48.765] List of future strategies:
[10:22:48.765] 1. sequential:
[10:22:48.765]    - args: function (..., envir = parent.frame())
[10:22:48.765]    - tweaked: FALSE
[10:22:48.765]    - call: NULL
[10:22:48.766] plan(): nbrOfWorkers() = 1
[10:22:48.768] plan(): Setting new future strategy stack:
[10:22:48.768] List of future strategies:
[10:22:48.768] 1. sequential:
[10:22:48.768]    - args: function (..., envir = parent.frame())
[10:22:48.768]    - tweaked: FALSE
[10:22:48.768]    - call: plan(strategy)
[10:22:48.769] plan(): nbrOfWorkers() = 1
[10:22:48.769] SequentialFuture started (and completed)
[10:22:48.769] - Launch lazy future ... done
[10:22:48.769] run() for ‘SequentialFuture’ ... done
[10:22:48.769] Created future:
[10:22:48.769] SequentialFuture:
[10:22:48.769] Label: ‘future_by-1’
[10:22:48.769] Expression:
[10:22:48.769] {
[10:22:48.769]     do.call(function(...) {
[10:22:48.769]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.769]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.769]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.769]             on.exit(options(oopts), add = TRUE)
[10:22:48.769]         }
[10:22:48.769]         {
[10:22:48.769]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.769]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.769]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.769]             })
[10:22:48.769]         }
[10:22:48.769]     }, args = future.call.arguments)
[10:22:48.769] }
[10:22:48.769] Lazy evaluation: FALSE
[10:22:48.769] Asynchronous evaluation: FALSE
[10:22:48.769] Local evaluation: TRUE
[10:22:48.769] Environment: 0x55f639b7e710
[10:22:48.769] Capture standard output: TRUE
[10:22:48.769] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.769] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.769] Packages: <none>
[10:22:48.769] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.769] Resolved: TRUE
[10:22:48.769] Value: 5.37 KiB of class ‘list’
[10:22:48.769] Early signaling: FALSE
[10:22:48.769] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.769] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.770] Chunk #1 of 1 ... DONE
[10:22:48.771] Launching 1 futures (chunks) ... DONE
[10:22:48.771] Resolving 1 futures (chunks) ...
[10:22:48.771] resolve() on list ...
[10:22:48.771]  recursive: 0
[10:22:48.771]  length: 1
[10:22:48.771] 
[10:22:48.771] resolved() for ‘SequentialFuture’ ...
[10:22:48.771] - state: ‘finished’
[10:22:48.771] - run: TRUE
[10:22:48.771] - result: ‘FutureResult’
[10:22:48.771] resolved() for ‘SequentialFuture’ ... done
[10:22:48.772] Future #1
[10:22:48.772] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.772] - nx: 1
[10:22:48.772] - relay: TRUE
[10:22:48.772] - stdout: TRUE
[10:22:48.772] - signal: TRUE
[10:22:48.772] - resignal: FALSE
[10:22:48.772] - force: TRUE
[10:22:48.772] - relayed: [n=1] FALSE
[10:22:48.772] - queued futures: [n=1] FALSE
[10:22:48.772]  - until=1
[10:22:48.772]  - relaying element #1
[10:22:48.773] - relayed: [n=1] TRUE
[10:22:48.773] - queued futures: [n=1] TRUE
[10:22:48.773] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.773]  length: 0 (resolved future 1)
[10:22:48.773] Relaying remaining futures
[10:22:48.773] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.773] - nx: 1
[10:22:48.773] - relay: TRUE
[10:22:48.773] - stdout: TRUE
[10:22:48.773] - signal: TRUE
[10:22:48.774] - resignal: FALSE
[10:22:48.774] - force: TRUE
[10:22:48.774] - relayed: [n=1] TRUE
[10:22:48.774] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.774] - relayed: [n=1] TRUE
[10:22:48.774] - queued futures: [n=1] TRUE
[10:22:48.774] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.774] resolve() on list ... DONE
[10:22:48.774]  - Number of value chunks collected: 1
[10:22:48.774] Resolving 1 futures (chunks) ... DONE
[10:22:48.774] Reducing values from 1 chunks ...
[10:22:48.775]  - Number of values collected after concatenation: 3
[10:22:48.775]  - Number of values expected: 3
[10:22:48.775] Reducing values from 1 chunks ... DONE
[10:22:48.775] future_lapply() ... DONE
[10:22:48.775] future_by_internal() ... DONE
[10:22:48.777] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:22:48.777] future_lapply() ...
[10:22:48.778] Number of chunks: 1
[10:22:48.778] getGlobalsAndPackagesXApply() ...
[10:22:48.778]  - future.globals: TRUE
[10:22:48.778] getGlobalsAndPackages() ...
[10:22:48.778] Searching for globals...
[10:22:48.779] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:48.779] Searching for globals ... DONE
[10:22:48.779] Resolving globals: FALSE
[10:22:48.780] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:48.780] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:48.780] - globals: [1] ‘FUN’
[10:22:48.780] 
[10:22:48.780] getGlobalsAndPackages() ... DONE
[10:22:48.780]  - globals found/used: [n=1] ‘FUN’
[10:22:48.780]  - needed namespaces: [n=0] 
[10:22:48.780] Finding globals ... DONE
[10:22:48.781]  - use_args: TRUE
[10:22:48.781]  - Getting '...' globals ...
[10:22:48.781] resolve() on list ...
[10:22:48.781]  recursive: 0
[10:22:48.781]  length: 1
[10:22:48.781]  elements: ‘...’
[10:22:48.781]  length: 0 (resolved future 1)
[10:22:48.781] resolve() on list ... DONE
[10:22:48.781]    - '...' content: [n=0] 
[10:22:48.782] List of 1
[10:22:48.782]  $ ...: list()
[10:22:48.782]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.782]  - attr(*, "where")=List of 1
[10:22:48.782]   ..$ ...:<environment: 0x55f639d34fb0> 
[10:22:48.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.782]  - attr(*, "resolved")= logi TRUE
[10:22:48.782]  - attr(*, "total_size")= num NA
[10:22:48.785]  - Getting '...' globals ... DONE
[10:22:48.785] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.785] List of 2
[10:22:48.785]  $ ...future.FUN:function (object, ...)  
[10:22:48.785]  $ ...          : list()
[10:22:48.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.785]  - attr(*, "where")=List of 2
[10:22:48.785]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.785]   ..$ ...          :<environment: 0x55f639d34fb0> 
[10:22:48.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.785]  - attr(*, "resolved")= logi FALSE
[10:22:48.785]  - attr(*, "total_size")= num 1240
[10:22:48.788] Packages to be attached in all futures: [n=0] 
[10:22:48.788] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.788] Number of futures (= number of chunks): 1
[10:22:48.788] Launching 1 futures (chunks) ...
[10:22:48.788] Chunk #1 of 1 ...
[10:22:48.788]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.788] getGlobalsAndPackages() ...
[10:22:48.789] Searching for globals...
[10:22:48.789] 
[10:22:48.789] Searching for globals ... DONE
[10:22:48.789] - globals: [0] <none>
[10:22:48.789] getGlobalsAndPackages() ... DONE
[10:22:48.789]    + additional globals found: [n=0] 
[10:22:48.789]    + additional namespaces needed: [n=0] 
[10:22:48.790]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.790]  - seeds: <none>
[10:22:48.790]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.790] getGlobalsAndPackages() ...
[10:22:48.790] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.790] Resolving globals: FALSE
[10:22:48.790] Tweak future expression to call with '...' arguments ...
[10:22:48.790] {
[10:22:48.790]     do.call(function(...) {
[10:22:48.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.790]             on.exit(options(oopts), add = TRUE)
[10:22:48.790]         }
[10:22:48.790]         {
[10:22:48.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.790]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.790]             })
[10:22:48.790]         }
[10:22:48.790]     }, args = future.call.arguments)
[10:22:48.790] }
[10:22:48.790] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.791] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.791] 
[10:22:48.791] getGlobalsAndPackages() ... DONE
[10:22:48.791] run() for ‘Future’ ...
[10:22:48.791] - state: ‘created’
[10:22:48.791] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:48.792] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.792]   - Field: ‘label’
[10:22:48.792]   - Field: ‘local’
[10:22:48.792]   - Field: ‘owner’
[10:22:48.792]   - Field: ‘envir’
[10:22:48.792]   - Field: ‘packages’
[10:22:48.792]   - Field: ‘gc’
[10:22:48.792]   - Field: ‘conditions’
[10:22:48.792]   - Field: ‘expr’
[10:22:48.793]   - Field: ‘uuid’
[10:22:48.793]   - Field: ‘seed’
[10:22:48.793]   - Field: ‘version’
[10:22:48.793]   - Field: ‘result’
[10:22:48.793]   - Field: ‘asynchronous’
[10:22:48.793]   - Field: ‘calls’
[10:22:48.793]   - Field: ‘globals’
[10:22:48.793]   - Field: ‘stdout’
[10:22:48.793]   - Field: ‘earlySignal’
[10:22:48.793]   - Field: ‘lazy’
[10:22:48.793]   - Field: ‘state’
[10:22:48.794] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.794] - Launch lazy future ...
[10:22:48.794] Packages needed by the future expression (n = 0): <none>
[10:22:48.794] Packages needed by future strategies (n = 0): <none>
[10:22:48.794] {
[10:22:48.794]     {
[10:22:48.794]         {
[10:22:48.794]             ...future.startTime <- base::Sys.time()
[10:22:48.794]             {
[10:22:48.794]                 {
[10:22:48.794]                   {
[10:22:48.794]                     base::local({
[10:22:48.794]                       has_future <- base::requireNamespace("future", 
[10:22:48.794]                         quietly = TRUE)
[10:22:48.794]                       if (has_future) {
[10:22:48.794]                         ns <- base::getNamespace("future")
[10:22:48.794]                         version <- ns[[".package"]][["version"]]
[10:22:48.794]                         if (is.null(version)) 
[10:22:48.794]                           version <- utils::packageVersion("future")
[10:22:48.794]                       }
[10:22:48.794]                       else {
[10:22:48.794]                         version <- NULL
[10:22:48.794]                       }
[10:22:48.794]                       if (!has_future || version < "1.8.0") {
[10:22:48.794]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.794]                           "", base::R.version$version.string), 
[10:22:48.794]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:48.794]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.794]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.794]                             "release", "version")], collapse = " "), 
[10:22:48.794]                           hostname = base::Sys.info()[["nodename"]])
[10:22:48.794]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.794]                           info)
[10:22:48.794]                         info <- base::paste(info, collapse = "; ")
[10:22:48.794]                         if (!has_future) {
[10:22:48.794]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.794]                             info)
[10:22:48.794]                         }
[10:22:48.794]                         else {
[10:22:48.794]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.794]                             info, version)
[10:22:48.794]                         }
[10:22:48.794]                         base::stop(msg)
[10:22:48.794]                       }
[10:22:48.794]                     })
[10:22:48.794]                   }
[10:22:48.794]                   options(future.plan = NULL)
[10:22:48.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.794]                 }
[10:22:48.794]                 ...future.workdir <- getwd()
[10:22:48.794]             }
[10:22:48.794]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.794]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.794]         }
[10:22:48.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.794]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.794]             base::names(...future.oldOptions))
[10:22:48.794]     }
[10:22:48.794]     if (FALSE) {
[10:22:48.794]     }
[10:22:48.794]     else {
[10:22:48.794]         if (TRUE) {
[10:22:48.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.794]                 open = "w")
[10:22:48.794]         }
[10:22:48.794]         else {
[10:22:48.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.794]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.794]         }
[10:22:48.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.794]             base::sink(type = "output", split = FALSE)
[10:22:48.794]             base::close(...future.stdout)
[10:22:48.794]         }, add = TRUE)
[10:22:48.794]     }
[10:22:48.794]     ...future.frame <- base::sys.nframe()
[10:22:48.794]     ...future.conditions <- base::list()
[10:22:48.794]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.794]     if (FALSE) {
[10:22:48.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.794]     }
[10:22:48.794]     ...future.result <- base::tryCatch({
[10:22:48.794]         base::withCallingHandlers({
[10:22:48.794]             ...future.value <- base::withVisible(base::local({
[10:22:48.794]                 do.call(function(...) {
[10:22:48.794]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.794]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.794]                     ...future.globals.maxSize)) {
[10:22:48.794]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.794]                     on.exit(options(oopts), add = TRUE)
[10:22:48.794]                   }
[10:22:48.794]                   {
[10:22:48.794]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.794]                       FUN = function(jj) {
[10:22:48.794]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.794]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.794]                       })
[10:22:48.794]                   }
[10:22:48.794]                 }, args = future.call.arguments)
[10:22:48.794]             }))
[10:22:48.794]             future::FutureResult(value = ...future.value$value, 
[10:22:48.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.794]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.794]                     ...future.globalenv.names))
[10:22:48.794]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.794]         }, condition = base::local({
[10:22:48.794]             c <- base::c
[10:22:48.794]             inherits <- base::inherits
[10:22:48.794]             invokeRestart <- base::invokeRestart
[10:22:48.794]             length <- base::length
[10:22:48.794]             list <- base::list
[10:22:48.794]             seq.int <- base::seq.int
[10:22:48.794]             signalCondition <- base::signalCondition
[10:22:48.794]             sys.calls <- base::sys.calls
[10:22:48.794]             `[[` <- base::`[[`
[10:22:48.794]             `+` <- base::`+`
[10:22:48.794]             `<<-` <- base::`<<-`
[10:22:48.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.794]                   3L)]
[10:22:48.794]             }
[10:22:48.794]             function(cond) {
[10:22:48.794]                 is_error <- inherits(cond, "error")
[10:22:48.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.794]                   NULL)
[10:22:48.794]                 if (is_error) {
[10:22:48.794]                   sessionInformation <- function() {
[10:22:48.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.794]                       search = base::search(), system = base::Sys.info())
[10:22:48.794]                   }
[10:22:48.794]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.794]                     cond$call), session = sessionInformation(), 
[10:22:48.794]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.794]                   signalCondition(cond)
[10:22:48.794]                 }
[10:22:48.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.794]                 "immediateCondition"))) {
[10:22:48.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.794]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.794]                   if (TRUE && !signal) {
[10:22:48.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.794]                     {
[10:22:48.794]                       inherits <- base::inherits
[10:22:48.794]                       invokeRestart <- base::invokeRestart
[10:22:48.794]                       is.null <- base::is.null
[10:22:48.794]                       muffled <- FALSE
[10:22:48.794]                       if (inherits(cond, "message")) {
[10:22:48.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.794]                         if (muffled) 
[10:22:48.794]                           invokeRestart("muffleMessage")
[10:22:48.794]                       }
[10:22:48.794]                       else if (inherits(cond, "warning")) {
[10:22:48.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.794]                         if (muffled) 
[10:22:48.794]                           invokeRestart("muffleWarning")
[10:22:48.794]                       }
[10:22:48.794]                       else if (inherits(cond, "condition")) {
[10:22:48.794]                         if (!is.null(pattern)) {
[10:22:48.794]                           computeRestarts <- base::computeRestarts
[10:22:48.794]                           grepl <- base::grepl
[10:22:48.794]                           restarts <- computeRestarts(cond)
[10:22:48.794]                           for (restart in restarts) {
[10:22:48.794]                             name <- restart$name
[10:22:48.794]                             if (is.null(name)) 
[10:22:48.794]                               next
[10:22:48.794]                             if (!grepl(pattern, name)) 
[10:22:48.794]                               next
[10:22:48.794]                             invokeRestart(restart)
[10:22:48.794]                             muffled <- TRUE
[10:22:48.794]                             break
[10:22:48.794]                           }
[10:22:48.794]                         }
[10:22:48.794]                       }
[10:22:48.794]                       invisible(muffled)
[10:22:48.794]                     }
[10:22:48.794]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.794]                   }
[10:22:48.794]                 }
[10:22:48.794]                 else {
[10:22:48.794]                   if (TRUE) {
[10:22:48.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.794]                     {
[10:22:48.794]                       inherits <- base::inherits
[10:22:48.794]                       invokeRestart <- base::invokeRestart
[10:22:48.794]                       is.null <- base::is.null
[10:22:48.794]                       muffled <- FALSE
[10:22:48.794]                       if (inherits(cond, "message")) {
[10:22:48.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.794]                         if (muffled) 
[10:22:48.794]                           invokeRestart("muffleMessage")
[10:22:48.794]                       }
[10:22:48.794]                       else if (inherits(cond, "warning")) {
[10:22:48.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.794]                         if (muffled) 
[10:22:48.794]                           invokeRestart("muffleWarning")
[10:22:48.794]                       }
[10:22:48.794]                       else if (inherits(cond, "condition")) {
[10:22:48.794]                         if (!is.null(pattern)) {
[10:22:48.794]                           computeRestarts <- base::computeRestarts
[10:22:48.794]                           grepl <- base::grepl
[10:22:48.794]                           restarts <- computeRestarts(cond)
[10:22:48.794]                           for (restart in restarts) {
[10:22:48.794]                             name <- restart$name
[10:22:48.794]                             if (is.null(name)) 
[10:22:48.794]                               next
[10:22:48.794]                             if (!grepl(pattern, name)) 
[10:22:48.794]                               next
[10:22:48.794]                             invokeRestart(restart)
[10:22:48.794]                             muffled <- TRUE
[10:22:48.794]                             break
[10:22:48.794]                           }
[10:22:48.794]                         }
[10:22:48.794]                       }
[10:22:48.794]                       invisible(muffled)
[10:22:48.794]                     }
[10:22:48.794]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.794]                   }
[10:22:48.794]                 }
[10:22:48.794]             }
[10:22:48.794]         }))
[10:22:48.794]     }, error = function(ex) {
[10:22:48.794]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.794]                 ...future.rng), started = ...future.startTime, 
[10:22:48.794]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.794]             version = "1.8"), class = "FutureResult")
[10:22:48.794]     }, finally = {
[10:22:48.794]         if (!identical(...future.workdir, getwd())) 
[10:22:48.794]             setwd(...future.workdir)
[10:22:48.794]         {
[10:22:48.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.794]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.794]             }
[10:22:48.794]             base::options(...future.oldOptions)
[10:22:48.794]             if (.Platform$OS.type == "windows") {
[10:22:48.794]                 old_names <- names(...future.oldEnvVars)
[10:22:48.794]                 envs <- base::Sys.getenv()
[10:22:48.794]                 names <- names(envs)
[10:22:48.794]                 common <- intersect(names, old_names)
[10:22:48.794]                 added <- setdiff(names, old_names)
[10:22:48.794]                 removed <- setdiff(old_names, names)
[10:22:48.794]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.794]                   envs[common]]
[10:22:48.794]                 NAMES <- toupper(changed)
[10:22:48.794]                 args <- list()
[10:22:48.794]                 for (kk in seq_along(NAMES)) {
[10:22:48.794]                   name <- changed[[kk]]
[10:22:48.794]                   NAME <- NAMES[[kk]]
[10:22:48.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.794]                     next
[10:22:48.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.794]                 }
[10:22:48.794]                 NAMES <- toupper(added)
[10:22:48.794]                 for (kk in seq_along(NAMES)) {
[10:22:48.794]                   name <- added[[kk]]
[10:22:48.794]                   NAME <- NAMES[[kk]]
[10:22:48.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.794]                     next
[10:22:48.794]                   args[[name]] <- ""
[10:22:48.794]                 }
[10:22:48.794]                 NAMES <- toupper(removed)
[10:22:48.794]                 for (kk in seq_along(NAMES)) {
[10:22:48.794]                   name <- removed[[kk]]
[10:22:48.794]                   NAME <- NAMES[[kk]]
[10:22:48.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.794]                     next
[10:22:48.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.794]                 }
[10:22:48.794]                 if (length(args) > 0) 
[10:22:48.794]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.794]             }
[10:22:48.794]             else {
[10:22:48.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.794]             }
[10:22:48.794]             {
[10:22:48.794]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.794]                   0L) {
[10:22:48.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.794]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.794]                   base::options(opts)
[10:22:48.794]                 }
[10:22:48.794]                 {
[10:22:48.794]                   {
[10:22:48.794]                     NULL
[10:22:48.794]                     RNGkind("Mersenne-Twister")
[10:22:48.794]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.794]                       inherits = FALSE)
[10:22:48.794]                   }
[10:22:48.794]                   options(future.plan = NULL)
[10:22:48.794]                   if (is.na(NA_character_)) 
[10:22:48.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.794]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:48.794]                   {
[10:22:48.794]                     future <- SequentialFuture(..., envir = envir)
[10:22:48.794]                     if (!future$lazy) 
[10:22:48.794]                       future <- run(future)
[10:22:48.794]                     invisible(future)
[10:22:48.794]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.794]                 }
[10:22:48.794]             }
[10:22:48.794]         }
[10:22:48.794]     })
[10:22:48.794]     if (TRUE) {
[10:22:48.794]         base::sink(type = "output", split = FALSE)
[10:22:48.794]         if (TRUE) {
[10:22:48.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.794]         }
[10:22:48.794]         else {
[10:22:48.794]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.794]         }
[10:22:48.794]         base::close(...future.stdout)
[10:22:48.794]         ...future.stdout <- NULL
[10:22:48.794]     }
[10:22:48.794]     ...future.result$conditions <- ...future.conditions
[10:22:48.794]     ...future.result$finished <- base::Sys.time()
[10:22:48.794]     ...future.result
[10:22:48.794] }
[10:22:48.796] assign_globals() ...
[10:22:48.796] List of 5
[10:22:48.796]  $ ...future.FUN            :function (object, ...)  
[10:22:48.796]  $ future.call.arguments    : list()
[10:22:48.796]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.796]  $ ...future.elements_ii    :List of 3
[10:22:48.796]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.796]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.796]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.796]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.796]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.796]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.796]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.796]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:48.796]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.796]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.796]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.796]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:48.796]  $ ...future.seeds_ii       : NULL
[10:22:48.796]  $ ...future.globals.maxSize: NULL
[10:22:48.796]  - attr(*, "where")=List of 5
[10:22:48.796]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.796]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.796]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.796]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.796]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.796]  - attr(*, "resolved")= logi FALSE
[10:22:48.796]  - attr(*, "total_size")= num 1240
[10:22:48.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.796]  - attr(*, "already-done")= logi TRUE
[10:22:48.805] - copied ‘...future.FUN’ to environment
[10:22:48.805] - copied ‘future.call.arguments’ to environment
[10:22:48.805] - copied ‘...future.elements_ii’ to environment
[10:22:48.805] - copied ‘...future.seeds_ii’ to environment
[10:22:48.805] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.805] assign_globals() ... done
[10:22:48.806] plan(): Setting new future strategy stack:
[10:22:48.806] List of future strategies:
[10:22:48.806] 1. sequential:
[10:22:48.806]    - args: function (..., envir = parent.frame())
[10:22:48.806]    - tweaked: FALSE
[10:22:48.806]    - call: NULL
[10:22:48.806] plan(): nbrOfWorkers() = 1
[10:22:48.808] plan(): Setting new future strategy stack:
[10:22:48.808] List of future strategies:
[10:22:48.808] 1. sequential:
[10:22:48.808]    - args: function (..., envir = parent.frame())
[10:22:48.808]    - tweaked: FALSE
[10:22:48.808]    - call: plan(strategy)
[10:22:48.809] plan(): nbrOfWorkers() = 1
[10:22:48.809] SequentialFuture started (and completed)
[10:22:48.809] - Launch lazy future ... done
[10:22:48.809] run() for ‘SequentialFuture’ ... done
[10:22:48.809] Created future:
[10:22:48.809] SequentialFuture:
[10:22:48.809] Label: ‘future_by-1’
[10:22:48.809] Expression:
[10:22:48.809] {
[10:22:48.809]     do.call(function(...) {
[10:22:48.809]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.809]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.809]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.809]             on.exit(options(oopts), add = TRUE)
[10:22:48.809]         }
[10:22:48.809]         {
[10:22:48.809]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.809]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.809]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.809]             })
[10:22:48.809]         }
[10:22:48.809]     }, args = future.call.arguments)
[10:22:48.809] }
[10:22:48.809] Lazy evaluation: FALSE
[10:22:48.809] Asynchronous evaluation: FALSE
[10:22:48.809] Local evaluation: TRUE
[10:22:48.809] Environment: 0x55f639b80ec8
[10:22:48.809] Capture standard output: TRUE
[10:22:48.809] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.809] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.809] Packages: <none>
[10:22:48.809] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.809] Resolved: TRUE
[10:22:48.809] Value: 5.37 KiB of class ‘list’
[10:22:48.809] Early signaling: FALSE
[10:22:48.809] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.809] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.810] Chunk #1 of 1 ... DONE
[10:22:48.810] Launching 1 futures (chunks) ... DONE
[10:22:48.810] Resolving 1 futures (chunks) ...
[10:22:48.811] resolve() on list ...
[10:22:48.811]  recursive: 0
[10:22:48.811]  length: 1
[10:22:48.811] 
[10:22:48.811] resolved() for ‘SequentialFuture’ ...
[10:22:48.811] - state: ‘finished’
[10:22:48.811] - run: TRUE
[10:22:48.811] - result: ‘FutureResult’
[10:22:48.811] resolved() for ‘SequentialFuture’ ... done
[10:22:48.811] Future #1
[10:22:48.812] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.812] - nx: 1
[10:22:48.812] - relay: TRUE
[10:22:48.812] - stdout: TRUE
[10:22:48.812] - signal: TRUE
[10:22:48.812] - resignal: FALSE
[10:22:48.812] - force: TRUE
[10:22:48.812] - relayed: [n=1] FALSE
[10:22:48.812] - queued futures: [n=1] FALSE
[10:22:48.812]  - until=1
[10:22:48.812]  - relaying element #1
[10:22:48.813] - relayed: [n=1] TRUE
[10:22:48.813] - queued futures: [n=1] TRUE
[10:22:48.813] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.813]  length: 0 (resolved future 1)
[10:22:48.813] Relaying remaining futures
[10:22:48.813] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.813] - nx: 1
[10:22:48.813] - relay: TRUE
[10:22:48.813] - stdout: TRUE
[10:22:48.813] - signal: TRUE
[10:22:48.813] - resignal: FALSE
[10:22:48.813] - force: TRUE
[10:22:48.814] - relayed: [n=1] TRUE
[10:22:48.814] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.814] - relayed: [n=1] TRUE
[10:22:48.814] - queued futures: [n=1] TRUE
[10:22:48.814] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.814] resolve() on list ... DONE
[10:22:48.814]  - Number of value chunks collected: 1
[10:22:48.814] Resolving 1 futures (chunks) ... DONE
[10:22:48.814] Reducing values from 1 chunks ...
[10:22:48.814]  - Number of values collected after concatenation: 3
[10:22:48.814]  - Number of values expected: 3
[10:22:48.815] Reducing values from 1 chunks ... DONE
[10:22:48.815] future_lapply() ... DONE
[10:22:48.815] future_by_internal() ... DONE
[10:22:48.815] future_by_internal() ...
- plan('multicore') ...
[10:22:48.816] plan(): Setting new future strategy stack:
[10:22:48.816] List of future strategies:
[10:22:48.816] 1. multicore:
[10:22:48.816]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:48.816]    - tweaked: FALSE
[10:22:48.816]    - call: plan(strategy)
[10:22:48.820] plan(): nbrOfWorkers() = 1
[10:22:48.820] future_by_internal() ...
[10:22:48.820] future_lapply() ...
[10:22:48.824] Number of chunks: 1
[10:22:48.824] getGlobalsAndPackagesXApply() ...
[10:22:48.824]  - future.globals: TRUE
[10:22:48.824] getGlobalsAndPackages() ...
[10:22:48.824] Searching for globals...
[10:22:48.825] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:48.825] Searching for globals ... DONE
[10:22:48.825] Resolving globals: FALSE
[10:22:48.826] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:48.826] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:48.826] - globals: [1] ‘FUN’
[10:22:48.826] 
[10:22:48.826] getGlobalsAndPackages() ... DONE
[10:22:48.826]  - globals found/used: [n=1] ‘FUN’
[10:22:48.828]  - needed namespaces: [n=0] 
[10:22:48.828] Finding globals ... DONE
[10:22:48.828]  - use_args: TRUE
[10:22:48.828]  - Getting '...' globals ...
[10:22:48.828] resolve() on list ...
[10:22:48.828]  recursive: 0
[10:22:48.828]  length: 1
[10:22:48.828]  elements: ‘...’
[10:22:48.829]  length: 0 (resolved future 1)
[10:22:48.829] resolve() on list ... DONE
[10:22:48.829]    - '...' content: [n=0] 
[10:22:48.829] List of 1
[10:22:48.829]  $ ...: list()
[10:22:48.829]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.829]  - attr(*, "where")=List of 1
[10:22:48.829]   ..$ ...:<environment: 0x55f639eba0d0> 
[10:22:48.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.829]  - attr(*, "resolved")= logi TRUE
[10:22:48.829]  - attr(*, "total_size")= num NA
[10:22:48.831]  - Getting '...' globals ... DONE
[10:22:48.831] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.832] List of 2
[10:22:48.832]  $ ...future.FUN:function (object, ...)  
[10:22:48.832]  $ ...          : list()
[10:22:48.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.832]  - attr(*, "where")=List of 2
[10:22:48.832]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.832]   ..$ ...          :<environment: 0x55f639eba0d0> 
[10:22:48.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.832]  - attr(*, "resolved")= logi FALSE
[10:22:48.832]  - attr(*, "total_size")= num 1240
[10:22:48.834] Packages to be attached in all futures: [n=0] 
[10:22:48.834] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.834] Number of futures (= number of chunks): 1
[10:22:48.835] Launching 1 futures (chunks) ...
[10:22:48.835] Chunk #1 of 1 ...
[10:22:48.835]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.835] getGlobalsAndPackages() ...
[10:22:48.835] Searching for globals...
[10:22:48.835] 
[10:22:48.835] Searching for globals ... DONE
[10:22:48.835] - globals: [0] <none>
[10:22:48.836] getGlobalsAndPackages() ... DONE
[10:22:48.836]    + additional globals found: [n=0] 
[10:22:48.836]    + additional namespaces needed: [n=0] 
[10:22:48.836]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.836]  - seeds: <none>
[10:22:48.836]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.836] getGlobalsAndPackages() ...
[10:22:48.836] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.836] Resolving globals: FALSE
[10:22:48.836] Tweak future expression to call with '...' arguments ...
[10:22:48.836] {
[10:22:48.836]     do.call(function(...) {
[10:22:48.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.836]             on.exit(options(oopts), add = TRUE)
[10:22:48.836]         }
[10:22:48.836]         {
[10:22:48.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.836]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.836]             })
[10:22:48.836]         }
[10:22:48.836]     }, args = future.call.arguments)
[10:22:48.836] }
[10:22:48.837] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.837] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.837] 
[10:22:48.837] getGlobalsAndPackages() ... DONE
[10:22:48.838] run() for ‘Future’ ...
[10:22:48.838] - state: ‘created’
[10:22:48.838] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.841] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.841]   - Field: ‘label’
[10:22:48.841]   - Field: ‘local’
[10:22:48.842]   - Field: ‘owner’
[10:22:48.842]   - Field: ‘envir’
[10:22:48.842]   - Field: ‘packages’
[10:22:48.842]   - Field: ‘gc’
[10:22:48.842]   - Field: ‘conditions’
[10:22:48.842]   - Field: ‘expr’
[10:22:48.842]   - Field: ‘uuid’
[10:22:48.842]   - Field: ‘seed’
[10:22:48.842]   - Field: ‘version’
[10:22:48.842]   - Field: ‘result’
[10:22:48.842]   - Field: ‘asynchronous’
[10:22:48.843]   - Field: ‘calls’
[10:22:48.843]   - Field: ‘globals’
[10:22:48.843]   - Field: ‘stdout’
[10:22:48.843]   - Field: ‘earlySignal’
[10:22:48.843]   - Field: ‘lazy’
[10:22:48.843]   - Field: ‘state’
[10:22:48.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.843] - Launch lazy future ...
[10:22:48.843] Packages needed by the future expression (n = 0): <none>
[10:22:48.843] Packages needed by future strategies (n = 0): <none>
[10:22:48.844] {
[10:22:48.844]     {
[10:22:48.844]         {
[10:22:48.844]             ...future.startTime <- base::Sys.time()
[10:22:48.844]             {
[10:22:48.844]                 {
[10:22:48.844]                   {
[10:22:48.844]                     base::local({
[10:22:48.844]                       has_future <- base::requireNamespace("future", 
[10:22:48.844]                         quietly = TRUE)
[10:22:48.844]                       if (has_future) {
[10:22:48.844]                         ns <- base::getNamespace("future")
[10:22:48.844]                         version <- ns[[".package"]][["version"]]
[10:22:48.844]                         if (is.null(version)) 
[10:22:48.844]                           version <- utils::packageVersion("future")
[10:22:48.844]                       }
[10:22:48.844]                       else {
[10:22:48.844]                         version <- NULL
[10:22:48.844]                       }
[10:22:48.844]                       if (!has_future || version < "1.8.0") {
[10:22:48.844]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.844]                           "", base::R.version$version.string), 
[10:22:48.844]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:48.844]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.844]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.844]                             "release", "version")], collapse = " "), 
[10:22:48.844]                           hostname = base::Sys.info()[["nodename"]])
[10:22:48.844]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.844]                           info)
[10:22:48.844]                         info <- base::paste(info, collapse = "; ")
[10:22:48.844]                         if (!has_future) {
[10:22:48.844]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.844]                             info)
[10:22:48.844]                         }
[10:22:48.844]                         else {
[10:22:48.844]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.844]                             info, version)
[10:22:48.844]                         }
[10:22:48.844]                         base::stop(msg)
[10:22:48.844]                       }
[10:22:48.844]                     })
[10:22:48.844]                   }
[10:22:48.844]                   options(future.plan = NULL)
[10:22:48.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.844]                 }
[10:22:48.844]                 ...future.workdir <- getwd()
[10:22:48.844]             }
[10:22:48.844]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.844]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.844]         }
[10:22:48.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.844]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.844]             base::names(...future.oldOptions))
[10:22:48.844]     }
[10:22:48.844]     if (FALSE) {
[10:22:48.844]     }
[10:22:48.844]     else {
[10:22:48.844]         if (TRUE) {
[10:22:48.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.844]                 open = "w")
[10:22:48.844]         }
[10:22:48.844]         else {
[10:22:48.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.844]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.844]         }
[10:22:48.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.844]             base::sink(type = "output", split = FALSE)
[10:22:48.844]             base::close(...future.stdout)
[10:22:48.844]         }, add = TRUE)
[10:22:48.844]     }
[10:22:48.844]     ...future.frame <- base::sys.nframe()
[10:22:48.844]     ...future.conditions <- base::list()
[10:22:48.844]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.844]     if (FALSE) {
[10:22:48.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.844]     }
[10:22:48.844]     ...future.result <- base::tryCatch({
[10:22:48.844]         base::withCallingHandlers({
[10:22:48.844]             ...future.value <- base::withVisible(base::local({
[10:22:48.844]                 do.call(function(...) {
[10:22:48.844]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.844]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.844]                     ...future.globals.maxSize)) {
[10:22:48.844]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.844]                     on.exit(options(oopts), add = TRUE)
[10:22:48.844]                   }
[10:22:48.844]                   {
[10:22:48.844]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.844]                       FUN = function(jj) {
[10:22:48.844]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.844]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.844]                       })
[10:22:48.844]                   }
[10:22:48.844]                 }, args = future.call.arguments)
[10:22:48.844]             }))
[10:22:48.844]             future::FutureResult(value = ...future.value$value, 
[10:22:48.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.844]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.844]                     ...future.globalenv.names))
[10:22:48.844]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.844]         }, condition = base::local({
[10:22:48.844]             c <- base::c
[10:22:48.844]             inherits <- base::inherits
[10:22:48.844]             invokeRestart <- base::invokeRestart
[10:22:48.844]             length <- base::length
[10:22:48.844]             list <- base::list
[10:22:48.844]             seq.int <- base::seq.int
[10:22:48.844]             signalCondition <- base::signalCondition
[10:22:48.844]             sys.calls <- base::sys.calls
[10:22:48.844]             `[[` <- base::`[[`
[10:22:48.844]             `+` <- base::`+`
[10:22:48.844]             `<<-` <- base::`<<-`
[10:22:48.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.844]                   3L)]
[10:22:48.844]             }
[10:22:48.844]             function(cond) {
[10:22:48.844]                 is_error <- inherits(cond, "error")
[10:22:48.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.844]                   NULL)
[10:22:48.844]                 if (is_error) {
[10:22:48.844]                   sessionInformation <- function() {
[10:22:48.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.844]                       search = base::search(), system = base::Sys.info())
[10:22:48.844]                   }
[10:22:48.844]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.844]                     cond$call), session = sessionInformation(), 
[10:22:48.844]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.844]                   signalCondition(cond)
[10:22:48.844]                 }
[10:22:48.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.844]                 "immediateCondition"))) {
[10:22:48.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.844]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.844]                   if (TRUE && !signal) {
[10:22:48.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.844]                     {
[10:22:48.844]                       inherits <- base::inherits
[10:22:48.844]                       invokeRestart <- base::invokeRestart
[10:22:48.844]                       is.null <- base::is.null
[10:22:48.844]                       muffled <- FALSE
[10:22:48.844]                       if (inherits(cond, "message")) {
[10:22:48.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.844]                         if (muffled) 
[10:22:48.844]                           invokeRestart("muffleMessage")
[10:22:48.844]                       }
[10:22:48.844]                       else if (inherits(cond, "warning")) {
[10:22:48.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.844]                         if (muffled) 
[10:22:48.844]                           invokeRestart("muffleWarning")
[10:22:48.844]                       }
[10:22:48.844]                       else if (inherits(cond, "condition")) {
[10:22:48.844]                         if (!is.null(pattern)) {
[10:22:48.844]                           computeRestarts <- base::computeRestarts
[10:22:48.844]                           grepl <- base::grepl
[10:22:48.844]                           restarts <- computeRestarts(cond)
[10:22:48.844]                           for (restart in restarts) {
[10:22:48.844]                             name <- restart$name
[10:22:48.844]                             if (is.null(name)) 
[10:22:48.844]                               next
[10:22:48.844]                             if (!grepl(pattern, name)) 
[10:22:48.844]                               next
[10:22:48.844]                             invokeRestart(restart)
[10:22:48.844]                             muffled <- TRUE
[10:22:48.844]                             break
[10:22:48.844]                           }
[10:22:48.844]                         }
[10:22:48.844]                       }
[10:22:48.844]                       invisible(muffled)
[10:22:48.844]                     }
[10:22:48.844]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.844]                   }
[10:22:48.844]                 }
[10:22:48.844]                 else {
[10:22:48.844]                   if (TRUE) {
[10:22:48.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.844]                     {
[10:22:48.844]                       inherits <- base::inherits
[10:22:48.844]                       invokeRestart <- base::invokeRestart
[10:22:48.844]                       is.null <- base::is.null
[10:22:48.844]                       muffled <- FALSE
[10:22:48.844]                       if (inherits(cond, "message")) {
[10:22:48.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.844]                         if (muffled) 
[10:22:48.844]                           invokeRestart("muffleMessage")
[10:22:48.844]                       }
[10:22:48.844]                       else if (inherits(cond, "warning")) {
[10:22:48.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.844]                         if (muffled) 
[10:22:48.844]                           invokeRestart("muffleWarning")
[10:22:48.844]                       }
[10:22:48.844]                       else if (inherits(cond, "condition")) {
[10:22:48.844]                         if (!is.null(pattern)) {
[10:22:48.844]                           computeRestarts <- base::computeRestarts
[10:22:48.844]                           grepl <- base::grepl
[10:22:48.844]                           restarts <- computeRestarts(cond)
[10:22:48.844]                           for (restart in restarts) {
[10:22:48.844]                             name <- restart$name
[10:22:48.844]                             if (is.null(name)) 
[10:22:48.844]                               next
[10:22:48.844]                             if (!grepl(pattern, name)) 
[10:22:48.844]                               next
[10:22:48.844]                             invokeRestart(restart)
[10:22:48.844]                             muffled <- TRUE
[10:22:48.844]                             break
[10:22:48.844]                           }
[10:22:48.844]                         }
[10:22:48.844]                       }
[10:22:48.844]                       invisible(muffled)
[10:22:48.844]                     }
[10:22:48.844]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.844]                   }
[10:22:48.844]                 }
[10:22:48.844]             }
[10:22:48.844]         }))
[10:22:48.844]     }, error = function(ex) {
[10:22:48.844]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.844]                 ...future.rng), started = ...future.startTime, 
[10:22:48.844]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.844]             version = "1.8"), class = "FutureResult")
[10:22:48.844]     }, finally = {
[10:22:48.844]         if (!identical(...future.workdir, getwd())) 
[10:22:48.844]             setwd(...future.workdir)
[10:22:48.844]         {
[10:22:48.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.844]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.844]             }
[10:22:48.844]             base::options(...future.oldOptions)
[10:22:48.844]             if (.Platform$OS.type == "windows") {
[10:22:48.844]                 old_names <- names(...future.oldEnvVars)
[10:22:48.844]                 envs <- base::Sys.getenv()
[10:22:48.844]                 names <- names(envs)
[10:22:48.844]                 common <- intersect(names, old_names)
[10:22:48.844]                 added <- setdiff(names, old_names)
[10:22:48.844]                 removed <- setdiff(old_names, names)
[10:22:48.844]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.844]                   envs[common]]
[10:22:48.844]                 NAMES <- toupper(changed)
[10:22:48.844]                 args <- list()
[10:22:48.844]                 for (kk in seq_along(NAMES)) {
[10:22:48.844]                   name <- changed[[kk]]
[10:22:48.844]                   NAME <- NAMES[[kk]]
[10:22:48.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.844]                     next
[10:22:48.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.844]                 }
[10:22:48.844]                 NAMES <- toupper(added)
[10:22:48.844]                 for (kk in seq_along(NAMES)) {
[10:22:48.844]                   name <- added[[kk]]
[10:22:48.844]                   NAME <- NAMES[[kk]]
[10:22:48.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.844]                     next
[10:22:48.844]                   args[[name]] <- ""
[10:22:48.844]                 }
[10:22:48.844]                 NAMES <- toupper(removed)
[10:22:48.844]                 for (kk in seq_along(NAMES)) {
[10:22:48.844]                   name <- removed[[kk]]
[10:22:48.844]                   NAME <- NAMES[[kk]]
[10:22:48.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.844]                     next
[10:22:48.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.844]                 }
[10:22:48.844]                 if (length(args) > 0) 
[10:22:48.844]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.844]             }
[10:22:48.844]             else {
[10:22:48.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.844]             }
[10:22:48.844]             {
[10:22:48.844]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.844]                   0L) {
[10:22:48.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.844]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.844]                   base::options(opts)
[10:22:48.844]                 }
[10:22:48.844]                 {
[10:22:48.844]                   {
[10:22:48.844]                     NULL
[10:22:48.844]                     RNGkind("Mersenne-Twister")
[10:22:48.844]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.844]                       inherits = FALSE)
[10:22:48.844]                   }
[10:22:48.844]                   options(future.plan = NULL)
[10:22:48.844]                   if (is.na(NA_character_)) 
[10:22:48.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.844]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:48.844]                     envir = parent.frame()) 
[10:22:48.844]                   {
[10:22:48.844]                     default_workers <- missing(workers)
[10:22:48.844]                     if (is.function(workers)) 
[10:22:48.844]                       workers <- workers()
[10:22:48.844]                     workers <- structure(as.integer(workers), 
[10:22:48.844]                       class = class(workers))
[10:22:48.844]                     stop_if_not(is.finite(workers), workers >= 
[10:22:48.844]                       1L)
[10:22:48.844]                     if ((workers == 1L && !inherits(workers, 
[10:22:48.844]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:48.844]                       if (default_workers) 
[10:22:48.844]                         supportsMulticore(warn = TRUE)
[10:22:48.844]                       return(sequential(..., envir = envir))
[10:22:48.844]                     }
[10:22:48.844]                     oopts <- options(mc.cores = workers)
[10:22:48.844]                     on.exit(options(oopts))
[10:22:48.844]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:48.844]                       envir = envir)
[10:22:48.844]                     if (!future$lazy) 
[10:22:48.844]                       future <- run(future)
[10:22:48.844]                     invisible(future)
[10:22:48.844]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.844]                 }
[10:22:48.844]             }
[10:22:48.844]         }
[10:22:48.844]     })
[10:22:48.844]     if (TRUE) {
[10:22:48.844]         base::sink(type = "output", split = FALSE)
[10:22:48.844]         if (TRUE) {
[10:22:48.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.844]         }
[10:22:48.844]         else {
[10:22:48.844]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.844]         }
[10:22:48.844]         base::close(...future.stdout)
[10:22:48.844]         ...future.stdout <- NULL
[10:22:48.844]     }
[10:22:48.844]     ...future.result$conditions <- ...future.conditions
[10:22:48.844]     ...future.result$finished <- base::Sys.time()
[10:22:48.844]     ...future.result
[10:22:48.844] }
[10:22:48.846] assign_globals() ...
[10:22:48.846] List of 5
[10:22:48.846]  $ ...future.FUN            :function (object, ...)  
[10:22:48.846]  $ future.call.arguments    : list()
[10:22:48.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.846]  $ ...future.elements_ii    :List of 3
[10:22:48.846]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:48.846]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.846]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.846]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:48.846]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.846]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.846]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:48.846]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.846]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.846]  $ ...future.seeds_ii       : NULL
[10:22:48.846]  $ ...future.globals.maxSize: NULL
[10:22:48.846]  - attr(*, "where")=List of 5
[10:22:48.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.846]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.846]  - attr(*, "resolved")= logi FALSE
[10:22:48.846]  - attr(*, "total_size")= num 1240
[10:22:48.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.846]  - attr(*, "already-done")= logi TRUE
[10:22:48.854] - copied ‘...future.FUN’ to environment
[10:22:48.854] - copied ‘future.call.arguments’ to environment
[10:22:48.854] - copied ‘...future.elements_ii’ to environment
[10:22:48.854] - copied ‘...future.seeds_ii’ to environment
[10:22:48.854] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.855] assign_globals() ... done
[10:22:48.855] plan(): Setting new future strategy stack:
[10:22:48.855] List of future strategies:
[10:22:48.855] 1. sequential:
[10:22:48.855]    - args: function (..., envir = parent.frame())
[10:22:48.855]    - tweaked: FALSE
[10:22:48.855]    - call: NULL
[10:22:48.855] plan(): nbrOfWorkers() = 1
[10:22:48.857] plan(): Setting new future strategy stack:
[10:22:48.857] List of future strategies:
[10:22:48.857] 1. multicore:
[10:22:48.857]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:48.857]    - tweaked: FALSE
[10:22:48.857]    - call: plan(strategy)
[10:22:48.860] plan(): nbrOfWorkers() = 1
[10:22:48.861] SequentialFuture started (and completed)
[10:22:48.861] - Launch lazy future ... done
[10:22:48.861] run() for ‘SequentialFuture’ ... done
[10:22:48.861] Created future:
[10:22:48.861] SequentialFuture:
[10:22:48.861] Label: ‘future_by-1’
[10:22:48.861] Expression:
[10:22:48.861] {
[10:22:48.861]     do.call(function(...) {
[10:22:48.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.861]             on.exit(options(oopts), add = TRUE)
[10:22:48.861]         }
[10:22:48.861]         {
[10:22:48.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.861]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.861]             })
[10:22:48.861]         }
[10:22:48.861]     }, args = future.call.arguments)
[10:22:48.861] }
[10:22:48.861] Lazy evaluation: FALSE
[10:22:48.861] Asynchronous evaluation: FALSE
[10:22:48.861] Local evaluation: TRUE
[10:22:48.861] Environment: R_GlobalEnv
[10:22:48.861] Capture standard output: TRUE
[10:22:48.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.861] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.861] Packages: <none>
[10:22:48.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.861] Resolved: TRUE
[10:22:48.861] Value: 4.62 KiB of class ‘list’
[10:22:48.861] Early signaling: FALSE
[10:22:48.861] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.861] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.862] Chunk #1 of 1 ... DONE
[10:22:48.862] Launching 1 futures (chunks) ... DONE
[10:22:48.862] Resolving 1 futures (chunks) ...
[10:22:48.862] resolve() on list ...
[10:22:48.863]  recursive: 0
[10:22:48.863]  length: 1
[10:22:48.863] 
[10:22:48.863] resolved() for ‘SequentialFuture’ ...
[10:22:48.863] - state: ‘finished’
[10:22:48.863] - run: TRUE
[10:22:48.863] - result: ‘FutureResult’
[10:22:48.863] resolved() for ‘SequentialFuture’ ... done
[10:22:48.863] Future #1
[10:22:48.863] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.863] - nx: 1
[10:22:48.864] - relay: TRUE
[10:22:48.864] - stdout: TRUE
[10:22:48.864] - signal: TRUE
[10:22:48.864] - resignal: FALSE
[10:22:48.864] - force: TRUE
[10:22:48.864] - relayed: [n=1] FALSE
[10:22:48.864] - queued futures: [n=1] FALSE
[10:22:48.864]  - until=1
[10:22:48.864]  - relaying element #1
[10:22:48.864] - relayed: [n=1] TRUE
[10:22:48.864] - queued futures: [n=1] TRUE
[10:22:48.865] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.865]  length: 0 (resolved future 1)
[10:22:48.865] Relaying remaining futures
[10:22:48.865] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.865] - nx: 1
[10:22:48.865] - relay: TRUE
[10:22:48.865] - stdout: TRUE
[10:22:48.865] - signal: TRUE
[10:22:48.865] - resignal: FALSE
[10:22:48.865] - force: TRUE
[10:22:48.865] - relayed: [n=1] TRUE
[10:22:48.865] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.866] - relayed: [n=1] TRUE
[10:22:48.866] - queued futures: [n=1] TRUE
[10:22:48.866] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.866] resolve() on list ... DONE
[10:22:48.866]  - Number of value chunks collected: 1
[10:22:48.866] Resolving 1 futures (chunks) ... DONE
[10:22:48.866] Reducing values from 1 chunks ...
[10:22:48.866]  - Number of values collected after concatenation: 3
[10:22:48.866]  - Number of values expected: 3
[10:22:48.866] Reducing values from 1 chunks ... DONE
[10:22:48.867] future_lapply() ... DONE
[10:22:48.867] future_by_internal() ... DONE
[10:22:48.867] future_by_internal() ...
[10:22:48.867] future_lapply() ...
[10:22:48.871] Number of chunks: 1
[10:22:48.871] getGlobalsAndPackagesXApply() ...
[10:22:48.871]  - future.globals: TRUE
[10:22:48.871] getGlobalsAndPackages() ...
[10:22:48.871] Searching for globals...
[10:22:48.873] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:48.873] Searching for globals ... DONE
[10:22:48.873] Resolving globals: FALSE
[10:22:48.874] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:48.874] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:48.874] - globals: [1] ‘FUN’
[10:22:48.874] 
[10:22:48.874] getGlobalsAndPackages() ... DONE
[10:22:48.875]  - globals found/used: [n=1] ‘FUN’
[10:22:48.875]  - needed namespaces: [n=0] 
[10:22:48.875] Finding globals ... DONE
[10:22:48.875]  - use_args: TRUE
[10:22:48.875]  - Getting '...' globals ...
[10:22:48.875] resolve() on list ...
[10:22:48.875]  recursive: 0
[10:22:48.875]  length: 1
[10:22:48.875]  elements: ‘...’
[10:22:48.876]  length: 0 (resolved future 1)
[10:22:48.876] resolve() on list ... DONE
[10:22:48.876]    - '...' content: [n=1] ‘digits’
[10:22:48.876] List of 1
[10:22:48.876]  $ ...:List of 1
[10:22:48.876]   ..$ digits: int 2
[10:22:48.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.876]  - attr(*, "where")=List of 1
[10:22:48.876]   ..$ ...:<environment: 0x55f63a02eee0> 
[10:22:48.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.876]  - attr(*, "resolved")= logi TRUE
[10:22:48.876]  - attr(*, "total_size")= num NA
[10:22:48.879]  - Getting '...' globals ... DONE
[10:22:48.879] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.879] List of 2
[10:22:48.879]  $ ...future.FUN:function (object, ...)  
[10:22:48.879]  $ ...          :List of 1
[10:22:48.879]   ..$ digits: int 2
[10:22:48.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.879]  - attr(*, "where")=List of 2
[10:22:48.879]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.879]   ..$ ...          :<environment: 0x55f63a02eee0> 
[10:22:48.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.879]  - attr(*, "resolved")= logi FALSE
[10:22:48.879]  - attr(*, "total_size")= num 1296
[10:22:48.882] Packages to be attached in all futures: [n=0] 
[10:22:48.882] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.882] Number of futures (= number of chunks): 1
[10:22:48.882] Launching 1 futures (chunks) ...
[10:22:48.882] Chunk #1 of 1 ...
[10:22:48.882]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.883] getGlobalsAndPackages() ...
[10:22:48.883] Searching for globals...
[10:22:48.883] 
[10:22:48.883] Searching for globals ... DONE
[10:22:48.883] - globals: [0] <none>
[10:22:48.883] getGlobalsAndPackages() ... DONE
[10:22:48.883]    + additional globals found: [n=0] 
[10:22:48.883]    + additional namespaces needed: [n=0] 
[10:22:48.883]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.883]  - seeds: <none>
[10:22:48.884]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.884] getGlobalsAndPackages() ...
[10:22:48.884] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.884] Resolving globals: FALSE
[10:22:48.884] Tweak future expression to call with '...' arguments ...
[10:22:48.884] {
[10:22:48.884]     do.call(function(...) {
[10:22:48.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.884]             on.exit(options(oopts), add = TRUE)
[10:22:48.884]         }
[10:22:48.884]         {
[10:22:48.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.884]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.884]             })
[10:22:48.884]         }
[10:22:48.884]     }, args = future.call.arguments)
[10:22:48.884] }
[10:22:48.884] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.885] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.885] 
[10:22:48.885] getGlobalsAndPackages() ... DONE
[10:22:48.885] run() for ‘Future’ ...
[10:22:48.885] - state: ‘created’
[10:22:48.885] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.889] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.889]   - Field: ‘label’
[10:22:48.889]   - Field: ‘local’
[10:22:48.889]   - Field: ‘owner’
[10:22:48.889]   - Field: ‘envir’
[10:22:48.889]   - Field: ‘packages’
[10:22:48.889]   - Field: ‘gc’
[10:22:48.889]   - Field: ‘conditions’
[10:22:48.890]   - Field: ‘expr’
[10:22:48.890]   - Field: ‘uuid’
[10:22:48.890]   - Field: ‘seed’
[10:22:48.890]   - Field: ‘version’
[10:22:48.890]   - Field: ‘result’
[10:22:48.890]   - Field: ‘asynchronous’
[10:22:48.890]   - Field: ‘calls’
[10:22:48.890]   - Field: ‘globals’
[10:22:48.890]   - Field: ‘stdout’
[10:22:48.890]   - Field: ‘earlySignal’
[10:22:48.890]   - Field: ‘lazy’
[10:22:48.890]   - Field: ‘state’
[10:22:48.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.891] - Launch lazy future ...
[10:22:48.891] Packages needed by the future expression (n = 0): <none>
[10:22:48.891] Packages needed by future strategies (n = 0): <none>
[10:22:48.891] {
[10:22:48.891]     {
[10:22:48.891]         {
[10:22:48.891]             ...future.startTime <- base::Sys.time()
[10:22:48.891]             {
[10:22:48.891]                 {
[10:22:48.891]                   {
[10:22:48.891]                     base::local({
[10:22:48.891]                       has_future <- base::requireNamespace("future", 
[10:22:48.891]                         quietly = TRUE)
[10:22:48.891]                       if (has_future) {
[10:22:48.891]                         ns <- base::getNamespace("future")
[10:22:48.891]                         version <- ns[[".package"]][["version"]]
[10:22:48.891]                         if (is.null(version)) 
[10:22:48.891]                           version <- utils::packageVersion("future")
[10:22:48.891]                       }
[10:22:48.891]                       else {
[10:22:48.891]                         version <- NULL
[10:22:48.891]                       }
[10:22:48.891]                       if (!has_future || version < "1.8.0") {
[10:22:48.891]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.891]                           "", base::R.version$version.string), 
[10:22:48.891]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:48.891]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.891]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.891]                             "release", "version")], collapse = " "), 
[10:22:48.891]                           hostname = base::Sys.info()[["nodename"]])
[10:22:48.891]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.891]                           info)
[10:22:48.891]                         info <- base::paste(info, collapse = "; ")
[10:22:48.891]                         if (!has_future) {
[10:22:48.891]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.891]                             info)
[10:22:48.891]                         }
[10:22:48.891]                         else {
[10:22:48.891]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.891]                             info, version)
[10:22:48.891]                         }
[10:22:48.891]                         base::stop(msg)
[10:22:48.891]                       }
[10:22:48.891]                     })
[10:22:48.891]                   }
[10:22:48.891]                   options(future.plan = NULL)
[10:22:48.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.891]                 }
[10:22:48.891]                 ...future.workdir <- getwd()
[10:22:48.891]             }
[10:22:48.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.891]         }
[10:22:48.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.891]             base::names(...future.oldOptions))
[10:22:48.891]     }
[10:22:48.891]     if (FALSE) {
[10:22:48.891]     }
[10:22:48.891]     else {
[10:22:48.891]         if (TRUE) {
[10:22:48.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.891]                 open = "w")
[10:22:48.891]         }
[10:22:48.891]         else {
[10:22:48.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.891]         }
[10:22:48.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.891]             base::sink(type = "output", split = FALSE)
[10:22:48.891]             base::close(...future.stdout)
[10:22:48.891]         }, add = TRUE)
[10:22:48.891]     }
[10:22:48.891]     ...future.frame <- base::sys.nframe()
[10:22:48.891]     ...future.conditions <- base::list()
[10:22:48.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.891]     if (FALSE) {
[10:22:48.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.891]     }
[10:22:48.891]     ...future.result <- base::tryCatch({
[10:22:48.891]         base::withCallingHandlers({
[10:22:48.891]             ...future.value <- base::withVisible(base::local({
[10:22:48.891]                 do.call(function(...) {
[10:22:48.891]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.891]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.891]                     ...future.globals.maxSize)) {
[10:22:48.891]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.891]                     on.exit(options(oopts), add = TRUE)
[10:22:48.891]                   }
[10:22:48.891]                   {
[10:22:48.891]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.891]                       FUN = function(jj) {
[10:22:48.891]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.891]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.891]                       })
[10:22:48.891]                   }
[10:22:48.891]                 }, args = future.call.arguments)
[10:22:48.891]             }))
[10:22:48.891]             future::FutureResult(value = ...future.value$value, 
[10:22:48.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.891]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.891]                     ...future.globalenv.names))
[10:22:48.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.891]         }, condition = base::local({
[10:22:48.891]             c <- base::c
[10:22:48.891]             inherits <- base::inherits
[10:22:48.891]             invokeRestart <- base::invokeRestart
[10:22:48.891]             length <- base::length
[10:22:48.891]             list <- base::list
[10:22:48.891]             seq.int <- base::seq.int
[10:22:48.891]             signalCondition <- base::signalCondition
[10:22:48.891]             sys.calls <- base::sys.calls
[10:22:48.891]             `[[` <- base::`[[`
[10:22:48.891]             `+` <- base::`+`
[10:22:48.891]             `<<-` <- base::`<<-`
[10:22:48.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.891]                   3L)]
[10:22:48.891]             }
[10:22:48.891]             function(cond) {
[10:22:48.891]                 is_error <- inherits(cond, "error")
[10:22:48.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.891]                   NULL)
[10:22:48.891]                 if (is_error) {
[10:22:48.891]                   sessionInformation <- function() {
[10:22:48.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.891]                       search = base::search(), system = base::Sys.info())
[10:22:48.891]                   }
[10:22:48.891]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.891]                     cond$call), session = sessionInformation(), 
[10:22:48.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.891]                   signalCondition(cond)
[10:22:48.891]                 }
[10:22:48.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.891]                 "immediateCondition"))) {
[10:22:48.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.891]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.891]                   if (TRUE && !signal) {
[10:22:48.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.891]                     {
[10:22:48.891]                       inherits <- base::inherits
[10:22:48.891]                       invokeRestart <- base::invokeRestart
[10:22:48.891]                       is.null <- base::is.null
[10:22:48.891]                       muffled <- FALSE
[10:22:48.891]                       if (inherits(cond, "message")) {
[10:22:48.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.891]                         if (muffled) 
[10:22:48.891]                           invokeRestart("muffleMessage")
[10:22:48.891]                       }
[10:22:48.891]                       else if (inherits(cond, "warning")) {
[10:22:48.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.891]                         if (muffled) 
[10:22:48.891]                           invokeRestart("muffleWarning")
[10:22:48.891]                       }
[10:22:48.891]                       else if (inherits(cond, "condition")) {
[10:22:48.891]                         if (!is.null(pattern)) {
[10:22:48.891]                           computeRestarts <- base::computeRestarts
[10:22:48.891]                           grepl <- base::grepl
[10:22:48.891]                           restarts <- computeRestarts(cond)
[10:22:48.891]                           for (restart in restarts) {
[10:22:48.891]                             name <- restart$name
[10:22:48.891]                             if (is.null(name)) 
[10:22:48.891]                               next
[10:22:48.891]                             if (!grepl(pattern, name)) 
[10:22:48.891]                               next
[10:22:48.891]                             invokeRestart(restart)
[10:22:48.891]                             muffled <- TRUE
[10:22:48.891]                             break
[10:22:48.891]                           }
[10:22:48.891]                         }
[10:22:48.891]                       }
[10:22:48.891]                       invisible(muffled)
[10:22:48.891]                     }
[10:22:48.891]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.891]                   }
[10:22:48.891]                 }
[10:22:48.891]                 else {
[10:22:48.891]                   if (TRUE) {
[10:22:48.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.891]                     {
[10:22:48.891]                       inherits <- base::inherits
[10:22:48.891]                       invokeRestart <- base::invokeRestart
[10:22:48.891]                       is.null <- base::is.null
[10:22:48.891]                       muffled <- FALSE
[10:22:48.891]                       if (inherits(cond, "message")) {
[10:22:48.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.891]                         if (muffled) 
[10:22:48.891]                           invokeRestart("muffleMessage")
[10:22:48.891]                       }
[10:22:48.891]                       else if (inherits(cond, "warning")) {
[10:22:48.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.891]                         if (muffled) 
[10:22:48.891]                           invokeRestart("muffleWarning")
[10:22:48.891]                       }
[10:22:48.891]                       else if (inherits(cond, "condition")) {
[10:22:48.891]                         if (!is.null(pattern)) {
[10:22:48.891]                           computeRestarts <- base::computeRestarts
[10:22:48.891]                           grepl <- base::grepl
[10:22:48.891]                           restarts <- computeRestarts(cond)
[10:22:48.891]                           for (restart in restarts) {
[10:22:48.891]                             name <- restart$name
[10:22:48.891]                             if (is.null(name)) 
[10:22:48.891]                               next
[10:22:48.891]                             if (!grepl(pattern, name)) 
[10:22:48.891]                               next
[10:22:48.891]                             invokeRestart(restart)
[10:22:48.891]                             muffled <- TRUE
[10:22:48.891]                             break
[10:22:48.891]                           }
[10:22:48.891]                         }
[10:22:48.891]                       }
[10:22:48.891]                       invisible(muffled)
[10:22:48.891]                     }
[10:22:48.891]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.891]                   }
[10:22:48.891]                 }
[10:22:48.891]             }
[10:22:48.891]         }))
[10:22:48.891]     }, error = function(ex) {
[10:22:48.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.891]                 ...future.rng), started = ...future.startTime, 
[10:22:48.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.891]             version = "1.8"), class = "FutureResult")
[10:22:48.891]     }, finally = {
[10:22:48.891]         if (!identical(...future.workdir, getwd())) 
[10:22:48.891]             setwd(...future.workdir)
[10:22:48.891]         {
[10:22:48.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.891]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.891]             }
[10:22:48.891]             base::options(...future.oldOptions)
[10:22:48.891]             if (.Platform$OS.type == "windows") {
[10:22:48.891]                 old_names <- names(...future.oldEnvVars)
[10:22:48.891]                 envs <- base::Sys.getenv()
[10:22:48.891]                 names <- names(envs)
[10:22:48.891]                 common <- intersect(names, old_names)
[10:22:48.891]                 added <- setdiff(names, old_names)
[10:22:48.891]                 removed <- setdiff(old_names, names)
[10:22:48.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.891]                   envs[common]]
[10:22:48.891]                 NAMES <- toupper(changed)
[10:22:48.891]                 args <- list()
[10:22:48.891]                 for (kk in seq_along(NAMES)) {
[10:22:48.891]                   name <- changed[[kk]]
[10:22:48.891]                   NAME <- NAMES[[kk]]
[10:22:48.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.891]                     next
[10:22:48.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.891]                 }
[10:22:48.891]                 NAMES <- toupper(added)
[10:22:48.891]                 for (kk in seq_along(NAMES)) {
[10:22:48.891]                   name <- added[[kk]]
[10:22:48.891]                   NAME <- NAMES[[kk]]
[10:22:48.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.891]                     next
[10:22:48.891]                   args[[name]] <- ""
[10:22:48.891]                 }
[10:22:48.891]                 NAMES <- toupper(removed)
[10:22:48.891]                 for (kk in seq_along(NAMES)) {
[10:22:48.891]                   name <- removed[[kk]]
[10:22:48.891]                   NAME <- NAMES[[kk]]
[10:22:48.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.891]                     next
[10:22:48.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.891]                 }
[10:22:48.891]                 if (length(args) > 0) 
[10:22:48.891]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.891]             }
[10:22:48.891]             else {
[10:22:48.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.891]             }
[10:22:48.891]             {
[10:22:48.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.891]                   0L) {
[10:22:48.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.891]                   base::options(opts)
[10:22:48.891]                 }
[10:22:48.891]                 {
[10:22:48.891]                   {
[10:22:48.891]                     NULL
[10:22:48.891]                     RNGkind("Mersenne-Twister")
[10:22:48.891]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.891]                       inherits = FALSE)
[10:22:48.891]                   }
[10:22:48.891]                   options(future.plan = NULL)
[10:22:48.891]                   if (is.na(NA_character_)) 
[10:22:48.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.891]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:48.891]                     envir = parent.frame()) 
[10:22:48.891]                   {
[10:22:48.891]                     default_workers <- missing(workers)
[10:22:48.891]                     if (is.function(workers)) 
[10:22:48.891]                       workers <- workers()
[10:22:48.891]                     workers <- structure(as.integer(workers), 
[10:22:48.891]                       class = class(workers))
[10:22:48.891]                     stop_if_not(is.finite(workers), workers >= 
[10:22:48.891]                       1L)
[10:22:48.891]                     if ((workers == 1L && !inherits(workers, 
[10:22:48.891]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:48.891]                       if (default_workers) 
[10:22:48.891]                         supportsMulticore(warn = TRUE)
[10:22:48.891]                       return(sequential(..., envir = envir))
[10:22:48.891]                     }
[10:22:48.891]                     oopts <- options(mc.cores = workers)
[10:22:48.891]                     on.exit(options(oopts))
[10:22:48.891]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:48.891]                       envir = envir)
[10:22:48.891]                     if (!future$lazy) 
[10:22:48.891]                       future <- run(future)
[10:22:48.891]                     invisible(future)
[10:22:48.891]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.891]                 }
[10:22:48.891]             }
[10:22:48.891]         }
[10:22:48.891]     })
[10:22:48.891]     if (TRUE) {
[10:22:48.891]         base::sink(type = "output", split = FALSE)
[10:22:48.891]         if (TRUE) {
[10:22:48.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.891]         }
[10:22:48.891]         else {
[10:22:48.891]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.891]         }
[10:22:48.891]         base::close(...future.stdout)
[10:22:48.891]         ...future.stdout <- NULL
[10:22:48.891]     }
[10:22:48.891]     ...future.result$conditions <- ...future.conditions
[10:22:48.891]     ...future.result$finished <- base::Sys.time()
[10:22:48.891]     ...future.result
[10:22:48.891] }
[10:22:48.893] assign_globals() ...
[10:22:48.894] List of 5
[10:22:48.894]  $ ...future.FUN            :function (object, ...)  
[10:22:48.894]  $ future.call.arguments    :List of 1
[10:22:48.894]   ..$ digits: int 2
[10:22:48.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.894]  $ ...future.elements_ii    :List of 6
[10:22:48.894]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:22:48.894]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:22:48.894]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:22:48.894]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:22:48.894]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:22:48.894]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:22:48.894]  $ ...future.seeds_ii       : NULL
[10:22:48.894]  $ ...future.globals.maxSize: NULL
[10:22:48.894]  - attr(*, "where")=List of 5
[10:22:48.894]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.894]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.894]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.894]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.894]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.894]  - attr(*, "resolved")= logi FALSE
[10:22:48.894]  - attr(*, "total_size")= num 1296
[10:22:48.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.894]  - attr(*, "already-done")= logi TRUE
[10:22:48.900] - copied ‘...future.FUN’ to environment
[10:22:48.901] - copied ‘future.call.arguments’ to environment
[10:22:48.901] - copied ‘...future.elements_ii’ to environment
[10:22:48.901] - copied ‘...future.seeds_ii’ to environment
[10:22:48.901] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.901] assign_globals() ... done
[10:22:48.901] plan(): Setting new future strategy stack:
[10:22:48.901] List of future strategies:
[10:22:48.901] 1. sequential:
[10:22:48.901]    - args: function (..., envir = parent.frame())
[10:22:48.901]    - tweaked: FALSE
[10:22:48.901]    - call: NULL
[10:22:48.902] plan(): nbrOfWorkers() = 1
[10:22:48.903] plan(): Setting new future strategy stack:
[10:22:48.903] List of future strategies:
[10:22:48.903] 1. multicore:
[10:22:48.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:48.903]    - tweaked: FALSE
[10:22:48.903]    - call: plan(strategy)
[10:22:48.906] plan(): nbrOfWorkers() = 1
[10:22:48.907] SequentialFuture started (and completed)
[10:22:48.907] - Launch lazy future ... done
[10:22:48.907] run() for ‘SequentialFuture’ ... done
[10:22:48.907] Created future:
[10:22:48.907] SequentialFuture:
[10:22:48.907] Label: ‘future_by-1’
[10:22:48.907] Expression:
[10:22:48.907] {
[10:22:48.907]     do.call(function(...) {
[10:22:48.907]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.907]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.907]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.907]             on.exit(options(oopts), add = TRUE)
[10:22:48.907]         }
[10:22:48.907]         {
[10:22:48.907]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.907]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.907]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.907]             })
[10:22:48.907]         }
[10:22:48.907]     }, args = future.call.arguments)
[10:22:48.907] }
[10:22:48.907] Lazy evaluation: FALSE
[10:22:48.907] Asynchronous evaluation: FALSE
[10:22:48.907] Local evaluation: TRUE
[10:22:48.907] Environment: R_GlobalEnv
[10:22:48.907] Capture standard output: TRUE
[10:22:48.907] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.907] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.907] Packages: <none>
[10:22:48.907] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.907] Resolved: TRUE
[10:22:48.907] Value: 5.48 KiB of class ‘list’
[10:22:48.907] Early signaling: FALSE
[10:22:48.907] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.907] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.908] Chunk #1 of 1 ... DONE
[10:22:48.908] Launching 1 futures (chunks) ... DONE
[10:22:48.908] Resolving 1 futures (chunks) ...
[10:22:48.908] resolve() on list ...
[10:22:48.908]  recursive: 0
[10:22:48.909]  length: 1
[10:22:48.909] 
[10:22:48.909] resolved() for ‘SequentialFuture’ ...
[10:22:48.909] - state: ‘finished’
[10:22:48.909] - run: TRUE
[10:22:48.909] - result: ‘FutureResult’
[10:22:48.909] resolved() for ‘SequentialFuture’ ... done
[10:22:48.909] Future #1
[10:22:48.909] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.909] - nx: 1
[10:22:48.910] - relay: TRUE
[10:22:48.910] - stdout: TRUE
[10:22:48.910] - signal: TRUE
[10:22:48.910] - resignal: FALSE
[10:22:48.910] - force: TRUE
[10:22:48.910] - relayed: [n=1] FALSE
[10:22:48.910] - queued futures: [n=1] FALSE
[10:22:48.910]  - until=1
[10:22:48.910]  - relaying element #1
[10:22:48.910] - relayed: [n=1] TRUE
[10:22:48.910] - queued futures: [n=1] TRUE
[10:22:48.911] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.911]  length: 0 (resolved future 1)
[10:22:48.911] Relaying remaining futures
[10:22:48.911] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.911] - nx: 1
[10:22:48.911] - relay: TRUE
[10:22:48.911] - stdout: TRUE
[10:22:48.911] - signal: TRUE
[10:22:48.911] - resignal: FALSE
[10:22:48.911] - force: TRUE
[10:22:48.911] - relayed: [n=1] TRUE
[10:22:48.911] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.912] - relayed: [n=1] TRUE
[10:22:48.912] - queued futures: [n=1] TRUE
[10:22:48.912] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.912] resolve() on list ... DONE
[10:22:48.912]  - Number of value chunks collected: 1
[10:22:48.912] Resolving 1 futures (chunks) ... DONE
[10:22:48.912] Reducing values from 1 chunks ...
[10:22:48.912]  - Number of values collected after concatenation: 6
[10:22:48.912]  - Number of values expected: 6
[10:22:48.912] Reducing values from 1 chunks ... DONE
[10:22:48.912] future_lapply() ... DONE
[10:22:48.913] future_by_internal() ... DONE
[10:22:48.939] future_by_internal() ...
[10:22:48.940] future_lapply() ...
[10:22:48.945] Number of chunks: 1
[10:22:48.945] getGlobalsAndPackagesXApply() ...
[10:22:48.945]  - future.globals: TRUE
[10:22:48.945] getGlobalsAndPackages() ...
[10:22:48.945] Searching for globals...
[10:22:48.947] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:48.947] Searching for globals ... DONE
[10:22:48.947] Resolving globals: FALSE
[10:22:48.947] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:22:48.948] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:22:48.948] - globals: [1] ‘FUN’
[10:22:48.948] - packages: [1] ‘stats’
[10:22:48.948] getGlobalsAndPackages() ... DONE
[10:22:48.948]  - globals found/used: [n=1] ‘FUN’
[10:22:48.948]  - needed namespaces: [n=1] ‘stats’
[10:22:48.948] Finding globals ... DONE
[10:22:48.948]  - use_args: TRUE
[10:22:48.949]  - Getting '...' globals ...
[10:22:48.949] resolve() on list ...
[10:22:48.949]  recursive: 0
[10:22:48.949]  length: 1
[10:22:48.949]  elements: ‘...’
[10:22:48.949]  length: 0 (resolved future 1)
[10:22:48.949] resolve() on list ... DONE
[10:22:48.949]    - '...' content: [n=1] ‘singular.ok’
[10:22:48.950] List of 1
[10:22:48.950]  $ ...:List of 1
[10:22:48.950]   ..$ singular.ok: logi FALSE
[10:22:48.950]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.950]  - attr(*, "where")=List of 1
[10:22:48.950]   ..$ ...:<environment: 0x55f63a2ada20> 
[10:22:48.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.950]  - attr(*, "resolved")= logi TRUE
[10:22:48.950]  - attr(*, "total_size")= num NA
[10:22:48.953]  - Getting '...' globals ... DONE
[10:22:48.953] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:48.953] List of 2
[10:22:48.953]  $ ...future.FUN:function (x, ...)  
[10:22:48.953]  $ ...          :List of 1
[10:22:48.953]   ..$ singular.ok: logi FALSE
[10:22:48.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.953]  - attr(*, "where")=List of 2
[10:22:48.953]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:48.953]   ..$ ...          :<environment: 0x55f63a2ada20> 
[10:22:48.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.953]  - attr(*, "resolved")= logi FALSE
[10:22:48.953]  - attr(*, "total_size")= num 5384
[10:22:48.956] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:48.956] getGlobalsAndPackagesXApply() ... DONE
[10:22:48.956] Number of futures (= number of chunks): 1
[10:22:48.957] Launching 1 futures (chunks) ...
[10:22:48.957] Chunk #1 of 1 ...
[10:22:48.957]  - Finding globals in 'X' for chunk #1 ...
[10:22:48.957] getGlobalsAndPackages() ...
[10:22:48.957] Searching for globals...
[10:22:48.957] 
[10:22:48.958] Searching for globals ... DONE
[10:22:48.958] - globals: [0] <none>
[10:22:48.958] getGlobalsAndPackages() ... DONE
[10:22:48.958]    + additional globals found: [n=0] 
[10:22:48.958]    + additional namespaces needed: [n=0] 
[10:22:48.958]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:48.958]  - seeds: <none>
[10:22:48.958]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.958] getGlobalsAndPackages() ...
[10:22:48.958] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.958] Resolving globals: FALSE
[10:22:48.959] Tweak future expression to call with '...' arguments ...
[10:22:48.959] {
[10:22:48.959]     do.call(function(...) {
[10:22:48.959]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.959]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.959]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.959]             on.exit(options(oopts), add = TRUE)
[10:22:48.959]         }
[10:22:48.959]         {
[10:22:48.959]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.959]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.959]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.959]             })
[10:22:48.959]         }
[10:22:48.959]     }, args = future.call.arguments)
[10:22:48.959] }
[10:22:48.959] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.959] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.959] 
[10:22:48.959] getGlobalsAndPackages() ... DONE
[10:22:48.960] run() for ‘Future’ ...
[10:22:48.960] - state: ‘created’
[10:22:48.960] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:48.964]   - Field: ‘label’
[10:22:48.964]   - Field: ‘local’
[10:22:48.964]   - Field: ‘owner’
[10:22:48.964]   - Field: ‘envir’
[10:22:48.964]   - Field: ‘packages’
[10:22:48.964]   - Field: ‘gc’
[10:22:48.965]   - Field: ‘conditions’
[10:22:48.965]   - Field: ‘expr’
[10:22:48.965]   - Field: ‘uuid’
[10:22:48.965]   - Field: ‘seed’
[10:22:48.965]   - Field: ‘version’
[10:22:48.965]   - Field: ‘result’
[10:22:48.965]   - Field: ‘asynchronous’
[10:22:48.965]   - Field: ‘calls’
[10:22:48.967]   - Field: ‘globals’
[10:22:48.967]   - Field: ‘stdout’
[10:22:48.967]   - Field: ‘earlySignal’
[10:22:48.967]   - Field: ‘lazy’
[10:22:48.967]   - Field: ‘state’
[10:22:48.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:48.967] - Launch lazy future ...
[10:22:48.968] Packages needed by the future expression (n = 1): ‘stats’
[10:22:48.968] Packages needed by future strategies (n = 0): <none>
[10:22:48.968] {
[10:22:48.968]     {
[10:22:48.968]         {
[10:22:48.968]             ...future.startTime <- base::Sys.time()
[10:22:48.968]             {
[10:22:48.968]                 {
[10:22:48.968]                   {
[10:22:48.968]                     {
[10:22:48.968]                       base::local({
[10:22:48.968]                         has_future <- base::requireNamespace("future", 
[10:22:48.968]                           quietly = TRUE)
[10:22:48.968]                         if (has_future) {
[10:22:48.968]                           ns <- base::getNamespace("future")
[10:22:48.968]                           version <- ns[[".package"]][["version"]]
[10:22:48.968]                           if (is.null(version)) 
[10:22:48.968]                             version <- utils::packageVersion("future")
[10:22:48.968]                         }
[10:22:48.968]                         else {
[10:22:48.968]                           version <- NULL
[10:22:48.968]                         }
[10:22:48.968]                         if (!has_future || version < "1.8.0") {
[10:22:48.968]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.968]                             "", base::R.version$version.string), 
[10:22:48.968]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.968]                               "release", "version")], collapse = " "), 
[10:22:48.968]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.968]                             info)
[10:22:48.968]                           info <- base::paste(info, collapse = "; ")
[10:22:48.968]                           if (!has_future) {
[10:22:48.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.968]                               info)
[10:22:48.968]                           }
[10:22:48.968]                           else {
[10:22:48.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.968]                               info, version)
[10:22:48.968]                           }
[10:22:48.968]                           base::stop(msg)
[10:22:48.968]                         }
[10:22:48.968]                       })
[10:22:48.968]                     }
[10:22:48.968]                     base::local({
[10:22:48.968]                       for (pkg in "stats") {
[10:22:48.968]                         base::loadNamespace(pkg)
[10:22:48.968]                         base::library(pkg, character.only = TRUE)
[10:22:48.968]                       }
[10:22:48.968]                     })
[10:22:48.968]                   }
[10:22:48.968]                   options(future.plan = NULL)
[10:22:48.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.968]                 }
[10:22:48.968]                 ...future.workdir <- getwd()
[10:22:48.968]             }
[10:22:48.968]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.968]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.968]         }
[10:22:48.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.968]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.968]             base::names(...future.oldOptions))
[10:22:48.968]     }
[10:22:48.968]     if (FALSE) {
[10:22:48.968]     }
[10:22:48.968]     else {
[10:22:48.968]         if (TRUE) {
[10:22:48.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.968]                 open = "w")
[10:22:48.968]         }
[10:22:48.968]         else {
[10:22:48.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.968]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.968]         }
[10:22:48.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.968]             base::sink(type = "output", split = FALSE)
[10:22:48.968]             base::close(...future.stdout)
[10:22:48.968]         }, add = TRUE)
[10:22:48.968]     }
[10:22:48.968]     ...future.frame <- base::sys.nframe()
[10:22:48.968]     ...future.conditions <- base::list()
[10:22:48.968]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.968]     if (FALSE) {
[10:22:48.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.968]     }
[10:22:48.968]     ...future.result <- base::tryCatch({
[10:22:48.968]         base::withCallingHandlers({
[10:22:48.968]             ...future.value <- base::withVisible(base::local({
[10:22:48.968]                 do.call(function(...) {
[10:22:48.968]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.968]                   if (!identical(...future.globals.maxSize.org, 
[10:22:48.968]                     ...future.globals.maxSize)) {
[10:22:48.968]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.968]                     on.exit(options(oopts), add = TRUE)
[10:22:48.968]                   }
[10:22:48.968]                   {
[10:22:48.968]                     lapply(seq_along(...future.elements_ii), 
[10:22:48.968]                       FUN = function(jj) {
[10:22:48.968]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.968]                         ...future.FUN(...future.X_jj, ...)
[10:22:48.968]                       })
[10:22:48.968]                   }
[10:22:48.968]                 }, args = future.call.arguments)
[10:22:48.968]             }))
[10:22:48.968]             future::FutureResult(value = ...future.value$value, 
[10:22:48.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.968]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.968]                     ...future.globalenv.names))
[10:22:48.968]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.968]         }, condition = base::local({
[10:22:48.968]             c <- base::c
[10:22:48.968]             inherits <- base::inherits
[10:22:48.968]             invokeRestart <- base::invokeRestart
[10:22:48.968]             length <- base::length
[10:22:48.968]             list <- base::list
[10:22:48.968]             seq.int <- base::seq.int
[10:22:48.968]             signalCondition <- base::signalCondition
[10:22:48.968]             sys.calls <- base::sys.calls
[10:22:48.968]             `[[` <- base::`[[`
[10:22:48.968]             `+` <- base::`+`
[10:22:48.968]             `<<-` <- base::`<<-`
[10:22:48.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.968]                   3L)]
[10:22:48.968]             }
[10:22:48.968]             function(cond) {
[10:22:48.968]                 is_error <- inherits(cond, "error")
[10:22:48.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.968]                   NULL)
[10:22:48.968]                 if (is_error) {
[10:22:48.968]                   sessionInformation <- function() {
[10:22:48.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.968]                       search = base::search(), system = base::Sys.info())
[10:22:48.968]                   }
[10:22:48.968]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.968]                     cond$call), session = sessionInformation(), 
[10:22:48.968]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.968]                   signalCondition(cond)
[10:22:48.968]                 }
[10:22:48.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.968]                 "immediateCondition"))) {
[10:22:48.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.968]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.968]                   if (TRUE && !signal) {
[10:22:48.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.968]                     {
[10:22:48.968]                       inherits <- base::inherits
[10:22:48.968]                       invokeRestart <- base::invokeRestart
[10:22:48.968]                       is.null <- base::is.null
[10:22:48.968]                       muffled <- FALSE
[10:22:48.968]                       if (inherits(cond, "message")) {
[10:22:48.968]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.968]                         if (muffled) 
[10:22:48.968]                           invokeRestart("muffleMessage")
[10:22:48.968]                       }
[10:22:48.968]                       else if (inherits(cond, "warning")) {
[10:22:48.968]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.968]                         if (muffled) 
[10:22:48.968]                           invokeRestart("muffleWarning")
[10:22:48.968]                       }
[10:22:48.968]                       else if (inherits(cond, "condition")) {
[10:22:48.968]                         if (!is.null(pattern)) {
[10:22:48.968]                           computeRestarts <- base::computeRestarts
[10:22:48.968]                           grepl <- base::grepl
[10:22:48.968]                           restarts <- computeRestarts(cond)
[10:22:48.968]                           for (restart in restarts) {
[10:22:48.968]                             name <- restart$name
[10:22:48.968]                             if (is.null(name)) 
[10:22:48.968]                               next
[10:22:48.968]                             if (!grepl(pattern, name)) 
[10:22:48.968]                               next
[10:22:48.968]                             invokeRestart(restart)
[10:22:48.968]                             muffled <- TRUE
[10:22:48.968]                             break
[10:22:48.968]                           }
[10:22:48.968]                         }
[10:22:48.968]                       }
[10:22:48.968]                       invisible(muffled)
[10:22:48.968]                     }
[10:22:48.968]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.968]                   }
[10:22:48.968]                 }
[10:22:48.968]                 else {
[10:22:48.968]                   if (TRUE) {
[10:22:48.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.968]                     {
[10:22:48.968]                       inherits <- base::inherits
[10:22:48.968]                       invokeRestart <- base::invokeRestart
[10:22:48.968]                       is.null <- base::is.null
[10:22:48.968]                       muffled <- FALSE
[10:22:48.968]                       if (inherits(cond, "message")) {
[10:22:48.968]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.968]                         if (muffled) 
[10:22:48.968]                           invokeRestart("muffleMessage")
[10:22:48.968]                       }
[10:22:48.968]                       else if (inherits(cond, "warning")) {
[10:22:48.968]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.968]                         if (muffled) 
[10:22:48.968]                           invokeRestart("muffleWarning")
[10:22:48.968]                       }
[10:22:48.968]                       else if (inherits(cond, "condition")) {
[10:22:48.968]                         if (!is.null(pattern)) {
[10:22:48.968]                           computeRestarts <- base::computeRestarts
[10:22:48.968]                           grepl <- base::grepl
[10:22:48.968]                           restarts <- computeRestarts(cond)
[10:22:48.968]                           for (restart in restarts) {
[10:22:48.968]                             name <- restart$name
[10:22:48.968]                             if (is.null(name)) 
[10:22:48.968]                               next
[10:22:48.968]                             if (!grepl(pattern, name)) 
[10:22:48.968]                               next
[10:22:48.968]                             invokeRestart(restart)
[10:22:48.968]                             muffled <- TRUE
[10:22:48.968]                             break
[10:22:48.968]                           }
[10:22:48.968]                         }
[10:22:48.968]                       }
[10:22:48.968]                       invisible(muffled)
[10:22:48.968]                     }
[10:22:48.968]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.968]                   }
[10:22:48.968]                 }
[10:22:48.968]             }
[10:22:48.968]         }))
[10:22:48.968]     }, error = function(ex) {
[10:22:48.968]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.968]                 ...future.rng), started = ...future.startTime, 
[10:22:48.968]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.968]             version = "1.8"), class = "FutureResult")
[10:22:48.968]     }, finally = {
[10:22:48.968]         if (!identical(...future.workdir, getwd())) 
[10:22:48.968]             setwd(...future.workdir)
[10:22:48.968]         {
[10:22:48.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.968]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.968]             }
[10:22:48.968]             base::options(...future.oldOptions)
[10:22:48.968]             if (.Platform$OS.type == "windows") {
[10:22:48.968]                 old_names <- names(...future.oldEnvVars)
[10:22:48.968]                 envs <- base::Sys.getenv()
[10:22:48.968]                 names <- names(envs)
[10:22:48.968]                 common <- intersect(names, old_names)
[10:22:48.968]                 added <- setdiff(names, old_names)
[10:22:48.968]                 removed <- setdiff(old_names, names)
[10:22:48.968]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.968]                   envs[common]]
[10:22:48.968]                 NAMES <- toupper(changed)
[10:22:48.968]                 args <- list()
[10:22:48.968]                 for (kk in seq_along(NAMES)) {
[10:22:48.968]                   name <- changed[[kk]]
[10:22:48.968]                   NAME <- NAMES[[kk]]
[10:22:48.968]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.968]                     next
[10:22:48.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.968]                 }
[10:22:48.968]                 NAMES <- toupper(added)
[10:22:48.968]                 for (kk in seq_along(NAMES)) {
[10:22:48.968]                   name <- added[[kk]]
[10:22:48.968]                   NAME <- NAMES[[kk]]
[10:22:48.968]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.968]                     next
[10:22:48.968]                   args[[name]] <- ""
[10:22:48.968]                 }
[10:22:48.968]                 NAMES <- toupper(removed)
[10:22:48.968]                 for (kk in seq_along(NAMES)) {
[10:22:48.968]                   name <- removed[[kk]]
[10:22:48.968]                   NAME <- NAMES[[kk]]
[10:22:48.968]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.968]                     next
[10:22:48.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.968]                 }
[10:22:48.968]                 if (length(args) > 0) 
[10:22:48.968]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.968]             }
[10:22:48.968]             else {
[10:22:48.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.968]             }
[10:22:48.968]             {
[10:22:48.968]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.968]                   0L) {
[10:22:48.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.968]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.968]                   base::options(opts)
[10:22:48.968]                 }
[10:22:48.968]                 {
[10:22:48.968]                   {
[10:22:48.968]                     NULL
[10:22:48.968]                     RNGkind("Mersenne-Twister")
[10:22:48.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:48.968]                       inherits = FALSE)
[10:22:48.968]                   }
[10:22:48.968]                   options(future.plan = NULL)
[10:22:48.968]                   if (is.na(NA_character_)) 
[10:22:48.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.968]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:48.968]                     envir = parent.frame()) 
[10:22:48.968]                   {
[10:22:48.968]                     default_workers <- missing(workers)
[10:22:48.968]                     if (is.function(workers)) 
[10:22:48.968]                       workers <- workers()
[10:22:48.968]                     workers <- structure(as.integer(workers), 
[10:22:48.968]                       class = class(workers))
[10:22:48.968]                     stop_if_not(is.finite(workers), workers >= 
[10:22:48.968]                       1L)
[10:22:48.968]                     if ((workers == 1L && !inherits(workers, 
[10:22:48.968]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:48.968]                       if (default_workers) 
[10:22:48.968]                         supportsMulticore(warn = TRUE)
[10:22:48.968]                       return(sequential(..., envir = envir))
[10:22:48.968]                     }
[10:22:48.968]                     oopts <- options(mc.cores = workers)
[10:22:48.968]                     on.exit(options(oopts))
[10:22:48.968]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:48.968]                       envir = envir)
[10:22:48.968]                     if (!future$lazy) 
[10:22:48.968]                       future <- run(future)
[10:22:48.968]                     invisible(future)
[10:22:48.968]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.968]                 }
[10:22:48.968]             }
[10:22:48.968]         }
[10:22:48.968]     })
[10:22:48.968]     if (TRUE) {
[10:22:48.968]         base::sink(type = "output", split = FALSE)
[10:22:48.968]         if (TRUE) {
[10:22:48.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.968]         }
[10:22:48.968]         else {
[10:22:48.968]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.968]         }
[10:22:48.968]         base::close(...future.stdout)
[10:22:48.968]         ...future.stdout <- NULL
[10:22:48.968]     }
[10:22:48.968]     ...future.result$conditions <- ...future.conditions
[10:22:48.968]     ...future.result$finished <- base::Sys.time()
[10:22:48.968]     ...future.result
[10:22:48.968] }
[10:22:48.970] assign_globals() ...
[10:22:48.970] List of 5
[10:22:48.970]  $ ...future.FUN            :function (x, ...)  
[10:22:48.970]  $ future.call.arguments    :List of 1
[10:22:48.970]   ..$ singular.ok: logi FALSE
[10:22:48.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:48.970]  $ ...future.elements_ii    :List of 3
[10:22:48.970]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.970]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:48.970]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.970]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:48.970]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.970]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:48.970]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.970]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:48.970]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:48.970]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:48.970]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:48.970]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:48.970]  $ ...future.seeds_ii       : NULL
[10:22:48.970]  $ ...future.globals.maxSize: NULL
[10:22:48.970]  - attr(*, "where")=List of 5
[10:22:48.970]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:48.970]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:48.970]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:48.970]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:48.970]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:48.970]  - attr(*, "resolved")= logi FALSE
[10:22:48.970]  - attr(*, "total_size")= num 5384
[10:22:48.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:48.970]  - attr(*, "already-done")= logi TRUE
[10:22:48.979] - reassign environment for ‘...future.FUN’
[10:22:48.980] - copied ‘...future.FUN’ to environment
[10:22:48.980] - copied ‘future.call.arguments’ to environment
[10:22:48.980] - copied ‘...future.elements_ii’ to environment
[10:22:48.980] - copied ‘...future.seeds_ii’ to environment
[10:22:48.980] - copied ‘...future.globals.maxSize’ to environment
[10:22:48.980] assign_globals() ... done
[10:22:48.980] plan(): Setting new future strategy stack:
[10:22:48.980] List of future strategies:
[10:22:48.980] 1. sequential:
[10:22:48.980]    - args: function (..., envir = parent.frame())
[10:22:48.980]    - tweaked: FALSE
[10:22:48.980]    - call: NULL
[10:22:48.981] plan(): nbrOfWorkers() = 1
[10:22:48.984] plan(): Setting new future strategy stack:
[10:22:48.984] List of future strategies:
[10:22:48.984] 1. multicore:
[10:22:48.984]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:48.984]    - tweaked: FALSE
[10:22:48.984]    - call: plan(strategy)
[10:22:48.987] plan(): nbrOfWorkers() = 1
[10:22:48.987] SequentialFuture started (and completed)
[10:22:48.988] - Launch lazy future ... done
[10:22:48.988] run() for ‘SequentialFuture’ ... done
[10:22:48.988] Created future:
[10:22:48.988] SequentialFuture:
[10:22:48.988] Label: ‘future_by-1’
[10:22:48.988] Expression:
[10:22:48.988] {
[10:22:48.988]     do.call(function(...) {
[10:22:48.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.988]             on.exit(options(oopts), add = TRUE)
[10:22:48.988]         }
[10:22:48.988]         {
[10:22:48.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.988]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.988]             })
[10:22:48.988]         }
[10:22:48.988]     }, args = future.call.arguments)
[10:22:48.988] }
[10:22:48.988] Lazy evaluation: FALSE
[10:22:48.988] Asynchronous evaluation: FALSE
[10:22:48.988] Local evaluation: TRUE
[10:22:48.988] Environment: R_GlobalEnv
[10:22:48.988] Capture standard output: TRUE
[10:22:48.988] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:48.988] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:48.988] Packages: 1 packages (‘stats’)
[10:22:48.988] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:48.988] Resolved: TRUE
[10:22:48.988] Value: 26.06 KiB of class ‘list’
[10:22:48.988] Early signaling: FALSE
[10:22:48.988] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:48.988] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:48.989] Chunk #1 of 1 ... DONE
[10:22:48.989] Launching 1 futures (chunks) ... DONE
[10:22:48.989] Resolving 1 futures (chunks) ...
[10:22:48.990] resolve() on list ...
[10:22:48.990]  recursive: 0
[10:22:48.990]  length: 1
[10:22:48.990] 
[10:22:48.990] resolved() for ‘SequentialFuture’ ...
[10:22:48.990] - state: ‘finished’
[10:22:48.990] - run: TRUE
[10:22:48.990] - result: ‘FutureResult’
[10:22:48.990] resolved() for ‘SequentialFuture’ ... done
[10:22:48.990] Future #1
[10:22:48.991] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:48.991] - nx: 1
[10:22:48.991] - relay: TRUE
[10:22:48.991] - stdout: TRUE
[10:22:48.991] - signal: TRUE
[10:22:48.991] - resignal: FALSE
[10:22:48.991] - force: TRUE
[10:22:48.991] - relayed: [n=1] FALSE
[10:22:48.991] - queued futures: [n=1] FALSE
[10:22:48.993]  - until=1
[10:22:48.993]  - relaying element #1
[10:22:48.993] - relayed: [n=1] TRUE
[10:22:48.993] - queued futures: [n=1] TRUE
[10:22:48.993] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:48.993]  length: 0 (resolved future 1)
[10:22:48.993] Relaying remaining futures
[10:22:48.994] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.994] - nx: 1
[10:22:48.994] - relay: TRUE
[10:22:48.994] - stdout: TRUE
[10:22:48.994] - signal: TRUE
[10:22:48.994] - resignal: FALSE
[10:22:48.994] - force: TRUE
[10:22:48.994] - relayed: [n=1] TRUE
[10:22:48.994] - queued futures: [n=1] TRUE
 - flush all
[10:22:48.994] - relayed: [n=1] TRUE
[10:22:48.994] - queued futures: [n=1] TRUE
[10:22:48.995] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.995] resolve() on list ... DONE
[10:22:48.995]  - Number of value chunks collected: 1
[10:22:48.995] Resolving 1 futures (chunks) ... DONE
[10:22:48.995] Reducing values from 1 chunks ...
[10:22:48.995]  - Number of values collected after concatenation: 3
[10:22:48.995]  - Number of values expected: 3
[10:22:48.995] Reducing values from 1 chunks ... DONE
[10:22:48.995] future_lapply() ... DONE
[10:22:48.995] future_by_internal() ... DONE
[10:22:48.999] future_by_internal() ...
[10:22:49.000] future_lapply() ...
[10:22:49.004] Number of chunks: 1
[10:22:49.004] getGlobalsAndPackagesXApply() ...
[10:22:49.004]  - future.globals: TRUE
[10:22:49.004] getGlobalsAndPackages() ...
[10:22:49.004] Searching for globals...
[10:22:49.006] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:49.006] Searching for globals ... DONE
[10:22:49.006] Resolving globals: FALSE
[10:22:49.006] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:22:49.007] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:22:49.007] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:49.007] - packages: [1] ‘stats’
[10:22:49.007] getGlobalsAndPackages() ... DONE
[10:22:49.007]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:49.007]  - needed namespaces: [n=1] ‘stats’
[10:22:49.007] Finding globals ... DONE
[10:22:49.007]  - use_args: TRUE
[10:22:49.008]  - Getting '...' globals ...
[10:22:49.008] resolve() on list ...
[10:22:49.008]  recursive: 0
[10:22:49.008]  length: 1
[10:22:49.008]  elements: ‘...’
[10:22:49.008]  length: 0 (resolved future 1)
[10:22:49.008] resolve() on list ... DONE
[10:22:49.008]    - '...' content: [n=0] 
[10:22:49.008] List of 1
[10:22:49.008]  $ ...: list()
[10:22:49.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.008]  - attr(*, "where")=List of 1
[10:22:49.008]   ..$ ...:<environment: 0x55f6381c77b8> 
[10:22:49.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.008]  - attr(*, "resolved")= logi TRUE
[10:22:49.008]  - attr(*, "total_size")= num NA
[10:22:49.011]  - Getting '...' globals ... DONE
[10:22:49.011] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:22:49.011] List of 4
[10:22:49.011]  $ ...future.FUN:function (x)  
[10:22:49.011]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:49.011]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.011]  $ ...          : list()
[10:22:49.011]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.011]  - attr(*, "where")=List of 4
[10:22:49.011]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.011]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:22:49.011]   ..$ wool         :<environment: R_EmptyEnv> 
[10:22:49.011]   ..$ ...          :<environment: 0x55f6381c77b8> 
[10:22:49.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.011]  - attr(*, "resolved")= logi FALSE
[10:22:49.011]  - attr(*, "total_size")= num 2320
[10:22:49.016] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:49.016] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.016] Number of futures (= number of chunks): 1
[10:22:49.017] Launching 1 futures (chunks) ...
[10:22:49.017] Chunk #1 of 1 ...
[10:22:49.017]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.017] getGlobalsAndPackages() ...
[10:22:49.017] Searching for globals...
[10:22:49.017] 
[10:22:49.017] Searching for globals ... DONE
[10:22:49.018] - globals: [0] <none>
[10:22:49.018] getGlobalsAndPackages() ... DONE
[10:22:49.018]    + additional globals found: [n=0] 
[10:22:49.018]    + additional namespaces needed: [n=0] 
[10:22:49.018]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.018]  - seeds: <none>
[10:22:49.018]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.018] getGlobalsAndPackages() ...
[10:22:49.018] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.018] Resolving globals: FALSE
[10:22:49.019] Tweak future expression to call with '...' arguments ...
[10:22:49.019] {
[10:22:49.019]     do.call(function(...) {
[10:22:49.019]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.019]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.019]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.019]             on.exit(options(oopts), add = TRUE)
[10:22:49.019]         }
[10:22:49.019]         {
[10:22:49.019]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.019]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.019]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.019]             })
[10:22:49.019]         }
[10:22:49.019]     }, args = future.call.arguments)
[10:22:49.019] }
[10:22:49.019] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.019] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.019] 
[10:22:49.019] getGlobalsAndPackages() ... DONE
[10:22:49.020] run() for ‘Future’ ...
[10:22:49.020] - state: ‘created’
[10:22:49.020] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.023] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.024]   - Field: ‘label’
[10:22:49.024]   - Field: ‘local’
[10:22:49.024]   - Field: ‘owner’
[10:22:49.024]   - Field: ‘envir’
[10:22:49.024]   - Field: ‘packages’
[10:22:49.024]   - Field: ‘gc’
[10:22:49.024]   - Field: ‘conditions’
[10:22:49.024]   - Field: ‘expr’
[10:22:49.024]   - Field: ‘uuid’
[10:22:49.024]   - Field: ‘seed’
[10:22:49.025]   - Field: ‘version’
[10:22:49.025]   - Field: ‘result’
[10:22:49.025]   - Field: ‘asynchronous’
[10:22:49.025]   - Field: ‘calls’
[10:22:49.025]   - Field: ‘globals’
[10:22:49.025]   - Field: ‘stdout’
[10:22:49.025]   - Field: ‘earlySignal’
[10:22:49.025]   - Field: ‘lazy’
[10:22:49.025]   - Field: ‘state’
[10:22:49.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.025] - Launch lazy future ...
[10:22:49.026] Packages needed by the future expression (n = 1): ‘stats’
[10:22:49.026] Packages needed by future strategies (n = 0): <none>
[10:22:49.026] {
[10:22:49.026]     {
[10:22:49.026]         {
[10:22:49.026]             ...future.startTime <- base::Sys.time()
[10:22:49.026]             {
[10:22:49.026]                 {
[10:22:49.026]                   {
[10:22:49.026]                     {
[10:22:49.026]                       base::local({
[10:22:49.026]                         has_future <- base::requireNamespace("future", 
[10:22:49.026]                           quietly = TRUE)
[10:22:49.026]                         if (has_future) {
[10:22:49.026]                           ns <- base::getNamespace("future")
[10:22:49.026]                           version <- ns[[".package"]][["version"]]
[10:22:49.026]                           if (is.null(version)) 
[10:22:49.026]                             version <- utils::packageVersion("future")
[10:22:49.026]                         }
[10:22:49.026]                         else {
[10:22:49.026]                           version <- NULL
[10:22:49.026]                         }
[10:22:49.026]                         if (!has_future || version < "1.8.0") {
[10:22:49.026]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.026]                             "", base::R.version$version.string), 
[10:22:49.026]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.026]                               "release", "version")], collapse = " "), 
[10:22:49.026]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.026]                             info)
[10:22:49.026]                           info <- base::paste(info, collapse = "; ")
[10:22:49.026]                           if (!has_future) {
[10:22:49.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.026]                               info)
[10:22:49.026]                           }
[10:22:49.026]                           else {
[10:22:49.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.026]                               info, version)
[10:22:49.026]                           }
[10:22:49.026]                           base::stop(msg)
[10:22:49.026]                         }
[10:22:49.026]                       })
[10:22:49.026]                     }
[10:22:49.026]                     base::local({
[10:22:49.026]                       for (pkg in "stats") {
[10:22:49.026]                         base::loadNamespace(pkg)
[10:22:49.026]                         base::library(pkg, character.only = TRUE)
[10:22:49.026]                       }
[10:22:49.026]                     })
[10:22:49.026]                   }
[10:22:49.026]                   options(future.plan = NULL)
[10:22:49.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.026]                 }
[10:22:49.026]                 ...future.workdir <- getwd()
[10:22:49.026]             }
[10:22:49.026]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.026]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.026]         }
[10:22:49.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.026]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.026]             base::names(...future.oldOptions))
[10:22:49.026]     }
[10:22:49.026]     if (FALSE) {
[10:22:49.026]     }
[10:22:49.026]     else {
[10:22:49.026]         if (TRUE) {
[10:22:49.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.026]                 open = "w")
[10:22:49.026]         }
[10:22:49.026]         else {
[10:22:49.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.026]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.026]         }
[10:22:49.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.026]             base::sink(type = "output", split = FALSE)
[10:22:49.026]             base::close(...future.stdout)
[10:22:49.026]         }, add = TRUE)
[10:22:49.026]     }
[10:22:49.026]     ...future.frame <- base::sys.nframe()
[10:22:49.026]     ...future.conditions <- base::list()
[10:22:49.026]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.026]     if (FALSE) {
[10:22:49.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.026]     }
[10:22:49.026]     ...future.result <- base::tryCatch({
[10:22:49.026]         base::withCallingHandlers({
[10:22:49.026]             ...future.value <- base::withVisible(base::local({
[10:22:49.026]                 do.call(function(...) {
[10:22:49.026]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.026]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.026]                     ...future.globals.maxSize)) {
[10:22:49.026]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.026]                     on.exit(options(oopts), add = TRUE)
[10:22:49.026]                   }
[10:22:49.026]                   {
[10:22:49.026]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.026]                       FUN = function(jj) {
[10:22:49.026]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.026]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.026]                       })
[10:22:49.026]                   }
[10:22:49.026]                 }, args = future.call.arguments)
[10:22:49.026]             }))
[10:22:49.026]             future::FutureResult(value = ...future.value$value, 
[10:22:49.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.026]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.026]                     ...future.globalenv.names))
[10:22:49.026]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.026]         }, condition = base::local({
[10:22:49.026]             c <- base::c
[10:22:49.026]             inherits <- base::inherits
[10:22:49.026]             invokeRestart <- base::invokeRestart
[10:22:49.026]             length <- base::length
[10:22:49.026]             list <- base::list
[10:22:49.026]             seq.int <- base::seq.int
[10:22:49.026]             signalCondition <- base::signalCondition
[10:22:49.026]             sys.calls <- base::sys.calls
[10:22:49.026]             `[[` <- base::`[[`
[10:22:49.026]             `+` <- base::`+`
[10:22:49.026]             `<<-` <- base::`<<-`
[10:22:49.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.026]                   3L)]
[10:22:49.026]             }
[10:22:49.026]             function(cond) {
[10:22:49.026]                 is_error <- inherits(cond, "error")
[10:22:49.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.026]                   NULL)
[10:22:49.026]                 if (is_error) {
[10:22:49.026]                   sessionInformation <- function() {
[10:22:49.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.026]                       search = base::search(), system = base::Sys.info())
[10:22:49.026]                   }
[10:22:49.026]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.026]                     cond$call), session = sessionInformation(), 
[10:22:49.026]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.026]                   signalCondition(cond)
[10:22:49.026]                 }
[10:22:49.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.026]                 "immediateCondition"))) {
[10:22:49.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.026]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.026]                   if (TRUE && !signal) {
[10:22:49.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.026]                     {
[10:22:49.026]                       inherits <- base::inherits
[10:22:49.026]                       invokeRestart <- base::invokeRestart
[10:22:49.026]                       is.null <- base::is.null
[10:22:49.026]                       muffled <- FALSE
[10:22:49.026]                       if (inherits(cond, "message")) {
[10:22:49.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.026]                         if (muffled) 
[10:22:49.026]                           invokeRestart("muffleMessage")
[10:22:49.026]                       }
[10:22:49.026]                       else if (inherits(cond, "warning")) {
[10:22:49.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.026]                         if (muffled) 
[10:22:49.026]                           invokeRestart("muffleWarning")
[10:22:49.026]                       }
[10:22:49.026]                       else if (inherits(cond, "condition")) {
[10:22:49.026]                         if (!is.null(pattern)) {
[10:22:49.026]                           computeRestarts <- base::computeRestarts
[10:22:49.026]                           grepl <- base::grepl
[10:22:49.026]                           restarts <- computeRestarts(cond)
[10:22:49.026]                           for (restart in restarts) {
[10:22:49.026]                             name <- restart$name
[10:22:49.026]                             if (is.null(name)) 
[10:22:49.026]                               next
[10:22:49.026]                             if (!grepl(pattern, name)) 
[10:22:49.026]                               next
[10:22:49.026]                             invokeRestart(restart)
[10:22:49.026]                             muffled <- TRUE
[10:22:49.026]                             break
[10:22:49.026]                           }
[10:22:49.026]                         }
[10:22:49.026]                       }
[10:22:49.026]                       invisible(muffled)
[10:22:49.026]                     }
[10:22:49.026]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.026]                   }
[10:22:49.026]                 }
[10:22:49.026]                 else {
[10:22:49.026]                   if (TRUE) {
[10:22:49.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.026]                     {
[10:22:49.026]                       inherits <- base::inherits
[10:22:49.026]                       invokeRestart <- base::invokeRestart
[10:22:49.026]                       is.null <- base::is.null
[10:22:49.026]                       muffled <- FALSE
[10:22:49.026]                       if (inherits(cond, "message")) {
[10:22:49.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.026]                         if (muffled) 
[10:22:49.026]                           invokeRestart("muffleMessage")
[10:22:49.026]                       }
[10:22:49.026]                       else if (inherits(cond, "warning")) {
[10:22:49.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.026]                         if (muffled) 
[10:22:49.026]                           invokeRestart("muffleWarning")
[10:22:49.026]                       }
[10:22:49.026]                       else if (inherits(cond, "condition")) {
[10:22:49.026]                         if (!is.null(pattern)) {
[10:22:49.026]                           computeRestarts <- base::computeRestarts
[10:22:49.026]                           grepl <- base::grepl
[10:22:49.026]                           restarts <- computeRestarts(cond)
[10:22:49.026]                           for (restart in restarts) {
[10:22:49.026]                             name <- restart$name
[10:22:49.026]                             if (is.null(name)) 
[10:22:49.026]                               next
[10:22:49.026]                             if (!grepl(pattern, name)) 
[10:22:49.026]                               next
[10:22:49.026]                             invokeRestart(restart)
[10:22:49.026]                             muffled <- TRUE
[10:22:49.026]                             break
[10:22:49.026]                           }
[10:22:49.026]                         }
[10:22:49.026]                       }
[10:22:49.026]                       invisible(muffled)
[10:22:49.026]                     }
[10:22:49.026]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.026]                   }
[10:22:49.026]                 }
[10:22:49.026]             }
[10:22:49.026]         }))
[10:22:49.026]     }, error = function(ex) {
[10:22:49.026]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.026]                 ...future.rng), started = ...future.startTime, 
[10:22:49.026]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.026]             version = "1.8"), class = "FutureResult")
[10:22:49.026]     }, finally = {
[10:22:49.026]         if (!identical(...future.workdir, getwd())) 
[10:22:49.026]             setwd(...future.workdir)
[10:22:49.026]         {
[10:22:49.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.026]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.026]             }
[10:22:49.026]             base::options(...future.oldOptions)
[10:22:49.026]             if (.Platform$OS.type == "windows") {
[10:22:49.026]                 old_names <- names(...future.oldEnvVars)
[10:22:49.026]                 envs <- base::Sys.getenv()
[10:22:49.026]                 names <- names(envs)
[10:22:49.026]                 common <- intersect(names, old_names)
[10:22:49.026]                 added <- setdiff(names, old_names)
[10:22:49.026]                 removed <- setdiff(old_names, names)
[10:22:49.026]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.026]                   envs[common]]
[10:22:49.026]                 NAMES <- toupper(changed)
[10:22:49.026]                 args <- list()
[10:22:49.026]                 for (kk in seq_along(NAMES)) {
[10:22:49.026]                   name <- changed[[kk]]
[10:22:49.026]                   NAME <- NAMES[[kk]]
[10:22:49.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.026]                     next
[10:22:49.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.026]                 }
[10:22:49.026]                 NAMES <- toupper(added)
[10:22:49.026]                 for (kk in seq_along(NAMES)) {
[10:22:49.026]                   name <- added[[kk]]
[10:22:49.026]                   NAME <- NAMES[[kk]]
[10:22:49.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.026]                     next
[10:22:49.026]                   args[[name]] <- ""
[10:22:49.026]                 }
[10:22:49.026]                 NAMES <- toupper(removed)
[10:22:49.026]                 for (kk in seq_along(NAMES)) {
[10:22:49.026]                   name <- removed[[kk]]
[10:22:49.026]                   NAME <- NAMES[[kk]]
[10:22:49.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.026]                     next
[10:22:49.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.026]                 }
[10:22:49.026]                 if (length(args) > 0) 
[10:22:49.026]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.026]             }
[10:22:49.026]             else {
[10:22:49.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.026]             }
[10:22:49.026]             {
[10:22:49.026]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.026]                   0L) {
[10:22:49.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.026]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.026]                   base::options(opts)
[10:22:49.026]                 }
[10:22:49.026]                 {
[10:22:49.026]                   {
[10:22:49.026]                     NULL
[10:22:49.026]                     RNGkind("Mersenne-Twister")
[10:22:49.026]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.026]                       inherits = FALSE)
[10:22:49.026]                   }
[10:22:49.026]                   options(future.plan = NULL)
[10:22:49.026]                   if (is.na(NA_character_)) 
[10:22:49.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.026]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.026]                     envir = parent.frame()) 
[10:22:49.026]                   {
[10:22:49.026]                     default_workers <- missing(workers)
[10:22:49.026]                     if (is.function(workers)) 
[10:22:49.026]                       workers <- workers()
[10:22:49.026]                     workers <- structure(as.integer(workers), 
[10:22:49.026]                       class = class(workers))
[10:22:49.026]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.026]                       1L)
[10:22:49.026]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.026]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.026]                       if (default_workers) 
[10:22:49.026]                         supportsMulticore(warn = TRUE)
[10:22:49.026]                       return(sequential(..., envir = envir))
[10:22:49.026]                     }
[10:22:49.026]                     oopts <- options(mc.cores = workers)
[10:22:49.026]                     on.exit(options(oopts))
[10:22:49.026]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.026]                       envir = envir)
[10:22:49.026]                     if (!future$lazy) 
[10:22:49.026]                       future <- run(future)
[10:22:49.026]                     invisible(future)
[10:22:49.026]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.026]                 }
[10:22:49.026]             }
[10:22:49.026]         }
[10:22:49.026]     })
[10:22:49.026]     if (TRUE) {
[10:22:49.026]         base::sink(type = "output", split = FALSE)
[10:22:49.026]         if (TRUE) {
[10:22:49.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.026]         }
[10:22:49.026]         else {
[10:22:49.026]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.026]         }
[10:22:49.026]         base::close(...future.stdout)
[10:22:49.026]         ...future.stdout <- NULL
[10:22:49.026]     }
[10:22:49.026]     ...future.result$conditions <- ...future.conditions
[10:22:49.026]     ...future.result$finished <- base::Sys.time()
[10:22:49.026]     ...future.result
[10:22:49.026] }
[10:22:49.028] assign_globals() ...
[10:22:49.028] List of 7
[10:22:49.028]  $ ...future.FUN            :function (x)  
[10:22:49.028]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:49.028]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.028]  $ future.call.arguments    : list()
[10:22:49.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.028]  $ ...future.elements_ii    :List of 3
[10:22:49.028]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.028]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.028]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.028]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.028]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.028]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.028]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.028]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.028]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.028]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.028]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.028]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.028]  $ ...future.seeds_ii       : NULL
[10:22:49.028]  $ ...future.globals.maxSize: NULL
[10:22:49.028]  - attr(*, "where")=List of 7
[10:22:49.028]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.028]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:22:49.028]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:22:49.028]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.028]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.028]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.028]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.028]  - attr(*, "resolved")= logi FALSE
[10:22:49.028]  - attr(*, "total_size")= num 2320
[10:22:49.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.028]  - attr(*, "already-done")= logi TRUE
[10:22:49.039] - reassign environment for ‘...future.FUN’
[10:22:49.039] - copied ‘...future.FUN’ to environment
[10:22:49.039] - copied ‘breaks’ to environment
[10:22:49.039] - copied ‘wool’ to environment
[10:22:49.039] - copied ‘future.call.arguments’ to environment
[10:22:49.039] - copied ‘...future.elements_ii’ to environment
[10:22:49.039] - copied ‘...future.seeds_ii’ to environment
[10:22:49.039] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.039] assign_globals() ... done
[10:22:49.040] plan(): Setting new future strategy stack:
[10:22:49.040] List of future strategies:
[10:22:49.040] 1. sequential:
[10:22:49.040]    - args: function (..., envir = parent.frame())
[10:22:49.040]    - tweaked: FALSE
[10:22:49.040]    - call: NULL
[10:22:49.040] plan(): nbrOfWorkers() = 1
[10:22:49.043] plan(): Setting new future strategy stack:
[10:22:49.043] List of future strategies:
[10:22:49.043] 1. multicore:
[10:22:49.043]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.043]    - tweaked: FALSE
[10:22:49.043]    - call: plan(strategy)
[10:22:49.046] plan(): nbrOfWorkers() = 1
[10:22:49.046] SequentialFuture started (and completed)
[10:22:49.046] - Launch lazy future ... done
[10:22:49.047] run() for ‘SequentialFuture’ ... done
[10:22:49.047] Created future:
[10:22:49.047] SequentialFuture:
[10:22:49.047] Label: ‘future_by-1’
[10:22:49.047] Expression:
[10:22:49.047] {
[10:22:49.047]     do.call(function(...) {
[10:22:49.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.047]             on.exit(options(oopts), add = TRUE)
[10:22:49.047]         }
[10:22:49.047]         {
[10:22:49.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.047]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.047]             })
[10:22:49.047]         }
[10:22:49.047]     }, args = future.call.arguments)
[10:22:49.047] }
[10:22:49.047] Lazy evaluation: FALSE
[10:22:49.047] Asynchronous evaluation: FALSE
[10:22:49.047] Local evaluation: TRUE
[10:22:49.047] Environment: 0x55f638436e38
[10:22:49.047] Capture standard output: TRUE
[10:22:49.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.047] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:22:49.047] Packages: 1 packages (‘stats’)
[10:22:49.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.047] Resolved: TRUE
[10:22:49.047] Value: 25.57 KiB of class ‘list’
[10:22:49.047] Early signaling: FALSE
[10:22:49.047] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.047] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.048] Chunk #1 of 1 ... DONE
[10:22:49.048] Launching 1 futures (chunks) ... DONE
[10:22:49.048] Resolving 1 futures (chunks) ...
[10:22:49.049] resolve() on list ...
[10:22:49.049]  recursive: 0
[10:22:49.049]  length: 1
[10:22:49.049] 
[10:22:49.049] resolved() for ‘SequentialFuture’ ...
[10:22:49.049] - state: ‘finished’
[10:22:49.049] - run: TRUE
[10:22:49.049] - result: ‘FutureResult’
[10:22:49.049] resolved() for ‘SequentialFuture’ ... done
[10:22:49.049] Future #1
[10:22:49.050] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.050] - nx: 1
[10:22:49.050] - relay: TRUE
[10:22:49.050] - stdout: TRUE
[10:22:49.050] - signal: TRUE
[10:22:49.050] - resignal: FALSE
[10:22:49.050] - force: TRUE
[10:22:49.050] - relayed: [n=1] FALSE
[10:22:49.050] - queued futures: [n=1] FALSE
[10:22:49.050]  - until=1
[10:22:49.050]  - relaying element #1
[10:22:49.051] - relayed: [n=1] TRUE
[10:22:49.051] - queued futures: [n=1] TRUE
[10:22:49.051] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.051]  length: 0 (resolved future 1)
[10:22:49.051] Relaying remaining futures
[10:22:49.051] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.051] - nx: 1
[10:22:49.051] - relay: TRUE
[10:22:49.051] - stdout: TRUE
[10:22:49.051] - signal: TRUE
[10:22:49.051] - resignal: FALSE
[10:22:49.052] - force: TRUE
[10:22:49.052] - relayed: [n=1] TRUE
[10:22:49.052] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.052] - relayed: [n=1] TRUE
[10:22:49.052] - queued futures: [n=1] TRUE
[10:22:49.052] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.052] resolve() on list ... DONE
[10:22:49.052]  - Number of value chunks collected: 1
[10:22:49.052] Resolving 1 futures (chunks) ... DONE
[10:22:49.052] Reducing values from 1 chunks ...
[10:22:49.052]  - Number of values collected after concatenation: 3
[10:22:49.053]  - Number of values expected: 3
[10:22:49.053] Reducing values from 1 chunks ... DONE
[10:22:49.053] future_lapply() ... DONE
[10:22:49.053] future_by_internal() ... DONE
[10:22:49.053] future_by_internal() ...
[10:22:49.054] future_lapply() ...
[10:22:49.057] Number of chunks: 1
[10:22:49.057] getGlobalsAndPackagesXApply() ...
[10:22:49.057]  - future.globals: TRUE
[10:22:49.057] getGlobalsAndPackages() ...
[10:22:49.058] Searching for globals...
[10:22:49.059] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.059] Searching for globals ... DONE
[10:22:49.059] Resolving globals: FALSE
[10:22:49.059] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.060] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.060] - globals: [1] ‘FUN’
[10:22:49.060] 
[10:22:49.060] getGlobalsAndPackages() ... DONE
[10:22:49.060]  - globals found/used: [n=1] ‘FUN’
[10:22:49.060]  - needed namespaces: [n=0] 
[10:22:49.060] Finding globals ... DONE
[10:22:49.060]  - use_args: TRUE
[10:22:49.060]  - Getting '...' globals ...
[10:22:49.061] resolve() on list ...
[10:22:49.061]  recursive: 0
[10:22:49.061]  length: 1
[10:22:49.061]  elements: ‘...’
[10:22:49.061]  length: 0 (resolved future 1)
[10:22:49.061] resolve() on list ... DONE
[10:22:49.061]    - '...' content: [n=0] 
[10:22:49.061] List of 1
[10:22:49.061]  $ ...: list()
[10:22:49.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.061]  - attr(*, "where")=List of 1
[10:22:49.061]   ..$ ...:<environment: 0x55f639d32440> 
[10:22:49.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.061]  - attr(*, "resolved")= logi TRUE
[10:22:49.061]  - attr(*, "total_size")= num NA
[10:22:49.066]  - Getting '...' globals ... DONE
[10:22:49.066] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.066] List of 2
[10:22:49.066]  $ ...future.FUN:function (object, ...)  
[10:22:49.066]  $ ...          : list()
[10:22:49.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.066]  - attr(*, "where")=List of 2
[10:22:49.066]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.066]   ..$ ...          :<environment: 0x55f639d32440> 
[10:22:49.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.066]  - attr(*, "resolved")= logi FALSE
[10:22:49.066]  - attr(*, "total_size")= num 1240
[10:22:49.069] Packages to be attached in all futures: [n=0] 
[10:22:49.069] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.069] Number of futures (= number of chunks): 1
[10:22:49.069] Launching 1 futures (chunks) ...
[10:22:49.069] Chunk #1 of 1 ...
[10:22:49.069]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.069] getGlobalsAndPackages() ...
[10:22:49.069] Searching for globals...
[10:22:49.070] 
[10:22:49.070] Searching for globals ... DONE
[10:22:49.070] - globals: [0] <none>
[10:22:49.070] getGlobalsAndPackages() ... DONE
[10:22:49.070]    + additional globals found: [n=0] 
[10:22:49.070]    + additional namespaces needed: [n=0] 
[10:22:49.070]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.071]  - seeds: <none>
[10:22:49.071]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.071] getGlobalsAndPackages() ...
[10:22:49.071] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.071] Resolving globals: FALSE
[10:22:49.071] Tweak future expression to call with '...' arguments ...
[10:22:49.071] {
[10:22:49.071]     do.call(function(...) {
[10:22:49.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.071]             on.exit(options(oopts), add = TRUE)
[10:22:49.071]         }
[10:22:49.071]         {
[10:22:49.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.071]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.071]             })
[10:22:49.071]         }
[10:22:49.071]     }, args = future.call.arguments)
[10:22:49.071] }
[10:22:49.071] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.072] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.072] 
[10:22:49.072] getGlobalsAndPackages() ... DONE
[10:22:49.072] run() for ‘Future’ ...
[10:22:49.072] - state: ‘created’
[10:22:49.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.076] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.076]   - Field: ‘label’
[10:22:49.076]   - Field: ‘local’
[10:22:49.076]   - Field: ‘owner’
[10:22:49.077]   - Field: ‘envir’
[10:22:49.077]   - Field: ‘packages’
[10:22:49.077]   - Field: ‘gc’
[10:22:49.077]   - Field: ‘conditions’
[10:22:49.077]   - Field: ‘expr’
[10:22:49.077]   - Field: ‘uuid’
[10:22:49.077]   - Field: ‘seed’
[10:22:49.077]   - Field: ‘version’
[10:22:49.077]   - Field: ‘result’
[10:22:49.077]   - Field: ‘asynchronous’
[10:22:49.078]   - Field: ‘calls’
[10:22:49.078]   - Field: ‘globals’
[10:22:49.078]   - Field: ‘stdout’
[10:22:49.078]   - Field: ‘earlySignal’
[10:22:49.078]   - Field: ‘lazy’
[10:22:49.078]   - Field: ‘state’
[10:22:49.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.078] - Launch lazy future ...
[10:22:49.078] Packages needed by the future expression (n = 0): <none>
[10:22:49.078] Packages needed by future strategies (n = 0): <none>
[10:22:49.079] {
[10:22:49.079]     {
[10:22:49.079]         {
[10:22:49.079]             ...future.startTime <- base::Sys.time()
[10:22:49.079]             {
[10:22:49.079]                 {
[10:22:49.079]                   {
[10:22:49.079]                     base::local({
[10:22:49.079]                       has_future <- base::requireNamespace("future", 
[10:22:49.079]                         quietly = TRUE)
[10:22:49.079]                       if (has_future) {
[10:22:49.079]                         ns <- base::getNamespace("future")
[10:22:49.079]                         version <- ns[[".package"]][["version"]]
[10:22:49.079]                         if (is.null(version)) 
[10:22:49.079]                           version <- utils::packageVersion("future")
[10:22:49.079]                       }
[10:22:49.079]                       else {
[10:22:49.079]                         version <- NULL
[10:22:49.079]                       }
[10:22:49.079]                       if (!has_future || version < "1.8.0") {
[10:22:49.079]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.079]                           "", base::R.version$version.string), 
[10:22:49.079]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.079]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.079]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.079]                             "release", "version")], collapse = " "), 
[10:22:49.079]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.079]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.079]                           info)
[10:22:49.079]                         info <- base::paste(info, collapse = "; ")
[10:22:49.079]                         if (!has_future) {
[10:22:49.079]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.079]                             info)
[10:22:49.079]                         }
[10:22:49.079]                         else {
[10:22:49.079]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.079]                             info, version)
[10:22:49.079]                         }
[10:22:49.079]                         base::stop(msg)
[10:22:49.079]                       }
[10:22:49.079]                     })
[10:22:49.079]                   }
[10:22:49.079]                   options(future.plan = NULL)
[10:22:49.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.079]                 }
[10:22:49.079]                 ...future.workdir <- getwd()
[10:22:49.079]             }
[10:22:49.079]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.079]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.079]         }
[10:22:49.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.079]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.079]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.079]             base::names(...future.oldOptions))
[10:22:49.079]     }
[10:22:49.079]     if (FALSE) {
[10:22:49.079]     }
[10:22:49.079]     else {
[10:22:49.079]         if (TRUE) {
[10:22:49.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.079]                 open = "w")
[10:22:49.079]         }
[10:22:49.079]         else {
[10:22:49.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.079]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.079]         }
[10:22:49.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.079]             base::sink(type = "output", split = FALSE)
[10:22:49.079]             base::close(...future.stdout)
[10:22:49.079]         }, add = TRUE)
[10:22:49.079]     }
[10:22:49.079]     ...future.frame <- base::sys.nframe()
[10:22:49.079]     ...future.conditions <- base::list()
[10:22:49.079]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.079]     if (FALSE) {
[10:22:49.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.079]     }
[10:22:49.079]     ...future.result <- base::tryCatch({
[10:22:49.079]         base::withCallingHandlers({
[10:22:49.079]             ...future.value <- base::withVisible(base::local({
[10:22:49.079]                 do.call(function(...) {
[10:22:49.079]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.079]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.079]                     ...future.globals.maxSize)) {
[10:22:49.079]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.079]                     on.exit(options(oopts), add = TRUE)
[10:22:49.079]                   }
[10:22:49.079]                   {
[10:22:49.079]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.079]                       FUN = function(jj) {
[10:22:49.079]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.079]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.079]                       })
[10:22:49.079]                   }
[10:22:49.079]                 }, args = future.call.arguments)
[10:22:49.079]             }))
[10:22:49.079]             future::FutureResult(value = ...future.value$value, 
[10:22:49.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.079]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.079]                     ...future.globalenv.names))
[10:22:49.079]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.079]         }, condition = base::local({
[10:22:49.079]             c <- base::c
[10:22:49.079]             inherits <- base::inherits
[10:22:49.079]             invokeRestart <- base::invokeRestart
[10:22:49.079]             length <- base::length
[10:22:49.079]             list <- base::list
[10:22:49.079]             seq.int <- base::seq.int
[10:22:49.079]             signalCondition <- base::signalCondition
[10:22:49.079]             sys.calls <- base::sys.calls
[10:22:49.079]             `[[` <- base::`[[`
[10:22:49.079]             `+` <- base::`+`
[10:22:49.079]             `<<-` <- base::`<<-`
[10:22:49.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.079]                   3L)]
[10:22:49.079]             }
[10:22:49.079]             function(cond) {
[10:22:49.079]                 is_error <- inherits(cond, "error")
[10:22:49.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.079]                   NULL)
[10:22:49.079]                 if (is_error) {
[10:22:49.079]                   sessionInformation <- function() {
[10:22:49.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.079]                       search = base::search(), system = base::Sys.info())
[10:22:49.079]                   }
[10:22:49.079]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.079]                     cond$call), session = sessionInformation(), 
[10:22:49.079]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.079]                   signalCondition(cond)
[10:22:49.079]                 }
[10:22:49.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.079]                 "immediateCondition"))) {
[10:22:49.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.079]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.079]                   if (TRUE && !signal) {
[10:22:49.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.079]                     {
[10:22:49.079]                       inherits <- base::inherits
[10:22:49.079]                       invokeRestart <- base::invokeRestart
[10:22:49.079]                       is.null <- base::is.null
[10:22:49.079]                       muffled <- FALSE
[10:22:49.079]                       if (inherits(cond, "message")) {
[10:22:49.079]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.079]                         if (muffled) 
[10:22:49.079]                           invokeRestart("muffleMessage")
[10:22:49.079]                       }
[10:22:49.079]                       else if (inherits(cond, "warning")) {
[10:22:49.079]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.079]                         if (muffled) 
[10:22:49.079]                           invokeRestart("muffleWarning")
[10:22:49.079]                       }
[10:22:49.079]                       else if (inherits(cond, "condition")) {
[10:22:49.079]                         if (!is.null(pattern)) {
[10:22:49.079]                           computeRestarts <- base::computeRestarts
[10:22:49.079]                           grepl <- base::grepl
[10:22:49.079]                           restarts <- computeRestarts(cond)
[10:22:49.079]                           for (restart in restarts) {
[10:22:49.079]                             name <- restart$name
[10:22:49.079]                             if (is.null(name)) 
[10:22:49.079]                               next
[10:22:49.079]                             if (!grepl(pattern, name)) 
[10:22:49.079]                               next
[10:22:49.079]                             invokeRestart(restart)
[10:22:49.079]                             muffled <- TRUE
[10:22:49.079]                             break
[10:22:49.079]                           }
[10:22:49.079]                         }
[10:22:49.079]                       }
[10:22:49.079]                       invisible(muffled)
[10:22:49.079]                     }
[10:22:49.079]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.079]                   }
[10:22:49.079]                 }
[10:22:49.079]                 else {
[10:22:49.079]                   if (TRUE) {
[10:22:49.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.079]                     {
[10:22:49.079]                       inherits <- base::inherits
[10:22:49.079]                       invokeRestart <- base::invokeRestart
[10:22:49.079]                       is.null <- base::is.null
[10:22:49.079]                       muffled <- FALSE
[10:22:49.079]                       if (inherits(cond, "message")) {
[10:22:49.079]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.079]                         if (muffled) 
[10:22:49.079]                           invokeRestart("muffleMessage")
[10:22:49.079]                       }
[10:22:49.079]                       else if (inherits(cond, "warning")) {
[10:22:49.079]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.079]                         if (muffled) 
[10:22:49.079]                           invokeRestart("muffleWarning")
[10:22:49.079]                       }
[10:22:49.079]                       else if (inherits(cond, "condition")) {
[10:22:49.079]                         if (!is.null(pattern)) {
[10:22:49.079]                           computeRestarts <- base::computeRestarts
[10:22:49.079]                           grepl <- base::grepl
[10:22:49.079]                           restarts <- computeRestarts(cond)
[10:22:49.079]                           for (restart in restarts) {
[10:22:49.079]                             name <- restart$name
[10:22:49.079]                             if (is.null(name)) 
[10:22:49.079]                               next
[10:22:49.079]                             if (!grepl(pattern, name)) 
[10:22:49.079]                               next
[10:22:49.079]                             invokeRestart(restart)
[10:22:49.079]                             muffled <- TRUE
[10:22:49.079]                             break
[10:22:49.079]                           }
[10:22:49.079]                         }
[10:22:49.079]                       }
[10:22:49.079]                       invisible(muffled)
[10:22:49.079]                     }
[10:22:49.079]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.079]                   }
[10:22:49.079]                 }
[10:22:49.079]             }
[10:22:49.079]         }))
[10:22:49.079]     }, error = function(ex) {
[10:22:49.079]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.079]                 ...future.rng), started = ...future.startTime, 
[10:22:49.079]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.079]             version = "1.8"), class = "FutureResult")
[10:22:49.079]     }, finally = {
[10:22:49.079]         if (!identical(...future.workdir, getwd())) 
[10:22:49.079]             setwd(...future.workdir)
[10:22:49.079]         {
[10:22:49.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.079]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.079]             }
[10:22:49.079]             base::options(...future.oldOptions)
[10:22:49.079]             if (.Platform$OS.type == "windows") {
[10:22:49.079]                 old_names <- names(...future.oldEnvVars)
[10:22:49.079]                 envs <- base::Sys.getenv()
[10:22:49.079]                 names <- names(envs)
[10:22:49.079]                 common <- intersect(names, old_names)
[10:22:49.079]                 added <- setdiff(names, old_names)
[10:22:49.079]                 removed <- setdiff(old_names, names)
[10:22:49.079]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.079]                   envs[common]]
[10:22:49.079]                 NAMES <- toupper(changed)
[10:22:49.079]                 args <- list()
[10:22:49.079]                 for (kk in seq_along(NAMES)) {
[10:22:49.079]                   name <- changed[[kk]]
[10:22:49.079]                   NAME <- NAMES[[kk]]
[10:22:49.079]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.079]                     next
[10:22:49.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.079]                 }
[10:22:49.079]                 NAMES <- toupper(added)
[10:22:49.079]                 for (kk in seq_along(NAMES)) {
[10:22:49.079]                   name <- added[[kk]]
[10:22:49.079]                   NAME <- NAMES[[kk]]
[10:22:49.079]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.079]                     next
[10:22:49.079]                   args[[name]] <- ""
[10:22:49.079]                 }
[10:22:49.079]                 NAMES <- toupper(removed)
[10:22:49.079]                 for (kk in seq_along(NAMES)) {
[10:22:49.079]                   name <- removed[[kk]]
[10:22:49.079]                   NAME <- NAMES[[kk]]
[10:22:49.079]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.079]                     next
[10:22:49.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.079]                 }
[10:22:49.079]                 if (length(args) > 0) 
[10:22:49.079]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.079]             }
[10:22:49.079]             else {
[10:22:49.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.079]             }
[10:22:49.079]             {
[10:22:49.079]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.079]                   0L) {
[10:22:49.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.079]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.079]                   base::options(opts)
[10:22:49.079]                 }
[10:22:49.079]                 {
[10:22:49.079]                   {
[10:22:49.079]                     NULL
[10:22:49.079]                     RNGkind("Mersenne-Twister")
[10:22:49.079]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.079]                       inherits = FALSE)
[10:22:49.079]                   }
[10:22:49.079]                   options(future.plan = NULL)
[10:22:49.079]                   if (is.na(NA_character_)) 
[10:22:49.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.079]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.079]                     envir = parent.frame()) 
[10:22:49.079]                   {
[10:22:49.079]                     default_workers <- missing(workers)
[10:22:49.079]                     if (is.function(workers)) 
[10:22:49.079]                       workers <- workers()
[10:22:49.079]                     workers <- structure(as.integer(workers), 
[10:22:49.079]                       class = class(workers))
[10:22:49.079]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.079]                       1L)
[10:22:49.079]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.079]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.079]                       if (default_workers) 
[10:22:49.079]                         supportsMulticore(warn = TRUE)
[10:22:49.079]                       return(sequential(..., envir = envir))
[10:22:49.079]                     }
[10:22:49.079]                     oopts <- options(mc.cores = workers)
[10:22:49.079]                     on.exit(options(oopts))
[10:22:49.079]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.079]                       envir = envir)
[10:22:49.079]                     if (!future$lazy) 
[10:22:49.079]                       future <- run(future)
[10:22:49.079]                     invisible(future)
[10:22:49.079]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.079]                 }
[10:22:49.079]             }
[10:22:49.079]         }
[10:22:49.079]     })
[10:22:49.079]     if (TRUE) {
[10:22:49.079]         base::sink(type = "output", split = FALSE)
[10:22:49.079]         if (TRUE) {
[10:22:49.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.079]         }
[10:22:49.079]         else {
[10:22:49.079]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.079]         }
[10:22:49.079]         base::close(...future.stdout)
[10:22:49.079]         ...future.stdout <- NULL
[10:22:49.079]     }
[10:22:49.079]     ...future.result$conditions <- ...future.conditions
[10:22:49.079]     ...future.result$finished <- base::Sys.time()
[10:22:49.079]     ...future.result
[10:22:49.079] }
[10:22:49.081] assign_globals() ...
[10:22:49.081] List of 5
[10:22:49.081]  $ ...future.FUN            :function (object, ...)  
[10:22:49.081]  $ future.call.arguments    : list()
[10:22:49.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.081]  $ ...future.elements_ii    :List of 3
[10:22:49.081]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.081]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.081]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.081]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.081]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.081]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.081]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.081]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.081]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.081]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.081]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.081]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.081]  $ ...future.seeds_ii       : NULL
[10:22:49.081]  $ ...future.globals.maxSize: NULL
[10:22:49.081]  - attr(*, "where")=List of 5
[10:22:49.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.081]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.081]  - attr(*, "resolved")= logi FALSE
[10:22:49.081]  - attr(*, "total_size")= num 1240
[10:22:49.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.081]  - attr(*, "already-done")= logi TRUE
[10:22:49.091] - copied ‘...future.FUN’ to environment
[10:22:49.091] - copied ‘future.call.arguments’ to environment
[10:22:49.091] - copied ‘...future.elements_ii’ to environment
[10:22:49.091] - copied ‘...future.seeds_ii’ to environment
[10:22:49.091] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.091] assign_globals() ... done
[10:22:49.091] plan(): Setting new future strategy stack:
[10:22:49.091] List of future strategies:
[10:22:49.091] 1. sequential:
[10:22:49.091]    - args: function (..., envir = parent.frame())
[10:22:49.091]    - tweaked: FALSE
[10:22:49.091]    - call: NULL
[10:22:49.092] plan(): nbrOfWorkers() = 1
[10:22:49.094] plan(): Setting new future strategy stack:
[10:22:49.094] List of future strategies:
[10:22:49.094] 1. multicore:
[10:22:49.094]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.094]    - tweaked: FALSE
[10:22:49.094]    - call: plan(strategy)
[10:22:49.097] plan(): nbrOfWorkers() = 1
[10:22:49.098] SequentialFuture started (and completed)
[10:22:49.098] - Launch lazy future ... done
[10:22:49.098] run() for ‘SequentialFuture’ ... done
[10:22:49.098] Created future:
[10:22:49.098] SequentialFuture:
[10:22:49.098] Label: ‘future_by-1’
[10:22:49.098] Expression:
[10:22:49.098] {
[10:22:49.098]     do.call(function(...) {
[10:22:49.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.098]             on.exit(options(oopts), add = TRUE)
[10:22:49.098]         }
[10:22:49.098]         {
[10:22:49.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.098]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.098]             })
[10:22:49.098]         }
[10:22:49.098]     }, args = future.call.arguments)
[10:22:49.098] }
[10:22:49.098] Lazy evaluation: FALSE
[10:22:49.098] Asynchronous evaluation: FALSE
[10:22:49.098] Local evaluation: TRUE
[10:22:49.098] Environment: 0x55f639cf7168
[10:22:49.098] Capture standard output: TRUE
[10:22:49.098] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.098] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.098] Packages: <none>
[10:22:49.098] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.098] Resolved: TRUE
[10:22:49.098] Value: 5.37 KiB of class ‘list’
[10:22:49.098] Early signaling: FALSE
[10:22:49.098] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.098] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.099] Chunk #1 of 1 ... DONE
[10:22:49.099] Launching 1 futures (chunks) ... DONE
[10:22:49.099] Resolving 1 futures (chunks) ...
[10:22:49.100] resolve() on list ...
[10:22:49.100]  recursive: 0
[10:22:49.100]  length: 1
[10:22:49.100] 
[10:22:49.100] resolved() for ‘SequentialFuture’ ...
[10:22:49.100] - state: ‘finished’
[10:22:49.100] - run: TRUE
[10:22:49.100] - result: ‘FutureResult’
[10:22:49.100] resolved() for ‘SequentialFuture’ ... done
[10:22:49.100] Future #1
[10:22:49.101] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.101] - nx: 1
[10:22:49.101] - relay: TRUE
[10:22:49.101] - stdout: TRUE
[10:22:49.101] - signal: TRUE
[10:22:49.101] - resignal: FALSE
[10:22:49.101] - force: TRUE
[10:22:49.101] - relayed: [n=1] FALSE
[10:22:49.101] - queued futures: [n=1] FALSE
[10:22:49.101]  - until=1
[10:22:49.101]  - relaying element #1
[10:22:49.102] - relayed: [n=1] TRUE
[10:22:49.102] - queued futures: [n=1] TRUE
[10:22:49.102] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.102]  length: 0 (resolved future 1)
[10:22:49.102] Relaying remaining futures
[10:22:49.102] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.102] - nx: 1
[10:22:49.102] - relay: TRUE
[10:22:49.102] - stdout: TRUE
[10:22:49.102] - signal: TRUE
[10:22:49.102] - resignal: FALSE
[10:22:49.103] - force: TRUE
[10:22:49.103] - relayed: [n=1] TRUE
[10:22:49.103] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.103] - relayed: [n=1] TRUE
[10:22:49.103] - queued futures: [n=1] TRUE
[10:22:49.103] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.103] resolve() on list ... DONE
[10:22:49.103]  - Number of value chunks collected: 1
[10:22:49.103] Resolving 1 futures (chunks) ... DONE
[10:22:49.103] Reducing values from 1 chunks ...
[10:22:49.103]  - Number of values collected after concatenation: 3
[10:22:49.104]  - Number of values expected: 3
[10:22:49.104] Reducing values from 1 chunks ... DONE
[10:22:49.104] future_lapply() ... DONE
[10:22:49.104] future_by_internal() ... DONE
[10:22:49.105] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:22:49.105] future_lapply() ...
[10:22:49.109] Number of chunks: 1
[10:22:49.109] getGlobalsAndPackagesXApply() ...
[10:22:49.109]  - future.globals: TRUE
[10:22:49.109] getGlobalsAndPackages() ...
[10:22:49.109] Searching for globals...
[10:22:49.110] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.110] Searching for globals ... DONE
[10:22:49.110] Resolving globals: FALSE
[10:22:49.111] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.111] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.111] - globals: [1] ‘FUN’
[10:22:49.111] 
[10:22:49.111] getGlobalsAndPackages() ... DONE
[10:22:49.111]  - globals found/used: [n=1] ‘FUN’
[10:22:49.111]  - needed namespaces: [n=0] 
[10:22:49.111] Finding globals ... DONE
[10:22:49.112]  - use_args: TRUE
[10:22:49.112]  - Getting '...' globals ...
[10:22:49.112] resolve() on list ...
[10:22:49.112]  recursive: 0
[10:22:49.112]  length: 1
[10:22:49.112]  elements: ‘...’
[10:22:49.112]  length: 0 (resolved future 1)
[10:22:49.112] resolve() on list ... DONE
[10:22:49.112]    - '...' content: [n=0] 
[10:22:49.113] List of 1
[10:22:49.113]  $ ...: list()
[10:22:49.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.113]  - attr(*, "where")=List of 1
[10:22:49.113]   ..$ ...:<environment: 0x55f639d739c8> 
[10:22:49.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.113]  - attr(*, "resolved")= logi TRUE
[10:22:49.113]  - attr(*, "total_size")= num NA
[10:22:49.116]  - Getting '...' globals ... DONE
[10:22:49.117] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.117] List of 2
[10:22:49.117]  $ ...future.FUN:function (object, ...)  
[10:22:49.117]  $ ...          : list()
[10:22:49.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.117]  - attr(*, "where")=List of 2
[10:22:49.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.117]   ..$ ...          :<environment: 0x55f639d739c8> 
[10:22:49.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.117]  - attr(*, "resolved")= logi FALSE
[10:22:49.117]  - attr(*, "total_size")= num 1240
[10:22:49.119] Packages to be attached in all futures: [n=0] 
[10:22:49.119] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.120] Number of futures (= number of chunks): 1
[10:22:49.120] Launching 1 futures (chunks) ...
[10:22:49.120] Chunk #1 of 1 ...
[10:22:49.120]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.120] getGlobalsAndPackages() ...
[10:22:49.120] Searching for globals...
[10:22:49.120] 
[10:22:49.121] Searching for globals ... DONE
[10:22:49.121] - globals: [0] <none>
[10:22:49.121] getGlobalsAndPackages() ... DONE
[10:22:49.121]    + additional globals found: [n=0] 
[10:22:49.121]    + additional namespaces needed: [n=0] 
[10:22:49.121]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.121]  - seeds: <none>
[10:22:49.121]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.121] getGlobalsAndPackages() ...
[10:22:49.121] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.122] Resolving globals: FALSE
[10:22:49.122] Tweak future expression to call with '...' arguments ...
[10:22:49.122] {
[10:22:49.122]     do.call(function(...) {
[10:22:49.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.122]             on.exit(options(oopts), add = TRUE)
[10:22:49.122]         }
[10:22:49.122]         {
[10:22:49.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.122]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.122]             })
[10:22:49.122]         }
[10:22:49.122]     }, args = future.call.arguments)
[10:22:49.122] }
[10:22:49.122] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.122] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.122] 
[10:22:49.123] getGlobalsAndPackages() ... DONE
[10:22:49.123] run() for ‘Future’ ...
[10:22:49.123] - state: ‘created’
[10:22:49.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.127]   - Field: ‘label’
[10:22:49.127]   - Field: ‘local’
[10:22:49.127]   - Field: ‘owner’
[10:22:49.127]   - Field: ‘envir’
[10:22:49.127]   - Field: ‘packages’
[10:22:49.127]   - Field: ‘gc’
[10:22:49.127]   - Field: ‘conditions’
[10:22:49.127]   - Field: ‘expr’
[10:22:49.127]   - Field: ‘uuid’
[10:22:49.128]   - Field: ‘seed’
[10:22:49.128]   - Field: ‘version’
[10:22:49.128]   - Field: ‘result’
[10:22:49.128]   - Field: ‘asynchronous’
[10:22:49.128]   - Field: ‘calls’
[10:22:49.128]   - Field: ‘globals’
[10:22:49.128]   - Field: ‘stdout’
[10:22:49.128]   - Field: ‘earlySignal’
[10:22:49.128]   - Field: ‘lazy’
[10:22:49.128]   - Field: ‘state’
[10:22:49.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.129] - Launch lazy future ...
[10:22:49.129] Packages needed by the future expression (n = 0): <none>
[10:22:49.129] Packages needed by future strategies (n = 0): <none>
[10:22:49.129] {
[10:22:49.129]     {
[10:22:49.129]         {
[10:22:49.129]             ...future.startTime <- base::Sys.time()
[10:22:49.129]             {
[10:22:49.129]                 {
[10:22:49.129]                   {
[10:22:49.129]                     base::local({
[10:22:49.129]                       has_future <- base::requireNamespace("future", 
[10:22:49.129]                         quietly = TRUE)
[10:22:49.129]                       if (has_future) {
[10:22:49.129]                         ns <- base::getNamespace("future")
[10:22:49.129]                         version <- ns[[".package"]][["version"]]
[10:22:49.129]                         if (is.null(version)) 
[10:22:49.129]                           version <- utils::packageVersion("future")
[10:22:49.129]                       }
[10:22:49.129]                       else {
[10:22:49.129]                         version <- NULL
[10:22:49.129]                       }
[10:22:49.129]                       if (!has_future || version < "1.8.0") {
[10:22:49.129]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.129]                           "", base::R.version$version.string), 
[10:22:49.129]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.129]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.129]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.129]                             "release", "version")], collapse = " "), 
[10:22:49.129]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.129]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.129]                           info)
[10:22:49.129]                         info <- base::paste(info, collapse = "; ")
[10:22:49.129]                         if (!has_future) {
[10:22:49.129]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.129]                             info)
[10:22:49.129]                         }
[10:22:49.129]                         else {
[10:22:49.129]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.129]                             info, version)
[10:22:49.129]                         }
[10:22:49.129]                         base::stop(msg)
[10:22:49.129]                       }
[10:22:49.129]                     })
[10:22:49.129]                   }
[10:22:49.129]                   options(future.plan = NULL)
[10:22:49.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.129]                 }
[10:22:49.129]                 ...future.workdir <- getwd()
[10:22:49.129]             }
[10:22:49.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.129]         }
[10:22:49.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.129]             base::names(...future.oldOptions))
[10:22:49.129]     }
[10:22:49.129]     if (FALSE) {
[10:22:49.129]     }
[10:22:49.129]     else {
[10:22:49.129]         if (TRUE) {
[10:22:49.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.129]                 open = "w")
[10:22:49.129]         }
[10:22:49.129]         else {
[10:22:49.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.129]         }
[10:22:49.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.129]             base::sink(type = "output", split = FALSE)
[10:22:49.129]             base::close(...future.stdout)
[10:22:49.129]         }, add = TRUE)
[10:22:49.129]     }
[10:22:49.129]     ...future.frame <- base::sys.nframe()
[10:22:49.129]     ...future.conditions <- base::list()
[10:22:49.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.129]     if (FALSE) {
[10:22:49.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.129]     }
[10:22:49.129]     ...future.result <- base::tryCatch({
[10:22:49.129]         base::withCallingHandlers({
[10:22:49.129]             ...future.value <- base::withVisible(base::local({
[10:22:49.129]                 do.call(function(...) {
[10:22:49.129]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.129]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.129]                     ...future.globals.maxSize)) {
[10:22:49.129]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.129]                     on.exit(options(oopts), add = TRUE)
[10:22:49.129]                   }
[10:22:49.129]                   {
[10:22:49.129]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.129]                       FUN = function(jj) {
[10:22:49.129]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.129]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.129]                       })
[10:22:49.129]                   }
[10:22:49.129]                 }, args = future.call.arguments)
[10:22:49.129]             }))
[10:22:49.129]             future::FutureResult(value = ...future.value$value, 
[10:22:49.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.129]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.129]                     ...future.globalenv.names))
[10:22:49.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.129]         }, condition = base::local({
[10:22:49.129]             c <- base::c
[10:22:49.129]             inherits <- base::inherits
[10:22:49.129]             invokeRestart <- base::invokeRestart
[10:22:49.129]             length <- base::length
[10:22:49.129]             list <- base::list
[10:22:49.129]             seq.int <- base::seq.int
[10:22:49.129]             signalCondition <- base::signalCondition
[10:22:49.129]             sys.calls <- base::sys.calls
[10:22:49.129]             `[[` <- base::`[[`
[10:22:49.129]             `+` <- base::`+`
[10:22:49.129]             `<<-` <- base::`<<-`
[10:22:49.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.129]                   3L)]
[10:22:49.129]             }
[10:22:49.129]             function(cond) {
[10:22:49.129]                 is_error <- inherits(cond, "error")
[10:22:49.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.129]                   NULL)
[10:22:49.129]                 if (is_error) {
[10:22:49.129]                   sessionInformation <- function() {
[10:22:49.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.129]                       search = base::search(), system = base::Sys.info())
[10:22:49.129]                   }
[10:22:49.129]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.129]                     cond$call), session = sessionInformation(), 
[10:22:49.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.129]                   signalCondition(cond)
[10:22:49.129]                 }
[10:22:49.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.129]                 "immediateCondition"))) {
[10:22:49.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.129]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.129]                   if (TRUE && !signal) {
[10:22:49.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.129]                     {
[10:22:49.129]                       inherits <- base::inherits
[10:22:49.129]                       invokeRestart <- base::invokeRestart
[10:22:49.129]                       is.null <- base::is.null
[10:22:49.129]                       muffled <- FALSE
[10:22:49.129]                       if (inherits(cond, "message")) {
[10:22:49.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.129]                         if (muffled) 
[10:22:49.129]                           invokeRestart("muffleMessage")
[10:22:49.129]                       }
[10:22:49.129]                       else if (inherits(cond, "warning")) {
[10:22:49.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.129]                         if (muffled) 
[10:22:49.129]                           invokeRestart("muffleWarning")
[10:22:49.129]                       }
[10:22:49.129]                       else if (inherits(cond, "condition")) {
[10:22:49.129]                         if (!is.null(pattern)) {
[10:22:49.129]                           computeRestarts <- base::computeRestarts
[10:22:49.129]                           grepl <- base::grepl
[10:22:49.129]                           restarts <- computeRestarts(cond)
[10:22:49.129]                           for (restart in restarts) {
[10:22:49.129]                             name <- restart$name
[10:22:49.129]                             if (is.null(name)) 
[10:22:49.129]                               next
[10:22:49.129]                             if (!grepl(pattern, name)) 
[10:22:49.129]                               next
[10:22:49.129]                             invokeRestart(restart)
[10:22:49.129]                             muffled <- TRUE
[10:22:49.129]                             break
[10:22:49.129]                           }
[10:22:49.129]                         }
[10:22:49.129]                       }
[10:22:49.129]                       invisible(muffled)
[10:22:49.129]                     }
[10:22:49.129]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.129]                   }
[10:22:49.129]                 }
[10:22:49.129]                 else {
[10:22:49.129]                   if (TRUE) {
[10:22:49.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.129]                     {
[10:22:49.129]                       inherits <- base::inherits
[10:22:49.129]                       invokeRestart <- base::invokeRestart
[10:22:49.129]                       is.null <- base::is.null
[10:22:49.129]                       muffled <- FALSE
[10:22:49.129]                       if (inherits(cond, "message")) {
[10:22:49.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.129]                         if (muffled) 
[10:22:49.129]                           invokeRestart("muffleMessage")
[10:22:49.129]                       }
[10:22:49.129]                       else if (inherits(cond, "warning")) {
[10:22:49.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.129]                         if (muffled) 
[10:22:49.129]                           invokeRestart("muffleWarning")
[10:22:49.129]                       }
[10:22:49.129]                       else if (inherits(cond, "condition")) {
[10:22:49.129]                         if (!is.null(pattern)) {
[10:22:49.129]                           computeRestarts <- base::computeRestarts
[10:22:49.129]                           grepl <- base::grepl
[10:22:49.129]                           restarts <- computeRestarts(cond)
[10:22:49.129]                           for (restart in restarts) {
[10:22:49.129]                             name <- restart$name
[10:22:49.129]                             if (is.null(name)) 
[10:22:49.129]                               next
[10:22:49.129]                             if (!grepl(pattern, name)) 
[10:22:49.129]                               next
[10:22:49.129]                             invokeRestart(restart)
[10:22:49.129]                             muffled <- TRUE
[10:22:49.129]                             break
[10:22:49.129]                           }
[10:22:49.129]                         }
[10:22:49.129]                       }
[10:22:49.129]                       invisible(muffled)
[10:22:49.129]                     }
[10:22:49.129]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.129]                   }
[10:22:49.129]                 }
[10:22:49.129]             }
[10:22:49.129]         }))
[10:22:49.129]     }, error = function(ex) {
[10:22:49.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.129]                 ...future.rng), started = ...future.startTime, 
[10:22:49.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.129]             version = "1.8"), class = "FutureResult")
[10:22:49.129]     }, finally = {
[10:22:49.129]         if (!identical(...future.workdir, getwd())) 
[10:22:49.129]             setwd(...future.workdir)
[10:22:49.129]         {
[10:22:49.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.129]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.129]             }
[10:22:49.129]             base::options(...future.oldOptions)
[10:22:49.129]             if (.Platform$OS.type == "windows") {
[10:22:49.129]                 old_names <- names(...future.oldEnvVars)
[10:22:49.129]                 envs <- base::Sys.getenv()
[10:22:49.129]                 names <- names(envs)
[10:22:49.129]                 common <- intersect(names, old_names)
[10:22:49.129]                 added <- setdiff(names, old_names)
[10:22:49.129]                 removed <- setdiff(old_names, names)
[10:22:49.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.129]                   envs[common]]
[10:22:49.129]                 NAMES <- toupper(changed)
[10:22:49.129]                 args <- list()
[10:22:49.129]                 for (kk in seq_along(NAMES)) {
[10:22:49.129]                   name <- changed[[kk]]
[10:22:49.129]                   NAME <- NAMES[[kk]]
[10:22:49.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.129]                     next
[10:22:49.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.129]                 }
[10:22:49.129]                 NAMES <- toupper(added)
[10:22:49.129]                 for (kk in seq_along(NAMES)) {
[10:22:49.129]                   name <- added[[kk]]
[10:22:49.129]                   NAME <- NAMES[[kk]]
[10:22:49.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.129]                     next
[10:22:49.129]                   args[[name]] <- ""
[10:22:49.129]                 }
[10:22:49.129]                 NAMES <- toupper(removed)
[10:22:49.129]                 for (kk in seq_along(NAMES)) {
[10:22:49.129]                   name <- removed[[kk]]
[10:22:49.129]                   NAME <- NAMES[[kk]]
[10:22:49.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.129]                     next
[10:22:49.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.129]                 }
[10:22:49.129]                 if (length(args) > 0) 
[10:22:49.129]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.129]             }
[10:22:49.129]             else {
[10:22:49.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.129]             }
[10:22:49.129]             {
[10:22:49.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.129]                   0L) {
[10:22:49.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.129]                   base::options(opts)
[10:22:49.129]                 }
[10:22:49.129]                 {
[10:22:49.129]                   {
[10:22:49.129]                     NULL
[10:22:49.129]                     RNGkind("Mersenne-Twister")
[10:22:49.129]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.129]                       inherits = FALSE)
[10:22:49.129]                   }
[10:22:49.129]                   options(future.plan = NULL)
[10:22:49.129]                   if (is.na(NA_character_)) 
[10:22:49.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.129]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.129]                     envir = parent.frame()) 
[10:22:49.129]                   {
[10:22:49.129]                     default_workers <- missing(workers)
[10:22:49.129]                     if (is.function(workers)) 
[10:22:49.129]                       workers <- workers()
[10:22:49.129]                     workers <- structure(as.integer(workers), 
[10:22:49.129]                       class = class(workers))
[10:22:49.129]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.129]                       1L)
[10:22:49.129]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.129]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.129]                       if (default_workers) 
[10:22:49.129]                         supportsMulticore(warn = TRUE)
[10:22:49.129]                       return(sequential(..., envir = envir))
[10:22:49.129]                     }
[10:22:49.129]                     oopts <- options(mc.cores = workers)
[10:22:49.129]                     on.exit(options(oopts))
[10:22:49.129]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.129]                       envir = envir)
[10:22:49.129]                     if (!future$lazy) 
[10:22:49.129]                       future <- run(future)
[10:22:49.129]                     invisible(future)
[10:22:49.129]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.129]                 }
[10:22:49.129]             }
[10:22:49.129]         }
[10:22:49.129]     })
[10:22:49.129]     if (TRUE) {
[10:22:49.129]         base::sink(type = "output", split = FALSE)
[10:22:49.129]         if (TRUE) {
[10:22:49.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.129]         }
[10:22:49.129]         else {
[10:22:49.129]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.129]         }
[10:22:49.129]         base::close(...future.stdout)
[10:22:49.129]         ...future.stdout <- NULL
[10:22:49.129]     }
[10:22:49.129]     ...future.result$conditions <- ...future.conditions
[10:22:49.129]     ...future.result$finished <- base::Sys.time()
[10:22:49.129]     ...future.result
[10:22:49.129] }
[10:22:49.131] assign_globals() ...
[10:22:49.131] List of 5
[10:22:49.131]  $ ...future.FUN            :function (object, ...)  
[10:22:49.131]  $ future.call.arguments    : list()
[10:22:49.131]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.131]  $ ...future.elements_ii    :List of 3
[10:22:49.131]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.131]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.131]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.131]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.131]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.131]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.131]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.131]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.131]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.131]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.131]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.131]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.131]  $ ...future.seeds_ii       : NULL
[10:22:49.131]  $ ...future.globals.maxSize: NULL
[10:22:49.131]  - attr(*, "where")=List of 5
[10:22:49.131]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.131]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.131]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.131]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.131]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.131]  - attr(*, "resolved")= logi FALSE
[10:22:49.131]  - attr(*, "total_size")= num 1240
[10:22:49.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.131]  - attr(*, "already-done")= logi TRUE
[10:22:49.141] - copied ‘...future.FUN’ to environment
[10:22:49.141] - copied ‘future.call.arguments’ to environment
[10:22:49.141] - copied ‘...future.elements_ii’ to environment
[10:22:49.141] - copied ‘...future.seeds_ii’ to environment
[10:22:49.141] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.142] assign_globals() ... done
[10:22:49.142] plan(): Setting new future strategy stack:
[10:22:49.142] List of future strategies:
[10:22:49.142] 1. sequential:
[10:22:49.142]    - args: function (..., envir = parent.frame())
[10:22:49.142]    - tweaked: FALSE
[10:22:49.142]    - call: NULL
[10:22:49.142] plan(): nbrOfWorkers() = 1
[10:22:49.144] plan(): Setting new future strategy stack:
[10:22:49.144] List of future strategies:
[10:22:49.144] 1. multicore:
[10:22:49.144]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.144]    - tweaked: FALSE
[10:22:49.144]    - call: plan(strategy)
[10:22:49.148] plan(): nbrOfWorkers() = 1
[10:22:49.148] SequentialFuture started (and completed)
[10:22:49.149] - Launch lazy future ... done
[10:22:49.149] run() for ‘SequentialFuture’ ... done
[10:22:49.149] Created future:
[10:22:49.149] SequentialFuture:
[10:22:49.149] Label: ‘future_by-1’
[10:22:49.149] Expression:
[10:22:49.149] {
[10:22:49.149]     do.call(function(...) {
[10:22:49.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.149]             on.exit(options(oopts), add = TRUE)
[10:22:49.149]         }
[10:22:49.149]         {
[10:22:49.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.149]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.149]             })
[10:22:49.149]         }
[10:22:49.149]     }, args = future.call.arguments)
[10:22:49.149] }
[10:22:49.149] Lazy evaluation: FALSE
[10:22:49.149] Asynchronous evaluation: FALSE
[10:22:49.149] Local evaluation: TRUE
[10:22:49.149] Environment: 0x55f639d3afe8
[10:22:49.149] Capture standard output: TRUE
[10:22:49.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.149] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.149] Packages: <none>
[10:22:49.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.149] Resolved: TRUE
[10:22:49.149] Value: 5.37 KiB of class ‘list’
[10:22:49.149] Early signaling: FALSE
[10:22:49.149] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.149] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.150] Chunk #1 of 1 ... DONE
[10:22:49.150] Launching 1 futures (chunks) ... DONE
[10:22:49.150] Resolving 1 futures (chunks) ...
[10:22:49.151] resolve() on list ...
[10:22:49.151]  recursive: 0
[10:22:49.151]  length: 1
[10:22:49.151] 
[10:22:49.151] resolved() for ‘SequentialFuture’ ...
[10:22:49.151] - state: ‘finished’
[10:22:49.151] - run: TRUE
[10:22:49.151] - result: ‘FutureResult’
[10:22:49.151] resolved() for ‘SequentialFuture’ ... done
[10:22:49.151] Future #1
[10:22:49.152] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.152] - nx: 1
[10:22:49.152] - relay: TRUE
[10:22:49.152] - stdout: TRUE
[10:22:49.152] - signal: TRUE
[10:22:49.152] - resignal: FALSE
[10:22:49.152] - force: TRUE
[10:22:49.152] - relayed: [n=1] FALSE
[10:22:49.152] - queued futures: [n=1] FALSE
[10:22:49.152]  - until=1
[10:22:49.152]  - relaying element #1
[10:22:49.153] - relayed: [n=1] TRUE
[10:22:49.153] - queued futures: [n=1] TRUE
[10:22:49.153] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.153]  length: 0 (resolved future 1)
[10:22:49.153] Relaying remaining futures
[10:22:49.153] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.153] - nx: 1
[10:22:49.153] - relay: TRUE
[10:22:49.153] - stdout: TRUE
[10:22:49.153] - signal: TRUE
[10:22:49.154] - resignal: FALSE
[10:22:49.154] - force: TRUE
[10:22:49.154] - relayed: [n=1] TRUE
[10:22:49.154] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.154] - relayed: [n=1] TRUE
[10:22:49.154] - queued futures: [n=1] TRUE
[10:22:49.154] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.154] resolve() on list ... DONE
[10:22:49.154]  - Number of value chunks collected: 1
[10:22:49.154] Resolving 1 futures (chunks) ... DONE
[10:22:49.155] Reducing values from 1 chunks ...
[10:22:49.155]  - Number of values collected after concatenation: 3
[10:22:49.155]  - Number of values expected: 3
[10:22:49.155] Reducing values from 1 chunks ... DONE
[10:22:49.155] future_lapply() ... DONE
[10:22:49.155] future_by_internal() ... DONE
[10:22:49.156] future_by_internal() ...
- plan('multisession') ...
[10:22:49.156] plan(): Setting new future strategy stack:
[10:22:49.156] List of future strategies:
[10:22:49.156] 1. multisession:
[10:22:49.156]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.156]    - tweaked: FALSE
[10:22:49.156]    - call: plan(strategy)
[10:22:49.157] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:49.157] multisession:
[10:22:49.157] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.157] - tweaked: FALSE
[10:22:49.157] - call: plan(strategy)
[10:22:49.160] getGlobalsAndPackages() ...
[10:22:49.161] Not searching for globals
[10:22:49.161] - globals: [0] <none>
[10:22:49.161] getGlobalsAndPackages() ... DONE
[10:22:49.161] Packages needed by the future expression (n = 0): <none>
[10:22:49.161] Packages needed by future strategies (n = 0): <none>
[10:22:49.162] {
[10:22:49.162]     {
[10:22:49.162]         {
[10:22:49.162]             ...future.startTime <- base::Sys.time()
[10:22:49.162]             {
[10:22:49.162]                 {
[10:22:49.162]                   {
[10:22:49.162]                     base::local({
[10:22:49.162]                       has_future <- base::requireNamespace("future", 
[10:22:49.162]                         quietly = TRUE)
[10:22:49.162]                       if (has_future) {
[10:22:49.162]                         ns <- base::getNamespace("future")
[10:22:49.162]                         version <- ns[[".package"]][["version"]]
[10:22:49.162]                         if (is.null(version)) 
[10:22:49.162]                           version <- utils::packageVersion("future")
[10:22:49.162]                       }
[10:22:49.162]                       else {
[10:22:49.162]                         version <- NULL
[10:22:49.162]                       }
[10:22:49.162]                       if (!has_future || version < "1.8.0") {
[10:22:49.162]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.162]                           "", base::R.version$version.string), 
[10:22:49.162]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.162]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.162]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.162]                             "release", "version")], collapse = " "), 
[10:22:49.162]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.162]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.162]                           info)
[10:22:49.162]                         info <- base::paste(info, collapse = "; ")
[10:22:49.162]                         if (!has_future) {
[10:22:49.162]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.162]                             info)
[10:22:49.162]                         }
[10:22:49.162]                         else {
[10:22:49.162]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.162]                             info, version)
[10:22:49.162]                         }
[10:22:49.162]                         base::stop(msg)
[10:22:49.162]                       }
[10:22:49.162]                     })
[10:22:49.162]                   }
[10:22:49.162]                   options(future.plan = NULL)
[10:22:49.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.162]                 }
[10:22:49.162]                 ...future.workdir <- getwd()
[10:22:49.162]             }
[10:22:49.162]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.162]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.162]         }
[10:22:49.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.162]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.162]             base::names(...future.oldOptions))
[10:22:49.162]     }
[10:22:49.162]     if (FALSE) {
[10:22:49.162]     }
[10:22:49.162]     else {
[10:22:49.162]         if (TRUE) {
[10:22:49.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.162]                 open = "w")
[10:22:49.162]         }
[10:22:49.162]         else {
[10:22:49.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.162]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.162]         }
[10:22:49.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.162]             base::sink(type = "output", split = FALSE)
[10:22:49.162]             base::close(...future.stdout)
[10:22:49.162]         }, add = TRUE)
[10:22:49.162]     }
[10:22:49.162]     ...future.frame <- base::sys.nframe()
[10:22:49.162]     ...future.conditions <- base::list()
[10:22:49.162]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.162]     if (FALSE) {
[10:22:49.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.162]     }
[10:22:49.162]     ...future.result <- base::tryCatch({
[10:22:49.162]         base::withCallingHandlers({
[10:22:49.162]             ...future.value <- base::withVisible(base::local(NA))
[10:22:49.162]             future::FutureResult(value = ...future.value$value, 
[10:22:49.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.162]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.162]                     ...future.globalenv.names))
[10:22:49.162]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.162]         }, condition = base::local({
[10:22:49.162]             c <- base::c
[10:22:49.162]             inherits <- base::inherits
[10:22:49.162]             invokeRestart <- base::invokeRestart
[10:22:49.162]             length <- base::length
[10:22:49.162]             list <- base::list
[10:22:49.162]             seq.int <- base::seq.int
[10:22:49.162]             signalCondition <- base::signalCondition
[10:22:49.162]             sys.calls <- base::sys.calls
[10:22:49.162]             `[[` <- base::`[[`
[10:22:49.162]             `+` <- base::`+`
[10:22:49.162]             `<<-` <- base::`<<-`
[10:22:49.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.162]                   3L)]
[10:22:49.162]             }
[10:22:49.162]             function(cond) {
[10:22:49.162]                 is_error <- inherits(cond, "error")
[10:22:49.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.162]                   NULL)
[10:22:49.162]                 if (is_error) {
[10:22:49.162]                   sessionInformation <- function() {
[10:22:49.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.162]                       search = base::search(), system = base::Sys.info())
[10:22:49.162]                   }
[10:22:49.162]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.162]                     cond$call), session = sessionInformation(), 
[10:22:49.162]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.162]                   signalCondition(cond)
[10:22:49.162]                 }
[10:22:49.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.162]                 "immediateCondition"))) {
[10:22:49.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.162]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.162]                   if (TRUE && !signal) {
[10:22:49.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.162]                     {
[10:22:49.162]                       inherits <- base::inherits
[10:22:49.162]                       invokeRestart <- base::invokeRestart
[10:22:49.162]                       is.null <- base::is.null
[10:22:49.162]                       muffled <- FALSE
[10:22:49.162]                       if (inherits(cond, "message")) {
[10:22:49.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.162]                         if (muffled) 
[10:22:49.162]                           invokeRestart("muffleMessage")
[10:22:49.162]                       }
[10:22:49.162]                       else if (inherits(cond, "warning")) {
[10:22:49.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.162]                         if (muffled) 
[10:22:49.162]                           invokeRestart("muffleWarning")
[10:22:49.162]                       }
[10:22:49.162]                       else if (inherits(cond, "condition")) {
[10:22:49.162]                         if (!is.null(pattern)) {
[10:22:49.162]                           computeRestarts <- base::computeRestarts
[10:22:49.162]                           grepl <- base::grepl
[10:22:49.162]                           restarts <- computeRestarts(cond)
[10:22:49.162]                           for (restart in restarts) {
[10:22:49.162]                             name <- restart$name
[10:22:49.162]                             if (is.null(name)) 
[10:22:49.162]                               next
[10:22:49.162]                             if (!grepl(pattern, name)) 
[10:22:49.162]                               next
[10:22:49.162]                             invokeRestart(restart)
[10:22:49.162]                             muffled <- TRUE
[10:22:49.162]                             break
[10:22:49.162]                           }
[10:22:49.162]                         }
[10:22:49.162]                       }
[10:22:49.162]                       invisible(muffled)
[10:22:49.162]                     }
[10:22:49.162]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.162]                   }
[10:22:49.162]                 }
[10:22:49.162]                 else {
[10:22:49.162]                   if (TRUE) {
[10:22:49.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.162]                     {
[10:22:49.162]                       inherits <- base::inherits
[10:22:49.162]                       invokeRestart <- base::invokeRestart
[10:22:49.162]                       is.null <- base::is.null
[10:22:49.162]                       muffled <- FALSE
[10:22:49.162]                       if (inherits(cond, "message")) {
[10:22:49.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.162]                         if (muffled) 
[10:22:49.162]                           invokeRestart("muffleMessage")
[10:22:49.162]                       }
[10:22:49.162]                       else if (inherits(cond, "warning")) {
[10:22:49.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.162]                         if (muffled) 
[10:22:49.162]                           invokeRestart("muffleWarning")
[10:22:49.162]                       }
[10:22:49.162]                       else if (inherits(cond, "condition")) {
[10:22:49.162]                         if (!is.null(pattern)) {
[10:22:49.162]                           computeRestarts <- base::computeRestarts
[10:22:49.162]                           grepl <- base::grepl
[10:22:49.162]                           restarts <- computeRestarts(cond)
[10:22:49.162]                           for (restart in restarts) {
[10:22:49.162]                             name <- restart$name
[10:22:49.162]                             if (is.null(name)) 
[10:22:49.162]                               next
[10:22:49.162]                             if (!grepl(pattern, name)) 
[10:22:49.162]                               next
[10:22:49.162]                             invokeRestart(restart)
[10:22:49.162]                             muffled <- TRUE
[10:22:49.162]                             break
[10:22:49.162]                           }
[10:22:49.162]                         }
[10:22:49.162]                       }
[10:22:49.162]                       invisible(muffled)
[10:22:49.162]                     }
[10:22:49.162]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.162]                   }
[10:22:49.162]                 }
[10:22:49.162]             }
[10:22:49.162]         }))
[10:22:49.162]     }, error = function(ex) {
[10:22:49.162]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.162]                 ...future.rng), started = ...future.startTime, 
[10:22:49.162]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.162]             version = "1.8"), class = "FutureResult")
[10:22:49.162]     }, finally = {
[10:22:49.162]         if (!identical(...future.workdir, getwd())) 
[10:22:49.162]             setwd(...future.workdir)
[10:22:49.162]         {
[10:22:49.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.162]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.162]             }
[10:22:49.162]             base::options(...future.oldOptions)
[10:22:49.162]             if (.Platform$OS.type == "windows") {
[10:22:49.162]                 old_names <- names(...future.oldEnvVars)
[10:22:49.162]                 envs <- base::Sys.getenv()
[10:22:49.162]                 names <- names(envs)
[10:22:49.162]                 common <- intersect(names, old_names)
[10:22:49.162]                 added <- setdiff(names, old_names)
[10:22:49.162]                 removed <- setdiff(old_names, names)
[10:22:49.162]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.162]                   envs[common]]
[10:22:49.162]                 NAMES <- toupper(changed)
[10:22:49.162]                 args <- list()
[10:22:49.162]                 for (kk in seq_along(NAMES)) {
[10:22:49.162]                   name <- changed[[kk]]
[10:22:49.162]                   NAME <- NAMES[[kk]]
[10:22:49.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.162]                     next
[10:22:49.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.162]                 }
[10:22:49.162]                 NAMES <- toupper(added)
[10:22:49.162]                 for (kk in seq_along(NAMES)) {
[10:22:49.162]                   name <- added[[kk]]
[10:22:49.162]                   NAME <- NAMES[[kk]]
[10:22:49.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.162]                     next
[10:22:49.162]                   args[[name]] <- ""
[10:22:49.162]                 }
[10:22:49.162]                 NAMES <- toupper(removed)
[10:22:49.162]                 for (kk in seq_along(NAMES)) {
[10:22:49.162]                   name <- removed[[kk]]
[10:22:49.162]                   NAME <- NAMES[[kk]]
[10:22:49.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.162]                     next
[10:22:49.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.162]                 }
[10:22:49.162]                 if (length(args) > 0) 
[10:22:49.162]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.162]             }
[10:22:49.162]             else {
[10:22:49.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.162]             }
[10:22:49.162]             {
[10:22:49.162]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.162]                   0L) {
[10:22:49.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.162]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.162]                   base::options(opts)
[10:22:49.162]                 }
[10:22:49.162]                 {
[10:22:49.162]                   {
[10:22:49.162]                     NULL
[10:22:49.162]                     RNGkind("Mersenne-Twister")
[10:22:49.162]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.162]                       inherits = FALSE)
[10:22:49.162]                   }
[10:22:49.162]                   options(future.plan = NULL)
[10:22:49.162]                   if (is.na(NA_character_)) 
[10:22:49.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.162]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.162]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.162]                     envir = parent.frame()) 
[10:22:49.162]                   {
[10:22:49.162]                     if (is.function(workers)) 
[10:22:49.162]                       workers <- workers()
[10:22:49.162]                     workers <- structure(as.integer(workers), 
[10:22:49.162]                       class = class(workers))
[10:22:49.162]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.162]                       workers >= 1)
[10:22:49.162]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.162]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.162]                     }
[10:22:49.162]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.162]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.162]                       envir = envir)
[10:22:49.162]                     if (!future$lazy) 
[10:22:49.162]                       future <- run(future)
[10:22:49.162]                     invisible(future)
[10:22:49.162]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.162]                 }
[10:22:49.162]             }
[10:22:49.162]         }
[10:22:49.162]     })
[10:22:49.162]     if (TRUE) {
[10:22:49.162]         base::sink(type = "output", split = FALSE)
[10:22:49.162]         if (TRUE) {
[10:22:49.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.162]         }
[10:22:49.162]         else {
[10:22:49.162]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.162]         }
[10:22:49.162]         base::close(...future.stdout)
[10:22:49.162]         ...future.stdout <- NULL
[10:22:49.162]     }
[10:22:49.162]     ...future.result$conditions <- ...future.conditions
[10:22:49.162]     ...future.result$finished <- base::Sys.time()
[10:22:49.162]     ...future.result
[10:22:49.162] }
[10:22:49.164] plan(): Setting new future strategy stack:
[10:22:49.164] List of future strategies:
[10:22:49.164] 1. sequential:
[10:22:49.164]    - args: function (..., envir = parent.frame())
[10:22:49.164]    - tweaked: FALSE
[10:22:49.164]    - call: NULL
[10:22:49.164] plan(): nbrOfWorkers() = 1
[10:22:49.165] plan(): Setting new future strategy stack:
[10:22:49.166] List of future strategies:
[10:22:49.166] 1. multisession:
[10:22:49.166]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.166]    - tweaked: FALSE
[10:22:49.166]    - call: plan(strategy)
[10:22:49.170] plan(): nbrOfWorkers() = 1
[10:22:49.170] SequentialFuture started (and completed)
[10:22:49.170] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:49.173] plan(): nbrOfWorkers() = 1
[10:22:49.174] future_by_internal() ...
[10:22:49.174] future_lapply() ...
[10:22:49.177] Number of chunks: 1
[10:22:49.177] getGlobalsAndPackagesXApply() ...
[10:22:49.177]  - future.globals: TRUE
[10:22:49.178] getGlobalsAndPackages() ...
[10:22:49.178] Searching for globals...
[10:22:49.179] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.179] Searching for globals ... DONE
[10:22:49.179] Resolving globals: FALSE
[10:22:49.179] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.180] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.180] - globals: [1] ‘FUN’
[10:22:49.180] 
[10:22:49.180] getGlobalsAndPackages() ... DONE
[10:22:49.180]  - globals found/used: [n=1] ‘FUN’
[10:22:49.180]  - needed namespaces: [n=0] 
[10:22:49.180] Finding globals ... DONE
[10:22:49.180]  - use_args: TRUE
[10:22:49.180]  - Getting '...' globals ...
[10:22:49.181] resolve() on list ...
[10:22:49.181]  recursive: 0
[10:22:49.181]  length: 1
[10:22:49.181]  elements: ‘...’
[10:22:49.181]  length: 0 (resolved future 1)
[10:22:49.181] resolve() on list ... DONE
[10:22:49.181]    - '...' content: [n=0] 
[10:22:49.181] List of 1
[10:22:49.181]  $ ...: list()
[10:22:49.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.181]  - attr(*, "where")=List of 1
[10:22:49.181]   ..$ ...:<environment: 0x55f6390f5bb0> 
[10:22:49.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.181]  - attr(*, "resolved")= logi TRUE
[10:22:49.181]  - attr(*, "total_size")= num NA
[10:22:49.184]  - Getting '...' globals ... DONE
[10:22:49.184] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.184] List of 2
[10:22:49.184]  $ ...future.FUN:function (object, ...)  
[10:22:49.184]  $ ...          : list()
[10:22:49.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.184]  - attr(*, "where")=List of 2
[10:22:49.184]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.184]   ..$ ...          :<environment: 0x55f6390f5bb0> 
[10:22:49.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.184]  - attr(*, "resolved")= logi FALSE
[10:22:49.184]  - attr(*, "total_size")= num 1240
[10:22:49.187] Packages to be attached in all futures: [n=0] 
[10:22:49.187] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.187] Number of futures (= number of chunks): 1
[10:22:49.187] Launching 1 futures (chunks) ...
[10:22:49.187] Chunk #1 of 1 ...
[10:22:49.187]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.188] getGlobalsAndPackages() ...
[10:22:49.188] Searching for globals...
[10:22:49.188] 
[10:22:49.188] Searching for globals ... DONE
[10:22:49.188] - globals: [0] <none>
[10:22:49.188] getGlobalsAndPackages() ... DONE
[10:22:49.188]    + additional globals found: [n=0] 
[10:22:49.188]    + additional namespaces needed: [n=0] 
[10:22:49.189]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.189]  - seeds: <none>
[10:22:49.189]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.189] getGlobalsAndPackages() ...
[10:22:49.189] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.189] Resolving globals: FALSE
[10:22:49.189] Tweak future expression to call with '...' arguments ...
[10:22:49.189] {
[10:22:49.189]     do.call(function(...) {
[10:22:49.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.189]             on.exit(options(oopts), add = TRUE)
[10:22:49.189]         }
[10:22:49.189]         {
[10:22:49.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.189]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.189]             })
[10:22:49.189]         }
[10:22:49.189]     }, args = future.call.arguments)
[10:22:49.189] }
[10:22:49.190] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.190] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.190] 
[10:22:49.190] getGlobalsAndPackages() ... DONE
[10:22:49.190] run() for ‘Future’ ...
[10:22:49.190] - state: ‘created’
[10:22:49.191] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.194] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.194]   - Field: ‘label’
[10:22:49.194]   - Field: ‘local’
[10:22:49.195]   - Field: ‘owner’
[10:22:49.196]   - Field: ‘envir’
[10:22:49.196]   - Field: ‘packages’
[10:22:49.196]   - Field: ‘gc’
[10:22:49.196]   - Field: ‘conditions’
[10:22:49.196]   - Field: ‘expr’
[10:22:49.196]   - Field: ‘uuid’
[10:22:49.196]   - Field: ‘seed’
[10:22:49.196]   - Field: ‘version’
[10:22:49.196]   - Field: ‘result’
[10:22:49.197]   - Field: ‘asynchronous’
[10:22:49.197]   - Field: ‘calls’
[10:22:49.197]   - Field: ‘globals’
[10:22:49.197]   - Field: ‘stdout’
[10:22:49.197]   - Field: ‘earlySignal’
[10:22:49.197]   - Field: ‘lazy’
[10:22:49.197]   - Field: ‘state’
[10:22:49.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.197] - Launch lazy future ...
[10:22:49.198] Packages needed by the future expression (n = 0): <none>
[10:22:49.198] Packages needed by future strategies (n = 0): <none>
[10:22:49.198] {
[10:22:49.198]     {
[10:22:49.198]         {
[10:22:49.198]             ...future.startTime <- base::Sys.time()
[10:22:49.198]             {
[10:22:49.198]                 {
[10:22:49.198]                   {
[10:22:49.198]                     base::local({
[10:22:49.198]                       has_future <- base::requireNamespace("future", 
[10:22:49.198]                         quietly = TRUE)
[10:22:49.198]                       if (has_future) {
[10:22:49.198]                         ns <- base::getNamespace("future")
[10:22:49.198]                         version <- ns[[".package"]][["version"]]
[10:22:49.198]                         if (is.null(version)) 
[10:22:49.198]                           version <- utils::packageVersion("future")
[10:22:49.198]                       }
[10:22:49.198]                       else {
[10:22:49.198]                         version <- NULL
[10:22:49.198]                       }
[10:22:49.198]                       if (!has_future || version < "1.8.0") {
[10:22:49.198]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.198]                           "", base::R.version$version.string), 
[10:22:49.198]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.198]                             "release", "version")], collapse = " "), 
[10:22:49.198]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.198]                           info)
[10:22:49.198]                         info <- base::paste(info, collapse = "; ")
[10:22:49.198]                         if (!has_future) {
[10:22:49.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.198]                             info)
[10:22:49.198]                         }
[10:22:49.198]                         else {
[10:22:49.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.198]                             info, version)
[10:22:49.198]                         }
[10:22:49.198]                         base::stop(msg)
[10:22:49.198]                       }
[10:22:49.198]                     })
[10:22:49.198]                   }
[10:22:49.198]                   options(future.plan = NULL)
[10:22:49.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.198]                 }
[10:22:49.198]                 ...future.workdir <- getwd()
[10:22:49.198]             }
[10:22:49.198]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.198]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.198]         }
[10:22:49.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.198]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.198]             base::names(...future.oldOptions))
[10:22:49.198]     }
[10:22:49.198]     if (FALSE) {
[10:22:49.198]     }
[10:22:49.198]     else {
[10:22:49.198]         if (TRUE) {
[10:22:49.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.198]                 open = "w")
[10:22:49.198]         }
[10:22:49.198]         else {
[10:22:49.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.198]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.198]         }
[10:22:49.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.198]             base::sink(type = "output", split = FALSE)
[10:22:49.198]             base::close(...future.stdout)
[10:22:49.198]         }, add = TRUE)
[10:22:49.198]     }
[10:22:49.198]     ...future.frame <- base::sys.nframe()
[10:22:49.198]     ...future.conditions <- base::list()
[10:22:49.198]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.198]     if (FALSE) {
[10:22:49.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.198]     }
[10:22:49.198]     ...future.result <- base::tryCatch({
[10:22:49.198]         base::withCallingHandlers({
[10:22:49.198]             ...future.value <- base::withVisible(base::local({
[10:22:49.198]                 do.call(function(...) {
[10:22:49.198]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.198]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.198]                     ...future.globals.maxSize)) {
[10:22:49.198]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.198]                     on.exit(options(oopts), add = TRUE)
[10:22:49.198]                   }
[10:22:49.198]                   {
[10:22:49.198]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.198]                       FUN = function(jj) {
[10:22:49.198]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.198]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.198]                       })
[10:22:49.198]                   }
[10:22:49.198]                 }, args = future.call.arguments)
[10:22:49.198]             }))
[10:22:49.198]             future::FutureResult(value = ...future.value$value, 
[10:22:49.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.198]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.198]                     ...future.globalenv.names))
[10:22:49.198]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.198]         }, condition = base::local({
[10:22:49.198]             c <- base::c
[10:22:49.198]             inherits <- base::inherits
[10:22:49.198]             invokeRestart <- base::invokeRestart
[10:22:49.198]             length <- base::length
[10:22:49.198]             list <- base::list
[10:22:49.198]             seq.int <- base::seq.int
[10:22:49.198]             signalCondition <- base::signalCondition
[10:22:49.198]             sys.calls <- base::sys.calls
[10:22:49.198]             `[[` <- base::`[[`
[10:22:49.198]             `+` <- base::`+`
[10:22:49.198]             `<<-` <- base::`<<-`
[10:22:49.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.198]                   3L)]
[10:22:49.198]             }
[10:22:49.198]             function(cond) {
[10:22:49.198]                 is_error <- inherits(cond, "error")
[10:22:49.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.198]                   NULL)
[10:22:49.198]                 if (is_error) {
[10:22:49.198]                   sessionInformation <- function() {
[10:22:49.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.198]                       search = base::search(), system = base::Sys.info())
[10:22:49.198]                   }
[10:22:49.198]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.198]                     cond$call), session = sessionInformation(), 
[10:22:49.198]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.198]                   signalCondition(cond)
[10:22:49.198]                 }
[10:22:49.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.198]                 "immediateCondition"))) {
[10:22:49.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.198]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.198]                   if (TRUE && !signal) {
[10:22:49.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.198]                     {
[10:22:49.198]                       inherits <- base::inherits
[10:22:49.198]                       invokeRestart <- base::invokeRestart
[10:22:49.198]                       is.null <- base::is.null
[10:22:49.198]                       muffled <- FALSE
[10:22:49.198]                       if (inherits(cond, "message")) {
[10:22:49.198]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.198]                         if (muffled) 
[10:22:49.198]                           invokeRestart("muffleMessage")
[10:22:49.198]                       }
[10:22:49.198]                       else if (inherits(cond, "warning")) {
[10:22:49.198]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.198]                         if (muffled) 
[10:22:49.198]                           invokeRestart("muffleWarning")
[10:22:49.198]                       }
[10:22:49.198]                       else if (inherits(cond, "condition")) {
[10:22:49.198]                         if (!is.null(pattern)) {
[10:22:49.198]                           computeRestarts <- base::computeRestarts
[10:22:49.198]                           grepl <- base::grepl
[10:22:49.198]                           restarts <- computeRestarts(cond)
[10:22:49.198]                           for (restart in restarts) {
[10:22:49.198]                             name <- restart$name
[10:22:49.198]                             if (is.null(name)) 
[10:22:49.198]                               next
[10:22:49.198]                             if (!grepl(pattern, name)) 
[10:22:49.198]                               next
[10:22:49.198]                             invokeRestart(restart)
[10:22:49.198]                             muffled <- TRUE
[10:22:49.198]                             break
[10:22:49.198]                           }
[10:22:49.198]                         }
[10:22:49.198]                       }
[10:22:49.198]                       invisible(muffled)
[10:22:49.198]                     }
[10:22:49.198]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.198]                   }
[10:22:49.198]                 }
[10:22:49.198]                 else {
[10:22:49.198]                   if (TRUE) {
[10:22:49.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.198]                     {
[10:22:49.198]                       inherits <- base::inherits
[10:22:49.198]                       invokeRestart <- base::invokeRestart
[10:22:49.198]                       is.null <- base::is.null
[10:22:49.198]                       muffled <- FALSE
[10:22:49.198]                       if (inherits(cond, "message")) {
[10:22:49.198]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.198]                         if (muffled) 
[10:22:49.198]                           invokeRestart("muffleMessage")
[10:22:49.198]                       }
[10:22:49.198]                       else if (inherits(cond, "warning")) {
[10:22:49.198]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.198]                         if (muffled) 
[10:22:49.198]                           invokeRestart("muffleWarning")
[10:22:49.198]                       }
[10:22:49.198]                       else if (inherits(cond, "condition")) {
[10:22:49.198]                         if (!is.null(pattern)) {
[10:22:49.198]                           computeRestarts <- base::computeRestarts
[10:22:49.198]                           grepl <- base::grepl
[10:22:49.198]                           restarts <- computeRestarts(cond)
[10:22:49.198]                           for (restart in restarts) {
[10:22:49.198]                             name <- restart$name
[10:22:49.198]                             if (is.null(name)) 
[10:22:49.198]                               next
[10:22:49.198]                             if (!grepl(pattern, name)) 
[10:22:49.198]                               next
[10:22:49.198]                             invokeRestart(restart)
[10:22:49.198]                             muffled <- TRUE
[10:22:49.198]                             break
[10:22:49.198]                           }
[10:22:49.198]                         }
[10:22:49.198]                       }
[10:22:49.198]                       invisible(muffled)
[10:22:49.198]                     }
[10:22:49.198]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.198]                   }
[10:22:49.198]                 }
[10:22:49.198]             }
[10:22:49.198]         }))
[10:22:49.198]     }, error = function(ex) {
[10:22:49.198]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.198]                 ...future.rng), started = ...future.startTime, 
[10:22:49.198]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.198]             version = "1.8"), class = "FutureResult")
[10:22:49.198]     }, finally = {
[10:22:49.198]         if (!identical(...future.workdir, getwd())) 
[10:22:49.198]             setwd(...future.workdir)
[10:22:49.198]         {
[10:22:49.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.198]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.198]             }
[10:22:49.198]             base::options(...future.oldOptions)
[10:22:49.198]             if (.Platform$OS.type == "windows") {
[10:22:49.198]                 old_names <- names(...future.oldEnvVars)
[10:22:49.198]                 envs <- base::Sys.getenv()
[10:22:49.198]                 names <- names(envs)
[10:22:49.198]                 common <- intersect(names, old_names)
[10:22:49.198]                 added <- setdiff(names, old_names)
[10:22:49.198]                 removed <- setdiff(old_names, names)
[10:22:49.198]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.198]                   envs[common]]
[10:22:49.198]                 NAMES <- toupper(changed)
[10:22:49.198]                 args <- list()
[10:22:49.198]                 for (kk in seq_along(NAMES)) {
[10:22:49.198]                   name <- changed[[kk]]
[10:22:49.198]                   NAME <- NAMES[[kk]]
[10:22:49.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.198]                     next
[10:22:49.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.198]                 }
[10:22:49.198]                 NAMES <- toupper(added)
[10:22:49.198]                 for (kk in seq_along(NAMES)) {
[10:22:49.198]                   name <- added[[kk]]
[10:22:49.198]                   NAME <- NAMES[[kk]]
[10:22:49.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.198]                     next
[10:22:49.198]                   args[[name]] <- ""
[10:22:49.198]                 }
[10:22:49.198]                 NAMES <- toupper(removed)
[10:22:49.198]                 for (kk in seq_along(NAMES)) {
[10:22:49.198]                   name <- removed[[kk]]
[10:22:49.198]                   NAME <- NAMES[[kk]]
[10:22:49.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.198]                     next
[10:22:49.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.198]                 }
[10:22:49.198]                 if (length(args) > 0) 
[10:22:49.198]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.198]             }
[10:22:49.198]             else {
[10:22:49.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.198]             }
[10:22:49.198]             {
[10:22:49.198]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.198]                   0L) {
[10:22:49.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.198]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.198]                   base::options(opts)
[10:22:49.198]                 }
[10:22:49.198]                 {
[10:22:49.198]                   {
[10:22:49.198]                     NULL
[10:22:49.198]                     RNGkind("Mersenne-Twister")
[10:22:49.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.198]                       inherits = FALSE)
[10:22:49.198]                   }
[10:22:49.198]                   options(future.plan = NULL)
[10:22:49.198]                   if (is.na(NA_character_)) 
[10:22:49.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.198]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.198]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.198]                     envir = parent.frame()) 
[10:22:49.198]                   {
[10:22:49.198]                     if (is.function(workers)) 
[10:22:49.198]                       workers <- workers()
[10:22:49.198]                     workers <- structure(as.integer(workers), 
[10:22:49.198]                       class = class(workers))
[10:22:49.198]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.198]                       workers >= 1)
[10:22:49.198]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.198]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.198]                     }
[10:22:49.198]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.198]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.198]                       envir = envir)
[10:22:49.198]                     if (!future$lazy) 
[10:22:49.198]                       future <- run(future)
[10:22:49.198]                     invisible(future)
[10:22:49.198]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.198]                 }
[10:22:49.198]             }
[10:22:49.198]         }
[10:22:49.198]     })
[10:22:49.198]     if (TRUE) {
[10:22:49.198]         base::sink(type = "output", split = FALSE)
[10:22:49.198]         if (TRUE) {
[10:22:49.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.198]         }
[10:22:49.198]         else {
[10:22:49.198]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.198]         }
[10:22:49.198]         base::close(...future.stdout)
[10:22:49.198]         ...future.stdout <- NULL
[10:22:49.198]     }
[10:22:49.198]     ...future.result$conditions <- ...future.conditions
[10:22:49.198]     ...future.result$finished <- base::Sys.time()
[10:22:49.198]     ...future.result
[10:22:49.198] }
[10:22:49.200] assign_globals() ...
[10:22:49.200] List of 5
[10:22:49.200]  $ ...future.FUN            :function (object, ...)  
[10:22:49.200]  $ future.call.arguments    : list()
[10:22:49.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.200]  $ ...future.elements_ii    :List of 3
[10:22:49.200]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.200]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.200]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.200]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.200]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.200]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.200]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.200]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.200]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.200]  $ ...future.seeds_ii       : NULL
[10:22:49.200]  $ ...future.globals.maxSize: NULL
[10:22:49.200]  - attr(*, "where")=List of 5
[10:22:49.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.200]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.200]  - attr(*, "resolved")= logi FALSE
[10:22:49.200]  - attr(*, "total_size")= num 1240
[10:22:49.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.200]  - attr(*, "already-done")= logi TRUE
[10:22:49.207] - copied ‘...future.FUN’ to environment
[10:22:49.207] - copied ‘future.call.arguments’ to environment
[10:22:49.207] - copied ‘...future.elements_ii’ to environment
[10:22:49.208] - copied ‘...future.seeds_ii’ to environment
[10:22:49.208] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.208] assign_globals() ... done
[10:22:49.208] plan(): Setting new future strategy stack:
[10:22:49.208] List of future strategies:
[10:22:49.208] 1. sequential:
[10:22:49.208]    - args: function (..., envir = parent.frame())
[10:22:49.208]    - tweaked: FALSE
[10:22:49.208]    - call: NULL
[10:22:49.208] plan(): nbrOfWorkers() = 1
[10:22:49.210] plan(): Setting new future strategy stack:
[10:22:49.210] List of future strategies:
[10:22:49.210] 1. multisession:
[10:22:49.210]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.210]    - tweaked: FALSE
[10:22:49.210]    - call: plan(strategy)
[10:22:49.214] plan(): nbrOfWorkers() = 1
[10:22:49.214] SequentialFuture started (and completed)
[10:22:49.214] - Launch lazy future ... done
[10:22:49.214] run() for ‘SequentialFuture’ ... done
[10:22:49.214] Created future:
[10:22:49.214] SequentialFuture:
[10:22:49.214] Label: ‘future_by-1’
[10:22:49.214] Expression:
[10:22:49.214] {
[10:22:49.214]     do.call(function(...) {
[10:22:49.214]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.214]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.214]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.214]             on.exit(options(oopts), add = TRUE)
[10:22:49.214]         }
[10:22:49.214]         {
[10:22:49.214]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.214]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.214]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.214]             })
[10:22:49.214]         }
[10:22:49.214]     }, args = future.call.arguments)
[10:22:49.214] }
[10:22:49.214] Lazy evaluation: FALSE
[10:22:49.214] Asynchronous evaluation: FALSE
[10:22:49.214] Local evaluation: TRUE
[10:22:49.214] Environment: R_GlobalEnv
[10:22:49.214] Capture standard output: TRUE
[10:22:49.214] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.214] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.214] Packages: <none>
[10:22:49.214] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.214] Resolved: TRUE
[10:22:49.214] Value: 4.62 KiB of class ‘list’
[10:22:49.214] Early signaling: FALSE
[10:22:49.214] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.214] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.215] Chunk #1 of 1 ... DONE
[10:22:49.215] Launching 1 futures (chunks) ... DONE
[10:22:49.216] Resolving 1 futures (chunks) ...
[10:22:49.216] resolve() on list ...
[10:22:49.216]  recursive: 0
[10:22:49.216]  length: 1
[10:22:49.216] 
[10:22:49.216] resolved() for ‘SequentialFuture’ ...
[10:22:49.216] - state: ‘finished’
[10:22:49.216] - run: TRUE
[10:22:49.216] - result: ‘FutureResult’
[10:22:49.216] resolved() for ‘SequentialFuture’ ... done
[10:22:49.217] Future #1
[10:22:49.217] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.217] - nx: 1
[10:22:49.217] - relay: TRUE
[10:22:49.217] - stdout: TRUE
[10:22:49.217] - signal: TRUE
[10:22:49.217] - resignal: FALSE
[10:22:49.217] - force: TRUE
[10:22:49.217] - relayed: [n=1] FALSE
[10:22:49.217] - queued futures: [n=1] FALSE
[10:22:49.217]  - until=1
[10:22:49.218]  - relaying element #1
[10:22:49.218] - relayed: [n=1] TRUE
[10:22:49.218] - queued futures: [n=1] TRUE
[10:22:49.218] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.219]  length: 0 (resolved future 1)
[10:22:49.219] Relaying remaining futures
[10:22:49.220] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.220] - nx: 1
[10:22:49.220] - relay: TRUE
[10:22:49.220] - stdout: TRUE
[10:22:49.220] - signal: TRUE
[10:22:49.220] - resignal: FALSE
[10:22:49.220] - force: TRUE
[10:22:49.220] - relayed: [n=1] TRUE
[10:22:49.220] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.220] - relayed: [n=1] TRUE
[10:22:49.220] - queued futures: [n=1] TRUE
[10:22:49.221] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.221] resolve() on list ... DONE
[10:22:49.221]  - Number of value chunks collected: 1
[10:22:49.221] Resolving 1 futures (chunks) ... DONE
[10:22:49.221] Reducing values from 1 chunks ...
[10:22:49.221]  - Number of values collected after concatenation: 3
[10:22:49.221]  - Number of values expected: 3
[10:22:49.221] Reducing values from 1 chunks ... DONE
[10:22:49.221] future_lapply() ... DONE
[10:22:49.222] future_by_internal() ... DONE
[10:22:49.222] future_by_internal() ...
[10:22:49.222] future_lapply() ...
[10:22:49.226] Number of chunks: 1
[10:22:49.226] getGlobalsAndPackagesXApply() ...
[10:22:49.226]  - future.globals: TRUE
[10:22:49.226] getGlobalsAndPackages() ...
[10:22:49.226] Searching for globals...
[10:22:49.227] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.227] Searching for globals ... DONE
[10:22:49.227] Resolving globals: FALSE
[10:22:49.227] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.228] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.228] - globals: [1] ‘FUN’
[10:22:49.228] 
[10:22:49.228] getGlobalsAndPackages() ... DONE
[10:22:49.228]  - globals found/used: [n=1] ‘FUN’
[10:22:49.228]  - needed namespaces: [n=0] 
[10:22:49.228] Finding globals ... DONE
[10:22:49.228]  - use_args: TRUE
[10:22:49.229]  - Getting '...' globals ...
[10:22:49.229] resolve() on list ...
[10:22:49.229]  recursive: 0
[10:22:49.229]  length: 1
[10:22:49.229]  elements: ‘...’
[10:22:49.229]  length: 0 (resolved future 1)
[10:22:49.229] resolve() on list ... DONE
[10:22:49.229]    - '...' content: [n=1] ‘digits’
[10:22:49.230] List of 1
[10:22:49.230]  $ ...:List of 1
[10:22:49.230]   ..$ digits: int 2
[10:22:49.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.230]  - attr(*, "where")=List of 1
[10:22:49.230]   ..$ ...:<environment: 0x55f639146a70> 
[10:22:49.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.230]  - attr(*, "resolved")= logi TRUE
[10:22:49.230]  - attr(*, "total_size")= num NA
[10:22:49.232]  - Getting '...' globals ... DONE
[10:22:49.233] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.233] List of 2
[10:22:49.233]  $ ...future.FUN:function (object, ...)  
[10:22:49.233]  $ ...          :List of 1
[10:22:49.233]   ..$ digits: int 2
[10:22:49.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.233]  - attr(*, "where")=List of 2
[10:22:49.233]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.233]   ..$ ...          :<environment: 0x55f639146a70> 
[10:22:49.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.233]  - attr(*, "resolved")= logi FALSE
[10:22:49.233]  - attr(*, "total_size")= num 1296
[10:22:49.236] Packages to be attached in all futures: [n=0] 
[10:22:49.236] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.236] Number of futures (= number of chunks): 1
[10:22:49.236] Launching 1 futures (chunks) ...
[10:22:49.236] Chunk #1 of 1 ...
[10:22:49.236]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.236] getGlobalsAndPackages() ...
[10:22:49.236] Searching for globals...
[10:22:49.237] 
[10:22:49.237] Searching for globals ... DONE
[10:22:49.237] - globals: [0] <none>
[10:22:49.237] getGlobalsAndPackages() ... DONE
[10:22:49.237]    + additional globals found: [n=0] 
[10:22:49.237]    + additional namespaces needed: [n=0] 
[10:22:49.237]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.237]  - seeds: <none>
[10:22:49.237]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.237] getGlobalsAndPackages() ...
[10:22:49.238] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.238] Resolving globals: FALSE
[10:22:49.238] Tweak future expression to call with '...' arguments ...
[10:22:49.238] {
[10:22:49.238]     do.call(function(...) {
[10:22:49.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.238]             on.exit(options(oopts), add = TRUE)
[10:22:49.238]         }
[10:22:49.238]         {
[10:22:49.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.238]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.238]             })
[10:22:49.238]         }
[10:22:49.238]     }, args = future.call.arguments)
[10:22:49.238] }
[10:22:49.238] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.238] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.239] 
[10:22:49.239] getGlobalsAndPackages() ... DONE
[10:22:49.239] run() for ‘Future’ ...
[10:22:49.239] - state: ‘created’
[10:22:49.239] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.244]   - Field: ‘label’
[10:22:49.244]   - Field: ‘local’
[10:22:49.244]   - Field: ‘owner’
[10:22:49.244]   - Field: ‘envir’
[10:22:49.245]   - Field: ‘packages’
[10:22:49.245]   - Field: ‘gc’
[10:22:49.245]   - Field: ‘conditions’
[10:22:49.245]   - Field: ‘expr’
[10:22:49.245]   - Field: ‘uuid’
[10:22:49.245]   - Field: ‘seed’
[10:22:49.245]   - Field: ‘version’
[10:22:49.245]   - Field: ‘result’
[10:22:49.245]   - Field: ‘asynchronous’
[10:22:49.245]   - Field: ‘calls’
[10:22:49.246]   - Field: ‘globals’
[10:22:49.246]   - Field: ‘stdout’
[10:22:49.246]   - Field: ‘earlySignal’
[10:22:49.246]   - Field: ‘lazy’
[10:22:49.246]   - Field: ‘state’
[10:22:49.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.246] - Launch lazy future ...
[10:22:49.246] Packages needed by the future expression (n = 0): <none>
[10:22:49.246] Packages needed by future strategies (n = 0): <none>
[10:22:49.247] {
[10:22:49.247]     {
[10:22:49.247]         {
[10:22:49.247]             ...future.startTime <- base::Sys.time()
[10:22:49.247]             {
[10:22:49.247]                 {
[10:22:49.247]                   {
[10:22:49.247]                     base::local({
[10:22:49.247]                       has_future <- base::requireNamespace("future", 
[10:22:49.247]                         quietly = TRUE)
[10:22:49.247]                       if (has_future) {
[10:22:49.247]                         ns <- base::getNamespace("future")
[10:22:49.247]                         version <- ns[[".package"]][["version"]]
[10:22:49.247]                         if (is.null(version)) 
[10:22:49.247]                           version <- utils::packageVersion("future")
[10:22:49.247]                       }
[10:22:49.247]                       else {
[10:22:49.247]                         version <- NULL
[10:22:49.247]                       }
[10:22:49.247]                       if (!has_future || version < "1.8.0") {
[10:22:49.247]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.247]                           "", base::R.version$version.string), 
[10:22:49.247]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.247]                             "release", "version")], collapse = " "), 
[10:22:49.247]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.247]                           info)
[10:22:49.247]                         info <- base::paste(info, collapse = "; ")
[10:22:49.247]                         if (!has_future) {
[10:22:49.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.247]                             info)
[10:22:49.247]                         }
[10:22:49.247]                         else {
[10:22:49.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.247]                             info, version)
[10:22:49.247]                         }
[10:22:49.247]                         base::stop(msg)
[10:22:49.247]                       }
[10:22:49.247]                     })
[10:22:49.247]                   }
[10:22:49.247]                   options(future.plan = NULL)
[10:22:49.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.247]                 }
[10:22:49.247]                 ...future.workdir <- getwd()
[10:22:49.247]             }
[10:22:49.247]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.247]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.247]         }
[10:22:49.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.247]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.247]             base::names(...future.oldOptions))
[10:22:49.247]     }
[10:22:49.247]     if (FALSE) {
[10:22:49.247]     }
[10:22:49.247]     else {
[10:22:49.247]         if (TRUE) {
[10:22:49.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.247]                 open = "w")
[10:22:49.247]         }
[10:22:49.247]         else {
[10:22:49.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.247]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.247]         }
[10:22:49.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.247]             base::sink(type = "output", split = FALSE)
[10:22:49.247]             base::close(...future.stdout)
[10:22:49.247]         }, add = TRUE)
[10:22:49.247]     }
[10:22:49.247]     ...future.frame <- base::sys.nframe()
[10:22:49.247]     ...future.conditions <- base::list()
[10:22:49.247]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.247]     if (FALSE) {
[10:22:49.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.247]     }
[10:22:49.247]     ...future.result <- base::tryCatch({
[10:22:49.247]         base::withCallingHandlers({
[10:22:49.247]             ...future.value <- base::withVisible(base::local({
[10:22:49.247]                 do.call(function(...) {
[10:22:49.247]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.247]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.247]                     ...future.globals.maxSize)) {
[10:22:49.247]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.247]                     on.exit(options(oopts), add = TRUE)
[10:22:49.247]                   }
[10:22:49.247]                   {
[10:22:49.247]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.247]                       FUN = function(jj) {
[10:22:49.247]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.247]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.247]                       })
[10:22:49.247]                   }
[10:22:49.247]                 }, args = future.call.arguments)
[10:22:49.247]             }))
[10:22:49.247]             future::FutureResult(value = ...future.value$value, 
[10:22:49.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.247]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.247]                     ...future.globalenv.names))
[10:22:49.247]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.247]         }, condition = base::local({
[10:22:49.247]             c <- base::c
[10:22:49.247]             inherits <- base::inherits
[10:22:49.247]             invokeRestart <- base::invokeRestart
[10:22:49.247]             length <- base::length
[10:22:49.247]             list <- base::list
[10:22:49.247]             seq.int <- base::seq.int
[10:22:49.247]             signalCondition <- base::signalCondition
[10:22:49.247]             sys.calls <- base::sys.calls
[10:22:49.247]             `[[` <- base::`[[`
[10:22:49.247]             `+` <- base::`+`
[10:22:49.247]             `<<-` <- base::`<<-`
[10:22:49.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.247]                   3L)]
[10:22:49.247]             }
[10:22:49.247]             function(cond) {
[10:22:49.247]                 is_error <- inherits(cond, "error")
[10:22:49.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.247]                   NULL)
[10:22:49.247]                 if (is_error) {
[10:22:49.247]                   sessionInformation <- function() {
[10:22:49.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.247]                       search = base::search(), system = base::Sys.info())
[10:22:49.247]                   }
[10:22:49.247]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.247]                     cond$call), session = sessionInformation(), 
[10:22:49.247]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.247]                   signalCondition(cond)
[10:22:49.247]                 }
[10:22:49.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.247]                 "immediateCondition"))) {
[10:22:49.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.247]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.247]                   if (TRUE && !signal) {
[10:22:49.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.247]                     {
[10:22:49.247]                       inherits <- base::inherits
[10:22:49.247]                       invokeRestart <- base::invokeRestart
[10:22:49.247]                       is.null <- base::is.null
[10:22:49.247]                       muffled <- FALSE
[10:22:49.247]                       if (inherits(cond, "message")) {
[10:22:49.247]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.247]                         if (muffled) 
[10:22:49.247]                           invokeRestart("muffleMessage")
[10:22:49.247]                       }
[10:22:49.247]                       else if (inherits(cond, "warning")) {
[10:22:49.247]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.247]                         if (muffled) 
[10:22:49.247]                           invokeRestart("muffleWarning")
[10:22:49.247]                       }
[10:22:49.247]                       else if (inherits(cond, "condition")) {
[10:22:49.247]                         if (!is.null(pattern)) {
[10:22:49.247]                           computeRestarts <- base::computeRestarts
[10:22:49.247]                           grepl <- base::grepl
[10:22:49.247]                           restarts <- computeRestarts(cond)
[10:22:49.247]                           for (restart in restarts) {
[10:22:49.247]                             name <- restart$name
[10:22:49.247]                             if (is.null(name)) 
[10:22:49.247]                               next
[10:22:49.247]                             if (!grepl(pattern, name)) 
[10:22:49.247]                               next
[10:22:49.247]                             invokeRestart(restart)
[10:22:49.247]                             muffled <- TRUE
[10:22:49.247]                             break
[10:22:49.247]                           }
[10:22:49.247]                         }
[10:22:49.247]                       }
[10:22:49.247]                       invisible(muffled)
[10:22:49.247]                     }
[10:22:49.247]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.247]                   }
[10:22:49.247]                 }
[10:22:49.247]                 else {
[10:22:49.247]                   if (TRUE) {
[10:22:49.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.247]                     {
[10:22:49.247]                       inherits <- base::inherits
[10:22:49.247]                       invokeRestart <- base::invokeRestart
[10:22:49.247]                       is.null <- base::is.null
[10:22:49.247]                       muffled <- FALSE
[10:22:49.247]                       if (inherits(cond, "message")) {
[10:22:49.247]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.247]                         if (muffled) 
[10:22:49.247]                           invokeRestart("muffleMessage")
[10:22:49.247]                       }
[10:22:49.247]                       else if (inherits(cond, "warning")) {
[10:22:49.247]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.247]                         if (muffled) 
[10:22:49.247]                           invokeRestart("muffleWarning")
[10:22:49.247]                       }
[10:22:49.247]                       else if (inherits(cond, "condition")) {
[10:22:49.247]                         if (!is.null(pattern)) {
[10:22:49.247]                           computeRestarts <- base::computeRestarts
[10:22:49.247]                           grepl <- base::grepl
[10:22:49.247]                           restarts <- computeRestarts(cond)
[10:22:49.247]                           for (restart in restarts) {
[10:22:49.247]                             name <- restart$name
[10:22:49.247]                             if (is.null(name)) 
[10:22:49.247]                               next
[10:22:49.247]                             if (!grepl(pattern, name)) 
[10:22:49.247]                               next
[10:22:49.247]                             invokeRestart(restart)
[10:22:49.247]                             muffled <- TRUE
[10:22:49.247]                             break
[10:22:49.247]                           }
[10:22:49.247]                         }
[10:22:49.247]                       }
[10:22:49.247]                       invisible(muffled)
[10:22:49.247]                     }
[10:22:49.247]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.247]                   }
[10:22:49.247]                 }
[10:22:49.247]             }
[10:22:49.247]         }))
[10:22:49.247]     }, error = function(ex) {
[10:22:49.247]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.247]                 ...future.rng), started = ...future.startTime, 
[10:22:49.247]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.247]             version = "1.8"), class = "FutureResult")
[10:22:49.247]     }, finally = {
[10:22:49.247]         if (!identical(...future.workdir, getwd())) 
[10:22:49.247]             setwd(...future.workdir)
[10:22:49.247]         {
[10:22:49.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.247]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.247]             }
[10:22:49.247]             base::options(...future.oldOptions)
[10:22:49.247]             if (.Platform$OS.type == "windows") {
[10:22:49.247]                 old_names <- names(...future.oldEnvVars)
[10:22:49.247]                 envs <- base::Sys.getenv()
[10:22:49.247]                 names <- names(envs)
[10:22:49.247]                 common <- intersect(names, old_names)
[10:22:49.247]                 added <- setdiff(names, old_names)
[10:22:49.247]                 removed <- setdiff(old_names, names)
[10:22:49.247]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.247]                   envs[common]]
[10:22:49.247]                 NAMES <- toupper(changed)
[10:22:49.247]                 args <- list()
[10:22:49.247]                 for (kk in seq_along(NAMES)) {
[10:22:49.247]                   name <- changed[[kk]]
[10:22:49.247]                   NAME <- NAMES[[kk]]
[10:22:49.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.247]                     next
[10:22:49.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.247]                 }
[10:22:49.247]                 NAMES <- toupper(added)
[10:22:49.247]                 for (kk in seq_along(NAMES)) {
[10:22:49.247]                   name <- added[[kk]]
[10:22:49.247]                   NAME <- NAMES[[kk]]
[10:22:49.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.247]                     next
[10:22:49.247]                   args[[name]] <- ""
[10:22:49.247]                 }
[10:22:49.247]                 NAMES <- toupper(removed)
[10:22:49.247]                 for (kk in seq_along(NAMES)) {
[10:22:49.247]                   name <- removed[[kk]]
[10:22:49.247]                   NAME <- NAMES[[kk]]
[10:22:49.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.247]                     next
[10:22:49.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.247]                 }
[10:22:49.247]                 if (length(args) > 0) 
[10:22:49.247]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.247]             }
[10:22:49.247]             else {
[10:22:49.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.247]             }
[10:22:49.247]             {
[10:22:49.247]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.247]                   0L) {
[10:22:49.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.247]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.247]                   base::options(opts)
[10:22:49.247]                 }
[10:22:49.247]                 {
[10:22:49.247]                   {
[10:22:49.247]                     NULL
[10:22:49.247]                     RNGkind("Mersenne-Twister")
[10:22:49.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.247]                       inherits = FALSE)
[10:22:49.247]                   }
[10:22:49.247]                   options(future.plan = NULL)
[10:22:49.247]                   if (is.na(NA_character_)) 
[10:22:49.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.247]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.247]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.247]                     envir = parent.frame()) 
[10:22:49.247]                   {
[10:22:49.247]                     if (is.function(workers)) 
[10:22:49.247]                       workers <- workers()
[10:22:49.247]                     workers <- structure(as.integer(workers), 
[10:22:49.247]                       class = class(workers))
[10:22:49.247]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.247]                       workers >= 1)
[10:22:49.247]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.247]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.247]                     }
[10:22:49.247]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.247]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.247]                       envir = envir)
[10:22:49.247]                     if (!future$lazy) 
[10:22:49.247]                       future <- run(future)
[10:22:49.247]                     invisible(future)
[10:22:49.247]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.247]                 }
[10:22:49.247]             }
[10:22:49.247]         }
[10:22:49.247]     })
[10:22:49.247]     if (TRUE) {
[10:22:49.247]         base::sink(type = "output", split = FALSE)
[10:22:49.247]         if (TRUE) {
[10:22:49.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.247]         }
[10:22:49.247]         else {
[10:22:49.247]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.247]         }
[10:22:49.247]         base::close(...future.stdout)
[10:22:49.247]         ...future.stdout <- NULL
[10:22:49.247]     }
[10:22:49.247]     ...future.result$conditions <- ...future.conditions
[10:22:49.247]     ...future.result$finished <- base::Sys.time()
[10:22:49.247]     ...future.result
[10:22:49.247] }
[10:22:49.249] assign_globals() ...
[10:22:49.249] List of 5
[10:22:49.249]  $ ...future.FUN            :function (object, ...)  
[10:22:49.249]  $ future.call.arguments    :List of 1
[10:22:49.249]   ..$ digits: int 2
[10:22:49.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.249]  $ ...future.elements_ii    :List of 6
[10:22:49.249]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:22:49.249]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:22:49.249]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:22:49.249]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:22:49.249]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:22:49.249]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:22:49.249]  $ ...future.seeds_ii       : NULL
[10:22:49.249]  $ ...future.globals.maxSize: NULL
[10:22:49.249]  - attr(*, "where")=List of 5
[10:22:49.249]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.249]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.249]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.249]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.249]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.249]  - attr(*, "resolved")= logi FALSE
[10:22:49.249]  - attr(*, "total_size")= num 1296
[10:22:49.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.249]  - attr(*, "already-done")= logi TRUE
[10:22:49.255] - copied ‘...future.FUN’ to environment
[10:22:49.255] - copied ‘future.call.arguments’ to environment
[10:22:49.255] - copied ‘...future.elements_ii’ to environment
[10:22:49.255] - copied ‘...future.seeds_ii’ to environment
[10:22:49.255] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.256] assign_globals() ... done
[10:22:49.256] plan(): Setting new future strategy stack:
[10:22:49.256] List of future strategies:
[10:22:49.256] 1. sequential:
[10:22:49.256]    - args: function (..., envir = parent.frame())
[10:22:49.256]    - tweaked: FALSE
[10:22:49.256]    - call: NULL
[10:22:49.256] plan(): nbrOfWorkers() = 1
[10:22:49.258] plan(): Setting new future strategy stack:
[10:22:49.258] List of future strategies:
[10:22:49.258] 1. multisession:
[10:22:49.258]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.258]    - tweaked: FALSE
[10:22:49.258]    - call: plan(strategy)
[10:22:49.261] plan(): nbrOfWorkers() = 1
[10:22:49.261] SequentialFuture started (and completed)
[10:22:49.261] - Launch lazy future ... done
[10:22:49.261] run() for ‘SequentialFuture’ ... done
[10:22:49.261] Created future:
[10:22:49.262] SequentialFuture:
[10:22:49.262] Label: ‘future_by-1’
[10:22:49.262] Expression:
[10:22:49.262] {
[10:22:49.262]     do.call(function(...) {
[10:22:49.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.262]             on.exit(options(oopts), add = TRUE)
[10:22:49.262]         }
[10:22:49.262]         {
[10:22:49.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.262]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.262]             })
[10:22:49.262]         }
[10:22:49.262]     }, args = future.call.arguments)
[10:22:49.262] }
[10:22:49.262] Lazy evaluation: FALSE
[10:22:49.262] Asynchronous evaluation: FALSE
[10:22:49.262] Local evaluation: TRUE
[10:22:49.262] Environment: R_GlobalEnv
[10:22:49.262] Capture standard output: TRUE
[10:22:49.262] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.262] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.262] Packages: <none>
[10:22:49.262] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.262] Resolved: TRUE
[10:22:49.262] Value: 5.48 KiB of class ‘list’
[10:22:49.262] Early signaling: FALSE
[10:22:49.262] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.262] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.263] Chunk #1 of 1 ... DONE
[10:22:49.263] Launching 1 futures (chunks) ... DONE
[10:22:49.263] Resolving 1 futures (chunks) ...
[10:22:49.263] resolve() on list ...
[10:22:49.263]  recursive: 0
[10:22:49.263]  length: 1
[10:22:49.263] 
[10:22:49.263] resolved() for ‘SequentialFuture’ ...
[10:22:49.263] - state: ‘finished’
[10:22:49.263] - run: TRUE
[10:22:49.263] - result: ‘FutureResult’
[10:22:49.264] resolved() for ‘SequentialFuture’ ... done
[10:22:49.264] Future #1
[10:22:49.264] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.264] - nx: 1
[10:22:49.264] - relay: TRUE
[10:22:49.264] - stdout: TRUE
[10:22:49.264] - signal: TRUE
[10:22:49.264] - resignal: FALSE
[10:22:49.264] - force: TRUE
[10:22:49.264] - relayed: [n=1] FALSE
[10:22:49.264] - queued futures: [n=1] FALSE
[10:22:49.265]  - until=1
[10:22:49.265]  - relaying element #1
[10:22:49.265] - relayed: [n=1] TRUE
[10:22:49.265] - queued futures: [n=1] TRUE
[10:22:49.265] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.265]  length: 0 (resolved future 1)
[10:22:49.265] Relaying remaining futures
[10:22:49.265] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.265] - nx: 1
[10:22:49.265] - relay: TRUE
[10:22:49.267] - stdout: TRUE
[10:22:49.267] - signal: TRUE
[10:22:49.267] - resignal: FALSE
[10:22:49.267] - force: TRUE
[10:22:49.267] - relayed: [n=1] TRUE
[10:22:49.267] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.267] - relayed: [n=1] TRUE
[10:22:49.267] - queued futures: [n=1] TRUE
[10:22:49.267] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.268] resolve() on list ... DONE
[10:22:49.268]  - Number of value chunks collected: 1
[10:22:49.268] Resolving 1 futures (chunks) ... DONE
[10:22:49.268] Reducing values from 1 chunks ...
[10:22:49.268]  - Number of values collected after concatenation: 6
[10:22:49.268]  - Number of values expected: 6
[10:22:49.268] Reducing values from 1 chunks ... DONE
[10:22:49.268] future_lapply() ... DONE
[10:22:49.268] future_by_internal() ... DONE
[10:22:49.269] future_by_internal() ...
[10:22:49.270] future_lapply() ...
[10:22:49.274] Number of chunks: 1
[10:22:49.274] getGlobalsAndPackagesXApply() ...
[10:22:49.274]  - future.globals: TRUE
[10:22:49.274] getGlobalsAndPackages() ...
[10:22:49.274] Searching for globals...
[10:22:49.276] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:49.276] Searching for globals ... DONE
[10:22:49.276] Resolving globals: FALSE
[10:22:49.276] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:22:49.277] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:22:49.277] - globals: [1] ‘FUN’
[10:22:49.277] - packages: [1] ‘stats’
[10:22:49.277] getGlobalsAndPackages() ... DONE
[10:22:49.277]  - globals found/used: [n=1] ‘FUN’
[10:22:49.277]  - needed namespaces: [n=1] ‘stats’
[10:22:49.277] Finding globals ... DONE
[10:22:49.277]  - use_args: TRUE
[10:22:49.277]  - Getting '...' globals ...
[10:22:49.278] resolve() on list ...
[10:22:49.278]  recursive: 0
[10:22:49.278]  length: 1
[10:22:49.278]  elements: ‘...’
[10:22:49.278]  length: 0 (resolved future 1)
[10:22:49.278] resolve() on list ... DONE
[10:22:49.278]    - '...' content: [n=1] ‘singular.ok’
[10:22:49.278] List of 1
[10:22:49.278]  $ ...:List of 1
[10:22:49.278]   ..$ singular.ok: logi FALSE
[10:22:49.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.278]  - attr(*, "where")=List of 1
[10:22:49.278]   ..$ ...:<environment: 0x55f6388ca6b8> 
[10:22:49.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.278]  - attr(*, "resolved")= logi TRUE
[10:22:49.278]  - attr(*, "total_size")= num NA
[10:22:49.281]  - Getting '...' globals ... DONE
[10:22:49.281] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.281] List of 2
[10:22:49.281]  $ ...future.FUN:function (x, ...)  
[10:22:49.281]  $ ...          :List of 1
[10:22:49.281]   ..$ singular.ok: logi FALSE
[10:22:49.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.281]  - attr(*, "where")=List of 2
[10:22:49.281]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.281]   ..$ ...          :<environment: 0x55f6388ca6b8> 
[10:22:49.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.281]  - attr(*, "resolved")= logi FALSE
[10:22:49.281]  - attr(*, "total_size")= num 5384
[10:22:49.284] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:49.284] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.285] Number of futures (= number of chunks): 1
[10:22:49.285] Launching 1 futures (chunks) ...
[10:22:49.285] Chunk #1 of 1 ...
[10:22:49.285]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.285] getGlobalsAndPackages() ...
[10:22:49.285] Searching for globals...
[10:22:49.286] 
[10:22:49.286] Searching for globals ... DONE
[10:22:49.286] - globals: [0] <none>
[10:22:49.286] getGlobalsAndPackages() ... DONE
[10:22:49.286]    + additional globals found: [n=0] 
[10:22:49.286]    + additional namespaces needed: [n=0] 
[10:22:49.286]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.286]  - seeds: <none>
[10:22:49.288]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.288] getGlobalsAndPackages() ...
[10:22:49.288] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.288] Resolving globals: FALSE
[10:22:49.288] Tweak future expression to call with '...' arguments ...
[10:22:49.288] {
[10:22:49.288]     do.call(function(...) {
[10:22:49.288]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.288]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.288]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.288]             on.exit(options(oopts), add = TRUE)
[10:22:49.288]         }
[10:22:49.288]         {
[10:22:49.288]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.288]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.288]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.288]             })
[10:22:49.288]         }
[10:22:49.288]     }, args = future.call.arguments)
[10:22:49.288] }
[10:22:49.288] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.289] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.289] 
[10:22:49.289] getGlobalsAndPackages() ... DONE
[10:22:49.289] run() for ‘Future’ ...
[10:22:49.289] - state: ‘created’
[10:22:49.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.293] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.293]   - Field: ‘label’
[10:22:49.293]   - Field: ‘local’
[10:22:49.293]   - Field: ‘owner’
[10:22:49.293]   - Field: ‘envir’
[10:22:49.294]   - Field: ‘packages’
[10:22:49.294]   - Field: ‘gc’
[10:22:49.294]   - Field: ‘conditions’
[10:22:49.294]   - Field: ‘expr’
[10:22:49.294]   - Field: ‘uuid’
[10:22:49.294]   - Field: ‘seed’
[10:22:49.294]   - Field: ‘version’
[10:22:49.294]   - Field: ‘result’
[10:22:49.294]   - Field: ‘asynchronous’
[10:22:49.294]   - Field: ‘calls’
[10:22:49.294]   - Field: ‘globals’
[10:22:49.295]   - Field: ‘stdout’
[10:22:49.295]   - Field: ‘earlySignal’
[10:22:49.295]   - Field: ‘lazy’
[10:22:49.295]   - Field: ‘state’
[10:22:49.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.295] - Launch lazy future ...
[10:22:49.295] Packages needed by the future expression (n = 1): ‘stats’
[10:22:49.295] Packages needed by future strategies (n = 0): <none>
[10:22:49.296] {
[10:22:49.296]     {
[10:22:49.296]         {
[10:22:49.296]             ...future.startTime <- base::Sys.time()
[10:22:49.296]             {
[10:22:49.296]                 {
[10:22:49.296]                   {
[10:22:49.296]                     {
[10:22:49.296]                       base::local({
[10:22:49.296]                         has_future <- base::requireNamespace("future", 
[10:22:49.296]                           quietly = TRUE)
[10:22:49.296]                         if (has_future) {
[10:22:49.296]                           ns <- base::getNamespace("future")
[10:22:49.296]                           version <- ns[[".package"]][["version"]]
[10:22:49.296]                           if (is.null(version)) 
[10:22:49.296]                             version <- utils::packageVersion("future")
[10:22:49.296]                         }
[10:22:49.296]                         else {
[10:22:49.296]                           version <- NULL
[10:22:49.296]                         }
[10:22:49.296]                         if (!has_future || version < "1.8.0") {
[10:22:49.296]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.296]                             "", base::R.version$version.string), 
[10:22:49.296]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.296]                               "release", "version")], collapse = " "), 
[10:22:49.296]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.296]                             info)
[10:22:49.296]                           info <- base::paste(info, collapse = "; ")
[10:22:49.296]                           if (!has_future) {
[10:22:49.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.296]                               info)
[10:22:49.296]                           }
[10:22:49.296]                           else {
[10:22:49.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.296]                               info, version)
[10:22:49.296]                           }
[10:22:49.296]                           base::stop(msg)
[10:22:49.296]                         }
[10:22:49.296]                       })
[10:22:49.296]                     }
[10:22:49.296]                     base::local({
[10:22:49.296]                       for (pkg in "stats") {
[10:22:49.296]                         base::loadNamespace(pkg)
[10:22:49.296]                         base::library(pkg, character.only = TRUE)
[10:22:49.296]                       }
[10:22:49.296]                     })
[10:22:49.296]                   }
[10:22:49.296]                   options(future.plan = NULL)
[10:22:49.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.296]                 }
[10:22:49.296]                 ...future.workdir <- getwd()
[10:22:49.296]             }
[10:22:49.296]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.296]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.296]         }
[10:22:49.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.296]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.296]             base::names(...future.oldOptions))
[10:22:49.296]     }
[10:22:49.296]     if (FALSE) {
[10:22:49.296]     }
[10:22:49.296]     else {
[10:22:49.296]         if (TRUE) {
[10:22:49.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.296]                 open = "w")
[10:22:49.296]         }
[10:22:49.296]         else {
[10:22:49.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.296]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.296]         }
[10:22:49.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.296]             base::sink(type = "output", split = FALSE)
[10:22:49.296]             base::close(...future.stdout)
[10:22:49.296]         }, add = TRUE)
[10:22:49.296]     }
[10:22:49.296]     ...future.frame <- base::sys.nframe()
[10:22:49.296]     ...future.conditions <- base::list()
[10:22:49.296]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.296]     if (FALSE) {
[10:22:49.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.296]     }
[10:22:49.296]     ...future.result <- base::tryCatch({
[10:22:49.296]         base::withCallingHandlers({
[10:22:49.296]             ...future.value <- base::withVisible(base::local({
[10:22:49.296]                 do.call(function(...) {
[10:22:49.296]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.296]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.296]                     ...future.globals.maxSize)) {
[10:22:49.296]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.296]                     on.exit(options(oopts), add = TRUE)
[10:22:49.296]                   }
[10:22:49.296]                   {
[10:22:49.296]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.296]                       FUN = function(jj) {
[10:22:49.296]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.296]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.296]                       })
[10:22:49.296]                   }
[10:22:49.296]                 }, args = future.call.arguments)
[10:22:49.296]             }))
[10:22:49.296]             future::FutureResult(value = ...future.value$value, 
[10:22:49.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.296]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.296]                     ...future.globalenv.names))
[10:22:49.296]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.296]         }, condition = base::local({
[10:22:49.296]             c <- base::c
[10:22:49.296]             inherits <- base::inherits
[10:22:49.296]             invokeRestart <- base::invokeRestart
[10:22:49.296]             length <- base::length
[10:22:49.296]             list <- base::list
[10:22:49.296]             seq.int <- base::seq.int
[10:22:49.296]             signalCondition <- base::signalCondition
[10:22:49.296]             sys.calls <- base::sys.calls
[10:22:49.296]             `[[` <- base::`[[`
[10:22:49.296]             `+` <- base::`+`
[10:22:49.296]             `<<-` <- base::`<<-`
[10:22:49.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.296]                   3L)]
[10:22:49.296]             }
[10:22:49.296]             function(cond) {
[10:22:49.296]                 is_error <- inherits(cond, "error")
[10:22:49.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.296]                   NULL)
[10:22:49.296]                 if (is_error) {
[10:22:49.296]                   sessionInformation <- function() {
[10:22:49.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.296]                       search = base::search(), system = base::Sys.info())
[10:22:49.296]                   }
[10:22:49.296]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.296]                     cond$call), session = sessionInformation(), 
[10:22:49.296]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.296]                   signalCondition(cond)
[10:22:49.296]                 }
[10:22:49.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.296]                 "immediateCondition"))) {
[10:22:49.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.296]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.296]                   if (TRUE && !signal) {
[10:22:49.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.296]                     {
[10:22:49.296]                       inherits <- base::inherits
[10:22:49.296]                       invokeRestart <- base::invokeRestart
[10:22:49.296]                       is.null <- base::is.null
[10:22:49.296]                       muffled <- FALSE
[10:22:49.296]                       if (inherits(cond, "message")) {
[10:22:49.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.296]                         if (muffled) 
[10:22:49.296]                           invokeRestart("muffleMessage")
[10:22:49.296]                       }
[10:22:49.296]                       else if (inherits(cond, "warning")) {
[10:22:49.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.296]                         if (muffled) 
[10:22:49.296]                           invokeRestart("muffleWarning")
[10:22:49.296]                       }
[10:22:49.296]                       else if (inherits(cond, "condition")) {
[10:22:49.296]                         if (!is.null(pattern)) {
[10:22:49.296]                           computeRestarts <- base::computeRestarts
[10:22:49.296]                           grepl <- base::grepl
[10:22:49.296]                           restarts <- computeRestarts(cond)
[10:22:49.296]                           for (restart in restarts) {
[10:22:49.296]                             name <- restart$name
[10:22:49.296]                             if (is.null(name)) 
[10:22:49.296]                               next
[10:22:49.296]                             if (!grepl(pattern, name)) 
[10:22:49.296]                               next
[10:22:49.296]                             invokeRestart(restart)
[10:22:49.296]                             muffled <- TRUE
[10:22:49.296]                             break
[10:22:49.296]                           }
[10:22:49.296]                         }
[10:22:49.296]                       }
[10:22:49.296]                       invisible(muffled)
[10:22:49.296]                     }
[10:22:49.296]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.296]                   }
[10:22:49.296]                 }
[10:22:49.296]                 else {
[10:22:49.296]                   if (TRUE) {
[10:22:49.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.296]                     {
[10:22:49.296]                       inherits <- base::inherits
[10:22:49.296]                       invokeRestart <- base::invokeRestart
[10:22:49.296]                       is.null <- base::is.null
[10:22:49.296]                       muffled <- FALSE
[10:22:49.296]                       if (inherits(cond, "message")) {
[10:22:49.296]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.296]                         if (muffled) 
[10:22:49.296]                           invokeRestart("muffleMessage")
[10:22:49.296]                       }
[10:22:49.296]                       else if (inherits(cond, "warning")) {
[10:22:49.296]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.296]                         if (muffled) 
[10:22:49.296]                           invokeRestart("muffleWarning")
[10:22:49.296]                       }
[10:22:49.296]                       else if (inherits(cond, "condition")) {
[10:22:49.296]                         if (!is.null(pattern)) {
[10:22:49.296]                           computeRestarts <- base::computeRestarts
[10:22:49.296]                           grepl <- base::grepl
[10:22:49.296]                           restarts <- computeRestarts(cond)
[10:22:49.296]                           for (restart in restarts) {
[10:22:49.296]                             name <- restart$name
[10:22:49.296]                             if (is.null(name)) 
[10:22:49.296]                               next
[10:22:49.296]                             if (!grepl(pattern, name)) 
[10:22:49.296]                               next
[10:22:49.296]                             invokeRestart(restart)
[10:22:49.296]                             muffled <- TRUE
[10:22:49.296]                             break
[10:22:49.296]                           }
[10:22:49.296]                         }
[10:22:49.296]                       }
[10:22:49.296]                       invisible(muffled)
[10:22:49.296]                     }
[10:22:49.296]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.296]                   }
[10:22:49.296]                 }
[10:22:49.296]             }
[10:22:49.296]         }))
[10:22:49.296]     }, error = function(ex) {
[10:22:49.296]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.296]                 ...future.rng), started = ...future.startTime, 
[10:22:49.296]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.296]             version = "1.8"), class = "FutureResult")
[10:22:49.296]     }, finally = {
[10:22:49.296]         if (!identical(...future.workdir, getwd())) 
[10:22:49.296]             setwd(...future.workdir)
[10:22:49.296]         {
[10:22:49.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.296]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.296]             }
[10:22:49.296]             base::options(...future.oldOptions)
[10:22:49.296]             if (.Platform$OS.type == "windows") {
[10:22:49.296]                 old_names <- names(...future.oldEnvVars)
[10:22:49.296]                 envs <- base::Sys.getenv()
[10:22:49.296]                 names <- names(envs)
[10:22:49.296]                 common <- intersect(names, old_names)
[10:22:49.296]                 added <- setdiff(names, old_names)
[10:22:49.296]                 removed <- setdiff(old_names, names)
[10:22:49.296]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.296]                   envs[common]]
[10:22:49.296]                 NAMES <- toupper(changed)
[10:22:49.296]                 args <- list()
[10:22:49.296]                 for (kk in seq_along(NAMES)) {
[10:22:49.296]                   name <- changed[[kk]]
[10:22:49.296]                   NAME <- NAMES[[kk]]
[10:22:49.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.296]                     next
[10:22:49.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.296]                 }
[10:22:49.296]                 NAMES <- toupper(added)
[10:22:49.296]                 for (kk in seq_along(NAMES)) {
[10:22:49.296]                   name <- added[[kk]]
[10:22:49.296]                   NAME <- NAMES[[kk]]
[10:22:49.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.296]                     next
[10:22:49.296]                   args[[name]] <- ""
[10:22:49.296]                 }
[10:22:49.296]                 NAMES <- toupper(removed)
[10:22:49.296]                 for (kk in seq_along(NAMES)) {
[10:22:49.296]                   name <- removed[[kk]]
[10:22:49.296]                   NAME <- NAMES[[kk]]
[10:22:49.296]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.296]                     next
[10:22:49.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.296]                 }
[10:22:49.296]                 if (length(args) > 0) 
[10:22:49.296]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.296]             }
[10:22:49.296]             else {
[10:22:49.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.296]             }
[10:22:49.296]             {
[10:22:49.296]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.296]                   0L) {
[10:22:49.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.296]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.296]                   base::options(opts)
[10:22:49.296]                 }
[10:22:49.296]                 {
[10:22:49.296]                   {
[10:22:49.296]                     NULL
[10:22:49.296]                     RNGkind("Mersenne-Twister")
[10:22:49.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.296]                       inherits = FALSE)
[10:22:49.296]                   }
[10:22:49.296]                   options(future.plan = NULL)
[10:22:49.296]                   if (is.na(NA_character_)) 
[10:22:49.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.296]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.296]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.296]                     envir = parent.frame()) 
[10:22:49.296]                   {
[10:22:49.296]                     if (is.function(workers)) 
[10:22:49.296]                       workers <- workers()
[10:22:49.296]                     workers <- structure(as.integer(workers), 
[10:22:49.296]                       class = class(workers))
[10:22:49.296]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.296]                       workers >= 1)
[10:22:49.296]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.296]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.296]                     }
[10:22:49.296]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.296]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.296]                       envir = envir)
[10:22:49.296]                     if (!future$lazy) 
[10:22:49.296]                       future <- run(future)
[10:22:49.296]                     invisible(future)
[10:22:49.296]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.296]                 }
[10:22:49.296]             }
[10:22:49.296]         }
[10:22:49.296]     })
[10:22:49.296]     if (TRUE) {
[10:22:49.296]         base::sink(type = "output", split = FALSE)
[10:22:49.296]         if (TRUE) {
[10:22:49.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.296]         }
[10:22:49.296]         else {
[10:22:49.296]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.296]         }
[10:22:49.296]         base::close(...future.stdout)
[10:22:49.296]         ...future.stdout <- NULL
[10:22:49.296]     }
[10:22:49.296]     ...future.result$conditions <- ...future.conditions
[10:22:49.296]     ...future.result$finished <- base::Sys.time()
[10:22:49.296]     ...future.result
[10:22:49.296] }
[10:22:49.298] assign_globals() ...
[10:22:49.298] List of 5
[10:22:49.298]  $ ...future.FUN            :function (x, ...)  
[10:22:49.298]  $ future.call.arguments    :List of 1
[10:22:49.298]   ..$ singular.ok: logi FALSE
[10:22:49.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.298]  $ ...future.elements_ii    :List of 3
[10:22:49.298]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.298]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.298]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.298]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.298]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.298]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.298]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.298]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.298]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.298]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.298]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.298]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.298]  $ ...future.seeds_ii       : NULL
[10:22:49.298]  $ ...future.globals.maxSize: NULL
[10:22:49.298]  - attr(*, "where")=List of 5
[10:22:49.298]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.298]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.298]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.298]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.298]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.298]  - attr(*, "resolved")= logi FALSE
[10:22:49.298]  - attr(*, "total_size")= num 5384
[10:22:49.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.298]  - attr(*, "already-done")= logi TRUE
[10:22:49.306] - reassign environment for ‘...future.FUN’
[10:22:49.306] - copied ‘...future.FUN’ to environment
[10:22:49.306] - copied ‘future.call.arguments’ to environment
[10:22:49.307] - copied ‘...future.elements_ii’ to environment
[10:22:49.307] - copied ‘...future.seeds_ii’ to environment
[10:22:49.307] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.307] assign_globals() ... done
[10:22:49.307] plan(): Setting new future strategy stack:
[10:22:49.307] List of future strategies:
[10:22:49.307] 1. sequential:
[10:22:49.307]    - args: function (..., envir = parent.frame())
[10:22:49.307]    - tweaked: FALSE
[10:22:49.307]    - call: NULL
[10:22:49.308] plan(): nbrOfWorkers() = 1
[10:22:49.312] plan(): Setting new future strategy stack:
[10:22:49.312] List of future strategies:
[10:22:49.312] 1. multisession:
[10:22:49.312]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.312]    - tweaked: FALSE
[10:22:49.312]    - call: plan(strategy)
[10:22:49.315] plan(): nbrOfWorkers() = 1
[10:22:49.315] SequentialFuture started (and completed)
[10:22:49.316] - Launch lazy future ... done
[10:22:49.316] run() for ‘SequentialFuture’ ... done
[10:22:49.316] Created future:
[10:22:49.316] SequentialFuture:
[10:22:49.316] Label: ‘future_by-1’
[10:22:49.316] Expression:
[10:22:49.316] {
[10:22:49.316]     do.call(function(...) {
[10:22:49.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.316]             on.exit(options(oopts), add = TRUE)
[10:22:49.316]         }
[10:22:49.316]         {
[10:22:49.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.316]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.316]             })
[10:22:49.316]         }
[10:22:49.316]     }, args = future.call.arguments)
[10:22:49.316] }
[10:22:49.316] Lazy evaluation: FALSE
[10:22:49.316] Asynchronous evaluation: FALSE
[10:22:49.316] Local evaluation: TRUE
[10:22:49.316] Environment: R_GlobalEnv
[10:22:49.316] Capture standard output: TRUE
[10:22:49.316] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.316] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.316] Packages: 1 packages (‘stats’)
[10:22:49.316] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.316] Resolved: TRUE
[10:22:49.316] Value: 26.06 KiB of class ‘list’
[10:22:49.316] Early signaling: FALSE
[10:22:49.316] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.316] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.317] Chunk #1 of 1 ... DONE
[10:22:49.317] Launching 1 futures (chunks) ... DONE
[10:22:49.318] Resolving 1 futures (chunks) ...
[10:22:49.318] resolve() on list ...
[10:22:49.318]  recursive: 0
[10:22:49.318]  length: 1
[10:22:49.318] 
[10:22:49.318] resolved() for ‘SequentialFuture’ ...
[10:22:49.318] - state: ‘finished’
[10:22:49.318] - run: TRUE
[10:22:49.318] - result: ‘FutureResult’
[10:22:49.318] resolved() for ‘SequentialFuture’ ... done
[10:22:49.318] Future #1
[10:22:49.319] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.319] - nx: 1
[10:22:49.319] - relay: TRUE
[10:22:49.319] - stdout: TRUE
[10:22:49.319] - signal: TRUE
[10:22:49.319] - resignal: FALSE
[10:22:49.319] - force: TRUE
[10:22:49.319] - relayed: [n=1] FALSE
[10:22:49.319] - queued futures: [n=1] FALSE
[10:22:49.319]  - until=1
[10:22:49.319]  - relaying element #1
[10:22:49.320] - relayed: [n=1] TRUE
[10:22:49.320] - queued futures: [n=1] TRUE
[10:22:49.320] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.320]  length: 0 (resolved future 1)
[10:22:49.320] Relaying remaining futures
[10:22:49.320] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.320] - nx: 1
[10:22:49.320] - relay: TRUE
[10:22:49.320] - stdout: TRUE
[10:22:49.320] - signal: TRUE
[10:22:49.320] - resignal: FALSE
[10:22:49.321] - force: TRUE
[10:22:49.321] - relayed: [n=1] TRUE
[10:22:49.321] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.321] - relayed: [n=1] TRUE
[10:22:49.321] - queued futures: [n=1] TRUE
[10:22:49.321] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.321] resolve() on list ... DONE
[10:22:49.321]  - Number of value chunks collected: 1
[10:22:49.321] Resolving 1 futures (chunks) ... DONE
[10:22:49.321] Reducing values from 1 chunks ...
[10:22:49.322]  - Number of values collected after concatenation: 3
[10:22:49.322]  - Number of values expected: 3
[10:22:49.322] Reducing values from 1 chunks ... DONE
[10:22:49.322] future_lapply() ... DONE
[10:22:49.322] future_by_internal() ... DONE
[10:22:49.326] future_by_internal() ...
[10:22:49.326] future_lapply() ...
[10:22:49.330] Number of chunks: 1
[10:22:49.330] getGlobalsAndPackagesXApply() ...
[10:22:49.330]  - future.globals: TRUE
[10:22:49.330] getGlobalsAndPackages() ...
[10:22:49.330] Searching for globals...
[10:22:49.333] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:49.333] Searching for globals ... DONE
[10:22:49.333] Resolving globals: FALSE
[10:22:49.334] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:22:49.334] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:22:49.334] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:49.334] - packages: [1] ‘stats’
[10:22:49.335] getGlobalsAndPackages() ... DONE
[10:22:49.335]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:49.335]  - needed namespaces: [n=1] ‘stats’
[10:22:49.335] Finding globals ... DONE
[10:22:49.335]  - use_args: TRUE
[10:22:49.335]  - Getting '...' globals ...
[10:22:49.335] resolve() on list ...
[10:22:49.335]  recursive: 0
[10:22:49.336]  length: 1
[10:22:49.336]  elements: ‘...’
[10:22:49.336]  length: 0 (resolved future 1)
[10:22:49.336] resolve() on list ... DONE
[10:22:49.336]    - '...' content: [n=0] 
[10:22:49.336] List of 1
[10:22:49.336]  $ ...: list()
[10:22:49.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.336]  - attr(*, "where")=List of 1
[10:22:49.336]   ..$ ...:<environment: 0x55f639e6dae8> 
[10:22:49.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.336]  - attr(*, "resolved")= logi TRUE
[10:22:49.336]  - attr(*, "total_size")= num NA
[10:22:49.338]  - Getting '...' globals ... DONE
[10:22:49.339] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:22:49.339] List of 4
[10:22:49.339]  $ ...future.FUN:function (x)  
[10:22:49.339]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:49.339]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.339]  $ ...          : list()
[10:22:49.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.339]  - attr(*, "where")=List of 4
[10:22:49.339]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.339]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:22:49.339]   ..$ wool         :<environment: R_EmptyEnv> 
[10:22:49.339]   ..$ ...          :<environment: 0x55f639e6dae8> 
[10:22:49.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.339]  - attr(*, "resolved")= logi FALSE
[10:22:49.339]  - attr(*, "total_size")= num 2320
[10:22:49.343] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:49.343] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.343] Number of futures (= number of chunks): 1
[10:22:49.343] Launching 1 futures (chunks) ...
[10:22:49.343] Chunk #1 of 1 ...
[10:22:49.343]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.343] getGlobalsAndPackages() ...
[10:22:49.343] Searching for globals...
[10:22:49.344] 
[10:22:49.344] Searching for globals ... DONE
[10:22:49.344] - globals: [0] <none>
[10:22:49.344] getGlobalsAndPackages() ... DONE
[10:22:49.344]    + additional globals found: [n=0] 
[10:22:49.344]    + additional namespaces needed: [n=0] 
[10:22:49.344]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.344]  - seeds: <none>
[10:22:49.344]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.345] getGlobalsAndPackages() ...
[10:22:49.345] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.345] Resolving globals: FALSE
[10:22:49.345] Tweak future expression to call with '...' arguments ...
[10:22:49.345] {
[10:22:49.345]     do.call(function(...) {
[10:22:49.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.345]             on.exit(options(oopts), add = TRUE)
[10:22:49.345]         }
[10:22:49.345]         {
[10:22:49.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.345]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.345]             })
[10:22:49.345]         }
[10:22:49.345]     }, args = future.call.arguments)
[10:22:49.345] }
[10:22:49.345] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.346] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.346] 
[10:22:49.346] getGlobalsAndPackages() ... DONE
[10:22:49.346] run() for ‘Future’ ...
[10:22:49.346] - state: ‘created’
[10:22:49.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.350] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.350]   - Field: ‘label’
[10:22:49.350]   - Field: ‘local’
[10:22:49.350]   - Field: ‘owner’
[10:22:49.350]   - Field: ‘envir’
[10:22:49.350]   - Field: ‘packages’
[10:22:49.350]   - Field: ‘gc’
[10:22:49.350]   - Field: ‘conditions’
[10:22:49.351]   - Field: ‘expr’
[10:22:49.351]   - Field: ‘uuid’
[10:22:49.351]   - Field: ‘seed’
[10:22:49.351]   - Field: ‘version’
[10:22:49.351]   - Field: ‘result’
[10:22:49.351]   - Field: ‘asynchronous’
[10:22:49.351]   - Field: ‘calls’
[10:22:49.351]   - Field: ‘globals’
[10:22:49.351]   - Field: ‘stdout’
[10:22:49.351]   - Field: ‘earlySignal’
[10:22:49.351]   - Field: ‘lazy’
[10:22:49.352]   - Field: ‘state’
[10:22:49.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.352] - Launch lazy future ...
[10:22:49.352] Packages needed by the future expression (n = 1): ‘stats’
[10:22:49.352] Packages needed by future strategies (n = 0): <none>
[10:22:49.354] {
[10:22:49.354]     {
[10:22:49.354]         {
[10:22:49.354]             ...future.startTime <- base::Sys.time()
[10:22:49.354]             {
[10:22:49.354]                 {
[10:22:49.354]                   {
[10:22:49.354]                     {
[10:22:49.354]                       base::local({
[10:22:49.354]                         has_future <- base::requireNamespace("future", 
[10:22:49.354]                           quietly = TRUE)
[10:22:49.354]                         if (has_future) {
[10:22:49.354]                           ns <- base::getNamespace("future")
[10:22:49.354]                           version <- ns[[".package"]][["version"]]
[10:22:49.354]                           if (is.null(version)) 
[10:22:49.354]                             version <- utils::packageVersion("future")
[10:22:49.354]                         }
[10:22:49.354]                         else {
[10:22:49.354]                           version <- NULL
[10:22:49.354]                         }
[10:22:49.354]                         if (!has_future || version < "1.8.0") {
[10:22:49.354]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.354]                             "", base::R.version$version.string), 
[10:22:49.354]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.354]                               "release", "version")], collapse = " "), 
[10:22:49.354]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.354]                             info)
[10:22:49.354]                           info <- base::paste(info, collapse = "; ")
[10:22:49.354]                           if (!has_future) {
[10:22:49.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.354]                               info)
[10:22:49.354]                           }
[10:22:49.354]                           else {
[10:22:49.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.354]                               info, version)
[10:22:49.354]                           }
[10:22:49.354]                           base::stop(msg)
[10:22:49.354]                         }
[10:22:49.354]                       })
[10:22:49.354]                     }
[10:22:49.354]                     base::local({
[10:22:49.354]                       for (pkg in "stats") {
[10:22:49.354]                         base::loadNamespace(pkg)
[10:22:49.354]                         base::library(pkg, character.only = TRUE)
[10:22:49.354]                       }
[10:22:49.354]                     })
[10:22:49.354]                   }
[10:22:49.354]                   options(future.plan = NULL)
[10:22:49.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.354]                 }
[10:22:49.354]                 ...future.workdir <- getwd()
[10:22:49.354]             }
[10:22:49.354]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.354]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.354]         }
[10:22:49.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.354]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.354]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.354]             base::names(...future.oldOptions))
[10:22:49.354]     }
[10:22:49.354]     if (FALSE) {
[10:22:49.354]     }
[10:22:49.354]     else {
[10:22:49.354]         if (TRUE) {
[10:22:49.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.354]                 open = "w")
[10:22:49.354]         }
[10:22:49.354]         else {
[10:22:49.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.354]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.354]         }
[10:22:49.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.354]             base::sink(type = "output", split = FALSE)
[10:22:49.354]             base::close(...future.stdout)
[10:22:49.354]         }, add = TRUE)
[10:22:49.354]     }
[10:22:49.354]     ...future.frame <- base::sys.nframe()
[10:22:49.354]     ...future.conditions <- base::list()
[10:22:49.354]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.354]     if (FALSE) {
[10:22:49.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.354]     }
[10:22:49.354]     ...future.result <- base::tryCatch({
[10:22:49.354]         base::withCallingHandlers({
[10:22:49.354]             ...future.value <- base::withVisible(base::local({
[10:22:49.354]                 do.call(function(...) {
[10:22:49.354]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.354]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.354]                     ...future.globals.maxSize)) {
[10:22:49.354]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.354]                     on.exit(options(oopts), add = TRUE)
[10:22:49.354]                   }
[10:22:49.354]                   {
[10:22:49.354]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.354]                       FUN = function(jj) {
[10:22:49.354]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.354]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.354]                       })
[10:22:49.354]                   }
[10:22:49.354]                 }, args = future.call.arguments)
[10:22:49.354]             }))
[10:22:49.354]             future::FutureResult(value = ...future.value$value, 
[10:22:49.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.354]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.354]                     ...future.globalenv.names))
[10:22:49.354]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.354]         }, condition = base::local({
[10:22:49.354]             c <- base::c
[10:22:49.354]             inherits <- base::inherits
[10:22:49.354]             invokeRestart <- base::invokeRestart
[10:22:49.354]             length <- base::length
[10:22:49.354]             list <- base::list
[10:22:49.354]             seq.int <- base::seq.int
[10:22:49.354]             signalCondition <- base::signalCondition
[10:22:49.354]             sys.calls <- base::sys.calls
[10:22:49.354]             `[[` <- base::`[[`
[10:22:49.354]             `+` <- base::`+`
[10:22:49.354]             `<<-` <- base::`<<-`
[10:22:49.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.354]                   3L)]
[10:22:49.354]             }
[10:22:49.354]             function(cond) {
[10:22:49.354]                 is_error <- inherits(cond, "error")
[10:22:49.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.354]                   NULL)
[10:22:49.354]                 if (is_error) {
[10:22:49.354]                   sessionInformation <- function() {
[10:22:49.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.354]                       search = base::search(), system = base::Sys.info())
[10:22:49.354]                   }
[10:22:49.354]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.354]                     cond$call), session = sessionInformation(), 
[10:22:49.354]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.354]                   signalCondition(cond)
[10:22:49.354]                 }
[10:22:49.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.354]                 "immediateCondition"))) {
[10:22:49.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.354]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.354]                   if (TRUE && !signal) {
[10:22:49.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.354]                     {
[10:22:49.354]                       inherits <- base::inherits
[10:22:49.354]                       invokeRestart <- base::invokeRestart
[10:22:49.354]                       is.null <- base::is.null
[10:22:49.354]                       muffled <- FALSE
[10:22:49.354]                       if (inherits(cond, "message")) {
[10:22:49.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.354]                         if (muffled) 
[10:22:49.354]                           invokeRestart("muffleMessage")
[10:22:49.354]                       }
[10:22:49.354]                       else if (inherits(cond, "warning")) {
[10:22:49.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.354]                         if (muffled) 
[10:22:49.354]                           invokeRestart("muffleWarning")
[10:22:49.354]                       }
[10:22:49.354]                       else if (inherits(cond, "condition")) {
[10:22:49.354]                         if (!is.null(pattern)) {
[10:22:49.354]                           computeRestarts <- base::computeRestarts
[10:22:49.354]                           grepl <- base::grepl
[10:22:49.354]                           restarts <- computeRestarts(cond)
[10:22:49.354]                           for (restart in restarts) {
[10:22:49.354]                             name <- restart$name
[10:22:49.354]                             if (is.null(name)) 
[10:22:49.354]                               next
[10:22:49.354]                             if (!grepl(pattern, name)) 
[10:22:49.354]                               next
[10:22:49.354]                             invokeRestart(restart)
[10:22:49.354]                             muffled <- TRUE
[10:22:49.354]                             break
[10:22:49.354]                           }
[10:22:49.354]                         }
[10:22:49.354]                       }
[10:22:49.354]                       invisible(muffled)
[10:22:49.354]                     }
[10:22:49.354]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.354]                   }
[10:22:49.354]                 }
[10:22:49.354]                 else {
[10:22:49.354]                   if (TRUE) {
[10:22:49.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.354]                     {
[10:22:49.354]                       inherits <- base::inherits
[10:22:49.354]                       invokeRestart <- base::invokeRestart
[10:22:49.354]                       is.null <- base::is.null
[10:22:49.354]                       muffled <- FALSE
[10:22:49.354]                       if (inherits(cond, "message")) {
[10:22:49.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.354]                         if (muffled) 
[10:22:49.354]                           invokeRestart("muffleMessage")
[10:22:49.354]                       }
[10:22:49.354]                       else if (inherits(cond, "warning")) {
[10:22:49.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.354]                         if (muffled) 
[10:22:49.354]                           invokeRestart("muffleWarning")
[10:22:49.354]                       }
[10:22:49.354]                       else if (inherits(cond, "condition")) {
[10:22:49.354]                         if (!is.null(pattern)) {
[10:22:49.354]                           computeRestarts <- base::computeRestarts
[10:22:49.354]                           grepl <- base::grepl
[10:22:49.354]                           restarts <- computeRestarts(cond)
[10:22:49.354]                           for (restart in restarts) {
[10:22:49.354]                             name <- restart$name
[10:22:49.354]                             if (is.null(name)) 
[10:22:49.354]                               next
[10:22:49.354]                             if (!grepl(pattern, name)) 
[10:22:49.354]                               next
[10:22:49.354]                             invokeRestart(restart)
[10:22:49.354]                             muffled <- TRUE
[10:22:49.354]                             break
[10:22:49.354]                           }
[10:22:49.354]                         }
[10:22:49.354]                       }
[10:22:49.354]                       invisible(muffled)
[10:22:49.354]                     }
[10:22:49.354]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.354]                   }
[10:22:49.354]                 }
[10:22:49.354]             }
[10:22:49.354]         }))
[10:22:49.354]     }, error = function(ex) {
[10:22:49.354]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.354]                 ...future.rng), started = ...future.startTime, 
[10:22:49.354]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.354]             version = "1.8"), class = "FutureResult")
[10:22:49.354]     }, finally = {
[10:22:49.354]         if (!identical(...future.workdir, getwd())) 
[10:22:49.354]             setwd(...future.workdir)
[10:22:49.354]         {
[10:22:49.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.354]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.354]             }
[10:22:49.354]             base::options(...future.oldOptions)
[10:22:49.354]             if (.Platform$OS.type == "windows") {
[10:22:49.354]                 old_names <- names(...future.oldEnvVars)
[10:22:49.354]                 envs <- base::Sys.getenv()
[10:22:49.354]                 names <- names(envs)
[10:22:49.354]                 common <- intersect(names, old_names)
[10:22:49.354]                 added <- setdiff(names, old_names)
[10:22:49.354]                 removed <- setdiff(old_names, names)
[10:22:49.354]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.354]                   envs[common]]
[10:22:49.354]                 NAMES <- toupper(changed)
[10:22:49.354]                 args <- list()
[10:22:49.354]                 for (kk in seq_along(NAMES)) {
[10:22:49.354]                   name <- changed[[kk]]
[10:22:49.354]                   NAME <- NAMES[[kk]]
[10:22:49.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.354]                     next
[10:22:49.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.354]                 }
[10:22:49.354]                 NAMES <- toupper(added)
[10:22:49.354]                 for (kk in seq_along(NAMES)) {
[10:22:49.354]                   name <- added[[kk]]
[10:22:49.354]                   NAME <- NAMES[[kk]]
[10:22:49.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.354]                     next
[10:22:49.354]                   args[[name]] <- ""
[10:22:49.354]                 }
[10:22:49.354]                 NAMES <- toupper(removed)
[10:22:49.354]                 for (kk in seq_along(NAMES)) {
[10:22:49.354]                   name <- removed[[kk]]
[10:22:49.354]                   NAME <- NAMES[[kk]]
[10:22:49.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.354]                     next
[10:22:49.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.354]                 }
[10:22:49.354]                 if (length(args) > 0) 
[10:22:49.354]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.354]             }
[10:22:49.354]             else {
[10:22:49.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.354]             }
[10:22:49.354]             {
[10:22:49.354]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.354]                   0L) {
[10:22:49.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.354]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.354]                   base::options(opts)
[10:22:49.354]                 }
[10:22:49.354]                 {
[10:22:49.354]                   {
[10:22:49.354]                     NULL
[10:22:49.354]                     RNGkind("Mersenne-Twister")
[10:22:49.354]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.354]                       inherits = FALSE)
[10:22:49.354]                   }
[10:22:49.354]                   options(future.plan = NULL)
[10:22:49.354]                   if (is.na(NA_character_)) 
[10:22:49.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.354]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.354]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.354]                     envir = parent.frame()) 
[10:22:49.354]                   {
[10:22:49.354]                     if (is.function(workers)) 
[10:22:49.354]                       workers <- workers()
[10:22:49.354]                     workers <- structure(as.integer(workers), 
[10:22:49.354]                       class = class(workers))
[10:22:49.354]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.354]                       workers >= 1)
[10:22:49.354]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.354]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.354]                     }
[10:22:49.354]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.354]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.354]                       envir = envir)
[10:22:49.354]                     if (!future$lazy) 
[10:22:49.354]                       future <- run(future)
[10:22:49.354]                     invisible(future)
[10:22:49.354]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.354]                 }
[10:22:49.354]             }
[10:22:49.354]         }
[10:22:49.354]     })
[10:22:49.354]     if (TRUE) {
[10:22:49.354]         base::sink(type = "output", split = FALSE)
[10:22:49.354]         if (TRUE) {
[10:22:49.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.354]         }
[10:22:49.354]         else {
[10:22:49.354]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.354]         }
[10:22:49.354]         base::close(...future.stdout)
[10:22:49.354]         ...future.stdout <- NULL
[10:22:49.354]     }
[10:22:49.354]     ...future.result$conditions <- ...future.conditions
[10:22:49.354]     ...future.result$finished <- base::Sys.time()
[10:22:49.354]     ...future.result
[10:22:49.354] }
[10:22:49.355] assign_globals() ...
[10:22:49.356] List of 7
[10:22:49.356]  $ ...future.FUN            :function (x)  
[10:22:49.356]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:49.356]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.356]  $ future.call.arguments    : list()
[10:22:49.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.356]  $ ...future.elements_ii    :List of 3
[10:22:49.356]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.356]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.356]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.356]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.356]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.356]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.356]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.356]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.356]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.356]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.356]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.356]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.356]  $ ...future.seeds_ii       : NULL
[10:22:49.356]  $ ...future.globals.maxSize: NULL
[10:22:49.356]  - attr(*, "where")=List of 7
[10:22:49.356]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.356]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:22:49.356]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:22:49.356]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.356]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.356]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.356]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.356]  - attr(*, "resolved")= logi FALSE
[10:22:49.356]  - attr(*, "total_size")= num 2320
[10:22:49.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.356]  - attr(*, "already-done")= logi TRUE
[10:22:49.365] - reassign environment for ‘...future.FUN’
[10:22:49.365] - copied ‘...future.FUN’ to environment
[10:22:49.365] - copied ‘breaks’ to environment
[10:22:49.365] - copied ‘wool’ to environment
[10:22:49.365] - copied ‘future.call.arguments’ to environment
[10:22:49.365] - copied ‘...future.elements_ii’ to environment
[10:22:49.365] - copied ‘...future.seeds_ii’ to environment
[10:22:49.366] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.366] assign_globals() ... done
[10:22:49.366] plan(): Setting new future strategy stack:
[10:22:49.366] List of future strategies:
[10:22:49.366] 1. sequential:
[10:22:49.366]    - args: function (..., envir = parent.frame())
[10:22:49.366]    - tweaked: FALSE
[10:22:49.366]    - call: NULL
[10:22:49.366] plan(): nbrOfWorkers() = 1
[10:22:49.369] plan(): Setting new future strategy stack:
[10:22:49.369] List of future strategies:
[10:22:49.369] 1. multisession:
[10:22:49.369]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.369]    - tweaked: FALSE
[10:22:49.369]    - call: plan(strategy)
[10:22:49.372] plan(): nbrOfWorkers() = 1
[10:22:49.372] SequentialFuture started (and completed)
[10:22:49.373] - Launch lazy future ... done
[10:22:49.373] run() for ‘SequentialFuture’ ... done
[10:22:49.373] Created future:
[10:22:49.373] SequentialFuture:
[10:22:49.373] Label: ‘future_by-1’
[10:22:49.373] Expression:
[10:22:49.373] {
[10:22:49.373]     do.call(function(...) {
[10:22:49.373]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.373]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.373]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.373]             on.exit(options(oopts), add = TRUE)
[10:22:49.373]         }
[10:22:49.373]         {
[10:22:49.373]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.373]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.373]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.373]             })
[10:22:49.373]         }
[10:22:49.373]     }, args = future.call.arguments)
[10:22:49.373] }
[10:22:49.373] Lazy evaluation: FALSE
[10:22:49.373] Asynchronous evaluation: FALSE
[10:22:49.373] Local evaluation: TRUE
[10:22:49.373] Environment: 0x55f639e0bea0
[10:22:49.373] Capture standard output: TRUE
[10:22:49.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.373] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:22:49.373] Packages: 1 packages (‘stats’)
[10:22:49.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.373] Resolved: TRUE
[10:22:49.373] Value: 25.57 KiB of class ‘list’
[10:22:49.373] Early signaling: FALSE
[10:22:49.373] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.373] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.376] Chunk #1 of 1 ... DONE
[10:22:49.376] Launching 1 futures (chunks) ... DONE
[10:22:49.376] Resolving 1 futures (chunks) ...
[10:22:49.376] resolve() on list ...
[10:22:49.376]  recursive: 0
[10:22:49.376]  length: 1
[10:22:49.376] 
[10:22:49.376] resolved() for ‘SequentialFuture’ ...
[10:22:49.376] - state: ‘finished’
[10:22:49.376] - run: TRUE
[10:22:49.377] - result: ‘FutureResult’
[10:22:49.377] resolved() for ‘SequentialFuture’ ... done
[10:22:49.377] Future #1
[10:22:49.377] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.377] - nx: 1
[10:22:49.377] - relay: TRUE
[10:22:49.377] - stdout: TRUE
[10:22:49.377] - signal: TRUE
[10:22:49.377] - resignal: FALSE
[10:22:49.377] - force: TRUE
[10:22:49.378] - relayed: [n=1] FALSE
[10:22:49.378] - queued futures: [n=1] FALSE
[10:22:49.378]  - until=1
[10:22:49.378]  - relaying element #1
[10:22:49.378] - relayed: [n=1] TRUE
[10:22:49.378] - queued futures: [n=1] TRUE
[10:22:49.378] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.378]  length: 0 (resolved future 1)
[10:22:49.378] Relaying remaining futures
[10:22:49.378] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.378] - nx: 1
[10:22:49.379] - relay: TRUE
[10:22:49.379] - stdout: TRUE
[10:22:49.379] - signal: TRUE
[10:22:49.379] - resignal: FALSE
[10:22:49.379] - force: TRUE
[10:22:49.379] - relayed: [n=1] TRUE
[10:22:49.379] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.379] - relayed: [n=1] TRUE
[10:22:49.379] - queued futures: [n=1] TRUE
[10:22:49.379] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.379] resolve() on list ... DONE
[10:22:49.380]  - Number of value chunks collected: 1
[10:22:49.380] Resolving 1 futures (chunks) ... DONE
[10:22:49.380] Reducing values from 1 chunks ...
[10:22:49.380]  - Number of values collected after concatenation: 3
[10:22:49.380]  - Number of values expected: 3
[10:22:49.380] Reducing values from 1 chunks ... DONE
[10:22:49.380] future_lapply() ... DONE
[10:22:49.380] future_by_internal() ... DONE
[10:22:49.381] future_by_internal() ...
[10:22:49.381] future_lapply() ...
[10:22:49.384] Number of chunks: 1
[10:22:49.384] getGlobalsAndPackagesXApply() ...
[10:22:49.384]  - future.globals: TRUE
[10:22:49.384] getGlobalsAndPackages() ...
[10:22:49.385] Searching for globals...
[10:22:49.386] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.386] Searching for globals ... DONE
[10:22:49.386] Resolving globals: FALSE
[10:22:49.386] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.386] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.387] - globals: [1] ‘FUN’
[10:22:49.387] 
[10:22:49.387] getGlobalsAndPackages() ... DONE
[10:22:49.387]  - globals found/used: [n=1] ‘FUN’
[10:22:49.387]  - needed namespaces: [n=0] 
[10:22:49.387] Finding globals ... DONE
[10:22:49.387]  - use_args: TRUE
[10:22:49.387]  - Getting '...' globals ...
[10:22:49.387] resolve() on list ...
[10:22:49.388]  recursive: 0
[10:22:49.388]  length: 1
[10:22:49.388]  elements: ‘...’
[10:22:49.388]  length: 0 (resolved future 1)
[10:22:49.388] resolve() on list ... DONE
[10:22:49.388]    - '...' content: [n=0] 
[10:22:49.388] List of 1
[10:22:49.388]  $ ...: list()
[10:22:49.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.388]  - attr(*, "where")=List of 1
[10:22:49.388]   ..$ ...:<environment: 0x55f637b88a30> 
[10:22:49.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.388]  - attr(*, "resolved")= logi TRUE
[10:22:49.388]  - attr(*, "total_size")= num NA
[10:22:49.390]  - Getting '...' globals ... DONE
[10:22:49.391] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.391] List of 2
[10:22:49.391]  $ ...future.FUN:function (object, ...)  
[10:22:49.391]  $ ...          : list()
[10:22:49.391]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.391]  - attr(*, "where")=List of 2
[10:22:49.391]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.391]   ..$ ...          :<environment: 0x55f637b88a30> 
[10:22:49.391]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.391]  - attr(*, "resolved")= logi FALSE
[10:22:49.391]  - attr(*, "total_size")= num 1240
[10:22:49.393] Packages to be attached in all futures: [n=0] 
[10:22:49.393] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.393] Number of futures (= number of chunks): 1
[10:22:49.394] Launching 1 futures (chunks) ...
[10:22:49.394] Chunk #1 of 1 ...
[10:22:49.394]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.394] getGlobalsAndPackages() ...
[10:22:49.394] Searching for globals...
[10:22:49.396] 
[10:22:49.396] Searching for globals ... DONE
[10:22:49.396] - globals: [0] <none>
[10:22:49.396] getGlobalsAndPackages() ... DONE
[10:22:49.396]    + additional globals found: [n=0] 
[10:22:49.396]    + additional namespaces needed: [n=0] 
[10:22:49.396]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.396]  - seeds: <none>
[10:22:49.396]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.396] getGlobalsAndPackages() ...
[10:22:49.397] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.397] Resolving globals: FALSE
[10:22:49.397] Tweak future expression to call with '...' arguments ...
[10:22:49.397] {
[10:22:49.397]     do.call(function(...) {
[10:22:49.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.397]             on.exit(options(oopts), add = TRUE)
[10:22:49.397]         }
[10:22:49.397]         {
[10:22:49.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.397]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.397]             })
[10:22:49.397]         }
[10:22:49.397]     }, args = future.call.arguments)
[10:22:49.397] }
[10:22:49.397] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.398] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.398] 
[10:22:49.398] getGlobalsAndPackages() ... DONE
[10:22:49.398] run() for ‘Future’ ...
[10:22:49.398] - state: ‘created’
[10:22:49.398] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.402]   - Field: ‘label’
[10:22:49.402]   - Field: ‘local’
[10:22:49.402]   - Field: ‘owner’
[10:22:49.402]   - Field: ‘envir’
[10:22:49.402]   - Field: ‘packages’
[10:22:49.402]   - Field: ‘gc’
[10:22:49.403]   - Field: ‘conditions’
[10:22:49.403]   - Field: ‘expr’
[10:22:49.403]   - Field: ‘uuid’
[10:22:49.403]   - Field: ‘seed’
[10:22:49.403]   - Field: ‘version’
[10:22:49.403]   - Field: ‘result’
[10:22:49.403]   - Field: ‘asynchronous’
[10:22:49.403]   - Field: ‘calls’
[10:22:49.403]   - Field: ‘globals’
[10:22:49.403]   - Field: ‘stdout’
[10:22:49.403]   - Field: ‘earlySignal’
[10:22:49.404]   - Field: ‘lazy’
[10:22:49.404]   - Field: ‘state’
[10:22:49.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.404] - Launch lazy future ...
[10:22:49.404] Packages needed by the future expression (n = 0): <none>
[10:22:49.404] Packages needed by future strategies (n = 0): <none>
[10:22:49.405] {
[10:22:49.405]     {
[10:22:49.405]         {
[10:22:49.405]             ...future.startTime <- base::Sys.time()
[10:22:49.405]             {
[10:22:49.405]                 {
[10:22:49.405]                   {
[10:22:49.405]                     base::local({
[10:22:49.405]                       has_future <- base::requireNamespace("future", 
[10:22:49.405]                         quietly = TRUE)
[10:22:49.405]                       if (has_future) {
[10:22:49.405]                         ns <- base::getNamespace("future")
[10:22:49.405]                         version <- ns[[".package"]][["version"]]
[10:22:49.405]                         if (is.null(version)) 
[10:22:49.405]                           version <- utils::packageVersion("future")
[10:22:49.405]                       }
[10:22:49.405]                       else {
[10:22:49.405]                         version <- NULL
[10:22:49.405]                       }
[10:22:49.405]                       if (!has_future || version < "1.8.0") {
[10:22:49.405]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.405]                           "", base::R.version$version.string), 
[10:22:49.405]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.405]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.405]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.405]                             "release", "version")], collapse = " "), 
[10:22:49.405]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.405]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.405]                           info)
[10:22:49.405]                         info <- base::paste(info, collapse = "; ")
[10:22:49.405]                         if (!has_future) {
[10:22:49.405]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.405]                             info)
[10:22:49.405]                         }
[10:22:49.405]                         else {
[10:22:49.405]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.405]                             info, version)
[10:22:49.405]                         }
[10:22:49.405]                         base::stop(msg)
[10:22:49.405]                       }
[10:22:49.405]                     })
[10:22:49.405]                   }
[10:22:49.405]                   options(future.plan = NULL)
[10:22:49.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.405]                 }
[10:22:49.405]                 ...future.workdir <- getwd()
[10:22:49.405]             }
[10:22:49.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.405]         }
[10:22:49.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.405]             base::names(...future.oldOptions))
[10:22:49.405]     }
[10:22:49.405]     if (FALSE) {
[10:22:49.405]     }
[10:22:49.405]     else {
[10:22:49.405]         if (TRUE) {
[10:22:49.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.405]                 open = "w")
[10:22:49.405]         }
[10:22:49.405]         else {
[10:22:49.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.405]         }
[10:22:49.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.405]             base::sink(type = "output", split = FALSE)
[10:22:49.405]             base::close(...future.stdout)
[10:22:49.405]         }, add = TRUE)
[10:22:49.405]     }
[10:22:49.405]     ...future.frame <- base::sys.nframe()
[10:22:49.405]     ...future.conditions <- base::list()
[10:22:49.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.405]     if (FALSE) {
[10:22:49.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.405]     }
[10:22:49.405]     ...future.result <- base::tryCatch({
[10:22:49.405]         base::withCallingHandlers({
[10:22:49.405]             ...future.value <- base::withVisible(base::local({
[10:22:49.405]                 do.call(function(...) {
[10:22:49.405]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.405]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.405]                     ...future.globals.maxSize)) {
[10:22:49.405]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.405]                     on.exit(options(oopts), add = TRUE)
[10:22:49.405]                   }
[10:22:49.405]                   {
[10:22:49.405]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.405]                       FUN = function(jj) {
[10:22:49.405]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.405]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.405]                       })
[10:22:49.405]                   }
[10:22:49.405]                 }, args = future.call.arguments)
[10:22:49.405]             }))
[10:22:49.405]             future::FutureResult(value = ...future.value$value, 
[10:22:49.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.405]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.405]                     ...future.globalenv.names))
[10:22:49.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.405]         }, condition = base::local({
[10:22:49.405]             c <- base::c
[10:22:49.405]             inherits <- base::inherits
[10:22:49.405]             invokeRestart <- base::invokeRestart
[10:22:49.405]             length <- base::length
[10:22:49.405]             list <- base::list
[10:22:49.405]             seq.int <- base::seq.int
[10:22:49.405]             signalCondition <- base::signalCondition
[10:22:49.405]             sys.calls <- base::sys.calls
[10:22:49.405]             `[[` <- base::`[[`
[10:22:49.405]             `+` <- base::`+`
[10:22:49.405]             `<<-` <- base::`<<-`
[10:22:49.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.405]                   3L)]
[10:22:49.405]             }
[10:22:49.405]             function(cond) {
[10:22:49.405]                 is_error <- inherits(cond, "error")
[10:22:49.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.405]                   NULL)
[10:22:49.405]                 if (is_error) {
[10:22:49.405]                   sessionInformation <- function() {
[10:22:49.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.405]                       search = base::search(), system = base::Sys.info())
[10:22:49.405]                   }
[10:22:49.405]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.405]                     cond$call), session = sessionInformation(), 
[10:22:49.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.405]                   signalCondition(cond)
[10:22:49.405]                 }
[10:22:49.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.405]                 "immediateCondition"))) {
[10:22:49.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.405]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.405]                   if (TRUE && !signal) {
[10:22:49.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.405]                     {
[10:22:49.405]                       inherits <- base::inherits
[10:22:49.405]                       invokeRestart <- base::invokeRestart
[10:22:49.405]                       is.null <- base::is.null
[10:22:49.405]                       muffled <- FALSE
[10:22:49.405]                       if (inherits(cond, "message")) {
[10:22:49.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.405]                         if (muffled) 
[10:22:49.405]                           invokeRestart("muffleMessage")
[10:22:49.405]                       }
[10:22:49.405]                       else if (inherits(cond, "warning")) {
[10:22:49.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.405]                         if (muffled) 
[10:22:49.405]                           invokeRestart("muffleWarning")
[10:22:49.405]                       }
[10:22:49.405]                       else if (inherits(cond, "condition")) {
[10:22:49.405]                         if (!is.null(pattern)) {
[10:22:49.405]                           computeRestarts <- base::computeRestarts
[10:22:49.405]                           grepl <- base::grepl
[10:22:49.405]                           restarts <- computeRestarts(cond)
[10:22:49.405]                           for (restart in restarts) {
[10:22:49.405]                             name <- restart$name
[10:22:49.405]                             if (is.null(name)) 
[10:22:49.405]                               next
[10:22:49.405]                             if (!grepl(pattern, name)) 
[10:22:49.405]                               next
[10:22:49.405]                             invokeRestart(restart)
[10:22:49.405]                             muffled <- TRUE
[10:22:49.405]                             break
[10:22:49.405]                           }
[10:22:49.405]                         }
[10:22:49.405]                       }
[10:22:49.405]                       invisible(muffled)
[10:22:49.405]                     }
[10:22:49.405]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.405]                   }
[10:22:49.405]                 }
[10:22:49.405]                 else {
[10:22:49.405]                   if (TRUE) {
[10:22:49.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.405]                     {
[10:22:49.405]                       inherits <- base::inherits
[10:22:49.405]                       invokeRestart <- base::invokeRestart
[10:22:49.405]                       is.null <- base::is.null
[10:22:49.405]                       muffled <- FALSE
[10:22:49.405]                       if (inherits(cond, "message")) {
[10:22:49.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.405]                         if (muffled) 
[10:22:49.405]                           invokeRestart("muffleMessage")
[10:22:49.405]                       }
[10:22:49.405]                       else if (inherits(cond, "warning")) {
[10:22:49.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.405]                         if (muffled) 
[10:22:49.405]                           invokeRestart("muffleWarning")
[10:22:49.405]                       }
[10:22:49.405]                       else if (inherits(cond, "condition")) {
[10:22:49.405]                         if (!is.null(pattern)) {
[10:22:49.405]                           computeRestarts <- base::computeRestarts
[10:22:49.405]                           grepl <- base::grepl
[10:22:49.405]                           restarts <- computeRestarts(cond)
[10:22:49.405]                           for (restart in restarts) {
[10:22:49.405]                             name <- restart$name
[10:22:49.405]                             if (is.null(name)) 
[10:22:49.405]                               next
[10:22:49.405]                             if (!grepl(pattern, name)) 
[10:22:49.405]                               next
[10:22:49.405]                             invokeRestart(restart)
[10:22:49.405]                             muffled <- TRUE
[10:22:49.405]                             break
[10:22:49.405]                           }
[10:22:49.405]                         }
[10:22:49.405]                       }
[10:22:49.405]                       invisible(muffled)
[10:22:49.405]                     }
[10:22:49.405]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.405]                   }
[10:22:49.405]                 }
[10:22:49.405]             }
[10:22:49.405]         }))
[10:22:49.405]     }, error = function(ex) {
[10:22:49.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.405]                 ...future.rng), started = ...future.startTime, 
[10:22:49.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.405]             version = "1.8"), class = "FutureResult")
[10:22:49.405]     }, finally = {
[10:22:49.405]         if (!identical(...future.workdir, getwd())) 
[10:22:49.405]             setwd(...future.workdir)
[10:22:49.405]         {
[10:22:49.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.405]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.405]             }
[10:22:49.405]             base::options(...future.oldOptions)
[10:22:49.405]             if (.Platform$OS.type == "windows") {
[10:22:49.405]                 old_names <- names(...future.oldEnvVars)
[10:22:49.405]                 envs <- base::Sys.getenv()
[10:22:49.405]                 names <- names(envs)
[10:22:49.405]                 common <- intersect(names, old_names)
[10:22:49.405]                 added <- setdiff(names, old_names)
[10:22:49.405]                 removed <- setdiff(old_names, names)
[10:22:49.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.405]                   envs[common]]
[10:22:49.405]                 NAMES <- toupper(changed)
[10:22:49.405]                 args <- list()
[10:22:49.405]                 for (kk in seq_along(NAMES)) {
[10:22:49.405]                   name <- changed[[kk]]
[10:22:49.405]                   NAME <- NAMES[[kk]]
[10:22:49.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.405]                     next
[10:22:49.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.405]                 }
[10:22:49.405]                 NAMES <- toupper(added)
[10:22:49.405]                 for (kk in seq_along(NAMES)) {
[10:22:49.405]                   name <- added[[kk]]
[10:22:49.405]                   NAME <- NAMES[[kk]]
[10:22:49.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.405]                     next
[10:22:49.405]                   args[[name]] <- ""
[10:22:49.405]                 }
[10:22:49.405]                 NAMES <- toupper(removed)
[10:22:49.405]                 for (kk in seq_along(NAMES)) {
[10:22:49.405]                   name <- removed[[kk]]
[10:22:49.405]                   NAME <- NAMES[[kk]]
[10:22:49.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.405]                     next
[10:22:49.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.405]                 }
[10:22:49.405]                 if (length(args) > 0) 
[10:22:49.405]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.405]             }
[10:22:49.405]             else {
[10:22:49.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.405]             }
[10:22:49.405]             {
[10:22:49.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.405]                   0L) {
[10:22:49.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.405]                   base::options(opts)
[10:22:49.405]                 }
[10:22:49.405]                 {
[10:22:49.405]                   {
[10:22:49.405]                     NULL
[10:22:49.405]                     RNGkind("Mersenne-Twister")
[10:22:49.405]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.405]                       inherits = FALSE)
[10:22:49.405]                   }
[10:22:49.405]                   options(future.plan = NULL)
[10:22:49.405]                   if (is.na(NA_character_)) 
[10:22:49.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.405]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.405]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.405]                     envir = parent.frame()) 
[10:22:49.405]                   {
[10:22:49.405]                     if (is.function(workers)) 
[10:22:49.405]                       workers <- workers()
[10:22:49.405]                     workers <- structure(as.integer(workers), 
[10:22:49.405]                       class = class(workers))
[10:22:49.405]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.405]                       workers >= 1)
[10:22:49.405]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.405]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.405]                     }
[10:22:49.405]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.405]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.405]                       envir = envir)
[10:22:49.405]                     if (!future$lazy) 
[10:22:49.405]                       future <- run(future)
[10:22:49.405]                     invisible(future)
[10:22:49.405]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.405]                 }
[10:22:49.405]             }
[10:22:49.405]         }
[10:22:49.405]     })
[10:22:49.405]     if (TRUE) {
[10:22:49.405]         base::sink(type = "output", split = FALSE)
[10:22:49.405]         if (TRUE) {
[10:22:49.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.405]         }
[10:22:49.405]         else {
[10:22:49.405]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.405]         }
[10:22:49.405]         base::close(...future.stdout)
[10:22:49.405]         ...future.stdout <- NULL
[10:22:49.405]     }
[10:22:49.405]     ...future.result$conditions <- ...future.conditions
[10:22:49.405]     ...future.result$finished <- base::Sys.time()
[10:22:49.405]     ...future.result
[10:22:49.405] }
[10:22:49.406] assign_globals() ...
[10:22:49.407] List of 5
[10:22:49.407]  $ ...future.FUN            :function (object, ...)  
[10:22:49.407]  $ future.call.arguments    : list()
[10:22:49.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.407]  $ ...future.elements_ii    :List of 3
[10:22:49.407]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.407]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.407]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.407]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.407]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.407]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.407]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.407]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.407]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.407]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.407]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.407]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.407]  $ ...future.seeds_ii       : NULL
[10:22:49.407]  $ ...future.globals.maxSize: NULL
[10:22:49.407]  - attr(*, "where")=List of 5
[10:22:49.407]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.407]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.407]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.407]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.407]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.407]  - attr(*, "resolved")= logi FALSE
[10:22:49.407]  - attr(*, "total_size")= num 1240
[10:22:49.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.407]  - attr(*, "already-done")= logi TRUE
[10:22:49.415] - copied ‘...future.FUN’ to environment
[10:22:49.415] - copied ‘future.call.arguments’ to environment
[10:22:49.415] - copied ‘...future.elements_ii’ to environment
[10:22:49.415] - copied ‘...future.seeds_ii’ to environment
[10:22:49.416] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.416] assign_globals() ... done
[10:22:49.416] plan(): Setting new future strategy stack:
[10:22:49.416] List of future strategies:
[10:22:49.416] 1. sequential:
[10:22:49.416]    - args: function (..., envir = parent.frame())
[10:22:49.416]    - tweaked: FALSE
[10:22:49.416]    - call: NULL
[10:22:49.416] plan(): nbrOfWorkers() = 1
[10:22:49.421] plan(): Setting new future strategy stack:
[10:22:49.421] List of future strategies:
[10:22:49.421] 1. multisession:
[10:22:49.421]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.421]    - tweaked: FALSE
[10:22:49.421]    - call: plan(strategy)
[10:22:49.424] plan(): nbrOfWorkers() = 1
[10:22:49.425] SequentialFuture started (and completed)
[10:22:49.425] - Launch lazy future ... done
[10:22:49.425] run() for ‘SequentialFuture’ ... done
[10:22:49.425] Created future:
[10:22:49.425] SequentialFuture:
[10:22:49.425] Label: ‘future_by-1’
[10:22:49.425] Expression:
[10:22:49.425] {
[10:22:49.425]     do.call(function(...) {
[10:22:49.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.425]             on.exit(options(oopts), add = TRUE)
[10:22:49.425]         }
[10:22:49.425]         {
[10:22:49.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.425]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.425]             })
[10:22:49.425]         }
[10:22:49.425]     }, args = future.call.arguments)
[10:22:49.425] }
[10:22:49.425] Lazy evaluation: FALSE
[10:22:49.425] Asynchronous evaluation: FALSE
[10:22:49.425] Local evaluation: TRUE
[10:22:49.425] Environment: 0x55f63824f4c0
[10:22:49.425] Capture standard output: TRUE
[10:22:49.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.425] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.425] Packages: <none>
[10:22:49.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.425] Resolved: TRUE
[10:22:49.425] Value: 5.37 KiB of class ‘list’
[10:22:49.425] Early signaling: FALSE
[10:22:49.425] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.425] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.427] Chunk #1 of 1 ... DONE
[10:22:49.427] Launching 1 futures (chunks) ... DONE
[10:22:49.427] Resolving 1 futures (chunks) ...
[10:22:49.427] resolve() on list ...
[10:22:49.427]  recursive: 0
[10:22:49.427]  length: 1
[10:22:49.427] 
[10:22:49.427] resolved() for ‘SequentialFuture’ ...
[10:22:49.428] - state: ‘finished’
[10:22:49.428] - run: TRUE
[10:22:49.428] - result: ‘FutureResult’
[10:22:49.428] resolved() for ‘SequentialFuture’ ... done
[10:22:49.428] Future #1
[10:22:49.428] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.428] - nx: 1
[10:22:49.428] - relay: TRUE
[10:22:49.428] - stdout: TRUE
[10:22:49.428] - signal: TRUE
[10:22:49.429] - resignal: FALSE
[10:22:49.429] - force: TRUE
[10:22:49.429] - relayed: [n=1] FALSE
[10:22:49.429] - queued futures: [n=1] FALSE
[10:22:49.429]  - until=1
[10:22:49.429]  - relaying element #1
[10:22:49.429] - relayed: [n=1] TRUE
[10:22:49.429] - queued futures: [n=1] TRUE
[10:22:49.429] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.430]  length: 0 (resolved future 1)
[10:22:49.430] Relaying remaining futures
[10:22:49.430] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.430] - nx: 1
[10:22:49.430] - relay: TRUE
[10:22:49.430] - stdout: TRUE
[10:22:49.430] - signal: TRUE
[10:22:49.430] - resignal: FALSE
[10:22:49.430] - force: TRUE
[10:22:49.430] - relayed: [n=1] TRUE
[10:22:49.430] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.431] - relayed: [n=1] TRUE
[10:22:49.431] - queued futures: [n=1] TRUE
[10:22:49.431] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.431] resolve() on list ... DONE
[10:22:49.431]  - Number of value chunks collected: 1
[10:22:49.431] Resolving 1 futures (chunks) ... DONE
[10:22:49.431] Reducing values from 1 chunks ...
[10:22:49.431]  - Number of values collected after concatenation: 3
[10:22:49.431]  - Number of values expected: 3
[10:22:49.431] Reducing values from 1 chunks ... DONE
[10:22:49.431] future_lapply() ... DONE
[10:22:49.432] future_by_internal() ... DONE
[10:22:49.432] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:22:49.433] future_lapply() ...
[10:22:49.436] Number of chunks: 1
[10:22:49.436] getGlobalsAndPackagesXApply() ...
[10:22:49.437]  - future.globals: TRUE
[10:22:49.437] getGlobalsAndPackages() ...
[10:22:49.437] Searching for globals...
[10:22:49.438] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.438] Searching for globals ... DONE
[10:22:49.438] Resolving globals: FALSE
[10:22:49.438] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.439] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.439] - globals: [1] ‘FUN’
[10:22:49.439] 
[10:22:49.439] getGlobalsAndPackages() ... DONE
[10:22:49.439]  - globals found/used: [n=1] ‘FUN’
[10:22:49.439]  - needed namespaces: [n=0] 
[10:22:49.439] Finding globals ... DONE
[10:22:49.439]  - use_args: TRUE
[10:22:49.439]  - Getting '...' globals ...
[10:22:49.440] resolve() on list ...
[10:22:49.440]  recursive: 0
[10:22:49.440]  length: 1
[10:22:49.440]  elements: ‘...’
[10:22:49.440]  length: 0 (resolved future 1)
[10:22:49.440] resolve() on list ... DONE
[10:22:49.440]    - '...' content: [n=0] 
[10:22:49.440] List of 1
[10:22:49.440]  $ ...: list()
[10:22:49.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.440]  - attr(*, "where")=List of 1
[10:22:49.440]   ..$ ...:<environment: 0x55f639a9d708> 
[10:22:49.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.440]  - attr(*, "resolved")= logi TRUE
[10:22:49.440]  - attr(*, "total_size")= num NA
[10:22:49.446]  - Getting '...' globals ... DONE
[10:22:49.446] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.446] List of 2
[10:22:49.446]  $ ...future.FUN:function (object, ...)  
[10:22:49.446]  $ ...          : list()
[10:22:49.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.446]  - attr(*, "where")=List of 2
[10:22:49.446]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.446]   ..$ ...          :<environment: 0x55f639a9d708> 
[10:22:49.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.446]  - attr(*, "resolved")= logi FALSE
[10:22:49.446]  - attr(*, "total_size")= num 1240
[10:22:49.449] Packages to be attached in all futures: [n=0] 
[10:22:49.450] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.450] Number of futures (= number of chunks): 1
[10:22:49.450] Launching 1 futures (chunks) ...
[10:22:49.450] Chunk #1 of 1 ...
[10:22:49.450]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.450] getGlobalsAndPackages() ...
[10:22:49.450] Searching for globals...
[10:22:49.451] 
[10:22:49.451] Searching for globals ... DONE
[10:22:49.451] - globals: [0] <none>
[10:22:49.451] getGlobalsAndPackages() ... DONE
[10:22:49.451]    + additional globals found: [n=0] 
[10:22:49.451]    + additional namespaces needed: [n=0] 
[10:22:49.451]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.452]  - seeds: <none>
[10:22:49.452]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.452] getGlobalsAndPackages() ...
[10:22:49.452] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.452] Resolving globals: FALSE
[10:22:49.452] Tweak future expression to call with '...' arguments ...
[10:22:49.452] {
[10:22:49.452]     do.call(function(...) {
[10:22:49.452]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.452]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.452]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.452]             on.exit(options(oopts), add = TRUE)
[10:22:49.452]         }
[10:22:49.452]         {
[10:22:49.452]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.452]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.452]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.452]             })
[10:22:49.452]         }
[10:22:49.452]     }, args = future.call.arguments)
[10:22:49.452] }
[10:22:49.452] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.453] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.453] 
[10:22:49.453] getGlobalsAndPackages() ... DONE
[10:22:49.453] run() for ‘Future’ ...
[10:22:49.454] - state: ‘created’
[10:22:49.454] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.457]   - Field: ‘label’
[10:22:49.458]   - Field: ‘local’
[10:22:49.458]   - Field: ‘owner’
[10:22:49.458]   - Field: ‘envir’
[10:22:49.458]   - Field: ‘packages’
[10:22:49.458]   - Field: ‘gc’
[10:22:49.458]   - Field: ‘conditions’
[10:22:49.458]   - Field: ‘expr’
[10:22:49.458]   - Field: ‘uuid’
[10:22:49.458]   - Field: ‘seed’
[10:22:49.458]   - Field: ‘version’
[10:22:49.459]   - Field: ‘result’
[10:22:49.459]   - Field: ‘asynchronous’
[10:22:49.459]   - Field: ‘calls’
[10:22:49.459]   - Field: ‘globals’
[10:22:49.459]   - Field: ‘stdout’
[10:22:49.459]   - Field: ‘earlySignal’
[10:22:49.459]   - Field: ‘lazy’
[10:22:49.459]   - Field: ‘state’
[10:22:49.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.459] - Launch lazy future ...
[10:22:49.460] Packages needed by the future expression (n = 0): <none>
[10:22:49.460] Packages needed by future strategies (n = 0): <none>
[10:22:49.460] {
[10:22:49.460]     {
[10:22:49.460]         {
[10:22:49.460]             ...future.startTime <- base::Sys.time()
[10:22:49.460]             {
[10:22:49.460]                 {
[10:22:49.460]                   {
[10:22:49.460]                     base::local({
[10:22:49.460]                       has_future <- base::requireNamespace("future", 
[10:22:49.460]                         quietly = TRUE)
[10:22:49.460]                       if (has_future) {
[10:22:49.460]                         ns <- base::getNamespace("future")
[10:22:49.460]                         version <- ns[[".package"]][["version"]]
[10:22:49.460]                         if (is.null(version)) 
[10:22:49.460]                           version <- utils::packageVersion("future")
[10:22:49.460]                       }
[10:22:49.460]                       else {
[10:22:49.460]                         version <- NULL
[10:22:49.460]                       }
[10:22:49.460]                       if (!has_future || version < "1.8.0") {
[10:22:49.460]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.460]                           "", base::R.version$version.string), 
[10:22:49.460]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.460]                             "release", "version")], collapse = " "), 
[10:22:49.460]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.460]                           info)
[10:22:49.460]                         info <- base::paste(info, collapse = "; ")
[10:22:49.460]                         if (!has_future) {
[10:22:49.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.460]                             info)
[10:22:49.460]                         }
[10:22:49.460]                         else {
[10:22:49.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.460]                             info, version)
[10:22:49.460]                         }
[10:22:49.460]                         base::stop(msg)
[10:22:49.460]                       }
[10:22:49.460]                     })
[10:22:49.460]                   }
[10:22:49.460]                   options(future.plan = NULL)
[10:22:49.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.460]                 }
[10:22:49.460]                 ...future.workdir <- getwd()
[10:22:49.460]             }
[10:22:49.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.460]         }
[10:22:49.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.460]             base::names(...future.oldOptions))
[10:22:49.460]     }
[10:22:49.460]     if (FALSE) {
[10:22:49.460]     }
[10:22:49.460]     else {
[10:22:49.460]         if (TRUE) {
[10:22:49.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.460]                 open = "w")
[10:22:49.460]         }
[10:22:49.460]         else {
[10:22:49.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.460]         }
[10:22:49.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.460]             base::sink(type = "output", split = FALSE)
[10:22:49.460]             base::close(...future.stdout)
[10:22:49.460]         }, add = TRUE)
[10:22:49.460]     }
[10:22:49.460]     ...future.frame <- base::sys.nframe()
[10:22:49.460]     ...future.conditions <- base::list()
[10:22:49.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.460]     if (FALSE) {
[10:22:49.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.460]     }
[10:22:49.460]     ...future.result <- base::tryCatch({
[10:22:49.460]         base::withCallingHandlers({
[10:22:49.460]             ...future.value <- base::withVisible(base::local({
[10:22:49.460]                 do.call(function(...) {
[10:22:49.460]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.460]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.460]                     ...future.globals.maxSize)) {
[10:22:49.460]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.460]                     on.exit(options(oopts), add = TRUE)
[10:22:49.460]                   }
[10:22:49.460]                   {
[10:22:49.460]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.460]                       FUN = function(jj) {
[10:22:49.460]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.460]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.460]                       })
[10:22:49.460]                   }
[10:22:49.460]                 }, args = future.call.arguments)
[10:22:49.460]             }))
[10:22:49.460]             future::FutureResult(value = ...future.value$value, 
[10:22:49.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.460]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.460]                     ...future.globalenv.names))
[10:22:49.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.460]         }, condition = base::local({
[10:22:49.460]             c <- base::c
[10:22:49.460]             inherits <- base::inherits
[10:22:49.460]             invokeRestart <- base::invokeRestart
[10:22:49.460]             length <- base::length
[10:22:49.460]             list <- base::list
[10:22:49.460]             seq.int <- base::seq.int
[10:22:49.460]             signalCondition <- base::signalCondition
[10:22:49.460]             sys.calls <- base::sys.calls
[10:22:49.460]             `[[` <- base::`[[`
[10:22:49.460]             `+` <- base::`+`
[10:22:49.460]             `<<-` <- base::`<<-`
[10:22:49.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.460]                   3L)]
[10:22:49.460]             }
[10:22:49.460]             function(cond) {
[10:22:49.460]                 is_error <- inherits(cond, "error")
[10:22:49.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.460]                   NULL)
[10:22:49.460]                 if (is_error) {
[10:22:49.460]                   sessionInformation <- function() {
[10:22:49.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.460]                       search = base::search(), system = base::Sys.info())
[10:22:49.460]                   }
[10:22:49.460]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.460]                     cond$call), session = sessionInformation(), 
[10:22:49.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.460]                   signalCondition(cond)
[10:22:49.460]                 }
[10:22:49.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.460]                 "immediateCondition"))) {
[10:22:49.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.460]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.460]                   if (TRUE && !signal) {
[10:22:49.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.460]                     {
[10:22:49.460]                       inherits <- base::inherits
[10:22:49.460]                       invokeRestart <- base::invokeRestart
[10:22:49.460]                       is.null <- base::is.null
[10:22:49.460]                       muffled <- FALSE
[10:22:49.460]                       if (inherits(cond, "message")) {
[10:22:49.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.460]                         if (muffled) 
[10:22:49.460]                           invokeRestart("muffleMessage")
[10:22:49.460]                       }
[10:22:49.460]                       else if (inherits(cond, "warning")) {
[10:22:49.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.460]                         if (muffled) 
[10:22:49.460]                           invokeRestart("muffleWarning")
[10:22:49.460]                       }
[10:22:49.460]                       else if (inherits(cond, "condition")) {
[10:22:49.460]                         if (!is.null(pattern)) {
[10:22:49.460]                           computeRestarts <- base::computeRestarts
[10:22:49.460]                           grepl <- base::grepl
[10:22:49.460]                           restarts <- computeRestarts(cond)
[10:22:49.460]                           for (restart in restarts) {
[10:22:49.460]                             name <- restart$name
[10:22:49.460]                             if (is.null(name)) 
[10:22:49.460]                               next
[10:22:49.460]                             if (!grepl(pattern, name)) 
[10:22:49.460]                               next
[10:22:49.460]                             invokeRestart(restart)
[10:22:49.460]                             muffled <- TRUE
[10:22:49.460]                             break
[10:22:49.460]                           }
[10:22:49.460]                         }
[10:22:49.460]                       }
[10:22:49.460]                       invisible(muffled)
[10:22:49.460]                     }
[10:22:49.460]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.460]                   }
[10:22:49.460]                 }
[10:22:49.460]                 else {
[10:22:49.460]                   if (TRUE) {
[10:22:49.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.460]                     {
[10:22:49.460]                       inherits <- base::inherits
[10:22:49.460]                       invokeRestart <- base::invokeRestart
[10:22:49.460]                       is.null <- base::is.null
[10:22:49.460]                       muffled <- FALSE
[10:22:49.460]                       if (inherits(cond, "message")) {
[10:22:49.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.460]                         if (muffled) 
[10:22:49.460]                           invokeRestart("muffleMessage")
[10:22:49.460]                       }
[10:22:49.460]                       else if (inherits(cond, "warning")) {
[10:22:49.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.460]                         if (muffled) 
[10:22:49.460]                           invokeRestart("muffleWarning")
[10:22:49.460]                       }
[10:22:49.460]                       else if (inherits(cond, "condition")) {
[10:22:49.460]                         if (!is.null(pattern)) {
[10:22:49.460]                           computeRestarts <- base::computeRestarts
[10:22:49.460]                           grepl <- base::grepl
[10:22:49.460]                           restarts <- computeRestarts(cond)
[10:22:49.460]                           for (restart in restarts) {
[10:22:49.460]                             name <- restart$name
[10:22:49.460]                             if (is.null(name)) 
[10:22:49.460]                               next
[10:22:49.460]                             if (!grepl(pattern, name)) 
[10:22:49.460]                               next
[10:22:49.460]                             invokeRestart(restart)
[10:22:49.460]                             muffled <- TRUE
[10:22:49.460]                             break
[10:22:49.460]                           }
[10:22:49.460]                         }
[10:22:49.460]                       }
[10:22:49.460]                       invisible(muffled)
[10:22:49.460]                     }
[10:22:49.460]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.460]                   }
[10:22:49.460]                 }
[10:22:49.460]             }
[10:22:49.460]         }))
[10:22:49.460]     }, error = function(ex) {
[10:22:49.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.460]                 ...future.rng), started = ...future.startTime, 
[10:22:49.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.460]             version = "1.8"), class = "FutureResult")
[10:22:49.460]     }, finally = {
[10:22:49.460]         if (!identical(...future.workdir, getwd())) 
[10:22:49.460]             setwd(...future.workdir)
[10:22:49.460]         {
[10:22:49.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.460]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.460]             }
[10:22:49.460]             base::options(...future.oldOptions)
[10:22:49.460]             if (.Platform$OS.type == "windows") {
[10:22:49.460]                 old_names <- names(...future.oldEnvVars)
[10:22:49.460]                 envs <- base::Sys.getenv()
[10:22:49.460]                 names <- names(envs)
[10:22:49.460]                 common <- intersect(names, old_names)
[10:22:49.460]                 added <- setdiff(names, old_names)
[10:22:49.460]                 removed <- setdiff(old_names, names)
[10:22:49.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.460]                   envs[common]]
[10:22:49.460]                 NAMES <- toupper(changed)
[10:22:49.460]                 args <- list()
[10:22:49.460]                 for (kk in seq_along(NAMES)) {
[10:22:49.460]                   name <- changed[[kk]]
[10:22:49.460]                   NAME <- NAMES[[kk]]
[10:22:49.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.460]                     next
[10:22:49.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.460]                 }
[10:22:49.460]                 NAMES <- toupper(added)
[10:22:49.460]                 for (kk in seq_along(NAMES)) {
[10:22:49.460]                   name <- added[[kk]]
[10:22:49.460]                   NAME <- NAMES[[kk]]
[10:22:49.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.460]                     next
[10:22:49.460]                   args[[name]] <- ""
[10:22:49.460]                 }
[10:22:49.460]                 NAMES <- toupper(removed)
[10:22:49.460]                 for (kk in seq_along(NAMES)) {
[10:22:49.460]                   name <- removed[[kk]]
[10:22:49.460]                   NAME <- NAMES[[kk]]
[10:22:49.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.460]                     next
[10:22:49.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.460]                 }
[10:22:49.460]                 if (length(args) > 0) 
[10:22:49.460]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.460]             }
[10:22:49.460]             else {
[10:22:49.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.460]             }
[10:22:49.460]             {
[10:22:49.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.460]                   0L) {
[10:22:49.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.460]                   base::options(opts)
[10:22:49.460]                 }
[10:22:49.460]                 {
[10:22:49.460]                   {
[10:22:49.460]                     NULL
[10:22:49.460]                     RNGkind("Mersenne-Twister")
[10:22:49.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.460]                       inherits = FALSE)
[10:22:49.460]                   }
[10:22:49.460]                   options(future.plan = NULL)
[10:22:49.460]                   if (is.na(NA_character_)) 
[10:22:49.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.460]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:49.460]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:49.460]                     envir = parent.frame()) 
[10:22:49.460]                   {
[10:22:49.460]                     if (is.function(workers)) 
[10:22:49.460]                       workers <- workers()
[10:22:49.460]                     workers <- structure(as.integer(workers), 
[10:22:49.460]                       class = class(workers))
[10:22:49.460]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:49.460]                       workers >= 1)
[10:22:49.460]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:49.460]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:49.460]                     }
[10:22:49.460]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:49.460]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:49.460]                       envir = envir)
[10:22:49.460]                     if (!future$lazy) 
[10:22:49.460]                       future <- run(future)
[10:22:49.460]                     invisible(future)
[10:22:49.460]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.460]                 }
[10:22:49.460]             }
[10:22:49.460]         }
[10:22:49.460]     })
[10:22:49.460]     if (TRUE) {
[10:22:49.460]         base::sink(type = "output", split = FALSE)
[10:22:49.460]         if (TRUE) {
[10:22:49.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.460]         }
[10:22:49.460]         else {
[10:22:49.460]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.460]         }
[10:22:49.460]         base::close(...future.stdout)
[10:22:49.460]         ...future.stdout <- NULL
[10:22:49.460]     }
[10:22:49.460]     ...future.result$conditions <- ...future.conditions
[10:22:49.460]     ...future.result$finished <- base::Sys.time()
[10:22:49.460]     ...future.result
[10:22:49.460] }
[10:22:49.462] assign_globals() ...
[10:22:49.462] List of 5
[10:22:49.462]  $ ...future.FUN            :function (object, ...)  
[10:22:49.462]  $ future.call.arguments    : list()
[10:22:49.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.462]  $ ...future.elements_ii    :List of 3
[10:22:49.462]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.462]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.462]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.462]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.462]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.462]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.462]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.462]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.462]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.462]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.462]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.462]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.462]  $ ...future.seeds_ii       : NULL
[10:22:49.462]  $ ...future.globals.maxSize: NULL
[10:22:49.462]  - attr(*, "where")=List of 5
[10:22:49.462]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.462]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.462]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.462]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.462]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.462]  - attr(*, "resolved")= logi FALSE
[10:22:49.462]  - attr(*, "total_size")= num 1240
[10:22:49.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.462]  - attr(*, "already-done")= logi TRUE
[10:22:49.473] - copied ‘...future.FUN’ to environment
[10:22:49.473] - copied ‘future.call.arguments’ to environment
[10:22:49.473] - copied ‘...future.elements_ii’ to environment
[10:22:49.473] - copied ‘...future.seeds_ii’ to environment
[10:22:49.474] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.474] assign_globals() ... done
[10:22:49.474] plan(): Setting new future strategy stack:
[10:22:49.474] List of future strategies:
[10:22:49.474] 1. sequential:
[10:22:49.474]    - args: function (..., envir = parent.frame())
[10:22:49.474]    - tweaked: FALSE
[10:22:49.474]    - call: NULL
[10:22:49.475] plan(): nbrOfWorkers() = 1
[10:22:49.477] plan(): Setting new future strategy stack:
[10:22:49.477] List of future strategies:
[10:22:49.477] 1. multisession:
[10:22:49.477]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:49.477]    - tweaked: FALSE
[10:22:49.477]    - call: plan(strategy)
[10:22:49.481] plan(): nbrOfWorkers() = 1
[10:22:49.481] SequentialFuture started (and completed)
[10:22:49.481] - Launch lazy future ... done
[10:22:49.481] run() for ‘SequentialFuture’ ... done
[10:22:49.481] Created future:
[10:22:49.481] SequentialFuture:
[10:22:49.481] Label: ‘future_by-1’
[10:22:49.481] Expression:
[10:22:49.481] {
[10:22:49.481]     do.call(function(...) {
[10:22:49.481]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.481]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.481]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.481]             on.exit(options(oopts), add = TRUE)
[10:22:49.481]         }
[10:22:49.481]         {
[10:22:49.481]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.481]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.481]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.481]             })
[10:22:49.481]         }
[10:22:49.481]     }, args = future.call.arguments)
[10:22:49.481] }
[10:22:49.481] Lazy evaluation: FALSE
[10:22:49.481] Asynchronous evaluation: FALSE
[10:22:49.481] Local evaluation: TRUE
[10:22:49.481] Environment: 0x55f639a32cd0
[10:22:49.481] Capture standard output: TRUE
[10:22:49.481] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.481] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.481] Packages: <none>
[10:22:49.481] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.481] Resolved: TRUE
[10:22:49.481] Value: 5.37 KiB of class ‘list’
[10:22:49.481] Early signaling: FALSE
[10:22:49.481] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.481] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.483] Chunk #1 of 1 ... DONE
[10:22:49.483] Launching 1 futures (chunks) ... DONE
[10:22:49.483] Resolving 1 futures (chunks) ...
[10:22:49.483] resolve() on list ...
[10:22:49.483]  recursive: 0
[10:22:49.483]  length: 1
[10:22:49.483] 
[10:22:49.483] resolved() for ‘SequentialFuture’ ...
[10:22:49.484] - state: ‘finished’
[10:22:49.484] - run: TRUE
[10:22:49.484] - result: ‘FutureResult’
[10:22:49.484] resolved() for ‘SequentialFuture’ ... done
[10:22:49.484] Future #1
[10:22:49.484] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.484] - nx: 1
[10:22:49.484] - relay: TRUE
[10:22:49.484] - stdout: TRUE
[10:22:49.484] - signal: TRUE
[10:22:49.484] - resignal: FALSE
[10:22:49.485] - force: TRUE
[10:22:49.485] - relayed: [n=1] FALSE
[10:22:49.485] - queued futures: [n=1] FALSE
[10:22:49.485]  - until=1
[10:22:49.485]  - relaying element #1
[10:22:49.485] - relayed: [n=1] TRUE
[10:22:49.485] - queued futures: [n=1] TRUE
[10:22:49.485] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.485]  length: 0 (resolved future 1)
[10:22:49.486] Relaying remaining futures
[10:22:49.486] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.486] - nx: 1
[10:22:49.486] - relay: TRUE
[10:22:49.486] - stdout: TRUE
[10:22:49.486] - signal: TRUE
[10:22:49.486] - resignal: FALSE
[10:22:49.486] - force: TRUE
[10:22:49.486] - relayed: [n=1] TRUE
[10:22:49.486] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.486] - relayed: [n=1] TRUE
[10:22:49.487] - queued futures: [n=1] TRUE
[10:22:49.487] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.487] resolve() on list ... DONE
[10:22:49.487]  - Number of value chunks collected: 1
[10:22:49.487] Resolving 1 futures (chunks) ... DONE
[10:22:49.487] Reducing values from 1 chunks ...
[10:22:49.487]  - Number of values collected after concatenation: 3
[10:22:49.487]  - Number of values expected: 3
[10:22:49.487] Reducing values from 1 chunks ... DONE
[10:22:49.487] future_lapply() ... DONE
[10:22:49.487] future_by_internal() ... DONE
[10:22:49.488] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[10:22:49.489] plan(): Setting new future strategy stack:
[10:22:49.489] List of future strategies:
[10:22:49.489] 1. sequential:
[10:22:49.489]    - args: function (..., envir = parent.frame())
[10:22:49.489]    - tweaked: FALSE
[10:22:49.489]    - call: plan(strategy)
[10:22:49.490] plan(): nbrOfWorkers() = 1
[10:22:49.490] future_by_internal() ...
[10:22:49.490] future_lapply() ...
[10:22:49.491] Number of chunks: 1
[10:22:49.491] getGlobalsAndPackagesXApply() ...
[10:22:49.491]  - future.globals: TRUE
[10:22:49.491] getGlobalsAndPackages() ...
[10:22:49.491] Searching for globals...
[10:22:49.492] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.492] Searching for globals ... DONE
[10:22:49.492] Resolving globals: FALSE
[10:22:49.493] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.493] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.493] - globals: [1] ‘FUN’
[10:22:49.493] 
[10:22:49.493] getGlobalsAndPackages() ... DONE
[10:22:49.493]  - globals found/used: [n=1] ‘FUN’
[10:22:49.493]  - needed namespaces: [n=0] 
[10:22:49.494] Finding globals ... DONE
[10:22:49.494]  - use_args: TRUE
[10:22:49.494]  - Getting '...' globals ...
[10:22:49.494] resolve() on list ...
[10:22:49.494]  recursive: 0
[10:22:49.494]  length: 1
[10:22:49.494]  elements: ‘...’
[10:22:49.494]  length: 0 (resolved future 1)
[10:22:49.494] resolve() on list ... DONE
[10:22:49.495]    - '...' content: [n=0] 
[10:22:49.495] List of 1
[10:22:49.495]  $ ...: list()
[10:22:49.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.495]  - attr(*, "where")=List of 1
[10:22:49.495]   ..$ ...:<environment: 0x55f639d187e0> 
[10:22:49.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.495]  - attr(*, "resolved")= logi TRUE
[10:22:49.495]  - attr(*, "total_size")= num NA
[10:22:49.499]  - Getting '...' globals ... DONE
[10:22:49.499] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.499] List of 2
[10:22:49.499]  $ ...future.FUN:function (object, ...)  
[10:22:49.499]  $ ...          : list()
[10:22:49.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.499]  - attr(*, "where")=List of 2
[10:22:49.499]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.499]   ..$ ...          :<environment: 0x55f639d187e0> 
[10:22:49.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.499]  - attr(*, "resolved")= logi FALSE
[10:22:49.499]  - attr(*, "total_size")= num 1240
[10:22:49.502] Packages to be attached in all futures: [n=0] 
[10:22:49.502] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.503] Number of futures (= number of chunks): 1
[10:22:49.503] Launching 1 futures (chunks) ...
[10:22:49.503] Chunk #1 of 1 ...
[10:22:49.503]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.503] getGlobalsAndPackages() ...
[10:22:49.503] Searching for globals...
[10:22:49.504] 
[10:22:49.504] Searching for globals ... DONE
[10:22:49.504] - globals: [0] <none>
[10:22:49.504] getGlobalsAndPackages() ... DONE
[10:22:49.504]    + additional globals found: [n=0] 
[10:22:49.504]    + additional namespaces needed: [n=0] 
[10:22:49.504]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.504]  - seeds: <none>
[10:22:49.504]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.504] getGlobalsAndPackages() ...
[10:22:49.504] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.505] Resolving globals: FALSE
[10:22:49.505] Tweak future expression to call with '...' arguments ...
[10:22:49.505] {
[10:22:49.505]     do.call(function(...) {
[10:22:49.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.505]             on.exit(options(oopts), add = TRUE)
[10:22:49.505]         }
[10:22:49.505]         {
[10:22:49.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.505]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.505]             })
[10:22:49.505]         }
[10:22:49.505]     }, args = future.call.arguments)
[10:22:49.505] }
[10:22:49.505] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.505] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.506] 
[10:22:49.506] getGlobalsAndPackages() ... DONE
[10:22:49.506] run() for ‘Future’ ...
[10:22:49.506] - state: ‘created’
[10:22:49.506] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:49.506] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.507]   - Field: ‘label’
[10:22:49.507]   - Field: ‘local’
[10:22:49.507]   - Field: ‘owner’
[10:22:49.507]   - Field: ‘envir’
[10:22:49.507]   - Field: ‘packages’
[10:22:49.507]   - Field: ‘gc’
[10:22:49.507]   - Field: ‘conditions’
[10:22:49.507]   - Field: ‘expr’
[10:22:49.507]   - Field: ‘uuid’
[10:22:49.508]   - Field: ‘seed’
[10:22:49.508]   - Field: ‘version’
[10:22:49.508]   - Field: ‘result’
[10:22:49.508]   - Field: ‘asynchronous’
[10:22:49.508]   - Field: ‘calls’
[10:22:49.508]   - Field: ‘globals’
[10:22:49.508]   - Field: ‘stdout’
[10:22:49.508]   - Field: ‘earlySignal’
[10:22:49.508]   - Field: ‘lazy’
[10:22:49.508]   - Field: ‘state’
[10:22:49.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.509] - Launch lazy future ...
[10:22:49.509] Packages needed by the future expression (n = 0): <none>
[10:22:49.509] Packages needed by future strategies (n = 0): <none>
[10:22:49.509] {
[10:22:49.509]     {
[10:22:49.509]         {
[10:22:49.509]             ...future.startTime <- base::Sys.time()
[10:22:49.509]             {
[10:22:49.509]                 {
[10:22:49.509]                   {
[10:22:49.509]                     base::local({
[10:22:49.509]                       has_future <- base::requireNamespace("future", 
[10:22:49.509]                         quietly = TRUE)
[10:22:49.509]                       if (has_future) {
[10:22:49.509]                         ns <- base::getNamespace("future")
[10:22:49.509]                         version <- ns[[".package"]][["version"]]
[10:22:49.509]                         if (is.null(version)) 
[10:22:49.509]                           version <- utils::packageVersion("future")
[10:22:49.509]                       }
[10:22:49.509]                       else {
[10:22:49.509]                         version <- NULL
[10:22:49.509]                       }
[10:22:49.509]                       if (!has_future || version < "1.8.0") {
[10:22:49.509]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.509]                           "", base::R.version$version.string), 
[10:22:49.509]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.509]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.509]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.509]                             "release", "version")], collapse = " "), 
[10:22:49.509]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.509]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.509]                           info)
[10:22:49.509]                         info <- base::paste(info, collapse = "; ")
[10:22:49.509]                         if (!has_future) {
[10:22:49.509]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.509]                             info)
[10:22:49.509]                         }
[10:22:49.509]                         else {
[10:22:49.509]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.509]                             info, version)
[10:22:49.509]                         }
[10:22:49.509]                         base::stop(msg)
[10:22:49.509]                       }
[10:22:49.509]                     })
[10:22:49.509]                   }
[10:22:49.509]                   options(future.plan = NULL)
[10:22:49.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.509]                 }
[10:22:49.509]                 ...future.workdir <- getwd()
[10:22:49.509]             }
[10:22:49.509]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.509]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.509]         }
[10:22:49.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.509]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.509]             base::names(...future.oldOptions))
[10:22:49.509]     }
[10:22:49.509]     if (FALSE) {
[10:22:49.509]     }
[10:22:49.509]     else {
[10:22:49.509]         if (TRUE) {
[10:22:49.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.509]                 open = "w")
[10:22:49.509]         }
[10:22:49.509]         else {
[10:22:49.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.509]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.509]         }
[10:22:49.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.509]             base::sink(type = "output", split = FALSE)
[10:22:49.509]             base::close(...future.stdout)
[10:22:49.509]         }, add = TRUE)
[10:22:49.509]     }
[10:22:49.509]     ...future.frame <- base::sys.nframe()
[10:22:49.509]     ...future.conditions <- base::list()
[10:22:49.509]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.509]     if (FALSE) {
[10:22:49.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.509]     }
[10:22:49.509]     ...future.result <- base::tryCatch({
[10:22:49.509]         base::withCallingHandlers({
[10:22:49.509]             ...future.value <- base::withVisible(base::local({
[10:22:49.509]                 do.call(function(...) {
[10:22:49.509]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.509]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.509]                     ...future.globals.maxSize)) {
[10:22:49.509]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.509]                     on.exit(options(oopts), add = TRUE)
[10:22:49.509]                   }
[10:22:49.509]                   {
[10:22:49.509]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.509]                       FUN = function(jj) {
[10:22:49.509]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.509]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.509]                       })
[10:22:49.509]                   }
[10:22:49.509]                 }, args = future.call.arguments)
[10:22:49.509]             }))
[10:22:49.509]             future::FutureResult(value = ...future.value$value, 
[10:22:49.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.509]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.509]                     ...future.globalenv.names))
[10:22:49.509]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.509]         }, condition = base::local({
[10:22:49.509]             c <- base::c
[10:22:49.509]             inherits <- base::inherits
[10:22:49.509]             invokeRestart <- base::invokeRestart
[10:22:49.509]             length <- base::length
[10:22:49.509]             list <- base::list
[10:22:49.509]             seq.int <- base::seq.int
[10:22:49.509]             signalCondition <- base::signalCondition
[10:22:49.509]             sys.calls <- base::sys.calls
[10:22:49.509]             `[[` <- base::`[[`
[10:22:49.509]             `+` <- base::`+`
[10:22:49.509]             `<<-` <- base::`<<-`
[10:22:49.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.509]                   3L)]
[10:22:49.509]             }
[10:22:49.509]             function(cond) {
[10:22:49.509]                 is_error <- inherits(cond, "error")
[10:22:49.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.509]                   NULL)
[10:22:49.509]                 if (is_error) {
[10:22:49.509]                   sessionInformation <- function() {
[10:22:49.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.509]                       search = base::search(), system = base::Sys.info())
[10:22:49.509]                   }
[10:22:49.509]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.509]                     cond$call), session = sessionInformation(), 
[10:22:49.509]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.509]                   signalCondition(cond)
[10:22:49.509]                 }
[10:22:49.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.509]                 "immediateCondition"))) {
[10:22:49.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.509]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.509]                   if (TRUE && !signal) {
[10:22:49.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.509]                     {
[10:22:49.509]                       inherits <- base::inherits
[10:22:49.509]                       invokeRestart <- base::invokeRestart
[10:22:49.509]                       is.null <- base::is.null
[10:22:49.509]                       muffled <- FALSE
[10:22:49.509]                       if (inherits(cond, "message")) {
[10:22:49.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.509]                         if (muffled) 
[10:22:49.509]                           invokeRestart("muffleMessage")
[10:22:49.509]                       }
[10:22:49.509]                       else if (inherits(cond, "warning")) {
[10:22:49.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.509]                         if (muffled) 
[10:22:49.509]                           invokeRestart("muffleWarning")
[10:22:49.509]                       }
[10:22:49.509]                       else if (inherits(cond, "condition")) {
[10:22:49.509]                         if (!is.null(pattern)) {
[10:22:49.509]                           computeRestarts <- base::computeRestarts
[10:22:49.509]                           grepl <- base::grepl
[10:22:49.509]                           restarts <- computeRestarts(cond)
[10:22:49.509]                           for (restart in restarts) {
[10:22:49.509]                             name <- restart$name
[10:22:49.509]                             if (is.null(name)) 
[10:22:49.509]                               next
[10:22:49.509]                             if (!grepl(pattern, name)) 
[10:22:49.509]                               next
[10:22:49.509]                             invokeRestart(restart)
[10:22:49.509]                             muffled <- TRUE
[10:22:49.509]                             break
[10:22:49.509]                           }
[10:22:49.509]                         }
[10:22:49.509]                       }
[10:22:49.509]                       invisible(muffled)
[10:22:49.509]                     }
[10:22:49.509]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.509]                   }
[10:22:49.509]                 }
[10:22:49.509]                 else {
[10:22:49.509]                   if (TRUE) {
[10:22:49.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.509]                     {
[10:22:49.509]                       inherits <- base::inherits
[10:22:49.509]                       invokeRestart <- base::invokeRestart
[10:22:49.509]                       is.null <- base::is.null
[10:22:49.509]                       muffled <- FALSE
[10:22:49.509]                       if (inherits(cond, "message")) {
[10:22:49.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.509]                         if (muffled) 
[10:22:49.509]                           invokeRestart("muffleMessage")
[10:22:49.509]                       }
[10:22:49.509]                       else if (inherits(cond, "warning")) {
[10:22:49.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.509]                         if (muffled) 
[10:22:49.509]                           invokeRestart("muffleWarning")
[10:22:49.509]                       }
[10:22:49.509]                       else if (inherits(cond, "condition")) {
[10:22:49.509]                         if (!is.null(pattern)) {
[10:22:49.509]                           computeRestarts <- base::computeRestarts
[10:22:49.509]                           grepl <- base::grepl
[10:22:49.509]                           restarts <- computeRestarts(cond)
[10:22:49.509]                           for (restart in restarts) {
[10:22:49.509]                             name <- restart$name
[10:22:49.509]                             if (is.null(name)) 
[10:22:49.509]                               next
[10:22:49.509]                             if (!grepl(pattern, name)) 
[10:22:49.509]                               next
[10:22:49.509]                             invokeRestart(restart)
[10:22:49.509]                             muffled <- TRUE
[10:22:49.509]                             break
[10:22:49.509]                           }
[10:22:49.509]                         }
[10:22:49.509]                       }
[10:22:49.509]                       invisible(muffled)
[10:22:49.509]                     }
[10:22:49.509]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.509]                   }
[10:22:49.509]                 }
[10:22:49.509]             }
[10:22:49.509]         }))
[10:22:49.509]     }, error = function(ex) {
[10:22:49.509]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.509]                 ...future.rng), started = ...future.startTime, 
[10:22:49.509]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.509]             version = "1.8"), class = "FutureResult")
[10:22:49.509]     }, finally = {
[10:22:49.509]         if (!identical(...future.workdir, getwd())) 
[10:22:49.509]             setwd(...future.workdir)
[10:22:49.509]         {
[10:22:49.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.509]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.509]             }
[10:22:49.509]             base::options(...future.oldOptions)
[10:22:49.509]             if (.Platform$OS.type == "windows") {
[10:22:49.509]                 old_names <- names(...future.oldEnvVars)
[10:22:49.509]                 envs <- base::Sys.getenv()
[10:22:49.509]                 names <- names(envs)
[10:22:49.509]                 common <- intersect(names, old_names)
[10:22:49.509]                 added <- setdiff(names, old_names)
[10:22:49.509]                 removed <- setdiff(old_names, names)
[10:22:49.509]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.509]                   envs[common]]
[10:22:49.509]                 NAMES <- toupper(changed)
[10:22:49.509]                 args <- list()
[10:22:49.509]                 for (kk in seq_along(NAMES)) {
[10:22:49.509]                   name <- changed[[kk]]
[10:22:49.509]                   NAME <- NAMES[[kk]]
[10:22:49.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.509]                     next
[10:22:49.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.509]                 }
[10:22:49.509]                 NAMES <- toupper(added)
[10:22:49.509]                 for (kk in seq_along(NAMES)) {
[10:22:49.509]                   name <- added[[kk]]
[10:22:49.509]                   NAME <- NAMES[[kk]]
[10:22:49.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.509]                     next
[10:22:49.509]                   args[[name]] <- ""
[10:22:49.509]                 }
[10:22:49.509]                 NAMES <- toupper(removed)
[10:22:49.509]                 for (kk in seq_along(NAMES)) {
[10:22:49.509]                   name <- removed[[kk]]
[10:22:49.509]                   NAME <- NAMES[[kk]]
[10:22:49.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.509]                     next
[10:22:49.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.509]                 }
[10:22:49.509]                 if (length(args) > 0) 
[10:22:49.509]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.509]             }
[10:22:49.509]             else {
[10:22:49.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.509]             }
[10:22:49.509]             {
[10:22:49.509]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.509]                   0L) {
[10:22:49.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.509]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.509]                   base::options(opts)
[10:22:49.509]                 }
[10:22:49.509]                 {
[10:22:49.509]                   {
[10:22:49.509]                     NULL
[10:22:49.509]                     RNGkind("Mersenne-Twister")
[10:22:49.509]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.509]                       inherits = FALSE)
[10:22:49.509]                   }
[10:22:49.509]                   options(future.plan = NULL)
[10:22:49.509]                   if (is.na(NA_character_)) 
[10:22:49.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.509]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:49.509]                   {
[10:22:49.509]                     future <- SequentialFuture(..., envir = envir)
[10:22:49.509]                     if (!future$lazy) 
[10:22:49.509]                       future <- run(future)
[10:22:49.509]                     invisible(future)
[10:22:49.509]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.509]                 }
[10:22:49.509]             }
[10:22:49.509]         }
[10:22:49.509]     })
[10:22:49.509]     if (TRUE) {
[10:22:49.509]         base::sink(type = "output", split = FALSE)
[10:22:49.509]         if (TRUE) {
[10:22:49.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.509]         }
[10:22:49.509]         else {
[10:22:49.509]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.509]         }
[10:22:49.509]         base::close(...future.stdout)
[10:22:49.509]         ...future.stdout <- NULL
[10:22:49.509]     }
[10:22:49.509]     ...future.result$conditions <- ...future.conditions
[10:22:49.509]     ...future.result$finished <- base::Sys.time()
[10:22:49.509]     ...future.result
[10:22:49.509] }
[10:22:49.511] assign_globals() ...
[10:22:49.511] List of 5
[10:22:49.511]  $ ...future.FUN            :function (object, ...)  
[10:22:49.511]  $ future.call.arguments    : list()
[10:22:49.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.511]  $ ...future.elements_ii    :List of 3
[10:22:49.511]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.511]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.511]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.511]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.511]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.511]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.511]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.511]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.511]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.511]  $ ...future.seeds_ii       : NULL
[10:22:49.511]  $ ...future.globals.maxSize: NULL
[10:22:49.511]  - attr(*, "where")=List of 5
[10:22:49.511]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.511]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.511]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.511]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.511]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.511]  - attr(*, "resolved")= logi FALSE
[10:22:49.511]  - attr(*, "total_size")= num 1240
[10:22:49.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.511]  - attr(*, "already-done")= logi TRUE
[10:22:49.520] - copied ‘...future.FUN’ to environment
[10:22:49.521] - copied ‘future.call.arguments’ to environment
[10:22:49.521] - copied ‘...future.elements_ii’ to environment
[10:22:49.521] - copied ‘...future.seeds_ii’ to environment
[10:22:49.521] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.521] assign_globals() ... done
[10:22:49.521] plan(): Setting new future strategy stack:
[10:22:49.521] List of future strategies:
[10:22:49.521] 1. sequential:
[10:22:49.521]    - args: function (..., envir = parent.frame())
[10:22:49.521]    - tweaked: FALSE
[10:22:49.521]    - call: NULL
[10:22:49.522] plan(): nbrOfWorkers() = 1
[10:22:49.524] plan(): Setting new future strategy stack:
[10:22:49.524] List of future strategies:
[10:22:49.524] 1. sequential:
[10:22:49.524]    - args: function (..., envir = parent.frame())
[10:22:49.524]    - tweaked: FALSE
[10:22:49.524]    - call: plan(strategy)
[10:22:49.524] plan(): nbrOfWorkers() = 1
[10:22:49.525] SequentialFuture started (and completed)
[10:22:49.525] - Launch lazy future ... done
[10:22:49.525] run() for ‘SequentialFuture’ ... done
[10:22:49.525] Created future:
[10:22:49.525] SequentialFuture:
[10:22:49.525] Label: ‘future_by-1’
[10:22:49.525] Expression:
[10:22:49.525] {
[10:22:49.525]     do.call(function(...) {
[10:22:49.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.525]             on.exit(options(oopts), add = TRUE)
[10:22:49.525]         }
[10:22:49.525]         {
[10:22:49.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.525]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.525]             })
[10:22:49.525]         }
[10:22:49.525]     }, args = future.call.arguments)
[10:22:49.525] }
[10:22:49.525] Lazy evaluation: FALSE
[10:22:49.525] Asynchronous evaluation: FALSE
[10:22:49.525] Local evaluation: TRUE
[10:22:49.525] Environment: R_GlobalEnv
[10:22:49.525] Capture standard output: TRUE
[10:22:49.525] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.525] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.525] Packages: <none>
[10:22:49.525] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.525] Resolved: TRUE
[10:22:49.525] Value: 4.62 KiB of class ‘list’
[10:22:49.525] Early signaling: FALSE
[10:22:49.525] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.525] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.526] Chunk #1 of 1 ... DONE
[10:22:49.526] Launching 1 futures (chunks) ... DONE
[10:22:49.526] Resolving 1 futures (chunks) ...
[10:22:49.527] resolve() on list ...
[10:22:49.527]  recursive: 0
[10:22:49.527]  length: 1
[10:22:49.527] 
[10:22:49.527] resolved() for ‘SequentialFuture’ ...
[10:22:49.527] - state: ‘finished’
[10:22:49.527] - run: TRUE
[10:22:49.527] - result: ‘FutureResult’
[10:22:49.527] resolved() for ‘SequentialFuture’ ... done
[10:22:49.527] Future #1
[10:22:49.528] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.528] - nx: 1
[10:22:49.528] - relay: TRUE
[10:22:49.528] - stdout: TRUE
[10:22:49.528] - signal: TRUE
[10:22:49.528] - resignal: FALSE
[10:22:49.528] - force: TRUE
[10:22:49.528] - relayed: [n=1] FALSE
[10:22:49.528] - queued futures: [n=1] FALSE
[10:22:49.528]  - until=1
[10:22:49.528]  - relaying element #1
[10:22:49.529] - relayed: [n=1] TRUE
[10:22:49.529] - queued futures: [n=1] TRUE
[10:22:49.529] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.529]  length: 0 (resolved future 1)
[10:22:49.529] Relaying remaining futures
[10:22:49.529] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.529] - nx: 1
[10:22:49.529] - relay: TRUE
[10:22:49.529] - stdout: TRUE
[10:22:49.529] - signal: TRUE
[10:22:49.529] - resignal: FALSE
[10:22:49.530] - force: TRUE
[10:22:49.530] - relayed: [n=1] TRUE
[10:22:49.530] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.530] - relayed: [n=1] TRUE
[10:22:49.530] - queued futures: [n=1] TRUE
[10:22:49.530] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.530] resolve() on list ... DONE
[10:22:49.530]  - Number of value chunks collected: 1
[10:22:49.530] Resolving 1 futures (chunks) ... DONE
[10:22:49.530] Reducing values from 1 chunks ...
[10:22:49.531]  - Number of values collected after concatenation: 3
[10:22:49.531]  - Number of values expected: 3
[10:22:49.531] Reducing values from 1 chunks ... DONE
[10:22:49.531] future_lapply() ... DONE
[10:22:49.531] future_by_internal() ... DONE
[10:22:49.531] future_by_internal() ...
[10:22:49.531] future_lapply() ...
[10:22:49.532] Number of chunks: 1
[10:22:49.532] getGlobalsAndPackagesXApply() ...
[10:22:49.532]  - future.globals: TRUE
[10:22:49.532] getGlobalsAndPackages() ...
[10:22:49.532] Searching for globals...
[10:22:49.533] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.533] Searching for globals ... DONE
[10:22:49.534] Resolving globals: FALSE
[10:22:49.534] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.534] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.534] - globals: [1] ‘FUN’
[10:22:49.534] 
[10:22:49.534] getGlobalsAndPackages() ... DONE
[10:22:49.535]  - globals found/used: [n=1] ‘FUN’
[10:22:49.535]  - needed namespaces: [n=0] 
[10:22:49.535] Finding globals ... DONE
[10:22:49.535]  - use_args: TRUE
[10:22:49.535]  - Getting '...' globals ...
[10:22:49.535] resolve() on list ...
[10:22:49.535]  recursive: 0
[10:22:49.535]  length: 1
[10:22:49.535]  elements: ‘...’
[10:22:49.536]  length: 0 (resolved future 1)
[10:22:49.536] resolve() on list ... DONE
[10:22:49.536]    - '...' content: [n=1] ‘digits’
[10:22:49.536] List of 1
[10:22:49.536]  $ ...:List of 1
[10:22:49.536]   ..$ digits: int 2
[10:22:49.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.536]  - attr(*, "where")=List of 1
[10:22:49.536]   ..$ ...:<environment: 0x55f639580880> 
[10:22:49.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.536]  - attr(*, "resolved")= logi TRUE
[10:22:49.536]  - attr(*, "total_size")= num NA
[10:22:49.539]  - Getting '...' globals ... DONE
[10:22:49.539] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.539] List of 2
[10:22:49.539]  $ ...future.FUN:function (object, ...)  
[10:22:49.539]  $ ...          :List of 1
[10:22:49.539]   ..$ digits: int 2
[10:22:49.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.539]  - attr(*, "where")=List of 2
[10:22:49.539]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.539]   ..$ ...          :<environment: 0x55f639580880> 
[10:22:49.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.539]  - attr(*, "resolved")= logi FALSE
[10:22:49.539]  - attr(*, "total_size")= num 1296
[10:22:49.544] Packages to be attached in all futures: [n=0] 
[10:22:49.544] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.544] Number of futures (= number of chunks): 1
[10:22:49.544] Launching 1 futures (chunks) ...
[10:22:49.544] Chunk #1 of 1 ...
[10:22:49.544]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.544] getGlobalsAndPackages() ...
[10:22:49.544] Searching for globals...
[10:22:49.545] 
[10:22:49.545] Searching for globals ... DONE
[10:22:49.545] - globals: [0] <none>
[10:22:49.545] getGlobalsAndPackages() ... DONE
[10:22:49.545]    + additional globals found: [n=0] 
[10:22:49.545]    + additional namespaces needed: [n=0] 
[10:22:49.545]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.545]  - seeds: <none>
[10:22:49.545]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.546] getGlobalsAndPackages() ...
[10:22:49.546] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.546] Resolving globals: FALSE
[10:22:49.546] Tweak future expression to call with '...' arguments ...
[10:22:49.546] {
[10:22:49.546]     do.call(function(...) {
[10:22:49.546]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.546]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.546]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.546]             on.exit(options(oopts), add = TRUE)
[10:22:49.546]         }
[10:22:49.546]         {
[10:22:49.546]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.546]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.546]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.546]             })
[10:22:49.546]         }
[10:22:49.546]     }, args = future.call.arguments)
[10:22:49.546] }
[10:22:49.546] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.547] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.547] 
[10:22:49.547] getGlobalsAndPackages() ... DONE
[10:22:49.547] run() for ‘Future’ ...
[10:22:49.547] - state: ‘created’
[10:22:49.547] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:49.548] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.548]   - Field: ‘label’
[10:22:49.548]   - Field: ‘local’
[10:22:49.548]   - Field: ‘owner’
[10:22:49.548]   - Field: ‘envir’
[10:22:49.548]   - Field: ‘packages’
[10:22:49.548]   - Field: ‘gc’
[10:22:49.548]   - Field: ‘conditions’
[10:22:49.548]   - Field: ‘expr’
[10:22:49.549]   - Field: ‘uuid’
[10:22:49.549]   - Field: ‘seed’
[10:22:49.549]   - Field: ‘version’
[10:22:49.549]   - Field: ‘result’
[10:22:49.549]   - Field: ‘asynchronous’
[10:22:49.549]   - Field: ‘calls’
[10:22:49.549]   - Field: ‘globals’
[10:22:49.549]   - Field: ‘stdout’
[10:22:49.549]   - Field: ‘earlySignal’
[10:22:49.549]   - Field: ‘lazy’
[10:22:49.549]   - Field: ‘state’
[10:22:49.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.550] - Launch lazy future ...
[10:22:49.550] Packages needed by the future expression (n = 0): <none>
[10:22:49.550] Packages needed by future strategies (n = 0): <none>
[10:22:49.550] {
[10:22:49.550]     {
[10:22:49.550]         {
[10:22:49.550]             ...future.startTime <- base::Sys.time()
[10:22:49.550]             {
[10:22:49.550]                 {
[10:22:49.550]                   {
[10:22:49.550]                     base::local({
[10:22:49.550]                       has_future <- base::requireNamespace("future", 
[10:22:49.550]                         quietly = TRUE)
[10:22:49.550]                       if (has_future) {
[10:22:49.550]                         ns <- base::getNamespace("future")
[10:22:49.550]                         version <- ns[[".package"]][["version"]]
[10:22:49.550]                         if (is.null(version)) 
[10:22:49.550]                           version <- utils::packageVersion("future")
[10:22:49.550]                       }
[10:22:49.550]                       else {
[10:22:49.550]                         version <- NULL
[10:22:49.550]                       }
[10:22:49.550]                       if (!has_future || version < "1.8.0") {
[10:22:49.550]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.550]                           "", base::R.version$version.string), 
[10:22:49.550]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.550]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.550]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.550]                             "release", "version")], collapse = " "), 
[10:22:49.550]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.550]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.550]                           info)
[10:22:49.550]                         info <- base::paste(info, collapse = "; ")
[10:22:49.550]                         if (!has_future) {
[10:22:49.550]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.550]                             info)
[10:22:49.550]                         }
[10:22:49.550]                         else {
[10:22:49.550]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.550]                             info, version)
[10:22:49.550]                         }
[10:22:49.550]                         base::stop(msg)
[10:22:49.550]                       }
[10:22:49.550]                     })
[10:22:49.550]                   }
[10:22:49.550]                   options(future.plan = NULL)
[10:22:49.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.550]                 }
[10:22:49.550]                 ...future.workdir <- getwd()
[10:22:49.550]             }
[10:22:49.550]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.550]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.550]         }
[10:22:49.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.550]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.550]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.550]             base::names(...future.oldOptions))
[10:22:49.550]     }
[10:22:49.550]     if (FALSE) {
[10:22:49.550]     }
[10:22:49.550]     else {
[10:22:49.550]         if (TRUE) {
[10:22:49.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.550]                 open = "w")
[10:22:49.550]         }
[10:22:49.550]         else {
[10:22:49.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.550]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.550]         }
[10:22:49.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.550]             base::sink(type = "output", split = FALSE)
[10:22:49.550]             base::close(...future.stdout)
[10:22:49.550]         }, add = TRUE)
[10:22:49.550]     }
[10:22:49.550]     ...future.frame <- base::sys.nframe()
[10:22:49.550]     ...future.conditions <- base::list()
[10:22:49.550]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.550]     if (FALSE) {
[10:22:49.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.550]     }
[10:22:49.550]     ...future.result <- base::tryCatch({
[10:22:49.550]         base::withCallingHandlers({
[10:22:49.550]             ...future.value <- base::withVisible(base::local({
[10:22:49.550]                 do.call(function(...) {
[10:22:49.550]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.550]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.550]                     ...future.globals.maxSize)) {
[10:22:49.550]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.550]                     on.exit(options(oopts), add = TRUE)
[10:22:49.550]                   }
[10:22:49.550]                   {
[10:22:49.550]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.550]                       FUN = function(jj) {
[10:22:49.550]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.550]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.550]                       })
[10:22:49.550]                   }
[10:22:49.550]                 }, args = future.call.arguments)
[10:22:49.550]             }))
[10:22:49.550]             future::FutureResult(value = ...future.value$value, 
[10:22:49.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.550]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.550]                     ...future.globalenv.names))
[10:22:49.550]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.550]         }, condition = base::local({
[10:22:49.550]             c <- base::c
[10:22:49.550]             inherits <- base::inherits
[10:22:49.550]             invokeRestart <- base::invokeRestart
[10:22:49.550]             length <- base::length
[10:22:49.550]             list <- base::list
[10:22:49.550]             seq.int <- base::seq.int
[10:22:49.550]             signalCondition <- base::signalCondition
[10:22:49.550]             sys.calls <- base::sys.calls
[10:22:49.550]             `[[` <- base::`[[`
[10:22:49.550]             `+` <- base::`+`
[10:22:49.550]             `<<-` <- base::`<<-`
[10:22:49.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.550]                   3L)]
[10:22:49.550]             }
[10:22:49.550]             function(cond) {
[10:22:49.550]                 is_error <- inherits(cond, "error")
[10:22:49.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.550]                   NULL)
[10:22:49.550]                 if (is_error) {
[10:22:49.550]                   sessionInformation <- function() {
[10:22:49.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.550]                       search = base::search(), system = base::Sys.info())
[10:22:49.550]                   }
[10:22:49.550]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.550]                     cond$call), session = sessionInformation(), 
[10:22:49.550]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.550]                   signalCondition(cond)
[10:22:49.550]                 }
[10:22:49.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.550]                 "immediateCondition"))) {
[10:22:49.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.550]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.550]                   if (TRUE && !signal) {
[10:22:49.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.550]                     {
[10:22:49.550]                       inherits <- base::inherits
[10:22:49.550]                       invokeRestart <- base::invokeRestart
[10:22:49.550]                       is.null <- base::is.null
[10:22:49.550]                       muffled <- FALSE
[10:22:49.550]                       if (inherits(cond, "message")) {
[10:22:49.550]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.550]                         if (muffled) 
[10:22:49.550]                           invokeRestart("muffleMessage")
[10:22:49.550]                       }
[10:22:49.550]                       else if (inherits(cond, "warning")) {
[10:22:49.550]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.550]                         if (muffled) 
[10:22:49.550]                           invokeRestart("muffleWarning")
[10:22:49.550]                       }
[10:22:49.550]                       else if (inherits(cond, "condition")) {
[10:22:49.550]                         if (!is.null(pattern)) {
[10:22:49.550]                           computeRestarts <- base::computeRestarts
[10:22:49.550]                           grepl <- base::grepl
[10:22:49.550]                           restarts <- computeRestarts(cond)
[10:22:49.550]                           for (restart in restarts) {
[10:22:49.550]                             name <- restart$name
[10:22:49.550]                             if (is.null(name)) 
[10:22:49.550]                               next
[10:22:49.550]                             if (!grepl(pattern, name)) 
[10:22:49.550]                               next
[10:22:49.550]                             invokeRestart(restart)
[10:22:49.550]                             muffled <- TRUE
[10:22:49.550]                             break
[10:22:49.550]                           }
[10:22:49.550]                         }
[10:22:49.550]                       }
[10:22:49.550]                       invisible(muffled)
[10:22:49.550]                     }
[10:22:49.550]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.550]                   }
[10:22:49.550]                 }
[10:22:49.550]                 else {
[10:22:49.550]                   if (TRUE) {
[10:22:49.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.550]                     {
[10:22:49.550]                       inherits <- base::inherits
[10:22:49.550]                       invokeRestart <- base::invokeRestart
[10:22:49.550]                       is.null <- base::is.null
[10:22:49.550]                       muffled <- FALSE
[10:22:49.550]                       if (inherits(cond, "message")) {
[10:22:49.550]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.550]                         if (muffled) 
[10:22:49.550]                           invokeRestart("muffleMessage")
[10:22:49.550]                       }
[10:22:49.550]                       else if (inherits(cond, "warning")) {
[10:22:49.550]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.550]                         if (muffled) 
[10:22:49.550]                           invokeRestart("muffleWarning")
[10:22:49.550]                       }
[10:22:49.550]                       else if (inherits(cond, "condition")) {
[10:22:49.550]                         if (!is.null(pattern)) {
[10:22:49.550]                           computeRestarts <- base::computeRestarts
[10:22:49.550]                           grepl <- base::grepl
[10:22:49.550]                           restarts <- computeRestarts(cond)
[10:22:49.550]                           for (restart in restarts) {
[10:22:49.550]                             name <- restart$name
[10:22:49.550]                             if (is.null(name)) 
[10:22:49.550]                               next
[10:22:49.550]                             if (!grepl(pattern, name)) 
[10:22:49.550]                               next
[10:22:49.550]                             invokeRestart(restart)
[10:22:49.550]                             muffled <- TRUE
[10:22:49.550]                             break
[10:22:49.550]                           }
[10:22:49.550]                         }
[10:22:49.550]                       }
[10:22:49.550]                       invisible(muffled)
[10:22:49.550]                     }
[10:22:49.550]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.550]                   }
[10:22:49.550]                 }
[10:22:49.550]             }
[10:22:49.550]         }))
[10:22:49.550]     }, error = function(ex) {
[10:22:49.550]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.550]                 ...future.rng), started = ...future.startTime, 
[10:22:49.550]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.550]             version = "1.8"), class = "FutureResult")
[10:22:49.550]     }, finally = {
[10:22:49.550]         if (!identical(...future.workdir, getwd())) 
[10:22:49.550]             setwd(...future.workdir)
[10:22:49.550]         {
[10:22:49.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.550]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.550]             }
[10:22:49.550]             base::options(...future.oldOptions)
[10:22:49.550]             if (.Platform$OS.type == "windows") {
[10:22:49.550]                 old_names <- names(...future.oldEnvVars)
[10:22:49.550]                 envs <- base::Sys.getenv()
[10:22:49.550]                 names <- names(envs)
[10:22:49.550]                 common <- intersect(names, old_names)
[10:22:49.550]                 added <- setdiff(names, old_names)
[10:22:49.550]                 removed <- setdiff(old_names, names)
[10:22:49.550]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.550]                   envs[common]]
[10:22:49.550]                 NAMES <- toupper(changed)
[10:22:49.550]                 args <- list()
[10:22:49.550]                 for (kk in seq_along(NAMES)) {
[10:22:49.550]                   name <- changed[[kk]]
[10:22:49.550]                   NAME <- NAMES[[kk]]
[10:22:49.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.550]                     next
[10:22:49.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.550]                 }
[10:22:49.550]                 NAMES <- toupper(added)
[10:22:49.550]                 for (kk in seq_along(NAMES)) {
[10:22:49.550]                   name <- added[[kk]]
[10:22:49.550]                   NAME <- NAMES[[kk]]
[10:22:49.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.550]                     next
[10:22:49.550]                   args[[name]] <- ""
[10:22:49.550]                 }
[10:22:49.550]                 NAMES <- toupper(removed)
[10:22:49.550]                 for (kk in seq_along(NAMES)) {
[10:22:49.550]                   name <- removed[[kk]]
[10:22:49.550]                   NAME <- NAMES[[kk]]
[10:22:49.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.550]                     next
[10:22:49.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.550]                 }
[10:22:49.550]                 if (length(args) > 0) 
[10:22:49.550]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.550]             }
[10:22:49.550]             else {
[10:22:49.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.550]             }
[10:22:49.550]             {
[10:22:49.550]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.550]                   0L) {
[10:22:49.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.550]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.550]                   base::options(opts)
[10:22:49.550]                 }
[10:22:49.550]                 {
[10:22:49.550]                   {
[10:22:49.550]                     NULL
[10:22:49.550]                     RNGkind("Mersenne-Twister")
[10:22:49.550]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.550]                       inherits = FALSE)
[10:22:49.550]                   }
[10:22:49.550]                   options(future.plan = NULL)
[10:22:49.550]                   if (is.na(NA_character_)) 
[10:22:49.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.550]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:49.550]                   {
[10:22:49.550]                     future <- SequentialFuture(..., envir = envir)
[10:22:49.550]                     if (!future$lazy) 
[10:22:49.550]                       future <- run(future)
[10:22:49.550]                     invisible(future)
[10:22:49.550]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.550]                 }
[10:22:49.550]             }
[10:22:49.550]         }
[10:22:49.550]     })
[10:22:49.550]     if (TRUE) {
[10:22:49.550]         base::sink(type = "output", split = FALSE)
[10:22:49.550]         if (TRUE) {
[10:22:49.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.550]         }
[10:22:49.550]         else {
[10:22:49.550]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.550]         }
[10:22:49.550]         base::close(...future.stdout)
[10:22:49.550]         ...future.stdout <- NULL
[10:22:49.550]     }
[10:22:49.550]     ...future.result$conditions <- ...future.conditions
[10:22:49.550]     ...future.result$finished <- base::Sys.time()
[10:22:49.550]     ...future.result
[10:22:49.550] }
[10:22:49.552] assign_globals() ...
[10:22:49.552] List of 5
[10:22:49.552]  $ ...future.FUN            :function (object, ...)  
[10:22:49.552]  $ future.call.arguments    :List of 1
[10:22:49.552]   ..$ digits: int 2
[10:22:49.552]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.552]  $ ...future.elements_ii    :List of 6
[10:22:49.552]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:22:49.552]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:22:49.552]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:22:49.552]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:22:49.552]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:22:49.552]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:22:49.552]  $ ...future.seeds_ii       : NULL
[10:22:49.552]  $ ...future.globals.maxSize: NULL
[10:22:49.552]  - attr(*, "where")=List of 5
[10:22:49.552]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.552]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.552]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.552]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.552]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.552]  - attr(*, "resolved")= logi FALSE
[10:22:49.552]  - attr(*, "total_size")= num 1296
[10:22:49.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.552]  - attr(*, "already-done")= logi TRUE
[10:22:49.558] - copied ‘...future.FUN’ to environment
[10:22:49.559] - copied ‘future.call.arguments’ to environment
[10:22:49.559] - copied ‘...future.elements_ii’ to environment
[10:22:49.559] - copied ‘...future.seeds_ii’ to environment
[10:22:49.559] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.559] assign_globals() ... done
[10:22:49.559] plan(): Setting new future strategy stack:
[10:22:49.559] List of future strategies:
[10:22:49.559] 1. sequential:
[10:22:49.559]    - args: function (..., envir = parent.frame())
[10:22:49.559]    - tweaked: FALSE
[10:22:49.559]    - call: NULL
[10:22:49.560] plan(): nbrOfWorkers() = 1
[10:22:49.562] plan(): Setting new future strategy stack:
[10:22:49.562] List of future strategies:
[10:22:49.562] 1. sequential:
[10:22:49.562]    - args: function (..., envir = parent.frame())
[10:22:49.562]    - tweaked: FALSE
[10:22:49.562]    - call: plan(strategy)
[10:22:49.563] plan(): nbrOfWorkers() = 1
[10:22:49.563] SequentialFuture started (and completed)
[10:22:49.563] - Launch lazy future ... done
[10:22:49.563] run() for ‘SequentialFuture’ ... done
[10:22:49.563] Created future:
[10:22:49.563] SequentialFuture:
[10:22:49.563] Label: ‘future_by-1’
[10:22:49.563] Expression:
[10:22:49.563] {
[10:22:49.563]     do.call(function(...) {
[10:22:49.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.563]             on.exit(options(oopts), add = TRUE)
[10:22:49.563]         }
[10:22:49.563]         {
[10:22:49.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.563]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.563]             })
[10:22:49.563]         }
[10:22:49.563]     }, args = future.call.arguments)
[10:22:49.563] }
[10:22:49.563] Lazy evaluation: FALSE
[10:22:49.563] Asynchronous evaluation: FALSE
[10:22:49.563] Local evaluation: TRUE
[10:22:49.563] Environment: R_GlobalEnv
[10:22:49.563] Capture standard output: TRUE
[10:22:49.563] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.563] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.563] Packages: <none>
[10:22:49.563] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.563] Resolved: TRUE
[10:22:49.563] Value: 5.48 KiB of class ‘list’
[10:22:49.563] Early signaling: FALSE
[10:22:49.563] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.563] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.564] Chunk #1 of 1 ... DONE
[10:22:49.564] Launching 1 futures (chunks) ... DONE
[10:22:49.564] Resolving 1 futures (chunks) ...
[10:22:49.565] resolve() on list ...
[10:22:49.565]  recursive: 0
[10:22:49.565]  length: 1
[10:22:49.565] 
[10:22:49.565] resolved() for ‘SequentialFuture’ ...
[10:22:49.565] - state: ‘finished’
[10:22:49.565] - run: TRUE
[10:22:49.565] - result: ‘FutureResult’
[10:22:49.565] resolved() for ‘SequentialFuture’ ... done
[10:22:49.565] Future #1
[10:22:49.566] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.566] - nx: 1
[10:22:49.566] - relay: TRUE
[10:22:49.566] - stdout: TRUE
[10:22:49.566] - signal: TRUE
[10:22:49.566] - resignal: FALSE
[10:22:49.566] - force: TRUE
[10:22:49.566] - relayed: [n=1] FALSE
[10:22:49.566] - queued futures: [n=1] FALSE
[10:22:49.566]  - until=1
[10:22:49.566]  - relaying element #1
[10:22:49.567] - relayed: [n=1] TRUE
[10:22:49.567] - queued futures: [n=1] TRUE
[10:22:49.567] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.567]  length: 0 (resolved future 1)
[10:22:49.567] Relaying remaining futures
[10:22:49.567] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.567] - nx: 1
[10:22:49.567] - relay: TRUE
[10:22:49.567] - stdout: TRUE
[10:22:49.567] - signal: TRUE
[10:22:49.567] - resignal: FALSE
[10:22:49.568] - force: TRUE
[10:22:49.568] - relayed: [n=1] TRUE
[10:22:49.568] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.568] - relayed: [n=1] TRUE
[10:22:49.568] - queued futures: [n=1] TRUE
[10:22:49.568] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.568] resolve() on list ... DONE
[10:22:49.568]  - Number of value chunks collected: 1
[10:22:49.568] Resolving 1 futures (chunks) ... DONE
[10:22:49.568] Reducing values from 1 chunks ...
[10:22:49.568]  - Number of values collected after concatenation: 6
[10:22:49.569]  - Number of values expected: 6
[10:22:49.569] Reducing values from 1 chunks ... DONE
[10:22:49.569] future_lapply() ... DONE
[10:22:49.569] future_by_internal() ... DONE
[10:22:49.570] future_by_internal() ...
[10:22:49.570] future_lapply() ...
[10:22:49.571] Number of chunks: 1
[10:22:49.571] getGlobalsAndPackagesXApply() ...
[10:22:49.571]  - future.globals: TRUE
[10:22:49.571] getGlobalsAndPackages() ...
[10:22:49.571] Searching for globals...
[10:22:49.573] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:49.573] Searching for globals ... DONE
[10:22:49.573] Resolving globals: FALSE
[10:22:49.573] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:22:49.574] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:22:49.574] - globals: [1] ‘FUN’
[10:22:49.574] - packages: [1] ‘stats’
[10:22:49.574] getGlobalsAndPackages() ... DONE
[10:22:49.574]  - globals found/used: [n=1] ‘FUN’
[10:22:49.574]  - needed namespaces: [n=1] ‘stats’
[10:22:49.574] Finding globals ... DONE
[10:22:49.574]  - use_args: TRUE
[10:22:49.574]  - Getting '...' globals ...
[10:22:49.575] resolve() on list ...
[10:22:49.575]  recursive: 0
[10:22:49.575]  length: 1
[10:22:49.575]  elements: ‘...’
[10:22:49.575]  length: 0 (resolved future 1)
[10:22:49.575] resolve() on list ... DONE
[10:22:49.575]    - '...' content: [n=1] ‘singular.ok’
[10:22:49.575] List of 1
[10:22:49.575]  $ ...:List of 1
[10:22:49.575]   ..$ singular.ok: logi FALSE
[10:22:49.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.575]  - attr(*, "where")=List of 1
[10:22:49.575]   ..$ ...:<environment: 0x55f637a306a8> 
[10:22:49.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.575]  - attr(*, "resolved")= logi TRUE
[10:22:49.575]  - attr(*, "total_size")= num NA
[10:22:49.578]  - Getting '...' globals ... DONE
[10:22:49.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.578] List of 2
[10:22:49.578]  $ ...future.FUN:function (x, ...)  
[10:22:49.578]  $ ...          :List of 1
[10:22:49.578]   ..$ singular.ok: logi FALSE
[10:22:49.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.578]  - attr(*, "where")=List of 2
[10:22:49.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.578]   ..$ ...          :<environment: 0x55f637a306a8> 
[10:22:49.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.578]  - attr(*, "resolved")= logi FALSE
[10:22:49.578]  - attr(*, "total_size")= num 5384
[10:22:49.583] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:49.583] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.583] Number of futures (= number of chunks): 1
[10:22:49.583] Launching 1 futures (chunks) ...
[10:22:49.583] Chunk #1 of 1 ...
[10:22:49.583]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.583] getGlobalsAndPackages() ...
[10:22:49.583] Searching for globals...
[10:22:49.584] 
[10:22:49.584] Searching for globals ... DONE
[10:22:49.584] - globals: [0] <none>
[10:22:49.584] getGlobalsAndPackages() ... DONE
[10:22:49.584]    + additional globals found: [n=0] 
[10:22:49.584]    + additional namespaces needed: [n=0] 
[10:22:49.584]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.585]  - seeds: <none>
[10:22:49.585]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.585] getGlobalsAndPackages() ...
[10:22:49.585] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.585] Resolving globals: FALSE
[10:22:49.585] Tweak future expression to call with '...' arguments ...
[10:22:49.585] {
[10:22:49.585]     do.call(function(...) {
[10:22:49.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.585]             on.exit(options(oopts), add = TRUE)
[10:22:49.585]         }
[10:22:49.585]         {
[10:22:49.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.585]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.585]             })
[10:22:49.585]         }
[10:22:49.585]     }, args = future.call.arguments)
[10:22:49.585] }
[10:22:49.585] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.586] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.586] 
[10:22:49.586] getGlobalsAndPackages() ... DONE
[10:22:49.586] run() for ‘Future’ ...
[10:22:49.586] - state: ‘created’
[10:22:49.586] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:49.587] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.587]   - Field: ‘label’
[10:22:49.587]   - Field: ‘local’
[10:22:49.587]   - Field: ‘owner’
[10:22:49.587]   - Field: ‘envir’
[10:22:49.587]   - Field: ‘packages’
[10:22:49.587]   - Field: ‘gc’
[10:22:49.587]   - Field: ‘conditions’
[10:22:49.588]   - Field: ‘expr’
[10:22:49.588]   - Field: ‘uuid’
[10:22:49.588]   - Field: ‘seed’
[10:22:49.588]   - Field: ‘version’
[10:22:49.588]   - Field: ‘result’
[10:22:49.588]   - Field: ‘asynchronous’
[10:22:49.588]   - Field: ‘calls’
[10:22:49.588]   - Field: ‘globals’
[10:22:49.588]   - Field: ‘stdout’
[10:22:49.588]   - Field: ‘earlySignal’
[10:22:49.588]   - Field: ‘lazy’
[10:22:49.588]   - Field: ‘state’
[10:22:49.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.589] - Launch lazy future ...
[10:22:49.589] Packages needed by the future expression (n = 1): ‘stats’
[10:22:49.589] Packages needed by future strategies (n = 0): <none>
[10:22:49.589] {
[10:22:49.589]     {
[10:22:49.589]         {
[10:22:49.589]             ...future.startTime <- base::Sys.time()
[10:22:49.589]             {
[10:22:49.589]                 {
[10:22:49.589]                   {
[10:22:49.589]                     {
[10:22:49.589]                       base::local({
[10:22:49.589]                         has_future <- base::requireNamespace("future", 
[10:22:49.589]                           quietly = TRUE)
[10:22:49.589]                         if (has_future) {
[10:22:49.589]                           ns <- base::getNamespace("future")
[10:22:49.589]                           version <- ns[[".package"]][["version"]]
[10:22:49.589]                           if (is.null(version)) 
[10:22:49.589]                             version <- utils::packageVersion("future")
[10:22:49.589]                         }
[10:22:49.589]                         else {
[10:22:49.589]                           version <- NULL
[10:22:49.589]                         }
[10:22:49.589]                         if (!has_future || version < "1.8.0") {
[10:22:49.589]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.589]                             "", base::R.version$version.string), 
[10:22:49.589]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.589]                               "release", "version")], collapse = " "), 
[10:22:49.589]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.589]                             info)
[10:22:49.589]                           info <- base::paste(info, collapse = "; ")
[10:22:49.589]                           if (!has_future) {
[10:22:49.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.589]                               info)
[10:22:49.589]                           }
[10:22:49.589]                           else {
[10:22:49.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.589]                               info, version)
[10:22:49.589]                           }
[10:22:49.589]                           base::stop(msg)
[10:22:49.589]                         }
[10:22:49.589]                       })
[10:22:49.589]                     }
[10:22:49.589]                     base::local({
[10:22:49.589]                       for (pkg in "stats") {
[10:22:49.589]                         base::loadNamespace(pkg)
[10:22:49.589]                         base::library(pkg, character.only = TRUE)
[10:22:49.589]                       }
[10:22:49.589]                     })
[10:22:49.589]                   }
[10:22:49.589]                   options(future.plan = NULL)
[10:22:49.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.589]                 }
[10:22:49.589]                 ...future.workdir <- getwd()
[10:22:49.589]             }
[10:22:49.589]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.589]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.589]         }
[10:22:49.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.589]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.589]             base::names(...future.oldOptions))
[10:22:49.589]     }
[10:22:49.589]     if (FALSE) {
[10:22:49.589]     }
[10:22:49.589]     else {
[10:22:49.589]         if (TRUE) {
[10:22:49.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.589]                 open = "w")
[10:22:49.589]         }
[10:22:49.589]         else {
[10:22:49.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.589]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.589]         }
[10:22:49.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.589]             base::sink(type = "output", split = FALSE)
[10:22:49.589]             base::close(...future.stdout)
[10:22:49.589]         }, add = TRUE)
[10:22:49.589]     }
[10:22:49.589]     ...future.frame <- base::sys.nframe()
[10:22:49.589]     ...future.conditions <- base::list()
[10:22:49.589]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.589]     if (FALSE) {
[10:22:49.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.589]     }
[10:22:49.589]     ...future.result <- base::tryCatch({
[10:22:49.589]         base::withCallingHandlers({
[10:22:49.589]             ...future.value <- base::withVisible(base::local({
[10:22:49.589]                 do.call(function(...) {
[10:22:49.589]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.589]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.589]                     ...future.globals.maxSize)) {
[10:22:49.589]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.589]                     on.exit(options(oopts), add = TRUE)
[10:22:49.589]                   }
[10:22:49.589]                   {
[10:22:49.589]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.589]                       FUN = function(jj) {
[10:22:49.589]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.589]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.589]                       })
[10:22:49.589]                   }
[10:22:49.589]                 }, args = future.call.arguments)
[10:22:49.589]             }))
[10:22:49.589]             future::FutureResult(value = ...future.value$value, 
[10:22:49.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.589]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.589]                     ...future.globalenv.names))
[10:22:49.589]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.589]         }, condition = base::local({
[10:22:49.589]             c <- base::c
[10:22:49.589]             inherits <- base::inherits
[10:22:49.589]             invokeRestart <- base::invokeRestart
[10:22:49.589]             length <- base::length
[10:22:49.589]             list <- base::list
[10:22:49.589]             seq.int <- base::seq.int
[10:22:49.589]             signalCondition <- base::signalCondition
[10:22:49.589]             sys.calls <- base::sys.calls
[10:22:49.589]             `[[` <- base::`[[`
[10:22:49.589]             `+` <- base::`+`
[10:22:49.589]             `<<-` <- base::`<<-`
[10:22:49.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.589]                   3L)]
[10:22:49.589]             }
[10:22:49.589]             function(cond) {
[10:22:49.589]                 is_error <- inherits(cond, "error")
[10:22:49.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.589]                   NULL)
[10:22:49.589]                 if (is_error) {
[10:22:49.589]                   sessionInformation <- function() {
[10:22:49.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.589]                       search = base::search(), system = base::Sys.info())
[10:22:49.589]                   }
[10:22:49.589]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.589]                     cond$call), session = sessionInformation(), 
[10:22:49.589]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.589]                   signalCondition(cond)
[10:22:49.589]                 }
[10:22:49.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.589]                 "immediateCondition"))) {
[10:22:49.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.589]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.589]                   if (TRUE && !signal) {
[10:22:49.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.589]                     {
[10:22:49.589]                       inherits <- base::inherits
[10:22:49.589]                       invokeRestart <- base::invokeRestart
[10:22:49.589]                       is.null <- base::is.null
[10:22:49.589]                       muffled <- FALSE
[10:22:49.589]                       if (inherits(cond, "message")) {
[10:22:49.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.589]                         if (muffled) 
[10:22:49.589]                           invokeRestart("muffleMessage")
[10:22:49.589]                       }
[10:22:49.589]                       else if (inherits(cond, "warning")) {
[10:22:49.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.589]                         if (muffled) 
[10:22:49.589]                           invokeRestart("muffleWarning")
[10:22:49.589]                       }
[10:22:49.589]                       else if (inherits(cond, "condition")) {
[10:22:49.589]                         if (!is.null(pattern)) {
[10:22:49.589]                           computeRestarts <- base::computeRestarts
[10:22:49.589]                           grepl <- base::grepl
[10:22:49.589]                           restarts <- computeRestarts(cond)
[10:22:49.589]                           for (restart in restarts) {
[10:22:49.589]                             name <- restart$name
[10:22:49.589]                             if (is.null(name)) 
[10:22:49.589]                               next
[10:22:49.589]                             if (!grepl(pattern, name)) 
[10:22:49.589]                               next
[10:22:49.589]                             invokeRestart(restart)
[10:22:49.589]                             muffled <- TRUE
[10:22:49.589]                             break
[10:22:49.589]                           }
[10:22:49.589]                         }
[10:22:49.589]                       }
[10:22:49.589]                       invisible(muffled)
[10:22:49.589]                     }
[10:22:49.589]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.589]                   }
[10:22:49.589]                 }
[10:22:49.589]                 else {
[10:22:49.589]                   if (TRUE) {
[10:22:49.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.589]                     {
[10:22:49.589]                       inherits <- base::inherits
[10:22:49.589]                       invokeRestart <- base::invokeRestart
[10:22:49.589]                       is.null <- base::is.null
[10:22:49.589]                       muffled <- FALSE
[10:22:49.589]                       if (inherits(cond, "message")) {
[10:22:49.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.589]                         if (muffled) 
[10:22:49.589]                           invokeRestart("muffleMessage")
[10:22:49.589]                       }
[10:22:49.589]                       else if (inherits(cond, "warning")) {
[10:22:49.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.589]                         if (muffled) 
[10:22:49.589]                           invokeRestart("muffleWarning")
[10:22:49.589]                       }
[10:22:49.589]                       else if (inherits(cond, "condition")) {
[10:22:49.589]                         if (!is.null(pattern)) {
[10:22:49.589]                           computeRestarts <- base::computeRestarts
[10:22:49.589]                           grepl <- base::grepl
[10:22:49.589]                           restarts <- computeRestarts(cond)
[10:22:49.589]                           for (restart in restarts) {
[10:22:49.589]                             name <- restart$name
[10:22:49.589]                             if (is.null(name)) 
[10:22:49.589]                               next
[10:22:49.589]                             if (!grepl(pattern, name)) 
[10:22:49.589]                               next
[10:22:49.589]                             invokeRestart(restart)
[10:22:49.589]                             muffled <- TRUE
[10:22:49.589]                             break
[10:22:49.589]                           }
[10:22:49.589]                         }
[10:22:49.589]                       }
[10:22:49.589]                       invisible(muffled)
[10:22:49.589]                     }
[10:22:49.589]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.589]                   }
[10:22:49.589]                 }
[10:22:49.589]             }
[10:22:49.589]         }))
[10:22:49.589]     }, error = function(ex) {
[10:22:49.589]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.589]                 ...future.rng), started = ...future.startTime, 
[10:22:49.589]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.589]             version = "1.8"), class = "FutureResult")
[10:22:49.589]     }, finally = {
[10:22:49.589]         if (!identical(...future.workdir, getwd())) 
[10:22:49.589]             setwd(...future.workdir)
[10:22:49.589]         {
[10:22:49.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.589]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.589]             }
[10:22:49.589]             base::options(...future.oldOptions)
[10:22:49.589]             if (.Platform$OS.type == "windows") {
[10:22:49.589]                 old_names <- names(...future.oldEnvVars)
[10:22:49.589]                 envs <- base::Sys.getenv()
[10:22:49.589]                 names <- names(envs)
[10:22:49.589]                 common <- intersect(names, old_names)
[10:22:49.589]                 added <- setdiff(names, old_names)
[10:22:49.589]                 removed <- setdiff(old_names, names)
[10:22:49.589]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.589]                   envs[common]]
[10:22:49.589]                 NAMES <- toupper(changed)
[10:22:49.589]                 args <- list()
[10:22:49.589]                 for (kk in seq_along(NAMES)) {
[10:22:49.589]                   name <- changed[[kk]]
[10:22:49.589]                   NAME <- NAMES[[kk]]
[10:22:49.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.589]                     next
[10:22:49.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.589]                 }
[10:22:49.589]                 NAMES <- toupper(added)
[10:22:49.589]                 for (kk in seq_along(NAMES)) {
[10:22:49.589]                   name <- added[[kk]]
[10:22:49.589]                   NAME <- NAMES[[kk]]
[10:22:49.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.589]                     next
[10:22:49.589]                   args[[name]] <- ""
[10:22:49.589]                 }
[10:22:49.589]                 NAMES <- toupper(removed)
[10:22:49.589]                 for (kk in seq_along(NAMES)) {
[10:22:49.589]                   name <- removed[[kk]]
[10:22:49.589]                   NAME <- NAMES[[kk]]
[10:22:49.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.589]                     next
[10:22:49.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.589]                 }
[10:22:49.589]                 if (length(args) > 0) 
[10:22:49.589]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.589]             }
[10:22:49.589]             else {
[10:22:49.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.589]             }
[10:22:49.589]             {
[10:22:49.589]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.589]                   0L) {
[10:22:49.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.589]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.589]                   base::options(opts)
[10:22:49.589]                 }
[10:22:49.589]                 {
[10:22:49.589]                   {
[10:22:49.589]                     NULL
[10:22:49.589]                     RNGkind("Mersenne-Twister")
[10:22:49.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.589]                       inherits = FALSE)
[10:22:49.589]                   }
[10:22:49.589]                   options(future.plan = NULL)
[10:22:49.589]                   if (is.na(NA_character_)) 
[10:22:49.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.589]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:49.589]                   {
[10:22:49.589]                     future <- SequentialFuture(..., envir = envir)
[10:22:49.589]                     if (!future$lazy) 
[10:22:49.589]                       future <- run(future)
[10:22:49.589]                     invisible(future)
[10:22:49.589]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.589]                 }
[10:22:49.589]             }
[10:22:49.589]         }
[10:22:49.589]     })
[10:22:49.589]     if (TRUE) {
[10:22:49.589]         base::sink(type = "output", split = FALSE)
[10:22:49.589]         if (TRUE) {
[10:22:49.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.589]         }
[10:22:49.589]         else {
[10:22:49.589]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.589]         }
[10:22:49.589]         base::close(...future.stdout)
[10:22:49.589]         ...future.stdout <- NULL
[10:22:49.589]     }
[10:22:49.589]     ...future.result$conditions <- ...future.conditions
[10:22:49.589]     ...future.result$finished <- base::Sys.time()
[10:22:49.589]     ...future.result
[10:22:49.589] }
[10:22:49.591] assign_globals() ...
[10:22:49.591] List of 5
[10:22:49.591]  $ ...future.FUN            :function (x, ...)  
[10:22:49.591]  $ future.call.arguments    :List of 1
[10:22:49.591]   ..$ singular.ok: logi FALSE
[10:22:49.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.591]  $ ...future.elements_ii    :List of 3
[10:22:49.591]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.591]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.591]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.591]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.591]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.591]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.591]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.591]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.591]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.591]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.591]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.591]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.591]  $ ...future.seeds_ii       : NULL
[10:22:49.591]  $ ...future.globals.maxSize: NULL
[10:22:49.591]  - attr(*, "where")=List of 5
[10:22:49.591]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.591]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.591]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.591]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.591]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.591]  - attr(*, "resolved")= logi FALSE
[10:22:49.591]  - attr(*, "total_size")= num 5384
[10:22:49.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.591]  - attr(*, "already-done")= logi TRUE
[10:22:49.601] - reassign environment for ‘...future.FUN’
[10:22:49.601] - copied ‘...future.FUN’ to environment
[10:22:49.601] - copied ‘future.call.arguments’ to environment
[10:22:49.601] - copied ‘...future.elements_ii’ to environment
[10:22:49.601] - copied ‘...future.seeds_ii’ to environment
[10:22:49.601] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.602] assign_globals() ... done
[10:22:49.602] plan(): Setting new future strategy stack:
[10:22:49.602] List of future strategies:
[10:22:49.602] 1. sequential:
[10:22:49.602]    - args: function (..., envir = parent.frame())
[10:22:49.602]    - tweaked: FALSE
[10:22:49.602]    - call: NULL
[10:22:49.602] plan(): nbrOfWorkers() = 1
[10:22:49.605] plan(): Setting new future strategy stack:
[10:22:49.605] List of future strategies:
[10:22:49.605] 1. sequential:
[10:22:49.605]    - args: function (..., envir = parent.frame())
[10:22:49.605]    - tweaked: FALSE
[10:22:49.605]    - call: plan(strategy)
[10:22:49.606] plan(): nbrOfWorkers() = 1
[10:22:49.606] SequentialFuture started (and completed)
[10:22:49.606] - Launch lazy future ... done
[10:22:49.606] run() for ‘SequentialFuture’ ... done
[10:22:49.606] Created future:
[10:22:49.606] SequentialFuture:
[10:22:49.606] Label: ‘future_by-1’
[10:22:49.606] Expression:
[10:22:49.606] {
[10:22:49.606]     do.call(function(...) {
[10:22:49.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.606]             on.exit(options(oopts), add = TRUE)
[10:22:49.606]         }
[10:22:49.606]         {
[10:22:49.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.606]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.606]             })
[10:22:49.606]         }
[10:22:49.606]     }, args = future.call.arguments)
[10:22:49.606] }
[10:22:49.606] Lazy evaluation: FALSE
[10:22:49.606] Asynchronous evaluation: FALSE
[10:22:49.606] Local evaluation: TRUE
[10:22:49.606] Environment: R_GlobalEnv
[10:22:49.606] Capture standard output: TRUE
[10:22:49.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.606] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.606] Packages: 1 packages (‘stats’)
[10:22:49.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.606] Resolved: TRUE
[10:22:49.606] Value: 26.06 KiB of class ‘list’
[10:22:49.606] Early signaling: FALSE
[10:22:49.606] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.606] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.608] Chunk #1 of 1 ... DONE
[10:22:49.608] Launching 1 futures (chunks) ... DONE
[10:22:49.608] Resolving 1 futures (chunks) ...
[10:22:49.608] resolve() on list ...
[10:22:49.608]  recursive: 0
[10:22:49.608]  length: 1
[10:22:49.608] 
[10:22:49.608] resolved() for ‘SequentialFuture’ ...
[10:22:49.608] - state: ‘finished’
[10:22:49.608] - run: TRUE
[10:22:49.608] - result: ‘FutureResult’
[10:22:49.609] resolved() for ‘SequentialFuture’ ... done
[10:22:49.609] Future #1
[10:22:49.609] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.609] - nx: 1
[10:22:49.609] - relay: TRUE
[10:22:49.609] - stdout: TRUE
[10:22:49.609] - signal: TRUE
[10:22:49.609] - resignal: FALSE
[10:22:49.609] - force: TRUE
[10:22:49.609] - relayed: [n=1] FALSE
[10:22:49.609] - queued futures: [n=1] FALSE
[10:22:49.610]  - until=1
[10:22:49.610]  - relaying element #1
[10:22:49.610] - relayed: [n=1] TRUE
[10:22:49.610] - queued futures: [n=1] TRUE
[10:22:49.610] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.610]  length: 0 (resolved future 1)
[10:22:49.610] Relaying remaining futures
[10:22:49.610] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.610] - nx: 1
[10:22:49.610] - relay: TRUE
[10:22:49.611] - stdout: TRUE
[10:22:49.611] - signal: TRUE
[10:22:49.611] - resignal: FALSE
[10:22:49.611] - force: TRUE
[10:22:49.611] - relayed: [n=1] TRUE
[10:22:49.611] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.611] - relayed: [n=1] TRUE
[10:22:49.611] - queued futures: [n=1] TRUE
[10:22:49.611] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.611] resolve() on list ... DONE
[10:22:49.611]  - Number of value chunks collected: 1
[10:22:49.612] Resolving 1 futures (chunks) ... DONE
[10:22:49.612] Reducing values from 1 chunks ...
[10:22:49.612]  - Number of values collected after concatenation: 3
[10:22:49.612]  - Number of values expected: 3
[10:22:49.612] Reducing values from 1 chunks ... DONE
[10:22:49.612] future_lapply() ... DONE
[10:22:49.612] future_by_internal() ... DONE
[10:22:49.616] future_by_internal() ...
[10:22:49.616] future_lapply() ...
[10:22:49.618] Number of chunks: 1
[10:22:49.618] getGlobalsAndPackagesXApply() ...
[10:22:49.618]  - future.globals: TRUE
[10:22:49.619] getGlobalsAndPackages() ...
[10:22:49.619] Searching for globals...
[10:22:49.620] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:49.620] Searching for globals ... DONE
[10:22:49.621] Resolving globals: FALSE
[10:22:49.621] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:22:49.621] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:22:49.622] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:49.622] - packages: [1] ‘stats’
[10:22:49.622] getGlobalsAndPackages() ... DONE
[10:22:49.622]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:49.622]  - needed namespaces: [n=1] ‘stats’
[10:22:49.622] Finding globals ... DONE
[10:22:49.622]  - use_args: TRUE
[10:22:49.622]  - Getting '...' globals ...
[10:22:49.623] resolve() on list ...
[10:22:49.623]  recursive: 0
[10:22:49.623]  length: 1
[10:22:49.623]  elements: ‘...’
[10:22:49.623]  length: 0 (resolved future 1)
[10:22:49.623] resolve() on list ... DONE
[10:22:49.623]    - '...' content: [n=0] 
[10:22:49.623] List of 1
[10:22:49.623]  $ ...: list()
[10:22:49.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.623]  - attr(*, "where")=List of 1
[10:22:49.623]   ..$ ...:<environment: 0x55f639fa4698> 
[10:22:49.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.623]  - attr(*, "resolved")= logi TRUE
[10:22:49.623]  - attr(*, "total_size")= num NA
[10:22:49.626]  - Getting '...' globals ... DONE
[10:22:49.626] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:22:49.626] List of 4
[10:22:49.626]  $ ...future.FUN:function (x)  
[10:22:49.626]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:49.626]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.626]  $ ...          : list()
[10:22:49.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.626]  - attr(*, "where")=List of 4
[10:22:49.626]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.626]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:22:49.626]   ..$ wool         :<environment: R_EmptyEnv> 
[10:22:49.626]   ..$ ...          :<environment: 0x55f639fa4698> 
[10:22:49.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.626]  - attr(*, "resolved")= logi FALSE
[10:22:49.626]  - attr(*, "total_size")= num 2320
[10:22:49.629] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:49.630] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.630] Number of futures (= number of chunks): 1
[10:22:49.630] Launching 1 futures (chunks) ...
[10:22:49.630] Chunk #1 of 1 ...
[10:22:49.630]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.630] getGlobalsAndPackages() ...
[10:22:49.630] Searching for globals...
[10:22:49.631] 
[10:22:49.631] Searching for globals ... DONE
[10:22:49.631] - globals: [0] <none>
[10:22:49.631] getGlobalsAndPackages() ... DONE
[10:22:49.631]    + additional globals found: [n=0] 
[10:22:49.631]    + additional namespaces needed: [n=0] 
[10:22:49.631]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.631]  - seeds: <none>
[10:22:49.631]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.631] getGlobalsAndPackages() ...
[10:22:49.632] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.632] Resolving globals: FALSE
[10:22:49.632] Tweak future expression to call with '...' arguments ...
[10:22:49.632] {
[10:22:49.632]     do.call(function(...) {
[10:22:49.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.632]             on.exit(options(oopts), add = TRUE)
[10:22:49.632]         }
[10:22:49.632]         {
[10:22:49.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.632]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.632]             })
[10:22:49.632]         }
[10:22:49.632]     }, args = future.call.arguments)
[10:22:49.632] }
[10:22:49.632] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.632] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.633] 
[10:22:49.633] getGlobalsAndPackages() ... DONE
[10:22:49.633] run() for ‘Future’ ...
[10:22:49.633] - state: ‘created’
[10:22:49.633] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:49.633] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.634]   - Field: ‘label’
[10:22:49.634]   - Field: ‘local’
[10:22:49.634]   - Field: ‘owner’
[10:22:49.634]   - Field: ‘envir’
[10:22:49.634]   - Field: ‘packages’
[10:22:49.634]   - Field: ‘gc’
[10:22:49.634]   - Field: ‘conditions’
[10:22:49.634]   - Field: ‘expr’
[10:22:49.634]   - Field: ‘uuid’
[10:22:49.634]   - Field: ‘seed’
[10:22:49.635]   - Field: ‘version’
[10:22:49.635]   - Field: ‘result’
[10:22:49.635]   - Field: ‘asynchronous’
[10:22:49.635]   - Field: ‘calls’
[10:22:49.635]   - Field: ‘globals’
[10:22:49.635]   - Field: ‘stdout’
[10:22:49.635]   - Field: ‘earlySignal’
[10:22:49.635]   - Field: ‘lazy’
[10:22:49.636]   - Field: ‘state’
[10:22:49.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.637] - Launch lazy future ...
[10:22:49.637] Packages needed by the future expression (n = 1): ‘stats’
[10:22:49.637] Packages needed by future strategies (n = 0): <none>
[10:22:49.637] {
[10:22:49.637]     {
[10:22:49.637]         {
[10:22:49.637]             ...future.startTime <- base::Sys.time()
[10:22:49.637]             {
[10:22:49.637]                 {
[10:22:49.637]                   {
[10:22:49.637]                     {
[10:22:49.637]                       base::local({
[10:22:49.637]                         has_future <- base::requireNamespace("future", 
[10:22:49.637]                           quietly = TRUE)
[10:22:49.637]                         if (has_future) {
[10:22:49.637]                           ns <- base::getNamespace("future")
[10:22:49.637]                           version <- ns[[".package"]][["version"]]
[10:22:49.637]                           if (is.null(version)) 
[10:22:49.637]                             version <- utils::packageVersion("future")
[10:22:49.637]                         }
[10:22:49.637]                         else {
[10:22:49.637]                           version <- NULL
[10:22:49.637]                         }
[10:22:49.637]                         if (!has_future || version < "1.8.0") {
[10:22:49.637]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.637]                             "", base::R.version$version.string), 
[10:22:49.637]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.637]                               "release", "version")], collapse = " "), 
[10:22:49.637]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.637]                             info)
[10:22:49.637]                           info <- base::paste(info, collapse = "; ")
[10:22:49.637]                           if (!has_future) {
[10:22:49.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.637]                               info)
[10:22:49.637]                           }
[10:22:49.637]                           else {
[10:22:49.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.637]                               info, version)
[10:22:49.637]                           }
[10:22:49.637]                           base::stop(msg)
[10:22:49.637]                         }
[10:22:49.637]                       })
[10:22:49.637]                     }
[10:22:49.637]                     base::local({
[10:22:49.637]                       for (pkg in "stats") {
[10:22:49.637]                         base::loadNamespace(pkg)
[10:22:49.637]                         base::library(pkg, character.only = TRUE)
[10:22:49.637]                       }
[10:22:49.637]                     })
[10:22:49.637]                   }
[10:22:49.637]                   options(future.plan = NULL)
[10:22:49.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.637]                 }
[10:22:49.637]                 ...future.workdir <- getwd()
[10:22:49.637]             }
[10:22:49.637]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.637]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.637]         }
[10:22:49.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.637]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.637]             base::names(...future.oldOptions))
[10:22:49.637]     }
[10:22:49.637]     if (FALSE) {
[10:22:49.637]     }
[10:22:49.637]     else {
[10:22:49.637]         if (TRUE) {
[10:22:49.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.637]                 open = "w")
[10:22:49.637]         }
[10:22:49.637]         else {
[10:22:49.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.637]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.637]         }
[10:22:49.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.637]             base::sink(type = "output", split = FALSE)
[10:22:49.637]             base::close(...future.stdout)
[10:22:49.637]         }, add = TRUE)
[10:22:49.637]     }
[10:22:49.637]     ...future.frame <- base::sys.nframe()
[10:22:49.637]     ...future.conditions <- base::list()
[10:22:49.637]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.637]     if (FALSE) {
[10:22:49.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.637]     }
[10:22:49.637]     ...future.result <- base::tryCatch({
[10:22:49.637]         base::withCallingHandlers({
[10:22:49.637]             ...future.value <- base::withVisible(base::local({
[10:22:49.637]                 do.call(function(...) {
[10:22:49.637]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.637]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.637]                     ...future.globals.maxSize)) {
[10:22:49.637]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.637]                     on.exit(options(oopts), add = TRUE)
[10:22:49.637]                   }
[10:22:49.637]                   {
[10:22:49.637]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.637]                       FUN = function(jj) {
[10:22:49.637]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.637]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.637]                       })
[10:22:49.637]                   }
[10:22:49.637]                 }, args = future.call.arguments)
[10:22:49.637]             }))
[10:22:49.637]             future::FutureResult(value = ...future.value$value, 
[10:22:49.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.637]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.637]                     ...future.globalenv.names))
[10:22:49.637]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.637]         }, condition = base::local({
[10:22:49.637]             c <- base::c
[10:22:49.637]             inherits <- base::inherits
[10:22:49.637]             invokeRestart <- base::invokeRestart
[10:22:49.637]             length <- base::length
[10:22:49.637]             list <- base::list
[10:22:49.637]             seq.int <- base::seq.int
[10:22:49.637]             signalCondition <- base::signalCondition
[10:22:49.637]             sys.calls <- base::sys.calls
[10:22:49.637]             `[[` <- base::`[[`
[10:22:49.637]             `+` <- base::`+`
[10:22:49.637]             `<<-` <- base::`<<-`
[10:22:49.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.637]                   3L)]
[10:22:49.637]             }
[10:22:49.637]             function(cond) {
[10:22:49.637]                 is_error <- inherits(cond, "error")
[10:22:49.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.637]                   NULL)
[10:22:49.637]                 if (is_error) {
[10:22:49.637]                   sessionInformation <- function() {
[10:22:49.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.637]                       search = base::search(), system = base::Sys.info())
[10:22:49.637]                   }
[10:22:49.637]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.637]                     cond$call), session = sessionInformation(), 
[10:22:49.637]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.637]                   signalCondition(cond)
[10:22:49.637]                 }
[10:22:49.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.637]                 "immediateCondition"))) {
[10:22:49.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.637]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.637]                   if (TRUE && !signal) {
[10:22:49.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.637]                     {
[10:22:49.637]                       inherits <- base::inherits
[10:22:49.637]                       invokeRestart <- base::invokeRestart
[10:22:49.637]                       is.null <- base::is.null
[10:22:49.637]                       muffled <- FALSE
[10:22:49.637]                       if (inherits(cond, "message")) {
[10:22:49.637]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.637]                         if (muffled) 
[10:22:49.637]                           invokeRestart("muffleMessage")
[10:22:49.637]                       }
[10:22:49.637]                       else if (inherits(cond, "warning")) {
[10:22:49.637]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.637]                         if (muffled) 
[10:22:49.637]                           invokeRestart("muffleWarning")
[10:22:49.637]                       }
[10:22:49.637]                       else if (inherits(cond, "condition")) {
[10:22:49.637]                         if (!is.null(pattern)) {
[10:22:49.637]                           computeRestarts <- base::computeRestarts
[10:22:49.637]                           grepl <- base::grepl
[10:22:49.637]                           restarts <- computeRestarts(cond)
[10:22:49.637]                           for (restart in restarts) {
[10:22:49.637]                             name <- restart$name
[10:22:49.637]                             if (is.null(name)) 
[10:22:49.637]                               next
[10:22:49.637]                             if (!grepl(pattern, name)) 
[10:22:49.637]                               next
[10:22:49.637]                             invokeRestart(restart)
[10:22:49.637]                             muffled <- TRUE
[10:22:49.637]                             break
[10:22:49.637]                           }
[10:22:49.637]                         }
[10:22:49.637]                       }
[10:22:49.637]                       invisible(muffled)
[10:22:49.637]                     }
[10:22:49.637]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.637]                   }
[10:22:49.637]                 }
[10:22:49.637]                 else {
[10:22:49.637]                   if (TRUE) {
[10:22:49.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.637]                     {
[10:22:49.637]                       inherits <- base::inherits
[10:22:49.637]                       invokeRestart <- base::invokeRestart
[10:22:49.637]                       is.null <- base::is.null
[10:22:49.637]                       muffled <- FALSE
[10:22:49.637]                       if (inherits(cond, "message")) {
[10:22:49.637]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.637]                         if (muffled) 
[10:22:49.637]                           invokeRestart("muffleMessage")
[10:22:49.637]                       }
[10:22:49.637]                       else if (inherits(cond, "warning")) {
[10:22:49.637]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.637]                         if (muffled) 
[10:22:49.637]                           invokeRestart("muffleWarning")
[10:22:49.637]                       }
[10:22:49.637]                       else if (inherits(cond, "condition")) {
[10:22:49.637]                         if (!is.null(pattern)) {
[10:22:49.637]                           computeRestarts <- base::computeRestarts
[10:22:49.637]                           grepl <- base::grepl
[10:22:49.637]                           restarts <- computeRestarts(cond)
[10:22:49.637]                           for (restart in restarts) {
[10:22:49.637]                             name <- restart$name
[10:22:49.637]                             if (is.null(name)) 
[10:22:49.637]                               next
[10:22:49.637]                             if (!grepl(pattern, name)) 
[10:22:49.637]                               next
[10:22:49.637]                             invokeRestart(restart)
[10:22:49.637]                             muffled <- TRUE
[10:22:49.637]                             break
[10:22:49.637]                           }
[10:22:49.637]                         }
[10:22:49.637]                       }
[10:22:49.637]                       invisible(muffled)
[10:22:49.637]                     }
[10:22:49.637]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.637]                   }
[10:22:49.637]                 }
[10:22:49.637]             }
[10:22:49.637]         }))
[10:22:49.637]     }, error = function(ex) {
[10:22:49.637]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.637]                 ...future.rng), started = ...future.startTime, 
[10:22:49.637]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.637]             version = "1.8"), class = "FutureResult")
[10:22:49.637]     }, finally = {
[10:22:49.637]         if (!identical(...future.workdir, getwd())) 
[10:22:49.637]             setwd(...future.workdir)
[10:22:49.637]         {
[10:22:49.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.637]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.637]             }
[10:22:49.637]             base::options(...future.oldOptions)
[10:22:49.637]             if (.Platform$OS.type == "windows") {
[10:22:49.637]                 old_names <- names(...future.oldEnvVars)
[10:22:49.637]                 envs <- base::Sys.getenv()
[10:22:49.637]                 names <- names(envs)
[10:22:49.637]                 common <- intersect(names, old_names)
[10:22:49.637]                 added <- setdiff(names, old_names)
[10:22:49.637]                 removed <- setdiff(old_names, names)
[10:22:49.637]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.637]                   envs[common]]
[10:22:49.637]                 NAMES <- toupper(changed)
[10:22:49.637]                 args <- list()
[10:22:49.637]                 for (kk in seq_along(NAMES)) {
[10:22:49.637]                   name <- changed[[kk]]
[10:22:49.637]                   NAME <- NAMES[[kk]]
[10:22:49.637]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.637]                     next
[10:22:49.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.637]                 }
[10:22:49.637]                 NAMES <- toupper(added)
[10:22:49.637]                 for (kk in seq_along(NAMES)) {
[10:22:49.637]                   name <- added[[kk]]
[10:22:49.637]                   NAME <- NAMES[[kk]]
[10:22:49.637]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.637]                     next
[10:22:49.637]                   args[[name]] <- ""
[10:22:49.637]                 }
[10:22:49.637]                 NAMES <- toupper(removed)
[10:22:49.637]                 for (kk in seq_along(NAMES)) {
[10:22:49.637]                   name <- removed[[kk]]
[10:22:49.637]                   NAME <- NAMES[[kk]]
[10:22:49.637]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.637]                     next
[10:22:49.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.637]                 }
[10:22:49.637]                 if (length(args) > 0) 
[10:22:49.637]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.637]             }
[10:22:49.637]             else {
[10:22:49.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.637]             }
[10:22:49.637]             {
[10:22:49.637]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.637]                   0L) {
[10:22:49.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.637]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.637]                   base::options(opts)
[10:22:49.637]                 }
[10:22:49.637]                 {
[10:22:49.637]                   {
[10:22:49.637]                     NULL
[10:22:49.637]                     RNGkind("Mersenne-Twister")
[10:22:49.637]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.637]                       inherits = FALSE)
[10:22:49.637]                   }
[10:22:49.637]                   options(future.plan = NULL)
[10:22:49.637]                   if (is.na(NA_character_)) 
[10:22:49.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.637]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:49.637]                   {
[10:22:49.637]                     future <- SequentialFuture(..., envir = envir)
[10:22:49.637]                     if (!future$lazy) 
[10:22:49.637]                       future <- run(future)
[10:22:49.637]                     invisible(future)
[10:22:49.637]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.637]                 }
[10:22:49.637]             }
[10:22:49.637]         }
[10:22:49.637]     })
[10:22:49.637]     if (TRUE) {
[10:22:49.637]         base::sink(type = "output", split = FALSE)
[10:22:49.637]         if (TRUE) {
[10:22:49.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.637]         }
[10:22:49.637]         else {
[10:22:49.637]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.637]         }
[10:22:49.637]         base::close(...future.stdout)
[10:22:49.637]         ...future.stdout <- NULL
[10:22:49.637]     }
[10:22:49.637]     ...future.result$conditions <- ...future.conditions
[10:22:49.637]     ...future.result$finished <- base::Sys.time()
[10:22:49.637]     ...future.result
[10:22:49.637] }
[10:22:49.639] assign_globals() ...
[10:22:49.639] List of 7
[10:22:49.639]  $ ...future.FUN            :function (x)  
[10:22:49.639]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:49.639]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.639]  $ future.call.arguments    : list()
[10:22:49.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.639]  $ ...future.elements_ii    :List of 3
[10:22:49.639]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.639]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.639]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.639]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.639]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.639]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.639]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.639]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.639]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.639]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.639]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.639]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.639]  $ ...future.seeds_ii       : NULL
[10:22:49.639]  $ ...future.globals.maxSize: NULL
[10:22:49.639]  - attr(*, "where")=List of 7
[10:22:49.639]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.639]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:22:49.639]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:22:49.639]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.639]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.639]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.639]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.639]  - attr(*, "resolved")= logi FALSE
[10:22:49.639]  - attr(*, "total_size")= num 2320
[10:22:49.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.639]  - attr(*, "already-done")= logi TRUE
[10:22:49.649] - reassign environment for ‘...future.FUN’
[10:22:49.649] - copied ‘...future.FUN’ to environment
[10:22:49.649] - copied ‘breaks’ to environment
[10:22:49.649] - copied ‘wool’ to environment
[10:22:49.649] - copied ‘future.call.arguments’ to environment
[10:22:49.649] - copied ‘...future.elements_ii’ to environment
[10:22:49.649] - copied ‘...future.seeds_ii’ to environment
[10:22:49.649] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.649] assign_globals() ... done
[10:22:49.650] plan(): Setting new future strategy stack:
[10:22:49.650] List of future strategies:
[10:22:49.650] 1. sequential:
[10:22:49.650]    - args: function (..., envir = parent.frame())
[10:22:49.650]    - tweaked: FALSE
[10:22:49.650]    - call: NULL
[10:22:49.650] plan(): nbrOfWorkers() = 1
[10:22:49.653] plan(): Setting new future strategy stack:
[10:22:49.653] List of future strategies:
[10:22:49.653] 1. sequential:
[10:22:49.653]    - args: function (..., envir = parent.frame())
[10:22:49.653]    - tweaked: FALSE
[10:22:49.653]    - call: plan(strategy)
[10:22:49.653] plan(): nbrOfWorkers() = 1
[10:22:49.653] SequentialFuture started (and completed)
[10:22:49.653] - Launch lazy future ... done
[10:22:49.654] run() for ‘SequentialFuture’ ... done
[10:22:49.654] Created future:
[10:22:49.654] SequentialFuture:
[10:22:49.654] Label: ‘future_by-1’
[10:22:49.654] Expression:
[10:22:49.654] {
[10:22:49.654]     do.call(function(...) {
[10:22:49.654]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.654]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.654]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.654]             on.exit(options(oopts), add = TRUE)
[10:22:49.654]         }
[10:22:49.654]         {
[10:22:49.654]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.654]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.654]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.654]             })
[10:22:49.654]         }
[10:22:49.654]     }, args = future.call.arguments)
[10:22:49.654] }
[10:22:49.654] Lazy evaluation: FALSE
[10:22:49.654] Asynchronous evaluation: FALSE
[10:22:49.654] Local evaluation: TRUE
[10:22:49.654] Environment: 0x55f639f3a1f8
[10:22:49.654] Capture standard output: TRUE
[10:22:49.654] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.654] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:22:49.654] Packages: 1 packages (‘stats’)
[10:22:49.654] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.654] Resolved: TRUE
[10:22:49.654] Value: 25.57 KiB of class ‘list’
[10:22:49.654] Early signaling: FALSE
[10:22:49.654] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.654] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.656] Chunk #1 of 1 ... DONE
[10:22:49.657] Launching 1 futures (chunks) ... DONE
[10:22:49.657] Resolving 1 futures (chunks) ...
[10:22:49.657] resolve() on list ...
[10:22:49.657]  recursive: 0
[10:22:49.657]  length: 1
[10:22:49.657] 
[10:22:49.657] resolved() for ‘SequentialFuture’ ...
[10:22:49.657] - state: ‘finished’
[10:22:49.657] - run: TRUE
[10:22:49.657] - result: ‘FutureResult’
[10:22:49.657] resolved() for ‘SequentialFuture’ ... done
[10:22:49.658] Future #1
[10:22:49.658] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.658] - nx: 1
[10:22:49.658] - relay: TRUE
[10:22:49.658] - stdout: TRUE
[10:22:49.658] - signal: TRUE
[10:22:49.658] - resignal: FALSE
[10:22:49.658] - force: TRUE
[10:22:49.658] - relayed: [n=1] FALSE
[10:22:49.658] - queued futures: [n=1] FALSE
[10:22:49.659]  - until=1
[10:22:49.659]  - relaying element #1
[10:22:49.659] - relayed: [n=1] TRUE
[10:22:49.659] - queued futures: [n=1] TRUE
[10:22:49.659] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.659]  length: 0 (resolved future 1)
[10:22:49.659] Relaying remaining futures
[10:22:49.659] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.659] - nx: 1
[10:22:49.659] - relay: TRUE
[10:22:49.659] - stdout: TRUE
[10:22:49.660] - signal: TRUE
[10:22:49.660] - resignal: FALSE
[10:22:49.660] - force: TRUE
[10:22:49.660] - relayed: [n=1] TRUE
[10:22:49.660] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.660] - relayed: [n=1] TRUE
[10:22:49.660] - queued futures: [n=1] TRUE
[10:22:49.660] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.660] resolve() on list ... DONE
[10:22:49.660]  - Number of value chunks collected: 1
[10:22:49.660] Resolving 1 futures (chunks) ... DONE
[10:22:49.661] Reducing values from 1 chunks ...
[10:22:49.661]  - Number of values collected after concatenation: 3
[10:22:49.661]  - Number of values expected: 3
[10:22:49.661] Reducing values from 1 chunks ... DONE
[10:22:49.661] future_lapply() ... DONE
[10:22:49.661] future_by_internal() ... DONE
[10:22:49.661] future_by_internal() ...
[10:22:49.662] future_lapply() ...
[10:22:49.662] Number of chunks: 1
[10:22:49.662] getGlobalsAndPackagesXApply() ...
[10:22:49.662]  - future.globals: TRUE
[10:22:49.662] getGlobalsAndPackages() ...
[10:22:49.663] Searching for globals...
[10:22:49.663] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.664] Searching for globals ... DONE
[10:22:49.664] Resolving globals: FALSE
[10:22:49.664] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.664] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.664] - globals: [1] ‘FUN’
[10:22:49.664] 
[10:22:49.665] getGlobalsAndPackages() ... DONE
[10:22:49.665]  - globals found/used: [n=1] ‘FUN’
[10:22:49.665]  - needed namespaces: [n=0] 
[10:22:49.665] Finding globals ... DONE
[10:22:49.665]  - use_args: TRUE
[10:22:49.665]  - Getting '...' globals ...
[10:22:49.665] resolve() on list ...
[10:22:49.665]  recursive: 0
[10:22:49.665]  length: 1
[10:22:49.666]  elements: ‘...’
[10:22:49.666]  length: 0 (resolved future 1)
[10:22:49.666] resolve() on list ... DONE
[10:22:49.666]    - '...' content: [n=0] 
[10:22:49.666] List of 1
[10:22:49.666]  $ ...: list()
[10:22:49.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.666]  - attr(*, "where")=List of 1
[10:22:49.666]   ..$ ...:<environment: 0x55f6385522b8> 
[10:22:49.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.666]  - attr(*, "resolved")= logi TRUE
[10:22:49.666]  - attr(*, "total_size")= num NA
[10:22:49.668]  - Getting '...' globals ... DONE
[10:22:49.668] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.668] List of 2
[10:22:49.668]  $ ...future.FUN:function (object, ...)  
[10:22:49.668]  $ ...          : list()
[10:22:49.668]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.668]  - attr(*, "where")=List of 2
[10:22:49.668]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.668]   ..$ ...          :<environment: 0x55f6385522b8> 
[10:22:49.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.668]  - attr(*, "resolved")= logi FALSE
[10:22:49.668]  - attr(*, "total_size")= num 1240
[10:22:49.671] Packages to be attached in all futures: [n=0] 
[10:22:49.671] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.671] Number of futures (= number of chunks): 1
[10:22:49.671] Launching 1 futures (chunks) ...
[10:22:49.671] Chunk #1 of 1 ...
[10:22:49.672]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.672] getGlobalsAndPackages() ...
[10:22:49.672] Searching for globals...
[10:22:49.672] 
[10:22:49.672] Searching for globals ... DONE
[10:22:49.672] - globals: [0] <none>
[10:22:49.672] getGlobalsAndPackages() ... DONE
[10:22:49.672]    + additional globals found: [n=0] 
[10:22:49.673]    + additional namespaces needed: [n=0] 
[10:22:49.673]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.673]  - seeds: <none>
[10:22:49.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.674] getGlobalsAndPackages() ...
[10:22:49.674] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.674] Resolving globals: FALSE
[10:22:49.674] Tweak future expression to call with '...' arguments ...
[10:22:49.674] {
[10:22:49.674]     do.call(function(...) {
[10:22:49.674]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.674]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.674]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.674]             on.exit(options(oopts), add = TRUE)
[10:22:49.674]         }
[10:22:49.674]         {
[10:22:49.674]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.674]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.674]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.674]             })
[10:22:49.674]         }
[10:22:49.674]     }, args = future.call.arguments)
[10:22:49.674] }
[10:22:49.675] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.675] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.675] 
[10:22:49.675] getGlobalsAndPackages() ... DONE
[10:22:49.675] run() for ‘Future’ ...
[10:22:49.676] - state: ‘created’
[10:22:49.676] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:49.676] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.676]   - Field: ‘label’
[10:22:49.676]   - Field: ‘local’
[10:22:49.676]   - Field: ‘owner’
[10:22:49.676]   - Field: ‘envir’
[10:22:49.677]   - Field: ‘packages’
[10:22:49.677]   - Field: ‘gc’
[10:22:49.677]   - Field: ‘conditions’
[10:22:49.677]   - Field: ‘expr’
[10:22:49.677]   - Field: ‘uuid’
[10:22:49.677]   - Field: ‘seed’
[10:22:49.677]   - Field: ‘version’
[10:22:49.677]   - Field: ‘result’
[10:22:49.677]   - Field: ‘asynchronous’
[10:22:49.677]   - Field: ‘calls’
[10:22:49.678]   - Field: ‘globals’
[10:22:49.678]   - Field: ‘stdout’
[10:22:49.678]   - Field: ‘earlySignal’
[10:22:49.678]   - Field: ‘lazy’
[10:22:49.678]   - Field: ‘state’
[10:22:49.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.678] - Launch lazy future ...
[10:22:49.678] Packages needed by the future expression (n = 0): <none>
[10:22:49.678] Packages needed by future strategies (n = 0): <none>
[10:22:49.679] {
[10:22:49.679]     {
[10:22:49.679]         {
[10:22:49.679]             ...future.startTime <- base::Sys.time()
[10:22:49.679]             {
[10:22:49.679]                 {
[10:22:49.679]                   {
[10:22:49.679]                     base::local({
[10:22:49.679]                       has_future <- base::requireNamespace("future", 
[10:22:49.679]                         quietly = TRUE)
[10:22:49.679]                       if (has_future) {
[10:22:49.679]                         ns <- base::getNamespace("future")
[10:22:49.679]                         version <- ns[[".package"]][["version"]]
[10:22:49.679]                         if (is.null(version)) 
[10:22:49.679]                           version <- utils::packageVersion("future")
[10:22:49.679]                       }
[10:22:49.679]                       else {
[10:22:49.679]                         version <- NULL
[10:22:49.679]                       }
[10:22:49.679]                       if (!has_future || version < "1.8.0") {
[10:22:49.679]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.679]                           "", base::R.version$version.string), 
[10:22:49.679]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.679]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.679]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.679]                             "release", "version")], collapse = " "), 
[10:22:49.679]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.679]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.679]                           info)
[10:22:49.679]                         info <- base::paste(info, collapse = "; ")
[10:22:49.679]                         if (!has_future) {
[10:22:49.679]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.679]                             info)
[10:22:49.679]                         }
[10:22:49.679]                         else {
[10:22:49.679]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.679]                             info, version)
[10:22:49.679]                         }
[10:22:49.679]                         base::stop(msg)
[10:22:49.679]                       }
[10:22:49.679]                     })
[10:22:49.679]                   }
[10:22:49.679]                   options(future.plan = NULL)
[10:22:49.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.679]                 }
[10:22:49.679]                 ...future.workdir <- getwd()
[10:22:49.679]             }
[10:22:49.679]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.679]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.679]         }
[10:22:49.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.679]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.679]             base::names(...future.oldOptions))
[10:22:49.679]     }
[10:22:49.679]     if (FALSE) {
[10:22:49.679]     }
[10:22:49.679]     else {
[10:22:49.679]         if (TRUE) {
[10:22:49.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.679]                 open = "w")
[10:22:49.679]         }
[10:22:49.679]         else {
[10:22:49.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.679]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.679]         }
[10:22:49.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.679]             base::sink(type = "output", split = FALSE)
[10:22:49.679]             base::close(...future.stdout)
[10:22:49.679]         }, add = TRUE)
[10:22:49.679]     }
[10:22:49.679]     ...future.frame <- base::sys.nframe()
[10:22:49.679]     ...future.conditions <- base::list()
[10:22:49.679]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.679]     if (FALSE) {
[10:22:49.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.679]     }
[10:22:49.679]     ...future.result <- base::tryCatch({
[10:22:49.679]         base::withCallingHandlers({
[10:22:49.679]             ...future.value <- base::withVisible(base::local({
[10:22:49.679]                 do.call(function(...) {
[10:22:49.679]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.679]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.679]                     ...future.globals.maxSize)) {
[10:22:49.679]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.679]                     on.exit(options(oopts), add = TRUE)
[10:22:49.679]                   }
[10:22:49.679]                   {
[10:22:49.679]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.679]                       FUN = function(jj) {
[10:22:49.679]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.679]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.679]                       })
[10:22:49.679]                   }
[10:22:49.679]                 }, args = future.call.arguments)
[10:22:49.679]             }))
[10:22:49.679]             future::FutureResult(value = ...future.value$value, 
[10:22:49.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.679]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.679]                     ...future.globalenv.names))
[10:22:49.679]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.679]         }, condition = base::local({
[10:22:49.679]             c <- base::c
[10:22:49.679]             inherits <- base::inherits
[10:22:49.679]             invokeRestart <- base::invokeRestart
[10:22:49.679]             length <- base::length
[10:22:49.679]             list <- base::list
[10:22:49.679]             seq.int <- base::seq.int
[10:22:49.679]             signalCondition <- base::signalCondition
[10:22:49.679]             sys.calls <- base::sys.calls
[10:22:49.679]             `[[` <- base::`[[`
[10:22:49.679]             `+` <- base::`+`
[10:22:49.679]             `<<-` <- base::`<<-`
[10:22:49.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.679]                   3L)]
[10:22:49.679]             }
[10:22:49.679]             function(cond) {
[10:22:49.679]                 is_error <- inherits(cond, "error")
[10:22:49.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.679]                   NULL)
[10:22:49.679]                 if (is_error) {
[10:22:49.679]                   sessionInformation <- function() {
[10:22:49.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.679]                       search = base::search(), system = base::Sys.info())
[10:22:49.679]                   }
[10:22:49.679]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.679]                     cond$call), session = sessionInformation(), 
[10:22:49.679]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.679]                   signalCondition(cond)
[10:22:49.679]                 }
[10:22:49.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.679]                 "immediateCondition"))) {
[10:22:49.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.679]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.679]                   if (TRUE && !signal) {
[10:22:49.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.679]                     {
[10:22:49.679]                       inherits <- base::inherits
[10:22:49.679]                       invokeRestart <- base::invokeRestart
[10:22:49.679]                       is.null <- base::is.null
[10:22:49.679]                       muffled <- FALSE
[10:22:49.679]                       if (inherits(cond, "message")) {
[10:22:49.679]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.679]                         if (muffled) 
[10:22:49.679]                           invokeRestart("muffleMessage")
[10:22:49.679]                       }
[10:22:49.679]                       else if (inherits(cond, "warning")) {
[10:22:49.679]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.679]                         if (muffled) 
[10:22:49.679]                           invokeRestart("muffleWarning")
[10:22:49.679]                       }
[10:22:49.679]                       else if (inherits(cond, "condition")) {
[10:22:49.679]                         if (!is.null(pattern)) {
[10:22:49.679]                           computeRestarts <- base::computeRestarts
[10:22:49.679]                           grepl <- base::grepl
[10:22:49.679]                           restarts <- computeRestarts(cond)
[10:22:49.679]                           for (restart in restarts) {
[10:22:49.679]                             name <- restart$name
[10:22:49.679]                             if (is.null(name)) 
[10:22:49.679]                               next
[10:22:49.679]                             if (!grepl(pattern, name)) 
[10:22:49.679]                               next
[10:22:49.679]                             invokeRestart(restart)
[10:22:49.679]                             muffled <- TRUE
[10:22:49.679]                             break
[10:22:49.679]                           }
[10:22:49.679]                         }
[10:22:49.679]                       }
[10:22:49.679]                       invisible(muffled)
[10:22:49.679]                     }
[10:22:49.679]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.679]                   }
[10:22:49.679]                 }
[10:22:49.679]                 else {
[10:22:49.679]                   if (TRUE) {
[10:22:49.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.679]                     {
[10:22:49.679]                       inherits <- base::inherits
[10:22:49.679]                       invokeRestart <- base::invokeRestart
[10:22:49.679]                       is.null <- base::is.null
[10:22:49.679]                       muffled <- FALSE
[10:22:49.679]                       if (inherits(cond, "message")) {
[10:22:49.679]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.679]                         if (muffled) 
[10:22:49.679]                           invokeRestart("muffleMessage")
[10:22:49.679]                       }
[10:22:49.679]                       else if (inherits(cond, "warning")) {
[10:22:49.679]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.679]                         if (muffled) 
[10:22:49.679]                           invokeRestart("muffleWarning")
[10:22:49.679]                       }
[10:22:49.679]                       else if (inherits(cond, "condition")) {
[10:22:49.679]                         if (!is.null(pattern)) {
[10:22:49.679]                           computeRestarts <- base::computeRestarts
[10:22:49.679]                           grepl <- base::grepl
[10:22:49.679]                           restarts <- computeRestarts(cond)
[10:22:49.679]                           for (restart in restarts) {
[10:22:49.679]                             name <- restart$name
[10:22:49.679]                             if (is.null(name)) 
[10:22:49.679]                               next
[10:22:49.679]                             if (!grepl(pattern, name)) 
[10:22:49.679]                               next
[10:22:49.679]                             invokeRestart(restart)
[10:22:49.679]                             muffled <- TRUE
[10:22:49.679]                             break
[10:22:49.679]                           }
[10:22:49.679]                         }
[10:22:49.679]                       }
[10:22:49.679]                       invisible(muffled)
[10:22:49.679]                     }
[10:22:49.679]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.679]                   }
[10:22:49.679]                 }
[10:22:49.679]             }
[10:22:49.679]         }))
[10:22:49.679]     }, error = function(ex) {
[10:22:49.679]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.679]                 ...future.rng), started = ...future.startTime, 
[10:22:49.679]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.679]             version = "1.8"), class = "FutureResult")
[10:22:49.679]     }, finally = {
[10:22:49.679]         if (!identical(...future.workdir, getwd())) 
[10:22:49.679]             setwd(...future.workdir)
[10:22:49.679]         {
[10:22:49.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.679]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.679]             }
[10:22:49.679]             base::options(...future.oldOptions)
[10:22:49.679]             if (.Platform$OS.type == "windows") {
[10:22:49.679]                 old_names <- names(...future.oldEnvVars)
[10:22:49.679]                 envs <- base::Sys.getenv()
[10:22:49.679]                 names <- names(envs)
[10:22:49.679]                 common <- intersect(names, old_names)
[10:22:49.679]                 added <- setdiff(names, old_names)
[10:22:49.679]                 removed <- setdiff(old_names, names)
[10:22:49.679]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.679]                   envs[common]]
[10:22:49.679]                 NAMES <- toupper(changed)
[10:22:49.679]                 args <- list()
[10:22:49.679]                 for (kk in seq_along(NAMES)) {
[10:22:49.679]                   name <- changed[[kk]]
[10:22:49.679]                   NAME <- NAMES[[kk]]
[10:22:49.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.679]                     next
[10:22:49.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.679]                 }
[10:22:49.679]                 NAMES <- toupper(added)
[10:22:49.679]                 for (kk in seq_along(NAMES)) {
[10:22:49.679]                   name <- added[[kk]]
[10:22:49.679]                   NAME <- NAMES[[kk]]
[10:22:49.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.679]                     next
[10:22:49.679]                   args[[name]] <- ""
[10:22:49.679]                 }
[10:22:49.679]                 NAMES <- toupper(removed)
[10:22:49.679]                 for (kk in seq_along(NAMES)) {
[10:22:49.679]                   name <- removed[[kk]]
[10:22:49.679]                   NAME <- NAMES[[kk]]
[10:22:49.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.679]                     next
[10:22:49.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.679]                 }
[10:22:49.679]                 if (length(args) > 0) 
[10:22:49.679]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.679]             }
[10:22:49.679]             else {
[10:22:49.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.679]             }
[10:22:49.679]             {
[10:22:49.679]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.679]                   0L) {
[10:22:49.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.679]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.679]                   base::options(opts)
[10:22:49.679]                 }
[10:22:49.679]                 {
[10:22:49.679]                   {
[10:22:49.679]                     NULL
[10:22:49.679]                     RNGkind("Mersenne-Twister")
[10:22:49.679]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.679]                       inherits = FALSE)
[10:22:49.679]                   }
[10:22:49.679]                   options(future.plan = NULL)
[10:22:49.679]                   if (is.na(NA_character_)) 
[10:22:49.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.679]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:49.679]                   {
[10:22:49.679]                     future <- SequentialFuture(..., envir = envir)
[10:22:49.679]                     if (!future$lazy) 
[10:22:49.679]                       future <- run(future)
[10:22:49.679]                     invisible(future)
[10:22:49.679]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.679]                 }
[10:22:49.679]             }
[10:22:49.679]         }
[10:22:49.679]     })
[10:22:49.679]     if (TRUE) {
[10:22:49.679]         base::sink(type = "output", split = FALSE)
[10:22:49.679]         if (TRUE) {
[10:22:49.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.679]         }
[10:22:49.679]         else {
[10:22:49.679]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.679]         }
[10:22:49.679]         base::close(...future.stdout)
[10:22:49.679]         ...future.stdout <- NULL
[10:22:49.679]     }
[10:22:49.679]     ...future.result$conditions <- ...future.conditions
[10:22:49.679]     ...future.result$finished <- base::Sys.time()
[10:22:49.679]     ...future.result
[10:22:49.679] }
[10:22:49.680] assign_globals() ...
[10:22:49.681] List of 5
[10:22:49.681]  $ ...future.FUN            :function (object, ...)  
[10:22:49.681]  $ future.call.arguments    : list()
[10:22:49.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.681]  $ ...future.elements_ii    :List of 3
[10:22:49.681]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.681]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.681]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.681]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.681]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.681]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.681]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.681]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.681]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.681]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.681]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.681]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.681]  $ ...future.seeds_ii       : NULL
[10:22:49.681]  $ ...future.globals.maxSize: NULL
[10:22:49.681]  - attr(*, "where")=List of 5
[10:22:49.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.681]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.681]  - attr(*, "resolved")= logi FALSE
[10:22:49.681]  - attr(*, "total_size")= num 1240
[10:22:49.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.681]  - attr(*, "already-done")= logi TRUE
[10:22:49.688] - copied ‘...future.FUN’ to environment
[10:22:49.689] - copied ‘future.call.arguments’ to environment
[10:22:49.689] - copied ‘...future.elements_ii’ to environment
[10:22:49.689] - copied ‘...future.seeds_ii’ to environment
[10:22:49.689] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.689] assign_globals() ... done
[10:22:49.689] plan(): Setting new future strategy stack:
[10:22:49.689] List of future strategies:
[10:22:49.689] 1. sequential:
[10:22:49.689]    - args: function (..., envir = parent.frame())
[10:22:49.689]    - tweaked: FALSE
[10:22:49.689]    - call: NULL
[10:22:49.690] plan(): nbrOfWorkers() = 1
[10:22:49.692] plan(): Setting new future strategy stack:
[10:22:49.692] List of future strategies:
[10:22:49.692] 1. sequential:
[10:22:49.692]    - args: function (..., envir = parent.frame())
[10:22:49.692]    - tweaked: FALSE
[10:22:49.692]    - call: plan(strategy)
[10:22:49.692] plan(): nbrOfWorkers() = 1
[10:22:49.692] SequentialFuture started (and completed)
[10:22:49.692] - Launch lazy future ... done
[10:22:49.693] run() for ‘SequentialFuture’ ... done
[10:22:49.694] Created future:
[10:22:49.694] SequentialFuture:
[10:22:49.694] Label: ‘future_by-1’
[10:22:49.694] Expression:
[10:22:49.694] {
[10:22:49.694]     do.call(function(...) {
[10:22:49.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.694]             on.exit(options(oopts), add = TRUE)
[10:22:49.694]         }
[10:22:49.694]         {
[10:22:49.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.694]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.694]             })
[10:22:49.694]         }
[10:22:49.694]     }, args = future.call.arguments)
[10:22:49.694] }
[10:22:49.694] Lazy evaluation: FALSE
[10:22:49.694] Asynchronous evaluation: FALSE
[10:22:49.694] Local evaluation: TRUE
[10:22:49.694] Environment: 0x55f6387c0d28
[10:22:49.694] Capture standard output: TRUE
[10:22:49.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.694] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.694] Packages: <none>
[10:22:49.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.694] Resolved: TRUE
[10:22:49.694] Value: 5.37 KiB of class ‘list’
[10:22:49.694] Early signaling: FALSE
[10:22:49.694] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.694] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.695] Chunk #1 of 1 ... DONE
[10:22:49.695] Launching 1 futures (chunks) ... DONE
[10:22:49.695] Resolving 1 futures (chunks) ...
[10:22:49.695] resolve() on list ...
[10:22:49.696]  recursive: 0
[10:22:49.696]  length: 1
[10:22:49.696] 
[10:22:49.696] resolved() for ‘SequentialFuture’ ...
[10:22:49.696] - state: ‘finished’
[10:22:49.696] - run: TRUE
[10:22:49.696] - result: ‘FutureResult’
[10:22:49.696] resolved() for ‘SequentialFuture’ ... done
[10:22:49.696] Future #1
[10:22:49.696] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.697] - nx: 1
[10:22:49.697] - relay: TRUE
[10:22:49.697] - stdout: TRUE
[10:22:49.697] - signal: TRUE
[10:22:49.697] - resignal: FALSE
[10:22:49.697] - force: TRUE
[10:22:49.697] - relayed: [n=1] FALSE
[10:22:49.697] - queued futures: [n=1] FALSE
[10:22:49.697]  - until=1
[10:22:49.697]  - relaying element #1
[10:22:49.697] - relayed: [n=1] TRUE
[10:22:49.698] - queued futures: [n=1] TRUE
[10:22:49.698] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.698]  length: 0 (resolved future 1)
[10:22:49.698] Relaying remaining futures
[10:22:49.698] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.698] - nx: 1
[10:22:49.698] - relay: TRUE
[10:22:49.698] - stdout: TRUE
[10:22:49.698] - signal: TRUE
[10:22:49.698] - resignal: FALSE
[10:22:49.698] - force: TRUE
[10:22:49.698] - relayed: [n=1] TRUE
[10:22:49.699] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.699] - relayed: [n=1] TRUE
[10:22:49.699] - queued futures: [n=1] TRUE
[10:22:49.699] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.699] resolve() on list ... DONE
[10:22:49.699]  - Number of value chunks collected: 1
[10:22:49.699] Resolving 1 futures (chunks) ... DONE
[10:22:49.699] Reducing values from 1 chunks ...
[10:22:49.699]  - Number of values collected after concatenation: 3
[10:22:49.699]  - Number of values expected: 3
[10:22:49.700] Reducing values from 1 chunks ... DONE
[10:22:49.700] future_lapply() ... DONE
[10:22:49.700] future_by_internal() ... DONE
[10:22:49.701] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:22:49.701] future_lapply() ...
[10:22:49.701] Number of chunks: 1
[10:22:49.702] getGlobalsAndPackagesXApply() ...
[10:22:49.702]  - future.globals: TRUE
[10:22:49.702] getGlobalsAndPackages() ...
[10:22:49.702] Searching for globals...
[10:22:49.703] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.703] Searching for globals ... DONE
[10:22:49.703] Resolving globals: FALSE
[10:22:49.703] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.704] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.704] - globals: [1] ‘FUN’
[10:22:49.704] 
[10:22:49.704] getGlobalsAndPackages() ... DONE
[10:22:49.704]  - globals found/used: [n=1] ‘FUN’
[10:22:49.704]  - needed namespaces: [n=0] 
[10:22:49.704] Finding globals ... DONE
[10:22:49.704]  - use_args: TRUE
[10:22:49.704]  - Getting '...' globals ...
[10:22:49.705] resolve() on list ...
[10:22:49.705]  recursive: 0
[10:22:49.705]  length: 1
[10:22:49.705]  elements: ‘...’
[10:22:49.705]  length: 0 (resolved future 1)
[10:22:49.705] resolve() on list ... DONE
[10:22:49.705]    - '...' content: [n=0] 
[10:22:49.705] List of 1
[10:22:49.705]  $ ...: list()
[10:22:49.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.705]  - attr(*, "where")=List of 1
[10:22:49.705]   ..$ ...:<environment: 0x55f637b7f6e8> 
[10:22:49.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.705]  - attr(*, "resolved")= logi TRUE
[10:22:49.705]  - attr(*, "total_size")= num NA
[10:22:49.708]  - Getting '...' globals ... DONE
[10:22:49.708] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.708] List of 2
[10:22:49.708]  $ ...future.FUN:function (object, ...)  
[10:22:49.708]  $ ...          : list()
[10:22:49.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.708]  - attr(*, "where")=List of 2
[10:22:49.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.708]   ..$ ...          :<environment: 0x55f637b7f6e8> 
[10:22:49.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.708]  - attr(*, "resolved")= logi FALSE
[10:22:49.708]  - attr(*, "total_size")= num 1240
[10:22:49.710] Packages to be attached in all futures: [n=0] 
[10:22:49.710] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.712] Number of futures (= number of chunks): 1
[10:22:49.712] Launching 1 futures (chunks) ...
[10:22:49.712] Chunk #1 of 1 ...
[10:22:49.712]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.712] getGlobalsAndPackages() ...
[10:22:49.712] Searching for globals...
[10:22:49.713] 
[10:22:49.713] Searching for globals ... DONE
[10:22:49.713] - globals: [0] <none>
[10:22:49.713] getGlobalsAndPackages() ... DONE
[10:22:49.713]    + additional globals found: [n=0] 
[10:22:49.713]    + additional namespaces needed: [n=0] 
[10:22:49.713]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.713]  - seeds: <none>
[10:22:49.714]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.714] getGlobalsAndPackages() ...
[10:22:49.714] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.714] Resolving globals: FALSE
[10:22:49.714] Tweak future expression to call with '...' arguments ...
[10:22:49.714] {
[10:22:49.714]     do.call(function(...) {
[10:22:49.714]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.714]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.714]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.714]             on.exit(options(oopts), add = TRUE)
[10:22:49.714]         }
[10:22:49.714]         {
[10:22:49.714]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.714]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.714]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.714]             })
[10:22:49.714]         }
[10:22:49.714]     }, args = future.call.arguments)
[10:22:49.714] }
[10:22:49.714] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.715] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.715] 
[10:22:49.715] getGlobalsAndPackages() ... DONE
[10:22:49.715] run() for ‘Future’ ...
[10:22:49.715] - state: ‘created’
[10:22:49.715] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:49.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:49.716]   - Field: ‘label’
[10:22:49.716]   - Field: ‘local’
[10:22:49.716]   - Field: ‘owner’
[10:22:49.716]   - Field: ‘envir’
[10:22:49.716]   - Field: ‘packages’
[10:22:49.716]   - Field: ‘gc’
[10:22:49.716]   - Field: ‘conditions’
[10:22:49.717]   - Field: ‘expr’
[10:22:49.717]   - Field: ‘uuid’
[10:22:49.717]   - Field: ‘seed’
[10:22:49.717]   - Field: ‘version’
[10:22:49.717]   - Field: ‘result’
[10:22:49.717]   - Field: ‘asynchronous’
[10:22:49.717]   - Field: ‘calls’
[10:22:49.717]   - Field: ‘globals’
[10:22:49.717]   - Field: ‘stdout’
[10:22:49.717]   - Field: ‘earlySignal’
[10:22:49.717]   - Field: ‘lazy’
[10:22:49.718]   - Field: ‘state’
[10:22:49.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:49.718] - Launch lazy future ...
[10:22:49.718] Packages needed by the future expression (n = 0): <none>
[10:22:49.718] Packages needed by future strategies (n = 0): <none>
[10:22:49.718] {
[10:22:49.718]     {
[10:22:49.718]         {
[10:22:49.718]             ...future.startTime <- base::Sys.time()
[10:22:49.718]             {
[10:22:49.718]                 {
[10:22:49.718]                   {
[10:22:49.718]                     base::local({
[10:22:49.718]                       has_future <- base::requireNamespace("future", 
[10:22:49.718]                         quietly = TRUE)
[10:22:49.718]                       if (has_future) {
[10:22:49.718]                         ns <- base::getNamespace("future")
[10:22:49.718]                         version <- ns[[".package"]][["version"]]
[10:22:49.718]                         if (is.null(version)) 
[10:22:49.718]                           version <- utils::packageVersion("future")
[10:22:49.718]                       }
[10:22:49.718]                       else {
[10:22:49.718]                         version <- NULL
[10:22:49.718]                       }
[10:22:49.718]                       if (!has_future || version < "1.8.0") {
[10:22:49.718]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.718]                           "", base::R.version$version.string), 
[10:22:49.718]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:49.718]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.718]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.718]                             "release", "version")], collapse = " "), 
[10:22:49.718]                           hostname = base::Sys.info()[["nodename"]])
[10:22:49.718]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.718]                           info)
[10:22:49.718]                         info <- base::paste(info, collapse = "; ")
[10:22:49.718]                         if (!has_future) {
[10:22:49.718]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.718]                             info)
[10:22:49.718]                         }
[10:22:49.718]                         else {
[10:22:49.718]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.718]                             info, version)
[10:22:49.718]                         }
[10:22:49.718]                         base::stop(msg)
[10:22:49.718]                       }
[10:22:49.718]                     })
[10:22:49.718]                   }
[10:22:49.718]                   options(future.plan = NULL)
[10:22:49.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.718]                 }
[10:22:49.718]                 ...future.workdir <- getwd()
[10:22:49.718]             }
[10:22:49.718]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.718]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.718]         }
[10:22:49.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.718]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.718]             base::names(...future.oldOptions))
[10:22:49.718]     }
[10:22:49.718]     if (FALSE) {
[10:22:49.718]     }
[10:22:49.718]     else {
[10:22:49.718]         if (TRUE) {
[10:22:49.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.718]                 open = "w")
[10:22:49.718]         }
[10:22:49.718]         else {
[10:22:49.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.718]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.718]         }
[10:22:49.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.718]             base::sink(type = "output", split = FALSE)
[10:22:49.718]             base::close(...future.stdout)
[10:22:49.718]         }, add = TRUE)
[10:22:49.718]     }
[10:22:49.718]     ...future.frame <- base::sys.nframe()
[10:22:49.718]     ...future.conditions <- base::list()
[10:22:49.718]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.718]     if (FALSE) {
[10:22:49.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.718]     }
[10:22:49.718]     ...future.result <- base::tryCatch({
[10:22:49.718]         base::withCallingHandlers({
[10:22:49.718]             ...future.value <- base::withVisible(base::local({
[10:22:49.718]                 do.call(function(...) {
[10:22:49.718]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.718]                   if (!identical(...future.globals.maxSize.org, 
[10:22:49.718]                     ...future.globals.maxSize)) {
[10:22:49.718]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.718]                     on.exit(options(oopts), add = TRUE)
[10:22:49.718]                   }
[10:22:49.718]                   {
[10:22:49.718]                     lapply(seq_along(...future.elements_ii), 
[10:22:49.718]                       FUN = function(jj) {
[10:22:49.718]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.718]                         ...future.FUN(...future.X_jj, ...)
[10:22:49.718]                       })
[10:22:49.718]                   }
[10:22:49.718]                 }, args = future.call.arguments)
[10:22:49.718]             }))
[10:22:49.718]             future::FutureResult(value = ...future.value$value, 
[10:22:49.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.718]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.718]                     ...future.globalenv.names))
[10:22:49.718]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.718]         }, condition = base::local({
[10:22:49.718]             c <- base::c
[10:22:49.718]             inherits <- base::inherits
[10:22:49.718]             invokeRestart <- base::invokeRestart
[10:22:49.718]             length <- base::length
[10:22:49.718]             list <- base::list
[10:22:49.718]             seq.int <- base::seq.int
[10:22:49.718]             signalCondition <- base::signalCondition
[10:22:49.718]             sys.calls <- base::sys.calls
[10:22:49.718]             `[[` <- base::`[[`
[10:22:49.718]             `+` <- base::`+`
[10:22:49.718]             `<<-` <- base::`<<-`
[10:22:49.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.718]                   3L)]
[10:22:49.718]             }
[10:22:49.718]             function(cond) {
[10:22:49.718]                 is_error <- inherits(cond, "error")
[10:22:49.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.718]                   NULL)
[10:22:49.718]                 if (is_error) {
[10:22:49.718]                   sessionInformation <- function() {
[10:22:49.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.718]                       search = base::search(), system = base::Sys.info())
[10:22:49.718]                   }
[10:22:49.718]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.718]                     cond$call), session = sessionInformation(), 
[10:22:49.718]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.718]                   signalCondition(cond)
[10:22:49.718]                 }
[10:22:49.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.718]                 "immediateCondition"))) {
[10:22:49.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.718]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.718]                   if (TRUE && !signal) {
[10:22:49.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.718]                     {
[10:22:49.718]                       inherits <- base::inherits
[10:22:49.718]                       invokeRestart <- base::invokeRestart
[10:22:49.718]                       is.null <- base::is.null
[10:22:49.718]                       muffled <- FALSE
[10:22:49.718]                       if (inherits(cond, "message")) {
[10:22:49.718]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.718]                         if (muffled) 
[10:22:49.718]                           invokeRestart("muffleMessage")
[10:22:49.718]                       }
[10:22:49.718]                       else if (inherits(cond, "warning")) {
[10:22:49.718]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.718]                         if (muffled) 
[10:22:49.718]                           invokeRestart("muffleWarning")
[10:22:49.718]                       }
[10:22:49.718]                       else if (inherits(cond, "condition")) {
[10:22:49.718]                         if (!is.null(pattern)) {
[10:22:49.718]                           computeRestarts <- base::computeRestarts
[10:22:49.718]                           grepl <- base::grepl
[10:22:49.718]                           restarts <- computeRestarts(cond)
[10:22:49.718]                           for (restart in restarts) {
[10:22:49.718]                             name <- restart$name
[10:22:49.718]                             if (is.null(name)) 
[10:22:49.718]                               next
[10:22:49.718]                             if (!grepl(pattern, name)) 
[10:22:49.718]                               next
[10:22:49.718]                             invokeRestart(restart)
[10:22:49.718]                             muffled <- TRUE
[10:22:49.718]                             break
[10:22:49.718]                           }
[10:22:49.718]                         }
[10:22:49.718]                       }
[10:22:49.718]                       invisible(muffled)
[10:22:49.718]                     }
[10:22:49.718]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.718]                   }
[10:22:49.718]                 }
[10:22:49.718]                 else {
[10:22:49.718]                   if (TRUE) {
[10:22:49.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.718]                     {
[10:22:49.718]                       inherits <- base::inherits
[10:22:49.718]                       invokeRestart <- base::invokeRestart
[10:22:49.718]                       is.null <- base::is.null
[10:22:49.718]                       muffled <- FALSE
[10:22:49.718]                       if (inherits(cond, "message")) {
[10:22:49.718]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.718]                         if (muffled) 
[10:22:49.718]                           invokeRestart("muffleMessage")
[10:22:49.718]                       }
[10:22:49.718]                       else if (inherits(cond, "warning")) {
[10:22:49.718]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.718]                         if (muffled) 
[10:22:49.718]                           invokeRestart("muffleWarning")
[10:22:49.718]                       }
[10:22:49.718]                       else if (inherits(cond, "condition")) {
[10:22:49.718]                         if (!is.null(pattern)) {
[10:22:49.718]                           computeRestarts <- base::computeRestarts
[10:22:49.718]                           grepl <- base::grepl
[10:22:49.718]                           restarts <- computeRestarts(cond)
[10:22:49.718]                           for (restart in restarts) {
[10:22:49.718]                             name <- restart$name
[10:22:49.718]                             if (is.null(name)) 
[10:22:49.718]                               next
[10:22:49.718]                             if (!grepl(pattern, name)) 
[10:22:49.718]                               next
[10:22:49.718]                             invokeRestart(restart)
[10:22:49.718]                             muffled <- TRUE
[10:22:49.718]                             break
[10:22:49.718]                           }
[10:22:49.718]                         }
[10:22:49.718]                       }
[10:22:49.718]                       invisible(muffled)
[10:22:49.718]                     }
[10:22:49.718]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.718]                   }
[10:22:49.718]                 }
[10:22:49.718]             }
[10:22:49.718]         }))
[10:22:49.718]     }, error = function(ex) {
[10:22:49.718]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.718]                 ...future.rng), started = ...future.startTime, 
[10:22:49.718]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.718]             version = "1.8"), class = "FutureResult")
[10:22:49.718]     }, finally = {
[10:22:49.718]         if (!identical(...future.workdir, getwd())) 
[10:22:49.718]             setwd(...future.workdir)
[10:22:49.718]         {
[10:22:49.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.718]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.718]             }
[10:22:49.718]             base::options(...future.oldOptions)
[10:22:49.718]             if (.Platform$OS.type == "windows") {
[10:22:49.718]                 old_names <- names(...future.oldEnvVars)
[10:22:49.718]                 envs <- base::Sys.getenv()
[10:22:49.718]                 names <- names(envs)
[10:22:49.718]                 common <- intersect(names, old_names)
[10:22:49.718]                 added <- setdiff(names, old_names)
[10:22:49.718]                 removed <- setdiff(old_names, names)
[10:22:49.718]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.718]                   envs[common]]
[10:22:49.718]                 NAMES <- toupper(changed)
[10:22:49.718]                 args <- list()
[10:22:49.718]                 for (kk in seq_along(NAMES)) {
[10:22:49.718]                   name <- changed[[kk]]
[10:22:49.718]                   NAME <- NAMES[[kk]]
[10:22:49.718]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.718]                     next
[10:22:49.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.718]                 }
[10:22:49.718]                 NAMES <- toupper(added)
[10:22:49.718]                 for (kk in seq_along(NAMES)) {
[10:22:49.718]                   name <- added[[kk]]
[10:22:49.718]                   NAME <- NAMES[[kk]]
[10:22:49.718]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.718]                     next
[10:22:49.718]                   args[[name]] <- ""
[10:22:49.718]                 }
[10:22:49.718]                 NAMES <- toupper(removed)
[10:22:49.718]                 for (kk in seq_along(NAMES)) {
[10:22:49.718]                   name <- removed[[kk]]
[10:22:49.718]                   NAME <- NAMES[[kk]]
[10:22:49.718]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.718]                     next
[10:22:49.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.718]                 }
[10:22:49.718]                 if (length(args) > 0) 
[10:22:49.718]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.718]             }
[10:22:49.718]             else {
[10:22:49.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.718]             }
[10:22:49.718]             {
[10:22:49.718]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.718]                   0L) {
[10:22:49.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.718]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.718]                   base::options(opts)
[10:22:49.718]                 }
[10:22:49.718]                 {
[10:22:49.718]                   {
[10:22:49.718]                     NULL
[10:22:49.718]                     RNGkind("Mersenne-Twister")
[10:22:49.718]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:49.718]                       inherits = FALSE)
[10:22:49.718]                   }
[10:22:49.718]                   options(future.plan = NULL)
[10:22:49.718]                   if (is.na(NA_character_)) 
[10:22:49.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.718]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:49.718]                   {
[10:22:49.718]                     future <- SequentialFuture(..., envir = envir)
[10:22:49.718]                     if (!future$lazy) 
[10:22:49.718]                       future <- run(future)
[10:22:49.718]                     invisible(future)
[10:22:49.718]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.718]                 }
[10:22:49.718]             }
[10:22:49.718]         }
[10:22:49.718]     })
[10:22:49.718]     if (TRUE) {
[10:22:49.718]         base::sink(type = "output", split = FALSE)
[10:22:49.718]         if (TRUE) {
[10:22:49.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.718]         }
[10:22:49.718]         else {
[10:22:49.718]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.718]         }
[10:22:49.718]         base::close(...future.stdout)
[10:22:49.718]         ...future.stdout <- NULL
[10:22:49.718]     }
[10:22:49.718]     ...future.result$conditions <- ...future.conditions
[10:22:49.718]     ...future.result$finished <- base::Sys.time()
[10:22:49.718]     ...future.result
[10:22:49.718] }
[10:22:49.720] assign_globals() ...
[10:22:49.720] List of 5
[10:22:49.720]  $ ...future.FUN            :function (object, ...)  
[10:22:49.720]  $ future.call.arguments    : list()
[10:22:49.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.720]  $ ...future.elements_ii    :List of 3
[10:22:49.720]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.720]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.720]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.720]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:49.720]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.720]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.720]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.720]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:49.720]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:49.720]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.720]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.720]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:49.720]  $ ...future.seeds_ii       : NULL
[10:22:49.720]  $ ...future.globals.maxSize: NULL
[10:22:49.720]  - attr(*, "where")=List of 5
[10:22:49.720]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.720]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.720]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.720]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.720]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.720]  - attr(*, "resolved")= logi FALSE
[10:22:49.720]  - attr(*, "total_size")= num 1240
[10:22:49.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.720]  - attr(*, "already-done")= logi TRUE
[10:22:49.728] - copied ‘...future.FUN’ to environment
[10:22:49.728] - copied ‘future.call.arguments’ to environment
[10:22:49.729] - copied ‘...future.elements_ii’ to environment
[10:22:49.729] - copied ‘...future.seeds_ii’ to environment
[10:22:49.729] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.729] assign_globals() ... done
[10:22:49.729] plan(): Setting new future strategy stack:
[10:22:49.729] List of future strategies:
[10:22:49.729] 1. sequential:
[10:22:49.729]    - args: function (..., envir = parent.frame())
[10:22:49.729]    - tweaked: FALSE
[10:22:49.729]    - call: NULL
[10:22:49.729] plan(): nbrOfWorkers() = 1
[10:22:49.733] plan(): Setting new future strategy stack:
[10:22:49.733] List of future strategies:
[10:22:49.733] 1. sequential:
[10:22:49.733]    - args: function (..., envir = parent.frame())
[10:22:49.733]    - tweaked: FALSE
[10:22:49.733]    - call: plan(strategy)
[10:22:49.733] plan(): nbrOfWorkers() = 1
[10:22:49.733] SequentialFuture started (and completed)
[10:22:49.734] - Launch lazy future ... done
[10:22:49.734] run() for ‘SequentialFuture’ ... done
[10:22:49.734] Created future:
[10:22:49.734] SequentialFuture:
[10:22:49.734] Label: ‘future_by-1’
[10:22:49.734] Expression:
[10:22:49.734] {
[10:22:49.734]     do.call(function(...) {
[10:22:49.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.734]             on.exit(options(oopts), add = TRUE)
[10:22:49.734]         }
[10:22:49.734]         {
[10:22:49.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.734]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.734]             })
[10:22:49.734]         }
[10:22:49.734]     }, args = future.call.arguments)
[10:22:49.734] }
[10:22:49.734] Lazy evaluation: FALSE
[10:22:49.734] Asynchronous evaluation: FALSE
[10:22:49.734] Local evaluation: TRUE
[10:22:49.734] Environment: 0x55f6382a06c0
[10:22:49.734] Capture standard output: TRUE
[10:22:49.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.734] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.734] Packages: <none>
[10:22:49.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.734] Resolved: TRUE
[10:22:49.734] Value: 5.37 KiB of class ‘list’
[10:22:49.734] Early signaling: FALSE
[10:22:49.734] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.734] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:49.735] Chunk #1 of 1 ... DONE
[10:22:49.735] Launching 1 futures (chunks) ... DONE
[10:22:49.735] Resolving 1 futures (chunks) ...
[10:22:49.735] resolve() on list ...
[10:22:49.735]  recursive: 0
[10:22:49.736]  length: 1
[10:22:49.736] 
[10:22:49.736] resolved() for ‘SequentialFuture’ ...
[10:22:49.736] - state: ‘finished’
[10:22:49.736] - run: TRUE
[10:22:49.736] - result: ‘FutureResult’
[10:22:49.736] resolved() for ‘SequentialFuture’ ... done
[10:22:49.736] Future #1
[10:22:49.736] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:49.736] - nx: 1
[10:22:49.737] - relay: TRUE
[10:22:49.737] - stdout: TRUE
[10:22:49.737] - signal: TRUE
[10:22:49.737] - resignal: FALSE
[10:22:49.737] - force: TRUE
[10:22:49.737] - relayed: [n=1] FALSE
[10:22:49.737] - queued futures: [n=1] FALSE
[10:22:49.737]  - until=1
[10:22:49.737]  - relaying element #1
[10:22:49.737] - relayed: [n=1] TRUE
[10:22:49.737] - queued futures: [n=1] TRUE
[10:22:49.738] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:49.738]  length: 0 (resolved future 1)
[10:22:49.738] Relaying remaining futures
[10:22:49.738] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.738] - nx: 1
[10:22:49.738] - relay: TRUE
[10:22:49.738] - stdout: TRUE
[10:22:49.738] - signal: TRUE
[10:22:49.738] - resignal: FALSE
[10:22:49.738] - force: TRUE
[10:22:49.738] - relayed: [n=1] TRUE
[10:22:49.738] - queued futures: [n=1] TRUE
 - flush all
[10:22:49.739] - relayed: [n=1] TRUE
[10:22:49.739] - queued futures: [n=1] TRUE
[10:22:49.739] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.739] resolve() on list ... DONE
[10:22:49.739]  - Number of value chunks collected: 1
[10:22:49.739] Resolving 1 futures (chunks) ... DONE
[10:22:49.739] Reducing values from 1 chunks ...
[10:22:49.739]  - Number of values collected after concatenation: 3
[10:22:49.739]  - Number of values expected: 3
[10:22:49.739] Reducing values from 1 chunks ... DONE
[10:22:49.739] future_lapply() ... DONE
[10:22:49.740] future_by_internal() ... DONE
[10:22:49.740] future_by_internal() ...
- plan('multicore') ...
[10:22:49.741] plan(): Setting new future strategy stack:
[10:22:49.741] List of future strategies:
[10:22:49.741] 1. multicore:
[10:22:49.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.741]    - tweaked: FALSE
[10:22:49.741]    - call: plan(strategy)
[10:22:49.745] plan(): nbrOfWorkers() = 2
[10:22:49.745] future_by_internal() ...
[10:22:49.745] future_lapply() ...
[10:22:49.749] Number of chunks: 2
[10:22:49.749] getGlobalsAndPackagesXApply() ...
[10:22:49.750]  - future.globals: TRUE
[10:22:49.750] getGlobalsAndPackages() ...
[10:22:49.750] Searching for globals...
[10:22:49.751] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.751] Searching for globals ... DONE
[10:22:49.751] Resolving globals: FALSE
[10:22:49.751] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.752] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.752] - globals: [1] ‘FUN’
[10:22:49.752] 
[10:22:49.752] getGlobalsAndPackages() ... DONE
[10:22:49.752]  - globals found/used: [n=1] ‘FUN’
[10:22:49.752]  - needed namespaces: [n=0] 
[10:22:49.752] Finding globals ... DONE
[10:22:49.752]  - use_args: TRUE
[10:22:49.752]  - Getting '...' globals ...
[10:22:49.753] resolve() on list ...
[10:22:49.753]  recursive: 0
[10:22:49.753]  length: 1
[10:22:49.753]  elements: ‘...’
[10:22:49.753]  length: 0 (resolved future 1)
[10:22:49.753] resolve() on list ... DONE
[10:22:49.753]    - '...' content: [n=0] 
[10:22:49.753] List of 1
[10:22:49.753]  $ ...: list()
[10:22:49.753]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.753]  - attr(*, "where")=List of 1
[10:22:49.753]   ..$ ...:<environment: 0x55f639a81ae8> 
[10:22:49.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.753]  - attr(*, "resolved")= logi TRUE
[10:22:49.753]  - attr(*, "total_size")= num NA
[10:22:49.757]  - Getting '...' globals ... DONE
[10:22:49.757] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.758] List of 2
[10:22:49.758]  $ ...future.FUN:function (object, ...)  
[10:22:49.758]  $ ...          : list()
[10:22:49.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.758]  - attr(*, "where")=List of 2
[10:22:49.758]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.758]   ..$ ...          :<environment: 0x55f639a81ae8> 
[10:22:49.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.758]  - attr(*, "resolved")= logi FALSE
[10:22:49.758]  - attr(*, "total_size")= num 1240
[10:22:49.760] Packages to be attached in all futures: [n=0] 
[10:22:49.760] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.760] Number of futures (= number of chunks): 2
[10:22:49.761] Launching 2 futures (chunks) ...
[10:22:49.761] Chunk #1 of 2 ...
[10:22:49.761]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.761] getGlobalsAndPackages() ...
[10:22:49.761] Searching for globals...
[10:22:49.761] 
[10:22:49.761] Searching for globals ... DONE
[10:22:49.762] - globals: [0] <none>
[10:22:49.762] getGlobalsAndPackages() ... DONE
[10:22:49.762]    + additional globals found: [n=0] 
[10:22:49.762]    + additional namespaces needed: [n=0] 
[10:22:49.762]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.762]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:49.762]  - seeds: <none>
[10:22:49.762]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.762] getGlobalsAndPackages() ...
[10:22:49.762] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.762] Resolving globals: FALSE
[10:22:49.763] Tweak future expression to call with '...' arguments ...
[10:22:49.763] {
[10:22:49.763]     do.call(function(...) {
[10:22:49.763]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.763]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.763]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.763]             on.exit(options(oopts), add = TRUE)
[10:22:49.763]         }
[10:22:49.763]         {
[10:22:49.763]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.763]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.763]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.763]             })
[10:22:49.763]         }
[10:22:49.763]     }, args = future.call.arguments)
[10:22:49.763] }
[10:22:49.763] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.763] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.763] 
[10:22:49.763] getGlobalsAndPackages() ... DONE
[10:22:49.764] run() for ‘Future’ ...
[10:22:49.764] - state: ‘created’
[10:22:49.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.768] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:49.768]   - Field: ‘label’
[10:22:49.768]   - Field: ‘local’
[10:22:49.768]   - Field: ‘owner’
[10:22:49.768]   - Field: ‘envir’
[10:22:49.768]   - Field: ‘workers’
[10:22:49.768]   - Field: ‘packages’
[10:22:49.768]   - Field: ‘gc’
[10:22:49.768]   - Field: ‘job’
[10:22:49.769]   - Field: ‘conditions’
[10:22:49.769]   - Field: ‘expr’
[10:22:49.769]   - Field: ‘uuid’
[10:22:49.769]   - Field: ‘seed’
[10:22:49.769]   - Field: ‘version’
[10:22:49.769]   - Field: ‘result’
[10:22:49.769]   - Field: ‘asynchronous’
[10:22:49.769]   - Field: ‘calls’
[10:22:49.769]   - Field: ‘globals’
[10:22:49.769]   - Field: ‘stdout’
[10:22:49.770]   - Field: ‘earlySignal’
[10:22:49.770]   - Field: ‘lazy’
[10:22:49.770]   - Field: ‘state’
[10:22:49.770] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:49.770] - Launch lazy future ...
[10:22:49.771] Packages needed by the future expression (n = 0): <none>
[10:22:49.771] Packages needed by future strategies (n = 0): <none>
[10:22:49.771] {
[10:22:49.771]     {
[10:22:49.771]         {
[10:22:49.771]             ...future.startTime <- base::Sys.time()
[10:22:49.771]             {
[10:22:49.771]                 {
[10:22:49.771]                   {
[10:22:49.771]                     {
[10:22:49.771]                       base::local({
[10:22:49.771]                         has_future <- base::requireNamespace("future", 
[10:22:49.771]                           quietly = TRUE)
[10:22:49.771]                         if (has_future) {
[10:22:49.771]                           ns <- base::getNamespace("future")
[10:22:49.771]                           version <- ns[[".package"]][["version"]]
[10:22:49.771]                           if (is.null(version)) 
[10:22:49.771]                             version <- utils::packageVersion("future")
[10:22:49.771]                         }
[10:22:49.771]                         else {
[10:22:49.771]                           version <- NULL
[10:22:49.771]                         }
[10:22:49.771]                         if (!has_future || version < "1.8.0") {
[10:22:49.771]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.771]                             "", base::R.version$version.string), 
[10:22:49.771]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.771]                               "release", "version")], collapse = " "), 
[10:22:49.771]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.771]                             info)
[10:22:49.771]                           info <- base::paste(info, collapse = "; ")
[10:22:49.771]                           if (!has_future) {
[10:22:49.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.771]                               info)
[10:22:49.771]                           }
[10:22:49.771]                           else {
[10:22:49.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.771]                               info, version)
[10:22:49.771]                           }
[10:22:49.771]                           base::stop(msg)
[10:22:49.771]                         }
[10:22:49.771]                       })
[10:22:49.771]                     }
[10:22:49.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.771]                     base::options(mc.cores = 1L)
[10:22:49.771]                   }
[10:22:49.771]                   options(future.plan = NULL)
[10:22:49.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.771]                 }
[10:22:49.771]                 ...future.workdir <- getwd()
[10:22:49.771]             }
[10:22:49.771]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.771]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.771]         }
[10:22:49.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.771]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:49.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.771]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.771]             base::names(...future.oldOptions))
[10:22:49.771]     }
[10:22:49.771]     if (FALSE) {
[10:22:49.771]     }
[10:22:49.771]     else {
[10:22:49.771]         if (TRUE) {
[10:22:49.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.771]                 open = "w")
[10:22:49.771]         }
[10:22:49.771]         else {
[10:22:49.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.771]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.771]         }
[10:22:49.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.771]             base::sink(type = "output", split = FALSE)
[10:22:49.771]             base::close(...future.stdout)
[10:22:49.771]         }, add = TRUE)
[10:22:49.771]     }
[10:22:49.771]     ...future.frame <- base::sys.nframe()
[10:22:49.771]     ...future.conditions <- base::list()
[10:22:49.771]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.771]     if (FALSE) {
[10:22:49.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.771]     }
[10:22:49.771]     ...future.result <- base::tryCatch({
[10:22:49.771]         base::withCallingHandlers({
[10:22:49.771]             ...future.value <- base::withVisible(base::local({
[10:22:49.771]                 withCallingHandlers({
[10:22:49.771]                   {
[10:22:49.771]                     do.call(function(...) {
[10:22:49.771]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.771]                       if (!identical(...future.globals.maxSize.org, 
[10:22:49.771]                         ...future.globals.maxSize)) {
[10:22:49.771]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.771]                         on.exit(options(oopts), add = TRUE)
[10:22:49.771]                       }
[10:22:49.771]                       {
[10:22:49.771]                         lapply(seq_along(...future.elements_ii), 
[10:22:49.771]                           FUN = function(jj) {
[10:22:49.771]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.771]                             ...future.FUN(...future.X_jj, ...)
[10:22:49.771]                           })
[10:22:49.771]                       }
[10:22:49.771]                     }, args = future.call.arguments)
[10:22:49.771]                   }
[10:22:49.771]                 }, immediateCondition = function(cond) {
[10:22:49.771]                   save_rds <- function (object, pathname, ...) 
[10:22:49.771]                   {
[10:22:49.771]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:49.771]                     if (file_test("-f", pathname_tmp)) {
[10:22:49.771]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.771]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:49.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.771]                         fi_tmp[["mtime"]])
[10:22:49.771]                     }
[10:22:49.771]                     tryCatch({
[10:22:49.771]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:49.771]                     }, error = function(ex) {
[10:22:49.771]                       msg <- conditionMessage(ex)
[10:22:49.771]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.771]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:49.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.771]                         fi_tmp[["mtime"]], msg)
[10:22:49.771]                       ex$message <- msg
[10:22:49.771]                       stop(ex)
[10:22:49.771]                     })
[10:22:49.771]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:49.771]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:49.771]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:49.771]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.771]                       fi <- file.info(pathname)
[10:22:49.771]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:49.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.771]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:49.771]                         fi[["size"]], fi[["mtime"]])
[10:22:49.771]                       stop(msg)
[10:22:49.771]                     }
[10:22:49.771]                     invisible(pathname)
[10:22:49.771]                   }
[10:22:49.771]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:49.771]                     rootPath = tempdir()) 
[10:22:49.771]                   {
[10:22:49.771]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:49.771]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:49.771]                       tmpdir = path, fileext = ".rds")
[10:22:49.771]                     save_rds(obj, file)
[10:22:49.771]                   }
[10:22:49.771]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:49.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.771]                   {
[10:22:49.771]                     inherits <- base::inherits
[10:22:49.771]                     invokeRestart <- base::invokeRestart
[10:22:49.771]                     is.null <- base::is.null
[10:22:49.771]                     muffled <- FALSE
[10:22:49.771]                     if (inherits(cond, "message")) {
[10:22:49.771]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.771]                       if (muffled) 
[10:22:49.771]                         invokeRestart("muffleMessage")
[10:22:49.771]                     }
[10:22:49.771]                     else if (inherits(cond, "warning")) {
[10:22:49.771]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.771]                       if (muffled) 
[10:22:49.771]                         invokeRestart("muffleWarning")
[10:22:49.771]                     }
[10:22:49.771]                     else if (inherits(cond, "condition")) {
[10:22:49.771]                       if (!is.null(pattern)) {
[10:22:49.771]                         computeRestarts <- base::computeRestarts
[10:22:49.771]                         grepl <- base::grepl
[10:22:49.771]                         restarts <- computeRestarts(cond)
[10:22:49.771]                         for (restart in restarts) {
[10:22:49.771]                           name <- restart$name
[10:22:49.771]                           if (is.null(name)) 
[10:22:49.771]                             next
[10:22:49.771]                           if (!grepl(pattern, name)) 
[10:22:49.771]                             next
[10:22:49.771]                           invokeRestart(restart)
[10:22:49.771]                           muffled <- TRUE
[10:22:49.771]                           break
[10:22:49.771]                         }
[10:22:49.771]                       }
[10:22:49.771]                     }
[10:22:49.771]                     invisible(muffled)
[10:22:49.771]                   }
[10:22:49.771]                   muffleCondition(cond)
[10:22:49.771]                 })
[10:22:49.771]             }))
[10:22:49.771]             future::FutureResult(value = ...future.value$value, 
[10:22:49.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.771]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.771]                     ...future.globalenv.names))
[10:22:49.771]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.771]         }, condition = base::local({
[10:22:49.771]             c <- base::c
[10:22:49.771]             inherits <- base::inherits
[10:22:49.771]             invokeRestart <- base::invokeRestart
[10:22:49.771]             length <- base::length
[10:22:49.771]             list <- base::list
[10:22:49.771]             seq.int <- base::seq.int
[10:22:49.771]             signalCondition <- base::signalCondition
[10:22:49.771]             sys.calls <- base::sys.calls
[10:22:49.771]             `[[` <- base::`[[`
[10:22:49.771]             `+` <- base::`+`
[10:22:49.771]             `<<-` <- base::`<<-`
[10:22:49.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.771]                   3L)]
[10:22:49.771]             }
[10:22:49.771]             function(cond) {
[10:22:49.771]                 is_error <- inherits(cond, "error")
[10:22:49.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.771]                   NULL)
[10:22:49.771]                 if (is_error) {
[10:22:49.771]                   sessionInformation <- function() {
[10:22:49.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.771]                       search = base::search(), system = base::Sys.info())
[10:22:49.771]                   }
[10:22:49.771]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.771]                     cond$call), session = sessionInformation(), 
[10:22:49.771]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.771]                   signalCondition(cond)
[10:22:49.771]                 }
[10:22:49.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.771]                 "immediateCondition"))) {
[10:22:49.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.771]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.771]                   if (TRUE && !signal) {
[10:22:49.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.771]                     {
[10:22:49.771]                       inherits <- base::inherits
[10:22:49.771]                       invokeRestart <- base::invokeRestart
[10:22:49.771]                       is.null <- base::is.null
[10:22:49.771]                       muffled <- FALSE
[10:22:49.771]                       if (inherits(cond, "message")) {
[10:22:49.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.771]                         if (muffled) 
[10:22:49.771]                           invokeRestart("muffleMessage")
[10:22:49.771]                       }
[10:22:49.771]                       else if (inherits(cond, "warning")) {
[10:22:49.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.771]                         if (muffled) 
[10:22:49.771]                           invokeRestart("muffleWarning")
[10:22:49.771]                       }
[10:22:49.771]                       else if (inherits(cond, "condition")) {
[10:22:49.771]                         if (!is.null(pattern)) {
[10:22:49.771]                           computeRestarts <- base::computeRestarts
[10:22:49.771]                           grepl <- base::grepl
[10:22:49.771]                           restarts <- computeRestarts(cond)
[10:22:49.771]                           for (restart in restarts) {
[10:22:49.771]                             name <- restart$name
[10:22:49.771]                             if (is.null(name)) 
[10:22:49.771]                               next
[10:22:49.771]                             if (!grepl(pattern, name)) 
[10:22:49.771]                               next
[10:22:49.771]                             invokeRestart(restart)
[10:22:49.771]                             muffled <- TRUE
[10:22:49.771]                             break
[10:22:49.771]                           }
[10:22:49.771]                         }
[10:22:49.771]                       }
[10:22:49.771]                       invisible(muffled)
[10:22:49.771]                     }
[10:22:49.771]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.771]                   }
[10:22:49.771]                 }
[10:22:49.771]                 else {
[10:22:49.771]                   if (TRUE) {
[10:22:49.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.771]                     {
[10:22:49.771]                       inherits <- base::inherits
[10:22:49.771]                       invokeRestart <- base::invokeRestart
[10:22:49.771]                       is.null <- base::is.null
[10:22:49.771]                       muffled <- FALSE
[10:22:49.771]                       if (inherits(cond, "message")) {
[10:22:49.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.771]                         if (muffled) 
[10:22:49.771]                           invokeRestart("muffleMessage")
[10:22:49.771]                       }
[10:22:49.771]                       else if (inherits(cond, "warning")) {
[10:22:49.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.771]                         if (muffled) 
[10:22:49.771]                           invokeRestart("muffleWarning")
[10:22:49.771]                       }
[10:22:49.771]                       else if (inherits(cond, "condition")) {
[10:22:49.771]                         if (!is.null(pattern)) {
[10:22:49.771]                           computeRestarts <- base::computeRestarts
[10:22:49.771]                           grepl <- base::grepl
[10:22:49.771]                           restarts <- computeRestarts(cond)
[10:22:49.771]                           for (restart in restarts) {
[10:22:49.771]                             name <- restart$name
[10:22:49.771]                             if (is.null(name)) 
[10:22:49.771]                               next
[10:22:49.771]                             if (!grepl(pattern, name)) 
[10:22:49.771]                               next
[10:22:49.771]                             invokeRestart(restart)
[10:22:49.771]                             muffled <- TRUE
[10:22:49.771]                             break
[10:22:49.771]                           }
[10:22:49.771]                         }
[10:22:49.771]                       }
[10:22:49.771]                       invisible(muffled)
[10:22:49.771]                     }
[10:22:49.771]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.771]                   }
[10:22:49.771]                 }
[10:22:49.771]             }
[10:22:49.771]         }))
[10:22:49.771]     }, error = function(ex) {
[10:22:49.771]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.771]                 ...future.rng), started = ...future.startTime, 
[10:22:49.771]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.771]             version = "1.8"), class = "FutureResult")
[10:22:49.771]     }, finally = {
[10:22:49.771]         if (!identical(...future.workdir, getwd())) 
[10:22:49.771]             setwd(...future.workdir)
[10:22:49.771]         {
[10:22:49.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.771]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.771]             }
[10:22:49.771]             base::options(...future.oldOptions)
[10:22:49.771]             if (.Platform$OS.type == "windows") {
[10:22:49.771]                 old_names <- names(...future.oldEnvVars)
[10:22:49.771]                 envs <- base::Sys.getenv()
[10:22:49.771]                 names <- names(envs)
[10:22:49.771]                 common <- intersect(names, old_names)
[10:22:49.771]                 added <- setdiff(names, old_names)
[10:22:49.771]                 removed <- setdiff(old_names, names)
[10:22:49.771]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.771]                   envs[common]]
[10:22:49.771]                 NAMES <- toupper(changed)
[10:22:49.771]                 args <- list()
[10:22:49.771]                 for (kk in seq_along(NAMES)) {
[10:22:49.771]                   name <- changed[[kk]]
[10:22:49.771]                   NAME <- NAMES[[kk]]
[10:22:49.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.771]                     next
[10:22:49.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.771]                 }
[10:22:49.771]                 NAMES <- toupper(added)
[10:22:49.771]                 for (kk in seq_along(NAMES)) {
[10:22:49.771]                   name <- added[[kk]]
[10:22:49.771]                   NAME <- NAMES[[kk]]
[10:22:49.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.771]                     next
[10:22:49.771]                   args[[name]] <- ""
[10:22:49.771]                 }
[10:22:49.771]                 NAMES <- toupper(removed)
[10:22:49.771]                 for (kk in seq_along(NAMES)) {
[10:22:49.771]                   name <- removed[[kk]]
[10:22:49.771]                   NAME <- NAMES[[kk]]
[10:22:49.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.771]                     next
[10:22:49.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.771]                 }
[10:22:49.771]                 if (length(args) > 0) 
[10:22:49.771]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.771]             }
[10:22:49.771]             else {
[10:22:49.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.771]             }
[10:22:49.771]             {
[10:22:49.771]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.771]                   0L) {
[10:22:49.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.771]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.771]                   base::options(opts)
[10:22:49.771]                 }
[10:22:49.771]                 {
[10:22:49.771]                   {
[10:22:49.771]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.771]                     NULL
[10:22:49.771]                   }
[10:22:49.771]                   options(future.plan = NULL)
[10:22:49.771]                   if (is.na(NA_character_)) 
[10:22:49.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.771]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.771]                     envir = parent.frame()) 
[10:22:49.771]                   {
[10:22:49.771]                     default_workers <- missing(workers)
[10:22:49.771]                     if (is.function(workers)) 
[10:22:49.771]                       workers <- workers()
[10:22:49.771]                     workers <- structure(as.integer(workers), 
[10:22:49.771]                       class = class(workers))
[10:22:49.771]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.771]                       1L)
[10:22:49.771]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.771]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.771]                       if (default_workers) 
[10:22:49.771]                         supportsMulticore(warn = TRUE)
[10:22:49.771]                       return(sequential(..., envir = envir))
[10:22:49.771]                     }
[10:22:49.771]                     oopts <- options(mc.cores = workers)
[10:22:49.771]                     on.exit(options(oopts))
[10:22:49.771]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.771]                       envir = envir)
[10:22:49.771]                     if (!future$lazy) 
[10:22:49.771]                       future <- run(future)
[10:22:49.771]                     invisible(future)
[10:22:49.771]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.771]                 }
[10:22:49.771]             }
[10:22:49.771]         }
[10:22:49.771]     })
[10:22:49.771]     if (TRUE) {
[10:22:49.771]         base::sink(type = "output", split = FALSE)
[10:22:49.771]         if (TRUE) {
[10:22:49.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.771]         }
[10:22:49.771]         else {
[10:22:49.771]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.771]         }
[10:22:49.771]         base::close(...future.stdout)
[10:22:49.771]         ...future.stdout <- NULL
[10:22:49.771]     }
[10:22:49.771]     ...future.result$conditions <- ...future.conditions
[10:22:49.771]     ...future.result$finished <- base::Sys.time()
[10:22:49.771]     ...future.result
[10:22:49.771] }
[10:22:49.774] assign_globals() ...
[10:22:49.774] List of 5
[10:22:49.774]  $ ...future.FUN            :function (object, ...)  
[10:22:49.774]  $ future.call.arguments    : list()
[10:22:49.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.774]  $ ...future.elements_ii    :List of 1
[10:22:49.774]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.774]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:49.774]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.774]  $ ...future.seeds_ii       : NULL
[10:22:49.774]  $ ...future.globals.maxSize: NULL
[10:22:49.774]  - attr(*, "where")=List of 5
[10:22:49.774]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.774]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.774]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.774]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.774]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.774]  - attr(*, "resolved")= logi FALSE
[10:22:49.774]  - attr(*, "total_size")= num 1240
[10:22:49.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.774]  - attr(*, "already-done")= logi TRUE
[10:22:49.781] - copied ‘...future.FUN’ to environment
[10:22:49.781] - copied ‘future.call.arguments’ to environment
[10:22:49.781] - copied ‘...future.elements_ii’ to environment
[10:22:49.781] - copied ‘...future.seeds_ii’ to environment
[10:22:49.781] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.782] assign_globals() ... done
[10:22:49.782] requestCore(): workers = 2
[10:22:49.785] MulticoreFuture started
[10:22:49.786] - Launch lazy future ... done
[10:22:49.786] plan(): Setting new future strategy stack:
[10:22:49.786] run() for ‘MulticoreFuture’ ... done
[10:22:49.787] Created future:
[10:22:49.787] List of future strategies:
[10:22:49.787] 1. sequential:
[10:22:49.787]    - args: function (..., envir = parent.frame())
[10:22:49.787]    - tweaked: FALSE
[10:22:49.787]    - call: NULL
[10:22:49.788] plan(): nbrOfWorkers() = 1
[10:22:49.791] plan(): Setting new future strategy stack:
[10:22:49.791] List of future strategies:
[10:22:49.791] 1. multicore:
[10:22:49.791]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.791]    - tweaked: FALSE
[10:22:49.791]    - call: plan(strategy)
[10:22:49.797] plan(): nbrOfWorkers() = 2
[10:22:49.787] MulticoreFuture:
[10:22:49.787] Label: ‘future_by-1’
[10:22:49.787] Expression:
[10:22:49.787] {
[10:22:49.787]     do.call(function(...) {
[10:22:49.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.787]             on.exit(options(oopts), add = TRUE)
[10:22:49.787]         }
[10:22:49.787]         {
[10:22:49.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.787]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.787]             })
[10:22:49.787]         }
[10:22:49.787]     }, args = future.call.arguments)
[10:22:49.787] }
[10:22:49.787] Lazy evaluation: FALSE
[10:22:49.787] Asynchronous evaluation: TRUE
[10:22:49.787] Local evaluation: TRUE
[10:22:49.787] Environment: R_GlobalEnv
[10:22:49.787] Capture standard output: TRUE
[10:22:49.787] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.787] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.787] Packages: <none>
[10:22:49.787] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.787] Resolved: TRUE
[10:22:49.787] Value: <not collected>
[10:22:49.787] Conditions captured: <none>
[10:22:49.787] Early signaling: FALSE
[10:22:49.787] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.787] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.798] Chunk #1 of 2 ... DONE
[10:22:49.799] Chunk #2 of 2 ...
[10:22:49.799]  - Finding globals in 'X' for chunk #2 ...
[10:22:49.799] getGlobalsAndPackages() ...
[10:22:49.799] Searching for globals...
[10:22:49.800] 
[10:22:49.800] Searching for globals ... DONE
[10:22:49.800] - globals: [0] <none>
[10:22:49.800] getGlobalsAndPackages() ... DONE
[10:22:49.800]    + additional globals found: [n=0] 
[10:22:49.801]    + additional namespaces needed: [n=0] 
[10:22:49.801]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:49.801]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:49.801]  - seeds: <none>
[10:22:49.801]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.802] getGlobalsAndPackages() ...
[10:22:49.802] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.802] Resolving globals: FALSE
[10:22:49.802] Tweak future expression to call with '...' arguments ...
[10:22:49.802] {
[10:22:49.802]     do.call(function(...) {
[10:22:49.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.802]             on.exit(options(oopts), add = TRUE)
[10:22:49.802]         }
[10:22:49.802]         {
[10:22:49.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.802]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.802]             })
[10:22:49.802]         }
[10:22:49.802]     }, args = future.call.arguments)
[10:22:49.802] }
[10:22:49.803] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.803] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.803] 
[10:22:49.804] getGlobalsAndPackages() ... DONE
[10:22:49.804] run() for ‘Future’ ...
[10:22:49.804] - state: ‘created’
[10:22:49.804] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.809] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:49.809]   - Field: ‘label’
[10:22:49.810]   - Field: ‘local’
[10:22:49.810]   - Field: ‘owner’
[10:22:49.810]   - Field: ‘envir’
[10:22:49.810]   - Field: ‘workers’
[10:22:49.810]   - Field: ‘packages’
[10:22:49.810]   - Field: ‘gc’
[10:22:49.810]   - Field: ‘job’
[10:22:49.811]   - Field: ‘conditions’
[10:22:49.811]   - Field: ‘expr’
[10:22:49.811]   - Field: ‘uuid’
[10:22:49.811]   - Field: ‘seed’
[10:22:49.811]   - Field: ‘version’
[10:22:49.811]   - Field: ‘result’
[10:22:49.812]   - Field: ‘asynchronous’
[10:22:49.812]   - Field: ‘calls’
[10:22:49.812]   - Field: ‘globals’
[10:22:49.812]   - Field: ‘stdout’
[10:22:49.812]   - Field: ‘earlySignal’
[10:22:49.812]   - Field: ‘lazy’
[10:22:49.812]   - Field: ‘state’
[10:22:49.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:49.813] - Launch lazy future ...
[10:22:49.813] Packages needed by the future expression (n = 0): <none>
[10:22:49.813] Packages needed by future strategies (n = 0): <none>
[10:22:49.814] {
[10:22:49.814]     {
[10:22:49.814]         {
[10:22:49.814]             ...future.startTime <- base::Sys.time()
[10:22:49.814]             {
[10:22:49.814]                 {
[10:22:49.814]                   {
[10:22:49.814]                     {
[10:22:49.814]                       base::local({
[10:22:49.814]                         has_future <- base::requireNamespace("future", 
[10:22:49.814]                           quietly = TRUE)
[10:22:49.814]                         if (has_future) {
[10:22:49.814]                           ns <- base::getNamespace("future")
[10:22:49.814]                           version <- ns[[".package"]][["version"]]
[10:22:49.814]                           if (is.null(version)) 
[10:22:49.814]                             version <- utils::packageVersion("future")
[10:22:49.814]                         }
[10:22:49.814]                         else {
[10:22:49.814]                           version <- NULL
[10:22:49.814]                         }
[10:22:49.814]                         if (!has_future || version < "1.8.0") {
[10:22:49.814]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.814]                             "", base::R.version$version.string), 
[10:22:49.814]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.814]                               "release", "version")], collapse = " "), 
[10:22:49.814]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.814]                             info)
[10:22:49.814]                           info <- base::paste(info, collapse = "; ")
[10:22:49.814]                           if (!has_future) {
[10:22:49.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.814]                               info)
[10:22:49.814]                           }
[10:22:49.814]                           else {
[10:22:49.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.814]                               info, version)
[10:22:49.814]                           }
[10:22:49.814]                           base::stop(msg)
[10:22:49.814]                         }
[10:22:49.814]                       })
[10:22:49.814]                     }
[10:22:49.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.814]                     base::options(mc.cores = 1L)
[10:22:49.814]                   }
[10:22:49.814]                   options(future.plan = NULL)
[10:22:49.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.814]                 }
[10:22:49.814]                 ...future.workdir <- getwd()
[10:22:49.814]             }
[10:22:49.814]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.814]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.814]         }
[10:22:49.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.814]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:49.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.814]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.814]             base::names(...future.oldOptions))
[10:22:49.814]     }
[10:22:49.814]     if (FALSE) {
[10:22:49.814]     }
[10:22:49.814]     else {
[10:22:49.814]         if (TRUE) {
[10:22:49.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.814]                 open = "w")
[10:22:49.814]         }
[10:22:49.814]         else {
[10:22:49.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.814]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.814]         }
[10:22:49.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.814]             base::sink(type = "output", split = FALSE)
[10:22:49.814]             base::close(...future.stdout)
[10:22:49.814]         }, add = TRUE)
[10:22:49.814]     }
[10:22:49.814]     ...future.frame <- base::sys.nframe()
[10:22:49.814]     ...future.conditions <- base::list()
[10:22:49.814]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.814]     if (FALSE) {
[10:22:49.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.814]     }
[10:22:49.814]     ...future.result <- base::tryCatch({
[10:22:49.814]         base::withCallingHandlers({
[10:22:49.814]             ...future.value <- base::withVisible(base::local({
[10:22:49.814]                 withCallingHandlers({
[10:22:49.814]                   {
[10:22:49.814]                     do.call(function(...) {
[10:22:49.814]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.814]                       if (!identical(...future.globals.maxSize.org, 
[10:22:49.814]                         ...future.globals.maxSize)) {
[10:22:49.814]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.814]                         on.exit(options(oopts), add = TRUE)
[10:22:49.814]                       }
[10:22:49.814]                       {
[10:22:49.814]                         lapply(seq_along(...future.elements_ii), 
[10:22:49.814]                           FUN = function(jj) {
[10:22:49.814]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.814]                             ...future.FUN(...future.X_jj, ...)
[10:22:49.814]                           })
[10:22:49.814]                       }
[10:22:49.814]                     }, args = future.call.arguments)
[10:22:49.814]                   }
[10:22:49.814]                 }, immediateCondition = function(cond) {
[10:22:49.814]                   save_rds <- function (object, pathname, ...) 
[10:22:49.814]                   {
[10:22:49.814]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:49.814]                     if (file_test("-f", pathname_tmp)) {
[10:22:49.814]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.814]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:49.814]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.814]                         fi_tmp[["mtime"]])
[10:22:49.814]                     }
[10:22:49.814]                     tryCatch({
[10:22:49.814]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:49.814]                     }, error = function(ex) {
[10:22:49.814]                       msg <- conditionMessage(ex)
[10:22:49.814]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.814]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:49.814]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.814]                         fi_tmp[["mtime"]], msg)
[10:22:49.814]                       ex$message <- msg
[10:22:49.814]                       stop(ex)
[10:22:49.814]                     })
[10:22:49.814]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:49.814]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:49.814]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:49.814]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.814]                       fi <- file.info(pathname)
[10:22:49.814]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:49.814]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.814]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:49.814]                         fi[["size"]], fi[["mtime"]])
[10:22:49.814]                       stop(msg)
[10:22:49.814]                     }
[10:22:49.814]                     invisible(pathname)
[10:22:49.814]                   }
[10:22:49.814]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:49.814]                     rootPath = tempdir()) 
[10:22:49.814]                   {
[10:22:49.814]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:49.814]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:49.814]                       tmpdir = path, fileext = ".rds")
[10:22:49.814]                     save_rds(obj, file)
[10:22:49.814]                   }
[10:22:49.814]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:49.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.814]                   {
[10:22:49.814]                     inherits <- base::inherits
[10:22:49.814]                     invokeRestart <- base::invokeRestart
[10:22:49.814]                     is.null <- base::is.null
[10:22:49.814]                     muffled <- FALSE
[10:22:49.814]                     if (inherits(cond, "message")) {
[10:22:49.814]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.814]                       if (muffled) 
[10:22:49.814]                         invokeRestart("muffleMessage")
[10:22:49.814]                     }
[10:22:49.814]                     else if (inherits(cond, "warning")) {
[10:22:49.814]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.814]                       if (muffled) 
[10:22:49.814]                         invokeRestart("muffleWarning")
[10:22:49.814]                     }
[10:22:49.814]                     else if (inherits(cond, "condition")) {
[10:22:49.814]                       if (!is.null(pattern)) {
[10:22:49.814]                         computeRestarts <- base::computeRestarts
[10:22:49.814]                         grepl <- base::grepl
[10:22:49.814]                         restarts <- computeRestarts(cond)
[10:22:49.814]                         for (restart in restarts) {
[10:22:49.814]                           name <- restart$name
[10:22:49.814]                           if (is.null(name)) 
[10:22:49.814]                             next
[10:22:49.814]                           if (!grepl(pattern, name)) 
[10:22:49.814]                             next
[10:22:49.814]                           invokeRestart(restart)
[10:22:49.814]                           muffled <- TRUE
[10:22:49.814]                           break
[10:22:49.814]                         }
[10:22:49.814]                       }
[10:22:49.814]                     }
[10:22:49.814]                     invisible(muffled)
[10:22:49.814]                   }
[10:22:49.814]                   muffleCondition(cond)
[10:22:49.814]                 })
[10:22:49.814]             }))
[10:22:49.814]             future::FutureResult(value = ...future.value$value, 
[10:22:49.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.814]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.814]                     ...future.globalenv.names))
[10:22:49.814]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.814]         }, condition = base::local({
[10:22:49.814]             c <- base::c
[10:22:49.814]             inherits <- base::inherits
[10:22:49.814]             invokeRestart <- base::invokeRestart
[10:22:49.814]             length <- base::length
[10:22:49.814]             list <- base::list
[10:22:49.814]             seq.int <- base::seq.int
[10:22:49.814]             signalCondition <- base::signalCondition
[10:22:49.814]             sys.calls <- base::sys.calls
[10:22:49.814]             `[[` <- base::`[[`
[10:22:49.814]             `+` <- base::`+`
[10:22:49.814]             `<<-` <- base::`<<-`
[10:22:49.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.814]                   3L)]
[10:22:49.814]             }
[10:22:49.814]             function(cond) {
[10:22:49.814]                 is_error <- inherits(cond, "error")
[10:22:49.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.814]                   NULL)
[10:22:49.814]                 if (is_error) {
[10:22:49.814]                   sessionInformation <- function() {
[10:22:49.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.814]                       search = base::search(), system = base::Sys.info())
[10:22:49.814]                   }
[10:22:49.814]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.814]                     cond$call), session = sessionInformation(), 
[10:22:49.814]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.814]                   signalCondition(cond)
[10:22:49.814]                 }
[10:22:49.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.814]                 "immediateCondition"))) {
[10:22:49.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.814]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.814]                   if (TRUE && !signal) {
[10:22:49.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.814]                     {
[10:22:49.814]                       inherits <- base::inherits
[10:22:49.814]                       invokeRestart <- base::invokeRestart
[10:22:49.814]                       is.null <- base::is.null
[10:22:49.814]                       muffled <- FALSE
[10:22:49.814]                       if (inherits(cond, "message")) {
[10:22:49.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.814]                         if (muffled) 
[10:22:49.814]                           invokeRestart("muffleMessage")
[10:22:49.814]                       }
[10:22:49.814]                       else if (inherits(cond, "warning")) {
[10:22:49.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.814]                         if (muffled) 
[10:22:49.814]                           invokeRestart("muffleWarning")
[10:22:49.814]                       }
[10:22:49.814]                       else if (inherits(cond, "condition")) {
[10:22:49.814]                         if (!is.null(pattern)) {
[10:22:49.814]                           computeRestarts <- base::computeRestarts
[10:22:49.814]                           grepl <- base::grepl
[10:22:49.814]                           restarts <- computeRestarts(cond)
[10:22:49.814]                           for (restart in restarts) {
[10:22:49.814]                             name <- restart$name
[10:22:49.814]                             if (is.null(name)) 
[10:22:49.814]                               next
[10:22:49.814]                             if (!grepl(pattern, name)) 
[10:22:49.814]                               next
[10:22:49.814]                             invokeRestart(restart)
[10:22:49.814]                             muffled <- TRUE
[10:22:49.814]                             break
[10:22:49.814]                           }
[10:22:49.814]                         }
[10:22:49.814]                       }
[10:22:49.814]                       invisible(muffled)
[10:22:49.814]                     }
[10:22:49.814]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.814]                   }
[10:22:49.814]                 }
[10:22:49.814]                 else {
[10:22:49.814]                   if (TRUE) {
[10:22:49.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.814]                     {
[10:22:49.814]                       inherits <- base::inherits
[10:22:49.814]                       invokeRestart <- base::invokeRestart
[10:22:49.814]                       is.null <- base::is.null
[10:22:49.814]                       muffled <- FALSE
[10:22:49.814]                       if (inherits(cond, "message")) {
[10:22:49.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.814]                         if (muffled) 
[10:22:49.814]                           invokeRestart("muffleMessage")
[10:22:49.814]                       }
[10:22:49.814]                       else if (inherits(cond, "warning")) {
[10:22:49.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.814]                         if (muffled) 
[10:22:49.814]                           invokeRestart("muffleWarning")
[10:22:49.814]                       }
[10:22:49.814]                       else if (inherits(cond, "condition")) {
[10:22:49.814]                         if (!is.null(pattern)) {
[10:22:49.814]                           computeRestarts <- base::computeRestarts
[10:22:49.814]                           grepl <- base::grepl
[10:22:49.814]                           restarts <- computeRestarts(cond)
[10:22:49.814]                           for (restart in restarts) {
[10:22:49.814]                             name <- restart$name
[10:22:49.814]                             if (is.null(name)) 
[10:22:49.814]                               next
[10:22:49.814]                             if (!grepl(pattern, name)) 
[10:22:49.814]                               next
[10:22:49.814]                             invokeRestart(restart)
[10:22:49.814]                             muffled <- TRUE
[10:22:49.814]                             break
[10:22:49.814]                           }
[10:22:49.814]                         }
[10:22:49.814]                       }
[10:22:49.814]                       invisible(muffled)
[10:22:49.814]                     }
[10:22:49.814]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.814]                   }
[10:22:49.814]                 }
[10:22:49.814]             }
[10:22:49.814]         }))
[10:22:49.814]     }, error = function(ex) {
[10:22:49.814]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.814]                 ...future.rng), started = ...future.startTime, 
[10:22:49.814]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.814]             version = "1.8"), class = "FutureResult")
[10:22:49.814]     }, finally = {
[10:22:49.814]         if (!identical(...future.workdir, getwd())) 
[10:22:49.814]             setwd(...future.workdir)
[10:22:49.814]         {
[10:22:49.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.814]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.814]             }
[10:22:49.814]             base::options(...future.oldOptions)
[10:22:49.814]             if (.Platform$OS.type == "windows") {
[10:22:49.814]                 old_names <- names(...future.oldEnvVars)
[10:22:49.814]                 envs <- base::Sys.getenv()
[10:22:49.814]                 names <- names(envs)
[10:22:49.814]                 common <- intersect(names, old_names)
[10:22:49.814]                 added <- setdiff(names, old_names)
[10:22:49.814]                 removed <- setdiff(old_names, names)
[10:22:49.814]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.814]                   envs[common]]
[10:22:49.814]                 NAMES <- toupper(changed)
[10:22:49.814]                 args <- list()
[10:22:49.814]                 for (kk in seq_along(NAMES)) {
[10:22:49.814]                   name <- changed[[kk]]
[10:22:49.814]                   NAME <- NAMES[[kk]]
[10:22:49.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.814]                     next
[10:22:49.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.814]                 }
[10:22:49.814]                 NAMES <- toupper(added)
[10:22:49.814]                 for (kk in seq_along(NAMES)) {
[10:22:49.814]                   name <- added[[kk]]
[10:22:49.814]                   NAME <- NAMES[[kk]]
[10:22:49.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.814]                     next
[10:22:49.814]                   args[[name]] <- ""
[10:22:49.814]                 }
[10:22:49.814]                 NAMES <- toupper(removed)
[10:22:49.814]                 for (kk in seq_along(NAMES)) {
[10:22:49.814]                   name <- removed[[kk]]
[10:22:49.814]                   NAME <- NAMES[[kk]]
[10:22:49.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.814]                     next
[10:22:49.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.814]                 }
[10:22:49.814]                 if (length(args) > 0) 
[10:22:49.814]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.814]             }
[10:22:49.814]             else {
[10:22:49.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.814]             }
[10:22:49.814]             {
[10:22:49.814]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.814]                   0L) {
[10:22:49.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.814]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.814]                   base::options(opts)
[10:22:49.814]                 }
[10:22:49.814]                 {
[10:22:49.814]                   {
[10:22:49.814]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.814]                     NULL
[10:22:49.814]                   }
[10:22:49.814]                   options(future.plan = NULL)
[10:22:49.814]                   if (is.na(NA_character_)) 
[10:22:49.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.814]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.814]                     envir = parent.frame()) 
[10:22:49.814]                   {
[10:22:49.814]                     default_workers <- missing(workers)
[10:22:49.814]                     if (is.function(workers)) 
[10:22:49.814]                       workers <- workers()
[10:22:49.814]                     workers <- structure(as.integer(workers), 
[10:22:49.814]                       class = class(workers))
[10:22:49.814]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.814]                       1L)
[10:22:49.814]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.814]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.814]                       if (default_workers) 
[10:22:49.814]                         supportsMulticore(warn = TRUE)
[10:22:49.814]                       return(sequential(..., envir = envir))
[10:22:49.814]                     }
[10:22:49.814]                     oopts <- options(mc.cores = workers)
[10:22:49.814]                     on.exit(options(oopts))
[10:22:49.814]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.814]                       envir = envir)
[10:22:49.814]                     if (!future$lazy) 
[10:22:49.814]                       future <- run(future)
[10:22:49.814]                     invisible(future)
[10:22:49.814]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.814]                 }
[10:22:49.814]             }
[10:22:49.814]         }
[10:22:49.814]     })
[10:22:49.814]     if (TRUE) {
[10:22:49.814]         base::sink(type = "output", split = FALSE)
[10:22:49.814]         if (TRUE) {
[10:22:49.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.814]         }
[10:22:49.814]         else {
[10:22:49.814]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.814]         }
[10:22:49.814]         base::close(...future.stdout)
[10:22:49.814]         ...future.stdout <- NULL
[10:22:49.814]     }
[10:22:49.814]     ...future.result$conditions <- ...future.conditions
[10:22:49.814]     ...future.result$finished <- base::Sys.time()
[10:22:49.814]     ...future.result
[10:22:49.814] }
[10:22:49.817] assign_globals() ...
[10:22:49.817] List of 5
[10:22:49.817]  $ ...future.FUN            :function (object, ...)  
[10:22:49.817]  $ future.call.arguments    : list()
[10:22:49.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.817]  $ ...future.elements_ii    :List of 2
[10:22:49.817]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.817]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:49.817]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.817]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:22:49.817]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:49.817]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:49.817]  $ ...future.seeds_ii       : NULL
[10:22:49.817]  $ ...future.globals.maxSize: NULL
[10:22:49.817]  - attr(*, "where")=List of 5
[10:22:49.817]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.817]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.817]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.817]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.817]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.817]  - attr(*, "resolved")= logi FALSE
[10:22:49.817]  - attr(*, "total_size")= num 1240
[10:22:49.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.817]  - attr(*, "already-done")= logi TRUE
[10:22:49.831] - copied ‘...future.FUN’ to environment
[10:22:49.831] - copied ‘future.call.arguments’ to environment
[10:22:49.831] - copied ‘...future.elements_ii’ to environment
[10:22:49.831] - copied ‘...future.seeds_ii’ to environment
[10:22:49.831] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.831] assign_globals() ... done
[10:22:49.831] requestCore(): workers = 2
[10:22:49.836] MulticoreFuture started
[10:22:49.837] - Launch lazy future ... done
[10:22:49.837] run() for ‘MulticoreFuture’ ... done
[10:22:49.837] Created future:
[10:22:49.837] plan(): Setting new future strategy stack:
[10:22:49.838] List of future strategies:
[10:22:49.838] 1. sequential:
[10:22:49.838]    - args: function (..., envir = parent.frame())
[10:22:49.838]    - tweaked: FALSE
[10:22:49.838]    - call: NULL
[10:22:49.838] plan(): nbrOfWorkers() = 1
[10:22:49.842] plan(): Setting new future strategy stack:
[10:22:49.842] List of future strategies:
[10:22:49.842] 1. multicore:
[10:22:49.842]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.842]    - tweaked: FALSE
[10:22:49.842]    - call: plan(strategy)
[10:22:49.848] plan(): nbrOfWorkers() = 2
[10:22:49.837] MulticoreFuture:
[10:22:49.837] Label: ‘future_by-2’
[10:22:49.837] Expression:
[10:22:49.837] {
[10:22:49.837]     do.call(function(...) {
[10:22:49.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.837]             on.exit(options(oopts), add = TRUE)
[10:22:49.837]         }
[10:22:49.837]         {
[10:22:49.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.837]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.837]             })
[10:22:49.837]         }
[10:22:49.837]     }, args = future.call.arguments)
[10:22:49.837] }
[10:22:49.837] Lazy evaluation: FALSE
[10:22:49.837] Asynchronous evaluation: TRUE
[10:22:49.837] Local evaluation: TRUE
[10:22:49.837] Environment: R_GlobalEnv
[10:22:49.837] Capture standard output: TRUE
[10:22:49.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.837] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.837] Packages: <none>
[10:22:49.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.837] Resolved: TRUE
[10:22:49.837] Value: <not collected>
[10:22:49.837] Conditions captured: <none>
[10:22:49.837] Early signaling: FALSE
[10:22:49.837] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.837] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.849] Chunk #2 of 2 ... DONE
[10:22:49.849] Launching 2 futures (chunks) ... DONE
[10:22:49.849] Resolving 2 futures (chunks) ...
[10:22:49.849] resolve() on list ...
[10:22:49.849]  recursive: 0
[10:22:49.850]  length: 2
[10:22:49.850] 
[10:22:49.850] Future #1
[10:22:49.851] result() for MulticoreFuture ...
[10:22:49.852] result() for MulticoreFuture ...
[10:22:49.853] result() for MulticoreFuture ... done
[10:22:49.853] result() for MulticoreFuture ... done
[10:22:49.853] result() for MulticoreFuture ...
[10:22:49.853] result() for MulticoreFuture ... done
[10:22:49.853] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:49.853] - nx: 2
[10:22:49.854] - relay: TRUE
[10:22:49.854] - stdout: TRUE
[10:22:49.854] - signal: TRUE
[10:22:49.854] - resignal: FALSE
[10:22:49.854] - force: TRUE
[10:22:49.854] - relayed: [n=2] FALSE, FALSE
[10:22:49.854] - queued futures: [n=2] FALSE, FALSE
[10:22:49.855]  - until=1
[10:22:49.855]  - relaying element #1
[10:22:49.855] result() for MulticoreFuture ...
[10:22:49.855] result() for MulticoreFuture ... done
[10:22:49.855] result() for MulticoreFuture ...
[10:22:49.855] result() for MulticoreFuture ... done
[10:22:49.856] result() for MulticoreFuture ...
[10:22:49.856] result() for MulticoreFuture ... done
[10:22:49.856] result() for MulticoreFuture ...
[10:22:49.856] result() for MulticoreFuture ... done
[10:22:49.856] - relayed: [n=2] TRUE, FALSE
[10:22:49.856] - queued futures: [n=2] TRUE, FALSE
[10:22:49.856] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:49.857]  length: 1 (resolved future 1)
[10:22:49.857] Future #2
[10:22:49.857] result() for MulticoreFuture ...
[10:22:49.858] result() for MulticoreFuture ...
[10:22:49.858] result() for MulticoreFuture ... done
[10:22:49.858] result() for MulticoreFuture ... done
[10:22:49.858] result() for MulticoreFuture ...
[10:22:49.858] result() for MulticoreFuture ... done
[10:22:49.859] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:49.859] - nx: 2
[10:22:49.859] - relay: TRUE
[10:22:49.859] - stdout: TRUE
[10:22:49.859] - signal: TRUE
[10:22:49.859] - resignal: FALSE
[10:22:49.859] - force: TRUE
[10:22:49.859] - relayed: [n=2] TRUE, FALSE
[10:22:49.859] - queued futures: [n=2] TRUE, FALSE
[10:22:49.860]  - until=2
[10:22:49.860]  - relaying element #2
[10:22:49.860] result() for MulticoreFuture ...
[10:22:49.860] result() for MulticoreFuture ... done
[10:22:49.860] result() for MulticoreFuture ...
[10:22:49.860] result() for MulticoreFuture ... done
[10:22:49.860] result() for MulticoreFuture ...
[10:22:49.860] result() for MulticoreFuture ... done
[10:22:49.861] result() for MulticoreFuture ...
[10:22:49.861] result() for MulticoreFuture ... done
[10:22:49.861] - relayed: [n=2] TRUE, TRUE
[10:22:49.861] - queued futures: [n=2] TRUE, TRUE
[10:22:49.861] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:49.861]  length: 0 (resolved future 2)
[10:22:49.861] Relaying remaining futures
[10:22:49.861] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.862] - nx: 2
[10:22:49.867] - relay: TRUE
[10:22:49.867] - stdout: TRUE
[10:22:49.867] - signal: TRUE
[10:22:49.867] - resignal: FALSE
[10:22:49.867] - force: TRUE
[10:22:49.868] - relayed: [n=2] TRUE, TRUE
[10:22:49.868] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:49.868] - relayed: [n=2] TRUE, TRUE
[10:22:49.868] - queued futures: [n=2] TRUE, TRUE
[10:22:49.868] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.868] resolve() on list ... DONE
[10:22:49.868] result() for MulticoreFuture ...
[10:22:49.868] result() for MulticoreFuture ... done
[10:22:49.868] result() for MulticoreFuture ...
[10:22:49.869] result() for MulticoreFuture ... done
[10:22:49.869] result() for MulticoreFuture ...
[10:22:49.869] result() for MulticoreFuture ... done
[10:22:49.869] result() for MulticoreFuture ...
[10:22:49.869] result() for MulticoreFuture ... done
[10:22:49.869]  - Number of value chunks collected: 2
[10:22:49.869] Resolving 2 futures (chunks) ... DONE
[10:22:49.870] Reducing values from 2 chunks ...
[10:22:49.870]  - Number of values collected after concatenation: 3
[10:22:49.870]  - Number of values expected: 3
[10:22:49.870] Reducing values from 2 chunks ... DONE
[10:22:49.870] future_lapply() ... DONE
[10:22:49.870] future_by_internal() ... DONE
[10:22:49.871] future_by_internal() ...
[10:22:49.871] future_lapply() ...
[10:22:49.876] Number of chunks: 2
[10:22:49.876] getGlobalsAndPackagesXApply() ...
[10:22:49.876]  - future.globals: TRUE
[10:22:49.876] getGlobalsAndPackages() ...
[10:22:49.876] Searching for globals...
[10:22:49.878] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:49.878] Searching for globals ... DONE
[10:22:49.878] Resolving globals: FALSE
[10:22:49.879] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:49.879] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:49.879] - globals: [1] ‘FUN’
[10:22:49.879] 
[10:22:49.879] getGlobalsAndPackages() ... DONE
[10:22:49.879]  - globals found/used: [n=1] ‘FUN’
[10:22:49.880]  - needed namespaces: [n=0] 
[10:22:49.880] Finding globals ... DONE
[10:22:49.880]  - use_args: TRUE
[10:22:49.880]  - Getting '...' globals ...
[10:22:49.880] resolve() on list ...
[10:22:49.880]  recursive: 0
[10:22:49.880]  length: 1
[10:22:49.880]  elements: ‘...’
[10:22:49.881]  length: 0 (resolved future 1)
[10:22:49.881] resolve() on list ... DONE
[10:22:49.881]    - '...' content: [n=1] ‘digits’
[10:22:49.881] List of 1
[10:22:49.881]  $ ...:List of 1
[10:22:49.881]   ..$ digits: int 2
[10:22:49.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.881]  - attr(*, "where")=List of 1
[10:22:49.881]   ..$ ...:<environment: 0x55f6388ca728> 
[10:22:49.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.881]  - attr(*, "resolved")= logi TRUE
[10:22:49.881]  - attr(*, "total_size")= num NA
[10:22:49.884]  - Getting '...' globals ... DONE
[10:22:49.884] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:49.884] List of 2
[10:22:49.884]  $ ...future.FUN:function (object, ...)  
[10:22:49.884]  $ ...          :List of 1
[10:22:49.884]   ..$ digits: int 2
[10:22:49.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.884]  - attr(*, "where")=List of 2
[10:22:49.884]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:49.884]   ..$ ...          :<environment: 0x55f6388ca728> 
[10:22:49.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.884]  - attr(*, "resolved")= logi FALSE
[10:22:49.884]  - attr(*, "total_size")= num 1296
[10:22:49.887] Packages to be attached in all futures: [n=0] 
[10:22:49.887] getGlobalsAndPackagesXApply() ... DONE
[10:22:49.888] Number of futures (= number of chunks): 2
[10:22:49.888] Launching 2 futures (chunks) ...
[10:22:49.888] Chunk #1 of 2 ...
[10:22:49.888]  - Finding globals in 'X' for chunk #1 ...
[10:22:49.888] getGlobalsAndPackages() ...
[10:22:49.888] Searching for globals...
[10:22:49.888] 
[10:22:49.889] Searching for globals ... DONE
[10:22:49.889] - globals: [0] <none>
[10:22:49.889] getGlobalsAndPackages() ... DONE
[10:22:49.889]    + additional globals found: [n=0] 
[10:22:49.889]    + additional namespaces needed: [n=0] 
[10:22:49.889]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:49.889]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:49.889]  - seeds: <none>
[10:22:49.889]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.889] getGlobalsAndPackages() ...
[10:22:49.889] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.890] Resolving globals: FALSE
[10:22:49.890] Tweak future expression to call with '...' arguments ...
[10:22:49.890] {
[10:22:49.890]     do.call(function(...) {
[10:22:49.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.890]             on.exit(options(oopts), add = TRUE)
[10:22:49.890]         }
[10:22:49.890]         {
[10:22:49.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.890]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.890]             })
[10:22:49.890]         }
[10:22:49.890]     }, args = future.call.arguments)
[10:22:49.890] }
[10:22:49.892] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.892] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.892] 
[10:22:49.892] getGlobalsAndPackages() ... DONE
[10:22:49.893] run() for ‘Future’ ...
[10:22:49.893] - state: ‘created’
[10:22:49.893] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.896] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:49.897]   - Field: ‘label’
[10:22:49.897]   - Field: ‘local’
[10:22:49.897]   - Field: ‘owner’
[10:22:49.897]   - Field: ‘envir’
[10:22:49.897]   - Field: ‘workers’
[10:22:49.897]   - Field: ‘packages’
[10:22:49.897]   - Field: ‘gc’
[10:22:49.898]   - Field: ‘job’
[10:22:49.898]   - Field: ‘conditions’
[10:22:49.898]   - Field: ‘expr’
[10:22:49.898]   - Field: ‘uuid’
[10:22:49.898]   - Field: ‘seed’
[10:22:49.898]   - Field: ‘version’
[10:22:49.898]   - Field: ‘result’
[10:22:49.898]   - Field: ‘asynchronous’
[10:22:49.898]   - Field: ‘calls’
[10:22:49.899]   - Field: ‘globals’
[10:22:49.899]   - Field: ‘stdout’
[10:22:49.899]   - Field: ‘earlySignal’
[10:22:49.899]   - Field: ‘lazy’
[10:22:49.899]   - Field: ‘state’
[10:22:49.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:49.899] - Launch lazy future ...
[10:22:49.899] Packages needed by the future expression (n = 0): <none>
[10:22:49.900] Packages needed by future strategies (n = 0): <none>
[10:22:49.900] {
[10:22:49.900]     {
[10:22:49.900]         {
[10:22:49.900]             ...future.startTime <- base::Sys.time()
[10:22:49.900]             {
[10:22:49.900]                 {
[10:22:49.900]                   {
[10:22:49.900]                     {
[10:22:49.900]                       base::local({
[10:22:49.900]                         has_future <- base::requireNamespace("future", 
[10:22:49.900]                           quietly = TRUE)
[10:22:49.900]                         if (has_future) {
[10:22:49.900]                           ns <- base::getNamespace("future")
[10:22:49.900]                           version <- ns[[".package"]][["version"]]
[10:22:49.900]                           if (is.null(version)) 
[10:22:49.900]                             version <- utils::packageVersion("future")
[10:22:49.900]                         }
[10:22:49.900]                         else {
[10:22:49.900]                           version <- NULL
[10:22:49.900]                         }
[10:22:49.900]                         if (!has_future || version < "1.8.0") {
[10:22:49.900]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.900]                             "", base::R.version$version.string), 
[10:22:49.900]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.900]                               "release", "version")], collapse = " "), 
[10:22:49.900]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.900]                             info)
[10:22:49.900]                           info <- base::paste(info, collapse = "; ")
[10:22:49.900]                           if (!has_future) {
[10:22:49.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.900]                               info)
[10:22:49.900]                           }
[10:22:49.900]                           else {
[10:22:49.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.900]                               info, version)
[10:22:49.900]                           }
[10:22:49.900]                           base::stop(msg)
[10:22:49.900]                         }
[10:22:49.900]                       })
[10:22:49.900]                     }
[10:22:49.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.900]                     base::options(mc.cores = 1L)
[10:22:49.900]                   }
[10:22:49.900]                   options(future.plan = NULL)
[10:22:49.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.900]                 }
[10:22:49.900]                 ...future.workdir <- getwd()
[10:22:49.900]             }
[10:22:49.900]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.900]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.900]         }
[10:22:49.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.900]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:49.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.900]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.900]             base::names(...future.oldOptions))
[10:22:49.900]     }
[10:22:49.900]     if (FALSE) {
[10:22:49.900]     }
[10:22:49.900]     else {
[10:22:49.900]         if (TRUE) {
[10:22:49.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.900]                 open = "w")
[10:22:49.900]         }
[10:22:49.900]         else {
[10:22:49.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.900]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.900]         }
[10:22:49.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.900]             base::sink(type = "output", split = FALSE)
[10:22:49.900]             base::close(...future.stdout)
[10:22:49.900]         }, add = TRUE)
[10:22:49.900]     }
[10:22:49.900]     ...future.frame <- base::sys.nframe()
[10:22:49.900]     ...future.conditions <- base::list()
[10:22:49.900]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.900]     if (FALSE) {
[10:22:49.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.900]     }
[10:22:49.900]     ...future.result <- base::tryCatch({
[10:22:49.900]         base::withCallingHandlers({
[10:22:49.900]             ...future.value <- base::withVisible(base::local({
[10:22:49.900]                 withCallingHandlers({
[10:22:49.900]                   {
[10:22:49.900]                     do.call(function(...) {
[10:22:49.900]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.900]                       if (!identical(...future.globals.maxSize.org, 
[10:22:49.900]                         ...future.globals.maxSize)) {
[10:22:49.900]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.900]                         on.exit(options(oopts), add = TRUE)
[10:22:49.900]                       }
[10:22:49.900]                       {
[10:22:49.900]                         lapply(seq_along(...future.elements_ii), 
[10:22:49.900]                           FUN = function(jj) {
[10:22:49.900]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.900]                             ...future.FUN(...future.X_jj, ...)
[10:22:49.900]                           })
[10:22:49.900]                       }
[10:22:49.900]                     }, args = future.call.arguments)
[10:22:49.900]                   }
[10:22:49.900]                 }, immediateCondition = function(cond) {
[10:22:49.900]                   save_rds <- function (object, pathname, ...) 
[10:22:49.900]                   {
[10:22:49.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:49.900]                     if (file_test("-f", pathname_tmp)) {
[10:22:49.900]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:49.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.900]                         fi_tmp[["mtime"]])
[10:22:49.900]                     }
[10:22:49.900]                     tryCatch({
[10:22:49.900]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:49.900]                     }, error = function(ex) {
[10:22:49.900]                       msg <- conditionMessage(ex)
[10:22:49.900]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:49.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.900]                         fi_tmp[["mtime"]], msg)
[10:22:49.900]                       ex$message <- msg
[10:22:49.900]                       stop(ex)
[10:22:49.900]                     })
[10:22:49.900]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:49.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:49.900]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:49.900]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.900]                       fi <- file.info(pathname)
[10:22:49.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:49.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:49.900]                         fi[["size"]], fi[["mtime"]])
[10:22:49.900]                       stop(msg)
[10:22:49.900]                     }
[10:22:49.900]                     invisible(pathname)
[10:22:49.900]                   }
[10:22:49.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:49.900]                     rootPath = tempdir()) 
[10:22:49.900]                   {
[10:22:49.900]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:49.900]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:49.900]                       tmpdir = path, fileext = ".rds")
[10:22:49.900]                     save_rds(obj, file)
[10:22:49.900]                   }
[10:22:49.900]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:49.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.900]                   {
[10:22:49.900]                     inherits <- base::inherits
[10:22:49.900]                     invokeRestart <- base::invokeRestart
[10:22:49.900]                     is.null <- base::is.null
[10:22:49.900]                     muffled <- FALSE
[10:22:49.900]                     if (inherits(cond, "message")) {
[10:22:49.900]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.900]                       if (muffled) 
[10:22:49.900]                         invokeRestart("muffleMessage")
[10:22:49.900]                     }
[10:22:49.900]                     else if (inherits(cond, "warning")) {
[10:22:49.900]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.900]                       if (muffled) 
[10:22:49.900]                         invokeRestart("muffleWarning")
[10:22:49.900]                     }
[10:22:49.900]                     else if (inherits(cond, "condition")) {
[10:22:49.900]                       if (!is.null(pattern)) {
[10:22:49.900]                         computeRestarts <- base::computeRestarts
[10:22:49.900]                         grepl <- base::grepl
[10:22:49.900]                         restarts <- computeRestarts(cond)
[10:22:49.900]                         for (restart in restarts) {
[10:22:49.900]                           name <- restart$name
[10:22:49.900]                           if (is.null(name)) 
[10:22:49.900]                             next
[10:22:49.900]                           if (!grepl(pattern, name)) 
[10:22:49.900]                             next
[10:22:49.900]                           invokeRestart(restart)
[10:22:49.900]                           muffled <- TRUE
[10:22:49.900]                           break
[10:22:49.900]                         }
[10:22:49.900]                       }
[10:22:49.900]                     }
[10:22:49.900]                     invisible(muffled)
[10:22:49.900]                   }
[10:22:49.900]                   muffleCondition(cond)
[10:22:49.900]                 })
[10:22:49.900]             }))
[10:22:49.900]             future::FutureResult(value = ...future.value$value, 
[10:22:49.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.900]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.900]                     ...future.globalenv.names))
[10:22:49.900]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.900]         }, condition = base::local({
[10:22:49.900]             c <- base::c
[10:22:49.900]             inherits <- base::inherits
[10:22:49.900]             invokeRestart <- base::invokeRestart
[10:22:49.900]             length <- base::length
[10:22:49.900]             list <- base::list
[10:22:49.900]             seq.int <- base::seq.int
[10:22:49.900]             signalCondition <- base::signalCondition
[10:22:49.900]             sys.calls <- base::sys.calls
[10:22:49.900]             `[[` <- base::`[[`
[10:22:49.900]             `+` <- base::`+`
[10:22:49.900]             `<<-` <- base::`<<-`
[10:22:49.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.900]                   3L)]
[10:22:49.900]             }
[10:22:49.900]             function(cond) {
[10:22:49.900]                 is_error <- inherits(cond, "error")
[10:22:49.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.900]                   NULL)
[10:22:49.900]                 if (is_error) {
[10:22:49.900]                   sessionInformation <- function() {
[10:22:49.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.900]                       search = base::search(), system = base::Sys.info())
[10:22:49.900]                   }
[10:22:49.900]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.900]                     cond$call), session = sessionInformation(), 
[10:22:49.900]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.900]                   signalCondition(cond)
[10:22:49.900]                 }
[10:22:49.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.900]                 "immediateCondition"))) {
[10:22:49.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.900]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.900]                   if (TRUE && !signal) {
[10:22:49.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.900]                     {
[10:22:49.900]                       inherits <- base::inherits
[10:22:49.900]                       invokeRestart <- base::invokeRestart
[10:22:49.900]                       is.null <- base::is.null
[10:22:49.900]                       muffled <- FALSE
[10:22:49.900]                       if (inherits(cond, "message")) {
[10:22:49.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.900]                         if (muffled) 
[10:22:49.900]                           invokeRestart("muffleMessage")
[10:22:49.900]                       }
[10:22:49.900]                       else if (inherits(cond, "warning")) {
[10:22:49.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.900]                         if (muffled) 
[10:22:49.900]                           invokeRestart("muffleWarning")
[10:22:49.900]                       }
[10:22:49.900]                       else if (inherits(cond, "condition")) {
[10:22:49.900]                         if (!is.null(pattern)) {
[10:22:49.900]                           computeRestarts <- base::computeRestarts
[10:22:49.900]                           grepl <- base::grepl
[10:22:49.900]                           restarts <- computeRestarts(cond)
[10:22:49.900]                           for (restart in restarts) {
[10:22:49.900]                             name <- restart$name
[10:22:49.900]                             if (is.null(name)) 
[10:22:49.900]                               next
[10:22:49.900]                             if (!grepl(pattern, name)) 
[10:22:49.900]                               next
[10:22:49.900]                             invokeRestart(restart)
[10:22:49.900]                             muffled <- TRUE
[10:22:49.900]                             break
[10:22:49.900]                           }
[10:22:49.900]                         }
[10:22:49.900]                       }
[10:22:49.900]                       invisible(muffled)
[10:22:49.900]                     }
[10:22:49.900]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.900]                   }
[10:22:49.900]                 }
[10:22:49.900]                 else {
[10:22:49.900]                   if (TRUE) {
[10:22:49.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.900]                     {
[10:22:49.900]                       inherits <- base::inherits
[10:22:49.900]                       invokeRestart <- base::invokeRestart
[10:22:49.900]                       is.null <- base::is.null
[10:22:49.900]                       muffled <- FALSE
[10:22:49.900]                       if (inherits(cond, "message")) {
[10:22:49.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.900]                         if (muffled) 
[10:22:49.900]                           invokeRestart("muffleMessage")
[10:22:49.900]                       }
[10:22:49.900]                       else if (inherits(cond, "warning")) {
[10:22:49.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.900]                         if (muffled) 
[10:22:49.900]                           invokeRestart("muffleWarning")
[10:22:49.900]                       }
[10:22:49.900]                       else if (inherits(cond, "condition")) {
[10:22:49.900]                         if (!is.null(pattern)) {
[10:22:49.900]                           computeRestarts <- base::computeRestarts
[10:22:49.900]                           grepl <- base::grepl
[10:22:49.900]                           restarts <- computeRestarts(cond)
[10:22:49.900]                           for (restart in restarts) {
[10:22:49.900]                             name <- restart$name
[10:22:49.900]                             if (is.null(name)) 
[10:22:49.900]                               next
[10:22:49.900]                             if (!grepl(pattern, name)) 
[10:22:49.900]                               next
[10:22:49.900]                             invokeRestart(restart)
[10:22:49.900]                             muffled <- TRUE
[10:22:49.900]                             break
[10:22:49.900]                           }
[10:22:49.900]                         }
[10:22:49.900]                       }
[10:22:49.900]                       invisible(muffled)
[10:22:49.900]                     }
[10:22:49.900]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.900]                   }
[10:22:49.900]                 }
[10:22:49.900]             }
[10:22:49.900]         }))
[10:22:49.900]     }, error = function(ex) {
[10:22:49.900]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.900]                 ...future.rng), started = ...future.startTime, 
[10:22:49.900]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.900]             version = "1.8"), class = "FutureResult")
[10:22:49.900]     }, finally = {
[10:22:49.900]         if (!identical(...future.workdir, getwd())) 
[10:22:49.900]             setwd(...future.workdir)
[10:22:49.900]         {
[10:22:49.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.900]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.900]             }
[10:22:49.900]             base::options(...future.oldOptions)
[10:22:49.900]             if (.Platform$OS.type == "windows") {
[10:22:49.900]                 old_names <- names(...future.oldEnvVars)
[10:22:49.900]                 envs <- base::Sys.getenv()
[10:22:49.900]                 names <- names(envs)
[10:22:49.900]                 common <- intersect(names, old_names)
[10:22:49.900]                 added <- setdiff(names, old_names)
[10:22:49.900]                 removed <- setdiff(old_names, names)
[10:22:49.900]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.900]                   envs[common]]
[10:22:49.900]                 NAMES <- toupper(changed)
[10:22:49.900]                 args <- list()
[10:22:49.900]                 for (kk in seq_along(NAMES)) {
[10:22:49.900]                   name <- changed[[kk]]
[10:22:49.900]                   NAME <- NAMES[[kk]]
[10:22:49.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.900]                     next
[10:22:49.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.900]                 }
[10:22:49.900]                 NAMES <- toupper(added)
[10:22:49.900]                 for (kk in seq_along(NAMES)) {
[10:22:49.900]                   name <- added[[kk]]
[10:22:49.900]                   NAME <- NAMES[[kk]]
[10:22:49.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.900]                     next
[10:22:49.900]                   args[[name]] <- ""
[10:22:49.900]                 }
[10:22:49.900]                 NAMES <- toupper(removed)
[10:22:49.900]                 for (kk in seq_along(NAMES)) {
[10:22:49.900]                   name <- removed[[kk]]
[10:22:49.900]                   NAME <- NAMES[[kk]]
[10:22:49.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.900]                     next
[10:22:49.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.900]                 }
[10:22:49.900]                 if (length(args) > 0) 
[10:22:49.900]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.900]             }
[10:22:49.900]             else {
[10:22:49.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.900]             }
[10:22:49.900]             {
[10:22:49.900]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.900]                   0L) {
[10:22:49.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.900]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.900]                   base::options(opts)
[10:22:49.900]                 }
[10:22:49.900]                 {
[10:22:49.900]                   {
[10:22:49.900]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.900]                     NULL
[10:22:49.900]                   }
[10:22:49.900]                   options(future.plan = NULL)
[10:22:49.900]                   if (is.na(NA_character_)) 
[10:22:49.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.900]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.900]                     envir = parent.frame()) 
[10:22:49.900]                   {
[10:22:49.900]                     default_workers <- missing(workers)
[10:22:49.900]                     if (is.function(workers)) 
[10:22:49.900]                       workers <- workers()
[10:22:49.900]                     workers <- structure(as.integer(workers), 
[10:22:49.900]                       class = class(workers))
[10:22:49.900]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.900]                       1L)
[10:22:49.900]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.900]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.900]                       if (default_workers) 
[10:22:49.900]                         supportsMulticore(warn = TRUE)
[10:22:49.900]                       return(sequential(..., envir = envir))
[10:22:49.900]                     }
[10:22:49.900]                     oopts <- options(mc.cores = workers)
[10:22:49.900]                     on.exit(options(oopts))
[10:22:49.900]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.900]                       envir = envir)
[10:22:49.900]                     if (!future$lazy) 
[10:22:49.900]                       future <- run(future)
[10:22:49.900]                     invisible(future)
[10:22:49.900]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.900]                 }
[10:22:49.900]             }
[10:22:49.900]         }
[10:22:49.900]     })
[10:22:49.900]     if (TRUE) {
[10:22:49.900]         base::sink(type = "output", split = FALSE)
[10:22:49.900]         if (TRUE) {
[10:22:49.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.900]         }
[10:22:49.900]         else {
[10:22:49.900]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.900]         }
[10:22:49.900]         base::close(...future.stdout)
[10:22:49.900]         ...future.stdout <- NULL
[10:22:49.900]     }
[10:22:49.900]     ...future.result$conditions <- ...future.conditions
[10:22:49.900]     ...future.result$finished <- base::Sys.time()
[10:22:49.900]     ...future.result
[10:22:49.900] }
[10:22:49.903] assign_globals() ...
[10:22:49.903] List of 5
[10:22:49.903]  $ ...future.FUN            :function (object, ...)  
[10:22:49.903]  $ future.call.arguments    :List of 1
[10:22:49.903]   ..$ digits: int 2
[10:22:49.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.903]  $ ...future.elements_ii    :List of 3
[10:22:49.903]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:22:49.903]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:22:49.903]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:22:49.903]  $ ...future.seeds_ii       : NULL
[10:22:49.903]  $ ...future.globals.maxSize: NULL
[10:22:49.903]  - attr(*, "where")=List of 5
[10:22:49.903]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.903]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.903]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.903]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.903]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.903]  - attr(*, "resolved")= logi FALSE
[10:22:49.903]  - attr(*, "total_size")= num 1296
[10:22:49.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.903]  - attr(*, "already-done")= logi TRUE
[10:22:49.908] - copied ‘...future.FUN’ to environment
[10:22:49.908] - copied ‘future.call.arguments’ to environment
[10:22:49.908] - copied ‘...future.elements_ii’ to environment
[10:22:49.909] - copied ‘...future.seeds_ii’ to environment
[10:22:49.909] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.909] assign_globals() ... done
[10:22:49.909] requestCore(): workers = 2
[10:22:49.911] MulticoreFuture started
[10:22:49.911] - Launch lazy future ... done
[10:22:49.911] run() for ‘MulticoreFuture’ ... done
[10:22:49.912] Created future:
[10:22:49.912] plan(): Setting new future strategy stack:
[10:22:49.912] List of future strategies:
[10:22:49.912] 1. sequential:
[10:22:49.912]    - args: function (..., envir = parent.frame())
[10:22:49.912]    - tweaked: FALSE
[10:22:49.912]    - call: NULL
[10:22:49.913] plan(): nbrOfWorkers() = 1
[10:22:49.916] plan(): Setting new future strategy stack:
[10:22:49.916] List of future strategies:
[10:22:49.916] 1. multicore:
[10:22:49.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.916]    - tweaked: FALSE
[10:22:49.916]    - call: plan(strategy)
[10:22:49.921] plan(): nbrOfWorkers() = 2
[10:22:49.912] MulticoreFuture:
[10:22:49.912] Label: ‘future_by-1’
[10:22:49.912] Expression:
[10:22:49.912] {
[10:22:49.912]     do.call(function(...) {
[10:22:49.912]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.912]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.912]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.912]             on.exit(options(oopts), add = TRUE)
[10:22:49.912]         }
[10:22:49.912]         {
[10:22:49.912]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.912]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.912]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.912]             })
[10:22:49.912]         }
[10:22:49.912]     }, args = future.call.arguments)
[10:22:49.912] }
[10:22:49.912] Lazy evaluation: FALSE
[10:22:49.912] Asynchronous evaluation: TRUE
[10:22:49.912] Local evaluation: TRUE
[10:22:49.912] Environment: R_GlobalEnv
[10:22:49.912] Capture standard output: TRUE
[10:22:49.912] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.912] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.912] Packages: <none>
[10:22:49.912] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.912] Resolved: TRUE
[10:22:49.912] Value: <not collected>
[10:22:49.912] Conditions captured: <none>
[10:22:49.912] Early signaling: FALSE
[10:22:49.912] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.912] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.922] Chunk #1 of 2 ... DONE
[10:22:49.922] Chunk #2 of 2 ...
[10:22:49.923]  - Finding globals in 'X' for chunk #2 ...
[10:22:49.923] getGlobalsAndPackages() ...
[10:22:49.923] Searching for globals...
[10:22:49.923] 
[10:22:49.924] Searching for globals ... DONE
[10:22:49.924] - globals: [0] <none>
[10:22:49.924] getGlobalsAndPackages() ... DONE
[10:22:49.924]    + additional globals found: [n=0] 
[10:22:49.924]    + additional namespaces needed: [n=0] 
[10:22:49.924]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:49.924]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:49.924]  - seeds: <none>
[10:22:49.925]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.925] getGlobalsAndPackages() ...
[10:22:49.925] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.925] Resolving globals: FALSE
[10:22:49.925] Tweak future expression to call with '...' arguments ...
[10:22:49.925] {
[10:22:49.925]     do.call(function(...) {
[10:22:49.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.925]             on.exit(options(oopts), add = TRUE)
[10:22:49.925]         }
[10:22:49.925]         {
[10:22:49.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.925]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.925]             })
[10:22:49.925]         }
[10:22:49.925]     }, args = future.call.arguments)
[10:22:49.925] }
[10:22:49.926] Tweak future expression to call with '...' arguments ... DONE
[10:22:49.926] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:49.927] 
[10:22:49.927] getGlobalsAndPackages() ... DONE
[10:22:49.927] run() for ‘Future’ ...
[10:22:49.927] - state: ‘created’
[10:22:49.928] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.937] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:49.938]   - Field: ‘label’
[10:22:49.938]   - Field: ‘local’
[10:22:49.938]   - Field: ‘owner’
[10:22:49.938]   - Field: ‘envir’
[10:22:49.939]   - Field: ‘workers’
[10:22:49.939]   - Field: ‘packages’
[10:22:49.939]   - Field: ‘gc’
[10:22:49.939]   - Field: ‘job’
[10:22:49.939]   - Field: ‘conditions’
[10:22:49.940]   - Field: ‘expr’
[10:22:49.940]   - Field: ‘uuid’
[10:22:49.940]   - Field: ‘seed’
[10:22:49.940]   - Field: ‘version’
[10:22:49.941]   - Field: ‘result’
[10:22:49.941]   - Field: ‘asynchronous’
[10:22:49.941]   - Field: ‘calls’
[10:22:49.941]   - Field: ‘globals’
[10:22:49.941]   - Field: ‘stdout’
[10:22:49.942]   - Field: ‘earlySignal’
[10:22:49.942]   - Field: ‘lazy’
[10:22:49.942]   - Field: ‘state’
[10:22:49.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:49.942] - Launch lazy future ...
[10:22:49.943] Packages needed by the future expression (n = 0): <none>
[10:22:49.943] Packages needed by future strategies (n = 0): <none>
[10:22:49.944] {
[10:22:49.944]     {
[10:22:49.944]         {
[10:22:49.944]             ...future.startTime <- base::Sys.time()
[10:22:49.944]             {
[10:22:49.944]                 {
[10:22:49.944]                   {
[10:22:49.944]                     {
[10:22:49.944]                       base::local({
[10:22:49.944]                         has_future <- base::requireNamespace("future", 
[10:22:49.944]                           quietly = TRUE)
[10:22:49.944]                         if (has_future) {
[10:22:49.944]                           ns <- base::getNamespace("future")
[10:22:49.944]                           version <- ns[[".package"]][["version"]]
[10:22:49.944]                           if (is.null(version)) 
[10:22:49.944]                             version <- utils::packageVersion("future")
[10:22:49.944]                         }
[10:22:49.944]                         else {
[10:22:49.944]                           version <- NULL
[10:22:49.944]                         }
[10:22:49.944]                         if (!has_future || version < "1.8.0") {
[10:22:49.944]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.944]                             "", base::R.version$version.string), 
[10:22:49.944]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.944]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.944]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.944]                               "release", "version")], collapse = " "), 
[10:22:49.944]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.944]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.944]                             info)
[10:22:49.944]                           info <- base::paste(info, collapse = "; ")
[10:22:49.944]                           if (!has_future) {
[10:22:49.944]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.944]                               info)
[10:22:49.944]                           }
[10:22:49.944]                           else {
[10:22:49.944]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.944]                               info, version)
[10:22:49.944]                           }
[10:22:49.944]                           base::stop(msg)
[10:22:49.944]                         }
[10:22:49.944]                       })
[10:22:49.944]                     }
[10:22:49.944]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.944]                     base::options(mc.cores = 1L)
[10:22:49.944]                   }
[10:22:49.944]                   options(future.plan = NULL)
[10:22:49.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.944]                 }
[10:22:49.944]                 ...future.workdir <- getwd()
[10:22:49.944]             }
[10:22:49.944]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.944]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.944]         }
[10:22:49.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.944]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:49.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.944]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.944]             base::names(...future.oldOptions))
[10:22:49.944]     }
[10:22:49.944]     if (FALSE) {
[10:22:49.944]     }
[10:22:49.944]     else {
[10:22:49.944]         if (TRUE) {
[10:22:49.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.944]                 open = "w")
[10:22:49.944]         }
[10:22:49.944]         else {
[10:22:49.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.944]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.944]         }
[10:22:49.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.944]             base::sink(type = "output", split = FALSE)
[10:22:49.944]             base::close(...future.stdout)
[10:22:49.944]         }, add = TRUE)
[10:22:49.944]     }
[10:22:49.944]     ...future.frame <- base::sys.nframe()
[10:22:49.944]     ...future.conditions <- base::list()
[10:22:49.944]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.944]     if (FALSE) {
[10:22:49.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.944]     }
[10:22:49.944]     ...future.result <- base::tryCatch({
[10:22:49.944]         base::withCallingHandlers({
[10:22:49.944]             ...future.value <- base::withVisible(base::local({
[10:22:49.944]                 withCallingHandlers({
[10:22:49.944]                   {
[10:22:49.944]                     do.call(function(...) {
[10:22:49.944]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.944]                       if (!identical(...future.globals.maxSize.org, 
[10:22:49.944]                         ...future.globals.maxSize)) {
[10:22:49.944]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.944]                         on.exit(options(oopts), add = TRUE)
[10:22:49.944]                       }
[10:22:49.944]                       {
[10:22:49.944]                         lapply(seq_along(...future.elements_ii), 
[10:22:49.944]                           FUN = function(jj) {
[10:22:49.944]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.944]                             ...future.FUN(...future.X_jj, ...)
[10:22:49.944]                           })
[10:22:49.944]                       }
[10:22:49.944]                     }, args = future.call.arguments)
[10:22:49.944]                   }
[10:22:49.944]                 }, immediateCondition = function(cond) {
[10:22:49.944]                   save_rds <- function (object, pathname, ...) 
[10:22:49.944]                   {
[10:22:49.944]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:49.944]                     if (file_test("-f", pathname_tmp)) {
[10:22:49.944]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.944]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:49.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.944]                         fi_tmp[["mtime"]])
[10:22:49.944]                     }
[10:22:49.944]                     tryCatch({
[10:22:49.944]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:49.944]                     }, error = function(ex) {
[10:22:49.944]                       msg <- conditionMessage(ex)
[10:22:49.944]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.944]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:49.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.944]                         fi_tmp[["mtime"]], msg)
[10:22:49.944]                       ex$message <- msg
[10:22:49.944]                       stop(ex)
[10:22:49.944]                     })
[10:22:49.944]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:49.944]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:49.944]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:49.944]                       fi_tmp <- file.info(pathname_tmp)
[10:22:49.944]                       fi <- file.info(pathname)
[10:22:49.944]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:49.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:49.944]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:49.944]                         fi[["size"]], fi[["mtime"]])
[10:22:49.944]                       stop(msg)
[10:22:49.944]                     }
[10:22:49.944]                     invisible(pathname)
[10:22:49.944]                   }
[10:22:49.944]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:49.944]                     rootPath = tempdir()) 
[10:22:49.944]                   {
[10:22:49.944]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:49.944]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:49.944]                       tmpdir = path, fileext = ".rds")
[10:22:49.944]                     save_rds(obj, file)
[10:22:49.944]                   }
[10:22:49.944]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:49.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.944]                   {
[10:22:49.944]                     inherits <- base::inherits
[10:22:49.944]                     invokeRestart <- base::invokeRestart
[10:22:49.944]                     is.null <- base::is.null
[10:22:49.944]                     muffled <- FALSE
[10:22:49.944]                     if (inherits(cond, "message")) {
[10:22:49.944]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.944]                       if (muffled) 
[10:22:49.944]                         invokeRestart("muffleMessage")
[10:22:49.944]                     }
[10:22:49.944]                     else if (inherits(cond, "warning")) {
[10:22:49.944]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.944]                       if (muffled) 
[10:22:49.944]                         invokeRestart("muffleWarning")
[10:22:49.944]                     }
[10:22:49.944]                     else if (inherits(cond, "condition")) {
[10:22:49.944]                       if (!is.null(pattern)) {
[10:22:49.944]                         computeRestarts <- base::computeRestarts
[10:22:49.944]                         grepl <- base::grepl
[10:22:49.944]                         restarts <- computeRestarts(cond)
[10:22:49.944]                         for (restart in restarts) {
[10:22:49.944]                           name <- restart$name
[10:22:49.944]                           if (is.null(name)) 
[10:22:49.944]                             next
[10:22:49.944]                           if (!grepl(pattern, name)) 
[10:22:49.944]                             next
[10:22:49.944]                           invokeRestart(restart)
[10:22:49.944]                           muffled <- TRUE
[10:22:49.944]                           break
[10:22:49.944]                         }
[10:22:49.944]                       }
[10:22:49.944]                     }
[10:22:49.944]                     invisible(muffled)
[10:22:49.944]                   }
[10:22:49.944]                   muffleCondition(cond)
[10:22:49.944]                 })
[10:22:49.944]             }))
[10:22:49.944]             future::FutureResult(value = ...future.value$value, 
[10:22:49.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.944]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.944]                     ...future.globalenv.names))
[10:22:49.944]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.944]         }, condition = base::local({
[10:22:49.944]             c <- base::c
[10:22:49.944]             inherits <- base::inherits
[10:22:49.944]             invokeRestart <- base::invokeRestart
[10:22:49.944]             length <- base::length
[10:22:49.944]             list <- base::list
[10:22:49.944]             seq.int <- base::seq.int
[10:22:49.944]             signalCondition <- base::signalCondition
[10:22:49.944]             sys.calls <- base::sys.calls
[10:22:49.944]             `[[` <- base::`[[`
[10:22:49.944]             `+` <- base::`+`
[10:22:49.944]             `<<-` <- base::`<<-`
[10:22:49.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.944]                   3L)]
[10:22:49.944]             }
[10:22:49.944]             function(cond) {
[10:22:49.944]                 is_error <- inherits(cond, "error")
[10:22:49.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.944]                   NULL)
[10:22:49.944]                 if (is_error) {
[10:22:49.944]                   sessionInformation <- function() {
[10:22:49.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.944]                       search = base::search(), system = base::Sys.info())
[10:22:49.944]                   }
[10:22:49.944]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.944]                     cond$call), session = sessionInformation(), 
[10:22:49.944]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.944]                   signalCondition(cond)
[10:22:49.944]                 }
[10:22:49.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.944]                 "immediateCondition"))) {
[10:22:49.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.944]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.944]                   if (TRUE && !signal) {
[10:22:49.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.944]                     {
[10:22:49.944]                       inherits <- base::inherits
[10:22:49.944]                       invokeRestart <- base::invokeRestart
[10:22:49.944]                       is.null <- base::is.null
[10:22:49.944]                       muffled <- FALSE
[10:22:49.944]                       if (inherits(cond, "message")) {
[10:22:49.944]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.944]                         if (muffled) 
[10:22:49.944]                           invokeRestart("muffleMessage")
[10:22:49.944]                       }
[10:22:49.944]                       else if (inherits(cond, "warning")) {
[10:22:49.944]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.944]                         if (muffled) 
[10:22:49.944]                           invokeRestart("muffleWarning")
[10:22:49.944]                       }
[10:22:49.944]                       else if (inherits(cond, "condition")) {
[10:22:49.944]                         if (!is.null(pattern)) {
[10:22:49.944]                           computeRestarts <- base::computeRestarts
[10:22:49.944]                           grepl <- base::grepl
[10:22:49.944]                           restarts <- computeRestarts(cond)
[10:22:49.944]                           for (restart in restarts) {
[10:22:49.944]                             name <- restart$name
[10:22:49.944]                             if (is.null(name)) 
[10:22:49.944]                               next
[10:22:49.944]                             if (!grepl(pattern, name)) 
[10:22:49.944]                               next
[10:22:49.944]                             invokeRestart(restart)
[10:22:49.944]                             muffled <- TRUE
[10:22:49.944]                             break
[10:22:49.944]                           }
[10:22:49.944]                         }
[10:22:49.944]                       }
[10:22:49.944]                       invisible(muffled)
[10:22:49.944]                     }
[10:22:49.944]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.944]                   }
[10:22:49.944]                 }
[10:22:49.944]                 else {
[10:22:49.944]                   if (TRUE) {
[10:22:49.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.944]                     {
[10:22:49.944]                       inherits <- base::inherits
[10:22:49.944]                       invokeRestart <- base::invokeRestart
[10:22:49.944]                       is.null <- base::is.null
[10:22:49.944]                       muffled <- FALSE
[10:22:49.944]                       if (inherits(cond, "message")) {
[10:22:49.944]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.944]                         if (muffled) 
[10:22:49.944]                           invokeRestart("muffleMessage")
[10:22:49.944]                       }
[10:22:49.944]                       else if (inherits(cond, "warning")) {
[10:22:49.944]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.944]                         if (muffled) 
[10:22:49.944]                           invokeRestart("muffleWarning")
[10:22:49.944]                       }
[10:22:49.944]                       else if (inherits(cond, "condition")) {
[10:22:49.944]                         if (!is.null(pattern)) {
[10:22:49.944]                           computeRestarts <- base::computeRestarts
[10:22:49.944]                           grepl <- base::grepl
[10:22:49.944]                           restarts <- computeRestarts(cond)
[10:22:49.944]                           for (restart in restarts) {
[10:22:49.944]                             name <- restart$name
[10:22:49.944]                             if (is.null(name)) 
[10:22:49.944]                               next
[10:22:49.944]                             if (!grepl(pattern, name)) 
[10:22:49.944]                               next
[10:22:49.944]                             invokeRestart(restart)
[10:22:49.944]                             muffled <- TRUE
[10:22:49.944]                             break
[10:22:49.944]                           }
[10:22:49.944]                         }
[10:22:49.944]                       }
[10:22:49.944]                       invisible(muffled)
[10:22:49.944]                     }
[10:22:49.944]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.944]                   }
[10:22:49.944]                 }
[10:22:49.944]             }
[10:22:49.944]         }))
[10:22:49.944]     }, error = function(ex) {
[10:22:49.944]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.944]                 ...future.rng), started = ...future.startTime, 
[10:22:49.944]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.944]             version = "1.8"), class = "FutureResult")
[10:22:49.944]     }, finally = {
[10:22:49.944]         if (!identical(...future.workdir, getwd())) 
[10:22:49.944]             setwd(...future.workdir)
[10:22:49.944]         {
[10:22:49.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.944]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.944]             }
[10:22:49.944]             base::options(...future.oldOptions)
[10:22:49.944]             if (.Platform$OS.type == "windows") {
[10:22:49.944]                 old_names <- names(...future.oldEnvVars)
[10:22:49.944]                 envs <- base::Sys.getenv()
[10:22:49.944]                 names <- names(envs)
[10:22:49.944]                 common <- intersect(names, old_names)
[10:22:49.944]                 added <- setdiff(names, old_names)
[10:22:49.944]                 removed <- setdiff(old_names, names)
[10:22:49.944]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.944]                   envs[common]]
[10:22:49.944]                 NAMES <- toupper(changed)
[10:22:49.944]                 args <- list()
[10:22:49.944]                 for (kk in seq_along(NAMES)) {
[10:22:49.944]                   name <- changed[[kk]]
[10:22:49.944]                   NAME <- NAMES[[kk]]
[10:22:49.944]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.944]                     next
[10:22:49.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.944]                 }
[10:22:49.944]                 NAMES <- toupper(added)
[10:22:49.944]                 for (kk in seq_along(NAMES)) {
[10:22:49.944]                   name <- added[[kk]]
[10:22:49.944]                   NAME <- NAMES[[kk]]
[10:22:49.944]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.944]                     next
[10:22:49.944]                   args[[name]] <- ""
[10:22:49.944]                 }
[10:22:49.944]                 NAMES <- toupper(removed)
[10:22:49.944]                 for (kk in seq_along(NAMES)) {
[10:22:49.944]                   name <- removed[[kk]]
[10:22:49.944]                   NAME <- NAMES[[kk]]
[10:22:49.944]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.944]                     next
[10:22:49.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.944]                 }
[10:22:49.944]                 if (length(args) > 0) 
[10:22:49.944]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.944]             }
[10:22:49.944]             else {
[10:22:49.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.944]             }
[10:22:49.944]             {
[10:22:49.944]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.944]                   0L) {
[10:22:49.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.944]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.944]                   base::options(opts)
[10:22:49.944]                 }
[10:22:49.944]                 {
[10:22:49.944]                   {
[10:22:49.944]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.944]                     NULL
[10:22:49.944]                   }
[10:22:49.944]                   options(future.plan = NULL)
[10:22:49.944]                   if (is.na(NA_character_)) 
[10:22:49.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.944]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:49.944]                     envir = parent.frame()) 
[10:22:49.944]                   {
[10:22:49.944]                     default_workers <- missing(workers)
[10:22:49.944]                     if (is.function(workers)) 
[10:22:49.944]                       workers <- workers()
[10:22:49.944]                     workers <- structure(as.integer(workers), 
[10:22:49.944]                       class = class(workers))
[10:22:49.944]                     stop_if_not(is.finite(workers), workers >= 
[10:22:49.944]                       1L)
[10:22:49.944]                     if ((workers == 1L && !inherits(workers, 
[10:22:49.944]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:49.944]                       if (default_workers) 
[10:22:49.944]                         supportsMulticore(warn = TRUE)
[10:22:49.944]                       return(sequential(..., envir = envir))
[10:22:49.944]                     }
[10:22:49.944]                     oopts <- options(mc.cores = workers)
[10:22:49.944]                     on.exit(options(oopts))
[10:22:49.944]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:49.944]                       envir = envir)
[10:22:49.944]                     if (!future$lazy) 
[10:22:49.944]                       future <- run(future)
[10:22:49.944]                     invisible(future)
[10:22:49.944]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:49.944]                 }
[10:22:49.944]             }
[10:22:49.944]         }
[10:22:49.944]     })
[10:22:49.944]     if (TRUE) {
[10:22:49.944]         base::sink(type = "output", split = FALSE)
[10:22:49.944]         if (TRUE) {
[10:22:49.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.944]         }
[10:22:49.944]         else {
[10:22:49.944]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.944]         }
[10:22:49.944]         base::close(...future.stdout)
[10:22:49.944]         ...future.stdout <- NULL
[10:22:49.944]     }
[10:22:49.944]     ...future.result$conditions <- ...future.conditions
[10:22:49.944]     ...future.result$finished <- base::Sys.time()
[10:22:49.944]     ...future.result
[10:22:49.944] }
[10:22:49.947] assign_globals() ...
[10:22:49.947] List of 5
[10:22:49.947]  $ ...future.FUN            :function (object, ...)  
[10:22:49.947]  $ future.call.arguments    :List of 1
[10:22:49.947]   ..$ digits: int 2
[10:22:49.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:49.947]  $ ...future.elements_ii    :List of 3
[10:22:49.947]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:22:49.947]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:22:49.947]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:22:49.947]  $ ...future.seeds_ii       : NULL
[10:22:49.947]  $ ...future.globals.maxSize: NULL
[10:22:49.947]  - attr(*, "where")=List of 5
[10:22:49.947]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:49.947]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:49.947]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:49.947]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:49.947]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:49.947]  - attr(*, "resolved")= logi FALSE
[10:22:49.947]  - attr(*, "total_size")= num 1296
[10:22:49.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:49.947]  - attr(*, "already-done")= logi TRUE
[10:22:49.956] - copied ‘...future.FUN’ to environment
[10:22:49.956] - copied ‘future.call.arguments’ to environment
[10:22:49.956] - copied ‘...future.elements_ii’ to environment
[10:22:49.956] - copied ‘...future.seeds_ii’ to environment
[10:22:49.956] - copied ‘...future.globals.maxSize’ to environment
[10:22:49.956] assign_globals() ... done
[10:22:49.956] requestCore(): workers = 2
[10:22:49.958] MulticoreFuture started
[10:22:49.959] - Launch lazy future ... done
[10:22:49.959] run() for ‘MulticoreFuture’ ... done
[10:22:49.959] Created future:
[10:22:49.960] plan(): Setting new future strategy stack:
[10:22:49.960] List of future strategies:
[10:22:49.960] 1. sequential:
[10:22:49.960]    - args: function (..., envir = parent.frame())
[10:22:49.960]    - tweaked: FALSE
[10:22:49.960]    - call: NULL
[10:22:49.961] plan(): nbrOfWorkers() = 1
[10:22:49.963] plan(): Setting new future strategy stack:
[10:22:49.964] List of future strategies:
[10:22:49.964] 1. multicore:
[10:22:49.964]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:49.964]    - tweaked: FALSE
[10:22:49.964]    - call: plan(strategy)
[10:22:49.969] plan(): nbrOfWorkers() = 2
[10:22:49.960] MulticoreFuture:
[10:22:49.960] Label: ‘future_by-2’
[10:22:49.960] Expression:
[10:22:49.960] {
[10:22:49.960]     do.call(function(...) {
[10:22:49.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:49.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:49.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:49.960]             on.exit(options(oopts), add = TRUE)
[10:22:49.960]         }
[10:22:49.960]         {
[10:22:49.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:49.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:49.960]                 ...future.FUN(...future.X_jj, ...)
[10:22:49.960]             })
[10:22:49.960]         }
[10:22:49.960]     }, args = future.call.arguments)
[10:22:49.960] }
[10:22:49.960] Lazy evaluation: FALSE
[10:22:49.960] Asynchronous evaluation: TRUE
[10:22:49.960] Local evaluation: TRUE
[10:22:49.960] Environment: R_GlobalEnv
[10:22:49.960] Capture standard output: TRUE
[10:22:49.960] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:49.960] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:49.960] Packages: <none>
[10:22:49.960] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:49.960] Resolved: TRUE
[10:22:49.960] Value: <not collected>
[10:22:49.960] Conditions captured: <none>
[10:22:49.960] Early signaling: FALSE
[10:22:49.960] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:49.960] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.970] Chunk #2 of 2 ... DONE
[10:22:49.970] Launching 2 futures (chunks) ... DONE
[10:22:49.970] Resolving 2 futures (chunks) ...
[10:22:49.970] resolve() on list ...
[10:22:49.971]  recursive: 0
[10:22:49.971]  length: 2
[10:22:49.971] 
[10:22:49.971] Future #1
[10:22:49.971] result() for MulticoreFuture ...
[10:22:49.972] result() for MulticoreFuture ...
[10:22:49.972] result() for MulticoreFuture ... done
[10:22:49.972] result() for MulticoreFuture ... done
[10:22:49.973] result() for MulticoreFuture ...
[10:22:49.973] result() for MulticoreFuture ... done
[10:22:49.973] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:49.973] - nx: 2
[10:22:49.973] - relay: TRUE
[10:22:49.973] - stdout: TRUE
[10:22:49.974] - signal: TRUE
[10:22:49.974] - resignal: FALSE
[10:22:49.974] - force: TRUE
[10:22:49.974] - relayed: [n=2] FALSE, FALSE
[10:22:49.974] - queued futures: [n=2] FALSE, FALSE
[10:22:49.974]  - until=1
[10:22:49.974]  - relaying element #1
[10:22:49.974] result() for MulticoreFuture ...
[10:22:49.975] result() for MulticoreFuture ... done
[10:22:49.975] result() for MulticoreFuture ...
[10:22:49.975] result() for MulticoreFuture ... done
[10:22:49.975] result() for MulticoreFuture ...
[10:22:49.975] result() for MulticoreFuture ... done
[10:22:49.975] result() for MulticoreFuture ...
[10:22:49.975] result() for MulticoreFuture ... done
[10:22:49.976] - relayed: [n=2] TRUE, FALSE
[10:22:49.976] - queued futures: [n=2] TRUE, FALSE
[10:22:49.976] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:49.976]  length: 1 (resolved future 1)
[10:22:49.976] Future #2
[10:22:49.977] result() for MulticoreFuture ...
[10:22:49.977] result() for MulticoreFuture ...
[10:22:49.977] result() for MulticoreFuture ... done
[10:22:49.977] result() for MulticoreFuture ... done
[10:22:49.978] result() for MulticoreFuture ...
[10:22:49.978] result() for MulticoreFuture ... done
[10:22:49.980] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:49.981] - nx: 2
[10:22:49.981] - relay: TRUE
[10:22:49.981] - stdout: TRUE
[10:22:49.981] - signal: TRUE
[10:22:49.981] - resignal: FALSE
[10:22:49.982] - force: TRUE
[10:22:49.982] - relayed: [n=2] TRUE, FALSE
[10:22:49.982] - queued futures: [n=2] TRUE, FALSE
[10:22:49.982]  - until=2
[10:22:49.982]  - relaying element #2
[10:22:49.982] result() for MulticoreFuture ...
[10:22:49.983] result() for MulticoreFuture ... done
[10:22:49.983] result() for MulticoreFuture ...
[10:22:49.983] result() for MulticoreFuture ... done
[10:22:49.983] result() for MulticoreFuture ...
[10:22:49.983] result() for MulticoreFuture ... done
[10:22:49.983] result() for MulticoreFuture ...
[10:22:49.984] result() for MulticoreFuture ... done
[10:22:49.984] - relayed: [n=2] TRUE, TRUE
[10:22:49.984] - queued futures: [n=2] TRUE, TRUE
[10:22:49.984] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:49.984]  length: 0 (resolved future 2)
[10:22:49.984] Relaying remaining futures
[10:22:49.984] signalConditionsASAP(NULL, pos=0) ...
[10:22:49.985] - nx: 2
[10:22:49.985] - relay: TRUE
[10:22:49.985] - stdout: TRUE
[10:22:49.985] - signal: TRUE
[10:22:49.985] - resignal: FALSE
[10:22:49.985] - force: TRUE
[10:22:49.985] - relayed: [n=2] TRUE, TRUE
[10:22:49.985] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:49.986] - relayed: [n=2] TRUE, TRUE
[10:22:49.986] - queued futures: [n=2] TRUE, TRUE
[10:22:49.986] signalConditionsASAP(NULL, pos=0) ... done
[10:22:49.986] resolve() on list ... DONE
[10:22:49.986] result() for MulticoreFuture ...
[10:22:49.986] result() for MulticoreFuture ... done
[10:22:49.987] result() for MulticoreFuture ...
[10:22:49.987] result() for MulticoreFuture ... done
[10:22:49.987] result() for MulticoreFuture ...
[10:22:49.987] result() for MulticoreFuture ... done
[10:22:49.987] result() for MulticoreFuture ...
[10:22:49.987] result() for MulticoreFuture ... done
[10:22:49.987]  - Number of value chunks collected: 2
[10:22:49.988] Resolving 2 futures (chunks) ... DONE
[10:22:49.988] Reducing values from 2 chunks ...
[10:22:49.988]  - Number of values collected after concatenation: 6
[10:22:49.988]  - Number of values expected: 6
[10:22:49.988] Reducing values from 2 chunks ... DONE
[10:22:49.988] future_lapply() ... DONE
[10:22:49.988] future_by_internal() ... DONE
[10:22:49.990] future_by_internal() ...
[10:22:49.990] future_lapply() ...
[10:22:49.995] Number of chunks: 2
[10:22:49.995] getGlobalsAndPackagesXApply() ...
[10:22:49.995]  - future.globals: TRUE
[10:22:49.995] getGlobalsAndPackages() ...
[10:22:49.996] Searching for globals...
[10:22:49.997] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:49.997] Searching for globals ... DONE
[10:22:49.998] Resolving globals: FALSE
[10:22:49.998] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:22:49.998] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:22:49.999] - globals: [1] ‘FUN’
[10:22:49.999] - packages: [1] ‘stats’
[10:22:49.999] getGlobalsAndPackages() ... DONE
[10:22:49.999]  - globals found/used: [n=1] ‘FUN’
[10:22:49.999]  - needed namespaces: [n=1] ‘stats’
[10:22:49.999] Finding globals ... DONE
[10:22:49.999]  - use_args: TRUE
[10:22:49.999]  - Getting '...' globals ...
[10:22:50.000] resolve() on list ...
[10:22:50.000]  recursive: 0
[10:22:50.000]  length: 1
[10:22:50.000]  elements: ‘...’
[10:22:50.000]  length: 0 (resolved future 1)
[10:22:50.000] resolve() on list ... DONE
[10:22:50.000]    - '...' content: [n=1] ‘singular.ok’
[10:22:50.000] List of 1
[10:22:50.000]  $ ...:List of 1
[10:22:50.000]   ..$ singular.ok: logi FALSE
[10:22:50.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.000]  - attr(*, "where")=List of 1
[10:22:50.000]   ..$ ...:<environment: 0x55f638799610> 
[10:22:50.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.000]  - attr(*, "resolved")= logi TRUE
[10:22:50.000]  - attr(*, "total_size")= num NA
[10:22:50.003]  - Getting '...' globals ... DONE
[10:22:50.003] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:50.004] List of 2
[10:22:50.004]  $ ...future.FUN:function (x, ...)  
[10:22:50.004]  $ ...          :List of 1
[10:22:50.004]   ..$ singular.ok: logi FALSE
[10:22:50.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.004]  - attr(*, "where")=List of 2
[10:22:50.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:50.004]   ..$ ...          :<environment: 0x55f638799610> 
[10:22:50.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.004]  - attr(*, "resolved")= logi FALSE
[10:22:50.004]  - attr(*, "total_size")= num 5384
[10:22:50.008] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:50.009] getGlobalsAndPackagesXApply() ... DONE
[10:22:50.009] Number of futures (= number of chunks): 2
[10:22:50.009] Launching 2 futures (chunks) ...
[10:22:50.009] Chunk #1 of 2 ...
[10:22:50.009]  - Finding globals in 'X' for chunk #1 ...
[10:22:50.009] getGlobalsAndPackages() ...
[10:22:50.009] Searching for globals...
[10:22:50.010] 
[10:22:50.010] Searching for globals ... DONE
[10:22:50.010] - globals: [0] <none>
[10:22:50.010] getGlobalsAndPackages() ... DONE
[10:22:50.010]    + additional globals found: [n=0] 
[10:22:50.010]    + additional namespaces needed: [n=0] 
[10:22:50.010]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:50.010]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.010]  - seeds: <none>
[10:22:50.010]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.011] getGlobalsAndPackages() ...
[10:22:50.011] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.011] Resolving globals: FALSE
[10:22:50.011] Tweak future expression to call with '...' arguments ...
[10:22:50.011] {
[10:22:50.011]     do.call(function(...) {
[10:22:50.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.011]             on.exit(options(oopts), add = TRUE)
[10:22:50.011]         }
[10:22:50.011]         {
[10:22:50.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.011]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.011]             })
[10:22:50.011]         }
[10:22:50.011]     }, args = future.call.arguments)
[10:22:50.011] }
[10:22:50.011] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.012] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.012] 
[10:22:50.012] getGlobalsAndPackages() ... DONE
[10:22:50.012] run() for ‘Future’ ...
[10:22:50.012] - state: ‘created’
[10:22:50.012] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.016]   - Field: ‘label’
[10:22:50.016]   - Field: ‘local’
[10:22:50.016]   - Field: ‘owner’
[10:22:50.017]   - Field: ‘envir’
[10:22:50.017]   - Field: ‘workers’
[10:22:50.017]   - Field: ‘packages’
[10:22:50.017]   - Field: ‘gc’
[10:22:50.017]   - Field: ‘job’
[10:22:50.017]   - Field: ‘conditions’
[10:22:50.017]   - Field: ‘expr’
[10:22:50.017]   - Field: ‘uuid’
[10:22:50.017]   - Field: ‘seed’
[10:22:50.017]   - Field: ‘version’
[10:22:50.017]   - Field: ‘result’
[10:22:50.018]   - Field: ‘asynchronous’
[10:22:50.018]   - Field: ‘calls’
[10:22:50.018]   - Field: ‘globals’
[10:22:50.018]   - Field: ‘stdout’
[10:22:50.018]   - Field: ‘earlySignal’
[10:22:50.018]   - Field: ‘lazy’
[10:22:50.018]   - Field: ‘state’
[10:22:50.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.018] - Launch lazy future ...
[10:22:50.019] Packages needed by the future expression (n = 1): ‘stats’
[10:22:50.019] Packages needed by future strategies (n = 0): <none>
[10:22:50.019] {
[10:22:50.019]     {
[10:22:50.019]         {
[10:22:50.019]             ...future.startTime <- base::Sys.time()
[10:22:50.019]             {
[10:22:50.019]                 {
[10:22:50.019]                   {
[10:22:50.019]                     {
[10:22:50.019]                       {
[10:22:50.019]                         base::local({
[10:22:50.019]                           has_future <- base::requireNamespace("future", 
[10:22:50.019]                             quietly = TRUE)
[10:22:50.019]                           if (has_future) {
[10:22:50.019]                             ns <- base::getNamespace("future")
[10:22:50.019]                             version <- ns[[".package"]][["version"]]
[10:22:50.019]                             if (is.null(version)) 
[10:22:50.019]                               version <- utils::packageVersion("future")
[10:22:50.019]                           }
[10:22:50.019]                           else {
[10:22:50.019]                             version <- NULL
[10:22:50.019]                           }
[10:22:50.019]                           if (!has_future || version < "1.8.0") {
[10:22:50.019]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.019]                               "", base::R.version$version.string), 
[10:22:50.019]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:50.019]                                 base::R.version$platform, 8 * 
[10:22:50.019]                                   base::.Machine$sizeof.pointer), 
[10:22:50.019]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.019]                                 "release", "version")], collapse = " "), 
[10:22:50.019]                               hostname = base::Sys.info()[["nodename"]])
[10:22:50.019]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.019]                               info)
[10:22:50.019]                             info <- base::paste(info, collapse = "; ")
[10:22:50.019]                             if (!has_future) {
[10:22:50.019]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.019]                                 info)
[10:22:50.019]                             }
[10:22:50.019]                             else {
[10:22:50.019]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.019]                                 info, version)
[10:22:50.019]                             }
[10:22:50.019]                             base::stop(msg)
[10:22:50.019]                           }
[10:22:50.019]                         })
[10:22:50.019]                       }
[10:22:50.019]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.019]                       base::options(mc.cores = 1L)
[10:22:50.019]                     }
[10:22:50.019]                     base::local({
[10:22:50.019]                       for (pkg in "stats") {
[10:22:50.019]                         base::loadNamespace(pkg)
[10:22:50.019]                         base::library(pkg, character.only = TRUE)
[10:22:50.019]                       }
[10:22:50.019]                     })
[10:22:50.019]                   }
[10:22:50.019]                   options(future.plan = NULL)
[10:22:50.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.019]                 }
[10:22:50.019]                 ...future.workdir <- getwd()
[10:22:50.019]             }
[10:22:50.019]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.019]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.019]         }
[10:22:50.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.019]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.019]             base::names(...future.oldOptions))
[10:22:50.019]     }
[10:22:50.019]     if (FALSE) {
[10:22:50.019]     }
[10:22:50.019]     else {
[10:22:50.019]         if (TRUE) {
[10:22:50.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.019]                 open = "w")
[10:22:50.019]         }
[10:22:50.019]         else {
[10:22:50.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.019]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.019]         }
[10:22:50.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.019]             base::sink(type = "output", split = FALSE)
[10:22:50.019]             base::close(...future.stdout)
[10:22:50.019]         }, add = TRUE)
[10:22:50.019]     }
[10:22:50.019]     ...future.frame <- base::sys.nframe()
[10:22:50.019]     ...future.conditions <- base::list()
[10:22:50.019]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.019]     if (FALSE) {
[10:22:50.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.019]     }
[10:22:50.019]     ...future.result <- base::tryCatch({
[10:22:50.019]         base::withCallingHandlers({
[10:22:50.019]             ...future.value <- base::withVisible(base::local({
[10:22:50.019]                 withCallingHandlers({
[10:22:50.019]                   {
[10:22:50.019]                     do.call(function(...) {
[10:22:50.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.019]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.019]                         ...future.globals.maxSize)) {
[10:22:50.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.019]                         on.exit(options(oopts), add = TRUE)
[10:22:50.019]                       }
[10:22:50.019]                       {
[10:22:50.019]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.019]                           FUN = function(jj) {
[10:22:50.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.019]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.019]                           })
[10:22:50.019]                       }
[10:22:50.019]                     }, args = future.call.arguments)
[10:22:50.019]                   }
[10:22:50.019]                 }, immediateCondition = function(cond) {
[10:22:50.019]                   save_rds <- function (object, pathname, ...) 
[10:22:50.019]                   {
[10:22:50.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.019]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.019]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.019]                         fi_tmp[["mtime"]])
[10:22:50.019]                     }
[10:22:50.019]                     tryCatch({
[10:22:50.019]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.019]                     }, error = function(ex) {
[10:22:50.019]                       msg <- conditionMessage(ex)
[10:22:50.019]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.019]                         fi_tmp[["mtime"]], msg)
[10:22:50.019]                       ex$message <- msg
[10:22:50.019]                       stop(ex)
[10:22:50.019]                     })
[10:22:50.019]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.019]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.019]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.019]                       fi <- file.info(pathname)
[10:22:50.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.019]                         fi[["size"]], fi[["mtime"]])
[10:22:50.019]                       stop(msg)
[10:22:50.019]                     }
[10:22:50.019]                     invisible(pathname)
[10:22:50.019]                   }
[10:22:50.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.019]                     rootPath = tempdir()) 
[10:22:50.019]                   {
[10:22:50.019]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.019]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.019]                       tmpdir = path, fileext = ".rds")
[10:22:50.019]                     save_rds(obj, file)
[10:22:50.019]                   }
[10:22:50.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.019]                   {
[10:22:50.019]                     inherits <- base::inherits
[10:22:50.019]                     invokeRestart <- base::invokeRestart
[10:22:50.019]                     is.null <- base::is.null
[10:22:50.019]                     muffled <- FALSE
[10:22:50.019]                     if (inherits(cond, "message")) {
[10:22:50.019]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.019]                       if (muffled) 
[10:22:50.019]                         invokeRestart("muffleMessage")
[10:22:50.019]                     }
[10:22:50.019]                     else if (inherits(cond, "warning")) {
[10:22:50.019]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.019]                       if (muffled) 
[10:22:50.019]                         invokeRestart("muffleWarning")
[10:22:50.019]                     }
[10:22:50.019]                     else if (inherits(cond, "condition")) {
[10:22:50.019]                       if (!is.null(pattern)) {
[10:22:50.019]                         computeRestarts <- base::computeRestarts
[10:22:50.019]                         grepl <- base::grepl
[10:22:50.019]                         restarts <- computeRestarts(cond)
[10:22:50.019]                         for (restart in restarts) {
[10:22:50.019]                           name <- restart$name
[10:22:50.019]                           if (is.null(name)) 
[10:22:50.019]                             next
[10:22:50.019]                           if (!grepl(pattern, name)) 
[10:22:50.019]                             next
[10:22:50.019]                           invokeRestart(restart)
[10:22:50.019]                           muffled <- TRUE
[10:22:50.019]                           break
[10:22:50.019]                         }
[10:22:50.019]                       }
[10:22:50.019]                     }
[10:22:50.019]                     invisible(muffled)
[10:22:50.019]                   }
[10:22:50.019]                   muffleCondition(cond)
[10:22:50.019]                 })
[10:22:50.019]             }))
[10:22:50.019]             future::FutureResult(value = ...future.value$value, 
[10:22:50.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.019]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.019]                     ...future.globalenv.names))
[10:22:50.019]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.019]         }, condition = base::local({
[10:22:50.019]             c <- base::c
[10:22:50.019]             inherits <- base::inherits
[10:22:50.019]             invokeRestart <- base::invokeRestart
[10:22:50.019]             length <- base::length
[10:22:50.019]             list <- base::list
[10:22:50.019]             seq.int <- base::seq.int
[10:22:50.019]             signalCondition <- base::signalCondition
[10:22:50.019]             sys.calls <- base::sys.calls
[10:22:50.019]             `[[` <- base::`[[`
[10:22:50.019]             `+` <- base::`+`
[10:22:50.019]             `<<-` <- base::`<<-`
[10:22:50.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.019]                   3L)]
[10:22:50.019]             }
[10:22:50.019]             function(cond) {
[10:22:50.019]                 is_error <- inherits(cond, "error")
[10:22:50.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.019]                   NULL)
[10:22:50.019]                 if (is_error) {
[10:22:50.019]                   sessionInformation <- function() {
[10:22:50.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.019]                       search = base::search(), system = base::Sys.info())
[10:22:50.019]                   }
[10:22:50.019]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.019]                     cond$call), session = sessionInformation(), 
[10:22:50.019]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.019]                   signalCondition(cond)
[10:22:50.019]                 }
[10:22:50.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.019]                 "immediateCondition"))) {
[10:22:50.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.019]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.019]                   if (TRUE && !signal) {
[10:22:50.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.019]                     {
[10:22:50.019]                       inherits <- base::inherits
[10:22:50.019]                       invokeRestart <- base::invokeRestart
[10:22:50.019]                       is.null <- base::is.null
[10:22:50.019]                       muffled <- FALSE
[10:22:50.019]                       if (inherits(cond, "message")) {
[10:22:50.019]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.019]                         if (muffled) 
[10:22:50.019]                           invokeRestart("muffleMessage")
[10:22:50.019]                       }
[10:22:50.019]                       else if (inherits(cond, "warning")) {
[10:22:50.019]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.019]                         if (muffled) 
[10:22:50.019]                           invokeRestart("muffleWarning")
[10:22:50.019]                       }
[10:22:50.019]                       else if (inherits(cond, "condition")) {
[10:22:50.019]                         if (!is.null(pattern)) {
[10:22:50.019]                           computeRestarts <- base::computeRestarts
[10:22:50.019]                           grepl <- base::grepl
[10:22:50.019]                           restarts <- computeRestarts(cond)
[10:22:50.019]                           for (restart in restarts) {
[10:22:50.019]                             name <- restart$name
[10:22:50.019]                             if (is.null(name)) 
[10:22:50.019]                               next
[10:22:50.019]                             if (!grepl(pattern, name)) 
[10:22:50.019]                               next
[10:22:50.019]                             invokeRestart(restart)
[10:22:50.019]                             muffled <- TRUE
[10:22:50.019]                             break
[10:22:50.019]                           }
[10:22:50.019]                         }
[10:22:50.019]                       }
[10:22:50.019]                       invisible(muffled)
[10:22:50.019]                     }
[10:22:50.019]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.019]                   }
[10:22:50.019]                 }
[10:22:50.019]                 else {
[10:22:50.019]                   if (TRUE) {
[10:22:50.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.019]                     {
[10:22:50.019]                       inherits <- base::inherits
[10:22:50.019]                       invokeRestart <- base::invokeRestart
[10:22:50.019]                       is.null <- base::is.null
[10:22:50.019]                       muffled <- FALSE
[10:22:50.019]                       if (inherits(cond, "message")) {
[10:22:50.019]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.019]                         if (muffled) 
[10:22:50.019]                           invokeRestart("muffleMessage")
[10:22:50.019]                       }
[10:22:50.019]                       else if (inherits(cond, "warning")) {
[10:22:50.019]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.019]                         if (muffled) 
[10:22:50.019]                           invokeRestart("muffleWarning")
[10:22:50.019]                       }
[10:22:50.019]                       else if (inherits(cond, "condition")) {
[10:22:50.019]                         if (!is.null(pattern)) {
[10:22:50.019]                           computeRestarts <- base::computeRestarts
[10:22:50.019]                           grepl <- base::grepl
[10:22:50.019]                           restarts <- computeRestarts(cond)
[10:22:50.019]                           for (restart in restarts) {
[10:22:50.019]                             name <- restart$name
[10:22:50.019]                             if (is.null(name)) 
[10:22:50.019]                               next
[10:22:50.019]                             if (!grepl(pattern, name)) 
[10:22:50.019]                               next
[10:22:50.019]                             invokeRestart(restart)
[10:22:50.019]                             muffled <- TRUE
[10:22:50.019]                             break
[10:22:50.019]                           }
[10:22:50.019]                         }
[10:22:50.019]                       }
[10:22:50.019]                       invisible(muffled)
[10:22:50.019]                     }
[10:22:50.019]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.019]                   }
[10:22:50.019]                 }
[10:22:50.019]             }
[10:22:50.019]         }))
[10:22:50.019]     }, error = function(ex) {
[10:22:50.019]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.019]                 ...future.rng), started = ...future.startTime, 
[10:22:50.019]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.019]             version = "1.8"), class = "FutureResult")
[10:22:50.019]     }, finally = {
[10:22:50.019]         if (!identical(...future.workdir, getwd())) 
[10:22:50.019]             setwd(...future.workdir)
[10:22:50.019]         {
[10:22:50.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.019]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.019]             }
[10:22:50.019]             base::options(...future.oldOptions)
[10:22:50.019]             if (.Platform$OS.type == "windows") {
[10:22:50.019]                 old_names <- names(...future.oldEnvVars)
[10:22:50.019]                 envs <- base::Sys.getenv()
[10:22:50.019]                 names <- names(envs)
[10:22:50.019]                 common <- intersect(names, old_names)
[10:22:50.019]                 added <- setdiff(names, old_names)
[10:22:50.019]                 removed <- setdiff(old_names, names)
[10:22:50.019]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.019]                   envs[common]]
[10:22:50.019]                 NAMES <- toupper(changed)
[10:22:50.019]                 args <- list()
[10:22:50.019]                 for (kk in seq_along(NAMES)) {
[10:22:50.019]                   name <- changed[[kk]]
[10:22:50.019]                   NAME <- NAMES[[kk]]
[10:22:50.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.019]                     next
[10:22:50.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.019]                 }
[10:22:50.019]                 NAMES <- toupper(added)
[10:22:50.019]                 for (kk in seq_along(NAMES)) {
[10:22:50.019]                   name <- added[[kk]]
[10:22:50.019]                   NAME <- NAMES[[kk]]
[10:22:50.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.019]                     next
[10:22:50.019]                   args[[name]] <- ""
[10:22:50.019]                 }
[10:22:50.019]                 NAMES <- toupper(removed)
[10:22:50.019]                 for (kk in seq_along(NAMES)) {
[10:22:50.019]                   name <- removed[[kk]]
[10:22:50.019]                   NAME <- NAMES[[kk]]
[10:22:50.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.019]                     next
[10:22:50.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.019]                 }
[10:22:50.019]                 if (length(args) > 0) 
[10:22:50.019]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.019]             }
[10:22:50.019]             else {
[10:22:50.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.019]             }
[10:22:50.019]             {
[10:22:50.019]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.019]                   0L) {
[10:22:50.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.019]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.019]                   base::options(opts)
[10:22:50.019]                 }
[10:22:50.019]                 {
[10:22:50.019]                   {
[10:22:50.019]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.019]                     NULL
[10:22:50.019]                   }
[10:22:50.019]                   options(future.plan = NULL)
[10:22:50.019]                   if (is.na(NA_character_)) 
[10:22:50.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.019]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.019]                     envir = parent.frame()) 
[10:22:50.019]                   {
[10:22:50.019]                     default_workers <- missing(workers)
[10:22:50.019]                     if (is.function(workers)) 
[10:22:50.019]                       workers <- workers()
[10:22:50.019]                     workers <- structure(as.integer(workers), 
[10:22:50.019]                       class = class(workers))
[10:22:50.019]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.019]                       1L)
[10:22:50.019]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.019]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.019]                       if (default_workers) 
[10:22:50.019]                         supportsMulticore(warn = TRUE)
[10:22:50.019]                       return(sequential(..., envir = envir))
[10:22:50.019]                     }
[10:22:50.019]                     oopts <- options(mc.cores = workers)
[10:22:50.019]                     on.exit(options(oopts))
[10:22:50.019]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.019]                       envir = envir)
[10:22:50.019]                     if (!future$lazy) 
[10:22:50.019]                       future <- run(future)
[10:22:50.019]                     invisible(future)
[10:22:50.019]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.019]                 }
[10:22:50.019]             }
[10:22:50.019]         }
[10:22:50.019]     })
[10:22:50.019]     if (TRUE) {
[10:22:50.019]         base::sink(type = "output", split = FALSE)
[10:22:50.019]         if (TRUE) {
[10:22:50.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.019]         }
[10:22:50.019]         else {
[10:22:50.019]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.019]         }
[10:22:50.019]         base::close(...future.stdout)
[10:22:50.019]         ...future.stdout <- NULL
[10:22:50.019]     }
[10:22:50.019]     ...future.result$conditions <- ...future.conditions
[10:22:50.019]     ...future.result$finished <- base::Sys.time()
[10:22:50.019]     ...future.result
[10:22:50.019] }
[10:22:50.022] assign_globals() ...
[10:22:50.022] List of 5
[10:22:50.022]  $ ...future.FUN            :function (x, ...)  
[10:22:50.022]  $ future.call.arguments    :List of 1
[10:22:50.022]   ..$ singular.ok: logi FALSE
[10:22:50.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.022]  $ ...future.elements_ii    :List of 1
[10:22:50.022]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.022]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:50.022]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.022]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.022]  $ ...future.seeds_ii       : NULL
[10:22:50.022]  $ ...future.globals.maxSize: NULL
[10:22:50.022]  - attr(*, "where")=List of 5
[10:22:50.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.022]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.022]  - attr(*, "resolved")= logi FALSE
[10:22:50.022]  - attr(*, "total_size")= num 5384
[10:22:50.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.022]  - attr(*, "already-done")= logi TRUE
[10:22:50.029] - reassign environment for ‘...future.FUN’
[10:22:50.029] - copied ‘...future.FUN’ to environment
[10:22:50.030] - copied ‘future.call.arguments’ to environment
[10:22:50.030] - copied ‘...future.elements_ii’ to environment
[10:22:50.030] - copied ‘...future.seeds_ii’ to environment
[10:22:50.030] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.030] assign_globals() ... done
[10:22:50.030] requestCore(): workers = 2
[10:22:50.032] MulticoreFuture started
[10:22:50.033] - Launch lazy future ... done
[10:22:50.033] run() for ‘MulticoreFuture’ ... done
[10:22:50.034] Created future:
[10:22:50.034] plan(): Setting new future strategy stack:
[10:22:50.035] List of future strategies:
[10:22:50.035] 1. sequential:
[10:22:50.035]    - args: function (..., envir = parent.frame())
[10:22:50.035]    - tweaked: FALSE
[10:22:50.035]    - call: NULL
[10:22:50.036] plan(): nbrOfWorkers() = 1
[10:22:50.041] plan(): Setting new future strategy stack:
[10:22:50.042] List of future strategies:
[10:22:50.042] 1. multicore:
[10:22:50.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.042]    - tweaked: FALSE
[10:22:50.042]    - call: plan(strategy)
[10:22:50.048] plan(): nbrOfWorkers() = 2
[10:22:50.034] MulticoreFuture:
[10:22:50.034] Label: ‘future_by-1’
[10:22:50.034] Expression:
[10:22:50.034] {
[10:22:50.034]     do.call(function(...) {
[10:22:50.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.034]             on.exit(options(oopts), add = TRUE)
[10:22:50.034]         }
[10:22:50.034]         {
[10:22:50.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.034]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.034]             })
[10:22:50.034]         }
[10:22:50.034]     }, args = future.call.arguments)
[10:22:50.034] }
[10:22:50.034] Lazy evaluation: FALSE
[10:22:50.034] Asynchronous evaluation: TRUE
[10:22:50.034] Local evaluation: TRUE
[10:22:50.034] Environment: R_GlobalEnv
[10:22:50.034] Capture standard output: TRUE
[10:22:50.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.034] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:50.034] Packages: 1 packages (‘stats’)
[10:22:50.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.034] Resolved: FALSE
[10:22:50.034] Value: <not collected>
[10:22:50.034] Conditions captured: <none>
[10:22:50.034] Early signaling: FALSE
[10:22:50.034] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.034] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.049] Chunk #1 of 2 ... DONE
[10:22:50.049] Chunk #2 of 2 ...
[10:22:50.050]  - Finding globals in 'X' for chunk #2 ...
[10:22:50.050] getGlobalsAndPackages() ...
[10:22:50.050] Searching for globals...
[10:22:50.051] 
[10:22:50.051] Searching for globals ... DONE
[10:22:50.051] - globals: [0] <none>
[10:22:50.052] getGlobalsAndPackages() ... DONE
[10:22:50.052]    + additional globals found: [n=0] 
[10:22:50.052]    + additional namespaces needed: [n=0] 
[10:22:50.052]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:50.052]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.052]  - seeds: <none>
[10:22:50.053]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.053] getGlobalsAndPackages() ...
[10:22:50.053] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.053] Resolving globals: FALSE
[10:22:50.053] Tweak future expression to call with '...' arguments ...
[10:22:50.054] {
[10:22:50.054]     do.call(function(...) {
[10:22:50.054]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.054]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.054]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.054]             on.exit(options(oopts), add = TRUE)
[10:22:50.054]         }
[10:22:50.054]         {
[10:22:50.054]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.054]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.054]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.054]             })
[10:22:50.054]         }
[10:22:50.054]     }, args = future.call.arguments)
[10:22:50.054] }
[10:22:50.054] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.055] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.055] 
[10:22:50.055] getGlobalsAndPackages() ... DONE
[10:22:50.056] run() for ‘Future’ ...
[10:22:50.056] - state: ‘created’
[10:22:50.056] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.061] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.061]   - Field: ‘label’
[10:22:50.062]   - Field: ‘local’
[10:22:50.062]   - Field: ‘owner’
[10:22:50.062]   - Field: ‘envir’
[10:22:50.062]   - Field: ‘workers’
[10:22:50.062]   - Field: ‘packages’
[10:22:50.062]   - Field: ‘gc’
[10:22:50.062]   - Field: ‘job’
[10:22:50.063]   - Field: ‘conditions’
[10:22:50.063]   - Field: ‘expr’
[10:22:50.063]   - Field: ‘uuid’
[10:22:50.063]   - Field: ‘seed’
[10:22:50.063]   - Field: ‘version’
[10:22:50.063]   - Field: ‘result’
[10:22:50.063]   - Field: ‘asynchronous’
[10:22:50.064]   - Field: ‘calls’
[10:22:50.064]   - Field: ‘globals’
[10:22:50.064]   - Field: ‘stdout’
[10:22:50.064]   - Field: ‘earlySignal’
[10:22:50.064]   - Field: ‘lazy’
[10:22:50.064]   - Field: ‘state’
[10:22:50.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.064] - Launch lazy future ...
[10:22:50.065] Packages needed by the future expression (n = 1): ‘stats’
[10:22:50.065] Packages needed by future strategies (n = 0): <none>
[10:22:50.066] {
[10:22:50.066]     {
[10:22:50.066]         {
[10:22:50.066]             ...future.startTime <- base::Sys.time()
[10:22:50.066]             {
[10:22:50.066]                 {
[10:22:50.066]                   {
[10:22:50.066]                     {
[10:22:50.066]                       {
[10:22:50.066]                         base::local({
[10:22:50.066]                           has_future <- base::requireNamespace("future", 
[10:22:50.066]                             quietly = TRUE)
[10:22:50.066]                           if (has_future) {
[10:22:50.066]                             ns <- base::getNamespace("future")
[10:22:50.066]                             version <- ns[[".package"]][["version"]]
[10:22:50.066]                             if (is.null(version)) 
[10:22:50.066]                               version <- utils::packageVersion("future")
[10:22:50.066]                           }
[10:22:50.066]                           else {
[10:22:50.066]                             version <- NULL
[10:22:50.066]                           }
[10:22:50.066]                           if (!has_future || version < "1.8.0") {
[10:22:50.066]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.066]                               "", base::R.version$version.string), 
[10:22:50.066]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:50.066]                                 base::R.version$platform, 8 * 
[10:22:50.066]                                   base::.Machine$sizeof.pointer), 
[10:22:50.066]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.066]                                 "release", "version")], collapse = " "), 
[10:22:50.066]                               hostname = base::Sys.info()[["nodename"]])
[10:22:50.066]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.066]                               info)
[10:22:50.066]                             info <- base::paste(info, collapse = "; ")
[10:22:50.066]                             if (!has_future) {
[10:22:50.066]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.066]                                 info)
[10:22:50.066]                             }
[10:22:50.066]                             else {
[10:22:50.066]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.066]                                 info, version)
[10:22:50.066]                             }
[10:22:50.066]                             base::stop(msg)
[10:22:50.066]                           }
[10:22:50.066]                         })
[10:22:50.066]                       }
[10:22:50.066]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.066]                       base::options(mc.cores = 1L)
[10:22:50.066]                     }
[10:22:50.066]                     base::local({
[10:22:50.066]                       for (pkg in "stats") {
[10:22:50.066]                         base::loadNamespace(pkg)
[10:22:50.066]                         base::library(pkg, character.only = TRUE)
[10:22:50.066]                       }
[10:22:50.066]                     })
[10:22:50.066]                   }
[10:22:50.066]                   options(future.plan = NULL)
[10:22:50.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.066]                 }
[10:22:50.066]                 ...future.workdir <- getwd()
[10:22:50.066]             }
[10:22:50.066]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.066]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.066]         }
[10:22:50.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.066]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.066]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.066]             base::names(...future.oldOptions))
[10:22:50.066]     }
[10:22:50.066]     if (FALSE) {
[10:22:50.066]     }
[10:22:50.066]     else {
[10:22:50.066]         if (TRUE) {
[10:22:50.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.066]                 open = "w")
[10:22:50.066]         }
[10:22:50.066]         else {
[10:22:50.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.066]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.066]         }
[10:22:50.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.066]             base::sink(type = "output", split = FALSE)
[10:22:50.066]             base::close(...future.stdout)
[10:22:50.066]         }, add = TRUE)
[10:22:50.066]     }
[10:22:50.066]     ...future.frame <- base::sys.nframe()
[10:22:50.066]     ...future.conditions <- base::list()
[10:22:50.066]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.066]     if (FALSE) {
[10:22:50.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.066]     }
[10:22:50.066]     ...future.result <- base::tryCatch({
[10:22:50.066]         base::withCallingHandlers({
[10:22:50.066]             ...future.value <- base::withVisible(base::local({
[10:22:50.066]                 withCallingHandlers({
[10:22:50.066]                   {
[10:22:50.066]                     do.call(function(...) {
[10:22:50.066]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.066]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.066]                         ...future.globals.maxSize)) {
[10:22:50.066]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.066]                         on.exit(options(oopts), add = TRUE)
[10:22:50.066]                       }
[10:22:50.066]                       {
[10:22:50.066]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.066]                           FUN = function(jj) {
[10:22:50.066]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.066]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.066]                           })
[10:22:50.066]                       }
[10:22:50.066]                     }, args = future.call.arguments)
[10:22:50.066]                   }
[10:22:50.066]                 }, immediateCondition = function(cond) {
[10:22:50.066]                   save_rds <- function (object, pathname, ...) 
[10:22:50.066]                   {
[10:22:50.066]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.066]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.066]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.066]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.066]                         fi_tmp[["mtime"]])
[10:22:50.066]                     }
[10:22:50.066]                     tryCatch({
[10:22:50.066]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.066]                     }, error = function(ex) {
[10:22:50.066]                       msg <- conditionMessage(ex)
[10:22:50.066]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.066]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.066]                         fi_tmp[["mtime"]], msg)
[10:22:50.066]                       ex$message <- msg
[10:22:50.066]                       stop(ex)
[10:22:50.066]                     })
[10:22:50.066]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.066]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.066]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.066]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.066]                       fi <- file.info(pathname)
[10:22:50.066]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.066]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.066]                         fi[["size"]], fi[["mtime"]])
[10:22:50.066]                       stop(msg)
[10:22:50.066]                     }
[10:22:50.066]                     invisible(pathname)
[10:22:50.066]                   }
[10:22:50.066]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.066]                     rootPath = tempdir()) 
[10:22:50.066]                   {
[10:22:50.066]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.066]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.066]                       tmpdir = path, fileext = ".rds")
[10:22:50.066]                     save_rds(obj, file)
[10:22:50.066]                   }
[10:22:50.066]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.066]                   {
[10:22:50.066]                     inherits <- base::inherits
[10:22:50.066]                     invokeRestart <- base::invokeRestart
[10:22:50.066]                     is.null <- base::is.null
[10:22:50.066]                     muffled <- FALSE
[10:22:50.066]                     if (inherits(cond, "message")) {
[10:22:50.066]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.066]                       if (muffled) 
[10:22:50.066]                         invokeRestart("muffleMessage")
[10:22:50.066]                     }
[10:22:50.066]                     else if (inherits(cond, "warning")) {
[10:22:50.066]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.066]                       if (muffled) 
[10:22:50.066]                         invokeRestart("muffleWarning")
[10:22:50.066]                     }
[10:22:50.066]                     else if (inherits(cond, "condition")) {
[10:22:50.066]                       if (!is.null(pattern)) {
[10:22:50.066]                         computeRestarts <- base::computeRestarts
[10:22:50.066]                         grepl <- base::grepl
[10:22:50.066]                         restarts <- computeRestarts(cond)
[10:22:50.066]                         for (restart in restarts) {
[10:22:50.066]                           name <- restart$name
[10:22:50.066]                           if (is.null(name)) 
[10:22:50.066]                             next
[10:22:50.066]                           if (!grepl(pattern, name)) 
[10:22:50.066]                             next
[10:22:50.066]                           invokeRestart(restart)
[10:22:50.066]                           muffled <- TRUE
[10:22:50.066]                           break
[10:22:50.066]                         }
[10:22:50.066]                       }
[10:22:50.066]                     }
[10:22:50.066]                     invisible(muffled)
[10:22:50.066]                   }
[10:22:50.066]                   muffleCondition(cond)
[10:22:50.066]                 })
[10:22:50.066]             }))
[10:22:50.066]             future::FutureResult(value = ...future.value$value, 
[10:22:50.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.066]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.066]                     ...future.globalenv.names))
[10:22:50.066]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.066]         }, condition = base::local({
[10:22:50.066]             c <- base::c
[10:22:50.066]             inherits <- base::inherits
[10:22:50.066]             invokeRestart <- base::invokeRestart
[10:22:50.066]             length <- base::length
[10:22:50.066]             list <- base::list
[10:22:50.066]             seq.int <- base::seq.int
[10:22:50.066]             signalCondition <- base::signalCondition
[10:22:50.066]             sys.calls <- base::sys.calls
[10:22:50.066]             `[[` <- base::`[[`
[10:22:50.066]             `+` <- base::`+`
[10:22:50.066]             `<<-` <- base::`<<-`
[10:22:50.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.066]                   3L)]
[10:22:50.066]             }
[10:22:50.066]             function(cond) {
[10:22:50.066]                 is_error <- inherits(cond, "error")
[10:22:50.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.066]                   NULL)
[10:22:50.066]                 if (is_error) {
[10:22:50.066]                   sessionInformation <- function() {
[10:22:50.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.066]                       search = base::search(), system = base::Sys.info())
[10:22:50.066]                   }
[10:22:50.066]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.066]                     cond$call), session = sessionInformation(), 
[10:22:50.066]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.066]                   signalCondition(cond)
[10:22:50.066]                 }
[10:22:50.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.066]                 "immediateCondition"))) {
[10:22:50.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.066]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.066]                   if (TRUE && !signal) {
[10:22:50.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.066]                     {
[10:22:50.066]                       inherits <- base::inherits
[10:22:50.066]                       invokeRestart <- base::invokeRestart
[10:22:50.066]                       is.null <- base::is.null
[10:22:50.066]                       muffled <- FALSE
[10:22:50.066]                       if (inherits(cond, "message")) {
[10:22:50.066]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.066]                         if (muffled) 
[10:22:50.066]                           invokeRestart("muffleMessage")
[10:22:50.066]                       }
[10:22:50.066]                       else if (inherits(cond, "warning")) {
[10:22:50.066]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.066]                         if (muffled) 
[10:22:50.066]                           invokeRestart("muffleWarning")
[10:22:50.066]                       }
[10:22:50.066]                       else if (inherits(cond, "condition")) {
[10:22:50.066]                         if (!is.null(pattern)) {
[10:22:50.066]                           computeRestarts <- base::computeRestarts
[10:22:50.066]                           grepl <- base::grepl
[10:22:50.066]                           restarts <- computeRestarts(cond)
[10:22:50.066]                           for (restart in restarts) {
[10:22:50.066]                             name <- restart$name
[10:22:50.066]                             if (is.null(name)) 
[10:22:50.066]                               next
[10:22:50.066]                             if (!grepl(pattern, name)) 
[10:22:50.066]                               next
[10:22:50.066]                             invokeRestart(restart)
[10:22:50.066]                             muffled <- TRUE
[10:22:50.066]                             break
[10:22:50.066]                           }
[10:22:50.066]                         }
[10:22:50.066]                       }
[10:22:50.066]                       invisible(muffled)
[10:22:50.066]                     }
[10:22:50.066]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.066]                   }
[10:22:50.066]                 }
[10:22:50.066]                 else {
[10:22:50.066]                   if (TRUE) {
[10:22:50.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.066]                     {
[10:22:50.066]                       inherits <- base::inherits
[10:22:50.066]                       invokeRestart <- base::invokeRestart
[10:22:50.066]                       is.null <- base::is.null
[10:22:50.066]                       muffled <- FALSE
[10:22:50.066]                       if (inherits(cond, "message")) {
[10:22:50.066]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.066]                         if (muffled) 
[10:22:50.066]                           invokeRestart("muffleMessage")
[10:22:50.066]                       }
[10:22:50.066]                       else if (inherits(cond, "warning")) {
[10:22:50.066]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.066]                         if (muffled) 
[10:22:50.066]                           invokeRestart("muffleWarning")
[10:22:50.066]                       }
[10:22:50.066]                       else if (inherits(cond, "condition")) {
[10:22:50.066]                         if (!is.null(pattern)) {
[10:22:50.066]                           computeRestarts <- base::computeRestarts
[10:22:50.066]                           grepl <- base::grepl
[10:22:50.066]                           restarts <- computeRestarts(cond)
[10:22:50.066]                           for (restart in restarts) {
[10:22:50.066]                             name <- restart$name
[10:22:50.066]                             if (is.null(name)) 
[10:22:50.066]                               next
[10:22:50.066]                             if (!grepl(pattern, name)) 
[10:22:50.066]                               next
[10:22:50.066]                             invokeRestart(restart)
[10:22:50.066]                             muffled <- TRUE
[10:22:50.066]                             break
[10:22:50.066]                           }
[10:22:50.066]                         }
[10:22:50.066]                       }
[10:22:50.066]                       invisible(muffled)
[10:22:50.066]                     }
[10:22:50.066]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.066]                   }
[10:22:50.066]                 }
[10:22:50.066]             }
[10:22:50.066]         }))
[10:22:50.066]     }, error = function(ex) {
[10:22:50.066]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.066]                 ...future.rng), started = ...future.startTime, 
[10:22:50.066]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.066]             version = "1.8"), class = "FutureResult")
[10:22:50.066]     }, finally = {
[10:22:50.066]         if (!identical(...future.workdir, getwd())) 
[10:22:50.066]             setwd(...future.workdir)
[10:22:50.066]         {
[10:22:50.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.066]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.066]             }
[10:22:50.066]             base::options(...future.oldOptions)
[10:22:50.066]             if (.Platform$OS.type == "windows") {
[10:22:50.066]                 old_names <- names(...future.oldEnvVars)
[10:22:50.066]                 envs <- base::Sys.getenv()
[10:22:50.066]                 names <- names(envs)
[10:22:50.066]                 common <- intersect(names, old_names)
[10:22:50.066]                 added <- setdiff(names, old_names)
[10:22:50.066]                 removed <- setdiff(old_names, names)
[10:22:50.066]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.066]                   envs[common]]
[10:22:50.066]                 NAMES <- toupper(changed)
[10:22:50.066]                 args <- list()
[10:22:50.066]                 for (kk in seq_along(NAMES)) {
[10:22:50.066]                   name <- changed[[kk]]
[10:22:50.066]                   NAME <- NAMES[[kk]]
[10:22:50.066]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.066]                     next
[10:22:50.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.066]                 }
[10:22:50.066]                 NAMES <- toupper(added)
[10:22:50.066]                 for (kk in seq_along(NAMES)) {
[10:22:50.066]                   name <- added[[kk]]
[10:22:50.066]                   NAME <- NAMES[[kk]]
[10:22:50.066]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.066]                     next
[10:22:50.066]                   args[[name]] <- ""
[10:22:50.066]                 }
[10:22:50.066]                 NAMES <- toupper(removed)
[10:22:50.066]                 for (kk in seq_along(NAMES)) {
[10:22:50.066]                   name <- removed[[kk]]
[10:22:50.066]                   NAME <- NAMES[[kk]]
[10:22:50.066]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.066]                     next
[10:22:50.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.066]                 }
[10:22:50.066]                 if (length(args) > 0) 
[10:22:50.066]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.066]             }
[10:22:50.066]             else {
[10:22:50.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.066]             }
[10:22:50.066]             {
[10:22:50.066]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.066]                   0L) {
[10:22:50.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.066]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.066]                   base::options(opts)
[10:22:50.066]                 }
[10:22:50.066]                 {
[10:22:50.066]                   {
[10:22:50.066]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.066]                     NULL
[10:22:50.066]                   }
[10:22:50.066]                   options(future.plan = NULL)
[10:22:50.066]                   if (is.na(NA_character_)) 
[10:22:50.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.066]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.066]                     envir = parent.frame()) 
[10:22:50.066]                   {
[10:22:50.066]                     default_workers <- missing(workers)
[10:22:50.066]                     if (is.function(workers)) 
[10:22:50.066]                       workers <- workers()
[10:22:50.066]                     workers <- structure(as.integer(workers), 
[10:22:50.066]                       class = class(workers))
[10:22:50.066]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.066]                       1L)
[10:22:50.066]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.066]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.066]                       if (default_workers) 
[10:22:50.066]                         supportsMulticore(warn = TRUE)
[10:22:50.066]                       return(sequential(..., envir = envir))
[10:22:50.066]                     }
[10:22:50.066]                     oopts <- options(mc.cores = workers)
[10:22:50.066]                     on.exit(options(oopts))
[10:22:50.066]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.066]                       envir = envir)
[10:22:50.066]                     if (!future$lazy) 
[10:22:50.066]                       future <- run(future)
[10:22:50.066]                     invisible(future)
[10:22:50.066]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.066]                 }
[10:22:50.066]             }
[10:22:50.066]         }
[10:22:50.066]     })
[10:22:50.066]     if (TRUE) {
[10:22:50.066]         base::sink(type = "output", split = FALSE)
[10:22:50.066]         if (TRUE) {
[10:22:50.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.066]         }
[10:22:50.066]         else {
[10:22:50.066]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.066]         }
[10:22:50.066]         base::close(...future.stdout)
[10:22:50.066]         ...future.stdout <- NULL
[10:22:50.066]     }
[10:22:50.066]     ...future.result$conditions <- ...future.conditions
[10:22:50.066]     ...future.result$finished <- base::Sys.time()
[10:22:50.066]     ...future.result
[10:22:50.066] }
[10:22:50.069] assign_globals() ...
[10:22:50.069] List of 5
[10:22:50.069]  $ ...future.FUN            :function (x, ...)  
[10:22:50.069]  $ future.call.arguments    :List of 1
[10:22:50.069]   ..$ singular.ok: logi FALSE
[10:22:50.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.069]  $ ...future.elements_ii    :List of 2
[10:22:50.069]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.069]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:50.069]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.069]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:50.069]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.069]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:50.069]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.069]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:50.069]  $ ...future.seeds_ii       : NULL
[10:22:50.069]  $ ...future.globals.maxSize: NULL
[10:22:50.069]  - attr(*, "where")=List of 5
[10:22:50.069]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.069]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.069]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.069]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.069]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.069]  - attr(*, "resolved")= logi FALSE
[10:22:50.069]  - attr(*, "total_size")= num 5384
[10:22:50.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.069]  - attr(*, "already-done")= logi TRUE
[10:22:50.082] - reassign environment for ‘...future.FUN’
[10:22:50.082] - copied ‘...future.FUN’ to environment
[10:22:50.082] - copied ‘future.call.arguments’ to environment
[10:22:50.082] - copied ‘...future.elements_ii’ to environment
[10:22:50.082] - copied ‘...future.seeds_ii’ to environment
[10:22:50.082] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.082] assign_globals() ... done
[10:22:50.083] requestCore(): workers = 2
[10:22:50.085] MulticoreFuture started
[10:22:50.086] - Launch lazy future ... done
[10:22:50.086] run() for ‘MulticoreFuture’ ... done
[10:22:50.087] Created future:
[10:22:50.087] plan(): Setting new future strategy stack:
[10:22:50.087] List of future strategies:
[10:22:50.087] 1. sequential:
[10:22:50.087]    - args: function (..., envir = parent.frame())
[10:22:50.087]    - tweaked: FALSE
[10:22:50.087]    - call: NULL
[10:22:50.089] plan(): nbrOfWorkers() = 1
[10:22:50.096] plan(): Setting new future strategy stack:
[10:22:50.096] List of future strategies:
[10:22:50.096] 1. multicore:
[10:22:50.096]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.096]    - tweaked: FALSE
[10:22:50.096]    - call: plan(strategy)
[10:22:50.101] plan(): nbrOfWorkers() = 2
[10:22:50.087] MulticoreFuture:
[10:22:50.087] Label: ‘future_by-2’
[10:22:50.087] Expression:
[10:22:50.087] {
[10:22:50.087]     do.call(function(...) {
[10:22:50.087]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.087]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.087]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.087]             on.exit(options(oopts), add = TRUE)
[10:22:50.087]         }
[10:22:50.087]         {
[10:22:50.087]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.087]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.087]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.087]             })
[10:22:50.087]         }
[10:22:50.087]     }, args = future.call.arguments)
[10:22:50.087] }
[10:22:50.087] Lazy evaluation: FALSE
[10:22:50.087] Asynchronous evaluation: TRUE
[10:22:50.087] Local evaluation: TRUE
[10:22:50.087] Environment: R_GlobalEnv
[10:22:50.087] Capture standard output: TRUE
[10:22:50.087] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.087] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:50.087] Packages: 1 packages (‘stats’)
[10:22:50.087] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.087] Resolved: FALSE
[10:22:50.087] Value: <not collected>
[10:22:50.087] Conditions captured: <none>
[10:22:50.087] Early signaling: FALSE
[10:22:50.087] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.087] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.102] Chunk #2 of 2 ... DONE
[10:22:50.102] Launching 2 futures (chunks) ... DONE
[10:22:50.103] Resolving 2 futures (chunks) ...
[10:22:50.103] resolve() on list ...
[10:22:50.103]  recursive: 0
[10:22:50.103]  length: 2
[10:22:50.103] 
[10:22:50.104] Future #1
[10:22:50.104] result() for MulticoreFuture ...
[10:22:50.106] result() for MulticoreFuture ...
[10:22:50.106] result() for MulticoreFuture ... done
[10:22:50.106] result() for MulticoreFuture ... done
[10:22:50.106] result() for MulticoreFuture ...
[10:22:50.106] result() for MulticoreFuture ... done
[10:22:50.106] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:50.107] - nx: 2
[10:22:50.107] - relay: TRUE
[10:22:50.107] - stdout: TRUE
[10:22:50.107] - signal: TRUE
[10:22:50.107] - resignal: FALSE
[10:22:50.107] - force: TRUE
[10:22:50.107] - relayed: [n=2] FALSE, FALSE
[10:22:50.107] - queued futures: [n=2] FALSE, FALSE
[10:22:50.108]  - until=1
[10:22:50.108]  - relaying element #1
[10:22:50.108] result() for MulticoreFuture ...
[10:22:50.108] result() for MulticoreFuture ... done
[10:22:50.108] result() for MulticoreFuture ...
[10:22:50.108] result() for MulticoreFuture ... done
[10:22:50.109] result() for MulticoreFuture ...
[10:22:50.109] result() for MulticoreFuture ... done
[10:22:50.109] result() for MulticoreFuture ...
[10:22:50.109] result() for MulticoreFuture ... done
[10:22:50.109] - relayed: [n=2] TRUE, FALSE
[10:22:50.109] - queued futures: [n=2] TRUE, FALSE
[10:22:50.110] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:50.110]  length: 1 (resolved future 1)
[10:22:50.110] Future #2
[10:22:50.110] result() for MulticoreFuture ...
[10:22:50.111] result() for MulticoreFuture ...
[10:22:50.112] result() for MulticoreFuture ... done
[10:22:50.112] result() for MulticoreFuture ... done
[10:22:50.112] result() for MulticoreFuture ...
[10:22:50.112] result() for MulticoreFuture ... done
[10:22:50.112] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:50.112] - nx: 2
[10:22:50.112] - relay: TRUE
[10:22:50.112] - stdout: TRUE
[10:22:50.113] - signal: TRUE
[10:22:50.113] - resignal: FALSE
[10:22:50.113] - force: TRUE
[10:22:50.113] - relayed: [n=2] TRUE, FALSE
[10:22:50.113] - queued futures: [n=2] TRUE, FALSE
[10:22:50.113]  - until=2
[10:22:50.113]  - relaying element #2
[10:22:50.113] result() for MulticoreFuture ...
[10:22:50.114] result() for MulticoreFuture ... done
[10:22:50.114] result() for MulticoreFuture ...
[10:22:50.114] result() for MulticoreFuture ... done
[10:22:50.114] result() for MulticoreFuture ...
[10:22:50.114] result() for MulticoreFuture ... done
[10:22:50.114] result() for MulticoreFuture ...
[10:22:50.114] result() for MulticoreFuture ... done
[10:22:50.114] - relayed: [n=2] TRUE, TRUE
[10:22:50.115] - queued futures: [n=2] TRUE, TRUE
[10:22:50.115] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:50.115]  length: 0 (resolved future 2)
[10:22:50.115] Relaying remaining futures
[10:22:50.115] signalConditionsASAP(NULL, pos=0) ...
[10:22:50.115] - nx: 2
[10:22:50.115] - relay: TRUE
[10:22:50.115] - stdout: TRUE
[10:22:50.115] - signal: TRUE
[10:22:50.115] - resignal: FALSE
[10:22:50.116] - force: TRUE
[10:22:50.116] - relayed: [n=2] TRUE, TRUE
[10:22:50.116] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:50.116] - relayed: [n=2] TRUE, TRUE
[10:22:50.116] - queued futures: [n=2] TRUE, TRUE
[10:22:50.116] signalConditionsASAP(NULL, pos=0) ... done
[10:22:50.116] resolve() on list ... DONE
[10:22:50.116] result() for MulticoreFuture ...
[10:22:50.116] result() for MulticoreFuture ... done
[10:22:50.117] result() for MulticoreFuture ...
[10:22:50.117] result() for MulticoreFuture ... done
[10:22:50.117] result() for MulticoreFuture ...
[10:22:50.117] result() for MulticoreFuture ... done
[10:22:50.117] result() for MulticoreFuture ...
[10:22:50.117] result() for MulticoreFuture ... done
[10:22:50.117]  - Number of value chunks collected: 2
[10:22:50.117] Resolving 2 futures (chunks) ... DONE
[10:22:50.117] Reducing values from 2 chunks ...
[10:22:50.118]  - Number of values collected after concatenation: 3
[10:22:50.118]  - Number of values expected: 3
[10:22:50.118] Reducing values from 2 chunks ... DONE
[10:22:50.118] future_lapply() ... DONE
[10:22:50.118] future_by_internal() ... DONE
[10:22:50.126] future_by_internal() ...
[10:22:50.126] future_lapply() ...
[10:22:50.131] Number of chunks: 2
[10:22:50.131] getGlobalsAndPackagesXApply() ...
[10:22:50.131]  - future.globals: TRUE
[10:22:50.132] getGlobalsAndPackages() ...
[10:22:50.132] Searching for globals...
[10:22:50.133] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:50.134] Searching for globals ... DONE
[10:22:50.134] Resolving globals: FALSE
[10:22:50.134] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:22:50.135] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:22:50.135] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:50.135] - packages: [1] ‘stats’
[10:22:50.135] getGlobalsAndPackages() ... DONE
[10:22:50.135]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:50.135]  - needed namespaces: [n=1] ‘stats’
[10:22:50.135] Finding globals ... DONE
[10:22:50.135]  - use_args: TRUE
[10:22:50.136]  - Getting '...' globals ...
[10:22:50.136] resolve() on list ...
[10:22:50.136]  recursive: 0
[10:22:50.136]  length: 1
[10:22:50.136]  elements: ‘...’
[10:22:50.136]  length: 0 (resolved future 1)
[10:22:50.136] resolve() on list ... DONE
[10:22:50.136]    - '...' content: [n=0] 
[10:22:50.137] List of 1
[10:22:50.137]  $ ...: list()
[10:22:50.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.137]  - attr(*, "where")=List of 1
[10:22:50.137]   ..$ ...:<environment: 0x55f6379c0ec8> 
[10:22:50.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.137]  - attr(*, "resolved")= logi TRUE
[10:22:50.137]  - attr(*, "total_size")= num NA
[10:22:50.139]  - Getting '...' globals ... DONE
[10:22:50.140] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:22:50.140] List of 4
[10:22:50.140]  $ ...future.FUN:function (x)  
[10:22:50.140]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:50.140]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.140]  $ ...          : list()
[10:22:50.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.140]  - attr(*, "where")=List of 4
[10:22:50.140]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:50.140]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:22:50.140]   ..$ wool         :<environment: R_EmptyEnv> 
[10:22:50.140]   ..$ ...          :<environment: 0x55f6379c0ec8> 
[10:22:50.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.140]  - attr(*, "resolved")= logi FALSE
[10:22:50.140]  - attr(*, "total_size")= num 2320
[10:22:50.146] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:50.146] getGlobalsAndPackagesXApply() ... DONE
[10:22:50.146] Number of futures (= number of chunks): 2
[10:22:50.146] Launching 2 futures (chunks) ...
[10:22:50.146] Chunk #1 of 2 ...
[10:22:50.147]  - Finding globals in 'X' for chunk #1 ...
[10:22:50.147] getGlobalsAndPackages() ...
[10:22:50.147] Searching for globals...
[10:22:50.147] 
[10:22:50.147] Searching for globals ... DONE
[10:22:50.147] - globals: [0] <none>
[10:22:50.147] getGlobalsAndPackages() ... DONE
[10:22:50.148]    + additional globals found: [n=0] 
[10:22:50.148]    + additional namespaces needed: [n=0] 
[10:22:50.148]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:50.148]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.148]  - seeds: <none>
[10:22:50.148]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.148] getGlobalsAndPackages() ...
[10:22:50.148] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.148] Resolving globals: FALSE
[10:22:50.148] Tweak future expression to call with '...' arguments ...
[10:22:50.149] {
[10:22:50.149]     do.call(function(...) {
[10:22:50.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.149]             on.exit(options(oopts), add = TRUE)
[10:22:50.149]         }
[10:22:50.149]         {
[10:22:50.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.149]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.149]             })
[10:22:50.149]         }
[10:22:50.149]     }, args = future.call.arguments)
[10:22:50.149] }
[10:22:50.149] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.149] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.150] 
[10:22:50.150] getGlobalsAndPackages() ... DONE
[10:22:50.150] run() for ‘Future’ ...
[10:22:50.150] - state: ‘created’
[10:22:50.150] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.154] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.154]   - Field: ‘label’
[10:22:50.154]   - Field: ‘local’
[10:22:50.154]   - Field: ‘owner’
[10:22:50.154]   - Field: ‘envir’
[10:22:50.155]   - Field: ‘workers’
[10:22:50.155]   - Field: ‘packages’
[10:22:50.155]   - Field: ‘gc’
[10:22:50.155]   - Field: ‘job’
[10:22:50.155]   - Field: ‘conditions’
[10:22:50.155]   - Field: ‘expr’
[10:22:50.155]   - Field: ‘uuid’
[10:22:50.155]   - Field: ‘seed’
[10:22:50.155]   - Field: ‘version’
[10:22:50.155]   - Field: ‘result’
[10:22:50.155]   - Field: ‘asynchronous’
[10:22:50.156]   - Field: ‘calls’
[10:22:50.156]   - Field: ‘globals’
[10:22:50.156]   - Field: ‘stdout’
[10:22:50.156]   - Field: ‘earlySignal’
[10:22:50.156]   - Field: ‘lazy’
[10:22:50.156]   - Field: ‘state’
[10:22:50.156] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.156] - Launch lazy future ...
[10:22:50.156] Packages needed by the future expression (n = 1): ‘stats’
[10:22:50.157] Packages needed by future strategies (n = 0): <none>
[10:22:50.157] {
[10:22:50.157]     {
[10:22:50.157]         {
[10:22:50.157]             ...future.startTime <- base::Sys.time()
[10:22:50.157]             {
[10:22:50.157]                 {
[10:22:50.157]                   {
[10:22:50.157]                     {
[10:22:50.157]                       {
[10:22:50.157]                         base::local({
[10:22:50.157]                           has_future <- base::requireNamespace("future", 
[10:22:50.157]                             quietly = TRUE)
[10:22:50.157]                           if (has_future) {
[10:22:50.157]                             ns <- base::getNamespace("future")
[10:22:50.157]                             version <- ns[[".package"]][["version"]]
[10:22:50.157]                             if (is.null(version)) 
[10:22:50.157]                               version <- utils::packageVersion("future")
[10:22:50.157]                           }
[10:22:50.157]                           else {
[10:22:50.157]                             version <- NULL
[10:22:50.157]                           }
[10:22:50.157]                           if (!has_future || version < "1.8.0") {
[10:22:50.157]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.157]                               "", base::R.version$version.string), 
[10:22:50.157]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:50.157]                                 base::R.version$platform, 8 * 
[10:22:50.157]                                   base::.Machine$sizeof.pointer), 
[10:22:50.157]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.157]                                 "release", "version")], collapse = " "), 
[10:22:50.157]                               hostname = base::Sys.info()[["nodename"]])
[10:22:50.157]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.157]                               info)
[10:22:50.157]                             info <- base::paste(info, collapse = "; ")
[10:22:50.157]                             if (!has_future) {
[10:22:50.157]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.157]                                 info)
[10:22:50.157]                             }
[10:22:50.157]                             else {
[10:22:50.157]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.157]                                 info, version)
[10:22:50.157]                             }
[10:22:50.157]                             base::stop(msg)
[10:22:50.157]                           }
[10:22:50.157]                         })
[10:22:50.157]                       }
[10:22:50.157]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.157]                       base::options(mc.cores = 1L)
[10:22:50.157]                     }
[10:22:50.157]                     base::local({
[10:22:50.157]                       for (pkg in "stats") {
[10:22:50.157]                         base::loadNamespace(pkg)
[10:22:50.157]                         base::library(pkg, character.only = TRUE)
[10:22:50.157]                       }
[10:22:50.157]                     })
[10:22:50.157]                   }
[10:22:50.157]                   options(future.plan = NULL)
[10:22:50.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.157]                 }
[10:22:50.157]                 ...future.workdir <- getwd()
[10:22:50.157]             }
[10:22:50.157]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.157]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.157]         }
[10:22:50.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.157]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.157]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.157]             base::names(...future.oldOptions))
[10:22:50.157]     }
[10:22:50.157]     if (FALSE) {
[10:22:50.157]     }
[10:22:50.157]     else {
[10:22:50.157]         if (TRUE) {
[10:22:50.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.157]                 open = "w")
[10:22:50.157]         }
[10:22:50.157]         else {
[10:22:50.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.157]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.157]         }
[10:22:50.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.157]             base::sink(type = "output", split = FALSE)
[10:22:50.157]             base::close(...future.stdout)
[10:22:50.157]         }, add = TRUE)
[10:22:50.157]     }
[10:22:50.157]     ...future.frame <- base::sys.nframe()
[10:22:50.157]     ...future.conditions <- base::list()
[10:22:50.157]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.157]     if (FALSE) {
[10:22:50.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.157]     }
[10:22:50.157]     ...future.result <- base::tryCatch({
[10:22:50.157]         base::withCallingHandlers({
[10:22:50.157]             ...future.value <- base::withVisible(base::local({
[10:22:50.157]                 withCallingHandlers({
[10:22:50.157]                   {
[10:22:50.157]                     do.call(function(...) {
[10:22:50.157]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.157]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.157]                         ...future.globals.maxSize)) {
[10:22:50.157]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.157]                         on.exit(options(oopts), add = TRUE)
[10:22:50.157]                       }
[10:22:50.157]                       {
[10:22:50.157]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.157]                           FUN = function(jj) {
[10:22:50.157]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.157]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.157]                           })
[10:22:50.157]                       }
[10:22:50.157]                     }, args = future.call.arguments)
[10:22:50.157]                   }
[10:22:50.157]                 }, immediateCondition = function(cond) {
[10:22:50.157]                   save_rds <- function (object, pathname, ...) 
[10:22:50.157]                   {
[10:22:50.157]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.157]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.157]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.157]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.157]                         fi_tmp[["mtime"]])
[10:22:50.157]                     }
[10:22:50.157]                     tryCatch({
[10:22:50.157]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.157]                     }, error = function(ex) {
[10:22:50.157]                       msg <- conditionMessage(ex)
[10:22:50.157]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.157]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.157]                         fi_tmp[["mtime"]], msg)
[10:22:50.157]                       ex$message <- msg
[10:22:50.157]                       stop(ex)
[10:22:50.157]                     })
[10:22:50.157]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.157]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.157]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.157]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.157]                       fi <- file.info(pathname)
[10:22:50.157]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.157]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.157]                         fi[["size"]], fi[["mtime"]])
[10:22:50.157]                       stop(msg)
[10:22:50.157]                     }
[10:22:50.157]                     invisible(pathname)
[10:22:50.157]                   }
[10:22:50.157]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.157]                     rootPath = tempdir()) 
[10:22:50.157]                   {
[10:22:50.157]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.157]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.157]                       tmpdir = path, fileext = ".rds")
[10:22:50.157]                     save_rds(obj, file)
[10:22:50.157]                   }
[10:22:50.157]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.157]                   {
[10:22:50.157]                     inherits <- base::inherits
[10:22:50.157]                     invokeRestart <- base::invokeRestart
[10:22:50.157]                     is.null <- base::is.null
[10:22:50.157]                     muffled <- FALSE
[10:22:50.157]                     if (inherits(cond, "message")) {
[10:22:50.157]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.157]                       if (muffled) 
[10:22:50.157]                         invokeRestart("muffleMessage")
[10:22:50.157]                     }
[10:22:50.157]                     else if (inherits(cond, "warning")) {
[10:22:50.157]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.157]                       if (muffled) 
[10:22:50.157]                         invokeRestart("muffleWarning")
[10:22:50.157]                     }
[10:22:50.157]                     else if (inherits(cond, "condition")) {
[10:22:50.157]                       if (!is.null(pattern)) {
[10:22:50.157]                         computeRestarts <- base::computeRestarts
[10:22:50.157]                         grepl <- base::grepl
[10:22:50.157]                         restarts <- computeRestarts(cond)
[10:22:50.157]                         for (restart in restarts) {
[10:22:50.157]                           name <- restart$name
[10:22:50.157]                           if (is.null(name)) 
[10:22:50.157]                             next
[10:22:50.157]                           if (!grepl(pattern, name)) 
[10:22:50.157]                             next
[10:22:50.157]                           invokeRestart(restart)
[10:22:50.157]                           muffled <- TRUE
[10:22:50.157]                           break
[10:22:50.157]                         }
[10:22:50.157]                       }
[10:22:50.157]                     }
[10:22:50.157]                     invisible(muffled)
[10:22:50.157]                   }
[10:22:50.157]                   muffleCondition(cond)
[10:22:50.157]                 })
[10:22:50.157]             }))
[10:22:50.157]             future::FutureResult(value = ...future.value$value, 
[10:22:50.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.157]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.157]                     ...future.globalenv.names))
[10:22:50.157]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.157]         }, condition = base::local({
[10:22:50.157]             c <- base::c
[10:22:50.157]             inherits <- base::inherits
[10:22:50.157]             invokeRestart <- base::invokeRestart
[10:22:50.157]             length <- base::length
[10:22:50.157]             list <- base::list
[10:22:50.157]             seq.int <- base::seq.int
[10:22:50.157]             signalCondition <- base::signalCondition
[10:22:50.157]             sys.calls <- base::sys.calls
[10:22:50.157]             `[[` <- base::`[[`
[10:22:50.157]             `+` <- base::`+`
[10:22:50.157]             `<<-` <- base::`<<-`
[10:22:50.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.157]                   3L)]
[10:22:50.157]             }
[10:22:50.157]             function(cond) {
[10:22:50.157]                 is_error <- inherits(cond, "error")
[10:22:50.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.157]                   NULL)
[10:22:50.157]                 if (is_error) {
[10:22:50.157]                   sessionInformation <- function() {
[10:22:50.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.157]                       search = base::search(), system = base::Sys.info())
[10:22:50.157]                   }
[10:22:50.157]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.157]                     cond$call), session = sessionInformation(), 
[10:22:50.157]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.157]                   signalCondition(cond)
[10:22:50.157]                 }
[10:22:50.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.157]                 "immediateCondition"))) {
[10:22:50.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.157]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.157]                   if (TRUE && !signal) {
[10:22:50.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.157]                     {
[10:22:50.157]                       inherits <- base::inherits
[10:22:50.157]                       invokeRestart <- base::invokeRestart
[10:22:50.157]                       is.null <- base::is.null
[10:22:50.157]                       muffled <- FALSE
[10:22:50.157]                       if (inherits(cond, "message")) {
[10:22:50.157]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.157]                         if (muffled) 
[10:22:50.157]                           invokeRestart("muffleMessage")
[10:22:50.157]                       }
[10:22:50.157]                       else if (inherits(cond, "warning")) {
[10:22:50.157]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.157]                         if (muffled) 
[10:22:50.157]                           invokeRestart("muffleWarning")
[10:22:50.157]                       }
[10:22:50.157]                       else if (inherits(cond, "condition")) {
[10:22:50.157]                         if (!is.null(pattern)) {
[10:22:50.157]                           computeRestarts <- base::computeRestarts
[10:22:50.157]                           grepl <- base::grepl
[10:22:50.157]                           restarts <- computeRestarts(cond)
[10:22:50.157]                           for (restart in restarts) {
[10:22:50.157]                             name <- restart$name
[10:22:50.157]                             if (is.null(name)) 
[10:22:50.157]                               next
[10:22:50.157]                             if (!grepl(pattern, name)) 
[10:22:50.157]                               next
[10:22:50.157]                             invokeRestart(restart)
[10:22:50.157]                             muffled <- TRUE
[10:22:50.157]                             break
[10:22:50.157]                           }
[10:22:50.157]                         }
[10:22:50.157]                       }
[10:22:50.157]                       invisible(muffled)
[10:22:50.157]                     }
[10:22:50.157]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.157]                   }
[10:22:50.157]                 }
[10:22:50.157]                 else {
[10:22:50.157]                   if (TRUE) {
[10:22:50.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.157]                     {
[10:22:50.157]                       inherits <- base::inherits
[10:22:50.157]                       invokeRestart <- base::invokeRestart
[10:22:50.157]                       is.null <- base::is.null
[10:22:50.157]                       muffled <- FALSE
[10:22:50.157]                       if (inherits(cond, "message")) {
[10:22:50.157]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.157]                         if (muffled) 
[10:22:50.157]                           invokeRestart("muffleMessage")
[10:22:50.157]                       }
[10:22:50.157]                       else if (inherits(cond, "warning")) {
[10:22:50.157]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.157]                         if (muffled) 
[10:22:50.157]                           invokeRestart("muffleWarning")
[10:22:50.157]                       }
[10:22:50.157]                       else if (inherits(cond, "condition")) {
[10:22:50.157]                         if (!is.null(pattern)) {
[10:22:50.157]                           computeRestarts <- base::computeRestarts
[10:22:50.157]                           grepl <- base::grepl
[10:22:50.157]                           restarts <- computeRestarts(cond)
[10:22:50.157]                           for (restart in restarts) {
[10:22:50.157]                             name <- restart$name
[10:22:50.157]                             if (is.null(name)) 
[10:22:50.157]                               next
[10:22:50.157]                             if (!grepl(pattern, name)) 
[10:22:50.157]                               next
[10:22:50.157]                             invokeRestart(restart)
[10:22:50.157]                             muffled <- TRUE
[10:22:50.157]                             break
[10:22:50.157]                           }
[10:22:50.157]                         }
[10:22:50.157]                       }
[10:22:50.157]                       invisible(muffled)
[10:22:50.157]                     }
[10:22:50.157]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.157]                   }
[10:22:50.157]                 }
[10:22:50.157]             }
[10:22:50.157]         }))
[10:22:50.157]     }, error = function(ex) {
[10:22:50.157]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.157]                 ...future.rng), started = ...future.startTime, 
[10:22:50.157]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.157]             version = "1.8"), class = "FutureResult")
[10:22:50.157]     }, finally = {
[10:22:50.157]         if (!identical(...future.workdir, getwd())) 
[10:22:50.157]             setwd(...future.workdir)
[10:22:50.157]         {
[10:22:50.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.157]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.157]             }
[10:22:50.157]             base::options(...future.oldOptions)
[10:22:50.157]             if (.Platform$OS.type == "windows") {
[10:22:50.157]                 old_names <- names(...future.oldEnvVars)
[10:22:50.157]                 envs <- base::Sys.getenv()
[10:22:50.157]                 names <- names(envs)
[10:22:50.157]                 common <- intersect(names, old_names)
[10:22:50.157]                 added <- setdiff(names, old_names)
[10:22:50.157]                 removed <- setdiff(old_names, names)
[10:22:50.157]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.157]                   envs[common]]
[10:22:50.157]                 NAMES <- toupper(changed)
[10:22:50.157]                 args <- list()
[10:22:50.157]                 for (kk in seq_along(NAMES)) {
[10:22:50.157]                   name <- changed[[kk]]
[10:22:50.157]                   NAME <- NAMES[[kk]]
[10:22:50.157]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.157]                     next
[10:22:50.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.157]                 }
[10:22:50.157]                 NAMES <- toupper(added)
[10:22:50.157]                 for (kk in seq_along(NAMES)) {
[10:22:50.157]                   name <- added[[kk]]
[10:22:50.157]                   NAME <- NAMES[[kk]]
[10:22:50.157]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.157]                     next
[10:22:50.157]                   args[[name]] <- ""
[10:22:50.157]                 }
[10:22:50.157]                 NAMES <- toupper(removed)
[10:22:50.157]                 for (kk in seq_along(NAMES)) {
[10:22:50.157]                   name <- removed[[kk]]
[10:22:50.157]                   NAME <- NAMES[[kk]]
[10:22:50.157]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.157]                     next
[10:22:50.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.157]                 }
[10:22:50.157]                 if (length(args) > 0) 
[10:22:50.157]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.157]             }
[10:22:50.157]             else {
[10:22:50.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.157]             }
[10:22:50.157]             {
[10:22:50.157]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.157]                   0L) {
[10:22:50.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.157]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.157]                   base::options(opts)
[10:22:50.157]                 }
[10:22:50.157]                 {
[10:22:50.157]                   {
[10:22:50.157]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.157]                     NULL
[10:22:50.157]                   }
[10:22:50.157]                   options(future.plan = NULL)
[10:22:50.157]                   if (is.na(NA_character_)) 
[10:22:50.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.157]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.157]                     envir = parent.frame()) 
[10:22:50.157]                   {
[10:22:50.157]                     default_workers <- missing(workers)
[10:22:50.157]                     if (is.function(workers)) 
[10:22:50.157]                       workers <- workers()
[10:22:50.157]                     workers <- structure(as.integer(workers), 
[10:22:50.157]                       class = class(workers))
[10:22:50.157]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.157]                       1L)
[10:22:50.157]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.157]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.157]                       if (default_workers) 
[10:22:50.157]                         supportsMulticore(warn = TRUE)
[10:22:50.157]                       return(sequential(..., envir = envir))
[10:22:50.157]                     }
[10:22:50.157]                     oopts <- options(mc.cores = workers)
[10:22:50.157]                     on.exit(options(oopts))
[10:22:50.157]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.157]                       envir = envir)
[10:22:50.157]                     if (!future$lazy) 
[10:22:50.157]                       future <- run(future)
[10:22:50.157]                     invisible(future)
[10:22:50.157]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.157]                 }
[10:22:50.157]             }
[10:22:50.157]         }
[10:22:50.157]     })
[10:22:50.157]     if (TRUE) {
[10:22:50.157]         base::sink(type = "output", split = FALSE)
[10:22:50.157]         if (TRUE) {
[10:22:50.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.157]         }
[10:22:50.157]         else {
[10:22:50.157]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.157]         }
[10:22:50.157]         base::close(...future.stdout)
[10:22:50.157]         ...future.stdout <- NULL
[10:22:50.157]     }
[10:22:50.157]     ...future.result$conditions <- ...future.conditions
[10:22:50.157]     ...future.result$finished <- base::Sys.time()
[10:22:50.157]     ...future.result
[10:22:50.157] }
[10:22:50.160] assign_globals() ...
[10:22:50.160] List of 7
[10:22:50.160]  $ ...future.FUN            :function (x)  
[10:22:50.160]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:50.160]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.160]  $ future.call.arguments    : list()
[10:22:50.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.160]  $ ...future.elements_ii    :List of 1
[10:22:50.160]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.160]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:50.160]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.160]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.160]  $ ...future.seeds_ii       : NULL
[10:22:50.160]  $ ...future.globals.maxSize: NULL
[10:22:50.160]  - attr(*, "where")=List of 7
[10:22:50.160]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.160]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:22:50.160]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:22:50.160]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.160]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.160]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.160]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.160]  - attr(*, "resolved")= logi FALSE
[10:22:50.160]  - attr(*, "total_size")= num 2320
[10:22:50.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.160]  - attr(*, "already-done")= logi TRUE
[10:22:50.169] - reassign environment for ‘...future.FUN’
[10:22:50.169] - copied ‘...future.FUN’ to environment
[10:22:50.170] - copied ‘breaks’ to environment
[10:22:50.170] - copied ‘wool’ to environment
[10:22:50.170] - copied ‘future.call.arguments’ to environment
[10:22:50.170] - copied ‘...future.elements_ii’ to environment
[10:22:50.170] - copied ‘...future.seeds_ii’ to environment
[10:22:50.170] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.170] assign_globals() ... done
[10:22:50.170] requestCore(): workers = 2
[10:22:50.173] MulticoreFuture started
[10:22:50.173] - Launch lazy future ... done
[10:22:50.174] run() for ‘MulticoreFuture’ ... done
[10:22:50.175] Created future:
[10:22:50.175] plan(): Setting new future strategy stack:
[10:22:50.175] List of future strategies:
[10:22:50.175] 1. sequential:
[10:22:50.175]    - args: function (..., envir = parent.frame())
[10:22:50.175]    - tweaked: FALSE
[10:22:50.175]    - call: NULL
[10:22:50.177] plan(): nbrOfWorkers() = 1
[10:22:50.182] plan(): Setting new future strategy stack:
[10:22:50.182] List of future strategies:
[10:22:50.182] 1. multicore:
[10:22:50.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.182]    - tweaked: FALSE
[10:22:50.182]    - call: plan(strategy)
[10:22:50.188] plan(): nbrOfWorkers() = 2
[10:22:50.175] MulticoreFuture:
[10:22:50.175] Label: ‘future_by-1’
[10:22:50.175] Expression:
[10:22:50.175] {
[10:22:50.175]     do.call(function(...) {
[10:22:50.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.175]             on.exit(options(oopts), add = TRUE)
[10:22:50.175]         }
[10:22:50.175]         {
[10:22:50.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.175]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.175]             })
[10:22:50.175]         }
[10:22:50.175]     }, args = future.call.arguments)
[10:22:50.175] }
[10:22:50.175] Lazy evaluation: FALSE
[10:22:50.175] Asynchronous evaluation: TRUE
[10:22:50.175] Local evaluation: TRUE
[10:22:50.175] Environment: 0x55f639e10bc0
[10:22:50.175] Capture standard output: TRUE
[10:22:50.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.175] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[10:22:50.175] Packages: 1 packages (‘stats’)
[10:22:50.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.175] Resolved: FALSE
[10:22:50.175] Value: <not collected>
[10:22:50.175] Conditions captured: <none>
[10:22:50.175] Early signaling: FALSE
[10:22:50.175] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.175] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.190] Chunk #1 of 2 ... DONE
[10:22:50.190] Chunk #2 of 2 ...
[10:22:50.191]  - Finding globals in 'X' for chunk #2 ...
[10:22:50.191] getGlobalsAndPackages() ...
[10:22:50.191] Searching for globals...
[10:22:50.192] 
[10:22:50.192] Searching for globals ... DONE
[10:22:50.192] - globals: [0] <none>
[10:22:50.193] getGlobalsAndPackages() ... DONE
[10:22:50.193]    + additional globals found: [n=0] 
[10:22:50.193]    + additional namespaces needed: [n=0] 
[10:22:50.193]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:50.193]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.193]  - seeds: <none>
[10:22:50.194]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.194] getGlobalsAndPackages() ...
[10:22:50.194] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.194] Resolving globals: FALSE
[10:22:50.194] Tweak future expression to call with '...' arguments ...
[10:22:50.195] {
[10:22:50.195]     do.call(function(...) {
[10:22:50.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.195]             on.exit(options(oopts), add = TRUE)
[10:22:50.195]         }
[10:22:50.195]         {
[10:22:50.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.195]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.195]             })
[10:22:50.195]         }
[10:22:50.195]     }, args = future.call.arguments)
[10:22:50.195] }
[10:22:50.195] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.196] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.196] 
[10:22:50.196] getGlobalsAndPackages() ... DONE
[10:22:50.197] run() for ‘Future’ ...
[10:22:50.197] - state: ‘created’
[10:22:50.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.202] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.202]   - Field: ‘label’
[10:22:50.202]   - Field: ‘local’
[10:22:50.202]   - Field: ‘owner’
[10:22:50.202]   - Field: ‘envir’
[10:22:50.203]   - Field: ‘workers’
[10:22:50.203]   - Field: ‘packages’
[10:22:50.203]   - Field: ‘gc’
[10:22:50.203]   - Field: ‘job’
[10:22:50.203]   - Field: ‘conditions’
[10:22:50.203]   - Field: ‘expr’
[10:22:50.203]   - Field: ‘uuid’
[10:22:50.203]   - Field: ‘seed’
[10:22:50.204]   - Field: ‘version’
[10:22:50.204]   - Field: ‘result’
[10:22:50.204]   - Field: ‘asynchronous’
[10:22:50.204]   - Field: ‘calls’
[10:22:50.204]   - Field: ‘globals’
[10:22:50.204]   - Field: ‘stdout’
[10:22:50.204]   - Field: ‘earlySignal’
[10:22:50.205]   - Field: ‘lazy’
[10:22:50.205]   - Field: ‘state’
[10:22:50.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.205] - Launch lazy future ...
[10:22:50.205] Packages needed by the future expression (n = 1): ‘stats’
[10:22:50.206] Packages needed by future strategies (n = 0): <none>
[10:22:50.206] {
[10:22:50.206]     {
[10:22:50.206]         {
[10:22:50.206]             ...future.startTime <- base::Sys.time()
[10:22:50.206]             {
[10:22:50.206]                 {
[10:22:50.206]                   {
[10:22:50.206]                     {
[10:22:50.206]                       {
[10:22:50.206]                         base::local({
[10:22:50.206]                           has_future <- base::requireNamespace("future", 
[10:22:50.206]                             quietly = TRUE)
[10:22:50.206]                           if (has_future) {
[10:22:50.206]                             ns <- base::getNamespace("future")
[10:22:50.206]                             version <- ns[[".package"]][["version"]]
[10:22:50.206]                             if (is.null(version)) 
[10:22:50.206]                               version <- utils::packageVersion("future")
[10:22:50.206]                           }
[10:22:50.206]                           else {
[10:22:50.206]                             version <- NULL
[10:22:50.206]                           }
[10:22:50.206]                           if (!has_future || version < "1.8.0") {
[10:22:50.206]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.206]                               "", base::R.version$version.string), 
[10:22:50.206]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:50.206]                                 base::R.version$platform, 8 * 
[10:22:50.206]                                   base::.Machine$sizeof.pointer), 
[10:22:50.206]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.206]                                 "release", "version")], collapse = " "), 
[10:22:50.206]                               hostname = base::Sys.info()[["nodename"]])
[10:22:50.206]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.206]                               info)
[10:22:50.206]                             info <- base::paste(info, collapse = "; ")
[10:22:50.206]                             if (!has_future) {
[10:22:50.206]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.206]                                 info)
[10:22:50.206]                             }
[10:22:50.206]                             else {
[10:22:50.206]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.206]                                 info, version)
[10:22:50.206]                             }
[10:22:50.206]                             base::stop(msg)
[10:22:50.206]                           }
[10:22:50.206]                         })
[10:22:50.206]                       }
[10:22:50.206]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.206]                       base::options(mc.cores = 1L)
[10:22:50.206]                     }
[10:22:50.206]                     base::local({
[10:22:50.206]                       for (pkg in "stats") {
[10:22:50.206]                         base::loadNamespace(pkg)
[10:22:50.206]                         base::library(pkg, character.only = TRUE)
[10:22:50.206]                       }
[10:22:50.206]                     })
[10:22:50.206]                   }
[10:22:50.206]                   options(future.plan = NULL)
[10:22:50.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.206]                 }
[10:22:50.206]                 ...future.workdir <- getwd()
[10:22:50.206]             }
[10:22:50.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.206]         }
[10:22:50.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.206]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.206]             base::names(...future.oldOptions))
[10:22:50.206]     }
[10:22:50.206]     if (FALSE) {
[10:22:50.206]     }
[10:22:50.206]     else {
[10:22:50.206]         if (TRUE) {
[10:22:50.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.206]                 open = "w")
[10:22:50.206]         }
[10:22:50.206]         else {
[10:22:50.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.206]         }
[10:22:50.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.206]             base::sink(type = "output", split = FALSE)
[10:22:50.206]             base::close(...future.stdout)
[10:22:50.206]         }, add = TRUE)
[10:22:50.206]     }
[10:22:50.206]     ...future.frame <- base::sys.nframe()
[10:22:50.206]     ...future.conditions <- base::list()
[10:22:50.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.206]     if (FALSE) {
[10:22:50.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.206]     }
[10:22:50.206]     ...future.result <- base::tryCatch({
[10:22:50.206]         base::withCallingHandlers({
[10:22:50.206]             ...future.value <- base::withVisible(base::local({
[10:22:50.206]                 withCallingHandlers({
[10:22:50.206]                   {
[10:22:50.206]                     do.call(function(...) {
[10:22:50.206]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.206]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.206]                         ...future.globals.maxSize)) {
[10:22:50.206]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.206]                         on.exit(options(oopts), add = TRUE)
[10:22:50.206]                       }
[10:22:50.206]                       {
[10:22:50.206]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.206]                           FUN = function(jj) {
[10:22:50.206]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.206]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.206]                           })
[10:22:50.206]                       }
[10:22:50.206]                     }, args = future.call.arguments)
[10:22:50.206]                   }
[10:22:50.206]                 }, immediateCondition = function(cond) {
[10:22:50.206]                   save_rds <- function (object, pathname, ...) 
[10:22:50.206]                   {
[10:22:50.206]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.206]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.206]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.206]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.206]                         fi_tmp[["mtime"]])
[10:22:50.206]                     }
[10:22:50.206]                     tryCatch({
[10:22:50.206]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.206]                     }, error = function(ex) {
[10:22:50.206]                       msg <- conditionMessage(ex)
[10:22:50.206]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.206]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.206]                         fi_tmp[["mtime"]], msg)
[10:22:50.206]                       ex$message <- msg
[10:22:50.206]                       stop(ex)
[10:22:50.206]                     })
[10:22:50.206]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.206]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.206]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.206]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.206]                       fi <- file.info(pathname)
[10:22:50.206]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.206]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.206]                         fi[["size"]], fi[["mtime"]])
[10:22:50.206]                       stop(msg)
[10:22:50.206]                     }
[10:22:50.206]                     invisible(pathname)
[10:22:50.206]                   }
[10:22:50.206]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.206]                     rootPath = tempdir()) 
[10:22:50.206]                   {
[10:22:50.206]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.206]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.206]                       tmpdir = path, fileext = ".rds")
[10:22:50.206]                     save_rds(obj, file)
[10:22:50.206]                   }
[10:22:50.206]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.206]                   {
[10:22:50.206]                     inherits <- base::inherits
[10:22:50.206]                     invokeRestart <- base::invokeRestart
[10:22:50.206]                     is.null <- base::is.null
[10:22:50.206]                     muffled <- FALSE
[10:22:50.206]                     if (inherits(cond, "message")) {
[10:22:50.206]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.206]                       if (muffled) 
[10:22:50.206]                         invokeRestart("muffleMessage")
[10:22:50.206]                     }
[10:22:50.206]                     else if (inherits(cond, "warning")) {
[10:22:50.206]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.206]                       if (muffled) 
[10:22:50.206]                         invokeRestart("muffleWarning")
[10:22:50.206]                     }
[10:22:50.206]                     else if (inherits(cond, "condition")) {
[10:22:50.206]                       if (!is.null(pattern)) {
[10:22:50.206]                         computeRestarts <- base::computeRestarts
[10:22:50.206]                         grepl <- base::grepl
[10:22:50.206]                         restarts <- computeRestarts(cond)
[10:22:50.206]                         for (restart in restarts) {
[10:22:50.206]                           name <- restart$name
[10:22:50.206]                           if (is.null(name)) 
[10:22:50.206]                             next
[10:22:50.206]                           if (!grepl(pattern, name)) 
[10:22:50.206]                             next
[10:22:50.206]                           invokeRestart(restart)
[10:22:50.206]                           muffled <- TRUE
[10:22:50.206]                           break
[10:22:50.206]                         }
[10:22:50.206]                       }
[10:22:50.206]                     }
[10:22:50.206]                     invisible(muffled)
[10:22:50.206]                   }
[10:22:50.206]                   muffleCondition(cond)
[10:22:50.206]                 })
[10:22:50.206]             }))
[10:22:50.206]             future::FutureResult(value = ...future.value$value, 
[10:22:50.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.206]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.206]                     ...future.globalenv.names))
[10:22:50.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.206]         }, condition = base::local({
[10:22:50.206]             c <- base::c
[10:22:50.206]             inherits <- base::inherits
[10:22:50.206]             invokeRestart <- base::invokeRestart
[10:22:50.206]             length <- base::length
[10:22:50.206]             list <- base::list
[10:22:50.206]             seq.int <- base::seq.int
[10:22:50.206]             signalCondition <- base::signalCondition
[10:22:50.206]             sys.calls <- base::sys.calls
[10:22:50.206]             `[[` <- base::`[[`
[10:22:50.206]             `+` <- base::`+`
[10:22:50.206]             `<<-` <- base::`<<-`
[10:22:50.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.206]                   3L)]
[10:22:50.206]             }
[10:22:50.206]             function(cond) {
[10:22:50.206]                 is_error <- inherits(cond, "error")
[10:22:50.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.206]                   NULL)
[10:22:50.206]                 if (is_error) {
[10:22:50.206]                   sessionInformation <- function() {
[10:22:50.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.206]                       search = base::search(), system = base::Sys.info())
[10:22:50.206]                   }
[10:22:50.206]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.206]                     cond$call), session = sessionInformation(), 
[10:22:50.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.206]                   signalCondition(cond)
[10:22:50.206]                 }
[10:22:50.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.206]                 "immediateCondition"))) {
[10:22:50.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.206]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.206]                   if (TRUE && !signal) {
[10:22:50.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.206]                     {
[10:22:50.206]                       inherits <- base::inherits
[10:22:50.206]                       invokeRestart <- base::invokeRestart
[10:22:50.206]                       is.null <- base::is.null
[10:22:50.206]                       muffled <- FALSE
[10:22:50.206]                       if (inherits(cond, "message")) {
[10:22:50.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.206]                         if (muffled) 
[10:22:50.206]                           invokeRestart("muffleMessage")
[10:22:50.206]                       }
[10:22:50.206]                       else if (inherits(cond, "warning")) {
[10:22:50.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.206]                         if (muffled) 
[10:22:50.206]                           invokeRestart("muffleWarning")
[10:22:50.206]                       }
[10:22:50.206]                       else if (inherits(cond, "condition")) {
[10:22:50.206]                         if (!is.null(pattern)) {
[10:22:50.206]                           computeRestarts <- base::computeRestarts
[10:22:50.206]                           grepl <- base::grepl
[10:22:50.206]                           restarts <- computeRestarts(cond)
[10:22:50.206]                           for (restart in restarts) {
[10:22:50.206]                             name <- restart$name
[10:22:50.206]                             if (is.null(name)) 
[10:22:50.206]                               next
[10:22:50.206]                             if (!grepl(pattern, name)) 
[10:22:50.206]                               next
[10:22:50.206]                             invokeRestart(restart)
[10:22:50.206]                             muffled <- TRUE
[10:22:50.206]                             break
[10:22:50.206]                           }
[10:22:50.206]                         }
[10:22:50.206]                       }
[10:22:50.206]                       invisible(muffled)
[10:22:50.206]                     }
[10:22:50.206]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.206]                   }
[10:22:50.206]                 }
[10:22:50.206]                 else {
[10:22:50.206]                   if (TRUE) {
[10:22:50.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.206]                     {
[10:22:50.206]                       inherits <- base::inherits
[10:22:50.206]                       invokeRestart <- base::invokeRestart
[10:22:50.206]                       is.null <- base::is.null
[10:22:50.206]                       muffled <- FALSE
[10:22:50.206]                       if (inherits(cond, "message")) {
[10:22:50.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.206]                         if (muffled) 
[10:22:50.206]                           invokeRestart("muffleMessage")
[10:22:50.206]                       }
[10:22:50.206]                       else if (inherits(cond, "warning")) {
[10:22:50.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.206]                         if (muffled) 
[10:22:50.206]                           invokeRestart("muffleWarning")
[10:22:50.206]                       }
[10:22:50.206]                       else if (inherits(cond, "condition")) {
[10:22:50.206]                         if (!is.null(pattern)) {
[10:22:50.206]                           computeRestarts <- base::computeRestarts
[10:22:50.206]                           grepl <- base::grepl
[10:22:50.206]                           restarts <- computeRestarts(cond)
[10:22:50.206]                           for (restart in restarts) {
[10:22:50.206]                             name <- restart$name
[10:22:50.206]                             if (is.null(name)) 
[10:22:50.206]                               next
[10:22:50.206]                             if (!grepl(pattern, name)) 
[10:22:50.206]                               next
[10:22:50.206]                             invokeRestart(restart)
[10:22:50.206]                             muffled <- TRUE
[10:22:50.206]                             break
[10:22:50.206]                           }
[10:22:50.206]                         }
[10:22:50.206]                       }
[10:22:50.206]                       invisible(muffled)
[10:22:50.206]                     }
[10:22:50.206]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.206]                   }
[10:22:50.206]                 }
[10:22:50.206]             }
[10:22:50.206]         }))
[10:22:50.206]     }, error = function(ex) {
[10:22:50.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.206]                 ...future.rng), started = ...future.startTime, 
[10:22:50.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.206]             version = "1.8"), class = "FutureResult")
[10:22:50.206]     }, finally = {
[10:22:50.206]         if (!identical(...future.workdir, getwd())) 
[10:22:50.206]             setwd(...future.workdir)
[10:22:50.206]         {
[10:22:50.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.206]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.206]             }
[10:22:50.206]             base::options(...future.oldOptions)
[10:22:50.206]             if (.Platform$OS.type == "windows") {
[10:22:50.206]                 old_names <- names(...future.oldEnvVars)
[10:22:50.206]                 envs <- base::Sys.getenv()
[10:22:50.206]                 names <- names(envs)
[10:22:50.206]                 common <- intersect(names, old_names)
[10:22:50.206]                 added <- setdiff(names, old_names)
[10:22:50.206]                 removed <- setdiff(old_names, names)
[10:22:50.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.206]                   envs[common]]
[10:22:50.206]                 NAMES <- toupper(changed)
[10:22:50.206]                 args <- list()
[10:22:50.206]                 for (kk in seq_along(NAMES)) {
[10:22:50.206]                   name <- changed[[kk]]
[10:22:50.206]                   NAME <- NAMES[[kk]]
[10:22:50.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.206]                     next
[10:22:50.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.206]                 }
[10:22:50.206]                 NAMES <- toupper(added)
[10:22:50.206]                 for (kk in seq_along(NAMES)) {
[10:22:50.206]                   name <- added[[kk]]
[10:22:50.206]                   NAME <- NAMES[[kk]]
[10:22:50.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.206]                     next
[10:22:50.206]                   args[[name]] <- ""
[10:22:50.206]                 }
[10:22:50.206]                 NAMES <- toupper(removed)
[10:22:50.206]                 for (kk in seq_along(NAMES)) {
[10:22:50.206]                   name <- removed[[kk]]
[10:22:50.206]                   NAME <- NAMES[[kk]]
[10:22:50.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.206]                     next
[10:22:50.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.206]                 }
[10:22:50.206]                 if (length(args) > 0) 
[10:22:50.206]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.206]             }
[10:22:50.206]             else {
[10:22:50.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.206]             }
[10:22:50.206]             {
[10:22:50.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.206]                   0L) {
[10:22:50.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.206]                   base::options(opts)
[10:22:50.206]                 }
[10:22:50.206]                 {
[10:22:50.206]                   {
[10:22:50.206]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.206]                     NULL
[10:22:50.206]                   }
[10:22:50.206]                   options(future.plan = NULL)
[10:22:50.206]                   if (is.na(NA_character_)) 
[10:22:50.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.206]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.206]                     envir = parent.frame()) 
[10:22:50.206]                   {
[10:22:50.206]                     default_workers <- missing(workers)
[10:22:50.206]                     if (is.function(workers)) 
[10:22:50.206]                       workers <- workers()
[10:22:50.206]                     workers <- structure(as.integer(workers), 
[10:22:50.206]                       class = class(workers))
[10:22:50.206]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.206]                       1L)
[10:22:50.206]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.206]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.206]                       if (default_workers) 
[10:22:50.206]                         supportsMulticore(warn = TRUE)
[10:22:50.206]                       return(sequential(..., envir = envir))
[10:22:50.206]                     }
[10:22:50.206]                     oopts <- options(mc.cores = workers)
[10:22:50.206]                     on.exit(options(oopts))
[10:22:50.206]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.206]                       envir = envir)
[10:22:50.206]                     if (!future$lazy) 
[10:22:50.206]                       future <- run(future)
[10:22:50.206]                     invisible(future)
[10:22:50.206]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.206]                 }
[10:22:50.206]             }
[10:22:50.206]         }
[10:22:50.206]     })
[10:22:50.206]     if (TRUE) {
[10:22:50.206]         base::sink(type = "output", split = FALSE)
[10:22:50.206]         if (TRUE) {
[10:22:50.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.206]         }
[10:22:50.206]         else {
[10:22:50.206]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.206]         }
[10:22:50.206]         base::close(...future.stdout)
[10:22:50.206]         ...future.stdout <- NULL
[10:22:50.206]     }
[10:22:50.206]     ...future.result$conditions <- ...future.conditions
[10:22:50.206]     ...future.result$finished <- base::Sys.time()
[10:22:50.206]     ...future.result
[10:22:50.206] }
[10:22:50.210] assign_globals() ...
[10:22:50.210] List of 7
[10:22:50.210]  $ ...future.FUN            :function (x)  
[10:22:50.210]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:50.210]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.210]  $ future.call.arguments    : list()
[10:22:50.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.210]  $ ...future.elements_ii    :List of 2
[10:22:50.210]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.210]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:50.210]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.210]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:50.210]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.210]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:50.210]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.210]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:50.210]  $ ...future.seeds_ii       : NULL
[10:22:50.210]  $ ...future.globals.maxSize: NULL
[10:22:50.210]  - attr(*, "where")=List of 7
[10:22:50.210]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.210]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:22:50.210]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:22:50.210]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.210]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.210]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.210]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.210]  - attr(*, "resolved")= logi FALSE
[10:22:50.210]  - attr(*, "total_size")= num 2320
[10:22:50.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.210]  - attr(*, "already-done")= logi TRUE
[10:22:50.223] - reassign environment for ‘...future.FUN’
[10:22:50.223] - copied ‘...future.FUN’ to environment
[10:22:50.223] - copied ‘breaks’ to environment
[10:22:50.223] - copied ‘wool’ to environment
[10:22:50.224] - copied ‘future.call.arguments’ to environment
[10:22:50.224] - copied ‘...future.elements_ii’ to environment
[10:22:50.224] - copied ‘...future.seeds_ii’ to environment
[10:22:50.224] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.224] assign_globals() ... done
[10:22:50.224] requestCore(): workers = 2
[10:22:50.227] MulticoreFuture started
[10:22:50.227] - Launch lazy future ... done
[10:22:50.228] run() for ‘MulticoreFuture’ ... done
[10:22:50.229] Created future:
[10:22:50.229] plan(): Setting new future strategy stack:
[10:22:50.229] List of future strategies:
[10:22:50.229] 1. sequential:
[10:22:50.229]    - args: function (..., envir = parent.frame())
[10:22:50.229]    - tweaked: FALSE
[10:22:50.229]    - call: NULL
[10:22:50.230] plan(): nbrOfWorkers() = 1
[10:22:50.236] plan(): Setting new future strategy stack:
[10:22:50.236] List of future strategies:
[10:22:50.236] 1. multicore:
[10:22:50.236]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.236]    - tweaked: FALSE
[10:22:50.236]    - call: plan(strategy)
[10:22:50.241] plan(): nbrOfWorkers() = 2
[10:22:50.229] MulticoreFuture:
[10:22:50.229] Label: ‘future_by-2’
[10:22:50.229] Expression:
[10:22:50.229] {
[10:22:50.229]     do.call(function(...) {
[10:22:50.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.229]             on.exit(options(oopts), add = TRUE)
[10:22:50.229]         }
[10:22:50.229]         {
[10:22:50.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.229]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.229]             })
[10:22:50.229]         }
[10:22:50.229]     }, args = future.call.arguments)
[10:22:50.229] }
[10:22:50.229] Lazy evaluation: FALSE
[10:22:50.229] Asynchronous evaluation: TRUE
[10:22:50.229] Local evaluation: TRUE
[10:22:50.229] Environment: 0x55f639e10bc0
[10:22:50.229] Capture standard output: TRUE
[10:22:50.229] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.229] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[10:22:50.229] Packages: 1 packages (‘stats’)
[10:22:50.229] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.229] Resolved: FALSE
[10:22:50.229] Value: <not collected>
[10:22:50.229] Conditions captured: <none>
[10:22:50.229] Early signaling: FALSE
[10:22:50.229] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.229] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.243] Chunk #2 of 2 ... DONE
[10:22:50.243] Launching 2 futures (chunks) ... DONE
[10:22:50.243] Resolving 2 futures (chunks) ...
[10:22:50.243] resolve() on list ...
[10:22:50.243]  recursive: 0
[10:22:50.244]  length: 2
[10:22:50.244] 
[10:22:50.244] Future #1
[10:22:50.244] result() for MulticoreFuture ...
[10:22:50.246] result() for MulticoreFuture ...
[10:22:50.246] result() for MulticoreFuture ... done
[10:22:50.246] result() for MulticoreFuture ... done
[10:22:50.246] result() for MulticoreFuture ...
[10:22:50.246] result() for MulticoreFuture ... done
[10:22:50.246] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:50.247] - nx: 2
[10:22:50.247] - relay: TRUE
[10:22:50.247] - stdout: TRUE
[10:22:50.247] - signal: TRUE
[10:22:50.247] - resignal: FALSE
[10:22:50.247] - force: TRUE
[10:22:50.247] - relayed: [n=2] FALSE, FALSE
[10:22:50.247] - queued futures: [n=2] FALSE, FALSE
[10:22:50.248]  - until=1
[10:22:50.248]  - relaying element #1
[10:22:50.248] result() for MulticoreFuture ...
[10:22:50.248] result() for MulticoreFuture ... done
[10:22:50.248] result() for MulticoreFuture ...
[10:22:50.248] result() for MulticoreFuture ... done
[10:22:50.249] result() for MulticoreFuture ...
[10:22:50.249] result() for MulticoreFuture ... done
[10:22:50.249] result() for MulticoreFuture ...
[10:22:50.249] result() for MulticoreFuture ... done
[10:22:50.249] - relayed: [n=2] TRUE, FALSE
[10:22:50.249] - queued futures: [n=2] TRUE, FALSE
[10:22:50.250] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:50.250]  length: 1 (resolved future 1)
[10:22:50.250] Future #2
[10:22:50.250] result() for MulticoreFuture ...
[10:22:50.252] result() for MulticoreFuture ...
[10:22:50.252] result() for MulticoreFuture ... done
[10:22:50.252] result() for MulticoreFuture ... done
[10:22:50.252] result() for MulticoreFuture ...
[10:22:50.252] result() for MulticoreFuture ... done
[10:22:50.252] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:50.253] - nx: 2
[10:22:50.253] - relay: TRUE
[10:22:50.253] - stdout: TRUE
[10:22:50.253] - signal: TRUE
[10:22:50.253] - resignal: FALSE
[10:22:50.253] - force: TRUE
[10:22:50.253] - relayed: [n=2] TRUE, FALSE
[10:22:50.253] - queued futures: [n=2] TRUE, FALSE
[10:22:50.254]  - until=2
[10:22:50.254]  - relaying element #2
[10:22:50.254] result() for MulticoreFuture ...
[10:22:50.254] result() for MulticoreFuture ... done
[10:22:50.254] result() for MulticoreFuture ...
[10:22:50.254] result() for MulticoreFuture ... done
[10:22:50.254] result() for MulticoreFuture ...
[10:22:50.254] result() for MulticoreFuture ... done
[10:22:50.255] result() for MulticoreFuture ...
[10:22:50.255] result() for MulticoreFuture ... done
[10:22:50.255] - relayed: [n=2] TRUE, TRUE
[10:22:50.255] - queued futures: [n=2] TRUE, TRUE
[10:22:50.255] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:50.255]  length: 0 (resolved future 2)
[10:22:50.255] Relaying remaining futures
[10:22:50.255] signalConditionsASAP(NULL, pos=0) ...
[10:22:50.255] - nx: 2
[10:22:50.256] - relay: TRUE
[10:22:50.256] - stdout: TRUE
[10:22:50.256] - signal: TRUE
[10:22:50.256] - resignal: FALSE
[10:22:50.256] - force: TRUE
[10:22:50.256] - relayed: [n=2] TRUE, TRUE
[10:22:50.256] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:50.256] - relayed: [n=2] TRUE, TRUE
[10:22:50.256] - queued futures: [n=2] TRUE, TRUE
[10:22:50.257] signalConditionsASAP(NULL, pos=0) ... done
[10:22:50.257] resolve() on list ... DONE
[10:22:50.257] result() for MulticoreFuture ...
[10:22:50.257] result() for MulticoreFuture ... done
[10:22:50.257] result() for MulticoreFuture ...
[10:22:50.257] result() for MulticoreFuture ... done
[10:22:50.257] result() for MulticoreFuture ...
[10:22:50.260] result() for MulticoreFuture ... done
[10:22:50.260] result() for MulticoreFuture ...
[10:22:50.260] result() for MulticoreFuture ... done
[10:22:50.260]  - Number of value chunks collected: 2
[10:22:50.260] Resolving 2 futures (chunks) ... DONE
[10:22:50.261] Reducing values from 2 chunks ...
[10:22:50.261]  - Number of values collected after concatenation: 3
[10:22:50.261]  - Number of values expected: 3
[10:22:50.261] Reducing values from 2 chunks ... DONE
[10:22:50.261] future_lapply() ... DONE
[10:22:50.261] future_by_internal() ... DONE
[10:22:50.262] future_by_internal() ...
[10:22:50.263] future_lapply() ...
[10:22:50.268] Number of chunks: 2
[10:22:50.268] getGlobalsAndPackagesXApply() ...
[10:22:50.268]  - future.globals: TRUE
[10:22:50.268] getGlobalsAndPackages() ...
[10:22:50.268] Searching for globals...
[10:22:50.270] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:50.270] Searching for globals ... DONE
[10:22:50.270] Resolving globals: FALSE
[10:22:50.270] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:50.271] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:50.271] - globals: [1] ‘FUN’
[10:22:50.271] 
[10:22:50.271] getGlobalsAndPackages() ... DONE
[10:22:50.271]  - globals found/used: [n=1] ‘FUN’
[10:22:50.271]  - needed namespaces: [n=0] 
[10:22:50.272] Finding globals ... DONE
[10:22:50.272]  - use_args: TRUE
[10:22:50.272]  - Getting '...' globals ...
[10:22:50.272] resolve() on list ...
[10:22:50.272]  recursive: 0
[10:22:50.272]  length: 1
[10:22:50.272]  elements: ‘...’
[10:22:50.272]  length: 0 (resolved future 1)
[10:22:50.273] resolve() on list ... DONE
[10:22:50.273]    - '...' content: [n=0] 
[10:22:50.273] List of 1
[10:22:50.273]  $ ...: list()
[10:22:50.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.273]  - attr(*, "where")=List of 1
[10:22:50.273]   ..$ ...:<environment: 0x55f63a0671d8> 
[10:22:50.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.273]  - attr(*, "resolved")= logi TRUE
[10:22:50.273]  - attr(*, "total_size")= num NA
[10:22:50.275]  - Getting '...' globals ... DONE
[10:22:50.276] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:50.276] List of 2
[10:22:50.276]  $ ...future.FUN:function (object, ...)  
[10:22:50.276]  $ ...          : list()
[10:22:50.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.276]  - attr(*, "where")=List of 2
[10:22:50.276]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:50.276]   ..$ ...          :<environment: 0x55f63a0671d8> 
[10:22:50.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.276]  - attr(*, "resolved")= logi FALSE
[10:22:50.276]  - attr(*, "total_size")= num 1240
[10:22:50.278] Packages to be attached in all futures: [n=0] 
[10:22:50.278] getGlobalsAndPackagesXApply() ... DONE
[10:22:50.279] Number of futures (= number of chunks): 2
[10:22:50.279] Launching 2 futures (chunks) ...
[10:22:50.279] Chunk #1 of 2 ...
[10:22:50.279]  - Finding globals in 'X' for chunk #1 ...
[10:22:50.279] getGlobalsAndPackages() ...
[10:22:50.279] Searching for globals...
[10:22:50.280] 
[10:22:50.280] Searching for globals ... DONE
[10:22:50.280] - globals: [0] <none>
[10:22:50.280] getGlobalsAndPackages() ... DONE
[10:22:50.280]    + additional globals found: [n=0] 
[10:22:50.280]    + additional namespaces needed: [n=0] 
[10:22:50.280]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:50.280]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.281]  - seeds: <none>
[10:22:50.281]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.281] getGlobalsAndPackages() ...
[10:22:50.281] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.281] Resolving globals: FALSE
[10:22:50.281] Tweak future expression to call with '...' arguments ...
[10:22:50.281] {
[10:22:50.281]     do.call(function(...) {
[10:22:50.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.281]             on.exit(options(oopts), add = TRUE)
[10:22:50.281]         }
[10:22:50.281]         {
[10:22:50.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.281]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.281]             })
[10:22:50.281]         }
[10:22:50.281]     }, args = future.call.arguments)
[10:22:50.281] }
[10:22:50.282] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.318] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.319] 
[10:22:50.319] getGlobalsAndPackages() ... DONE
[10:22:50.319] run() for ‘Future’ ...
[10:22:50.319] - state: ‘created’
[10:22:50.319] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.323] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.323]   - Field: ‘label’
[10:22:50.323]   - Field: ‘local’
[10:22:50.323]   - Field: ‘owner’
[10:22:50.324]   - Field: ‘envir’
[10:22:50.324]   - Field: ‘workers’
[10:22:50.324]   - Field: ‘packages’
[10:22:50.324]   - Field: ‘gc’
[10:22:50.324]   - Field: ‘job’
[10:22:50.324]   - Field: ‘conditions’
[10:22:50.324]   - Field: ‘expr’
[10:22:50.324]   - Field: ‘uuid’
[10:22:50.324]   - Field: ‘seed’
[10:22:50.324]   - Field: ‘version’
[10:22:50.324]   - Field: ‘result’
[10:22:50.325]   - Field: ‘asynchronous’
[10:22:50.325]   - Field: ‘calls’
[10:22:50.325]   - Field: ‘globals’
[10:22:50.325]   - Field: ‘stdout’
[10:22:50.325]   - Field: ‘earlySignal’
[10:22:50.325]   - Field: ‘lazy’
[10:22:50.325]   - Field: ‘state’
[10:22:50.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.325] - Launch lazy future ...
[10:22:50.326] Packages needed by the future expression (n = 0): <none>
[10:22:50.326] Packages needed by future strategies (n = 0): <none>
[10:22:50.326] {
[10:22:50.326]     {
[10:22:50.326]         {
[10:22:50.326]             ...future.startTime <- base::Sys.time()
[10:22:50.326]             {
[10:22:50.326]                 {
[10:22:50.326]                   {
[10:22:50.326]                     {
[10:22:50.326]                       base::local({
[10:22:50.326]                         has_future <- base::requireNamespace("future", 
[10:22:50.326]                           quietly = TRUE)
[10:22:50.326]                         if (has_future) {
[10:22:50.326]                           ns <- base::getNamespace("future")
[10:22:50.326]                           version <- ns[[".package"]][["version"]]
[10:22:50.326]                           if (is.null(version)) 
[10:22:50.326]                             version <- utils::packageVersion("future")
[10:22:50.326]                         }
[10:22:50.326]                         else {
[10:22:50.326]                           version <- NULL
[10:22:50.326]                         }
[10:22:50.326]                         if (!has_future || version < "1.8.0") {
[10:22:50.326]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.326]                             "", base::R.version$version.string), 
[10:22:50.326]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.326]                               "release", "version")], collapse = " "), 
[10:22:50.326]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.326]                             info)
[10:22:50.326]                           info <- base::paste(info, collapse = "; ")
[10:22:50.326]                           if (!has_future) {
[10:22:50.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.326]                               info)
[10:22:50.326]                           }
[10:22:50.326]                           else {
[10:22:50.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.326]                               info, version)
[10:22:50.326]                           }
[10:22:50.326]                           base::stop(msg)
[10:22:50.326]                         }
[10:22:50.326]                       })
[10:22:50.326]                     }
[10:22:50.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.326]                     base::options(mc.cores = 1L)
[10:22:50.326]                   }
[10:22:50.326]                   options(future.plan = NULL)
[10:22:50.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.326]                 }
[10:22:50.326]                 ...future.workdir <- getwd()
[10:22:50.326]             }
[10:22:50.326]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.326]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.326]         }
[10:22:50.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.326]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.326]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.326]             base::names(...future.oldOptions))
[10:22:50.326]     }
[10:22:50.326]     if (FALSE) {
[10:22:50.326]     }
[10:22:50.326]     else {
[10:22:50.326]         if (TRUE) {
[10:22:50.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.326]                 open = "w")
[10:22:50.326]         }
[10:22:50.326]         else {
[10:22:50.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.326]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.326]         }
[10:22:50.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.326]             base::sink(type = "output", split = FALSE)
[10:22:50.326]             base::close(...future.stdout)
[10:22:50.326]         }, add = TRUE)
[10:22:50.326]     }
[10:22:50.326]     ...future.frame <- base::sys.nframe()
[10:22:50.326]     ...future.conditions <- base::list()
[10:22:50.326]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.326]     if (FALSE) {
[10:22:50.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.326]     }
[10:22:50.326]     ...future.result <- base::tryCatch({
[10:22:50.326]         base::withCallingHandlers({
[10:22:50.326]             ...future.value <- base::withVisible(base::local({
[10:22:50.326]                 withCallingHandlers({
[10:22:50.326]                   {
[10:22:50.326]                     do.call(function(...) {
[10:22:50.326]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.326]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.326]                         ...future.globals.maxSize)) {
[10:22:50.326]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.326]                         on.exit(options(oopts), add = TRUE)
[10:22:50.326]                       }
[10:22:50.326]                       {
[10:22:50.326]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.326]                           FUN = function(jj) {
[10:22:50.326]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.326]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.326]                           })
[10:22:50.326]                       }
[10:22:50.326]                     }, args = future.call.arguments)
[10:22:50.326]                   }
[10:22:50.326]                 }, immediateCondition = function(cond) {
[10:22:50.326]                   save_rds <- function (object, pathname, ...) 
[10:22:50.326]                   {
[10:22:50.326]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.326]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.326]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.326]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.326]                         fi_tmp[["mtime"]])
[10:22:50.326]                     }
[10:22:50.326]                     tryCatch({
[10:22:50.326]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.326]                     }, error = function(ex) {
[10:22:50.326]                       msg <- conditionMessage(ex)
[10:22:50.326]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.326]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.326]                         fi_tmp[["mtime"]], msg)
[10:22:50.326]                       ex$message <- msg
[10:22:50.326]                       stop(ex)
[10:22:50.326]                     })
[10:22:50.326]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.326]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.326]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.326]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.326]                       fi <- file.info(pathname)
[10:22:50.326]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.326]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.326]                         fi[["size"]], fi[["mtime"]])
[10:22:50.326]                       stop(msg)
[10:22:50.326]                     }
[10:22:50.326]                     invisible(pathname)
[10:22:50.326]                   }
[10:22:50.326]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.326]                     rootPath = tempdir()) 
[10:22:50.326]                   {
[10:22:50.326]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.326]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.326]                       tmpdir = path, fileext = ".rds")
[10:22:50.326]                     save_rds(obj, file)
[10:22:50.326]                   }
[10:22:50.326]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.326]                   {
[10:22:50.326]                     inherits <- base::inherits
[10:22:50.326]                     invokeRestart <- base::invokeRestart
[10:22:50.326]                     is.null <- base::is.null
[10:22:50.326]                     muffled <- FALSE
[10:22:50.326]                     if (inherits(cond, "message")) {
[10:22:50.326]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.326]                       if (muffled) 
[10:22:50.326]                         invokeRestart("muffleMessage")
[10:22:50.326]                     }
[10:22:50.326]                     else if (inherits(cond, "warning")) {
[10:22:50.326]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.326]                       if (muffled) 
[10:22:50.326]                         invokeRestart("muffleWarning")
[10:22:50.326]                     }
[10:22:50.326]                     else if (inherits(cond, "condition")) {
[10:22:50.326]                       if (!is.null(pattern)) {
[10:22:50.326]                         computeRestarts <- base::computeRestarts
[10:22:50.326]                         grepl <- base::grepl
[10:22:50.326]                         restarts <- computeRestarts(cond)
[10:22:50.326]                         for (restart in restarts) {
[10:22:50.326]                           name <- restart$name
[10:22:50.326]                           if (is.null(name)) 
[10:22:50.326]                             next
[10:22:50.326]                           if (!grepl(pattern, name)) 
[10:22:50.326]                             next
[10:22:50.326]                           invokeRestart(restart)
[10:22:50.326]                           muffled <- TRUE
[10:22:50.326]                           break
[10:22:50.326]                         }
[10:22:50.326]                       }
[10:22:50.326]                     }
[10:22:50.326]                     invisible(muffled)
[10:22:50.326]                   }
[10:22:50.326]                   muffleCondition(cond)
[10:22:50.326]                 })
[10:22:50.326]             }))
[10:22:50.326]             future::FutureResult(value = ...future.value$value, 
[10:22:50.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.326]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.326]                     ...future.globalenv.names))
[10:22:50.326]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.326]         }, condition = base::local({
[10:22:50.326]             c <- base::c
[10:22:50.326]             inherits <- base::inherits
[10:22:50.326]             invokeRestart <- base::invokeRestart
[10:22:50.326]             length <- base::length
[10:22:50.326]             list <- base::list
[10:22:50.326]             seq.int <- base::seq.int
[10:22:50.326]             signalCondition <- base::signalCondition
[10:22:50.326]             sys.calls <- base::sys.calls
[10:22:50.326]             `[[` <- base::`[[`
[10:22:50.326]             `+` <- base::`+`
[10:22:50.326]             `<<-` <- base::`<<-`
[10:22:50.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.326]                   3L)]
[10:22:50.326]             }
[10:22:50.326]             function(cond) {
[10:22:50.326]                 is_error <- inherits(cond, "error")
[10:22:50.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.326]                   NULL)
[10:22:50.326]                 if (is_error) {
[10:22:50.326]                   sessionInformation <- function() {
[10:22:50.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.326]                       search = base::search(), system = base::Sys.info())
[10:22:50.326]                   }
[10:22:50.326]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.326]                     cond$call), session = sessionInformation(), 
[10:22:50.326]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.326]                   signalCondition(cond)
[10:22:50.326]                 }
[10:22:50.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.326]                 "immediateCondition"))) {
[10:22:50.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.326]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.326]                   if (TRUE && !signal) {
[10:22:50.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.326]                     {
[10:22:50.326]                       inherits <- base::inherits
[10:22:50.326]                       invokeRestart <- base::invokeRestart
[10:22:50.326]                       is.null <- base::is.null
[10:22:50.326]                       muffled <- FALSE
[10:22:50.326]                       if (inherits(cond, "message")) {
[10:22:50.326]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.326]                         if (muffled) 
[10:22:50.326]                           invokeRestart("muffleMessage")
[10:22:50.326]                       }
[10:22:50.326]                       else if (inherits(cond, "warning")) {
[10:22:50.326]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.326]                         if (muffled) 
[10:22:50.326]                           invokeRestart("muffleWarning")
[10:22:50.326]                       }
[10:22:50.326]                       else if (inherits(cond, "condition")) {
[10:22:50.326]                         if (!is.null(pattern)) {
[10:22:50.326]                           computeRestarts <- base::computeRestarts
[10:22:50.326]                           grepl <- base::grepl
[10:22:50.326]                           restarts <- computeRestarts(cond)
[10:22:50.326]                           for (restart in restarts) {
[10:22:50.326]                             name <- restart$name
[10:22:50.326]                             if (is.null(name)) 
[10:22:50.326]                               next
[10:22:50.326]                             if (!grepl(pattern, name)) 
[10:22:50.326]                               next
[10:22:50.326]                             invokeRestart(restart)
[10:22:50.326]                             muffled <- TRUE
[10:22:50.326]                             break
[10:22:50.326]                           }
[10:22:50.326]                         }
[10:22:50.326]                       }
[10:22:50.326]                       invisible(muffled)
[10:22:50.326]                     }
[10:22:50.326]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.326]                   }
[10:22:50.326]                 }
[10:22:50.326]                 else {
[10:22:50.326]                   if (TRUE) {
[10:22:50.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.326]                     {
[10:22:50.326]                       inherits <- base::inherits
[10:22:50.326]                       invokeRestart <- base::invokeRestart
[10:22:50.326]                       is.null <- base::is.null
[10:22:50.326]                       muffled <- FALSE
[10:22:50.326]                       if (inherits(cond, "message")) {
[10:22:50.326]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.326]                         if (muffled) 
[10:22:50.326]                           invokeRestart("muffleMessage")
[10:22:50.326]                       }
[10:22:50.326]                       else if (inherits(cond, "warning")) {
[10:22:50.326]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.326]                         if (muffled) 
[10:22:50.326]                           invokeRestart("muffleWarning")
[10:22:50.326]                       }
[10:22:50.326]                       else if (inherits(cond, "condition")) {
[10:22:50.326]                         if (!is.null(pattern)) {
[10:22:50.326]                           computeRestarts <- base::computeRestarts
[10:22:50.326]                           grepl <- base::grepl
[10:22:50.326]                           restarts <- computeRestarts(cond)
[10:22:50.326]                           for (restart in restarts) {
[10:22:50.326]                             name <- restart$name
[10:22:50.326]                             if (is.null(name)) 
[10:22:50.326]                               next
[10:22:50.326]                             if (!grepl(pattern, name)) 
[10:22:50.326]                               next
[10:22:50.326]                             invokeRestart(restart)
[10:22:50.326]                             muffled <- TRUE
[10:22:50.326]                             break
[10:22:50.326]                           }
[10:22:50.326]                         }
[10:22:50.326]                       }
[10:22:50.326]                       invisible(muffled)
[10:22:50.326]                     }
[10:22:50.326]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.326]                   }
[10:22:50.326]                 }
[10:22:50.326]             }
[10:22:50.326]         }))
[10:22:50.326]     }, error = function(ex) {
[10:22:50.326]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.326]                 ...future.rng), started = ...future.startTime, 
[10:22:50.326]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.326]             version = "1.8"), class = "FutureResult")
[10:22:50.326]     }, finally = {
[10:22:50.326]         if (!identical(...future.workdir, getwd())) 
[10:22:50.326]             setwd(...future.workdir)
[10:22:50.326]         {
[10:22:50.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.326]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.326]             }
[10:22:50.326]             base::options(...future.oldOptions)
[10:22:50.326]             if (.Platform$OS.type == "windows") {
[10:22:50.326]                 old_names <- names(...future.oldEnvVars)
[10:22:50.326]                 envs <- base::Sys.getenv()
[10:22:50.326]                 names <- names(envs)
[10:22:50.326]                 common <- intersect(names, old_names)
[10:22:50.326]                 added <- setdiff(names, old_names)
[10:22:50.326]                 removed <- setdiff(old_names, names)
[10:22:50.326]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.326]                   envs[common]]
[10:22:50.326]                 NAMES <- toupper(changed)
[10:22:50.326]                 args <- list()
[10:22:50.326]                 for (kk in seq_along(NAMES)) {
[10:22:50.326]                   name <- changed[[kk]]
[10:22:50.326]                   NAME <- NAMES[[kk]]
[10:22:50.326]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.326]                     next
[10:22:50.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.326]                 }
[10:22:50.326]                 NAMES <- toupper(added)
[10:22:50.326]                 for (kk in seq_along(NAMES)) {
[10:22:50.326]                   name <- added[[kk]]
[10:22:50.326]                   NAME <- NAMES[[kk]]
[10:22:50.326]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.326]                     next
[10:22:50.326]                   args[[name]] <- ""
[10:22:50.326]                 }
[10:22:50.326]                 NAMES <- toupper(removed)
[10:22:50.326]                 for (kk in seq_along(NAMES)) {
[10:22:50.326]                   name <- removed[[kk]]
[10:22:50.326]                   NAME <- NAMES[[kk]]
[10:22:50.326]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.326]                     next
[10:22:50.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.326]                 }
[10:22:50.326]                 if (length(args) > 0) 
[10:22:50.326]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.326]             }
[10:22:50.326]             else {
[10:22:50.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.326]             }
[10:22:50.326]             {
[10:22:50.326]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.326]                   0L) {
[10:22:50.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.326]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.326]                   base::options(opts)
[10:22:50.326]                 }
[10:22:50.326]                 {
[10:22:50.326]                   {
[10:22:50.326]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.326]                     NULL
[10:22:50.326]                   }
[10:22:50.326]                   options(future.plan = NULL)
[10:22:50.326]                   if (is.na(NA_character_)) 
[10:22:50.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.326]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.326]                     envir = parent.frame()) 
[10:22:50.326]                   {
[10:22:50.326]                     default_workers <- missing(workers)
[10:22:50.326]                     if (is.function(workers)) 
[10:22:50.326]                       workers <- workers()
[10:22:50.326]                     workers <- structure(as.integer(workers), 
[10:22:50.326]                       class = class(workers))
[10:22:50.326]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.326]                       1L)
[10:22:50.326]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.326]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.326]                       if (default_workers) 
[10:22:50.326]                         supportsMulticore(warn = TRUE)
[10:22:50.326]                       return(sequential(..., envir = envir))
[10:22:50.326]                     }
[10:22:50.326]                     oopts <- options(mc.cores = workers)
[10:22:50.326]                     on.exit(options(oopts))
[10:22:50.326]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.326]                       envir = envir)
[10:22:50.326]                     if (!future$lazy) 
[10:22:50.326]                       future <- run(future)
[10:22:50.326]                     invisible(future)
[10:22:50.326]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.326]                 }
[10:22:50.326]             }
[10:22:50.326]         }
[10:22:50.326]     })
[10:22:50.326]     if (TRUE) {
[10:22:50.326]         base::sink(type = "output", split = FALSE)
[10:22:50.326]         if (TRUE) {
[10:22:50.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.326]         }
[10:22:50.326]         else {
[10:22:50.326]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.326]         }
[10:22:50.326]         base::close(...future.stdout)
[10:22:50.326]         ...future.stdout <- NULL
[10:22:50.326]     }
[10:22:50.326]     ...future.result$conditions <- ...future.conditions
[10:22:50.326]     ...future.result$finished <- base::Sys.time()
[10:22:50.326]     ...future.result
[10:22:50.326] }
[10:22:50.328] assign_globals() ...
[10:22:50.329] List of 5
[10:22:50.329]  $ ...future.FUN            :function (object, ...)  
[10:22:50.329]  $ future.call.arguments    : list()
[10:22:50.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.329]  $ ...future.elements_ii    :List of 1
[10:22:50.329]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.329]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:50.329]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.329]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.329]  $ ...future.seeds_ii       : NULL
[10:22:50.329]  $ ...future.globals.maxSize: NULL
[10:22:50.329]  - attr(*, "where")=List of 5
[10:22:50.329]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.329]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.329]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.329]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.329]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.329]  - attr(*, "resolved")= logi FALSE
[10:22:50.329]  - attr(*, "total_size")= num 1240
[10:22:50.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.329]  - attr(*, "already-done")= logi TRUE
[10:22:50.334] - copied ‘...future.FUN’ to environment
[10:22:50.334] - copied ‘future.call.arguments’ to environment
[10:22:50.334] - copied ‘...future.elements_ii’ to environment
[10:22:50.334] - copied ‘...future.seeds_ii’ to environment
[10:22:50.335] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.335] assign_globals() ... done
[10:22:50.335] requestCore(): workers = 2
[10:22:50.337] MulticoreFuture started
[10:22:50.337] - Launch lazy future ... done
[10:22:50.338] run() for ‘MulticoreFuture’ ... done
[10:22:50.338] Created future:
[10:22:50.338] plan(): Setting new future strategy stack:
[10:22:50.339] List of future strategies:
[10:22:50.339] 1. sequential:
[10:22:50.339]    - args: function (..., envir = parent.frame())
[10:22:50.339]    - tweaked: FALSE
[10:22:50.339]    - call: NULL
[10:22:50.339] plan(): nbrOfWorkers() = 1
[10:22:50.343] plan(): Setting new future strategy stack:
[10:22:50.343] List of future strategies:
[10:22:50.343] 1. multicore:
[10:22:50.343]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.343]    - tweaked: FALSE
[10:22:50.343]    - call: plan(strategy)
[10:22:50.348] plan(): nbrOfWorkers() = 2
[10:22:50.338] MulticoreFuture:
[10:22:50.338] Label: ‘future_by-1’
[10:22:50.338] Expression:
[10:22:50.338] {
[10:22:50.338]     do.call(function(...) {
[10:22:50.338]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.338]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.338]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.338]             on.exit(options(oopts), add = TRUE)
[10:22:50.338]         }
[10:22:50.338]         {
[10:22:50.338]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.338]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.338]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.338]             })
[10:22:50.338]         }
[10:22:50.338]     }, args = future.call.arguments)
[10:22:50.338] }
[10:22:50.338] Lazy evaluation: FALSE
[10:22:50.338] Asynchronous evaluation: TRUE
[10:22:50.338] Local evaluation: TRUE
[10:22:50.338] Environment: 0x55f63a061280
[10:22:50.338] Capture standard output: TRUE
[10:22:50.338] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.338] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:50.338] Packages: <none>
[10:22:50.338] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.338] Resolved: TRUE
[10:22:50.338] Value: <not collected>
[10:22:50.338] Conditions captured: <none>
[10:22:50.338] Early signaling: FALSE
[10:22:50.338] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.338] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.349] Chunk #1 of 2 ... DONE
[10:22:50.349] Chunk #2 of 2 ...
[10:22:50.349]  - Finding globals in 'X' for chunk #2 ...
[10:22:50.349] getGlobalsAndPackages() ...
[10:22:50.350] Searching for globals...
[10:22:50.350] 
[10:22:50.350] Searching for globals ... DONE
[10:22:50.351] - globals: [0] <none>
[10:22:50.351] getGlobalsAndPackages() ... DONE
[10:22:50.351]    + additional globals found: [n=0] 
[10:22:50.351]    + additional namespaces needed: [n=0] 
[10:22:50.351]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:50.351]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.351]  - seeds: <none>
[10:22:50.351]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.352] getGlobalsAndPackages() ...
[10:22:50.352] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.352] Resolving globals: FALSE
[10:22:50.352] Tweak future expression to call with '...' arguments ...
[10:22:50.352] {
[10:22:50.352]     do.call(function(...) {
[10:22:50.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.352]             on.exit(options(oopts), add = TRUE)
[10:22:50.352]         }
[10:22:50.352]         {
[10:22:50.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.352]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.352]             })
[10:22:50.352]         }
[10:22:50.352]     }, args = future.call.arguments)
[10:22:50.352] }
[10:22:50.353] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.354] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.354] 
[10:22:50.354] getGlobalsAndPackages() ... DONE
[10:22:50.355] run() for ‘Future’ ...
[10:22:50.355] - state: ‘created’
[10:22:50.355] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.360] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.360]   - Field: ‘label’
[10:22:50.360]   - Field: ‘local’
[10:22:50.360]   - Field: ‘owner’
[10:22:50.361]   - Field: ‘envir’
[10:22:50.361]   - Field: ‘workers’
[10:22:50.361]   - Field: ‘packages’
[10:22:50.361]   - Field: ‘gc’
[10:22:50.362]   - Field: ‘job’
[10:22:50.362]   - Field: ‘conditions’
[10:22:50.362]   - Field: ‘expr’
[10:22:50.362]   - Field: ‘uuid’
[10:22:50.362]   - Field: ‘seed’
[10:22:50.363]   - Field: ‘version’
[10:22:50.363]   - Field: ‘result’
[10:22:50.363]   - Field: ‘asynchronous’
[10:22:50.363]   - Field: ‘calls’
[10:22:50.363]   - Field: ‘globals’
[10:22:50.363]   - Field: ‘stdout’
[10:22:50.364]   - Field: ‘earlySignal’
[10:22:50.364]   - Field: ‘lazy’
[10:22:50.364]   - Field: ‘state’
[10:22:50.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.364] - Launch lazy future ...
[10:22:50.365] Packages needed by the future expression (n = 0): <none>
[10:22:50.365] Packages needed by future strategies (n = 0): <none>
[10:22:50.366] {
[10:22:50.366]     {
[10:22:50.366]         {
[10:22:50.366]             ...future.startTime <- base::Sys.time()
[10:22:50.366]             {
[10:22:50.366]                 {
[10:22:50.366]                   {
[10:22:50.366]                     {
[10:22:50.366]                       base::local({
[10:22:50.366]                         has_future <- base::requireNamespace("future", 
[10:22:50.366]                           quietly = TRUE)
[10:22:50.366]                         if (has_future) {
[10:22:50.366]                           ns <- base::getNamespace("future")
[10:22:50.366]                           version <- ns[[".package"]][["version"]]
[10:22:50.366]                           if (is.null(version)) 
[10:22:50.366]                             version <- utils::packageVersion("future")
[10:22:50.366]                         }
[10:22:50.366]                         else {
[10:22:50.366]                           version <- NULL
[10:22:50.366]                         }
[10:22:50.366]                         if (!has_future || version < "1.8.0") {
[10:22:50.366]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.366]                             "", base::R.version$version.string), 
[10:22:50.366]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.366]                               "release", "version")], collapse = " "), 
[10:22:50.366]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.366]                             info)
[10:22:50.366]                           info <- base::paste(info, collapse = "; ")
[10:22:50.366]                           if (!has_future) {
[10:22:50.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.366]                               info)
[10:22:50.366]                           }
[10:22:50.366]                           else {
[10:22:50.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.366]                               info, version)
[10:22:50.366]                           }
[10:22:50.366]                           base::stop(msg)
[10:22:50.366]                         }
[10:22:50.366]                       })
[10:22:50.366]                     }
[10:22:50.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.366]                     base::options(mc.cores = 1L)
[10:22:50.366]                   }
[10:22:50.366]                   options(future.plan = NULL)
[10:22:50.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.366]                 }
[10:22:50.366]                 ...future.workdir <- getwd()
[10:22:50.366]             }
[10:22:50.366]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.366]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.366]         }
[10:22:50.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.366]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.366]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.366]             base::names(...future.oldOptions))
[10:22:50.366]     }
[10:22:50.366]     if (FALSE) {
[10:22:50.366]     }
[10:22:50.366]     else {
[10:22:50.366]         if (TRUE) {
[10:22:50.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.366]                 open = "w")
[10:22:50.366]         }
[10:22:50.366]         else {
[10:22:50.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.366]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.366]         }
[10:22:50.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.366]             base::sink(type = "output", split = FALSE)
[10:22:50.366]             base::close(...future.stdout)
[10:22:50.366]         }, add = TRUE)
[10:22:50.366]     }
[10:22:50.366]     ...future.frame <- base::sys.nframe()
[10:22:50.366]     ...future.conditions <- base::list()
[10:22:50.366]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.366]     if (FALSE) {
[10:22:50.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.366]     }
[10:22:50.366]     ...future.result <- base::tryCatch({
[10:22:50.366]         base::withCallingHandlers({
[10:22:50.366]             ...future.value <- base::withVisible(base::local({
[10:22:50.366]                 withCallingHandlers({
[10:22:50.366]                   {
[10:22:50.366]                     do.call(function(...) {
[10:22:50.366]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.366]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.366]                         ...future.globals.maxSize)) {
[10:22:50.366]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.366]                         on.exit(options(oopts), add = TRUE)
[10:22:50.366]                       }
[10:22:50.366]                       {
[10:22:50.366]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.366]                           FUN = function(jj) {
[10:22:50.366]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.366]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.366]                           })
[10:22:50.366]                       }
[10:22:50.366]                     }, args = future.call.arguments)
[10:22:50.366]                   }
[10:22:50.366]                 }, immediateCondition = function(cond) {
[10:22:50.366]                   save_rds <- function (object, pathname, ...) 
[10:22:50.366]                   {
[10:22:50.366]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.366]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.366]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.366]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.366]                         fi_tmp[["mtime"]])
[10:22:50.366]                     }
[10:22:50.366]                     tryCatch({
[10:22:50.366]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.366]                     }, error = function(ex) {
[10:22:50.366]                       msg <- conditionMessage(ex)
[10:22:50.366]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.366]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.366]                         fi_tmp[["mtime"]], msg)
[10:22:50.366]                       ex$message <- msg
[10:22:50.366]                       stop(ex)
[10:22:50.366]                     })
[10:22:50.366]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.366]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.366]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.366]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.366]                       fi <- file.info(pathname)
[10:22:50.366]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.366]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.366]                         fi[["size"]], fi[["mtime"]])
[10:22:50.366]                       stop(msg)
[10:22:50.366]                     }
[10:22:50.366]                     invisible(pathname)
[10:22:50.366]                   }
[10:22:50.366]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.366]                     rootPath = tempdir()) 
[10:22:50.366]                   {
[10:22:50.366]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.366]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.366]                       tmpdir = path, fileext = ".rds")
[10:22:50.366]                     save_rds(obj, file)
[10:22:50.366]                   }
[10:22:50.366]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.366]                   {
[10:22:50.366]                     inherits <- base::inherits
[10:22:50.366]                     invokeRestart <- base::invokeRestart
[10:22:50.366]                     is.null <- base::is.null
[10:22:50.366]                     muffled <- FALSE
[10:22:50.366]                     if (inherits(cond, "message")) {
[10:22:50.366]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.366]                       if (muffled) 
[10:22:50.366]                         invokeRestart("muffleMessage")
[10:22:50.366]                     }
[10:22:50.366]                     else if (inherits(cond, "warning")) {
[10:22:50.366]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.366]                       if (muffled) 
[10:22:50.366]                         invokeRestart("muffleWarning")
[10:22:50.366]                     }
[10:22:50.366]                     else if (inherits(cond, "condition")) {
[10:22:50.366]                       if (!is.null(pattern)) {
[10:22:50.366]                         computeRestarts <- base::computeRestarts
[10:22:50.366]                         grepl <- base::grepl
[10:22:50.366]                         restarts <- computeRestarts(cond)
[10:22:50.366]                         for (restart in restarts) {
[10:22:50.366]                           name <- restart$name
[10:22:50.366]                           if (is.null(name)) 
[10:22:50.366]                             next
[10:22:50.366]                           if (!grepl(pattern, name)) 
[10:22:50.366]                             next
[10:22:50.366]                           invokeRestart(restart)
[10:22:50.366]                           muffled <- TRUE
[10:22:50.366]                           break
[10:22:50.366]                         }
[10:22:50.366]                       }
[10:22:50.366]                     }
[10:22:50.366]                     invisible(muffled)
[10:22:50.366]                   }
[10:22:50.366]                   muffleCondition(cond)
[10:22:50.366]                 })
[10:22:50.366]             }))
[10:22:50.366]             future::FutureResult(value = ...future.value$value, 
[10:22:50.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.366]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.366]                     ...future.globalenv.names))
[10:22:50.366]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.366]         }, condition = base::local({
[10:22:50.366]             c <- base::c
[10:22:50.366]             inherits <- base::inherits
[10:22:50.366]             invokeRestart <- base::invokeRestart
[10:22:50.366]             length <- base::length
[10:22:50.366]             list <- base::list
[10:22:50.366]             seq.int <- base::seq.int
[10:22:50.366]             signalCondition <- base::signalCondition
[10:22:50.366]             sys.calls <- base::sys.calls
[10:22:50.366]             `[[` <- base::`[[`
[10:22:50.366]             `+` <- base::`+`
[10:22:50.366]             `<<-` <- base::`<<-`
[10:22:50.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.366]                   3L)]
[10:22:50.366]             }
[10:22:50.366]             function(cond) {
[10:22:50.366]                 is_error <- inherits(cond, "error")
[10:22:50.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.366]                   NULL)
[10:22:50.366]                 if (is_error) {
[10:22:50.366]                   sessionInformation <- function() {
[10:22:50.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.366]                       search = base::search(), system = base::Sys.info())
[10:22:50.366]                   }
[10:22:50.366]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.366]                     cond$call), session = sessionInformation(), 
[10:22:50.366]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.366]                   signalCondition(cond)
[10:22:50.366]                 }
[10:22:50.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.366]                 "immediateCondition"))) {
[10:22:50.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.366]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.366]                   if (TRUE && !signal) {
[10:22:50.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.366]                     {
[10:22:50.366]                       inherits <- base::inherits
[10:22:50.366]                       invokeRestart <- base::invokeRestart
[10:22:50.366]                       is.null <- base::is.null
[10:22:50.366]                       muffled <- FALSE
[10:22:50.366]                       if (inherits(cond, "message")) {
[10:22:50.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.366]                         if (muffled) 
[10:22:50.366]                           invokeRestart("muffleMessage")
[10:22:50.366]                       }
[10:22:50.366]                       else if (inherits(cond, "warning")) {
[10:22:50.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.366]                         if (muffled) 
[10:22:50.366]                           invokeRestart("muffleWarning")
[10:22:50.366]                       }
[10:22:50.366]                       else if (inherits(cond, "condition")) {
[10:22:50.366]                         if (!is.null(pattern)) {
[10:22:50.366]                           computeRestarts <- base::computeRestarts
[10:22:50.366]                           grepl <- base::grepl
[10:22:50.366]                           restarts <- computeRestarts(cond)
[10:22:50.366]                           for (restart in restarts) {
[10:22:50.366]                             name <- restart$name
[10:22:50.366]                             if (is.null(name)) 
[10:22:50.366]                               next
[10:22:50.366]                             if (!grepl(pattern, name)) 
[10:22:50.366]                               next
[10:22:50.366]                             invokeRestart(restart)
[10:22:50.366]                             muffled <- TRUE
[10:22:50.366]                             break
[10:22:50.366]                           }
[10:22:50.366]                         }
[10:22:50.366]                       }
[10:22:50.366]                       invisible(muffled)
[10:22:50.366]                     }
[10:22:50.366]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.366]                   }
[10:22:50.366]                 }
[10:22:50.366]                 else {
[10:22:50.366]                   if (TRUE) {
[10:22:50.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.366]                     {
[10:22:50.366]                       inherits <- base::inherits
[10:22:50.366]                       invokeRestart <- base::invokeRestart
[10:22:50.366]                       is.null <- base::is.null
[10:22:50.366]                       muffled <- FALSE
[10:22:50.366]                       if (inherits(cond, "message")) {
[10:22:50.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.366]                         if (muffled) 
[10:22:50.366]                           invokeRestart("muffleMessage")
[10:22:50.366]                       }
[10:22:50.366]                       else if (inherits(cond, "warning")) {
[10:22:50.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.366]                         if (muffled) 
[10:22:50.366]                           invokeRestart("muffleWarning")
[10:22:50.366]                       }
[10:22:50.366]                       else if (inherits(cond, "condition")) {
[10:22:50.366]                         if (!is.null(pattern)) {
[10:22:50.366]                           computeRestarts <- base::computeRestarts
[10:22:50.366]                           grepl <- base::grepl
[10:22:50.366]                           restarts <- computeRestarts(cond)
[10:22:50.366]                           for (restart in restarts) {
[10:22:50.366]                             name <- restart$name
[10:22:50.366]                             if (is.null(name)) 
[10:22:50.366]                               next
[10:22:50.366]                             if (!grepl(pattern, name)) 
[10:22:50.366]                               next
[10:22:50.366]                             invokeRestart(restart)
[10:22:50.366]                             muffled <- TRUE
[10:22:50.366]                             break
[10:22:50.366]                           }
[10:22:50.366]                         }
[10:22:50.366]                       }
[10:22:50.366]                       invisible(muffled)
[10:22:50.366]                     }
[10:22:50.366]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.366]                   }
[10:22:50.366]                 }
[10:22:50.366]             }
[10:22:50.366]         }))
[10:22:50.366]     }, error = function(ex) {
[10:22:50.366]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.366]                 ...future.rng), started = ...future.startTime, 
[10:22:50.366]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.366]             version = "1.8"), class = "FutureResult")
[10:22:50.366]     }, finally = {
[10:22:50.366]         if (!identical(...future.workdir, getwd())) 
[10:22:50.366]             setwd(...future.workdir)
[10:22:50.366]         {
[10:22:50.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.366]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.366]             }
[10:22:50.366]             base::options(...future.oldOptions)
[10:22:50.366]             if (.Platform$OS.type == "windows") {
[10:22:50.366]                 old_names <- names(...future.oldEnvVars)
[10:22:50.366]                 envs <- base::Sys.getenv()
[10:22:50.366]                 names <- names(envs)
[10:22:50.366]                 common <- intersect(names, old_names)
[10:22:50.366]                 added <- setdiff(names, old_names)
[10:22:50.366]                 removed <- setdiff(old_names, names)
[10:22:50.366]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.366]                   envs[common]]
[10:22:50.366]                 NAMES <- toupper(changed)
[10:22:50.366]                 args <- list()
[10:22:50.366]                 for (kk in seq_along(NAMES)) {
[10:22:50.366]                   name <- changed[[kk]]
[10:22:50.366]                   NAME <- NAMES[[kk]]
[10:22:50.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.366]                     next
[10:22:50.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.366]                 }
[10:22:50.366]                 NAMES <- toupper(added)
[10:22:50.366]                 for (kk in seq_along(NAMES)) {
[10:22:50.366]                   name <- added[[kk]]
[10:22:50.366]                   NAME <- NAMES[[kk]]
[10:22:50.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.366]                     next
[10:22:50.366]                   args[[name]] <- ""
[10:22:50.366]                 }
[10:22:50.366]                 NAMES <- toupper(removed)
[10:22:50.366]                 for (kk in seq_along(NAMES)) {
[10:22:50.366]                   name <- removed[[kk]]
[10:22:50.366]                   NAME <- NAMES[[kk]]
[10:22:50.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.366]                     next
[10:22:50.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.366]                 }
[10:22:50.366]                 if (length(args) > 0) 
[10:22:50.366]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.366]             }
[10:22:50.366]             else {
[10:22:50.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.366]             }
[10:22:50.366]             {
[10:22:50.366]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.366]                   0L) {
[10:22:50.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.366]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.366]                   base::options(opts)
[10:22:50.366]                 }
[10:22:50.366]                 {
[10:22:50.366]                   {
[10:22:50.366]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.366]                     NULL
[10:22:50.366]                   }
[10:22:50.366]                   options(future.plan = NULL)
[10:22:50.366]                   if (is.na(NA_character_)) 
[10:22:50.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.366]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.366]                     envir = parent.frame()) 
[10:22:50.366]                   {
[10:22:50.366]                     default_workers <- missing(workers)
[10:22:50.366]                     if (is.function(workers)) 
[10:22:50.366]                       workers <- workers()
[10:22:50.366]                     workers <- structure(as.integer(workers), 
[10:22:50.366]                       class = class(workers))
[10:22:50.366]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.366]                       1L)
[10:22:50.366]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.366]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.366]                       if (default_workers) 
[10:22:50.366]                         supportsMulticore(warn = TRUE)
[10:22:50.366]                       return(sequential(..., envir = envir))
[10:22:50.366]                     }
[10:22:50.366]                     oopts <- options(mc.cores = workers)
[10:22:50.366]                     on.exit(options(oopts))
[10:22:50.366]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.366]                       envir = envir)
[10:22:50.366]                     if (!future$lazy) 
[10:22:50.366]                       future <- run(future)
[10:22:50.366]                     invisible(future)
[10:22:50.366]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.366]                 }
[10:22:50.366]             }
[10:22:50.366]         }
[10:22:50.366]     })
[10:22:50.366]     if (TRUE) {
[10:22:50.366]         base::sink(type = "output", split = FALSE)
[10:22:50.366]         if (TRUE) {
[10:22:50.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.366]         }
[10:22:50.366]         else {
[10:22:50.366]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.366]         }
[10:22:50.366]         base::close(...future.stdout)
[10:22:50.366]         ...future.stdout <- NULL
[10:22:50.366]     }
[10:22:50.366]     ...future.result$conditions <- ...future.conditions
[10:22:50.366]     ...future.result$finished <- base::Sys.time()
[10:22:50.366]     ...future.result
[10:22:50.366] }
[10:22:50.369] assign_globals() ...
[10:22:50.369] List of 5
[10:22:50.369]  $ ...future.FUN            :function (object, ...)  
[10:22:50.369]  $ future.call.arguments    : list()
[10:22:50.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.369]  $ ...future.elements_ii    :List of 2
[10:22:50.369]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.369]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:50.369]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.369]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:50.369]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.369]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:50.369]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.369]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:50.369]  $ ...future.seeds_ii       : NULL
[10:22:50.369]  $ ...future.globals.maxSize: NULL
[10:22:50.369]  - attr(*, "where")=List of 5
[10:22:50.369]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.369]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.369]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.369]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.369]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.369]  - attr(*, "resolved")= logi FALSE
[10:22:50.369]  - attr(*, "total_size")= num 1240
[10:22:50.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.369]  - attr(*, "already-done")= logi TRUE
[10:22:50.380] - copied ‘...future.FUN’ to environment
[10:22:50.380] - copied ‘future.call.arguments’ to environment
[10:22:50.380] - copied ‘...future.elements_ii’ to environment
[10:22:50.381] - copied ‘...future.seeds_ii’ to environment
[10:22:50.381] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.381] assign_globals() ... done
[10:22:50.381] requestCore(): workers = 2
[10:22:50.383] MulticoreFuture started
[10:22:50.384] - Launch lazy future ... done
[10:22:50.384] run() for ‘MulticoreFuture’ ... done
[10:22:50.384] Created future:
[10:22:50.385] plan(): Setting new future strategy stack:
[10:22:50.385] List of future strategies:
[10:22:50.385] 1. sequential:
[10:22:50.385]    - args: function (..., envir = parent.frame())
[10:22:50.385]    - tweaked: FALSE
[10:22:50.385]    - call: NULL
[10:22:50.386] plan(): nbrOfWorkers() = 1
[10:22:50.390] plan(): Setting new future strategy stack:
[10:22:50.390] List of future strategies:
[10:22:50.390] 1. multicore:
[10:22:50.390]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.390]    - tweaked: FALSE
[10:22:50.390]    - call: plan(strategy)
[10:22:50.395] plan(): nbrOfWorkers() = 2
[10:22:50.384] MulticoreFuture:
[10:22:50.384] Label: ‘future_by-2’
[10:22:50.384] Expression:
[10:22:50.384] {
[10:22:50.384]     do.call(function(...) {
[10:22:50.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.384]             on.exit(options(oopts), add = TRUE)
[10:22:50.384]         }
[10:22:50.384]         {
[10:22:50.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.384]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.384]             })
[10:22:50.384]         }
[10:22:50.384]     }, args = future.call.arguments)
[10:22:50.384] }
[10:22:50.384] Lazy evaluation: FALSE
[10:22:50.384] Asynchronous evaluation: TRUE
[10:22:50.384] Local evaluation: TRUE
[10:22:50.384] Environment: 0x55f63a061280
[10:22:50.384] Capture standard output: TRUE
[10:22:50.384] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.384] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:50.384] Packages: <none>
[10:22:50.384] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.384] Resolved: TRUE
[10:22:50.384] Value: <not collected>
[10:22:50.384] Conditions captured: <none>
[10:22:50.384] Early signaling: FALSE
[10:22:50.384] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.384] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.396] Chunk #2 of 2 ... DONE
[10:22:50.396] Launching 2 futures (chunks) ... DONE
[10:22:50.396] Resolving 2 futures (chunks) ...
[10:22:50.396] resolve() on list ...
[10:22:50.397]  recursive: 0
[10:22:50.397]  length: 2
[10:22:50.397] 
[10:22:50.397] Future #1
[10:22:50.397] result() for MulticoreFuture ...
[10:22:50.398] result() for MulticoreFuture ...
[10:22:50.399] result() for MulticoreFuture ... done
[10:22:50.399] result() for MulticoreFuture ... done
[10:22:50.399] result() for MulticoreFuture ...
[10:22:50.399] result() for MulticoreFuture ... done
[10:22:50.399] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:50.399] - nx: 2
[10:22:50.400] - relay: TRUE
[10:22:50.400] - stdout: TRUE
[10:22:50.400] - signal: TRUE
[10:22:50.400] - resignal: FALSE
[10:22:50.400] - force: TRUE
[10:22:50.400] - relayed: [n=2] FALSE, FALSE
[10:22:50.401] - queued futures: [n=2] FALSE, FALSE
[10:22:50.401]  - until=1
[10:22:50.401]  - relaying element #1
[10:22:50.401] result() for MulticoreFuture ...
[10:22:50.401] result() for MulticoreFuture ... done
[10:22:50.401] result() for MulticoreFuture ...
[10:22:50.402] result() for MulticoreFuture ... done
[10:22:50.402] result() for MulticoreFuture ...
[10:22:50.402] result() for MulticoreFuture ... done
[10:22:50.402] result() for MulticoreFuture ...
[10:22:50.402] result() for MulticoreFuture ... done
[10:22:50.403] - relayed: [n=2] TRUE, FALSE
[10:22:50.403] - queued futures: [n=2] TRUE, FALSE
[10:22:50.403] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:50.403]  length: 1 (resolved future 1)
[10:22:50.403] Future #2
[10:22:50.403] result() for MulticoreFuture ...
[10:22:50.404] result() for MulticoreFuture ...
[10:22:50.404] result() for MulticoreFuture ... done
[10:22:50.404] result() for MulticoreFuture ... done
[10:22:50.404] result() for MulticoreFuture ...
[10:22:50.405] result() for MulticoreFuture ... done
[10:22:50.405] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:50.405] - nx: 2
[10:22:50.405] - relay: TRUE
[10:22:50.405] - stdout: TRUE
[10:22:50.405] - signal: TRUE
[10:22:50.405] - resignal: FALSE
[10:22:50.405] - force: TRUE
[10:22:50.406] - relayed: [n=2] TRUE, FALSE
[10:22:50.406] - queued futures: [n=2] TRUE, FALSE
[10:22:50.406]  - until=2
[10:22:50.406]  - relaying element #2
[10:22:50.406] result() for MulticoreFuture ...
[10:22:50.406] result() for MulticoreFuture ... done
[10:22:50.406] result() for MulticoreFuture ...
[10:22:50.406] result() for MulticoreFuture ... done
[10:22:50.407] result() for MulticoreFuture ...
[10:22:50.407] result() for MulticoreFuture ... done
[10:22:50.407] result() for MulticoreFuture ...
[10:22:50.407] result() for MulticoreFuture ... done
[10:22:50.407] - relayed: [n=2] TRUE, TRUE
[10:22:50.407] - queued futures: [n=2] TRUE, TRUE
[10:22:50.407] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:50.407]  length: 0 (resolved future 2)
[10:22:50.408] Relaying remaining futures
[10:22:50.408] signalConditionsASAP(NULL, pos=0) ...
[10:22:50.408] - nx: 2
[10:22:50.408] - relay: TRUE
[10:22:50.408] - stdout: TRUE
[10:22:50.408] - signal: TRUE
[10:22:50.408] - resignal: FALSE
[10:22:50.408] - force: TRUE
[10:22:50.408] - relayed: [n=2] TRUE, TRUE
[10:22:50.408] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:50.409] - relayed: [n=2] TRUE, TRUE
[10:22:50.409] - queued futures: [n=2] TRUE, TRUE
[10:22:50.409] signalConditionsASAP(NULL, pos=0) ... done
[10:22:50.409] resolve() on list ... DONE
[10:22:50.409] result() for MulticoreFuture ...
[10:22:50.409] result() for MulticoreFuture ... done
[10:22:50.409] result() for MulticoreFuture ...
[10:22:50.410] result() for MulticoreFuture ... done
[10:22:50.410] result() for MulticoreFuture ...
[10:22:50.410] result() for MulticoreFuture ... done
[10:22:50.410] result() for MulticoreFuture ...
[10:22:50.410] result() for MulticoreFuture ... done
[10:22:50.410]  - Number of value chunks collected: 2
[10:22:50.410] Resolving 2 futures (chunks) ... DONE
[10:22:50.410] Reducing values from 2 chunks ...
[10:22:50.411]  - Number of values collected after concatenation: 3
[10:22:50.411]  - Number of values expected: 3
[10:22:50.411] Reducing values from 2 chunks ... DONE
[10:22:50.411] future_lapply() ... DONE
[10:22:50.411] future_by_internal() ... DONE
[10:22:50.412] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:22:50.413] future_lapply() ...
[10:22:50.418] Number of chunks: 2
[10:22:50.418] getGlobalsAndPackagesXApply() ...
[10:22:50.418]  - future.globals: TRUE
[10:22:50.418] getGlobalsAndPackages() ...
[10:22:50.418] Searching for globals...
[10:22:50.420] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:50.420] Searching for globals ... DONE
[10:22:50.420] Resolving globals: FALSE
[10:22:50.420] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:50.421] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:50.421] - globals: [1] ‘FUN’
[10:22:50.421] 
[10:22:50.421] getGlobalsAndPackages() ... DONE
[10:22:50.421]  - globals found/used: [n=1] ‘FUN’
[10:22:50.422]  - needed namespaces: [n=0] 
[10:22:50.422] Finding globals ... DONE
[10:22:50.422]  - use_args: TRUE
[10:22:50.422]  - Getting '...' globals ...
[10:22:50.422] resolve() on list ...
[10:22:50.422]  recursive: 0
[10:22:50.423]  length: 1
[10:22:50.423]  elements: ‘...’
[10:22:50.423]  length: 0 (resolved future 1)
[10:22:50.423] resolve() on list ... DONE
[10:22:50.423]    - '...' content: [n=0] 
[10:22:50.423] List of 1
[10:22:50.423]  $ ...: list()
[10:22:50.423]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.423]  - attr(*, "where")=List of 1
[10:22:50.423]   ..$ ...:<environment: 0x55f63b295078> 
[10:22:50.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.423]  - attr(*, "resolved")= logi TRUE
[10:22:50.423]  - attr(*, "total_size")= num NA
[10:22:50.427]  - Getting '...' globals ... DONE
[10:22:50.427] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:50.427] List of 2
[10:22:50.427]  $ ...future.FUN:function (object, ...)  
[10:22:50.427]  $ ...          : list()
[10:22:50.427]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.427]  - attr(*, "where")=List of 2
[10:22:50.427]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:50.427]   ..$ ...          :<environment: 0x55f63b295078> 
[10:22:50.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.427]  - attr(*, "resolved")= logi FALSE
[10:22:50.427]  - attr(*, "total_size")= num 1240
[10:22:50.431] Packages to be attached in all futures: [n=0] 
[10:22:50.431] getGlobalsAndPackagesXApply() ... DONE
[10:22:50.431] Number of futures (= number of chunks): 2
[10:22:50.431] Launching 2 futures (chunks) ...
[10:22:50.431] Chunk #1 of 2 ...
[10:22:50.431]  - Finding globals in 'X' for chunk #1 ...
[10:22:50.432] getGlobalsAndPackages() ...
[10:22:50.432] Searching for globals...
[10:22:50.432] 
[10:22:50.432] Searching for globals ... DONE
[10:22:50.432] - globals: [0] <none>
[10:22:50.432] getGlobalsAndPackages() ... DONE
[10:22:50.433]    + additional globals found: [n=0] 
[10:22:50.433]    + additional namespaces needed: [n=0] 
[10:22:50.433]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:50.433]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.433]  - seeds: <none>
[10:22:50.433]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.433] getGlobalsAndPackages() ...
[10:22:50.433] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.434] Resolving globals: FALSE
[10:22:50.434] Tweak future expression to call with '...' arguments ...
[10:22:50.434] {
[10:22:50.434]     do.call(function(...) {
[10:22:50.434]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.434]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.434]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.434]             on.exit(options(oopts), add = TRUE)
[10:22:50.434]         }
[10:22:50.434]         {
[10:22:50.434]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.434]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.434]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.434]             })
[10:22:50.434]         }
[10:22:50.434]     }, args = future.call.arguments)
[10:22:50.434] }
[10:22:50.434] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.435] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.435] 
[10:22:50.435] getGlobalsAndPackages() ... DONE
[10:22:50.435] run() for ‘Future’ ...
[10:22:50.435] - state: ‘created’
[10:22:50.436] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.440] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.440]   - Field: ‘label’
[10:22:50.440]   - Field: ‘local’
[10:22:50.440]   - Field: ‘owner’
[10:22:50.440]   - Field: ‘envir’
[10:22:50.440]   - Field: ‘workers’
[10:22:50.440]   - Field: ‘packages’
[10:22:50.441]   - Field: ‘gc’
[10:22:50.441]   - Field: ‘job’
[10:22:50.441]   - Field: ‘conditions’
[10:22:50.441]   - Field: ‘expr’
[10:22:50.441]   - Field: ‘uuid’
[10:22:50.441]   - Field: ‘seed’
[10:22:50.441]   - Field: ‘version’
[10:22:50.441]   - Field: ‘result’
[10:22:50.442]   - Field: ‘asynchronous’
[10:22:50.442]   - Field: ‘calls’
[10:22:50.442]   - Field: ‘globals’
[10:22:50.442]   - Field: ‘stdout’
[10:22:50.442]   - Field: ‘earlySignal’
[10:22:50.442]   - Field: ‘lazy’
[10:22:50.442]   - Field: ‘state’
[10:22:50.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.443] - Launch lazy future ...
[10:22:50.443] Packages needed by the future expression (n = 0): <none>
[10:22:50.443] Packages needed by future strategies (n = 0): <none>
[10:22:50.444] {
[10:22:50.444]     {
[10:22:50.444]         {
[10:22:50.444]             ...future.startTime <- base::Sys.time()
[10:22:50.444]             {
[10:22:50.444]                 {
[10:22:50.444]                   {
[10:22:50.444]                     {
[10:22:50.444]                       base::local({
[10:22:50.444]                         has_future <- base::requireNamespace("future", 
[10:22:50.444]                           quietly = TRUE)
[10:22:50.444]                         if (has_future) {
[10:22:50.444]                           ns <- base::getNamespace("future")
[10:22:50.444]                           version <- ns[[".package"]][["version"]]
[10:22:50.444]                           if (is.null(version)) 
[10:22:50.444]                             version <- utils::packageVersion("future")
[10:22:50.444]                         }
[10:22:50.444]                         else {
[10:22:50.444]                           version <- NULL
[10:22:50.444]                         }
[10:22:50.444]                         if (!has_future || version < "1.8.0") {
[10:22:50.444]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.444]                             "", base::R.version$version.string), 
[10:22:50.444]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.444]                               "release", "version")], collapse = " "), 
[10:22:50.444]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.444]                             info)
[10:22:50.444]                           info <- base::paste(info, collapse = "; ")
[10:22:50.444]                           if (!has_future) {
[10:22:50.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.444]                               info)
[10:22:50.444]                           }
[10:22:50.444]                           else {
[10:22:50.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.444]                               info, version)
[10:22:50.444]                           }
[10:22:50.444]                           base::stop(msg)
[10:22:50.444]                         }
[10:22:50.444]                       })
[10:22:50.444]                     }
[10:22:50.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.444]                     base::options(mc.cores = 1L)
[10:22:50.444]                   }
[10:22:50.444]                   options(future.plan = NULL)
[10:22:50.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.444]                 }
[10:22:50.444]                 ...future.workdir <- getwd()
[10:22:50.444]             }
[10:22:50.444]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.444]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.444]         }
[10:22:50.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.444]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.444]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.444]             base::names(...future.oldOptions))
[10:22:50.444]     }
[10:22:50.444]     if (FALSE) {
[10:22:50.444]     }
[10:22:50.444]     else {
[10:22:50.444]         if (TRUE) {
[10:22:50.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.444]                 open = "w")
[10:22:50.444]         }
[10:22:50.444]         else {
[10:22:50.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.444]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.444]         }
[10:22:50.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.444]             base::sink(type = "output", split = FALSE)
[10:22:50.444]             base::close(...future.stdout)
[10:22:50.444]         }, add = TRUE)
[10:22:50.444]     }
[10:22:50.444]     ...future.frame <- base::sys.nframe()
[10:22:50.444]     ...future.conditions <- base::list()
[10:22:50.444]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.444]     if (FALSE) {
[10:22:50.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.444]     }
[10:22:50.444]     ...future.result <- base::tryCatch({
[10:22:50.444]         base::withCallingHandlers({
[10:22:50.444]             ...future.value <- base::withVisible(base::local({
[10:22:50.444]                 withCallingHandlers({
[10:22:50.444]                   {
[10:22:50.444]                     do.call(function(...) {
[10:22:50.444]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.444]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.444]                         ...future.globals.maxSize)) {
[10:22:50.444]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.444]                         on.exit(options(oopts), add = TRUE)
[10:22:50.444]                       }
[10:22:50.444]                       {
[10:22:50.444]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.444]                           FUN = function(jj) {
[10:22:50.444]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.444]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.444]                           })
[10:22:50.444]                       }
[10:22:50.444]                     }, args = future.call.arguments)
[10:22:50.444]                   }
[10:22:50.444]                 }, immediateCondition = function(cond) {
[10:22:50.444]                   save_rds <- function (object, pathname, ...) 
[10:22:50.444]                   {
[10:22:50.444]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.444]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.444]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.444]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.444]                         fi_tmp[["mtime"]])
[10:22:50.444]                     }
[10:22:50.444]                     tryCatch({
[10:22:50.444]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.444]                     }, error = function(ex) {
[10:22:50.444]                       msg <- conditionMessage(ex)
[10:22:50.444]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.444]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.444]                         fi_tmp[["mtime"]], msg)
[10:22:50.444]                       ex$message <- msg
[10:22:50.444]                       stop(ex)
[10:22:50.444]                     })
[10:22:50.444]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.444]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.444]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.444]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.444]                       fi <- file.info(pathname)
[10:22:50.444]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.444]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.444]                         fi[["size"]], fi[["mtime"]])
[10:22:50.444]                       stop(msg)
[10:22:50.444]                     }
[10:22:50.444]                     invisible(pathname)
[10:22:50.444]                   }
[10:22:50.444]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.444]                     rootPath = tempdir()) 
[10:22:50.444]                   {
[10:22:50.444]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.444]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.444]                       tmpdir = path, fileext = ".rds")
[10:22:50.444]                     save_rds(obj, file)
[10:22:50.444]                   }
[10:22:50.444]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.444]                   {
[10:22:50.444]                     inherits <- base::inherits
[10:22:50.444]                     invokeRestart <- base::invokeRestart
[10:22:50.444]                     is.null <- base::is.null
[10:22:50.444]                     muffled <- FALSE
[10:22:50.444]                     if (inherits(cond, "message")) {
[10:22:50.444]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.444]                       if (muffled) 
[10:22:50.444]                         invokeRestart("muffleMessage")
[10:22:50.444]                     }
[10:22:50.444]                     else if (inherits(cond, "warning")) {
[10:22:50.444]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.444]                       if (muffled) 
[10:22:50.444]                         invokeRestart("muffleWarning")
[10:22:50.444]                     }
[10:22:50.444]                     else if (inherits(cond, "condition")) {
[10:22:50.444]                       if (!is.null(pattern)) {
[10:22:50.444]                         computeRestarts <- base::computeRestarts
[10:22:50.444]                         grepl <- base::grepl
[10:22:50.444]                         restarts <- computeRestarts(cond)
[10:22:50.444]                         for (restart in restarts) {
[10:22:50.444]                           name <- restart$name
[10:22:50.444]                           if (is.null(name)) 
[10:22:50.444]                             next
[10:22:50.444]                           if (!grepl(pattern, name)) 
[10:22:50.444]                             next
[10:22:50.444]                           invokeRestart(restart)
[10:22:50.444]                           muffled <- TRUE
[10:22:50.444]                           break
[10:22:50.444]                         }
[10:22:50.444]                       }
[10:22:50.444]                     }
[10:22:50.444]                     invisible(muffled)
[10:22:50.444]                   }
[10:22:50.444]                   muffleCondition(cond)
[10:22:50.444]                 })
[10:22:50.444]             }))
[10:22:50.444]             future::FutureResult(value = ...future.value$value, 
[10:22:50.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.444]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.444]                     ...future.globalenv.names))
[10:22:50.444]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.444]         }, condition = base::local({
[10:22:50.444]             c <- base::c
[10:22:50.444]             inherits <- base::inherits
[10:22:50.444]             invokeRestart <- base::invokeRestart
[10:22:50.444]             length <- base::length
[10:22:50.444]             list <- base::list
[10:22:50.444]             seq.int <- base::seq.int
[10:22:50.444]             signalCondition <- base::signalCondition
[10:22:50.444]             sys.calls <- base::sys.calls
[10:22:50.444]             `[[` <- base::`[[`
[10:22:50.444]             `+` <- base::`+`
[10:22:50.444]             `<<-` <- base::`<<-`
[10:22:50.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.444]                   3L)]
[10:22:50.444]             }
[10:22:50.444]             function(cond) {
[10:22:50.444]                 is_error <- inherits(cond, "error")
[10:22:50.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.444]                   NULL)
[10:22:50.444]                 if (is_error) {
[10:22:50.444]                   sessionInformation <- function() {
[10:22:50.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.444]                       search = base::search(), system = base::Sys.info())
[10:22:50.444]                   }
[10:22:50.444]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.444]                     cond$call), session = sessionInformation(), 
[10:22:50.444]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.444]                   signalCondition(cond)
[10:22:50.444]                 }
[10:22:50.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.444]                 "immediateCondition"))) {
[10:22:50.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.444]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.444]                   if (TRUE && !signal) {
[10:22:50.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.444]                     {
[10:22:50.444]                       inherits <- base::inherits
[10:22:50.444]                       invokeRestart <- base::invokeRestart
[10:22:50.444]                       is.null <- base::is.null
[10:22:50.444]                       muffled <- FALSE
[10:22:50.444]                       if (inherits(cond, "message")) {
[10:22:50.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.444]                         if (muffled) 
[10:22:50.444]                           invokeRestart("muffleMessage")
[10:22:50.444]                       }
[10:22:50.444]                       else if (inherits(cond, "warning")) {
[10:22:50.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.444]                         if (muffled) 
[10:22:50.444]                           invokeRestart("muffleWarning")
[10:22:50.444]                       }
[10:22:50.444]                       else if (inherits(cond, "condition")) {
[10:22:50.444]                         if (!is.null(pattern)) {
[10:22:50.444]                           computeRestarts <- base::computeRestarts
[10:22:50.444]                           grepl <- base::grepl
[10:22:50.444]                           restarts <- computeRestarts(cond)
[10:22:50.444]                           for (restart in restarts) {
[10:22:50.444]                             name <- restart$name
[10:22:50.444]                             if (is.null(name)) 
[10:22:50.444]                               next
[10:22:50.444]                             if (!grepl(pattern, name)) 
[10:22:50.444]                               next
[10:22:50.444]                             invokeRestart(restart)
[10:22:50.444]                             muffled <- TRUE
[10:22:50.444]                             break
[10:22:50.444]                           }
[10:22:50.444]                         }
[10:22:50.444]                       }
[10:22:50.444]                       invisible(muffled)
[10:22:50.444]                     }
[10:22:50.444]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.444]                   }
[10:22:50.444]                 }
[10:22:50.444]                 else {
[10:22:50.444]                   if (TRUE) {
[10:22:50.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.444]                     {
[10:22:50.444]                       inherits <- base::inherits
[10:22:50.444]                       invokeRestart <- base::invokeRestart
[10:22:50.444]                       is.null <- base::is.null
[10:22:50.444]                       muffled <- FALSE
[10:22:50.444]                       if (inherits(cond, "message")) {
[10:22:50.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.444]                         if (muffled) 
[10:22:50.444]                           invokeRestart("muffleMessage")
[10:22:50.444]                       }
[10:22:50.444]                       else if (inherits(cond, "warning")) {
[10:22:50.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.444]                         if (muffled) 
[10:22:50.444]                           invokeRestart("muffleWarning")
[10:22:50.444]                       }
[10:22:50.444]                       else if (inherits(cond, "condition")) {
[10:22:50.444]                         if (!is.null(pattern)) {
[10:22:50.444]                           computeRestarts <- base::computeRestarts
[10:22:50.444]                           grepl <- base::grepl
[10:22:50.444]                           restarts <- computeRestarts(cond)
[10:22:50.444]                           for (restart in restarts) {
[10:22:50.444]                             name <- restart$name
[10:22:50.444]                             if (is.null(name)) 
[10:22:50.444]                               next
[10:22:50.444]                             if (!grepl(pattern, name)) 
[10:22:50.444]                               next
[10:22:50.444]                             invokeRestart(restart)
[10:22:50.444]                             muffled <- TRUE
[10:22:50.444]                             break
[10:22:50.444]                           }
[10:22:50.444]                         }
[10:22:50.444]                       }
[10:22:50.444]                       invisible(muffled)
[10:22:50.444]                     }
[10:22:50.444]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.444]                   }
[10:22:50.444]                 }
[10:22:50.444]             }
[10:22:50.444]         }))
[10:22:50.444]     }, error = function(ex) {
[10:22:50.444]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.444]                 ...future.rng), started = ...future.startTime, 
[10:22:50.444]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.444]             version = "1.8"), class = "FutureResult")
[10:22:50.444]     }, finally = {
[10:22:50.444]         if (!identical(...future.workdir, getwd())) 
[10:22:50.444]             setwd(...future.workdir)
[10:22:50.444]         {
[10:22:50.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.444]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.444]             }
[10:22:50.444]             base::options(...future.oldOptions)
[10:22:50.444]             if (.Platform$OS.type == "windows") {
[10:22:50.444]                 old_names <- names(...future.oldEnvVars)
[10:22:50.444]                 envs <- base::Sys.getenv()
[10:22:50.444]                 names <- names(envs)
[10:22:50.444]                 common <- intersect(names, old_names)
[10:22:50.444]                 added <- setdiff(names, old_names)
[10:22:50.444]                 removed <- setdiff(old_names, names)
[10:22:50.444]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.444]                   envs[common]]
[10:22:50.444]                 NAMES <- toupper(changed)
[10:22:50.444]                 args <- list()
[10:22:50.444]                 for (kk in seq_along(NAMES)) {
[10:22:50.444]                   name <- changed[[kk]]
[10:22:50.444]                   NAME <- NAMES[[kk]]
[10:22:50.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.444]                     next
[10:22:50.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.444]                 }
[10:22:50.444]                 NAMES <- toupper(added)
[10:22:50.444]                 for (kk in seq_along(NAMES)) {
[10:22:50.444]                   name <- added[[kk]]
[10:22:50.444]                   NAME <- NAMES[[kk]]
[10:22:50.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.444]                     next
[10:22:50.444]                   args[[name]] <- ""
[10:22:50.444]                 }
[10:22:50.444]                 NAMES <- toupper(removed)
[10:22:50.444]                 for (kk in seq_along(NAMES)) {
[10:22:50.444]                   name <- removed[[kk]]
[10:22:50.444]                   NAME <- NAMES[[kk]]
[10:22:50.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.444]                     next
[10:22:50.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.444]                 }
[10:22:50.444]                 if (length(args) > 0) 
[10:22:50.444]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.444]             }
[10:22:50.444]             else {
[10:22:50.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.444]             }
[10:22:50.444]             {
[10:22:50.444]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.444]                   0L) {
[10:22:50.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.444]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.444]                   base::options(opts)
[10:22:50.444]                 }
[10:22:50.444]                 {
[10:22:50.444]                   {
[10:22:50.444]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.444]                     NULL
[10:22:50.444]                   }
[10:22:50.444]                   options(future.plan = NULL)
[10:22:50.444]                   if (is.na(NA_character_)) 
[10:22:50.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.444]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.444]                     envir = parent.frame()) 
[10:22:50.444]                   {
[10:22:50.444]                     default_workers <- missing(workers)
[10:22:50.444]                     if (is.function(workers)) 
[10:22:50.444]                       workers <- workers()
[10:22:50.444]                     workers <- structure(as.integer(workers), 
[10:22:50.444]                       class = class(workers))
[10:22:50.444]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.444]                       1L)
[10:22:50.444]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.444]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.444]                       if (default_workers) 
[10:22:50.444]                         supportsMulticore(warn = TRUE)
[10:22:50.444]                       return(sequential(..., envir = envir))
[10:22:50.444]                     }
[10:22:50.444]                     oopts <- options(mc.cores = workers)
[10:22:50.444]                     on.exit(options(oopts))
[10:22:50.444]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.444]                       envir = envir)
[10:22:50.444]                     if (!future$lazy) 
[10:22:50.444]                       future <- run(future)
[10:22:50.444]                     invisible(future)
[10:22:50.444]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.444]                 }
[10:22:50.444]             }
[10:22:50.444]         }
[10:22:50.444]     })
[10:22:50.444]     if (TRUE) {
[10:22:50.444]         base::sink(type = "output", split = FALSE)
[10:22:50.444]         if (TRUE) {
[10:22:50.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.444]         }
[10:22:50.444]         else {
[10:22:50.444]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.444]         }
[10:22:50.444]         base::close(...future.stdout)
[10:22:50.444]         ...future.stdout <- NULL
[10:22:50.444]     }
[10:22:50.444]     ...future.result$conditions <- ...future.conditions
[10:22:50.444]     ...future.result$finished <- base::Sys.time()
[10:22:50.444]     ...future.result
[10:22:50.444] }
[10:22:50.446] assign_globals() ...
[10:22:50.447] List of 5
[10:22:50.447]  $ ...future.FUN            :function (object, ...)  
[10:22:50.447]  $ future.call.arguments    : list()
[10:22:50.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.447]  $ ...future.elements_ii    :List of 1
[10:22:50.447]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.447]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:22:50.447]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.447]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:50.447]  $ ...future.seeds_ii       : NULL
[10:22:50.447]  $ ...future.globals.maxSize: NULL
[10:22:50.447]  - attr(*, "where")=List of 5
[10:22:50.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.447]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.447]  - attr(*, "resolved")= logi FALSE
[10:22:50.447]  - attr(*, "total_size")= num 1240
[10:22:50.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.447]  - attr(*, "already-done")= logi TRUE
[10:22:50.454] - copied ‘...future.FUN’ to environment
[10:22:50.454] - copied ‘future.call.arguments’ to environment
[10:22:50.454] - copied ‘...future.elements_ii’ to environment
[10:22:50.454] - copied ‘...future.seeds_ii’ to environment
[10:22:50.454] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.455] assign_globals() ... done
[10:22:50.455] requestCore(): workers = 2
[10:22:50.457] MulticoreFuture started
[10:22:50.457] - Launch lazy future ... done
[10:22:50.457] run() for ‘MulticoreFuture’ ... done
[10:22:50.458] Created future:
[10:22:50.458] plan(): Setting new future strategy stack:
[10:22:50.458] List of future strategies:
[10:22:50.458] 1. sequential:
[10:22:50.458]    - args: function (..., envir = parent.frame())
[10:22:50.458]    - tweaked: FALSE
[10:22:50.458]    - call: NULL
[10:22:50.459] plan(): nbrOfWorkers() = 1
[10:22:50.462] plan(): Setting new future strategy stack:
[10:22:50.462] List of future strategies:
[10:22:50.462] 1. multicore:
[10:22:50.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.462]    - tweaked: FALSE
[10:22:50.462]    - call: plan(strategy)
[10:22:50.467] plan(): nbrOfWorkers() = 2
[10:22:50.458] MulticoreFuture:
[10:22:50.458] Label: ‘future_by-1’
[10:22:50.458] Expression:
[10:22:50.458] {
[10:22:50.458]     do.call(function(...) {
[10:22:50.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.458]             on.exit(options(oopts), add = TRUE)
[10:22:50.458]         }
[10:22:50.458]         {
[10:22:50.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.458]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.458]             })
[10:22:50.458]         }
[10:22:50.458]     }, args = future.call.arguments)
[10:22:50.458] }
[10:22:50.458] Lazy evaluation: FALSE
[10:22:50.458] Asynchronous evaluation: TRUE
[10:22:50.458] Local evaluation: TRUE
[10:22:50.458] Environment: 0x55f63b2601c0
[10:22:50.458] Capture standard output: TRUE
[10:22:50.458] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.458] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:50.458] Packages: <none>
[10:22:50.458] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.458] Resolved: TRUE
[10:22:50.458] Value: <not collected>
[10:22:50.458] Conditions captured: <none>
[10:22:50.458] Early signaling: FALSE
[10:22:50.458] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.458] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.468] Chunk #1 of 2 ... DONE
[10:22:50.468] Chunk #2 of 2 ...
[10:22:50.468]  - Finding globals in 'X' for chunk #2 ...
[10:22:50.468] getGlobalsAndPackages() ...
[10:22:50.469] Searching for globals...
[10:22:50.469] 
[10:22:50.469] Searching for globals ... DONE
[10:22:50.470] - globals: [0] <none>
[10:22:50.470] getGlobalsAndPackages() ... DONE
[10:22:50.470]    + additional globals found: [n=0] 
[10:22:50.470]    + additional namespaces needed: [n=0] 
[10:22:50.470]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:50.470]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:50.470]  - seeds: <none>
[10:22:50.470]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.471] getGlobalsAndPackages() ...
[10:22:50.471] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.471] Resolving globals: FALSE
[10:22:50.471] Tweak future expression to call with '...' arguments ...
[10:22:50.471] {
[10:22:50.471]     do.call(function(...) {
[10:22:50.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.471]             on.exit(options(oopts), add = TRUE)
[10:22:50.471]         }
[10:22:50.471]         {
[10:22:50.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.471]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.471]             })
[10:22:50.471]         }
[10:22:50.471]     }, args = future.call.arguments)
[10:22:50.471] }
[10:22:50.472] Tweak future expression to call with '...' arguments ... DONE
[10:22:50.472] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:50.472] 
[10:22:50.472] getGlobalsAndPackages() ... DONE
[10:22:50.473] run() for ‘Future’ ...
[10:22:50.473] - state: ‘created’
[10:22:50.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.483] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.483] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:50.484]   - Field: ‘label’
[10:22:50.484]   - Field: ‘local’
[10:22:50.484]   - Field: ‘owner’
[10:22:50.484]   - Field: ‘envir’
[10:22:50.484]   - Field: ‘workers’
[10:22:50.484]   - Field: ‘packages’
[10:22:50.484]   - Field: ‘gc’
[10:22:50.485]   - Field: ‘job’
[10:22:50.485]   - Field: ‘conditions’
[10:22:50.485]   - Field: ‘expr’
[10:22:50.485]   - Field: ‘uuid’
[10:22:50.485]   - Field: ‘seed’
[10:22:50.485]   - Field: ‘version’
[10:22:50.485]   - Field: ‘result’
[10:22:50.485]   - Field: ‘asynchronous’
[10:22:50.486]   - Field: ‘calls’
[10:22:50.486]   - Field: ‘globals’
[10:22:50.486]   - Field: ‘stdout’
[10:22:50.486]   - Field: ‘earlySignal’
[10:22:50.486]   - Field: ‘lazy’
[10:22:50.486]   - Field: ‘state’
[10:22:50.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:50.486] - Launch lazy future ...
[10:22:50.487] Packages needed by the future expression (n = 0): <none>
[10:22:50.487] Packages needed by future strategies (n = 0): <none>
[10:22:50.488] {
[10:22:50.488]     {
[10:22:50.488]         {
[10:22:50.488]             ...future.startTime <- base::Sys.time()
[10:22:50.488]             {
[10:22:50.488]                 {
[10:22:50.488]                   {
[10:22:50.488]                     {
[10:22:50.488]                       base::local({
[10:22:50.488]                         has_future <- base::requireNamespace("future", 
[10:22:50.488]                           quietly = TRUE)
[10:22:50.488]                         if (has_future) {
[10:22:50.488]                           ns <- base::getNamespace("future")
[10:22:50.488]                           version <- ns[[".package"]][["version"]]
[10:22:50.488]                           if (is.null(version)) 
[10:22:50.488]                             version <- utils::packageVersion("future")
[10:22:50.488]                         }
[10:22:50.488]                         else {
[10:22:50.488]                           version <- NULL
[10:22:50.488]                         }
[10:22:50.488]                         if (!has_future || version < "1.8.0") {
[10:22:50.488]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.488]                             "", base::R.version$version.string), 
[10:22:50.488]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.488]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.488]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.488]                               "release", "version")], collapse = " "), 
[10:22:50.488]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.488]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.488]                             info)
[10:22:50.488]                           info <- base::paste(info, collapse = "; ")
[10:22:50.488]                           if (!has_future) {
[10:22:50.488]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.488]                               info)
[10:22:50.488]                           }
[10:22:50.488]                           else {
[10:22:50.488]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.488]                               info, version)
[10:22:50.488]                           }
[10:22:50.488]                           base::stop(msg)
[10:22:50.488]                         }
[10:22:50.488]                       })
[10:22:50.488]                     }
[10:22:50.488]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.488]                     base::options(mc.cores = 1L)
[10:22:50.488]                   }
[10:22:50.488]                   options(future.plan = NULL)
[10:22:50.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.488]                 }
[10:22:50.488]                 ...future.workdir <- getwd()
[10:22:50.488]             }
[10:22:50.488]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.488]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.488]         }
[10:22:50.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.488]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:50.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.488]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.488]             base::names(...future.oldOptions))
[10:22:50.488]     }
[10:22:50.488]     if (FALSE) {
[10:22:50.488]     }
[10:22:50.488]     else {
[10:22:50.488]         if (TRUE) {
[10:22:50.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.488]                 open = "w")
[10:22:50.488]         }
[10:22:50.488]         else {
[10:22:50.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.488]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.488]         }
[10:22:50.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.488]             base::sink(type = "output", split = FALSE)
[10:22:50.488]             base::close(...future.stdout)
[10:22:50.488]         }, add = TRUE)
[10:22:50.488]     }
[10:22:50.488]     ...future.frame <- base::sys.nframe()
[10:22:50.488]     ...future.conditions <- base::list()
[10:22:50.488]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.488]     if (FALSE) {
[10:22:50.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.488]     }
[10:22:50.488]     ...future.result <- base::tryCatch({
[10:22:50.488]         base::withCallingHandlers({
[10:22:50.488]             ...future.value <- base::withVisible(base::local({
[10:22:50.488]                 withCallingHandlers({
[10:22:50.488]                   {
[10:22:50.488]                     do.call(function(...) {
[10:22:50.488]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.488]                       if (!identical(...future.globals.maxSize.org, 
[10:22:50.488]                         ...future.globals.maxSize)) {
[10:22:50.488]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.488]                         on.exit(options(oopts), add = TRUE)
[10:22:50.488]                       }
[10:22:50.488]                       {
[10:22:50.488]                         lapply(seq_along(...future.elements_ii), 
[10:22:50.488]                           FUN = function(jj) {
[10:22:50.488]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.488]                             ...future.FUN(...future.X_jj, ...)
[10:22:50.488]                           })
[10:22:50.488]                       }
[10:22:50.488]                     }, args = future.call.arguments)
[10:22:50.488]                   }
[10:22:50.488]                 }, immediateCondition = function(cond) {
[10:22:50.488]                   save_rds <- function (object, pathname, ...) 
[10:22:50.488]                   {
[10:22:50.488]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:50.488]                     if (file_test("-f", pathname_tmp)) {
[10:22:50.488]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.488]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:50.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.488]                         fi_tmp[["mtime"]])
[10:22:50.488]                     }
[10:22:50.488]                     tryCatch({
[10:22:50.488]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:50.488]                     }, error = function(ex) {
[10:22:50.488]                       msg <- conditionMessage(ex)
[10:22:50.488]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.488]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:50.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.488]                         fi_tmp[["mtime"]], msg)
[10:22:50.488]                       ex$message <- msg
[10:22:50.488]                       stop(ex)
[10:22:50.488]                     })
[10:22:50.488]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:50.488]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:50.488]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:50.488]                       fi_tmp <- file.info(pathname_tmp)
[10:22:50.488]                       fi <- file.info(pathname)
[10:22:50.488]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:50.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:50.488]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:50.488]                         fi[["size"]], fi[["mtime"]])
[10:22:50.488]                       stop(msg)
[10:22:50.488]                     }
[10:22:50.488]                     invisible(pathname)
[10:22:50.488]                   }
[10:22:50.488]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:50.488]                     rootPath = tempdir()) 
[10:22:50.488]                   {
[10:22:50.488]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:50.488]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:50.488]                       tmpdir = path, fileext = ".rds")
[10:22:50.488]                     save_rds(obj, file)
[10:22:50.488]                   }
[10:22:50.488]                   saveImmediateCondition(cond, path = "/tmp/RtmpDejBuO/.future/immediateConditions")
[10:22:50.488]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.488]                   {
[10:22:50.488]                     inherits <- base::inherits
[10:22:50.488]                     invokeRestart <- base::invokeRestart
[10:22:50.488]                     is.null <- base::is.null
[10:22:50.488]                     muffled <- FALSE
[10:22:50.488]                     if (inherits(cond, "message")) {
[10:22:50.488]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.488]                       if (muffled) 
[10:22:50.488]                         invokeRestart("muffleMessage")
[10:22:50.488]                     }
[10:22:50.488]                     else if (inherits(cond, "warning")) {
[10:22:50.488]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.488]                       if (muffled) 
[10:22:50.488]                         invokeRestart("muffleWarning")
[10:22:50.488]                     }
[10:22:50.488]                     else if (inherits(cond, "condition")) {
[10:22:50.488]                       if (!is.null(pattern)) {
[10:22:50.488]                         computeRestarts <- base::computeRestarts
[10:22:50.488]                         grepl <- base::grepl
[10:22:50.488]                         restarts <- computeRestarts(cond)
[10:22:50.488]                         for (restart in restarts) {
[10:22:50.488]                           name <- restart$name
[10:22:50.488]                           if (is.null(name)) 
[10:22:50.488]                             next
[10:22:50.488]                           if (!grepl(pattern, name)) 
[10:22:50.488]                             next
[10:22:50.488]                           invokeRestart(restart)
[10:22:50.488]                           muffled <- TRUE
[10:22:50.488]                           break
[10:22:50.488]                         }
[10:22:50.488]                       }
[10:22:50.488]                     }
[10:22:50.488]                     invisible(muffled)
[10:22:50.488]                   }
[10:22:50.488]                   muffleCondition(cond)
[10:22:50.488]                 })
[10:22:50.488]             }))
[10:22:50.488]             future::FutureResult(value = ...future.value$value, 
[10:22:50.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.488]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.488]                     ...future.globalenv.names))
[10:22:50.488]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.488]         }, condition = base::local({
[10:22:50.488]             c <- base::c
[10:22:50.488]             inherits <- base::inherits
[10:22:50.488]             invokeRestart <- base::invokeRestart
[10:22:50.488]             length <- base::length
[10:22:50.488]             list <- base::list
[10:22:50.488]             seq.int <- base::seq.int
[10:22:50.488]             signalCondition <- base::signalCondition
[10:22:50.488]             sys.calls <- base::sys.calls
[10:22:50.488]             `[[` <- base::`[[`
[10:22:50.488]             `+` <- base::`+`
[10:22:50.488]             `<<-` <- base::`<<-`
[10:22:50.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.488]                   3L)]
[10:22:50.488]             }
[10:22:50.488]             function(cond) {
[10:22:50.488]                 is_error <- inherits(cond, "error")
[10:22:50.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.488]                   NULL)
[10:22:50.488]                 if (is_error) {
[10:22:50.488]                   sessionInformation <- function() {
[10:22:50.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.488]                       search = base::search(), system = base::Sys.info())
[10:22:50.488]                   }
[10:22:50.488]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.488]                     cond$call), session = sessionInformation(), 
[10:22:50.488]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.488]                   signalCondition(cond)
[10:22:50.488]                 }
[10:22:50.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.488]                 "immediateCondition"))) {
[10:22:50.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.488]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.488]                   if (TRUE && !signal) {
[10:22:50.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.488]                     {
[10:22:50.488]                       inherits <- base::inherits
[10:22:50.488]                       invokeRestart <- base::invokeRestart
[10:22:50.488]                       is.null <- base::is.null
[10:22:50.488]                       muffled <- FALSE
[10:22:50.488]                       if (inherits(cond, "message")) {
[10:22:50.488]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.488]                         if (muffled) 
[10:22:50.488]                           invokeRestart("muffleMessage")
[10:22:50.488]                       }
[10:22:50.488]                       else if (inherits(cond, "warning")) {
[10:22:50.488]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.488]                         if (muffled) 
[10:22:50.488]                           invokeRestart("muffleWarning")
[10:22:50.488]                       }
[10:22:50.488]                       else if (inherits(cond, "condition")) {
[10:22:50.488]                         if (!is.null(pattern)) {
[10:22:50.488]                           computeRestarts <- base::computeRestarts
[10:22:50.488]                           grepl <- base::grepl
[10:22:50.488]                           restarts <- computeRestarts(cond)
[10:22:50.488]                           for (restart in restarts) {
[10:22:50.488]                             name <- restart$name
[10:22:50.488]                             if (is.null(name)) 
[10:22:50.488]                               next
[10:22:50.488]                             if (!grepl(pattern, name)) 
[10:22:50.488]                               next
[10:22:50.488]                             invokeRestart(restart)
[10:22:50.488]                             muffled <- TRUE
[10:22:50.488]                             break
[10:22:50.488]                           }
[10:22:50.488]                         }
[10:22:50.488]                       }
[10:22:50.488]                       invisible(muffled)
[10:22:50.488]                     }
[10:22:50.488]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.488]                   }
[10:22:50.488]                 }
[10:22:50.488]                 else {
[10:22:50.488]                   if (TRUE) {
[10:22:50.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.488]                     {
[10:22:50.488]                       inherits <- base::inherits
[10:22:50.488]                       invokeRestart <- base::invokeRestart
[10:22:50.488]                       is.null <- base::is.null
[10:22:50.488]                       muffled <- FALSE
[10:22:50.488]                       if (inherits(cond, "message")) {
[10:22:50.488]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.488]                         if (muffled) 
[10:22:50.488]                           invokeRestart("muffleMessage")
[10:22:50.488]                       }
[10:22:50.488]                       else if (inherits(cond, "warning")) {
[10:22:50.488]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.488]                         if (muffled) 
[10:22:50.488]                           invokeRestart("muffleWarning")
[10:22:50.488]                       }
[10:22:50.488]                       else if (inherits(cond, "condition")) {
[10:22:50.488]                         if (!is.null(pattern)) {
[10:22:50.488]                           computeRestarts <- base::computeRestarts
[10:22:50.488]                           grepl <- base::grepl
[10:22:50.488]                           restarts <- computeRestarts(cond)
[10:22:50.488]                           for (restart in restarts) {
[10:22:50.488]                             name <- restart$name
[10:22:50.488]                             if (is.null(name)) 
[10:22:50.488]                               next
[10:22:50.488]                             if (!grepl(pattern, name)) 
[10:22:50.488]                               next
[10:22:50.488]                             invokeRestart(restart)
[10:22:50.488]                             muffled <- TRUE
[10:22:50.488]                             break
[10:22:50.488]                           }
[10:22:50.488]                         }
[10:22:50.488]                       }
[10:22:50.488]                       invisible(muffled)
[10:22:50.488]                     }
[10:22:50.488]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.488]                   }
[10:22:50.488]                 }
[10:22:50.488]             }
[10:22:50.488]         }))
[10:22:50.488]     }, error = function(ex) {
[10:22:50.488]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.488]                 ...future.rng), started = ...future.startTime, 
[10:22:50.488]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.488]             version = "1.8"), class = "FutureResult")
[10:22:50.488]     }, finally = {
[10:22:50.488]         if (!identical(...future.workdir, getwd())) 
[10:22:50.488]             setwd(...future.workdir)
[10:22:50.488]         {
[10:22:50.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.488]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.488]             }
[10:22:50.488]             base::options(...future.oldOptions)
[10:22:50.488]             if (.Platform$OS.type == "windows") {
[10:22:50.488]                 old_names <- names(...future.oldEnvVars)
[10:22:50.488]                 envs <- base::Sys.getenv()
[10:22:50.488]                 names <- names(envs)
[10:22:50.488]                 common <- intersect(names, old_names)
[10:22:50.488]                 added <- setdiff(names, old_names)
[10:22:50.488]                 removed <- setdiff(old_names, names)
[10:22:50.488]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.488]                   envs[common]]
[10:22:50.488]                 NAMES <- toupper(changed)
[10:22:50.488]                 args <- list()
[10:22:50.488]                 for (kk in seq_along(NAMES)) {
[10:22:50.488]                   name <- changed[[kk]]
[10:22:50.488]                   NAME <- NAMES[[kk]]
[10:22:50.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.488]                     next
[10:22:50.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.488]                 }
[10:22:50.488]                 NAMES <- toupper(added)
[10:22:50.488]                 for (kk in seq_along(NAMES)) {
[10:22:50.488]                   name <- added[[kk]]
[10:22:50.488]                   NAME <- NAMES[[kk]]
[10:22:50.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.488]                     next
[10:22:50.488]                   args[[name]] <- ""
[10:22:50.488]                 }
[10:22:50.488]                 NAMES <- toupper(removed)
[10:22:50.488]                 for (kk in seq_along(NAMES)) {
[10:22:50.488]                   name <- removed[[kk]]
[10:22:50.488]                   NAME <- NAMES[[kk]]
[10:22:50.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.488]                     next
[10:22:50.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.488]                 }
[10:22:50.488]                 if (length(args) > 0) 
[10:22:50.488]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.488]             }
[10:22:50.488]             else {
[10:22:50.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.488]             }
[10:22:50.488]             {
[10:22:50.488]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.488]                   0L) {
[10:22:50.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.488]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.488]                   base::options(opts)
[10:22:50.488]                 }
[10:22:50.488]                 {
[10:22:50.488]                   {
[10:22:50.488]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.488]                     NULL
[10:22:50.488]                   }
[10:22:50.488]                   options(future.plan = NULL)
[10:22:50.488]                   if (is.na(NA_character_)) 
[10:22:50.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.488]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:50.488]                     envir = parent.frame()) 
[10:22:50.488]                   {
[10:22:50.488]                     default_workers <- missing(workers)
[10:22:50.488]                     if (is.function(workers)) 
[10:22:50.488]                       workers <- workers()
[10:22:50.488]                     workers <- structure(as.integer(workers), 
[10:22:50.488]                       class = class(workers))
[10:22:50.488]                     stop_if_not(is.finite(workers), workers >= 
[10:22:50.488]                       1L)
[10:22:50.488]                     if ((workers == 1L && !inherits(workers, 
[10:22:50.488]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:50.488]                       if (default_workers) 
[10:22:50.488]                         supportsMulticore(warn = TRUE)
[10:22:50.488]                       return(sequential(..., envir = envir))
[10:22:50.488]                     }
[10:22:50.488]                     oopts <- options(mc.cores = workers)
[10:22:50.488]                     on.exit(options(oopts))
[10:22:50.488]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:50.488]                       envir = envir)
[10:22:50.488]                     if (!future$lazy) 
[10:22:50.488]                       future <- run(future)
[10:22:50.488]                     invisible(future)
[10:22:50.488]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:50.488]                 }
[10:22:50.488]             }
[10:22:50.488]         }
[10:22:50.488]     })
[10:22:50.488]     if (TRUE) {
[10:22:50.488]         base::sink(type = "output", split = FALSE)
[10:22:50.488]         if (TRUE) {
[10:22:50.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.488]         }
[10:22:50.488]         else {
[10:22:50.488]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.488]         }
[10:22:50.488]         base::close(...future.stdout)
[10:22:50.488]         ...future.stdout <- NULL
[10:22:50.488]     }
[10:22:50.488]     ...future.result$conditions <- ...future.conditions
[10:22:50.488]     ...future.result$finished <- base::Sys.time()
[10:22:50.488]     ...future.result
[10:22:50.488] }
[10:22:50.490] assign_globals() ...
[10:22:50.490] List of 5
[10:22:50.490]  $ ...future.FUN            :function (object, ...)  
[10:22:50.490]  $ future.call.arguments    : list()
[10:22:50.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:50.490]  $ ...future.elements_ii    :List of 2
[10:22:50.490]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.490]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:22:50.490]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.490]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:22:50.490]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:22:50.490]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:22:50.490]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:22:50.490]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:22:50.490]  $ ...future.seeds_ii       : NULL
[10:22:50.490]  $ ...future.globals.maxSize: NULL
[10:22:50.490]  - attr(*, "where")=List of 5
[10:22:50.490]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:50.490]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:50.490]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:50.490]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:50.490]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:50.490]  - attr(*, "resolved")= logi FALSE
[10:22:50.490]  - attr(*, "total_size")= num 1240
[10:22:50.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:50.490]  - attr(*, "already-done")= logi TRUE
[10:22:50.501] - copied ‘...future.FUN’ to environment
[10:22:50.501] - copied ‘future.call.arguments’ to environment
[10:22:50.501] - copied ‘...future.elements_ii’ to environment
[10:22:50.501] - copied ‘...future.seeds_ii’ to environment
[10:22:50.501] - copied ‘...future.globals.maxSize’ to environment
[10:22:50.501] assign_globals() ... done
[10:22:50.501] requestCore(): workers = 2
[10:22:50.504] MulticoreFuture started
[10:22:50.504] - Launch lazy future ... done
[10:22:50.504] run() for ‘MulticoreFuture’ ... done
[10:22:50.505] Created future:
[10:22:50.505] plan(): Setting new future strategy stack:
[10:22:50.505] List of future strategies:
[10:22:50.505] 1. sequential:
[10:22:50.505]    - args: function (..., envir = parent.frame())
[10:22:50.505]    - tweaked: FALSE
[10:22:50.505]    - call: NULL
[10:22:50.506] plan(): nbrOfWorkers() = 1
[10:22:50.510] plan(): Setting new future strategy stack:
[10:22:50.511] List of future strategies:
[10:22:50.511] 1. multicore:
[10:22:50.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:50.511]    - tweaked: FALSE
[10:22:50.511]    - call: plan(strategy)
[10:22:50.516] plan(): nbrOfWorkers() = 2
[10:22:50.505] MulticoreFuture:
[10:22:50.505] Label: ‘future_by-2’
[10:22:50.505] Expression:
[10:22:50.505] {
[10:22:50.505]     do.call(function(...) {
[10:22:50.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:50.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:50.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:50.505]             on.exit(options(oopts), add = TRUE)
[10:22:50.505]         }
[10:22:50.505]         {
[10:22:50.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:50.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:50.505]                 ...future.FUN(...future.X_jj, ...)
[10:22:50.505]             })
[10:22:50.505]         }
[10:22:50.505]     }, args = future.call.arguments)
[10:22:50.505] }
[10:22:50.505] Lazy evaluation: FALSE
[10:22:50.505] Asynchronous evaluation: TRUE
[10:22:50.505] Local evaluation: TRUE
[10:22:50.505] Environment: 0x55f63b2601c0
[10:22:50.505] Capture standard output: TRUE
[10:22:50.505] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:50.505] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:50.505] Packages: <none>
[10:22:50.505] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:50.505] Resolved: TRUE
[10:22:50.505] Value: <not collected>
[10:22:50.505] Conditions captured: <none>
[10:22:50.505] Early signaling: FALSE
[10:22:50.505] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:50.505] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.517] Chunk #2 of 2 ... DONE
[10:22:50.517] Launching 2 futures (chunks) ... DONE
[10:22:50.517] Resolving 2 futures (chunks) ...
[10:22:50.517] resolve() on list ...
[10:22:50.517]  recursive: 0
[10:22:50.518]  length: 2
[10:22:50.518] 
[10:22:50.518] Future #1
[10:22:50.518] result() for MulticoreFuture ...
[10:22:50.519] result() for MulticoreFuture ...
[10:22:50.519] result() for MulticoreFuture ... done
[10:22:50.519] result() for MulticoreFuture ... done
[10:22:50.520] result() for MulticoreFuture ...
[10:22:50.520] result() for MulticoreFuture ... done
[10:22:50.520] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:50.520] - nx: 2
[10:22:50.520] - relay: TRUE
[10:22:50.521] - stdout: TRUE
[10:22:50.521] - signal: TRUE
[10:22:50.521] - resignal: FALSE
[10:22:50.521] - force: TRUE
[10:22:50.521] - relayed: [n=2] FALSE, FALSE
[10:22:50.522] - queued futures: [n=2] FALSE, FALSE
[10:22:50.522]  - until=1
[10:22:50.522]  - relaying element #1
[10:22:50.522] result() for MulticoreFuture ...
[10:22:50.523] result() for MulticoreFuture ... done
[10:22:50.523] result() for MulticoreFuture ...
[10:22:50.523] result() for MulticoreFuture ... done
[10:22:50.523] result() for MulticoreFuture ...
[10:22:50.524] result() for MulticoreFuture ... done
[10:22:50.524] result() for MulticoreFuture ...
[10:22:50.524] result() for MulticoreFuture ... done
[10:22:50.524] - relayed: [n=2] TRUE, FALSE
[10:22:50.525] - queued futures: [n=2] TRUE, FALSE
[10:22:50.525] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:50.525]  length: 1 (resolved future 1)
[10:22:50.525] Future #2
[10:22:50.525] result() for MulticoreFuture ...
[10:22:50.526] result() for MulticoreFuture ...
[10:22:50.526] result() for MulticoreFuture ... done
[10:22:50.526] result() for MulticoreFuture ... done
[10:22:50.527] result() for MulticoreFuture ...
[10:22:50.527] result() for MulticoreFuture ... done
[10:22:50.527] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:50.527] - nx: 2
[10:22:50.527] - relay: TRUE
[10:22:50.527] - stdout: TRUE
[10:22:50.527] - signal: TRUE
[10:22:50.528] - resignal: FALSE
[10:22:50.528] - force: TRUE
[10:22:50.528] - relayed: [n=2] TRUE, FALSE
[10:22:50.528] - queued futures: [n=2] TRUE, FALSE
[10:22:50.528]  - until=2
[10:22:50.528]  - relaying element #2
[10:22:50.528] result() for MulticoreFuture ...
[10:22:50.529] result() for MulticoreFuture ... done
[10:22:50.529] result() for MulticoreFuture ...
[10:22:50.529] result() for MulticoreFuture ... done
[10:22:50.529] result() for MulticoreFuture ...
[10:22:50.529] result() for MulticoreFuture ... done
[10:22:50.529] result() for MulticoreFuture ...
[10:22:50.529] result() for MulticoreFuture ... done
[10:22:50.530] - relayed: [n=2] TRUE, TRUE
[10:22:50.530] - queued futures: [n=2] TRUE, TRUE
[10:22:50.530] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:50.530]  length: 0 (resolved future 2)
[10:22:50.530] Relaying remaining futures
[10:22:50.530] signalConditionsASAP(NULL, pos=0) ...
[10:22:50.530] - nx: 2
[10:22:50.530] - relay: TRUE
[10:22:50.531] - stdout: TRUE
[10:22:50.531] - signal: TRUE
[10:22:50.531] - resignal: FALSE
[10:22:50.531] - force: TRUE
[10:22:50.531] - relayed: [n=2] TRUE, TRUE
[10:22:50.531] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:50.531] - relayed: [n=2] TRUE, TRUE
[10:22:50.531] - queued futures: [n=2] TRUE, TRUE
[10:22:50.532] signalConditionsASAP(NULL, pos=0) ... done
[10:22:50.532] resolve() on list ... DONE
[10:22:50.532] result() for MulticoreFuture ...
[10:22:50.532] result() for MulticoreFuture ... done
[10:22:50.532] result() for MulticoreFuture ...
[10:22:50.532] result() for MulticoreFuture ... done
[10:22:50.532] result() for MulticoreFuture ...
[10:22:50.532] result() for MulticoreFuture ... done
[10:22:50.533] result() for MulticoreFuture ...
[10:22:50.533] result() for MulticoreFuture ... done
[10:22:50.533]  - Number of value chunks collected: 2
[10:22:50.533] Resolving 2 futures (chunks) ... DONE
[10:22:50.533] Reducing values from 2 chunks ...
[10:22:50.533]  - Number of values collected after concatenation: 3
[10:22:50.533]  - Number of values expected: 3
[10:22:50.533] Reducing values from 2 chunks ... DONE
[10:22:50.534] future_lapply() ... DONE
[10:22:50.534] future_by_internal() ... DONE
[10:22:50.535] future_by_internal() ...
- plan('multisession') ...
[10:22:50.535] plan(): Setting new future strategy stack:
[10:22:50.535] List of future strategies:
[10:22:50.535] 1. multisession:
[10:22:50.535]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:50.535]    - tweaked: FALSE
[10:22:50.535]    - call: plan(strategy)
[10:22:50.536] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:50.536] multisession:
[10:22:50.536] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:50.536] - tweaked: FALSE
[10:22:50.536] - call: plan(strategy)
[10:22:50.543] getGlobalsAndPackages() ...
[10:22:50.543] Not searching for globals
[10:22:50.544] - globals: [0] <none>
[10:22:50.544] getGlobalsAndPackages() ... DONE
[10:22:50.544] [local output] makeClusterPSOCK() ...
[10:22:50.595] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:22:50.596] [local output] Base port: 11244
[10:22:50.596] [local output] Getting setup options for 2 cluster nodes ...
[10:22:50.596] [local output]  - Node 1 of 2 ...
[10:22:50.597] [local output] localMachine=TRUE => revtunnel=FALSE

[10:22:50.598] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpDejBuO/worker.rank=1.parallelly.parent=68865.10d0165878e9.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpDejBuO/worker.rank=1.parallelly.parent=68865.10d0165878e9.pid")'’
[10:22:50.788] - Possible to infer worker's PID: TRUE
[10:22:50.788] [local output] Rscript port: 11244

[10:22:50.788] [local output]  - Node 2 of 2 ...
[10:22:50.789] [local output] localMachine=TRUE => revtunnel=FALSE

[10:22:50.789] [local output] Rscript port: 11244

[10:22:50.790] [local output] Getting setup options for 2 cluster nodes ... done
[10:22:50.790] [local output]  - Parallel setup requested for some PSOCK nodes
[10:22:50.790] [local output] Setting up PSOCK nodes in parallel
[10:22:50.790] List of 36
[10:22:50.790]  $ worker          : chr "localhost"
[10:22:50.790]   ..- attr(*, "localhost")= logi TRUE
[10:22:50.790]  $ master          : chr "localhost"
[10:22:50.790]  $ port            : int 11244
[10:22:50.790]  $ connectTimeout  : num 120
[10:22:50.790]  $ timeout         : num 2592000
[10:22:50.790]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:22:50.790]  $ homogeneous     : logi TRUE
[10:22:50.790]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:22:50.790]  $ rscript_envs    : NULL
[10:22:50.790]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:22:50.790]  $ rscript_startup : NULL
[10:22:50.790]  $ rscript_sh      : chr "sh"
[10:22:50.790]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:22:50.790]  $ methods         : logi TRUE
[10:22:50.790]  $ socketOptions   : chr "no-delay"
[10:22:50.790]  $ useXDR          : logi FALSE
[10:22:50.790]  $ outfile         : chr "/dev/null"
[10:22:50.790]  $ renice          : int NA
[10:22:50.790]  $ rshcmd          : NULL
[10:22:50.790]  $ user            : chr(0) 
[10:22:50.790]  $ revtunnel       : logi FALSE
[10:22:50.790]  $ rshlogfile      : NULL
[10:22:50.790]  $ rshopts         : chr(0) 
[10:22:50.790]  $ rank            : int 1
[10:22:50.790]  $ manual          : logi FALSE
[10:22:50.790]  $ dryrun          : logi FALSE
[10:22:50.790]  $ quiet           : logi FALSE
[10:22:50.790]  $ setup_strategy  : chr "parallel"
[10:22:50.790]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:22:50.790]  $ pidfile         : chr "/tmp/RtmpDejBuO/worker.rank=1.parallelly.parent=68865.10d0165878e9.pid"
[10:22:50.790]  $ rshcmd_label    : NULL
[10:22:50.790]  $ rsh_call        : NULL
[10:22:50.790]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:22:50.790]  $ localMachine    : logi TRUE
[10:22:50.790]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:22:50.790]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:22:50.790]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:22:50.790]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:22:50.790]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:22:50.790]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:22:50.790]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:22:50.790]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:22:50.790]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:22:50.790]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:22:50.790]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:22:50.790]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:22:50.790]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:22:50.790]  $ arguments       :List of 28
[10:22:50.790]   ..$ worker          : chr "localhost"
[10:22:50.790]   ..$ master          : NULL
[10:22:50.790]   ..$ port            : int 11244
[10:22:50.790]   ..$ connectTimeout  : num 120
[10:22:50.790]   ..$ timeout         : num 2592000
[10:22:50.790]   ..$ rscript         : NULL
[10:22:50.790]   ..$ homogeneous     : NULL
[10:22:50.790]   ..$ rscript_args    : NULL
[10:22:50.790]   ..$ rscript_envs    : NULL
[10:22:50.790]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:22:50.790]   ..$ rscript_startup : NULL
[10:22:50.790]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:22:50.790]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:22:50.790]   ..$ methods         : logi TRUE
[10:22:50.790]   ..$ socketOptions   : chr "no-delay"
[10:22:50.790]   ..$ useXDR          : logi FALSE
[10:22:50.790]   ..$ outfile         : chr "/dev/null"
[10:22:50.790]   ..$ renice          : int NA
[10:22:50.790]   ..$ rshcmd          : NULL
[10:22:50.790]   ..$ user            : NULL
[10:22:50.790]   ..$ revtunnel       : logi NA
[10:22:50.790]   ..$ rshlogfile      : NULL
[10:22:50.790]   ..$ rshopts         : NULL
[10:22:50.790]   ..$ rank            : int 1
[10:22:50.790]   ..$ manual          : logi FALSE
[10:22:50.790]   ..$ dryrun          : logi FALSE
[10:22:50.790]   ..$ quiet           : logi FALSE
[10:22:50.790]   ..$ setup_strategy  : chr "parallel"
[10:22:50.790]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:22:50.807] [local output] System call to launch all workers:
[10:22:50.807] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpDejBuO/worker.rank=1.parallelly.parent=68865.10d0165878e9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11244 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:22:50.807] [local output] Starting PSOCK main server
[10:22:50.813] [local output] Workers launched
[10:22:50.813] [local output] Waiting for workers to connect back
[10:22:50.813]  - [local output] 0 workers out of 2 ready
[10:22:51.063]  - [local output] 0 workers out of 2 ready
[10:22:51.063]  - [local output] 1 workers out of 2 ready
[10:22:51.075]  - [local output] 1 workers out of 2 ready
[10:22:51.075]  - [local output] 2 workers out of 2 ready
[10:22:51.075] [local output] Launching of workers completed
[10:22:51.075] [local output] Collecting session information from workers
[10:22:51.076] [local output]  - Worker #1 of 2
[10:22:51.077] [local output]  - Worker #2 of 2
[10:22:51.077] [local output] makeClusterPSOCK() ... done
[10:22:51.088] Packages needed by the future expression (n = 0): <none>
[10:22:51.088] Packages needed by future strategies (n = 0): <none>
[10:22:51.088] {
[10:22:51.088]     {
[10:22:51.088]         {
[10:22:51.088]             ...future.startTime <- base::Sys.time()
[10:22:51.088]             {
[10:22:51.088]                 {
[10:22:51.088]                   {
[10:22:51.088]                     {
[10:22:51.088]                       base::local({
[10:22:51.088]                         has_future <- base::requireNamespace("future", 
[10:22:51.088]                           quietly = TRUE)
[10:22:51.088]                         if (has_future) {
[10:22:51.088]                           ns <- base::getNamespace("future")
[10:22:51.088]                           version <- ns[[".package"]][["version"]]
[10:22:51.088]                           if (is.null(version)) 
[10:22:51.088]                             version <- utils::packageVersion("future")
[10:22:51.088]                         }
[10:22:51.088]                         else {
[10:22:51.088]                           version <- NULL
[10:22:51.088]                         }
[10:22:51.088]                         if (!has_future || version < "1.8.0") {
[10:22:51.088]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.088]                             "", base::R.version$version.string), 
[10:22:51.088]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.088]                               "release", "version")], collapse = " "), 
[10:22:51.088]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.088]                             info)
[10:22:51.088]                           info <- base::paste(info, collapse = "; ")
[10:22:51.088]                           if (!has_future) {
[10:22:51.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.088]                               info)
[10:22:51.088]                           }
[10:22:51.088]                           else {
[10:22:51.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.088]                               info, version)
[10:22:51.088]                           }
[10:22:51.088]                           base::stop(msg)
[10:22:51.088]                         }
[10:22:51.088]                       })
[10:22:51.088]                     }
[10:22:51.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.088]                     base::options(mc.cores = 1L)
[10:22:51.088]                   }
[10:22:51.088]                   options(future.plan = NULL)
[10:22:51.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.088]                 }
[10:22:51.088]                 ...future.workdir <- getwd()
[10:22:51.088]             }
[10:22:51.088]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.088]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.088]         }
[10:22:51.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:51.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.088]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.088]             base::names(...future.oldOptions))
[10:22:51.088]     }
[10:22:51.088]     if (FALSE) {
[10:22:51.088]     }
[10:22:51.088]     else {
[10:22:51.088]         if (TRUE) {
[10:22:51.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.088]                 open = "w")
[10:22:51.088]         }
[10:22:51.088]         else {
[10:22:51.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.088]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.088]         }
[10:22:51.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.088]             base::sink(type = "output", split = FALSE)
[10:22:51.088]             base::close(...future.stdout)
[10:22:51.088]         }, add = TRUE)
[10:22:51.088]     }
[10:22:51.088]     ...future.frame <- base::sys.nframe()
[10:22:51.088]     ...future.conditions <- base::list()
[10:22:51.088]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.088]     if (FALSE) {
[10:22:51.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.088]     }
[10:22:51.088]     ...future.result <- base::tryCatch({
[10:22:51.088]         base::withCallingHandlers({
[10:22:51.088]             ...future.value <- base::withVisible(base::local({
[10:22:51.088]                 ...future.makeSendCondition <- base::local({
[10:22:51.088]                   sendCondition <- NULL
[10:22:51.088]                   function(frame = 1L) {
[10:22:51.088]                     if (is.function(sendCondition)) 
[10:22:51.088]                       return(sendCondition)
[10:22:51.088]                     ns <- getNamespace("parallel")
[10:22:51.088]                     if (exists("sendData", mode = "function", 
[10:22:51.088]                       envir = ns)) {
[10:22:51.088]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.088]                         envir = ns)
[10:22:51.088]                       envir <- sys.frame(frame)
[10:22:51.088]                       master <- NULL
[10:22:51.088]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.088]                         !identical(envir, emptyenv())) {
[10:22:51.088]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.088]                           inherits = FALSE)) {
[10:22:51.088]                           master <- get("master", mode = "list", 
[10:22:51.088]                             envir = envir, inherits = FALSE)
[10:22:51.088]                           if (inherits(master, c("SOCKnode", 
[10:22:51.088]                             "SOCK0node"))) {
[10:22:51.088]                             sendCondition <<- function(cond) {
[10:22:51.088]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.088]                                 success = TRUE)
[10:22:51.088]                               parallel_sendData(master, data)
[10:22:51.088]                             }
[10:22:51.088]                             return(sendCondition)
[10:22:51.088]                           }
[10:22:51.088]                         }
[10:22:51.088]                         frame <- frame + 1L
[10:22:51.088]                         envir <- sys.frame(frame)
[10:22:51.088]                       }
[10:22:51.088]                     }
[10:22:51.088]                     sendCondition <<- function(cond) NULL
[10:22:51.088]                   }
[10:22:51.088]                 })
[10:22:51.088]                 withCallingHandlers({
[10:22:51.088]                   NA
[10:22:51.088]                 }, immediateCondition = function(cond) {
[10:22:51.088]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.088]                   sendCondition(cond)
[10:22:51.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.088]                   {
[10:22:51.088]                     inherits <- base::inherits
[10:22:51.088]                     invokeRestart <- base::invokeRestart
[10:22:51.088]                     is.null <- base::is.null
[10:22:51.088]                     muffled <- FALSE
[10:22:51.088]                     if (inherits(cond, "message")) {
[10:22:51.088]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.088]                       if (muffled) 
[10:22:51.088]                         invokeRestart("muffleMessage")
[10:22:51.088]                     }
[10:22:51.088]                     else if (inherits(cond, "warning")) {
[10:22:51.088]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.088]                       if (muffled) 
[10:22:51.088]                         invokeRestart("muffleWarning")
[10:22:51.088]                     }
[10:22:51.088]                     else if (inherits(cond, "condition")) {
[10:22:51.088]                       if (!is.null(pattern)) {
[10:22:51.088]                         computeRestarts <- base::computeRestarts
[10:22:51.088]                         grepl <- base::grepl
[10:22:51.088]                         restarts <- computeRestarts(cond)
[10:22:51.088]                         for (restart in restarts) {
[10:22:51.088]                           name <- restart$name
[10:22:51.088]                           if (is.null(name)) 
[10:22:51.088]                             next
[10:22:51.088]                           if (!grepl(pattern, name)) 
[10:22:51.088]                             next
[10:22:51.088]                           invokeRestart(restart)
[10:22:51.088]                           muffled <- TRUE
[10:22:51.088]                           break
[10:22:51.088]                         }
[10:22:51.088]                       }
[10:22:51.088]                     }
[10:22:51.088]                     invisible(muffled)
[10:22:51.088]                   }
[10:22:51.088]                   muffleCondition(cond)
[10:22:51.088]                 })
[10:22:51.088]             }))
[10:22:51.088]             future::FutureResult(value = ...future.value$value, 
[10:22:51.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.088]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.088]                     ...future.globalenv.names))
[10:22:51.088]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.088]         }, condition = base::local({
[10:22:51.088]             c <- base::c
[10:22:51.088]             inherits <- base::inherits
[10:22:51.088]             invokeRestart <- base::invokeRestart
[10:22:51.088]             length <- base::length
[10:22:51.088]             list <- base::list
[10:22:51.088]             seq.int <- base::seq.int
[10:22:51.088]             signalCondition <- base::signalCondition
[10:22:51.088]             sys.calls <- base::sys.calls
[10:22:51.088]             `[[` <- base::`[[`
[10:22:51.088]             `+` <- base::`+`
[10:22:51.088]             `<<-` <- base::`<<-`
[10:22:51.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.088]                   3L)]
[10:22:51.088]             }
[10:22:51.088]             function(cond) {
[10:22:51.088]                 is_error <- inherits(cond, "error")
[10:22:51.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.088]                   NULL)
[10:22:51.088]                 if (is_error) {
[10:22:51.088]                   sessionInformation <- function() {
[10:22:51.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.088]                       search = base::search(), system = base::Sys.info())
[10:22:51.088]                   }
[10:22:51.088]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.088]                     cond$call), session = sessionInformation(), 
[10:22:51.088]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.088]                   signalCondition(cond)
[10:22:51.088]                 }
[10:22:51.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.088]                 "immediateCondition"))) {
[10:22:51.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.088]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.088]                   if (TRUE && !signal) {
[10:22:51.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.088]                     {
[10:22:51.088]                       inherits <- base::inherits
[10:22:51.088]                       invokeRestart <- base::invokeRestart
[10:22:51.088]                       is.null <- base::is.null
[10:22:51.088]                       muffled <- FALSE
[10:22:51.088]                       if (inherits(cond, "message")) {
[10:22:51.088]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.088]                         if (muffled) 
[10:22:51.088]                           invokeRestart("muffleMessage")
[10:22:51.088]                       }
[10:22:51.088]                       else if (inherits(cond, "warning")) {
[10:22:51.088]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.088]                         if (muffled) 
[10:22:51.088]                           invokeRestart("muffleWarning")
[10:22:51.088]                       }
[10:22:51.088]                       else if (inherits(cond, "condition")) {
[10:22:51.088]                         if (!is.null(pattern)) {
[10:22:51.088]                           computeRestarts <- base::computeRestarts
[10:22:51.088]                           grepl <- base::grepl
[10:22:51.088]                           restarts <- computeRestarts(cond)
[10:22:51.088]                           for (restart in restarts) {
[10:22:51.088]                             name <- restart$name
[10:22:51.088]                             if (is.null(name)) 
[10:22:51.088]                               next
[10:22:51.088]                             if (!grepl(pattern, name)) 
[10:22:51.088]                               next
[10:22:51.088]                             invokeRestart(restart)
[10:22:51.088]                             muffled <- TRUE
[10:22:51.088]                             break
[10:22:51.088]                           }
[10:22:51.088]                         }
[10:22:51.088]                       }
[10:22:51.088]                       invisible(muffled)
[10:22:51.088]                     }
[10:22:51.088]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.088]                   }
[10:22:51.088]                 }
[10:22:51.088]                 else {
[10:22:51.088]                   if (TRUE) {
[10:22:51.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.088]                     {
[10:22:51.088]                       inherits <- base::inherits
[10:22:51.088]                       invokeRestart <- base::invokeRestart
[10:22:51.088]                       is.null <- base::is.null
[10:22:51.088]                       muffled <- FALSE
[10:22:51.088]                       if (inherits(cond, "message")) {
[10:22:51.088]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.088]                         if (muffled) 
[10:22:51.088]                           invokeRestart("muffleMessage")
[10:22:51.088]                       }
[10:22:51.088]                       else if (inherits(cond, "warning")) {
[10:22:51.088]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.088]                         if (muffled) 
[10:22:51.088]                           invokeRestart("muffleWarning")
[10:22:51.088]                       }
[10:22:51.088]                       else if (inherits(cond, "condition")) {
[10:22:51.088]                         if (!is.null(pattern)) {
[10:22:51.088]                           computeRestarts <- base::computeRestarts
[10:22:51.088]                           grepl <- base::grepl
[10:22:51.088]                           restarts <- computeRestarts(cond)
[10:22:51.088]                           for (restart in restarts) {
[10:22:51.088]                             name <- restart$name
[10:22:51.088]                             if (is.null(name)) 
[10:22:51.088]                               next
[10:22:51.088]                             if (!grepl(pattern, name)) 
[10:22:51.088]                               next
[10:22:51.088]                             invokeRestart(restart)
[10:22:51.088]                             muffled <- TRUE
[10:22:51.088]                             break
[10:22:51.088]                           }
[10:22:51.088]                         }
[10:22:51.088]                       }
[10:22:51.088]                       invisible(muffled)
[10:22:51.088]                     }
[10:22:51.088]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.088]                   }
[10:22:51.088]                 }
[10:22:51.088]             }
[10:22:51.088]         }))
[10:22:51.088]     }, error = function(ex) {
[10:22:51.088]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.088]                 ...future.rng), started = ...future.startTime, 
[10:22:51.088]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.088]             version = "1.8"), class = "FutureResult")
[10:22:51.088]     }, finally = {
[10:22:51.088]         if (!identical(...future.workdir, getwd())) 
[10:22:51.088]             setwd(...future.workdir)
[10:22:51.088]         {
[10:22:51.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.088]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.088]             }
[10:22:51.088]             base::options(...future.oldOptions)
[10:22:51.088]             if (.Platform$OS.type == "windows") {
[10:22:51.088]                 old_names <- names(...future.oldEnvVars)
[10:22:51.088]                 envs <- base::Sys.getenv()
[10:22:51.088]                 names <- names(envs)
[10:22:51.088]                 common <- intersect(names, old_names)
[10:22:51.088]                 added <- setdiff(names, old_names)
[10:22:51.088]                 removed <- setdiff(old_names, names)
[10:22:51.088]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.088]                   envs[common]]
[10:22:51.088]                 NAMES <- toupper(changed)
[10:22:51.088]                 args <- list()
[10:22:51.088]                 for (kk in seq_along(NAMES)) {
[10:22:51.088]                   name <- changed[[kk]]
[10:22:51.088]                   NAME <- NAMES[[kk]]
[10:22:51.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.088]                     next
[10:22:51.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.088]                 }
[10:22:51.088]                 NAMES <- toupper(added)
[10:22:51.088]                 for (kk in seq_along(NAMES)) {
[10:22:51.088]                   name <- added[[kk]]
[10:22:51.088]                   NAME <- NAMES[[kk]]
[10:22:51.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.088]                     next
[10:22:51.088]                   args[[name]] <- ""
[10:22:51.088]                 }
[10:22:51.088]                 NAMES <- toupper(removed)
[10:22:51.088]                 for (kk in seq_along(NAMES)) {
[10:22:51.088]                   name <- removed[[kk]]
[10:22:51.088]                   NAME <- NAMES[[kk]]
[10:22:51.088]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.088]                     next
[10:22:51.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.088]                 }
[10:22:51.088]                 if (length(args) > 0) 
[10:22:51.088]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.088]             }
[10:22:51.088]             else {
[10:22:51.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.088]             }
[10:22:51.088]             {
[10:22:51.088]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.088]                   0L) {
[10:22:51.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.088]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.088]                   base::options(opts)
[10:22:51.088]                 }
[10:22:51.088]                 {
[10:22:51.088]                   {
[10:22:51.088]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.088]                     NULL
[10:22:51.088]                   }
[10:22:51.088]                   options(future.plan = NULL)
[10:22:51.088]                   if (is.na(NA_character_)) 
[10:22:51.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.088]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.088]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.088]                     envir = parent.frame()) 
[10:22:51.088]                   {
[10:22:51.088]                     if (is.function(workers)) 
[10:22:51.088]                       workers <- workers()
[10:22:51.088]                     workers <- structure(as.integer(workers), 
[10:22:51.088]                       class = class(workers))
[10:22:51.088]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.088]                       workers >= 1)
[10:22:51.088]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.088]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.088]                     }
[10:22:51.088]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.088]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.088]                       envir = envir)
[10:22:51.088]                     if (!future$lazy) 
[10:22:51.088]                       future <- run(future)
[10:22:51.088]                     invisible(future)
[10:22:51.088]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.088]                 }
[10:22:51.088]             }
[10:22:51.088]         }
[10:22:51.088]     })
[10:22:51.088]     if (TRUE) {
[10:22:51.088]         base::sink(type = "output", split = FALSE)
[10:22:51.088]         if (TRUE) {
[10:22:51.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.088]         }
[10:22:51.088]         else {
[10:22:51.088]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.088]         }
[10:22:51.088]         base::close(...future.stdout)
[10:22:51.088]         ...future.stdout <- NULL
[10:22:51.088]     }
[10:22:51.088]     ...future.result$conditions <- ...future.conditions
[10:22:51.088]     ...future.result$finished <- base::Sys.time()
[10:22:51.088]     ...future.result
[10:22:51.088] }
[10:22:51.141] MultisessionFuture started
[10:22:51.142] result() for ClusterFuture ...
[10:22:51.142] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.143] - Validating connection of MultisessionFuture
[10:22:51.186] - received message: FutureResult
[10:22:51.186] - Received FutureResult
[10:22:51.186] - Erased future from FutureRegistry
[10:22:51.186] result() for ClusterFuture ...
[10:22:51.186] - result already collected: FutureResult
[10:22:51.186] result() for ClusterFuture ... done
[10:22:51.186] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.186] result() for ClusterFuture ... done
[10:22:51.187] result() for ClusterFuture ...
[10:22:51.187] - result already collected: FutureResult
[10:22:51.187] result() for ClusterFuture ... done
[10:22:51.187] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:51.190] plan(): nbrOfWorkers() = 2
[10:22:51.190] future_by_internal() ...
[10:22:51.191] future_lapply() ...
[10:22:51.194] Number of chunks: 2
[10:22:51.195] getGlobalsAndPackagesXApply() ...
[10:22:51.195]  - future.globals: TRUE
[10:22:51.195] getGlobalsAndPackages() ...
[10:22:51.195] Searching for globals...
[10:22:51.196] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:51.196] Searching for globals ... DONE
[10:22:51.196] Resolving globals: FALSE
[10:22:51.196] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:51.197] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:51.197] - globals: [1] ‘FUN’
[10:22:51.197] 
[10:22:51.197] getGlobalsAndPackages() ... DONE
[10:22:51.197]  - globals found/used: [n=1] ‘FUN’
[10:22:51.197]  - needed namespaces: [n=0] 
[10:22:51.197] Finding globals ... DONE
[10:22:51.198]  - use_args: TRUE
[10:22:51.198]  - Getting '...' globals ...
[10:22:51.198] resolve() on list ...
[10:22:51.198]  recursive: 0
[10:22:51.198]  length: 1
[10:22:51.198]  elements: ‘...’
[10:22:51.198]  length: 0 (resolved future 1)
[10:22:51.198] resolve() on list ... DONE
[10:22:51.199]    - '...' content: [n=0] 
[10:22:51.199] List of 1
[10:22:51.199]  $ ...: list()
[10:22:51.199]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.199]  - attr(*, "where")=List of 1
[10:22:51.199]   ..$ ...:<environment: 0x55f63b1ffe20> 
[10:22:51.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.199]  - attr(*, "resolved")= logi TRUE
[10:22:51.199]  - attr(*, "total_size")= num NA
[10:22:51.201]  - Getting '...' globals ... DONE
[10:22:51.201] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:51.201] List of 2
[10:22:51.201]  $ ...future.FUN:function (object, ...)  
[10:22:51.201]  $ ...          : list()
[10:22:51.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.201]  - attr(*, "where")=List of 2
[10:22:51.201]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:51.201]   ..$ ...          :<environment: 0x55f63b1ffe20> 
[10:22:51.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.201]  - attr(*, "resolved")= logi FALSE
[10:22:51.201]  - attr(*, "total_size")= num 1240
[10:22:51.204] Packages to be attached in all futures: [n=0] 
[10:22:51.204] getGlobalsAndPackagesXApply() ... DONE
[10:22:51.204] Number of futures (= number of chunks): 2
[10:22:51.204] Launching 2 futures (chunks) ...
[10:22:51.204] Chunk #1 of 2 ...
[10:22:51.205]  - Finding globals in 'X' for chunk #1 ...
[10:22:51.205] getGlobalsAndPackages() ...
[10:22:51.205] Searching for globals...
[10:22:51.205] 
[10:22:51.205] Searching for globals ... DONE
[10:22:51.205] - globals: [0] <none>
[10:22:51.205] getGlobalsAndPackages() ... DONE
[10:22:51.205]    + additional globals found: [n=0] 
[10:22:51.206]    + additional namespaces needed: [n=0] 
[10:22:51.206]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:51.206]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.206]  - seeds: <none>
[10:22:51.206]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.206] getGlobalsAndPackages() ...
[10:22:51.206] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.206] Resolving globals: FALSE
[10:22:51.206] Tweak future expression to call with '...' arguments ...
[10:22:51.206] {
[10:22:51.206]     do.call(function(...) {
[10:22:51.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.206]             on.exit(options(oopts), add = TRUE)
[10:22:51.206]         }
[10:22:51.206]         {
[10:22:51.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.206]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.206]             })
[10:22:51.206]         }
[10:22:51.206]     }, args = future.call.arguments)
[10:22:51.206] }
[10:22:51.207] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.207] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.207] 
[10:22:51.207] getGlobalsAndPackages() ... DONE
[10:22:51.207] run() for ‘Future’ ...
[10:22:51.208] - state: ‘created’
[10:22:51.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.222]   - Field: ‘node’
[10:22:51.222]   - Field: ‘label’
[10:22:51.222]   - Field: ‘local’
[10:22:51.222]   - Field: ‘owner’
[10:22:51.222]   - Field: ‘envir’
[10:22:51.222]   - Field: ‘workers’
[10:22:51.222]   - Field: ‘packages’
[10:22:51.222]   - Field: ‘gc’
[10:22:51.222]   - Field: ‘conditions’
[10:22:51.222]   - Field: ‘persistent’
[10:22:51.223]   - Field: ‘expr’
[10:22:51.223]   - Field: ‘uuid’
[10:22:51.223]   - Field: ‘seed’
[10:22:51.223]   - Field: ‘version’
[10:22:51.223]   - Field: ‘result’
[10:22:51.223]   - Field: ‘asynchronous’
[10:22:51.223]   - Field: ‘calls’
[10:22:51.223]   - Field: ‘globals’
[10:22:51.223]   - Field: ‘stdout’
[10:22:51.223]   - Field: ‘earlySignal’
[10:22:51.223]   - Field: ‘lazy’
[10:22:51.224]   - Field: ‘state’
[10:22:51.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.224] - Launch lazy future ...
[10:22:51.224] Packages needed by the future expression (n = 0): <none>
[10:22:51.224] Packages needed by future strategies (n = 0): <none>
[10:22:51.225] {
[10:22:51.225]     {
[10:22:51.225]         {
[10:22:51.225]             ...future.startTime <- base::Sys.time()
[10:22:51.225]             {
[10:22:51.225]                 {
[10:22:51.225]                   {
[10:22:51.225]                     {
[10:22:51.225]                       base::local({
[10:22:51.225]                         has_future <- base::requireNamespace("future", 
[10:22:51.225]                           quietly = TRUE)
[10:22:51.225]                         if (has_future) {
[10:22:51.225]                           ns <- base::getNamespace("future")
[10:22:51.225]                           version <- ns[[".package"]][["version"]]
[10:22:51.225]                           if (is.null(version)) 
[10:22:51.225]                             version <- utils::packageVersion("future")
[10:22:51.225]                         }
[10:22:51.225]                         else {
[10:22:51.225]                           version <- NULL
[10:22:51.225]                         }
[10:22:51.225]                         if (!has_future || version < "1.8.0") {
[10:22:51.225]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.225]                             "", base::R.version$version.string), 
[10:22:51.225]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.225]                               "release", "version")], collapse = " "), 
[10:22:51.225]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.225]                             info)
[10:22:51.225]                           info <- base::paste(info, collapse = "; ")
[10:22:51.225]                           if (!has_future) {
[10:22:51.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.225]                               info)
[10:22:51.225]                           }
[10:22:51.225]                           else {
[10:22:51.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.225]                               info, version)
[10:22:51.225]                           }
[10:22:51.225]                           base::stop(msg)
[10:22:51.225]                         }
[10:22:51.225]                       })
[10:22:51.225]                     }
[10:22:51.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.225]                     base::options(mc.cores = 1L)
[10:22:51.225]                   }
[10:22:51.225]                   options(future.plan = NULL)
[10:22:51.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.225]                 }
[10:22:51.225]                 ...future.workdir <- getwd()
[10:22:51.225]             }
[10:22:51.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.225]         }
[10:22:51.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.225]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.225]             base::names(...future.oldOptions))
[10:22:51.225]     }
[10:22:51.225]     if (FALSE) {
[10:22:51.225]     }
[10:22:51.225]     else {
[10:22:51.225]         if (TRUE) {
[10:22:51.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.225]                 open = "w")
[10:22:51.225]         }
[10:22:51.225]         else {
[10:22:51.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.225]         }
[10:22:51.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.225]             base::sink(type = "output", split = FALSE)
[10:22:51.225]             base::close(...future.stdout)
[10:22:51.225]         }, add = TRUE)
[10:22:51.225]     }
[10:22:51.225]     ...future.frame <- base::sys.nframe()
[10:22:51.225]     ...future.conditions <- base::list()
[10:22:51.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.225]     if (FALSE) {
[10:22:51.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.225]     }
[10:22:51.225]     ...future.result <- base::tryCatch({
[10:22:51.225]         base::withCallingHandlers({
[10:22:51.225]             ...future.value <- base::withVisible(base::local({
[10:22:51.225]                 ...future.makeSendCondition <- base::local({
[10:22:51.225]                   sendCondition <- NULL
[10:22:51.225]                   function(frame = 1L) {
[10:22:51.225]                     if (is.function(sendCondition)) 
[10:22:51.225]                       return(sendCondition)
[10:22:51.225]                     ns <- getNamespace("parallel")
[10:22:51.225]                     if (exists("sendData", mode = "function", 
[10:22:51.225]                       envir = ns)) {
[10:22:51.225]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.225]                         envir = ns)
[10:22:51.225]                       envir <- sys.frame(frame)
[10:22:51.225]                       master <- NULL
[10:22:51.225]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.225]                         !identical(envir, emptyenv())) {
[10:22:51.225]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.225]                           inherits = FALSE)) {
[10:22:51.225]                           master <- get("master", mode = "list", 
[10:22:51.225]                             envir = envir, inherits = FALSE)
[10:22:51.225]                           if (inherits(master, c("SOCKnode", 
[10:22:51.225]                             "SOCK0node"))) {
[10:22:51.225]                             sendCondition <<- function(cond) {
[10:22:51.225]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.225]                                 success = TRUE)
[10:22:51.225]                               parallel_sendData(master, data)
[10:22:51.225]                             }
[10:22:51.225]                             return(sendCondition)
[10:22:51.225]                           }
[10:22:51.225]                         }
[10:22:51.225]                         frame <- frame + 1L
[10:22:51.225]                         envir <- sys.frame(frame)
[10:22:51.225]                       }
[10:22:51.225]                     }
[10:22:51.225]                     sendCondition <<- function(cond) NULL
[10:22:51.225]                   }
[10:22:51.225]                 })
[10:22:51.225]                 withCallingHandlers({
[10:22:51.225]                   {
[10:22:51.225]                     do.call(function(...) {
[10:22:51.225]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.225]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.225]                         ...future.globals.maxSize)) {
[10:22:51.225]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.225]                         on.exit(options(oopts), add = TRUE)
[10:22:51.225]                       }
[10:22:51.225]                       {
[10:22:51.225]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.225]                           FUN = function(jj) {
[10:22:51.225]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.225]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.225]                           })
[10:22:51.225]                       }
[10:22:51.225]                     }, args = future.call.arguments)
[10:22:51.225]                   }
[10:22:51.225]                 }, immediateCondition = function(cond) {
[10:22:51.225]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.225]                   sendCondition(cond)
[10:22:51.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.225]                   {
[10:22:51.225]                     inherits <- base::inherits
[10:22:51.225]                     invokeRestart <- base::invokeRestart
[10:22:51.225]                     is.null <- base::is.null
[10:22:51.225]                     muffled <- FALSE
[10:22:51.225]                     if (inherits(cond, "message")) {
[10:22:51.225]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.225]                       if (muffled) 
[10:22:51.225]                         invokeRestart("muffleMessage")
[10:22:51.225]                     }
[10:22:51.225]                     else if (inherits(cond, "warning")) {
[10:22:51.225]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.225]                       if (muffled) 
[10:22:51.225]                         invokeRestart("muffleWarning")
[10:22:51.225]                     }
[10:22:51.225]                     else if (inherits(cond, "condition")) {
[10:22:51.225]                       if (!is.null(pattern)) {
[10:22:51.225]                         computeRestarts <- base::computeRestarts
[10:22:51.225]                         grepl <- base::grepl
[10:22:51.225]                         restarts <- computeRestarts(cond)
[10:22:51.225]                         for (restart in restarts) {
[10:22:51.225]                           name <- restart$name
[10:22:51.225]                           if (is.null(name)) 
[10:22:51.225]                             next
[10:22:51.225]                           if (!grepl(pattern, name)) 
[10:22:51.225]                             next
[10:22:51.225]                           invokeRestart(restart)
[10:22:51.225]                           muffled <- TRUE
[10:22:51.225]                           break
[10:22:51.225]                         }
[10:22:51.225]                       }
[10:22:51.225]                     }
[10:22:51.225]                     invisible(muffled)
[10:22:51.225]                   }
[10:22:51.225]                   muffleCondition(cond)
[10:22:51.225]                 })
[10:22:51.225]             }))
[10:22:51.225]             future::FutureResult(value = ...future.value$value, 
[10:22:51.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.225]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.225]                     ...future.globalenv.names))
[10:22:51.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.225]         }, condition = base::local({
[10:22:51.225]             c <- base::c
[10:22:51.225]             inherits <- base::inherits
[10:22:51.225]             invokeRestart <- base::invokeRestart
[10:22:51.225]             length <- base::length
[10:22:51.225]             list <- base::list
[10:22:51.225]             seq.int <- base::seq.int
[10:22:51.225]             signalCondition <- base::signalCondition
[10:22:51.225]             sys.calls <- base::sys.calls
[10:22:51.225]             `[[` <- base::`[[`
[10:22:51.225]             `+` <- base::`+`
[10:22:51.225]             `<<-` <- base::`<<-`
[10:22:51.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.225]                   3L)]
[10:22:51.225]             }
[10:22:51.225]             function(cond) {
[10:22:51.225]                 is_error <- inherits(cond, "error")
[10:22:51.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.225]                   NULL)
[10:22:51.225]                 if (is_error) {
[10:22:51.225]                   sessionInformation <- function() {
[10:22:51.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.225]                       search = base::search(), system = base::Sys.info())
[10:22:51.225]                   }
[10:22:51.225]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.225]                     cond$call), session = sessionInformation(), 
[10:22:51.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.225]                   signalCondition(cond)
[10:22:51.225]                 }
[10:22:51.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.225]                 "immediateCondition"))) {
[10:22:51.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.225]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.225]                   if (TRUE && !signal) {
[10:22:51.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.225]                     {
[10:22:51.225]                       inherits <- base::inherits
[10:22:51.225]                       invokeRestart <- base::invokeRestart
[10:22:51.225]                       is.null <- base::is.null
[10:22:51.225]                       muffled <- FALSE
[10:22:51.225]                       if (inherits(cond, "message")) {
[10:22:51.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.225]                         if (muffled) 
[10:22:51.225]                           invokeRestart("muffleMessage")
[10:22:51.225]                       }
[10:22:51.225]                       else if (inherits(cond, "warning")) {
[10:22:51.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.225]                         if (muffled) 
[10:22:51.225]                           invokeRestart("muffleWarning")
[10:22:51.225]                       }
[10:22:51.225]                       else if (inherits(cond, "condition")) {
[10:22:51.225]                         if (!is.null(pattern)) {
[10:22:51.225]                           computeRestarts <- base::computeRestarts
[10:22:51.225]                           grepl <- base::grepl
[10:22:51.225]                           restarts <- computeRestarts(cond)
[10:22:51.225]                           for (restart in restarts) {
[10:22:51.225]                             name <- restart$name
[10:22:51.225]                             if (is.null(name)) 
[10:22:51.225]                               next
[10:22:51.225]                             if (!grepl(pattern, name)) 
[10:22:51.225]                               next
[10:22:51.225]                             invokeRestart(restart)
[10:22:51.225]                             muffled <- TRUE
[10:22:51.225]                             break
[10:22:51.225]                           }
[10:22:51.225]                         }
[10:22:51.225]                       }
[10:22:51.225]                       invisible(muffled)
[10:22:51.225]                     }
[10:22:51.225]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.225]                   }
[10:22:51.225]                 }
[10:22:51.225]                 else {
[10:22:51.225]                   if (TRUE) {
[10:22:51.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.225]                     {
[10:22:51.225]                       inherits <- base::inherits
[10:22:51.225]                       invokeRestart <- base::invokeRestart
[10:22:51.225]                       is.null <- base::is.null
[10:22:51.225]                       muffled <- FALSE
[10:22:51.225]                       if (inherits(cond, "message")) {
[10:22:51.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.225]                         if (muffled) 
[10:22:51.225]                           invokeRestart("muffleMessage")
[10:22:51.225]                       }
[10:22:51.225]                       else if (inherits(cond, "warning")) {
[10:22:51.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.225]                         if (muffled) 
[10:22:51.225]                           invokeRestart("muffleWarning")
[10:22:51.225]                       }
[10:22:51.225]                       else if (inherits(cond, "condition")) {
[10:22:51.225]                         if (!is.null(pattern)) {
[10:22:51.225]                           computeRestarts <- base::computeRestarts
[10:22:51.225]                           grepl <- base::grepl
[10:22:51.225]                           restarts <- computeRestarts(cond)
[10:22:51.225]                           for (restart in restarts) {
[10:22:51.225]                             name <- restart$name
[10:22:51.225]                             if (is.null(name)) 
[10:22:51.225]                               next
[10:22:51.225]                             if (!grepl(pattern, name)) 
[10:22:51.225]                               next
[10:22:51.225]                             invokeRestart(restart)
[10:22:51.225]                             muffled <- TRUE
[10:22:51.225]                             break
[10:22:51.225]                           }
[10:22:51.225]                         }
[10:22:51.225]                       }
[10:22:51.225]                       invisible(muffled)
[10:22:51.225]                     }
[10:22:51.225]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.225]                   }
[10:22:51.225]                 }
[10:22:51.225]             }
[10:22:51.225]         }))
[10:22:51.225]     }, error = function(ex) {
[10:22:51.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.225]                 ...future.rng), started = ...future.startTime, 
[10:22:51.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.225]             version = "1.8"), class = "FutureResult")
[10:22:51.225]     }, finally = {
[10:22:51.225]         if (!identical(...future.workdir, getwd())) 
[10:22:51.225]             setwd(...future.workdir)
[10:22:51.225]         {
[10:22:51.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.225]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.225]             }
[10:22:51.225]             base::options(...future.oldOptions)
[10:22:51.225]             if (.Platform$OS.type == "windows") {
[10:22:51.225]                 old_names <- names(...future.oldEnvVars)
[10:22:51.225]                 envs <- base::Sys.getenv()
[10:22:51.225]                 names <- names(envs)
[10:22:51.225]                 common <- intersect(names, old_names)
[10:22:51.225]                 added <- setdiff(names, old_names)
[10:22:51.225]                 removed <- setdiff(old_names, names)
[10:22:51.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.225]                   envs[common]]
[10:22:51.225]                 NAMES <- toupper(changed)
[10:22:51.225]                 args <- list()
[10:22:51.225]                 for (kk in seq_along(NAMES)) {
[10:22:51.225]                   name <- changed[[kk]]
[10:22:51.225]                   NAME <- NAMES[[kk]]
[10:22:51.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.225]                     next
[10:22:51.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.225]                 }
[10:22:51.225]                 NAMES <- toupper(added)
[10:22:51.225]                 for (kk in seq_along(NAMES)) {
[10:22:51.225]                   name <- added[[kk]]
[10:22:51.225]                   NAME <- NAMES[[kk]]
[10:22:51.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.225]                     next
[10:22:51.225]                   args[[name]] <- ""
[10:22:51.225]                 }
[10:22:51.225]                 NAMES <- toupper(removed)
[10:22:51.225]                 for (kk in seq_along(NAMES)) {
[10:22:51.225]                   name <- removed[[kk]]
[10:22:51.225]                   NAME <- NAMES[[kk]]
[10:22:51.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.225]                     next
[10:22:51.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.225]                 }
[10:22:51.225]                 if (length(args) > 0) 
[10:22:51.225]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.225]             }
[10:22:51.225]             else {
[10:22:51.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.225]             }
[10:22:51.225]             {
[10:22:51.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.225]                   0L) {
[10:22:51.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.225]                   base::options(opts)
[10:22:51.225]                 }
[10:22:51.225]                 {
[10:22:51.225]                   {
[10:22:51.225]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.225]                     NULL
[10:22:51.225]                   }
[10:22:51.225]                   options(future.plan = NULL)
[10:22:51.225]                   if (is.na(NA_character_)) 
[10:22:51.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.225]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.225]                     envir = parent.frame()) 
[10:22:51.225]                   {
[10:22:51.225]                     if (is.function(workers)) 
[10:22:51.225]                       workers <- workers()
[10:22:51.225]                     workers <- structure(as.integer(workers), 
[10:22:51.225]                       class = class(workers))
[10:22:51.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.225]                       workers >= 1)
[10:22:51.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.225]                     }
[10:22:51.225]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.225]                       envir = envir)
[10:22:51.225]                     if (!future$lazy) 
[10:22:51.225]                       future <- run(future)
[10:22:51.225]                     invisible(future)
[10:22:51.225]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.225]                 }
[10:22:51.225]             }
[10:22:51.225]         }
[10:22:51.225]     })
[10:22:51.225]     if (TRUE) {
[10:22:51.225]         base::sink(type = "output", split = FALSE)
[10:22:51.225]         if (TRUE) {
[10:22:51.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.225]         }
[10:22:51.225]         else {
[10:22:51.225]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.225]         }
[10:22:51.225]         base::close(...future.stdout)
[10:22:51.225]         ...future.stdout <- NULL
[10:22:51.225]     }
[10:22:51.225]     ...future.result$conditions <- ...future.conditions
[10:22:51.225]     ...future.result$finished <- base::Sys.time()
[10:22:51.225]     ...future.result
[10:22:51.225] }
[10:22:51.227] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:22:51.228] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:22:51.228] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:22:51.228] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:51.229] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.229] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[10:22:51.229] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[10:22:51.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:51.230] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:22:51.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.230] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:22:51.231] MultisessionFuture started
[10:22:51.231] - Launch lazy future ... done
[10:22:51.231] run() for ‘MultisessionFuture’ ... done
[10:22:51.231] Created future:
[10:22:51.231] MultisessionFuture:
[10:22:51.231] Label: ‘future_by-1’
[10:22:51.231] Expression:
[10:22:51.231] {
[10:22:51.231]     do.call(function(...) {
[10:22:51.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.231]             on.exit(options(oopts), add = TRUE)
[10:22:51.231]         }
[10:22:51.231]         {
[10:22:51.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.231]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.231]             })
[10:22:51.231]         }
[10:22:51.231]     }, args = future.call.arguments)
[10:22:51.231] }
[10:22:51.231] Lazy evaluation: FALSE
[10:22:51.231] Asynchronous evaluation: TRUE
[10:22:51.231] Local evaluation: TRUE
[10:22:51.231] Environment: R_GlobalEnv
[10:22:51.231] Capture standard output: TRUE
[10:22:51.231] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.231] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.231] Packages: <none>
[10:22:51.231] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.231] Resolved: FALSE
[10:22:51.231] Value: <not collected>
[10:22:51.231] Conditions captured: <none>
[10:22:51.231] Early signaling: FALSE
[10:22:51.231] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.231] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.243] Chunk #1 of 2 ... DONE
[10:22:51.243] Chunk #2 of 2 ...
[10:22:51.243]  - Finding globals in 'X' for chunk #2 ...
[10:22:51.243] getGlobalsAndPackages() ...
[10:22:51.243] Searching for globals...
[10:22:51.244] 
[10:22:51.244] Searching for globals ... DONE
[10:22:51.244] - globals: [0] <none>
[10:22:51.244] getGlobalsAndPackages() ... DONE
[10:22:51.244]    + additional globals found: [n=0] 
[10:22:51.244]    + additional namespaces needed: [n=0] 
[10:22:51.244]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:51.244]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.244]  - seeds: <none>
[10:22:51.244]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.245] getGlobalsAndPackages() ...
[10:22:51.245] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.245] Resolving globals: FALSE
[10:22:51.245] Tweak future expression to call with '...' arguments ...
[10:22:51.245] {
[10:22:51.245]     do.call(function(...) {
[10:22:51.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.245]             on.exit(options(oopts), add = TRUE)
[10:22:51.245]         }
[10:22:51.245]         {
[10:22:51.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.245]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.245]             })
[10:22:51.245]         }
[10:22:51.245]     }, args = future.call.arguments)
[10:22:51.245] }
[10:22:51.245] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.246] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.246] 
[10:22:51.246] getGlobalsAndPackages() ... DONE
[10:22:51.246] run() for ‘Future’ ...
[10:22:51.246] - state: ‘created’
[10:22:51.246] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.260]   - Field: ‘node’
[10:22:51.260]   - Field: ‘label’
[10:22:51.260]   - Field: ‘local’
[10:22:51.261]   - Field: ‘owner’
[10:22:51.261]   - Field: ‘envir’
[10:22:51.261]   - Field: ‘workers’
[10:22:51.261]   - Field: ‘packages’
[10:22:51.261]   - Field: ‘gc’
[10:22:51.261]   - Field: ‘conditions’
[10:22:51.261]   - Field: ‘persistent’
[10:22:51.261]   - Field: ‘expr’
[10:22:51.261]   - Field: ‘uuid’
[10:22:51.261]   - Field: ‘seed’
[10:22:51.261]   - Field: ‘version’
[10:22:51.262]   - Field: ‘result’
[10:22:51.262]   - Field: ‘asynchronous’
[10:22:51.262]   - Field: ‘calls’
[10:22:51.262]   - Field: ‘globals’
[10:22:51.262]   - Field: ‘stdout’
[10:22:51.262]   - Field: ‘earlySignal’
[10:22:51.262]   - Field: ‘lazy’
[10:22:51.262]   - Field: ‘state’
[10:22:51.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.262] - Launch lazy future ...
[10:22:51.263] Packages needed by the future expression (n = 0): <none>
[10:22:51.263] Packages needed by future strategies (n = 0): <none>
[10:22:51.263] {
[10:22:51.263]     {
[10:22:51.263]         {
[10:22:51.263]             ...future.startTime <- base::Sys.time()
[10:22:51.263]             {
[10:22:51.263]                 {
[10:22:51.263]                   {
[10:22:51.263]                     {
[10:22:51.263]                       base::local({
[10:22:51.263]                         has_future <- base::requireNamespace("future", 
[10:22:51.263]                           quietly = TRUE)
[10:22:51.263]                         if (has_future) {
[10:22:51.263]                           ns <- base::getNamespace("future")
[10:22:51.263]                           version <- ns[[".package"]][["version"]]
[10:22:51.263]                           if (is.null(version)) 
[10:22:51.263]                             version <- utils::packageVersion("future")
[10:22:51.263]                         }
[10:22:51.263]                         else {
[10:22:51.263]                           version <- NULL
[10:22:51.263]                         }
[10:22:51.263]                         if (!has_future || version < "1.8.0") {
[10:22:51.263]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.263]                             "", base::R.version$version.string), 
[10:22:51.263]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.263]                               "release", "version")], collapse = " "), 
[10:22:51.263]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.263]                             info)
[10:22:51.263]                           info <- base::paste(info, collapse = "; ")
[10:22:51.263]                           if (!has_future) {
[10:22:51.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.263]                               info)
[10:22:51.263]                           }
[10:22:51.263]                           else {
[10:22:51.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.263]                               info, version)
[10:22:51.263]                           }
[10:22:51.263]                           base::stop(msg)
[10:22:51.263]                         }
[10:22:51.263]                       })
[10:22:51.263]                     }
[10:22:51.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.263]                     base::options(mc.cores = 1L)
[10:22:51.263]                   }
[10:22:51.263]                   options(future.plan = NULL)
[10:22:51.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.263]                 }
[10:22:51.263]                 ...future.workdir <- getwd()
[10:22:51.263]             }
[10:22:51.263]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.263]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.263]         }
[10:22:51.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.263]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.263]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.263]             base::names(...future.oldOptions))
[10:22:51.263]     }
[10:22:51.263]     if (FALSE) {
[10:22:51.263]     }
[10:22:51.263]     else {
[10:22:51.263]         if (TRUE) {
[10:22:51.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.263]                 open = "w")
[10:22:51.263]         }
[10:22:51.263]         else {
[10:22:51.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.263]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.263]         }
[10:22:51.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.263]             base::sink(type = "output", split = FALSE)
[10:22:51.263]             base::close(...future.stdout)
[10:22:51.263]         }, add = TRUE)
[10:22:51.263]     }
[10:22:51.263]     ...future.frame <- base::sys.nframe()
[10:22:51.263]     ...future.conditions <- base::list()
[10:22:51.263]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.263]     if (FALSE) {
[10:22:51.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.263]     }
[10:22:51.263]     ...future.result <- base::tryCatch({
[10:22:51.263]         base::withCallingHandlers({
[10:22:51.263]             ...future.value <- base::withVisible(base::local({
[10:22:51.263]                 ...future.makeSendCondition <- base::local({
[10:22:51.263]                   sendCondition <- NULL
[10:22:51.263]                   function(frame = 1L) {
[10:22:51.263]                     if (is.function(sendCondition)) 
[10:22:51.263]                       return(sendCondition)
[10:22:51.263]                     ns <- getNamespace("parallel")
[10:22:51.263]                     if (exists("sendData", mode = "function", 
[10:22:51.263]                       envir = ns)) {
[10:22:51.263]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.263]                         envir = ns)
[10:22:51.263]                       envir <- sys.frame(frame)
[10:22:51.263]                       master <- NULL
[10:22:51.263]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.263]                         !identical(envir, emptyenv())) {
[10:22:51.263]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.263]                           inherits = FALSE)) {
[10:22:51.263]                           master <- get("master", mode = "list", 
[10:22:51.263]                             envir = envir, inherits = FALSE)
[10:22:51.263]                           if (inherits(master, c("SOCKnode", 
[10:22:51.263]                             "SOCK0node"))) {
[10:22:51.263]                             sendCondition <<- function(cond) {
[10:22:51.263]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.263]                                 success = TRUE)
[10:22:51.263]                               parallel_sendData(master, data)
[10:22:51.263]                             }
[10:22:51.263]                             return(sendCondition)
[10:22:51.263]                           }
[10:22:51.263]                         }
[10:22:51.263]                         frame <- frame + 1L
[10:22:51.263]                         envir <- sys.frame(frame)
[10:22:51.263]                       }
[10:22:51.263]                     }
[10:22:51.263]                     sendCondition <<- function(cond) NULL
[10:22:51.263]                   }
[10:22:51.263]                 })
[10:22:51.263]                 withCallingHandlers({
[10:22:51.263]                   {
[10:22:51.263]                     do.call(function(...) {
[10:22:51.263]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.263]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.263]                         ...future.globals.maxSize)) {
[10:22:51.263]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.263]                         on.exit(options(oopts), add = TRUE)
[10:22:51.263]                       }
[10:22:51.263]                       {
[10:22:51.263]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.263]                           FUN = function(jj) {
[10:22:51.263]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.263]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.263]                           })
[10:22:51.263]                       }
[10:22:51.263]                     }, args = future.call.arguments)
[10:22:51.263]                   }
[10:22:51.263]                 }, immediateCondition = function(cond) {
[10:22:51.263]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.263]                   sendCondition(cond)
[10:22:51.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.263]                   {
[10:22:51.263]                     inherits <- base::inherits
[10:22:51.263]                     invokeRestart <- base::invokeRestart
[10:22:51.263]                     is.null <- base::is.null
[10:22:51.263]                     muffled <- FALSE
[10:22:51.263]                     if (inherits(cond, "message")) {
[10:22:51.263]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.263]                       if (muffled) 
[10:22:51.263]                         invokeRestart("muffleMessage")
[10:22:51.263]                     }
[10:22:51.263]                     else if (inherits(cond, "warning")) {
[10:22:51.263]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.263]                       if (muffled) 
[10:22:51.263]                         invokeRestart("muffleWarning")
[10:22:51.263]                     }
[10:22:51.263]                     else if (inherits(cond, "condition")) {
[10:22:51.263]                       if (!is.null(pattern)) {
[10:22:51.263]                         computeRestarts <- base::computeRestarts
[10:22:51.263]                         grepl <- base::grepl
[10:22:51.263]                         restarts <- computeRestarts(cond)
[10:22:51.263]                         for (restart in restarts) {
[10:22:51.263]                           name <- restart$name
[10:22:51.263]                           if (is.null(name)) 
[10:22:51.263]                             next
[10:22:51.263]                           if (!grepl(pattern, name)) 
[10:22:51.263]                             next
[10:22:51.263]                           invokeRestart(restart)
[10:22:51.263]                           muffled <- TRUE
[10:22:51.263]                           break
[10:22:51.263]                         }
[10:22:51.263]                       }
[10:22:51.263]                     }
[10:22:51.263]                     invisible(muffled)
[10:22:51.263]                   }
[10:22:51.263]                   muffleCondition(cond)
[10:22:51.263]                 })
[10:22:51.263]             }))
[10:22:51.263]             future::FutureResult(value = ...future.value$value, 
[10:22:51.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.263]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.263]                     ...future.globalenv.names))
[10:22:51.263]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.263]         }, condition = base::local({
[10:22:51.263]             c <- base::c
[10:22:51.263]             inherits <- base::inherits
[10:22:51.263]             invokeRestart <- base::invokeRestart
[10:22:51.263]             length <- base::length
[10:22:51.263]             list <- base::list
[10:22:51.263]             seq.int <- base::seq.int
[10:22:51.263]             signalCondition <- base::signalCondition
[10:22:51.263]             sys.calls <- base::sys.calls
[10:22:51.263]             `[[` <- base::`[[`
[10:22:51.263]             `+` <- base::`+`
[10:22:51.263]             `<<-` <- base::`<<-`
[10:22:51.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.263]                   3L)]
[10:22:51.263]             }
[10:22:51.263]             function(cond) {
[10:22:51.263]                 is_error <- inherits(cond, "error")
[10:22:51.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.263]                   NULL)
[10:22:51.263]                 if (is_error) {
[10:22:51.263]                   sessionInformation <- function() {
[10:22:51.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.263]                       search = base::search(), system = base::Sys.info())
[10:22:51.263]                   }
[10:22:51.263]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.263]                     cond$call), session = sessionInformation(), 
[10:22:51.263]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.263]                   signalCondition(cond)
[10:22:51.263]                 }
[10:22:51.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.263]                 "immediateCondition"))) {
[10:22:51.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.263]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.263]                   if (TRUE && !signal) {
[10:22:51.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.263]                     {
[10:22:51.263]                       inherits <- base::inherits
[10:22:51.263]                       invokeRestart <- base::invokeRestart
[10:22:51.263]                       is.null <- base::is.null
[10:22:51.263]                       muffled <- FALSE
[10:22:51.263]                       if (inherits(cond, "message")) {
[10:22:51.263]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.263]                         if (muffled) 
[10:22:51.263]                           invokeRestart("muffleMessage")
[10:22:51.263]                       }
[10:22:51.263]                       else if (inherits(cond, "warning")) {
[10:22:51.263]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.263]                         if (muffled) 
[10:22:51.263]                           invokeRestart("muffleWarning")
[10:22:51.263]                       }
[10:22:51.263]                       else if (inherits(cond, "condition")) {
[10:22:51.263]                         if (!is.null(pattern)) {
[10:22:51.263]                           computeRestarts <- base::computeRestarts
[10:22:51.263]                           grepl <- base::grepl
[10:22:51.263]                           restarts <- computeRestarts(cond)
[10:22:51.263]                           for (restart in restarts) {
[10:22:51.263]                             name <- restart$name
[10:22:51.263]                             if (is.null(name)) 
[10:22:51.263]                               next
[10:22:51.263]                             if (!grepl(pattern, name)) 
[10:22:51.263]                               next
[10:22:51.263]                             invokeRestart(restart)
[10:22:51.263]                             muffled <- TRUE
[10:22:51.263]                             break
[10:22:51.263]                           }
[10:22:51.263]                         }
[10:22:51.263]                       }
[10:22:51.263]                       invisible(muffled)
[10:22:51.263]                     }
[10:22:51.263]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.263]                   }
[10:22:51.263]                 }
[10:22:51.263]                 else {
[10:22:51.263]                   if (TRUE) {
[10:22:51.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.263]                     {
[10:22:51.263]                       inherits <- base::inherits
[10:22:51.263]                       invokeRestart <- base::invokeRestart
[10:22:51.263]                       is.null <- base::is.null
[10:22:51.263]                       muffled <- FALSE
[10:22:51.263]                       if (inherits(cond, "message")) {
[10:22:51.263]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.263]                         if (muffled) 
[10:22:51.263]                           invokeRestart("muffleMessage")
[10:22:51.263]                       }
[10:22:51.263]                       else if (inherits(cond, "warning")) {
[10:22:51.263]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.263]                         if (muffled) 
[10:22:51.263]                           invokeRestart("muffleWarning")
[10:22:51.263]                       }
[10:22:51.263]                       else if (inherits(cond, "condition")) {
[10:22:51.263]                         if (!is.null(pattern)) {
[10:22:51.263]                           computeRestarts <- base::computeRestarts
[10:22:51.263]                           grepl <- base::grepl
[10:22:51.263]                           restarts <- computeRestarts(cond)
[10:22:51.263]                           for (restart in restarts) {
[10:22:51.263]                             name <- restart$name
[10:22:51.263]                             if (is.null(name)) 
[10:22:51.263]                               next
[10:22:51.263]                             if (!grepl(pattern, name)) 
[10:22:51.263]                               next
[10:22:51.263]                             invokeRestart(restart)
[10:22:51.263]                             muffled <- TRUE
[10:22:51.263]                             break
[10:22:51.263]                           }
[10:22:51.263]                         }
[10:22:51.263]                       }
[10:22:51.263]                       invisible(muffled)
[10:22:51.263]                     }
[10:22:51.263]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.263]                   }
[10:22:51.263]                 }
[10:22:51.263]             }
[10:22:51.263]         }))
[10:22:51.263]     }, error = function(ex) {
[10:22:51.263]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.263]                 ...future.rng), started = ...future.startTime, 
[10:22:51.263]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.263]             version = "1.8"), class = "FutureResult")
[10:22:51.263]     }, finally = {
[10:22:51.263]         if (!identical(...future.workdir, getwd())) 
[10:22:51.263]             setwd(...future.workdir)
[10:22:51.263]         {
[10:22:51.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.263]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.263]             }
[10:22:51.263]             base::options(...future.oldOptions)
[10:22:51.263]             if (.Platform$OS.type == "windows") {
[10:22:51.263]                 old_names <- names(...future.oldEnvVars)
[10:22:51.263]                 envs <- base::Sys.getenv()
[10:22:51.263]                 names <- names(envs)
[10:22:51.263]                 common <- intersect(names, old_names)
[10:22:51.263]                 added <- setdiff(names, old_names)
[10:22:51.263]                 removed <- setdiff(old_names, names)
[10:22:51.263]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.263]                   envs[common]]
[10:22:51.263]                 NAMES <- toupper(changed)
[10:22:51.263]                 args <- list()
[10:22:51.263]                 for (kk in seq_along(NAMES)) {
[10:22:51.263]                   name <- changed[[kk]]
[10:22:51.263]                   NAME <- NAMES[[kk]]
[10:22:51.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.263]                     next
[10:22:51.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.263]                 }
[10:22:51.263]                 NAMES <- toupper(added)
[10:22:51.263]                 for (kk in seq_along(NAMES)) {
[10:22:51.263]                   name <- added[[kk]]
[10:22:51.263]                   NAME <- NAMES[[kk]]
[10:22:51.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.263]                     next
[10:22:51.263]                   args[[name]] <- ""
[10:22:51.263]                 }
[10:22:51.263]                 NAMES <- toupper(removed)
[10:22:51.263]                 for (kk in seq_along(NAMES)) {
[10:22:51.263]                   name <- removed[[kk]]
[10:22:51.263]                   NAME <- NAMES[[kk]]
[10:22:51.263]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.263]                     next
[10:22:51.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.263]                 }
[10:22:51.263]                 if (length(args) > 0) 
[10:22:51.263]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.263]             }
[10:22:51.263]             else {
[10:22:51.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.263]             }
[10:22:51.263]             {
[10:22:51.263]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.263]                   0L) {
[10:22:51.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.263]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.263]                   base::options(opts)
[10:22:51.263]                 }
[10:22:51.263]                 {
[10:22:51.263]                   {
[10:22:51.263]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.263]                     NULL
[10:22:51.263]                   }
[10:22:51.263]                   options(future.plan = NULL)
[10:22:51.263]                   if (is.na(NA_character_)) 
[10:22:51.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.263]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.263]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.263]                     envir = parent.frame()) 
[10:22:51.263]                   {
[10:22:51.263]                     if (is.function(workers)) 
[10:22:51.263]                       workers <- workers()
[10:22:51.263]                     workers <- structure(as.integer(workers), 
[10:22:51.263]                       class = class(workers))
[10:22:51.263]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.263]                       workers >= 1)
[10:22:51.263]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.263]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.263]                     }
[10:22:51.263]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.263]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.263]                       envir = envir)
[10:22:51.263]                     if (!future$lazy) 
[10:22:51.263]                       future <- run(future)
[10:22:51.263]                     invisible(future)
[10:22:51.263]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.263]                 }
[10:22:51.263]             }
[10:22:51.263]         }
[10:22:51.263]     })
[10:22:51.263]     if (TRUE) {
[10:22:51.263]         base::sink(type = "output", split = FALSE)
[10:22:51.263]         if (TRUE) {
[10:22:51.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.263]         }
[10:22:51.263]         else {
[10:22:51.263]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.263]         }
[10:22:51.263]         base::close(...future.stdout)
[10:22:51.263]         ...future.stdout <- NULL
[10:22:51.263]     }
[10:22:51.263]     ...future.result$conditions <- ...future.conditions
[10:22:51.263]     ...future.result$finished <- base::Sys.time()
[10:22:51.263]     ...future.result
[10:22:51.263] }
[10:22:51.320] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:22:51.320] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:22:51.321] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:22:51.321] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:51.321] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.322] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[10:22:51.322] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[10:22:51.322] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:51.322] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.323] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:22:51.323] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.323] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:22:51.324] MultisessionFuture started
[10:22:51.324] - Launch lazy future ... done
[10:22:51.324] run() for ‘MultisessionFuture’ ... done
[10:22:51.324] Created future:
[10:22:51.324] MultisessionFuture:
[10:22:51.324] Label: ‘future_by-2’
[10:22:51.324] Expression:
[10:22:51.324] {
[10:22:51.324]     do.call(function(...) {
[10:22:51.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.324]             on.exit(options(oopts), add = TRUE)
[10:22:51.324]         }
[10:22:51.324]         {
[10:22:51.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.324]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.324]             })
[10:22:51.324]         }
[10:22:51.324]     }, args = future.call.arguments)
[10:22:51.324] }
[10:22:51.324] Lazy evaluation: FALSE
[10:22:51.324] Asynchronous evaluation: TRUE
[10:22:51.324] Local evaluation: TRUE
[10:22:51.324] Environment: R_GlobalEnv
[10:22:51.324] Capture standard output: TRUE
[10:22:51.324] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.324] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.324] Packages: <none>
[10:22:51.324] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.324] Resolved: FALSE
[10:22:51.324] Value: <not collected>
[10:22:51.324] Conditions captured: <none>
[10:22:51.324] Early signaling: FALSE
[10:22:51.324] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.324] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.336] Chunk #2 of 2 ... DONE
[10:22:51.336] Launching 2 futures (chunks) ... DONE
[10:22:51.336] Resolving 2 futures (chunks) ...
[10:22:51.336] resolve() on list ...
[10:22:51.336]  recursive: 0
[10:22:51.337]  length: 2
[10:22:51.337] 
[10:22:51.337] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.337] - Validating connection of MultisessionFuture
[10:22:51.337] - received message: FutureResult
[10:22:51.338] - Received FutureResult
[10:22:51.338] - Erased future from FutureRegistry
[10:22:51.338] result() for ClusterFuture ...
[10:22:51.338] - result already collected: FutureResult
[10:22:51.338] result() for ClusterFuture ... done
[10:22:51.338] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.338] Future #1
[10:22:51.338] result() for ClusterFuture ...
[10:22:51.338] - result already collected: FutureResult
[10:22:51.338] result() for ClusterFuture ... done
[10:22:51.339] result() for ClusterFuture ...
[10:22:51.339] - result already collected: FutureResult
[10:22:51.339] result() for ClusterFuture ... done
[10:22:51.339] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:51.339] - nx: 2
[10:22:51.339] - relay: TRUE
[10:22:51.339] - stdout: TRUE
[10:22:51.339] - signal: TRUE
[10:22:51.339] - resignal: FALSE
[10:22:51.342] - force: TRUE
[10:22:51.342] - relayed: [n=2] FALSE, FALSE
[10:22:51.342] - queued futures: [n=2] FALSE, FALSE
[10:22:51.342]  - until=1
[10:22:51.342]  - relaying element #1
[10:22:51.342] result() for ClusterFuture ...
[10:22:51.343] - result already collected: FutureResult
[10:22:51.343] result() for ClusterFuture ... done
[10:22:51.343] result() for ClusterFuture ...
[10:22:51.343] - result already collected: FutureResult
[10:22:51.343] result() for ClusterFuture ... done
[10:22:51.343] result() for ClusterFuture ...
[10:22:51.343] - result already collected: FutureResult
[10:22:51.343] result() for ClusterFuture ... done
[10:22:51.343] result() for ClusterFuture ...
[10:22:51.343] - result already collected: FutureResult
[10:22:51.343] result() for ClusterFuture ... done
[10:22:51.343] - relayed: [n=2] TRUE, FALSE
[10:22:51.344] - queued futures: [n=2] TRUE, FALSE
[10:22:51.344] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:51.344]  length: 1 (resolved future 1)
[10:22:51.414] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.415] - Validating connection of MultisessionFuture
[10:22:51.415] - received message: FutureResult
[10:22:51.415] - Received FutureResult
[10:22:51.415] - Erased future from FutureRegistry
[10:22:51.415] result() for ClusterFuture ...
[10:22:51.415] - result already collected: FutureResult
[10:22:51.415] result() for ClusterFuture ... done
[10:22:51.416] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.416] Future #2
[10:22:51.416] result() for ClusterFuture ...
[10:22:51.416] - result already collected: FutureResult
[10:22:51.416] result() for ClusterFuture ... done
[10:22:51.416] result() for ClusterFuture ...
[10:22:51.416] - result already collected: FutureResult
[10:22:51.416] result() for ClusterFuture ... done
[10:22:51.416] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:51.416] - nx: 2
[10:22:51.416] - relay: TRUE
[10:22:51.417] - stdout: TRUE
[10:22:51.417] - signal: TRUE
[10:22:51.417] - resignal: FALSE
[10:22:51.417] - force: TRUE
[10:22:51.417] - relayed: [n=2] TRUE, FALSE
[10:22:51.417] - queued futures: [n=2] TRUE, FALSE
[10:22:51.417]  - until=2
[10:22:51.417]  - relaying element #2
[10:22:51.417] result() for ClusterFuture ...
[10:22:51.417] - result already collected: FutureResult
[10:22:51.417] result() for ClusterFuture ... done
[10:22:51.417] result() for ClusterFuture ...
[10:22:51.418] - result already collected: FutureResult
[10:22:51.418] result() for ClusterFuture ... done
[10:22:51.418] result() for ClusterFuture ...
[10:22:51.418] - result already collected: FutureResult
[10:22:51.418] result() for ClusterFuture ... done
[10:22:51.418] result() for ClusterFuture ...
[10:22:51.418] - result already collected: FutureResult
[10:22:51.418] result() for ClusterFuture ... done
[10:22:51.418] - relayed: [n=2] TRUE, TRUE
[10:22:51.418] - queued futures: [n=2] TRUE, TRUE
[10:22:51.418] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:51.419]  length: 0 (resolved future 2)
[10:22:51.419] Relaying remaining futures
[10:22:51.419] signalConditionsASAP(NULL, pos=0) ...
[10:22:51.419] - nx: 2
[10:22:51.419] - relay: TRUE
[10:22:51.419] - stdout: TRUE
[10:22:51.419] - signal: TRUE
[10:22:51.419] - resignal: FALSE
[10:22:51.419] - force: TRUE
[10:22:51.419] - relayed: [n=2] TRUE, TRUE
[10:22:51.419] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:51.420] - relayed: [n=2] TRUE, TRUE
[10:22:51.420] - queued futures: [n=2] TRUE, TRUE
[10:22:51.420] signalConditionsASAP(NULL, pos=0) ... done
[10:22:51.420] resolve() on list ... DONE
[10:22:51.420] result() for ClusterFuture ...
[10:22:51.420] - result already collected: FutureResult
[10:22:51.420] result() for ClusterFuture ... done
[10:22:51.420] result() for ClusterFuture ...
[10:22:51.420] - result already collected: FutureResult
[10:22:51.420] result() for ClusterFuture ... done
[10:22:51.420] result() for ClusterFuture ...
[10:22:51.421] - result already collected: FutureResult
[10:22:51.421] result() for ClusterFuture ... done
[10:22:51.421] result() for ClusterFuture ...
[10:22:51.421] - result already collected: FutureResult
[10:22:51.421] result() for ClusterFuture ... done
[10:22:51.421]  - Number of value chunks collected: 2
[10:22:51.421] Resolving 2 futures (chunks) ... DONE
[10:22:51.421] Reducing values from 2 chunks ...
[10:22:51.421]  - Number of values collected after concatenation: 3
[10:22:51.421]  - Number of values expected: 3
[10:22:51.421] Reducing values from 2 chunks ... DONE
[10:22:51.422] future_lapply() ... DONE
[10:22:51.422] future_by_internal() ... DONE
[10:22:51.422] future_by_internal() ...
[10:22:51.422] future_lapply() ...
[10:22:51.426] Number of chunks: 2
[10:22:51.426] getGlobalsAndPackagesXApply() ...
[10:22:51.426]  - future.globals: TRUE
[10:22:51.426] getGlobalsAndPackages() ...
[10:22:51.427] Searching for globals...
[10:22:51.428] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:51.428] Searching for globals ... DONE
[10:22:51.428] Resolving globals: FALSE
[10:22:51.428] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:51.429] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:51.429] - globals: [1] ‘FUN’
[10:22:51.429] 
[10:22:51.429] getGlobalsAndPackages() ... DONE
[10:22:51.429]  - globals found/used: [n=1] ‘FUN’
[10:22:51.429]  - needed namespaces: [n=0] 
[10:22:51.429] Finding globals ... DONE
[10:22:51.429]  - use_args: TRUE
[10:22:51.429]  - Getting '...' globals ...
[10:22:51.430] resolve() on list ...
[10:22:51.430]  recursive: 0
[10:22:51.430]  length: 1
[10:22:51.430]  elements: ‘...’
[10:22:51.430]  length: 0 (resolved future 1)
[10:22:51.430] resolve() on list ... DONE
[10:22:51.430]    - '...' content: [n=1] ‘digits’
[10:22:51.430] List of 1
[10:22:51.430]  $ ...:List of 1
[10:22:51.430]   ..$ digits: int 2
[10:22:51.430]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.430]  - attr(*, "where")=List of 1
[10:22:51.430]   ..$ ...:<environment: 0x55f63bca8de0> 
[10:22:51.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.430]  - attr(*, "resolved")= logi TRUE
[10:22:51.430]  - attr(*, "total_size")= num NA
[10:22:51.433]  - Getting '...' globals ... DONE
[10:22:51.433] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:51.434] List of 2
[10:22:51.434]  $ ...future.FUN:function (object, ...)  
[10:22:51.434]  $ ...          :List of 1
[10:22:51.434]   ..$ digits: int 2
[10:22:51.434]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.434]  - attr(*, "where")=List of 2
[10:22:51.434]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:51.434]   ..$ ...          :<environment: 0x55f63bca8de0> 
[10:22:51.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.434]  - attr(*, "resolved")= logi FALSE
[10:22:51.434]  - attr(*, "total_size")= num 1296
[10:22:51.437] Packages to be attached in all futures: [n=0] 
[10:22:51.437] getGlobalsAndPackagesXApply() ... DONE
[10:22:51.437] Number of futures (= number of chunks): 2
[10:22:51.437] Launching 2 futures (chunks) ...
[10:22:51.437] Chunk #1 of 2 ...
[10:22:51.437]  - Finding globals in 'X' for chunk #1 ...
[10:22:51.437] getGlobalsAndPackages() ...
[10:22:51.437] Searching for globals...
[10:22:51.438] 
[10:22:51.438] Searching for globals ... DONE
[10:22:51.438] - globals: [0] <none>
[10:22:51.438] getGlobalsAndPackages() ... DONE
[10:22:51.438]    + additional globals found: [n=0] 
[10:22:51.438]    + additional namespaces needed: [n=0] 
[10:22:51.438]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:51.438]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.438]  - seeds: <none>
[10:22:51.438]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.438] getGlobalsAndPackages() ...
[10:22:51.439] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.439] Resolving globals: FALSE
[10:22:51.439] Tweak future expression to call with '...' arguments ...
[10:22:51.439] {
[10:22:51.439]     do.call(function(...) {
[10:22:51.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.439]             on.exit(options(oopts), add = TRUE)
[10:22:51.439]         }
[10:22:51.439]         {
[10:22:51.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.439]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.439]             })
[10:22:51.439]         }
[10:22:51.439]     }, args = future.call.arguments)
[10:22:51.439] }
[10:22:51.439] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.439] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.440] 
[10:22:51.440] getGlobalsAndPackages() ... DONE
[10:22:51.440] run() for ‘Future’ ...
[10:22:51.440] - state: ‘created’
[10:22:51.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.454]   - Field: ‘node’
[10:22:51.454]   - Field: ‘label’
[10:22:51.454]   - Field: ‘local’
[10:22:51.454]   - Field: ‘owner’
[10:22:51.454]   - Field: ‘envir’
[10:22:51.455]   - Field: ‘workers’
[10:22:51.455]   - Field: ‘packages’
[10:22:51.455]   - Field: ‘gc’
[10:22:51.455]   - Field: ‘conditions’
[10:22:51.455]   - Field: ‘persistent’
[10:22:51.455]   - Field: ‘expr’
[10:22:51.455]   - Field: ‘uuid’
[10:22:51.455]   - Field: ‘seed’
[10:22:51.455]   - Field: ‘version’
[10:22:51.455]   - Field: ‘result’
[10:22:51.455]   - Field: ‘asynchronous’
[10:22:51.455]   - Field: ‘calls’
[10:22:51.456]   - Field: ‘globals’
[10:22:51.456]   - Field: ‘stdout’
[10:22:51.456]   - Field: ‘earlySignal’
[10:22:51.456]   - Field: ‘lazy’
[10:22:51.456]   - Field: ‘state’
[10:22:51.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.456] - Launch lazy future ...
[10:22:51.456] Packages needed by the future expression (n = 0): <none>
[10:22:51.456] Packages needed by future strategies (n = 0): <none>
[10:22:51.457] {
[10:22:51.457]     {
[10:22:51.457]         {
[10:22:51.457]             ...future.startTime <- base::Sys.time()
[10:22:51.457]             {
[10:22:51.457]                 {
[10:22:51.457]                   {
[10:22:51.457]                     {
[10:22:51.457]                       base::local({
[10:22:51.457]                         has_future <- base::requireNamespace("future", 
[10:22:51.457]                           quietly = TRUE)
[10:22:51.457]                         if (has_future) {
[10:22:51.457]                           ns <- base::getNamespace("future")
[10:22:51.457]                           version <- ns[[".package"]][["version"]]
[10:22:51.457]                           if (is.null(version)) 
[10:22:51.457]                             version <- utils::packageVersion("future")
[10:22:51.457]                         }
[10:22:51.457]                         else {
[10:22:51.457]                           version <- NULL
[10:22:51.457]                         }
[10:22:51.457]                         if (!has_future || version < "1.8.0") {
[10:22:51.457]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.457]                             "", base::R.version$version.string), 
[10:22:51.457]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.457]                               "release", "version")], collapse = " "), 
[10:22:51.457]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.457]                             info)
[10:22:51.457]                           info <- base::paste(info, collapse = "; ")
[10:22:51.457]                           if (!has_future) {
[10:22:51.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.457]                               info)
[10:22:51.457]                           }
[10:22:51.457]                           else {
[10:22:51.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.457]                               info, version)
[10:22:51.457]                           }
[10:22:51.457]                           base::stop(msg)
[10:22:51.457]                         }
[10:22:51.457]                       })
[10:22:51.457]                     }
[10:22:51.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.457]                     base::options(mc.cores = 1L)
[10:22:51.457]                   }
[10:22:51.457]                   options(future.plan = NULL)
[10:22:51.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.457]                 }
[10:22:51.457]                 ...future.workdir <- getwd()
[10:22:51.457]             }
[10:22:51.457]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.457]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.457]         }
[10:22:51.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.457]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.457]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.457]             base::names(...future.oldOptions))
[10:22:51.457]     }
[10:22:51.457]     if (FALSE) {
[10:22:51.457]     }
[10:22:51.457]     else {
[10:22:51.457]         if (TRUE) {
[10:22:51.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.457]                 open = "w")
[10:22:51.457]         }
[10:22:51.457]         else {
[10:22:51.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.457]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.457]         }
[10:22:51.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.457]             base::sink(type = "output", split = FALSE)
[10:22:51.457]             base::close(...future.stdout)
[10:22:51.457]         }, add = TRUE)
[10:22:51.457]     }
[10:22:51.457]     ...future.frame <- base::sys.nframe()
[10:22:51.457]     ...future.conditions <- base::list()
[10:22:51.457]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.457]     if (FALSE) {
[10:22:51.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.457]     }
[10:22:51.457]     ...future.result <- base::tryCatch({
[10:22:51.457]         base::withCallingHandlers({
[10:22:51.457]             ...future.value <- base::withVisible(base::local({
[10:22:51.457]                 ...future.makeSendCondition <- base::local({
[10:22:51.457]                   sendCondition <- NULL
[10:22:51.457]                   function(frame = 1L) {
[10:22:51.457]                     if (is.function(sendCondition)) 
[10:22:51.457]                       return(sendCondition)
[10:22:51.457]                     ns <- getNamespace("parallel")
[10:22:51.457]                     if (exists("sendData", mode = "function", 
[10:22:51.457]                       envir = ns)) {
[10:22:51.457]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.457]                         envir = ns)
[10:22:51.457]                       envir <- sys.frame(frame)
[10:22:51.457]                       master <- NULL
[10:22:51.457]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.457]                         !identical(envir, emptyenv())) {
[10:22:51.457]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.457]                           inherits = FALSE)) {
[10:22:51.457]                           master <- get("master", mode = "list", 
[10:22:51.457]                             envir = envir, inherits = FALSE)
[10:22:51.457]                           if (inherits(master, c("SOCKnode", 
[10:22:51.457]                             "SOCK0node"))) {
[10:22:51.457]                             sendCondition <<- function(cond) {
[10:22:51.457]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.457]                                 success = TRUE)
[10:22:51.457]                               parallel_sendData(master, data)
[10:22:51.457]                             }
[10:22:51.457]                             return(sendCondition)
[10:22:51.457]                           }
[10:22:51.457]                         }
[10:22:51.457]                         frame <- frame + 1L
[10:22:51.457]                         envir <- sys.frame(frame)
[10:22:51.457]                       }
[10:22:51.457]                     }
[10:22:51.457]                     sendCondition <<- function(cond) NULL
[10:22:51.457]                   }
[10:22:51.457]                 })
[10:22:51.457]                 withCallingHandlers({
[10:22:51.457]                   {
[10:22:51.457]                     do.call(function(...) {
[10:22:51.457]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.457]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.457]                         ...future.globals.maxSize)) {
[10:22:51.457]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.457]                         on.exit(options(oopts), add = TRUE)
[10:22:51.457]                       }
[10:22:51.457]                       {
[10:22:51.457]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.457]                           FUN = function(jj) {
[10:22:51.457]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.457]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.457]                           })
[10:22:51.457]                       }
[10:22:51.457]                     }, args = future.call.arguments)
[10:22:51.457]                   }
[10:22:51.457]                 }, immediateCondition = function(cond) {
[10:22:51.457]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.457]                   sendCondition(cond)
[10:22:51.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.457]                   {
[10:22:51.457]                     inherits <- base::inherits
[10:22:51.457]                     invokeRestart <- base::invokeRestart
[10:22:51.457]                     is.null <- base::is.null
[10:22:51.457]                     muffled <- FALSE
[10:22:51.457]                     if (inherits(cond, "message")) {
[10:22:51.457]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.457]                       if (muffled) 
[10:22:51.457]                         invokeRestart("muffleMessage")
[10:22:51.457]                     }
[10:22:51.457]                     else if (inherits(cond, "warning")) {
[10:22:51.457]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.457]                       if (muffled) 
[10:22:51.457]                         invokeRestart("muffleWarning")
[10:22:51.457]                     }
[10:22:51.457]                     else if (inherits(cond, "condition")) {
[10:22:51.457]                       if (!is.null(pattern)) {
[10:22:51.457]                         computeRestarts <- base::computeRestarts
[10:22:51.457]                         grepl <- base::grepl
[10:22:51.457]                         restarts <- computeRestarts(cond)
[10:22:51.457]                         for (restart in restarts) {
[10:22:51.457]                           name <- restart$name
[10:22:51.457]                           if (is.null(name)) 
[10:22:51.457]                             next
[10:22:51.457]                           if (!grepl(pattern, name)) 
[10:22:51.457]                             next
[10:22:51.457]                           invokeRestart(restart)
[10:22:51.457]                           muffled <- TRUE
[10:22:51.457]                           break
[10:22:51.457]                         }
[10:22:51.457]                       }
[10:22:51.457]                     }
[10:22:51.457]                     invisible(muffled)
[10:22:51.457]                   }
[10:22:51.457]                   muffleCondition(cond)
[10:22:51.457]                 })
[10:22:51.457]             }))
[10:22:51.457]             future::FutureResult(value = ...future.value$value, 
[10:22:51.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.457]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.457]                     ...future.globalenv.names))
[10:22:51.457]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.457]         }, condition = base::local({
[10:22:51.457]             c <- base::c
[10:22:51.457]             inherits <- base::inherits
[10:22:51.457]             invokeRestart <- base::invokeRestart
[10:22:51.457]             length <- base::length
[10:22:51.457]             list <- base::list
[10:22:51.457]             seq.int <- base::seq.int
[10:22:51.457]             signalCondition <- base::signalCondition
[10:22:51.457]             sys.calls <- base::sys.calls
[10:22:51.457]             `[[` <- base::`[[`
[10:22:51.457]             `+` <- base::`+`
[10:22:51.457]             `<<-` <- base::`<<-`
[10:22:51.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.457]                   3L)]
[10:22:51.457]             }
[10:22:51.457]             function(cond) {
[10:22:51.457]                 is_error <- inherits(cond, "error")
[10:22:51.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.457]                   NULL)
[10:22:51.457]                 if (is_error) {
[10:22:51.457]                   sessionInformation <- function() {
[10:22:51.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.457]                       search = base::search(), system = base::Sys.info())
[10:22:51.457]                   }
[10:22:51.457]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.457]                     cond$call), session = sessionInformation(), 
[10:22:51.457]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.457]                   signalCondition(cond)
[10:22:51.457]                 }
[10:22:51.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.457]                 "immediateCondition"))) {
[10:22:51.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.457]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.457]                   if (TRUE && !signal) {
[10:22:51.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.457]                     {
[10:22:51.457]                       inherits <- base::inherits
[10:22:51.457]                       invokeRestart <- base::invokeRestart
[10:22:51.457]                       is.null <- base::is.null
[10:22:51.457]                       muffled <- FALSE
[10:22:51.457]                       if (inherits(cond, "message")) {
[10:22:51.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.457]                         if (muffled) 
[10:22:51.457]                           invokeRestart("muffleMessage")
[10:22:51.457]                       }
[10:22:51.457]                       else if (inherits(cond, "warning")) {
[10:22:51.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.457]                         if (muffled) 
[10:22:51.457]                           invokeRestart("muffleWarning")
[10:22:51.457]                       }
[10:22:51.457]                       else if (inherits(cond, "condition")) {
[10:22:51.457]                         if (!is.null(pattern)) {
[10:22:51.457]                           computeRestarts <- base::computeRestarts
[10:22:51.457]                           grepl <- base::grepl
[10:22:51.457]                           restarts <- computeRestarts(cond)
[10:22:51.457]                           for (restart in restarts) {
[10:22:51.457]                             name <- restart$name
[10:22:51.457]                             if (is.null(name)) 
[10:22:51.457]                               next
[10:22:51.457]                             if (!grepl(pattern, name)) 
[10:22:51.457]                               next
[10:22:51.457]                             invokeRestart(restart)
[10:22:51.457]                             muffled <- TRUE
[10:22:51.457]                             break
[10:22:51.457]                           }
[10:22:51.457]                         }
[10:22:51.457]                       }
[10:22:51.457]                       invisible(muffled)
[10:22:51.457]                     }
[10:22:51.457]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.457]                   }
[10:22:51.457]                 }
[10:22:51.457]                 else {
[10:22:51.457]                   if (TRUE) {
[10:22:51.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.457]                     {
[10:22:51.457]                       inherits <- base::inherits
[10:22:51.457]                       invokeRestart <- base::invokeRestart
[10:22:51.457]                       is.null <- base::is.null
[10:22:51.457]                       muffled <- FALSE
[10:22:51.457]                       if (inherits(cond, "message")) {
[10:22:51.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.457]                         if (muffled) 
[10:22:51.457]                           invokeRestart("muffleMessage")
[10:22:51.457]                       }
[10:22:51.457]                       else if (inherits(cond, "warning")) {
[10:22:51.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.457]                         if (muffled) 
[10:22:51.457]                           invokeRestart("muffleWarning")
[10:22:51.457]                       }
[10:22:51.457]                       else if (inherits(cond, "condition")) {
[10:22:51.457]                         if (!is.null(pattern)) {
[10:22:51.457]                           computeRestarts <- base::computeRestarts
[10:22:51.457]                           grepl <- base::grepl
[10:22:51.457]                           restarts <- computeRestarts(cond)
[10:22:51.457]                           for (restart in restarts) {
[10:22:51.457]                             name <- restart$name
[10:22:51.457]                             if (is.null(name)) 
[10:22:51.457]                               next
[10:22:51.457]                             if (!grepl(pattern, name)) 
[10:22:51.457]                               next
[10:22:51.457]                             invokeRestart(restart)
[10:22:51.457]                             muffled <- TRUE
[10:22:51.457]                             break
[10:22:51.457]                           }
[10:22:51.457]                         }
[10:22:51.457]                       }
[10:22:51.457]                       invisible(muffled)
[10:22:51.457]                     }
[10:22:51.457]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.457]                   }
[10:22:51.457]                 }
[10:22:51.457]             }
[10:22:51.457]         }))
[10:22:51.457]     }, error = function(ex) {
[10:22:51.457]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.457]                 ...future.rng), started = ...future.startTime, 
[10:22:51.457]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.457]             version = "1.8"), class = "FutureResult")
[10:22:51.457]     }, finally = {
[10:22:51.457]         if (!identical(...future.workdir, getwd())) 
[10:22:51.457]             setwd(...future.workdir)
[10:22:51.457]         {
[10:22:51.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.457]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.457]             }
[10:22:51.457]             base::options(...future.oldOptions)
[10:22:51.457]             if (.Platform$OS.type == "windows") {
[10:22:51.457]                 old_names <- names(...future.oldEnvVars)
[10:22:51.457]                 envs <- base::Sys.getenv()
[10:22:51.457]                 names <- names(envs)
[10:22:51.457]                 common <- intersect(names, old_names)
[10:22:51.457]                 added <- setdiff(names, old_names)
[10:22:51.457]                 removed <- setdiff(old_names, names)
[10:22:51.457]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.457]                   envs[common]]
[10:22:51.457]                 NAMES <- toupper(changed)
[10:22:51.457]                 args <- list()
[10:22:51.457]                 for (kk in seq_along(NAMES)) {
[10:22:51.457]                   name <- changed[[kk]]
[10:22:51.457]                   NAME <- NAMES[[kk]]
[10:22:51.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.457]                     next
[10:22:51.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.457]                 }
[10:22:51.457]                 NAMES <- toupper(added)
[10:22:51.457]                 for (kk in seq_along(NAMES)) {
[10:22:51.457]                   name <- added[[kk]]
[10:22:51.457]                   NAME <- NAMES[[kk]]
[10:22:51.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.457]                     next
[10:22:51.457]                   args[[name]] <- ""
[10:22:51.457]                 }
[10:22:51.457]                 NAMES <- toupper(removed)
[10:22:51.457]                 for (kk in seq_along(NAMES)) {
[10:22:51.457]                   name <- removed[[kk]]
[10:22:51.457]                   NAME <- NAMES[[kk]]
[10:22:51.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.457]                     next
[10:22:51.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.457]                 }
[10:22:51.457]                 if (length(args) > 0) 
[10:22:51.457]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.457]             }
[10:22:51.457]             else {
[10:22:51.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.457]             }
[10:22:51.457]             {
[10:22:51.457]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.457]                   0L) {
[10:22:51.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.457]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.457]                   base::options(opts)
[10:22:51.457]                 }
[10:22:51.457]                 {
[10:22:51.457]                   {
[10:22:51.457]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.457]                     NULL
[10:22:51.457]                   }
[10:22:51.457]                   options(future.plan = NULL)
[10:22:51.457]                   if (is.na(NA_character_)) 
[10:22:51.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.457]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.457]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.457]                     envir = parent.frame()) 
[10:22:51.457]                   {
[10:22:51.457]                     if (is.function(workers)) 
[10:22:51.457]                       workers <- workers()
[10:22:51.457]                     workers <- structure(as.integer(workers), 
[10:22:51.457]                       class = class(workers))
[10:22:51.457]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.457]                       workers >= 1)
[10:22:51.457]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.457]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.457]                     }
[10:22:51.457]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.457]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.457]                       envir = envir)
[10:22:51.457]                     if (!future$lazy) 
[10:22:51.457]                       future <- run(future)
[10:22:51.457]                     invisible(future)
[10:22:51.457]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.457]                 }
[10:22:51.457]             }
[10:22:51.457]         }
[10:22:51.457]     })
[10:22:51.457]     if (TRUE) {
[10:22:51.457]         base::sink(type = "output", split = FALSE)
[10:22:51.457]         if (TRUE) {
[10:22:51.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.457]         }
[10:22:51.457]         else {
[10:22:51.457]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.457]         }
[10:22:51.457]         base::close(...future.stdout)
[10:22:51.457]         ...future.stdout <- NULL
[10:22:51.457]     }
[10:22:51.457]     ...future.result$conditions <- ...future.conditions
[10:22:51.457]     ...future.result$finished <- base::Sys.time()
[10:22:51.457]     ...future.result
[10:22:51.457] }
[10:22:51.460] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:22:51.460] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:22:51.460] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:22:51.461] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[10:22:51.461] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[10:22:51.461] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[10:22:51.461] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[10:22:51.462] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:51.462] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.462] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:22:51.462] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.463] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:22:51.463] MultisessionFuture started
[10:22:51.463] - Launch lazy future ... done
[10:22:51.463] run() for ‘MultisessionFuture’ ... done
[10:22:51.464] Created future:
[10:22:51.464] MultisessionFuture:
[10:22:51.464] Label: ‘future_by-1’
[10:22:51.464] Expression:
[10:22:51.464] {
[10:22:51.464]     do.call(function(...) {
[10:22:51.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.464]             on.exit(options(oopts), add = TRUE)
[10:22:51.464]         }
[10:22:51.464]         {
[10:22:51.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.464]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.464]             })
[10:22:51.464]         }
[10:22:51.464]     }, args = future.call.arguments)
[10:22:51.464] }
[10:22:51.464] Lazy evaluation: FALSE
[10:22:51.464] Asynchronous evaluation: TRUE
[10:22:51.464] Local evaluation: TRUE
[10:22:51.464] Environment: R_GlobalEnv
[10:22:51.464] Capture standard output: TRUE
[10:22:51.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.464] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.464] Packages: <none>
[10:22:51.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.464] Resolved: FALSE
[10:22:51.464] Value: <not collected>
[10:22:51.464] Conditions captured: <none>
[10:22:51.464] Early signaling: FALSE
[10:22:51.464] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.464] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.475] Chunk #1 of 2 ... DONE
[10:22:51.475] Chunk #2 of 2 ...
[10:22:51.476]  - Finding globals in 'X' for chunk #2 ...
[10:22:51.476] getGlobalsAndPackages() ...
[10:22:51.476] Searching for globals...
[10:22:51.476] 
[10:22:51.476] Searching for globals ... DONE
[10:22:51.476] - globals: [0] <none>
[10:22:51.476] getGlobalsAndPackages() ... DONE
[10:22:51.476]    + additional globals found: [n=0] 
[10:22:51.476]    + additional namespaces needed: [n=0] 
[10:22:51.477]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:51.477]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.477]  - seeds: <none>
[10:22:51.477]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.477] getGlobalsAndPackages() ...
[10:22:51.477] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.477] Resolving globals: FALSE
[10:22:51.477] Tweak future expression to call with '...' arguments ...
[10:22:51.477] {
[10:22:51.477]     do.call(function(...) {
[10:22:51.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.477]             on.exit(options(oopts), add = TRUE)
[10:22:51.477]         }
[10:22:51.477]         {
[10:22:51.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.477]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.477]             })
[10:22:51.477]         }
[10:22:51.477]     }, args = future.call.arguments)
[10:22:51.477] }
[10:22:51.478] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.478] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.478] 
[10:22:51.478] getGlobalsAndPackages() ... DONE
[10:22:51.478] run() for ‘Future’ ...
[10:22:51.479] - state: ‘created’
[10:22:51.479] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.492]   - Field: ‘node’
[10:22:51.492]   - Field: ‘label’
[10:22:51.493]   - Field: ‘local’
[10:22:51.493]   - Field: ‘owner’
[10:22:51.493]   - Field: ‘envir’
[10:22:51.493]   - Field: ‘workers’
[10:22:51.493]   - Field: ‘packages’
[10:22:51.493]   - Field: ‘gc’
[10:22:51.493]   - Field: ‘conditions’
[10:22:51.493]   - Field: ‘persistent’
[10:22:51.493]   - Field: ‘expr’
[10:22:51.493]   - Field: ‘uuid’
[10:22:51.493]   - Field: ‘seed’
[10:22:51.494]   - Field: ‘version’
[10:22:51.494]   - Field: ‘result’
[10:22:51.494]   - Field: ‘asynchronous’
[10:22:51.494]   - Field: ‘calls’
[10:22:51.494]   - Field: ‘globals’
[10:22:51.494]   - Field: ‘stdout’
[10:22:51.494]   - Field: ‘earlySignal’
[10:22:51.494]   - Field: ‘lazy’
[10:22:51.494]   - Field: ‘state’
[10:22:51.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.494] - Launch lazy future ...
[10:22:51.495] Packages needed by the future expression (n = 0): <none>
[10:22:51.495] Packages needed by future strategies (n = 0): <none>
[10:22:51.495] {
[10:22:51.495]     {
[10:22:51.495]         {
[10:22:51.495]             ...future.startTime <- base::Sys.time()
[10:22:51.495]             {
[10:22:51.495]                 {
[10:22:51.495]                   {
[10:22:51.495]                     {
[10:22:51.495]                       base::local({
[10:22:51.495]                         has_future <- base::requireNamespace("future", 
[10:22:51.495]                           quietly = TRUE)
[10:22:51.495]                         if (has_future) {
[10:22:51.495]                           ns <- base::getNamespace("future")
[10:22:51.495]                           version <- ns[[".package"]][["version"]]
[10:22:51.495]                           if (is.null(version)) 
[10:22:51.495]                             version <- utils::packageVersion("future")
[10:22:51.495]                         }
[10:22:51.495]                         else {
[10:22:51.495]                           version <- NULL
[10:22:51.495]                         }
[10:22:51.495]                         if (!has_future || version < "1.8.0") {
[10:22:51.495]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.495]                             "", base::R.version$version.string), 
[10:22:51.495]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.495]                               "release", "version")], collapse = " "), 
[10:22:51.495]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.495]                             info)
[10:22:51.495]                           info <- base::paste(info, collapse = "; ")
[10:22:51.495]                           if (!has_future) {
[10:22:51.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.495]                               info)
[10:22:51.495]                           }
[10:22:51.495]                           else {
[10:22:51.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.495]                               info, version)
[10:22:51.495]                           }
[10:22:51.495]                           base::stop(msg)
[10:22:51.495]                         }
[10:22:51.495]                       })
[10:22:51.495]                     }
[10:22:51.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.495]                     base::options(mc.cores = 1L)
[10:22:51.495]                   }
[10:22:51.495]                   options(future.plan = NULL)
[10:22:51.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.495]                 }
[10:22:51.495]                 ...future.workdir <- getwd()
[10:22:51.495]             }
[10:22:51.495]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.495]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.495]         }
[10:22:51.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.495]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.495]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.495]             base::names(...future.oldOptions))
[10:22:51.495]     }
[10:22:51.495]     if (FALSE) {
[10:22:51.495]     }
[10:22:51.495]     else {
[10:22:51.495]         if (TRUE) {
[10:22:51.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.495]                 open = "w")
[10:22:51.495]         }
[10:22:51.495]         else {
[10:22:51.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.495]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.495]         }
[10:22:51.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.495]             base::sink(type = "output", split = FALSE)
[10:22:51.495]             base::close(...future.stdout)
[10:22:51.495]         }, add = TRUE)
[10:22:51.495]     }
[10:22:51.495]     ...future.frame <- base::sys.nframe()
[10:22:51.495]     ...future.conditions <- base::list()
[10:22:51.495]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.495]     if (FALSE) {
[10:22:51.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.495]     }
[10:22:51.495]     ...future.result <- base::tryCatch({
[10:22:51.495]         base::withCallingHandlers({
[10:22:51.495]             ...future.value <- base::withVisible(base::local({
[10:22:51.495]                 ...future.makeSendCondition <- base::local({
[10:22:51.495]                   sendCondition <- NULL
[10:22:51.495]                   function(frame = 1L) {
[10:22:51.495]                     if (is.function(sendCondition)) 
[10:22:51.495]                       return(sendCondition)
[10:22:51.495]                     ns <- getNamespace("parallel")
[10:22:51.495]                     if (exists("sendData", mode = "function", 
[10:22:51.495]                       envir = ns)) {
[10:22:51.495]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.495]                         envir = ns)
[10:22:51.495]                       envir <- sys.frame(frame)
[10:22:51.495]                       master <- NULL
[10:22:51.495]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.495]                         !identical(envir, emptyenv())) {
[10:22:51.495]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.495]                           inherits = FALSE)) {
[10:22:51.495]                           master <- get("master", mode = "list", 
[10:22:51.495]                             envir = envir, inherits = FALSE)
[10:22:51.495]                           if (inherits(master, c("SOCKnode", 
[10:22:51.495]                             "SOCK0node"))) {
[10:22:51.495]                             sendCondition <<- function(cond) {
[10:22:51.495]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.495]                                 success = TRUE)
[10:22:51.495]                               parallel_sendData(master, data)
[10:22:51.495]                             }
[10:22:51.495]                             return(sendCondition)
[10:22:51.495]                           }
[10:22:51.495]                         }
[10:22:51.495]                         frame <- frame + 1L
[10:22:51.495]                         envir <- sys.frame(frame)
[10:22:51.495]                       }
[10:22:51.495]                     }
[10:22:51.495]                     sendCondition <<- function(cond) NULL
[10:22:51.495]                   }
[10:22:51.495]                 })
[10:22:51.495]                 withCallingHandlers({
[10:22:51.495]                   {
[10:22:51.495]                     do.call(function(...) {
[10:22:51.495]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.495]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.495]                         ...future.globals.maxSize)) {
[10:22:51.495]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.495]                         on.exit(options(oopts), add = TRUE)
[10:22:51.495]                       }
[10:22:51.495]                       {
[10:22:51.495]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.495]                           FUN = function(jj) {
[10:22:51.495]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.495]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.495]                           })
[10:22:51.495]                       }
[10:22:51.495]                     }, args = future.call.arguments)
[10:22:51.495]                   }
[10:22:51.495]                 }, immediateCondition = function(cond) {
[10:22:51.495]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.495]                   sendCondition(cond)
[10:22:51.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.495]                   {
[10:22:51.495]                     inherits <- base::inherits
[10:22:51.495]                     invokeRestart <- base::invokeRestart
[10:22:51.495]                     is.null <- base::is.null
[10:22:51.495]                     muffled <- FALSE
[10:22:51.495]                     if (inherits(cond, "message")) {
[10:22:51.495]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.495]                       if (muffled) 
[10:22:51.495]                         invokeRestart("muffleMessage")
[10:22:51.495]                     }
[10:22:51.495]                     else if (inherits(cond, "warning")) {
[10:22:51.495]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.495]                       if (muffled) 
[10:22:51.495]                         invokeRestart("muffleWarning")
[10:22:51.495]                     }
[10:22:51.495]                     else if (inherits(cond, "condition")) {
[10:22:51.495]                       if (!is.null(pattern)) {
[10:22:51.495]                         computeRestarts <- base::computeRestarts
[10:22:51.495]                         grepl <- base::grepl
[10:22:51.495]                         restarts <- computeRestarts(cond)
[10:22:51.495]                         for (restart in restarts) {
[10:22:51.495]                           name <- restart$name
[10:22:51.495]                           if (is.null(name)) 
[10:22:51.495]                             next
[10:22:51.495]                           if (!grepl(pattern, name)) 
[10:22:51.495]                             next
[10:22:51.495]                           invokeRestart(restart)
[10:22:51.495]                           muffled <- TRUE
[10:22:51.495]                           break
[10:22:51.495]                         }
[10:22:51.495]                       }
[10:22:51.495]                     }
[10:22:51.495]                     invisible(muffled)
[10:22:51.495]                   }
[10:22:51.495]                   muffleCondition(cond)
[10:22:51.495]                 })
[10:22:51.495]             }))
[10:22:51.495]             future::FutureResult(value = ...future.value$value, 
[10:22:51.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.495]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.495]                     ...future.globalenv.names))
[10:22:51.495]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.495]         }, condition = base::local({
[10:22:51.495]             c <- base::c
[10:22:51.495]             inherits <- base::inherits
[10:22:51.495]             invokeRestart <- base::invokeRestart
[10:22:51.495]             length <- base::length
[10:22:51.495]             list <- base::list
[10:22:51.495]             seq.int <- base::seq.int
[10:22:51.495]             signalCondition <- base::signalCondition
[10:22:51.495]             sys.calls <- base::sys.calls
[10:22:51.495]             `[[` <- base::`[[`
[10:22:51.495]             `+` <- base::`+`
[10:22:51.495]             `<<-` <- base::`<<-`
[10:22:51.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.495]                   3L)]
[10:22:51.495]             }
[10:22:51.495]             function(cond) {
[10:22:51.495]                 is_error <- inherits(cond, "error")
[10:22:51.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.495]                   NULL)
[10:22:51.495]                 if (is_error) {
[10:22:51.495]                   sessionInformation <- function() {
[10:22:51.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.495]                       search = base::search(), system = base::Sys.info())
[10:22:51.495]                   }
[10:22:51.495]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.495]                     cond$call), session = sessionInformation(), 
[10:22:51.495]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.495]                   signalCondition(cond)
[10:22:51.495]                 }
[10:22:51.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.495]                 "immediateCondition"))) {
[10:22:51.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.495]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.495]                   if (TRUE && !signal) {
[10:22:51.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.495]                     {
[10:22:51.495]                       inherits <- base::inherits
[10:22:51.495]                       invokeRestart <- base::invokeRestart
[10:22:51.495]                       is.null <- base::is.null
[10:22:51.495]                       muffled <- FALSE
[10:22:51.495]                       if (inherits(cond, "message")) {
[10:22:51.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.495]                         if (muffled) 
[10:22:51.495]                           invokeRestart("muffleMessage")
[10:22:51.495]                       }
[10:22:51.495]                       else if (inherits(cond, "warning")) {
[10:22:51.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.495]                         if (muffled) 
[10:22:51.495]                           invokeRestart("muffleWarning")
[10:22:51.495]                       }
[10:22:51.495]                       else if (inherits(cond, "condition")) {
[10:22:51.495]                         if (!is.null(pattern)) {
[10:22:51.495]                           computeRestarts <- base::computeRestarts
[10:22:51.495]                           grepl <- base::grepl
[10:22:51.495]                           restarts <- computeRestarts(cond)
[10:22:51.495]                           for (restart in restarts) {
[10:22:51.495]                             name <- restart$name
[10:22:51.495]                             if (is.null(name)) 
[10:22:51.495]                               next
[10:22:51.495]                             if (!grepl(pattern, name)) 
[10:22:51.495]                               next
[10:22:51.495]                             invokeRestart(restart)
[10:22:51.495]                             muffled <- TRUE
[10:22:51.495]                             break
[10:22:51.495]                           }
[10:22:51.495]                         }
[10:22:51.495]                       }
[10:22:51.495]                       invisible(muffled)
[10:22:51.495]                     }
[10:22:51.495]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.495]                   }
[10:22:51.495]                 }
[10:22:51.495]                 else {
[10:22:51.495]                   if (TRUE) {
[10:22:51.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.495]                     {
[10:22:51.495]                       inherits <- base::inherits
[10:22:51.495]                       invokeRestart <- base::invokeRestart
[10:22:51.495]                       is.null <- base::is.null
[10:22:51.495]                       muffled <- FALSE
[10:22:51.495]                       if (inherits(cond, "message")) {
[10:22:51.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.495]                         if (muffled) 
[10:22:51.495]                           invokeRestart("muffleMessage")
[10:22:51.495]                       }
[10:22:51.495]                       else if (inherits(cond, "warning")) {
[10:22:51.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.495]                         if (muffled) 
[10:22:51.495]                           invokeRestart("muffleWarning")
[10:22:51.495]                       }
[10:22:51.495]                       else if (inherits(cond, "condition")) {
[10:22:51.495]                         if (!is.null(pattern)) {
[10:22:51.495]                           computeRestarts <- base::computeRestarts
[10:22:51.495]                           grepl <- base::grepl
[10:22:51.495]                           restarts <- computeRestarts(cond)
[10:22:51.495]                           for (restart in restarts) {
[10:22:51.495]                             name <- restart$name
[10:22:51.495]                             if (is.null(name)) 
[10:22:51.495]                               next
[10:22:51.495]                             if (!grepl(pattern, name)) 
[10:22:51.495]                               next
[10:22:51.495]                             invokeRestart(restart)
[10:22:51.495]                             muffled <- TRUE
[10:22:51.495]                             break
[10:22:51.495]                           }
[10:22:51.495]                         }
[10:22:51.495]                       }
[10:22:51.495]                       invisible(muffled)
[10:22:51.495]                     }
[10:22:51.495]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.495]                   }
[10:22:51.495]                 }
[10:22:51.495]             }
[10:22:51.495]         }))
[10:22:51.495]     }, error = function(ex) {
[10:22:51.495]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.495]                 ...future.rng), started = ...future.startTime, 
[10:22:51.495]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.495]             version = "1.8"), class = "FutureResult")
[10:22:51.495]     }, finally = {
[10:22:51.495]         if (!identical(...future.workdir, getwd())) 
[10:22:51.495]             setwd(...future.workdir)
[10:22:51.495]         {
[10:22:51.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.495]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.495]             }
[10:22:51.495]             base::options(...future.oldOptions)
[10:22:51.495]             if (.Platform$OS.type == "windows") {
[10:22:51.495]                 old_names <- names(...future.oldEnvVars)
[10:22:51.495]                 envs <- base::Sys.getenv()
[10:22:51.495]                 names <- names(envs)
[10:22:51.495]                 common <- intersect(names, old_names)
[10:22:51.495]                 added <- setdiff(names, old_names)
[10:22:51.495]                 removed <- setdiff(old_names, names)
[10:22:51.495]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.495]                   envs[common]]
[10:22:51.495]                 NAMES <- toupper(changed)
[10:22:51.495]                 args <- list()
[10:22:51.495]                 for (kk in seq_along(NAMES)) {
[10:22:51.495]                   name <- changed[[kk]]
[10:22:51.495]                   NAME <- NAMES[[kk]]
[10:22:51.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.495]                     next
[10:22:51.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.495]                 }
[10:22:51.495]                 NAMES <- toupper(added)
[10:22:51.495]                 for (kk in seq_along(NAMES)) {
[10:22:51.495]                   name <- added[[kk]]
[10:22:51.495]                   NAME <- NAMES[[kk]]
[10:22:51.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.495]                     next
[10:22:51.495]                   args[[name]] <- ""
[10:22:51.495]                 }
[10:22:51.495]                 NAMES <- toupper(removed)
[10:22:51.495]                 for (kk in seq_along(NAMES)) {
[10:22:51.495]                   name <- removed[[kk]]
[10:22:51.495]                   NAME <- NAMES[[kk]]
[10:22:51.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.495]                     next
[10:22:51.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.495]                 }
[10:22:51.495]                 if (length(args) > 0) 
[10:22:51.495]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.495]             }
[10:22:51.495]             else {
[10:22:51.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.495]             }
[10:22:51.495]             {
[10:22:51.495]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.495]                   0L) {
[10:22:51.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.495]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.495]                   base::options(opts)
[10:22:51.495]                 }
[10:22:51.495]                 {
[10:22:51.495]                   {
[10:22:51.495]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.495]                     NULL
[10:22:51.495]                   }
[10:22:51.495]                   options(future.plan = NULL)
[10:22:51.495]                   if (is.na(NA_character_)) 
[10:22:51.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.495]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.495]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.495]                     envir = parent.frame()) 
[10:22:51.495]                   {
[10:22:51.495]                     if (is.function(workers)) 
[10:22:51.495]                       workers <- workers()
[10:22:51.495]                     workers <- structure(as.integer(workers), 
[10:22:51.495]                       class = class(workers))
[10:22:51.495]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.495]                       workers >= 1)
[10:22:51.495]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.495]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.495]                     }
[10:22:51.495]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.495]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.495]                       envir = envir)
[10:22:51.495]                     if (!future$lazy) 
[10:22:51.495]                       future <- run(future)
[10:22:51.495]                     invisible(future)
[10:22:51.495]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.495]                 }
[10:22:51.495]             }
[10:22:51.495]         }
[10:22:51.495]     })
[10:22:51.495]     if (TRUE) {
[10:22:51.495]         base::sink(type = "output", split = FALSE)
[10:22:51.495]         if (TRUE) {
[10:22:51.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.495]         }
[10:22:51.495]         else {
[10:22:51.495]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.495]         }
[10:22:51.495]         base::close(...future.stdout)
[10:22:51.495]         ...future.stdout <- NULL
[10:22:51.495]     }
[10:22:51.495]     ...future.result$conditions <- ...future.conditions
[10:22:51.495]     ...future.result$finished <- base::Sys.time()
[10:22:51.495]     ...future.result
[10:22:51.495] }
[10:22:51.498] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:22:51.498] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:22:51.499] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:22:51.499] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[10:22:51.499] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[10:22:51.499] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[10:22:51.500] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[10:22:51.500] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:51.500] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.500] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:22:51.501] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.501] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:22:51.501] MultisessionFuture started
[10:22:51.502] - Launch lazy future ... done
[10:22:51.502] run() for ‘MultisessionFuture’ ... done
[10:22:51.502] Created future:
[10:22:51.502] MultisessionFuture:
[10:22:51.502] Label: ‘future_by-2’
[10:22:51.502] Expression:
[10:22:51.502] {
[10:22:51.502]     do.call(function(...) {
[10:22:51.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.502]             on.exit(options(oopts), add = TRUE)
[10:22:51.502]         }
[10:22:51.502]         {
[10:22:51.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.502]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.502]             })
[10:22:51.502]         }
[10:22:51.502]     }, args = future.call.arguments)
[10:22:51.502] }
[10:22:51.502] Lazy evaluation: FALSE
[10:22:51.502] Asynchronous evaluation: TRUE
[10:22:51.502] Local evaluation: TRUE
[10:22:51.502] Environment: R_GlobalEnv
[10:22:51.502] Capture standard output: TRUE
[10:22:51.502] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.502] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.502] Packages: <none>
[10:22:51.502] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.502] Resolved: FALSE
[10:22:51.502] Value: <not collected>
[10:22:51.502] Conditions captured: <none>
[10:22:51.502] Early signaling: FALSE
[10:22:51.502] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.502] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.513] Chunk #2 of 2 ... DONE
[10:22:51.514] Launching 2 futures (chunks) ... DONE
[10:22:51.514] Resolving 2 futures (chunks) ...
[10:22:51.514] resolve() on list ...
[10:22:51.514]  recursive: 0
[10:22:51.514]  length: 2
[10:22:51.514] 
[10:22:51.515] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.515] - Validating connection of MultisessionFuture
[10:22:51.515] - received message: FutureResult
[10:22:51.515] - Received FutureResult
[10:22:51.515] - Erased future from FutureRegistry
[10:22:51.515] result() for ClusterFuture ...
[10:22:51.515] - result already collected: FutureResult
[10:22:51.515] result() for ClusterFuture ... done
[10:22:51.515] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.516] Future #1
[10:22:51.516] result() for ClusterFuture ...
[10:22:51.516] - result already collected: FutureResult
[10:22:51.516] result() for ClusterFuture ... done
[10:22:51.516] result() for ClusterFuture ...
[10:22:51.516] - result already collected: FutureResult
[10:22:51.516] result() for ClusterFuture ... done
[10:22:51.516] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:51.516] - nx: 2
[10:22:51.516] - relay: TRUE
[10:22:51.516] - stdout: TRUE
[10:22:51.517] - signal: TRUE
[10:22:51.517] - resignal: FALSE
[10:22:51.517] - force: TRUE
[10:22:51.517] - relayed: [n=2] FALSE, FALSE
[10:22:51.517] - queued futures: [n=2] FALSE, FALSE
[10:22:51.517]  - until=1
[10:22:51.517]  - relaying element #1
[10:22:51.517] result() for ClusterFuture ...
[10:22:51.517] - result already collected: FutureResult
[10:22:51.517] result() for ClusterFuture ... done
[10:22:51.517] result() for ClusterFuture ...
[10:22:51.517] - result already collected: FutureResult
[10:22:51.518] result() for ClusterFuture ... done
[10:22:51.518] result() for ClusterFuture ...
[10:22:51.518] - result already collected: FutureResult
[10:22:51.518] result() for ClusterFuture ... done
[10:22:51.518] result() for ClusterFuture ...
[10:22:51.518] - result already collected: FutureResult
[10:22:51.518] result() for ClusterFuture ... done
[10:22:51.518] - relayed: [n=2] TRUE, FALSE
[10:22:51.518] - queued futures: [n=2] TRUE, FALSE
[10:22:51.518] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:51.518]  length: 1 (resolved future 1)
[10:22:51.547] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.547] - Validating connection of MultisessionFuture
[10:22:51.547] - received message: FutureResult
[10:22:51.547] - Received FutureResult
[10:22:51.547] - Erased future from FutureRegistry
[10:22:51.548] result() for ClusterFuture ...
[10:22:51.548] - result already collected: FutureResult
[10:22:51.548] result() for ClusterFuture ... done
[10:22:51.548] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.548] Future #2
[10:22:51.548] result() for ClusterFuture ...
[10:22:51.548] - result already collected: FutureResult
[10:22:51.548] result() for ClusterFuture ... done
[10:22:51.548] result() for ClusterFuture ...
[10:22:51.548] - result already collected: FutureResult
[10:22:51.548] result() for ClusterFuture ... done
[10:22:51.549] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:51.549] - nx: 2
[10:22:51.549] - relay: TRUE
[10:22:51.549] - stdout: TRUE
[10:22:51.549] - signal: TRUE
[10:22:51.549] - resignal: FALSE
[10:22:51.549] - force: TRUE
[10:22:51.549] - relayed: [n=2] TRUE, FALSE
[10:22:51.549] - queued futures: [n=2] TRUE, FALSE
[10:22:51.549]  - until=2
[10:22:51.549]  - relaying element #2
[10:22:51.550] result() for ClusterFuture ...
[10:22:51.550] - result already collected: FutureResult
[10:22:51.550] result() for ClusterFuture ... done
[10:22:51.550] result() for ClusterFuture ...
[10:22:51.550] - result already collected: FutureResult
[10:22:51.550] result() for ClusterFuture ... done
[10:22:51.550] result() for ClusterFuture ...
[10:22:51.550] - result already collected: FutureResult
[10:22:51.550] result() for ClusterFuture ... done
[10:22:51.550] result() for ClusterFuture ...
[10:22:51.550] - result already collected: FutureResult
[10:22:51.551] result() for ClusterFuture ... done
[10:22:51.551] - relayed: [n=2] TRUE, TRUE
[10:22:51.551] - queued futures: [n=2] TRUE, TRUE
[10:22:51.551] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:51.551]  length: 0 (resolved future 2)
[10:22:51.551] Relaying remaining futures
[10:22:51.551] signalConditionsASAP(NULL, pos=0) ...
[10:22:51.551] - nx: 2
[10:22:51.551] - relay: TRUE
[10:22:51.551] - stdout: TRUE
[10:22:51.551] - signal: TRUE
[10:22:51.551] - resignal: FALSE
[10:22:51.552] - force: TRUE
[10:22:51.552] - relayed: [n=2] TRUE, TRUE
[10:22:51.552] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:51.552] - relayed: [n=2] TRUE, TRUE
[10:22:51.552] - queued futures: [n=2] TRUE, TRUE
[10:22:51.552] signalConditionsASAP(NULL, pos=0) ... done
[10:22:51.552] resolve() on list ... DONE
[10:22:51.552] result() for ClusterFuture ...
[10:22:51.552] - result already collected: FutureResult
[10:22:51.552] result() for ClusterFuture ... done
[10:22:51.552] result() for ClusterFuture ...
[10:22:51.553] - result already collected: FutureResult
[10:22:51.553] result() for ClusterFuture ... done
[10:22:51.553] result() for ClusterFuture ...
[10:22:51.553] - result already collected: FutureResult
[10:22:51.553] result() for ClusterFuture ... done
[10:22:51.553] result() for ClusterFuture ...
[10:22:51.553] - result already collected: FutureResult
[10:22:51.553] result() for ClusterFuture ... done
[10:22:51.553]  - Number of value chunks collected: 2
[10:22:51.553] Resolving 2 futures (chunks) ... DONE
[10:22:51.554] Reducing values from 2 chunks ...
[10:22:51.554]  - Number of values collected after concatenation: 6
[10:22:51.554]  - Number of values expected: 6
[10:22:51.554] Reducing values from 2 chunks ... DONE
[10:22:51.554] future_lapply() ... DONE
[10:22:51.554] future_by_internal() ... DONE
[10:22:51.555] future_by_internal() ...
[10:22:51.556] future_lapply() ...
[10:22:51.560] Number of chunks: 2
[10:22:51.560] getGlobalsAndPackagesXApply() ...
[10:22:51.560]  - future.globals: TRUE
[10:22:51.560] getGlobalsAndPackages() ...
[10:22:51.560] Searching for globals...
[10:22:51.562] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:51.562] Searching for globals ... DONE
[10:22:51.562] Resolving globals: FALSE
[10:22:51.563] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:22:51.563] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:22:51.563] - globals: [1] ‘FUN’
[10:22:51.563] - packages: [1] ‘stats’
[10:22:51.563] getGlobalsAndPackages() ... DONE
[10:22:51.564]  - globals found/used: [n=1] ‘FUN’
[10:22:51.564]  - needed namespaces: [n=1] ‘stats’
[10:22:51.564] Finding globals ... DONE
[10:22:51.564]  - use_args: TRUE
[10:22:51.564]  - Getting '...' globals ...
[10:22:51.564] resolve() on list ...
[10:22:51.564]  recursive: 0
[10:22:51.564]  length: 1
[10:22:51.564]  elements: ‘...’
[10:22:51.565]  length: 0 (resolved future 1)
[10:22:51.565] resolve() on list ... DONE
[10:22:51.565]    - '...' content: [n=1] ‘singular.ok’
[10:22:51.565] List of 1
[10:22:51.565]  $ ...:List of 1
[10:22:51.565]   ..$ singular.ok: logi FALSE
[10:22:51.565]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.565]  - attr(*, "where")=List of 1
[10:22:51.565]   ..$ ...:<environment: 0x55f639d27330> 
[10:22:51.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.565]  - attr(*, "resolved")= logi TRUE
[10:22:51.565]  - attr(*, "total_size")= num NA
[10:22:51.570]  - Getting '...' globals ... DONE
[10:22:51.570] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:51.570] List of 2
[10:22:51.570]  $ ...future.FUN:function (x, ...)  
[10:22:51.570]  $ ...          :List of 1
[10:22:51.570]   ..$ singular.ok: logi FALSE
[10:22:51.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.570]  - attr(*, "where")=List of 2
[10:22:51.570]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:51.570]   ..$ ...          :<environment: 0x55f639d27330> 
[10:22:51.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.570]  - attr(*, "resolved")= logi FALSE
[10:22:51.570]  - attr(*, "total_size")= num 5384
[10:22:51.573] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:51.573] getGlobalsAndPackagesXApply() ... DONE
[10:22:51.574] Number of futures (= number of chunks): 2
[10:22:51.574] Launching 2 futures (chunks) ...
[10:22:51.574] Chunk #1 of 2 ...
[10:22:51.574]  - Finding globals in 'X' for chunk #1 ...
[10:22:51.574] getGlobalsAndPackages() ...
[10:22:51.574] Searching for globals...
[10:22:51.574] 
[10:22:51.575] Searching for globals ... DONE
[10:22:51.575] - globals: [0] <none>
[10:22:51.575] getGlobalsAndPackages() ... DONE
[10:22:51.575]    + additional globals found: [n=0] 
[10:22:51.575]    + additional namespaces needed: [n=0] 
[10:22:51.575]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:51.575]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.575]  - seeds: <none>
[10:22:51.575]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.575] getGlobalsAndPackages() ...
[10:22:51.575] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.576] Resolving globals: FALSE
[10:22:51.576] Tweak future expression to call with '...' arguments ...
[10:22:51.576] {
[10:22:51.576]     do.call(function(...) {
[10:22:51.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.576]             on.exit(options(oopts), add = TRUE)
[10:22:51.576]         }
[10:22:51.576]         {
[10:22:51.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.576]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.576]             })
[10:22:51.576]         }
[10:22:51.576]     }, args = future.call.arguments)
[10:22:51.576] }
[10:22:51.576] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.576] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.576] 
[10:22:51.577] getGlobalsAndPackages() ... DONE
[10:22:51.577] run() for ‘Future’ ...
[10:22:51.577] - state: ‘created’
[10:22:51.577] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.590] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.591]   - Field: ‘node’
[10:22:51.591]   - Field: ‘label’
[10:22:51.591]   - Field: ‘local’
[10:22:51.591]   - Field: ‘owner’
[10:22:51.591]   - Field: ‘envir’
[10:22:51.591]   - Field: ‘workers’
[10:22:51.591]   - Field: ‘packages’
[10:22:51.591]   - Field: ‘gc’
[10:22:51.591]   - Field: ‘conditions’
[10:22:51.591]   - Field: ‘persistent’
[10:22:51.592]   - Field: ‘expr’
[10:22:51.592]   - Field: ‘uuid’
[10:22:51.592]   - Field: ‘seed’
[10:22:51.592]   - Field: ‘version’
[10:22:51.592]   - Field: ‘result’
[10:22:51.592]   - Field: ‘asynchronous’
[10:22:51.592]   - Field: ‘calls’
[10:22:51.592]   - Field: ‘globals’
[10:22:51.592]   - Field: ‘stdout’
[10:22:51.592]   - Field: ‘earlySignal’
[10:22:51.592]   - Field: ‘lazy’
[10:22:51.593]   - Field: ‘state’
[10:22:51.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.593] - Launch lazy future ...
[10:22:51.593] Packages needed by the future expression (n = 1): ‘stats’
[10:22:51.593] Packages needed by future strategies (n = 0): <none>
[10:22:51.594] {
[10:22:51.594]     {
[10:22:51.594]         {
[10:22:51.594]             ...future.startTime <- base::Sys.time()
[10:22:51.594]             {
[10:22:51.594]                 {
[10:22:51.594]                   {
[10:22:51.594]                     {
[10:22:51.594]                       {
[10:22:51.594]                         base::local({
[10:22:51.594]                           has_future <- base::requireNamespace("future", 
[10:22:51.594]                             quietly = TRUE)
[10:22:51.594]                           if (has_future) {
[10:22:51.594]                             ns <- base::getNamespace("future")
[10:22:51.594]                             version <- ns[[".package"]][["version"]]
[10:22:51.594]                             if (is.null(version)) 
[10:22:51.594]                               version <- utils::packageVersion("future")
[10:22:51.594]                           }
[10:22:51.594]                           else {
[10:22:51.594]                             version <- NULL
[10:22:51.594]                           }
[10:22:51.594]                           if (!has_future || version < "1.8.0") {
[10:22:51.594]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.594]                               "", base::R.version$version.string), 
[10:22:51.594]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:51.594]                                 base::R.version$platform, 8 * 
[10:22:51.594]                                   base::.Machine$sizeof.pointer), 
[10:22:51.594]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.594]                                 "release", "version")], collapse = " "), 
[10:22:51.594]                               hostname = base::Sys.info()[["nodename"]])
[10:22:51.594]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.594]                               info)
[10:22:51.594]                             info <- base::paste(info, collapse = "; ")
[10:22:51.594]                             if (!has_future) {
[10:22:51.594]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.594]                                 info)
[10:22:51.594]                             }
[10:22:51.594]                             else {
[10:22:51.594]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.594]                                 info, version)
[10:22:51.594]                             }
[10:22:51.594]                             base::stop(msg)
[10:22:51.594]                           }
[10:22:51.594]                         })
[10:22:51.594]                       }
[10:22:51.594]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.594]                       base::options(mc.cores = 1L)
[10:22:51.594]                     }
[10:22:51.594]                     base::local({
[10:22:51.594]                       for (pkg in "stats") {
[10:22:51.594]                         base::loadNamespace(pkg)
[10:22:51.594]                         base::library(pkg, character.only = TRUE)
[10:22:51.594]                       }
[10:22:51.594]                     })
[10:22:51.594]                   }
[10:22:51.594]                   options(future.plan = NULL)
[10:22:51.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.594]                 }
[10:22:51.594]                 ...future.workdir <- getwd()
[10:22:51.594]             }
[10:22:51.594]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.594]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.594]         }
[10:22:51.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.594]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.594]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.594]             base::names(...future.oldOptions))
[10:22:51.594]     }
[10:22:51.594]     if (FALSE) {
[10:22:51.594]     }
[10:22:51.594]     else {
[10:22:51.594]         if (TRUE) {
[10:22:51.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.594]                 open = "w")
[10:22:51.594]         }
[10:22:51.594]         else {
[10:22:51.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.594]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.594]         }
[10:22:51.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.594]             base::sink(type = "output", split = FALSE)
[10:22:51.594]             base::close(...future.stdout)
[10:22:51.594]         }, add = TRUE)
[10:22:51.594]     }
[10:22:51.594]     ...future.frame <- base::sys.nframe()
[10:22:51.594]     ...future.conditions <- base::list()
[10:22:51.594]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.594]     if (FALSE) {
[10:22:51.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.594]     }
[10:22:51.594]     ...future.result <- base::tryCatch({
[10:22:51.594]         base::withCallingHandlers({
[10:22:51.594]             ...future.value <- base::withVisible(base::local({
[10:22:51.594]                 ...future.makeSendCondition <- base::local({
[10:22:51.594]                   sendCondition <- NULL
[10:22:51.594]                   function(frame = 1L) {
[10:22:51.594]                     if (is.function(sendCondition)) 
[10:22:51.594]                       return(sendCondition)
[10:22:51.594]                     ns <- getNamespace("parallel")
[10:22:51.594]                     if (exists("sendData", mode = "function", 
[10:22:51.594]                       envir = ns)) {
[10:22:51.594]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.594]                         envir = ns)
[10:22:51.594]                       envir <- sys.frame(frame)
[10:22:51.594]                       master <- NULL
[10:22:51.594]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.594]                         !identical(envir, emptyenv())) {
[10:22:51.594]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.594]                           inherits = FALSE)) {
[10:22:51.594]                           master <- get("master", mode = "list", 
[10:22:51.594]                             envir = envir, inherits = FALSE)
[10:22:51.594]                           if (inherits(master, c("SOCKnode", 
[10:22:51.594]                             "SOCK0node"))) {
[10:22:51.594]                             sendCondition <<- function(cond) {
[10:22:51.594]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.594]                                 success = TRUE)
[10:22:51.594]                               parallel_sendData(master, data)
[10:22:51.594]                             }
[10:22:51.594]                             return(sendCondition)
[10:22:51.594]                           }
[10:22:51.594]                         }
[10:22:51.594]                         frame <- frame + 1L
[10:22:51.594]                         envir <- sys.frame(frame)
[10:22:51.594]                       }
[10:22:51.594]                     }
[10:22:51.594]                     sendCondition <<- function(cond) NULL
[10:22:51.594]                   }
[10:22:51.594]                 })
[10:22:51.594]                 withCallingHandlers({
[10:22:51.594]                   {
[10:22:51.594]                     do.call(function(...) {
[10:22:51.594]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.594]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.594]                         ...future.globals.maxSize)) {
[10:22:51.594]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.594]                         on.exit(options(oopts), add = TRUE)
[10:22:51.594]                       }
[10:22:51.594]                       {
[10:22:51.594]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.594]                           FUN = function(jj) {
[10:22:51.594]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.594]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.594]                           })
[10:22:51.594]                       }
[10:22:51.594]                     }, args = future.call.arguments)
[10:22:51.594]                   }
[10:22:51.594]                 }, immediateCondition = function(cond) {
[10:22:51.594]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.594]                   sendCondition(cond)
[10:22:51.594]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.594]                   {
[10:22:51.594]                     inherits <- base::inherits
[10:22:51.594]                     invokeRestart <- base::invokeRestart
[10:22:51.594]                     is.null <- base::is.null
[10:22:51.594]                     muffled <- FALSE
[10:22:51.594]                     if (inherits(cond, "message")) {
[10:22:51.594]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.594]                       if (muffled) 
[10:22:51.594]                         invokeRestart("muffleMessage")
[10:22:51.594]                     }
[10:22:51.594]                     else if (inherits(cond, "warning")) {
[10:22:51.594]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.594]                       if (muffled) 
[10:22:51.594]                         invokeRestart("muffleWarning")
[10:22:51.594]                     }
[10:22:51.594]                     else if (inherits(cond, "condition")) {
[10:22:51.594]                       if (!is.null(pattern)) {
[10:22:51.594]                         computeRestarts <- base::computeRestarts
[10:22:51.594]                         grepl <- base::grepl
[10:22:51.594]                         restarts <- computeRestarts(cond)
[10:22:51.594]                         for (restart in restarts) {
[10:22:51.594]                           name <- restart$name
[10:22:51.594]                           if (is.null(name)) 
[10:22:51.594]                             next
[10:22:51.594]                           if (!grepl(pattern, name)) 
[10:22:51.594]                             next
[10:22:51.594]                           invokeRestart(restart)
[10:22:51.594]                           muffled <- TRUE
[10:22:51.594]                           break
[10:22:51.594]                         }
[10:22:51.594]                       }
[10:22:51.594]                     }
[10:22:51.594]                     invisible(muffled)
[10:22:51.594]                   }
[10:22:51.594]                   muffleCondition(cond)
[10:22:51.594]                 })
[10:22:51.594]             }))
[10:22:51.594]             future::FutureResult(value = ...future.value$value, 
[10:22:51.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.594]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.594]                     ...future.globalenv.names))
[10:22:51.594]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.594]         }, condition = base::local({
[10:22:51.594]             c <- base::c
[10:22:51.594]             inherits <- base::inherits
[10:22:51.594]             invokeRestart <- base::invokeRestart
[10:22:51.594]             length <- base::length
[10:22:51.594]             list <- base::list
[10:22:51.594]             seq.int <- base::seq.int
[10:22:51.594]             signalCondition <- base::signalCondition
[10:22:51.594]             sys.calls <- base::sys.calls
[10:22:51.594]             `[[` <- base::`[[`
[10:22:51.594]             `+` <- base::`+`
[10:22:51.594]             `<<-` <- base::`<<-`
[10:22:51.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.594]                   3L)]
[10:22:51.594]             }
[10:22:51.594]             function(cond) {
[10:22:51.594]                 is_error <- inherits(cond, "error")
[10:22:51.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.594]                   NULL)
[10:22:51.594]                 if (is_error) {
[10:22:51.594]                   sessionInformation <- function() {
[10:22:51.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.594]                       search = base::search(), system = base::Sys.info())
[10:22:51.594]                   }
[10:22:51.594]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.594]                     cond$call), session = sessionInformation(), 
[10:22:51.594]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.594]                   signalCondition(cond)
[10:22:51.594]                 }
[10:22:51.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.594]                 "immediateCondition"))) {
[10:22:51.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.594]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.594]                   if (TRUE && !signal) {
[10:22:51.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.594]                     {
[10:22:51.594]                       inherits <- base::inherits
[10:22:51.594]                       invokeRestart <- base::invokeRestart
[10:22:51.594]                       is.null <- base::is.null
[10:22:51.594]                       muffled <- FALSE
[10:22:51.594]                       if (inherits(cond, "message")) {
[10:22:51.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.594]                         if (muffled) 
[10:22:51.594]                           invokeRestart("muffleMessage")
[10:22:51.594]                       }
[10:22:51.594]                       else if (inherits(cond, "warning")) {
[10:22:51.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.594]                         if (muffled) 
[10:22:51.594]                           invokeRestart("muffleWarning")
[10:22:51.594]                       }
[10:22:51.594]                       else if (inherits(cond, "condition")) {
[10:22:51.594]                         if (!is.null(pattern)) {
[10:22:51.594]                           computeRestarts <- base::computeRestarts
[10:22:51.594]                           grepl <- base::grepl
[10:22:51.594]                           restarts <- computeRestarts(cond)
[10:22:51.594]                           for (restart in restarts) {
[10:22:51.594]                             name <- restart$name
[10:22:51.594]                             if (is.null(name)) 
[10:22:51.594]                               next
[10:22:51.594]                             if (!grepl(pattern, name)) 
[10:22:51.594]                               next
[10:22:51.594]                             invokeRestart(restart)
[10:22:51.594]                             muffled <- TRUE
[10:22:51.594]                             break
[10:22:51.594]                           }
[10:22:51.594]                         }
[10:22:51.594]                       }
[10:22:51.594]                       invisible(muffled)
[10:22:51.594]                     }
[10:22:51.594]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.594]                   }
[10:22:51.594]                 }
[10:22:51.594]                 else {
[10:22:51.594]                   if (TRUE) {
[10:22:51.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.594]                     {
[10:22:51.594]                       inherits <- base::inherits
[10:22:51.594]                       invokeRestart <- base::invokeRestart
[10:22:51.594]                       is.null <- base::is.null
[10:22:51.594]                       muffled <- FALSE
[10:22:51.594]                       if (inherits(cond, "message")) {
[10:22:51.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.594]                         if (muffled) 
[10:22:51.594]                           invokeRestart("muffleMessage")
[10:22:51.594]                       }
[10:22:51.594]                       else if (inherits(cond, "warning")) {
[10:22:51.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.594]                         if (muffled) 
[10:22:51.594]                           invokeRestart("muffleWarning")
[10:22:51.594]                       }
[10:22:51.594]                       else if (inherits(cond, "condition")) {
[10:22:51.594]                         if (!is.null(pattern)) {
[10:22:51.594]                           computeRestarts <- base::computeRestarts
[10:22:51.594]                           grepl <- base::grepl
[10:22:51.594]                           restarts <- computeRestarts(cond)
[10:22:51.594]                           for (restart in restarts) {
[10:22:51.594]                             name <- restart$name
[10:22:51.594]                             if (is.null(name)) 
[10:22:51.594]                               next
[10:22:51.594]                             if (!grepl(pattern, name)) 
[10:22:51.594]                               next
[10:22:51.594]                             invokeRestart(restart)
[10:22:51.594]                             muffled <- TRUE
[10:22:51.594]                             break
[10:22:51.594]                           }
[10:22:51.594]                         }
[10:22:51.594]                       }
[10:22:51.594]                       invisible(muffled)
[10:22:51.594]                     }
[10:22:51.594]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.594]                   }
[10:22:51.594]                 }
[10:22:51.594]             }
[10:22:51.594]         }))
[10:22:51.594]     }, error = function(ex) {
[10:22:51.594]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.594]                 ...future.rng), started = ...future.startTime, 
[10:22:51.594]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.594]             version = "1.8"), class = "FutureResult")
[10:22:51.594]     }, finally = {
[10:22:51.594]         if (!identical(...future.workdir, getwd())) 
[10:22:51.594]             setwd(...future.workdir)
[10:22:51.594]         {
[10:22:51.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.594]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.594]             }
[10:22:51.594]             base::options(...future.oldOptions)
[10:22:51.594]             if (.Platform$OS.type == "windows") {
[10:22:51.594]                 old_names <- names(...future.oldEnvVars)
[10:22:51.594]                 envs <- base::Sys.getenv()
[10:22:51.594]                 names <- names(envs)
[10:22:51.594]                 common <- intersect(names, old_names)
[10:22:51.594]                 added <- setdiff(names, old_names)
[10:22:51.594]                 removed <- setdiff(old_names, names)
[10:22:51.594]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.594]                   envs[common]]
[10:22:51.594]                 NAMES <- toupper(changed)
[10:22:51.594]                 args <- list()
[10:22:51.594]                 for (kk in seq_along(NAMES)) {
[10:22:51.594]                   name <- changed[[kk]]
[10:22:51.594]                   NAME <- NAMES[[kk]]
[10:22:51.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.594]                     next
[10:22:51.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.594]                 }
[10:22:51.594]                 NAMES <- toupper(added)
[10:22:51.594]                 for (kk in seq_along(NAMES)) {
[10:22:51.594]                   name <- added[[kk]]
[10:22:51.594]                   NAME <- NAMES[[kk]]
[10:22:51.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.594]                     next
[10:22:51.594]                   args[[name]] <- ""
[10:22:51.594]                 }
[10:22:51.594]                 NAMES <- toupper(removed)
[10:22:51.594]                 for (kk in seq_along(NAMES)) {
[10:22:51.594]                   name <- removed[[kk]]
[10:22:51.594]                   NAME <- NAMES[[kk]]
[10:22:51.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.594]                     next
[10:22:51.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.594]                 }
[10:22:51.594]                 if (length(args) > 0) 
[10:22:51.594]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.594]             }
[10:22:51.594]             else {
[10:22:51.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.594]             }
[10:22:51.594]             {
[10:22:51.594]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.594]                   0L) {
[10:22:51.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.594]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.594]                   base::options(opts)
[10:22:51.594]                 }
[10:22:51.594]                 {
[10:22:51.594]                   {
[10:22:51.594]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.594]                     NULL
[10:22:51.594]                   }
[10:22:51.594]                   options(future.plan = NULL)
[10:22:51.594]                   if (is.na(NA_character_)) 
[10:22:51.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.594]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.594]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.594]                     envir = parent.frame()) 
[10:22:51.594]                   {
[10:22:51.594]                     if (is.function(workers)) 
[10:22:51.594]                       workers <- workers()
[10:22:51.594]                     workers <- structure(as.integer(workers), 
[10:22:51.594]                       class = class(workers))
[10:22:51.594]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.594]                       workers >= 1)
[10:22:51.594]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.594]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.594]                     }
[10:22:51.594]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.594]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.594]                       envir = envir)
[10:22:51.594]                     if (!future$lazy) 
[10:22:51.594]                       future <- run(future)
[10:22:51.594]                     invisible(future)
[10:22:51.594]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.594]                 }
[10:22:51.594]             }
[10:22:51.594]         }
[10:22:51.594]     })
[10:22:51.594]     if (TRUE) {
[10:22:51.594]         base::sink(type = "output", split = FALSE)
[10:22:51.594]         if (TRUE) {
[10:22:51.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.594]         }
[10:22:51.594]         else {
[10:22:51.594]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.594]         }
[10:22:51.594]         base::close(...future.stdout)
[10:22:51.594]         ...future.stdout <- NULL
[10:22:51.594]     }
[10:22:51.594]     ...future.result$conditions <- ...future.conditions
[10:22:51.594]     ...future.result$finished <- base::Sys.time()
[10:22:51.594]     ...future.result
[10:22:51.594] }
[10:22:51.596] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[10:22:51.597] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[10:22:51.597] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[10:22:51.597] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[10:22:51.598] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[10:22:51.598] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:22:51.598] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:22:51.598] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:51.599] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:22:51.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.599] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[10:22:51.600] MultisessionFuture started
[10:22:51.600] - Launch lazy future ... done
[10:22:51.600] run() for ‘MultisessionFuture’ ... done
[10:22:51.600] Created future:
[10:22:51.600] MultisessionFuture:
[10:22:51.600] Label: ‘future_by-1’
[10:22:51.600] Expression:
[10:22:51.600] {
[10:22:51.600]     do.call(function(...) {
[10:22:51.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.600]             on.exit(options(oopts), add = TRUE)
[10:22:51.600]         }
[10:22:51.600]         {
[10:22:51.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.600]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.600]             })
[10:22:51.600]         }
[10:22:51.600]     }, args = future.call.arguments)
[10:22:51.600] }
[10:22:51.600] Lazy evaluation: FALSE
[10:22:51.600] Asynchronous evaluation: TRUE
[10:22:51.600] Local evaluation: TRUE
[10:22:51.600] Environment: R_GlobalEnv
[10:22:51.600] Capture standard output: TRUE
[10:22:51.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.600] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.600] Packages: 1 packages (‘stats’)
[10:22:51.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.600] Resolved: FALSE
[10:22:51.600] Value: <not collected>
[10:22:51.600] Conditions captured: <none>
[10:22:51.600] Early signaling: FALSE
[10:22:51.600] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.600] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.612] Chunk #1 of 2 ... DONE
[10:22:51.612] Chunk #2 of 2 ...
[10:22:51.612]  - Finding globals in 'X' for chunk #2 ...
[10:22:51.612] getGlobalsAndPackages() ...
[10:22:51.612] Searching for globals...
[10:22:51.613] 
[10:22:51.613] Searching for globals ... DONE
[10:22:51.613] - globals: [0] <none>
[10:22:51.613] getGlobalsAndPackages() ... DONE
[10:22:51.613]    + additional globals found: [n=0] 
[10:22:51.613]    + additional namespaces needed: [n=0] 
[10:22:51.613]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:51.613]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.614]  - seeds: <none>
[10:22:51.614]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.614] getGlobalsAndPackages() ...
[10:22:51.614] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.614] Resolving globals: FALSE
[10:22:51.614] Tweak future expression to call with '...' arguments ...
[10:22:51.614] {
[10:22:51.614]     do.call(function(...) {
[10:22:51.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.614]             on.exit(options(oopts), add = TRUE)
[10:22:51.614]         }
[10:22:51.614]         {
[10:22:51.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.614]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.614]             })
[10:22:51.614]         }
[10:22:51.614]     }, args = future.call.arguments)
[10:22:51.614] }
[10:22:51.614] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.615] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.615] 
[10:22:51.615] getGlobalsAndPackages() ... DONE
[10:22:51.615] run() for ‘Future’ ...
[10:22:51.615] - state: ‘created’
[10:22:51.615] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.628] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.629]   - Field: ‘node’
[10:22:51.629]   - Field: ‘label’
[10:22:51.629]   - Field: ‘local’
[10:22:51.629]   - Field: ‘owner’
[10:22:51.629]   - Field: ‘envir’
[10:22:51.629]   - Field: ‘workers’
[10:22:51.629]   - Field: ‘packages’
[10:22:51.629]   - Field: ‘gc’
[10:22:51.629]   - Field: ‘conditions’
[10:22:51.629]   - Field: ‘persistent’
[10:22:51.630]   - Field: ‘expr’
[10:22:51.630]   - Field: ‘uuid’
[10:22:51.630]   - Field: ‘seed’
[10:22:51.630]   - Field: ‘version’
[10:22:51.630]   - Field: ‘result’
[10:22:51.630]   - Field: ‘asynchronous’
[10:22:51.630]   - Field: ‘calls’
[10:22:51.630]   - Field: ‘globals’
[10:22:51.630]   - Field: ‘stdout’
[10:22:51.630]   - Field: ‘earlySignal’
[10:22:51.630]   - Field: ‘lazy’
[10:22:51.631]   - Field: ‘state’
[10:22:51.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.631] - Launch lazy future ...
[10:22:51.631] Packages needed by the future expression (n = 1): ‘stats’
[10:22:51.631] Packages needed by future strategies (n = 0): <none>
[10:22:51.632] {
[10:22:51.632]     {
[10:22:51.632]         {
[10:22:51.632]             ...future.startTime <- base::Sys.time()
[10:22:51.632]             {
[10:22:51.632]                 {
[10:22:51.632]                   {
[10:22:51.632]                     {
[10:22:51.632]                       {
[10:22:51.632]                         base::local({
[10:22:51.632]                           has_future <- base::requireNamespace("future", 
[10:22:51.632]                             quietly = TRUE)
[10:22:51.632]                           if (has_future) {
[10:22:51.632]                             ns <- base::getNamespace("future")
[10:22:51.632]                             version <- ns[[".package"]][["version"]]
[10:22:51.632]                             if (is.null(version)) 
[10:22:51.632]                               version <- utils::packageVersion("future")
[10:22:51.632]                           }
[10:22:51.632]                           else {
[10:22:51.632]                             version <- NULL
[10:22:51.632]                           }
[10:22:51.632]                           if (!has_future || version < "1.8.0") {
[10:22:51.632]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.632]                               "", base::R.version$version.string), 
[10:22:51.632]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:51.632]                                 base::R.version$platform, 8 * 
[10:22:51.632]                                   base::.Machine$sizeof.pointer), 
[10:22:51.632]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.632]                                 "release", "version")], collapse = " "), 
[10:22:51.632]                               hostname = base::Sys.info()[["nodename"]])
[10:22:51.632]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.632]                               info)
[10:22:51.632]                             info <- base::paste(info, collapse = "; ")
[10:22:51.632]                             if (!has_future) {
[10:22:51.632]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.632]                                 info)
[10:22:51.632]                             }
[10:22:51.632]                             else {
[10:22:51.632]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.632]                                 info, version)
[10:22:51.632]                             }
[10:22:51.632]                             base::stop(msg)
[10:22:51.632]                           }
[10:22:51.632]                         })
[10:22:51.632]                       }
[10:22:51.632]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.632]                       base::options(mc.cores = 1L)
[10:22:51.632]                     }
[10:22:51.632]                     base::local({
[10:22:51.632]                       for (pkg in "stats") {
[10:22:51.632]                         base::loadNamespace(pkg)
[10:22:51.632]                         base::library(pkg, character.only = TRUE)
[10:22:51.632]                       }
[10:22:51.632]                     })
[10:22:51.632]                   }
[10:22:51.632]                   options(future.plan = NULL)
[10:22:51.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.632]                 }
[10:22:51.632]                 ...future.workdir <- getwd()
[10:22:51.632]             }
[10:22:51.632]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.632]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.632]         }
[10:22:51.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.632]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.632]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.632]             base::names(...future.oldOptions))
[10:22:51.632]     }
[10:22:51.632]     if (FALSE) {
[10:22:51.632]     }
[10:22:51.632]     else {
[10:22:51.632]         if (TRUE) {
[10:22:51.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.632]                 open = "w")
[10:22:51.632]         }
[10:22:51.632]         else {
[10:22:51.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.632]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.632]         }
[10:22:51.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.632]             base::sink(type = "output", split = FALSE)
[10:22:51.632]             base::close(...future.stdout)
[10:22:51.632]         }, add = TRUE)
[10:22:51.632]     }
[10:22:51.632]     ...future.frame <- base::sys.nframe()
[10:22:51.632]     ...future.conditions <- base::list()
[10:22:51.632]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.632]     if (FALSE) {
[10:22:51.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.632]     }
[10:22:51.632]     ...future.result <- base::tryCatch({
[10:22:51.632]         base::withCallingHandlers({
[10:22:51.632]             ...future.value <- base::withVisible(base::local({
[10:22:51.632]                 ...future.makeSendCondition <- base::local({
[10:22:51.632]                   sendCondition <- NULL
[10:22:51.632]                   function(frame = 1L) {
[10:22:51.632]                     if (is.function(sendCondition)) 
[10:22:51.632]                       return(sendCondition)
[10:22:51.632]                     ns <- getNamespace("parallel")
[10:22:51.632]                     if (exists("sendData", mode = "function", 
[10:22:51.632]                       envir = ns)) {
[10:22:51.632]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.632]                         envir = ns)
[10:22:51.632]                       envir <- sys.frame(frame)
[10:22:51.632]                       master <- NULL
[10:22:51.632]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.632]                         !identical(envir, emptyenv())) {
[10:22:51.632]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.632]                           inherits = FALSE)) {
[10:22:51.632]                           master <- get("master", mode = "list", 
[10:22:51.632]                             envir = envir, inherits = FALSE)
[10:22:51.632]                           if (inherits(master, c("SOCKnode", 
[10:22:51.632]                             "SOCK0node"))) {
[10:22:51.632]                             sendCondition <<- function(cond) {
[10:22:51.632]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.632]                                 success = TRUE)
[10:22:51.632]                               parallel_sendData(master, data)
[10:22:51.632]                             }
[10:22:51.632]                             return(sendCondition)
[10:22:51.632]                           }
[10:22:51.632]                         }
[10:22:51.632]                         frame <- frame + 1L
[10:22:51.632]                         envir <- sys.frame(frame)
[10:22:51.632]                       }
[10:22:51.632]                     }
[10:22:51.632]                     sendCondition <<- function(cond) NULL
[10:22:51.632]                   }
[10:22:51.632]                 })
[10:22:51.632]                 withCallingHandlers({
[10:22:51.632]                   {
[10:22:51.632]                     do.call(function(...) {
[10:22:51.632]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.632]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.632]                         ...future.globals.maxSize)) {
[10:22:51.632]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.632]                         on.exit(options(oopts), add = TRUE)
[10:22:51.632]                       }
[10:22:51.632]                       {
[10:22:51.632]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.632]                           FUN = function(jj) {
[10:22:51.632]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.632]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.632]                           })
[10:22:51.632]                       }
[10:22:51.632]                     }, args = future.call.arguments)
[10:22:51.632]                   }
[10:22:51.632]                 }, immediateCondition = function(cond) {
[10:22:51.632]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.632]                   sendCondition(cond)
[10:22:51.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.632]                   {
[10:22:51.632]                     inherits <- base::inherits
[10:22:51.632]                     invokeRestart <- base::invokeRestart
[10:22:51.632]                     is.null <- base::is.null
[10:22:51.632]                     muffled <- FALSE
[10:22:51.632]                     if (inherits(cond, "message")) {
[10:22:51.632]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.632]                       if (muffled) 
[10:22:51.632]                         invokeRestart("muffleMessage")
[10:22:51.632]                     }
[10:22:51.632]                     else if (inherits(cond, "warning")) {
[10:22:51.632]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.632]                       if (muffled) 
[10:22:51.632]                         invokeRestart("muffleWarning")
[10:22:51.632]                     }
[10:22:51.632]                     else if (inherits(cond, "condition")) {
[10:22:51.632]                       if (!is.null(pattern)) {
[10:22:51.632]                         computeRestarts <- base::computeRestarts
[10:22:51.632]                         grepl <- base::grepl
[10:22:51.632]                         restarts <- computeRestarts(cond)
[10:22:51.632]                         for (restart in restarts) {
[10:22:51.632]                           name <- restart$name
[10:22:51.632]                           if (is.null(name)) 
[10:22:51.632]                             next
[10:22:51.632]                           if (!grepl(pattern, name)) 
[10:22:51.632]                             next
[10:22:51.632]                           invokeRestart(restart)
[10:22:51.632]                           muffled <- TRUE
[10:22:51.632]                           break
[10:22:51.632]                         }
[10:22:51.632]                       }
[10:22:51.632]                     }
[10:22:51.632]                     invisible(muffled)
[10:22:51.632]                   }
[10:22:51.632]                   muffleCondition(cond)
[10:22:51.632]                 })
[10:22:51.632]             }))
[10:22:51.632]             future::FutureResult(value = ...future.value$value, 
[10:22:51.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.632]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.632]                     ...future.globalenv.names))
[10:22:51.632]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.632]         }, condition = base::local({
[10:22:51.632]             c <- base::c
[10:22:51.632]             inherits <- base::inherits
[10:22:51.632]             invokeRestart <- base::invokeRestart
[10:22:51.632]             length <- base::length
[10:22:51.632]             list <- base::list
[10:22:51.632]             seq.int <- base::seq.int
[10:22:51.632]             signalCondition <- base::signalCondition
[10:22:51.632]             sys.calls <- base::sys.calls
[10:22:51.632]             `[[` <- base::`[[`
[10:22:51.632]             `+` <- base::`+`
[10:22:51.632]             `<<-` <- base::`<<-`
[10:22:51.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.632]                   3L)]
[10:22:51.632]             }
[10:22:51.632]             function(cond) {
[10:22:51.632]                 is_error <- inherits(cond, "error")
[10:22:51.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.632]                   NULL)
[10:22:51.632]                 if (is_error) {
[10:22:51.632]                   sessionInformation <- function() {
[10:22:51.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.632]                       search = base::search(), system = base::Sys.info())
[10:22:51.632]                   }
[10:22:51.632]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.632]                     cond$call), session = sessionInformation(), 
[10:22:51.632]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.632]                   signalCondition(cond)
[10:22:51.632]                 }
[10:22:51.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.632]                 "immediateCondition"))) {
[10:22:51.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.632]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.632]                   if (TRUE && !signal) {
[10:22:51.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.632]                     {
[10:22:51.632]                       inherits <- base::inherits
[10:22:51.632]                       invokeRestart <- base::invokeRestart
[10:22:51.632]                       is.null <- base::is.null
[10:22:51.632]                       muffled <- FALSE
[10:22:51.632]                       if (inherits(cond, "message")) {
[10:22:51.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.632]                         if (muffled) 
[10:22:51.632]                           invokeRestart("muffleMessage")
[10:22:51.632]                       }
[10:22:51.632]                       else if (inherits(cond, "warning")) {
[10:22:51.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.632]                         if (muffled) 
[10:22:51.632]                           invokeRestart("muffleWarning")
[10:22:51.632]                       }
[10:22:51.632]                       else if (inherits(cond, "condition")) {
[10:22:51.632]                         if (!is.null(pattern)) {
[10:22:51.632]                           computeRestarts <- base::computeRestarts
[10:22:51.632]                           grepl <- base::grepl
[10:22:51.632]                           restarts <- computeRestarts(cond)
[10:22:51.632]                           for (restart in restarts) {
[10:22:51.632]                             name <- restart$name
[10:22:51.632]                             if (is.null(name)) 
[10:22:51.632]                               next
[10:22:51.632]                             if (!grepl(pattern, name)) 
[10:22:51.632]                               next
[10:22:51.632]                             invokeRestart(restart)
[10:22:51.632]                             muffled <- TRUE
[10:22:51.632]                             break
[10:22:51.632]                           }
[10:22:51.632]                         }
[10:22:51.632]                       }
[10:22:51.632]                       invisible(muffled)
[10:22:51.632]                     }
[10:22:51.632]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.632]                   }
[10:22:51.632]                 }
[10:22:51.632]                 else {
[10:22:51.632]                   if (TRUE) {
[10:22:51.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.632]                     {
[10:22:51.632]                       inherits <- base::inherits
[10:22:51.632]                       invokeRestart <- base::invokeRestart
[10:22:51.632]                       is.null <- base::is.null
[10:22:51.632]                       muffled <- FALSE
[10:22:51.632]                       if (inherits(cond, "message")) {
[10:22:51.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.632]                         if (muffled) 
[10:22:51.632]                           invokeRestart("muffleMessage")
[10:22:51.632]                       }
[10:22:51.632]                       else if (inherits(cond, "warning")) {
[10:22:51.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.632]                         if (muffled) 
[10:22:51.632]                           invokeRestart("muffleWarning")
[10:22:51.632]                       }
[10:22:51.632]                       else if (inherits(cond, "condition")) {
[10:22:51.632]                         if (!is.null(pattern)) {
[10:22:51.632]                           computeRestarts <- base::computeRestarts
[10:22:51.632]                           grepl <- base::grepl
[10:22:51.632]                           restarts <- computeRestarts(cond)
[10:22:51.632]                           for (restart in restarts) {
[10:22:51.632]                             name <- restart$name
[10:22:51.632]                             if (is.null(name)) 
[10:22:51.632]                               next
[10:22:51.632]                             if (!grepl(pattern, name)) 
[10:22:51.632]                               next
[10:22:51.632]                             invokeRestart(restart)
[10:22:51.632]                             muffled <- TRUE
[10:22:51.632]                             break
[10:22:51.632]                           }
[10:22:51.632]                         }
[10:22:51.632]                       }
[10:22:51.632]                       invisible(muffled)
[10:22:51.632]                     }
[10:22:51.632]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.632]                   }
[10:22:51.632]                 }
[10:22:51.632]             }
[10:22:51.632]         }))
[10:22:51.632]     }, error = function(ex) {
[10:22:51.632]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.632]                 ...future.rng), started = ...future.startTime, 
[10:22:51.632]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.632]             version = "1.8"), class = "FutureResult")
[10:22:51.632]     }, finally = {
[10:22:51.632]         if (!identical(...future.workdir, getwd())) 
[10:22:51.632]             setwd(...future.workdir)
[10:22:51.632]         {
[10:22:51.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.632]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.632]             }
[10:22:51.632]             base::options(...future.oldOptions)
[10:22:51.632]             if (.Platform$OS.type == "windows") {
[10:22:51.632]                 old_names <- names(...future.oldEnvVars)
[10:22:51.632]                 envs <- base::Sys.getenv()
[10:22:51.632]                 names <- names(envs)
[10:22:51.632]                 common <- intersect(names, old_names)
[10:22:51.632]                 added <- setdiff(names, old_names)
[10:22:51.632]                 removed <- setdiff(old_names, names)
[10:22:51.632]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.632]                   envs[common]]
[10:22:51.632]                 NAMES <- toupper(changed)
[10:22:51.632]                 args <- list()
[10:22:51.632]                 for (kk in seq_along(NAMES)) {
[10:22:51.632]                   name <- changed[[kk]]
[10:22:51.632]                   NAME <- NAMES[[kk]]
[10:22:51.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.632]                     next
[10:22:51.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.632]                 }
[10:22:51.632]                 NAMES <- toupper(added)
[10:22:51.632]                 for (kk in seq_along(NAMES)) {
[10:22:51.632]                   name <- added[[kk]]
[10:22:51.632]                   NAME <- NAMES[[kk]]
[10:22:51.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.632]                     next
[10:22:51.632]                   args[[name]] <- ""
[10:22:51.632]                 }
[10:22:51.632]                 NAMES <- toupper(removed)
[10:22:51.632]                 for (kk in seq_along(NAMES)) {
[10:22:51.632]                   name <- removed[[kk]]
[10:22:51.632]                   NAME <- NAMES[[kk]]
[10:22:51.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.632]                     next
[10:22:51.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.632]                 }
[10:22:51.632]                 if (length(args) > 0) 
[10:22:51.632]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.632]             }
[10:22:51.632]             else {
[10:22:51.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.632]             }
[10:22:51.632]             {
[10:22:51.632]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.632]                   0L) {
[10:22:51.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.632]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.632]                   base::options(opts)
[10:22:51.632]                 }
[10:22:51.632]                 {
[10:22:51.632]                   {
[10:22:51.632]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.632]                     NULL
[10:22:51.632]                   }
[10:22:51.632]                   options(future.plan = NULL)
[10:22:51.632]                   if (is.na(NA_character_)) 
[10:22:51.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.632]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.632]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.632]                     envir = parent.frame()) 
[10:22:51.632]                   {
[10:22:51.632]                     if (is.function(workers)) 
[10:22:51.632]                       workers <- workers()
[10:22:51.632]                     workers <- structure(as.integer(workers), 
[10:22:51.632]                       class = class(workers))
[10:22:51.632]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.632]                       workers >= 1)
[10:22:51.632]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.632]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.632]                     }
[10:22:51.632]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.632]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.632]                       envir = envir)
[10:22:51.632]                     if (!future$lazy) 
[10:22:51.632]                       future <- run(future)
[10:22:51.632]                     invisible(future)
[10:22:51.632]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.632]                 }
[10:22:51.632]             }
[10:22:51.632]         }
[10:22:51.632]     })
[10:22:51.632]     if (TRUE) {
[10:22:51.632]         base::sink(type = "output", split = FALSE)
[10:22:51.632]         if (TRUE) {
[10:22:51.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.632]         }
[10:22:51.632]         else {
[10:22:51.632]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.632]         }
[10:22:51.632]         base::close(...future.stdout)
[10:22:51.632]         ...future.stdout <- NULL
[10:22:51.632]     }
[10:22:51.632]     ...future.result$conditions <- ...future.conditions
[10:22:51.632]     ...future.result$finished <- base::Sys.time()
[10:22:51.632]     ...future.result
[10:22:51.632] }
[10:22:51.634] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[10:22:51.635] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[10:22:51.635] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[10:22:51.635] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[10:22:51.636] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[10:22:51.636] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:22:51.636] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:22:51.636] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:51.637] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.637] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:22:51.637] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.637] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[10:22:51.638] MultisessionFuture started
[10:22:51.638] - Launch lazy future ... done
[10:22:51.638] run() for ‘MultisessionFuture’ ... done
[10:22:51.638] Created future:
[10:22:51.639] MultisessionFuture:
[10:22:51.639] Label: ‘future_by-2’
[10:22:51.639] Expression:
[10:22:51.639] {
[10:22:51.639]     do.call(function(...) {
[10:22:51.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.639]             on.exit(options(oopts), add = TRUE)
[10:22:51.639]         }
[10:22:51.639]         {
[10:22:51.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.639]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.639]             })
[10:22:51.639]         }
[10:22:51.639]     }, args = future.call.arguments)
[10:22:51.639] }
[10:22:51.639] Lazy evaluation: FALSE
[10:22:51.639] Asynchronous evaluation: TRUE
[10:22:51.639] Local evaluation: TRUE
[10:22:51.639] Environment: R_GlobalEnv
[10:22:51.639] Capture standard output: TRUE
[10:22:51.639] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.639] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.639] Packages: 1 packages (‘stats’)
[10:22:51.639] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.639] Resolved: FALSE
[10:22:51.639] Value: <not collected>
[10:22:51.639] Conditions captured: <none>
[10:22:51.639] Early signaling: FALSE
[10:22:51.639] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.639] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.650] Chunk #2 of 2 ... DONE
[10:22:51.650] Launching 2 futures (chunks) ... DONE
[10:22:51.650] Resolving 2 futures (chunks) ...
[10:22:51.651] resolve() on list ...
[10:22:51.651]  recursive: 0
[10:22:51.651]  length: 2
[10:22:51.651] 
[10:22:51.652] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.652] - Validating connection of MultisessionFuture
[10:22:51.652] - received message: FutureResult
[10:22:51.652] - Received FutureResult
[10:22:51.652] - Erased future from FutureRegistry
[10:22:51.652] result() for ClusterFuture ...
[10:22:51.652] - result already collected: FutureResult
[10:22:51.652] result() for ClusterFuture ... done
[10:22:51.653] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.653] Future #1
[10:22:51.653] result() for ClusterFuture ...
[10:22:51.653] - result already collected: FutureResult
[10:22:51.653] result() for ClusterFuture ... done
[10:22:51.653] result() for ClusterFuture ...
[10:22:51.653] - result already collected: FutureResult
[10:22:51.653] result() for ClusterFuture ... done
[10:22:51.653] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:51.653] - nx: 2
[10:22:51.653] - relay: TRUE
[10:22:51.654] - stdout: TRUE
[10:22:51.654] - signal: TRUE
[10:22:51.654] - resignal: FALSE
[10:22:51.654] - force: TRUE
[10:22:51.654] - relayed: [n=2] FALSE, FALSE
[10:22:51.654] - queued futures: [n=2] FALSE, FALSE
[10:22:51.654]  - until=1
[10:22:51.654]  - relaying element #1
[10:22:51.654] result() for ClusterFuture ...
[10:22:51.654] - result already collected: FutureResult
[10:22:51.654] result() for ClusterFuture ... done
[10:22:51.654] result() for ClusterFuture ...
[10:22:51.655] - result already collected: FutureResult
[10:22:51.655] result() for ClusterFuture ... done
[10:22:51.655] result() for ClusterFuture ...
[10:22:51.655] - result already collected: FutureResult
[10:22:51.655] result() for ClusterFuture ... done
[10:22:51.655] result() for ClusterFuture ...
[10:22:51.655] - result already collected: FutureResult
[10:22:51.655] result() for ClusterFuture ... done
[10:22:51.655] - relayed: [n=2] TRUE, FALSE
[10:22:51.655] - queued futures: [n=2] TRUE, FALSE
[10:22:51.655] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:51.656]  length: 1 (resolved future 1)
[10:22:51.697] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.697] - Validating connection of MultisessionFuture
[10:22:51.698] - received message: FutureResult
[10:22:51.698] - Received FutureResult
[10:22:51.698] - Erased future from FutureRegistry
[10:22:51.698] result() for ClusterFuture ...
[10:22:51.698] - result already collected: FutureResult
[10:22:51.698] result() for ClusterFuture ... done
[10:22:51.698] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.698] Future #2
[10:22:51.698] result() for ClusterFuture ...
[10:22:51.698] - result already collected: FutureResult
[10:22:51.699] result() for ClusterFuture ... done
[10:22:51.699] result() for ClusterFuture ...
[10:22:51.699] - result already collected: FutureResult
[10:22:51.699] result() for ClusterFuture ... done
[10:22:51.699] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:51.699] - nx: 2
[10:22:51.699] - relay: TRUE
[10:22:51.699] - stdout: TRUE
[10:22:51.699] - signal: TRUE
[10:22:51.699] - resignal: FALSE
[10:22:51.699] - force: TRUE
[10:22:51.700] - relayed: [n=2] TRUE, FALSE
[10:22:51.700] - queued futures: [n=2] TRUE, FALSE
[10:22:51.700]  - until=2
[10:22:51.700]  - relaying element #2
[10:22:51.700] result() for ClusterFuture ...
[10:22:51.700] - result already collected: FutureResult
[10:22:51.700] result() for ClusterFuture ... done
[10:22:51.700] result() for ClusterFuture ...
[10:22:51.700] - result already collected: FutureResult
[10:22:51.700] result() for ClusterFuture ... done
[10:22:51.700] result() for ClusterFuture ...
[10:22:51.701] - result already collected: FutureResult
[10:22:51.701] result() for ClusterFuture ... done
[10:22:51.701] result() for ClusterFuture ...
[10:22:51.701] - result already collected: FutureResult
[10:22:51.701] result() for ClusterFuture ... done
[10:22:51.701] - relayed: [n=2] TRUE, TRUE
[10:22:51.701] - queued futures: [n=2] TRUE, TRUE
[10:22:51.701] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:51.701]  length: 0 (resolved future 2)
[10:22:51.701] Relaying remaining futures
[10:22:51.701] signalConditionsASAP(NULL, pos=0) ...
[10:22:51.701] - nx: 2
[10:22:51.702] - relay: TRUE
[10:22:51.702] - stdout: TRUE
[10:22:51.702] - signal: TRUE
[10:22:51.702] - resignal: FALSE
[10:22:51.702] - force: TRUE
[10:22:51.702] - relayed: [n=2] TRUE, TRUE
[10:22:51.702] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:51.702] - relayed: [n=2] TRUE, TRUE
[10:22:51.702] - queued futures: [n=2] TRUE, TRUE
[10:22:51.702] signalConditionsASAP(NULL, pos=0) ... done
[10:22:51.702] resolve() on list ... DONE
[10:22:51.703] result() for ClusterFuture ...
[10:22:51.703] - result already collected: FutureResult
[10:22:51.703] result() for ClusterFuture ... done
[10:22:51.703] result() for ClusterFuture ...
[10:22:51.703] - result already collected: FutureResult
[10:22:51.703] result() for ClusterFuture ... done
[10:22:51.703] result() for ClusterFuture ...
[10:22:51.703] - result already collected: FutureResult
[10:22:51.703] result() for ClusterFuture ... done
[10:22:51.703] result() for ClusterFuture ...
[10:22:51.703] - result already collected: FutureResult
[10:22:51.703] result() for ClusterFuture ... done
[10:22:51.704]  - Number of value chunks collected: 2
[10:22:51.704] Resolving 2 futures (chunks) ... DONE
[10:22:51.704] Reducing values from 2 chunks ...
[10:22:51.704]  - Number of values collected after concatenation: 3
[10:22:51.704]  - Number of values expected: 3
[10:22:51.704] Reducing values from 2 chunks ... DONE
[10:22:51.704] future_lapply() ... DONE
[10:22:51.704] future_by_internal() ... DONE
[10:22:51.708] future_by_internal() ...
[10:22:51.709] future_lapply() ...
[10:22:51.713] Number of chunks: 2
[10:22:51.713] getGlobalsAndPackagesXApply() ...
[10:22:51.713]  - future.globals: TRUE
[10:22:51.713] getGlobalsAndPackages() ...
[10:22:51.713] Searching for globals...
[10:22:51.715] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:22:51.715] Searching for globals ... DONE
[10:22:51.715] Resolving globals: FALSE
[10:22:51.716] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:22:51.716] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:22:51.716] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:51.716] - packages: [1] ‘stats’
[10:22:51.716] getGlobalsAndPackages() ... DONE
[10:22:51.716]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:22:51.717]  - needed namespaces: [n=1] ‘stats’
[10:22:51.717] Finding globals ... DONE
[10:22:51.717]  - use_args: TRUE
[10:22:51.717]  - Getting '...' globals ...
[10:22:51.717] resolve() on list ...
[10:22:51.717]  recursive: 0
[10:22:51.717]  length: 1
[10:22:51.717]  elements: ‘...’
[10:22:51.718]  length: 0 (resolved future 1)
[10:22:51.718] resolve() on list ... DONE
[10:22:51.718]    - '...' content: [n=0] 
[10:22:51.718] List of 1
[10:22:51.718]  $ ...: list()
[10:22:51.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.718]  - attr(*, "where")=List of 1
[10:22:51.718]   ..$ ...:<environment: 0x55f63a792e08> 
[10:22:51.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.718]  - attr(*, "resolved")= logi TRUE
[10:22:51.718]  - attr(*, "total_size")= num NA
[10:22:51.720]  - Getting '...' globals ... DONE
[10:22:51.721] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:22:51.721] List of 4
[10:22:51.721]  $ ...future.FUN:function (x)  
[10:22:51.721]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:22:51.721]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:22:51.721]  $ ...          : list()
[10:22:51.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.721]  - attr(*, "where")=List of 4
[10:22:51.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:51.721]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:22:51.721]   ..$ wool         :<environment: R_EmptyEnv> 
[10:22:51.721]   ..$ ...          :<environment: 0x55f63a792e08> 
[10:22:51.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.721]  - attr(*, "resolved")= logi FALSE
[10:22:51.721]  - attr(*, "total_size")= num 2320
[10:22:51.724] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:51.725] getGlobalsAndPackagesXApply() ... DONE
[10:22:51.725] Number of futures (= number of chunks): 2
[10:22:51.725] Launching 2 futures (chunks) ...
[10:22:51.725] Chunk #1 of 2 ...
[10:22:51.725]  - Finding globals in 'X' for chunk #1 ...
[10:22:51.725] getGlobalsAndPackages() ...
[10:22:51.725] Searching for globals...
[10:22:51.726] 
[10:22:51.726] Searching for globals ... DONE
[10:22:51.726] - globals: [0] <none>
[10:22:51.726] getGlobalsAndPackages() ... DONE
[10:22:51.726]    + additional globals found: [n=0] 
[10:22:51.726]    + additional namespaces needed: [n=0] 
[10:22:51.726]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:51.726]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.726]  - seeds: <none>
[10:22:51.727]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.727] getGlobalsAndPackages() ...
[10:22:51.727] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.727] Resolving globals: FALSE
[10:22:51.727] Tweak future expression to call with '...' arguments ...
[10:22:51.727] {
[10:22:51.727]     do.call(function(...) {
[10:22:51.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.727]             on.exit(options(oopts), add = TRUE)
[10:22:51.727]         }
[10:22:51.727]         {
[10:22:51.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.727]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.727]             })
[10:22:51.727]         }
[10:22:51.727]     }, args = future.call.arguments)
[10:22:51.727] }
[10:22:51.727] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.728] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.728] 
[10:22:51.728] getGlobalsAndPackages() ... DONE
[10:22:51.728] run() for ‘Future’ ...
[10:22:51.728] - state: ‘created’
[10:22:51.728] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.743] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.743]   - Field: ‘node’
[10:22:51.743]   - Field: ‘label’
[10:22:51.744]   - Field: ‘local’
[10:22:51.744]   - Field: ‘owner’
[10:22:51.744]   - Field: ‘envir’
[10:22:51.744]   - Field: ‘workers’
[10:22:51.744]   - Field: ‘packages’
[10:22:51.744]   - Field: ‘gc’
[10:22:51.744]   - Field: ‘conditions’
[10:22:51.744]   - Field: ‘persistent’
[10:22:51.744]   - Field: ‘expr’
[10:22:51.744]   - Field: ‘uuid’
[10:22:51.745]   - Field: ‘seed’
[10:22:51.745]   - Field: ‘version’
[10:22:51.745]   - Field: ‘result’
[10:22:51.745]   - Field: ‘asynchronous’
[10:22:51.747]   - Field: ‘calls’
[10:22:51.747]   - Field: ‘globals’
[10:22:51.747]   - Field: ‘stdout’
[10:22:51.747]   - Field: ‘earlySignal’
[10:22:51.748]   - Field: ‘lazy’
[10:22:51.748]   - Field: ‘state’
[10:22:51.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.748] - Launch lazy future ...
[10:22:51.748] Packages needed by the future expression (n = 1): ‘stats’
[10:22:51.748] Packages needed by future strategies (n = 0): <none>
[10:22:51.749] {
[10:22:51.749]     {
[10:22:51.749]         {
[10:22:51.749]             ...future.startTime <- base::Sys.time()
[10:22:51.749]             {
[10:22:51.749]                 {
[10:22:51.749]                   {
[10:22:51.749]                     {
[10:22:51.749]                       {
[10:22:51.749]                         base::local({
[10:22:51.749]                           has_future <- base::requireNamespace("future", 
[10:22:51.749]                             quietly = TRUE)
[10:22:51.749]                           if (has_future) {
[10:22:51.749]                             ns <- base::getNamespace("future")
[10:22:51.749]                             version <- ns[[".package"]][["version"]]
[10:22:51.749]                             if (is.null(version)) 
[10:22:51.749]                               version <- utils::packageVersion("future")
[10:22:51.749]                           }
[10:22:51.749]                           else {
[10:22:51.749]                             version <- NULL
[10:22:51.749]                           }
[10:22:51.749]                           if (!has_future || version < "1.8.0") {
[10:22:51.749]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.749]                               "", base::R.version$version.string), 
[10:22:51.749]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:51.749]                                 base::R.version$platform, 8 * 
[10:22:51.749]                                   base::.Machine$sizeof.pointer), 
[10:22:51.749]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.749]                                 "release", "version")], collapse = " "), 
[10:22:51.749]                               hostname = base::Sys.info()[["nodename"]])
[10:22:51.749]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.749]                               info)
[10:22:51.749]                             info <- base::paste(info, collapse = "; ")
[10:22:51.749]                             if (!has_future) {
[10:22:51.749]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.749]                                 info)
[10:22:51.749]                             }
[10:22:51.749]                             else {
[10:22:51.749]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.749]                                 info, version)
[10:22:51.749]                             }
[10:22:51.749]                             base::stop(msg)
[10:22:51.749]                           }
[10:22:51.749]                         })
[10:22:51.749]                       }
[10:22:51.749]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.749]                       base::options(mc.cores = 1L)
[10:22:51.749]                     }
[10:22:51.749]                     base::local({
[10:22:51.749]                       for (pkg in "stats") {
[10:22:51.749]                         base::loadNamespace(pkg)
[10:22:51.749]                         base::library(pkg, character.only = TRUE)
[10:22:51.749]                       }
[10:22:51.749]                     })
[10:22:51.749]                   }
[10:22:51.749]                   options(future.plan = NULL)
[10:22:51.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.749]                 }
[10:22:51.749]                 ...future.workdir <- getwd()
[10:22:51.749]             }
[10:22:51.749]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.749]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.749]         }
[10:22:51.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.749]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.749]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.749]             base::names(...future.oldOptions))
[10:22:51.749]     }
[10:22:51.749]     if (FALSE) {
[10:22:51.749]     }
[10:22:51.749]     else {
[10:22:51.749]         if (TRUE) {
[10:22:51.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.749]                 open = "w")
[10:22:51.749]         }
[10:22:51.749]         else {
[10:22:51.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.749]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.749]         }
[10:22:51.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.749]             base::sink(type = "output", split = FALSE)
[10:22:51.749]             base::close(...future.stdout)
[10:22:51.749]         }, add = TRUE)
[10:22:51.749]     }
[10:22:51.749]     ...future.frame <- base::sys.nframe()
[10:22:51.749]     ...future.conditions <- base::list()
[10:22:51.749]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.749]     if (FALSE) {
[10:22:51.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.749]     }
[10:22:51.749]     ...future.result <- base::tryCatch({
[10:22:51.749]         base::withCallingHandlers({
[10:22:51.749]             ...future.value <- base::withVisible(base::local({
[10:22:51.749]                 ...future.makeSendCondition <- base::local({
[10:22:51.749]                   sendCondition <- NULL
[10:22:51.749]                   function(frame = 1L) {
[10:22:51.749]                     if (is.function(sendCondition)) 
[10:22:51.749]                       return(sendCondition)
[10:22:51.749]                     ns <- getNamespace("parallel")
[10:22:51.749]                     if (exists("sendData", mode = "function", 
[10:22:51.749]                       envir = ns)) {
[10:22:51.749]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.749]                         envir = ns)
[10:22:51.749]                       envir <- sys.frame(frame)
[10:22:51.749]                       master <- NULL
[10:22:51.749]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.749]                         !identical(envir, emptyenv())) {
[10:22:51.749]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.749]                           inherits = FALSE)) {
[10:22:51.749]                           master <- get("master", mode = "list", 
[10:22:51.749]                             envir = envir, inherits = FALSE)
[10:22:51.749]                           if (inherits(master, c("SOCKnode", 
[10:22:51.749]                             "SOCK0node"))) {
[10:22:51.749]                             sendCondition <<- function(cond) {
[10:22:51.749]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.749]                                 success = TRUE)
[10:22:51.749]                               parallel_sendData(master, data)
[10:22:51.749]                             }
[10:22:51.749]                             return(sendCondition)
[10:22:51.749]                           }
[10:22:51.749]                         }
[10:22:51.749]                         frame <- frame + 1L
[10:22:51.749]                         envir <- sys.frame(frame)
[10:22:51.749]                       }
[10:22:51.749]                     }
[10:22:51.749]                     sendCondition <<- function(cond) NULL
[10:22:51.749]                   }
[10:22:51.749]                 })
[10:22:51.749]                 withCallingHandlers({
[10:22:51.749]                   {
[10:22:51.749]                     do.call(function(...) {
[10:22:51.749]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.749]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.749]                         ...future.globals.maxSize)) {
[10:22:51.749]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.749]                         on.exit(options(oopts), add = TRUE)
[10:22:51.749]                       }
[10:22:51.749]                       {
[10:22:51.749]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.749]                           FUN = function(jj) {
[10:22:51.749]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.749]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.749]                           })
[10:22:51.749]                       }
[10:22:51.749]                     }, args = future.call.arguments)
[10:22:51.749]                   }
[10:22:51.749]                 }, immediateCondition = function(cond) {
[10:22:51.749]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.749]                   sendCondition(cond)
[10:22:51.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.749]                   {
[10:22:51.749]                     inherits <- base::inherits
[10:22:51.749]                     invokeRestart <- base::invokeRestart
[10:22:51.749]                     is.null <- base::is.null
[10:22:51.749]                     muffled <- FALSE
[10:22:51.749]                     if (inherits(cond, "message")) {
[10:22:51.749]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.749]                       if (muffled) 
[10:22:51.749]                         invokeRestart("muffleMessage")
[10:22:51.749]                     }
[10:22:51.749]                     else if (inherits(cond, "warning")) {
[10:22:51.749]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.749]                       if (muffled) 
[10:22:51.749]                         invokeRestart("muffleWarning")
[10:22:51.749]                     }
[10:22:51.749]                     else if (inherits(cond, "condition")) {
[10:22:51.749]                       if (!is.null(pattern)) {
[10:22:51.749]                         computeRestarts <- base::computeRestarts
[10:22:51.749]                         grepl <- base::grepl
[10:22:51.749]                         restarts <- computeRestarts(cond)
[10:22:51.749]                         for (restart in restarts) {
[10:22:51.749]                           name <- restart$name
[10:22:51.749]                           if (is.null(name)) 
[10:22:51.749]                             next
[10:22:51.749]                           if (!grepl(pattern, name)) 
[10:22:51.749]                             next
[10:22:51.749]                           invokeRestart(restart)
[10:22:51.749]                           muffled <- TRUE
[10:22:51.749]                           break
[10:22:51.749]                         }
[10:22:51.749]                       }
[10:22:51.749]                     }
[10:22:51.749]                     invisible(muffled)
[10:22:51.749]                   }
[10:22:51.749]                   muffleCondition(cond)
[10:22:51.749]                 })
[10:22:51.749]             }))
[10:22:51.749]             future::FutureResult(value = ...future.value$value, 
[10:22:51.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.749]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.749]                     ...future.globalenv.names))
[10:22:51.749]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.749]         }, condition = base::local({
[10:22:51.749]             c <- base::c
[10:22:51.749]             inherits <- base::inherits
[10:22:51.749]             invokeRestart <- base::invokeRestart
[10:22:51.749]             length <- base::length
[10:22:51.749]             list <- base::list
[10:22:51.749]             seq.int <- base::seq.int
[10:22:51.749]             signalCondition <- base::signalCondition
[10:22:51.749]             sys.calls <- base::sys.calls
[10:22:51.749]             `[[` <- base::`[[`
[10:22:51.749]             `+` <- base::`+`
[10:22:51.749]             `<<-` <- base::`<<-`
[10:22:51.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.749]                   3L)]
[10:22:51.749]             }
[10:22:51.749]             function(cond) {
[10:22:51.749]                 is_error <- inherits(cond, "error")
[10:22:51.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.749]                   NULL)
[10:22:51.749]                 if (is_error) {
[10:22:51.749]                   sessionInformation <- function() {
[10:22:51.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.749]                       search = base::search(), system = base::Sys.info())
[10:22:51.749]                   }
[10:22:51.749]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.749]                     cond$call), session = sessionInformation(), 
[10:22:51.749]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.749]                   signalCondition(cond)
[10:22:51.749]                 }
[10:22:51.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.749]                 "immediateCondition"))) {
[10:22:51.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.749]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.749]                   if (TRUE && !signal) {
[10:22:51.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.749]                     {
[10:22:51.749]                       inherits <- base::inherits
[10:22:51.749]                       invokeRestart <- base::invokeRestart
[10:22:51.749]                       is.null <- base::is.null
[10:22:51.749]                       muffled <- FALSE
[10:22:51.749]                       if (inherits(cond, "message")) {
[10:22:51.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.749]                         if (muffled) 
[10:22:51.749]                           invokeRestart("muffleMessage")
[10:22:51.749]                       }
[10:22:51.749]                       else if (inherits(cond, "warning")) {
[10:22:51.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.749]                         if (muffled) 
[10:22:51.749]                           invokeRestart("muffleWarning")
[10:22:51.749]                       }
[10:22:51.749]                       else if (inherits(cond, "condition")) {
[10:22:51.749]                         if (!is.null(pattern)) {
[10:22:51.749]                           computeRestarts <- base::computeRestarts
[10:22:51.749]                           grepl <- base::grepl
[10:22:51.749]                           restarts <- computeRestarts(cond)
[10:22:51.749]                           for (restart in restarts) {
[10:22:51.749]                             name <- restart$name
[10:22:51.749]                             if (is.null(name)) 
[10:22:51.749]                               next
[10:22:51.749]                             if (!grepl(pattern, name)) 
[10:22:51.749]                               next
[10:22:51.749]                             invokeRestart(restart)
[10:22:51.749]                             muffled <- TRUE
[10:22:51.749]                             break
[10:22:51.749]                           }
[10:22:51.749]                         }
[10:22:51.749]                       }
[10:22:51.749]                       invisible(muffled)
[10:22:51.749]                     }
[10:22:51.749]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.749]                   }
[10:22:51.749]                 }
[10:22:51.749]                 else {
[10:22:51.749]                   if (TRUE) {
[10:22:51.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.749]                     {
[10:22:51.749]                       inherits <- base::inherits
[10:22:51.749]                       invokeRestart <- base::invokeRestart
[10:22:51.749]                       is.null <- base::is.null
[10:22:51.749]                       muffled <- FALSE
[10:22:51.749]                       if (inherits(cond, "message")) {
[10:22:51.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.749]                         if (muffled) 
[10:22:51.749]                           invokeRestart("muffleMessage")
[10:22:51.749]                       }
[10:22:51.749]                       else if (inherits(cond, "warning")) {
[10:22:51.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.749]                         if (muffled) 
[10:22:51.749]                           invokeRestart("muffleWarning")
[10:22:51.749]                       }
[10:22:51.749]                       else if (inherits(cond, "condition")) {
[10:22:51.749]                         if (!is.null(pattern)) {
[10:22:51.749]                           computeRestarts <- base::computeRestarts
[10:22:51.749]                           grepl <- base::grepl
[10:22:51.749]                           restarts <- computeRestarts(cond)
[10:22:51.749]                           for (restart in restarts) {
[10:22:51.749]                             name <- restart$name
[10:22:51.749]                             if (is.null(name)) 
[10:22:51.749]                               next
[10:22:51.749]                             if (!grepl(pattern, name)) 
[10:22:51.749]                               next
[10:22:51.749]                             invokeRestart(restart)
[10:22:51.749]                             muffled <- TRUE
[10:22:51.749]                             break
[10:22:51.749]                           }
[10:22:51.749]                         }
[10:22:51.749]                       }
[10:22:51.749]                       invisible(muffled)
[10:22:51.749]                     }
[10:22:51.749]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.749]                   }
[10:22:51.749]                 }
[10:22:51.749]             }
[10:22:51.749]         }))
[10:22:51.749]     }, error = function(ex) {
[10:22:51.749]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.749]                 ...future.rng), started = ...future.startTime, 
[10:22:51.749]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.749]             version = "1.8"), class = "FutureResult")
[10:22:51.749]     }, finally = {
[10:22:51.749]         if (!identical(...future.workdir, getwd())) 
[10:22:51.749]             setwd(...future.workdir)
[10:22:51.749]         {
[10:22:51.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.749]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.749]             }
[10:22:51.749]             base::options(...future.oldOptions)
[10:22:51.749]             if (.Platform$OS.type == "windows") {
[10:22:51.749]                 old_names <- names(...future.oldEnvVars)
[10:22:51.749]                 envs <- base::Sys.getenv()
[10:22:51.749]                 names <- names(envs)
[10:22:51.749]                 common <- intersect(names, old_names)
[10:22:51.749]                 added <- setdiff(names, old_names)
[10:22:51.749]                 removed <- setdiff(old_names, names)
[10:22:51.749]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.749]                   envs[common]]
[10:22:51.749]                 NAMES <- toupper(changed)
[10:22:51.749]                 args <- list()
[10:22:51.749]                 for (kk in seq_along(NAMES)) {
[10:22:51.749]                   name <- changed[[kk]]
[10:22:51.749]                   NAME <- NAMES[[kk]]
[10:22:51.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.749]                     next
[10:22:51.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.749]                 }
[10:22:51.749]                 NAMES <- toupper(added)
[10:22:51.749]                 for (kk in seq_along(NAMES)) {
[10:22:51.749]                   name <- added[[kk]]
[10:22:51.749]                   NAME <- NAMES[[kk]]
[10:22:51.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.749]                     next
[10:22:51.749]                   args[[name]] <- ""
[10:22:51.749]                 }
[10:22:51.749]                 NAMES <- toupper(removed)
[10:22:51.749]                 for (kk in seq_along(NAMES)) {
[10:22:51.749]                   name <- removed[[kk]]
[10:22:51.749]                   NAME <- NAMES[[kk]]
[10:22:51.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.749]                     next
[10:22:51.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.749]                 }
[10:22:51.749]                 if (length(args) > 0) 
[10:22:51.749]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.749]             }
[10:22:51.749]             else {
[10:22:51.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.749]             }
[10:22:51.749]             {
[10:22:51.749]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.749]                   0L) {
[10:22:51.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.749]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.749]                   base::options(opts)
[10:22:51.749]                 }
[10:22:51.749]                 {
[10:22:51.749]                   {
[10:22:51.749]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.749]                     NULL
[10:22:51.749]                   }
[10:22:51.749]                   options(future.plan = NULL)
[10:22:51.749]                   if (is.na(NA_character_)) 
[10:22:51.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.749]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.749]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.749]                     envir = parent.frame()) 
[10:22:51.749]                   {
[10:22:51.749]                     if (is.function(workers)) 
[10:22:51.749]                       workers <- workers()
[10:22:51.749]                     workers <- structure(as.integer(workers), 
[10:22:51.749]                       class = class(workers))
[10:22:51.749]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.749]                       workers >= 1)
[10:22:51.749]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.749]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.749]                     }
[10:22:51.749]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.749]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.749]                       envir = envir)
[10:22:51.749]                     if (!future$lazy) 
[10:22:51.749]                       future <- run(future)
[10:22:51.749]                     invisible(future)
[10:22:51.749]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.749]                 }
[10:22:51.749]             }
[10:22:51.749]         }
[10:22:51.749]     })
[10:22:51.749]     if (TRUE) {
[10:22:51.749]         base::sink(type = "output", split = FALSE)
[10:22:51.749]         if (TRUE) {
[10:22:51.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.749]         }
[10:22:51.749]         else {
[10:22:51.749]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.749]         }
[10:22:51.749]         base::close(...future.stdout)
[10:22:51.749]         ...future.stdout <- NULL
[10:22:51.749]     }
[10:22:51.749]     ...future.result$conditions <- ...future.conditions
[10:22:51.749]     ...future.result$finished <- base::Sys.time()
[10:22:51.749]     ...future.result
[10:22:51.749] }
[10:22:51.752] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[10:22:51.752] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[10:22:51.752] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[10:22:51.752] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[10:22:51.753] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[10:22:51.753] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[10:22:51.753] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[10:22:51.753] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:51.753] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.754] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:22:51.754] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:22:51.754] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:51.754] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.755] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:22:51.755] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.755] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[10:22:51.755] MultisessionFuture started
[10:22:51.755] - Launch lazy future ... done
[10:22:51.756] run() for ‘MultisessionFuture’ ... done
[10:22:51.756] Created future:
[10:22:51.756] MultisessionFuture:
[10:22:51.756] Label: ‘future_by-1’
[10:22:51.756] Expression:
[10:22:51.756] {
[10:22:51.756]     do.call(function(...) {
[10:22:51.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.756]             on.exit(options(oopts), add = TRUE)
[10:22:51.756]         }
[10:22:51.756]         {
[10:22:51.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.756]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.756]             })
[10:22:51.756]         }
[10:22:51.756]     }, args = future.call.arguments)
[10:22:51.756] }
[10:22:51.756] Lazy evaluation: FALSE
[10:22:51.756] Asynchronous evaluation: TRUE
[10:22:51.756] Local evaluation: TRUE
[10:22:51.756] Environment: 0x55f63a78f0f0
[10:22:51.756] Capture standard output: TRUE
[10:22:51.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.756] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[10:22:51.756] Packages: 1 packages (‘stats’)
[10:22:51.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.756] Resolved: FALSE
[10:22:51.756] Value: <not collected>
[10:22:51.756] Conditions captured: <none>
[10:22:51.756] Early signaling: FALSE
[10:22:51.756] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.756] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.767] Chunk #1 of 2 ... DONE
[10:22:51.767] Chunk #2 of 2 ...
[10:22:51.768]  - Finding globals in 'X' for chunk #2 ...
[10:22:51.768] getGlobalsAndPackages() ...
[10:22:51.768] Searching for globals...
[10:22:51.768] 
[10:22:51.768] Searching for globals ... DONE
[10:22:51.768] - globals: [0] <none>
[10:22:51.769] getGlobalsAndPackages() ... DONE
[10:22:51.769]    + additional globals found: [n=0] 
[10:22:51.769]    + additional namespaces needed: [n=0] 
[10:22:51.769]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:51.769]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.769]  - seeds: <none>
[10:22:51.769]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.769] getGlobalsAndPackages() ...
[10:22:51.769] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.769] Resolving globals: FALSE
[10:22:51.770] Tweak future expression to call with '...' arguments ...
[10:22:51.770] {
[10:22:51.770]     do.call(function(...) {
[10:22:51.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.770]             on.exit(options(oopts), add = TRUE)
[10:22:51.770]         }
[10:22:51.770]         {
[10:22:51.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.770]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.770]             })
[10:22:51.770]         }
[10:22:51.770]     }, args = future.call.arguments)
[10:22:51.770] }
[10:22:51.770] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.770] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.770] 
[10:22:51.770] getGlobalsAndPackages() ... DONE
[10:22:51.771] run() for ‘Future’ ...
[10:22:51.771] - state: ‘created’
[10:22:51.771] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.785]   - Field: ‘node’
[10:22:51.785]   - Field: ‘label’
[10:22:51.785]   - Field: ‘local’
[10:22:51.785]   - Field: ‘owner’
[10:22:51.785]   - Field: ‘envir’
[10:22:51.785]   - Field: ‘workers’
[10:22:51.785]   - Field: ‘packages’
[10:22:51.785]   - Field: ‘gc’
[10:22:51.785]   - Field: ‘conditions’
[10:22:51.785]   - Field: ‘persistent’
[10:22:51.786]   - Field: ‘expr’
[10:22:51.786]   - Field: ‘uuid’
[10:22:51.786]   - Field: ‘seed’
[10:22:51.786]   - Field: ‘version’
[10:22:51.786]   - Field: ‘result’
[10:22:51.786]   - Field: ‘asynchronous’
[10:22:51.786]   - Field: ‘calls’
[10:22:51.786]   - Field: ‘globals’
[10:22:51.786]   - Field: ‘stdout’
[10:22:51.786]   - Field: ‘earlySignal’
[10:22:51.786]   - Field: ‘lazy’
[10:22:51.786]   - Field: ‘state’
[10:22:51.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.787] - Launch lazy future ...
[10:22:51.787] Packages needed by the future expression (n = 1): ‘stats’
[10:22:51.787] Packages needed by future strategies (n = 0): <none>
[10:22:51.788] {
[10:22:51.788]     {
[10:22:51.788]         {
[10:22:51.788]             ...future.startTime <- base::Sys.time()
[10:22:51.788]             {
[10:22:51.788]                 {
[10:22:51.788]                   {
[10:22:51.788]                     {
[10:22:51.788]                       {
[10:22:51.788]                         base::local({
[10:22:51.788]                           has_future <- base::requireNamespace("future", 
[10:22:51.788]                             quietly = TRUE)
[10:22:51.788]                           if (has_future) {
[10:22:51.788]                             ns <- base::getNamespace("future")
[10:22:51.788]                             version <- ns[[".package"]][["version"]]
[10:22:51.788]                             if (is.null(version)) 
[10:22:51.788]                               version <- utils::packageVersion("future")
[10:22:51.788]                           }
[10:22:51.788]                           else {
[10:22:51.788]                             version <- NULL
[10:22:51.788]                           }
[10:22:51.788]                           if (!has_future || version < "1.8.0") {
[10:22:51.788]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.788]                               "", base::R.version$version.string), 
[10:22:51.788]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:51.788]                                 base::R.version$platform, 8 * 
[10:22:51.788]                                   base::.Machine$sizeof.pointer), 
[10:22:51.788]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.788]                                 "release", "version")], collapse = " "), 
[10:22:51.788]                               hostname = base::Sys.info()[["nodename"]])
[10:22:51.788]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.788]                               info)
[10:22:51.788]                             info <- base::paste(info, collapse = "; ")
[10:22:51.788]                             if (!has_future) {
[10:22:51.788]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.788]                                 info)
[10:22:51.788]                             }
[10:22:51.788]                             else {
[10:22:51.788]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.788]                                 info, version)
[10:22:51.788]                             }
[10:22:51.788]                             base::stop(msg)
[10:22:51.788]                           }
[10:22:51.788]                         })
[10:22:51.788]                       }
[10:22:51.788]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.788]                       base::options(mc.cores = 1L)
[10:22:51.788]                     }
[10:22:51.788]                     base::local({
[10:22:51.788]                       for (pkg in "stats") {
[10:22:51.788]                         base::loadNamespace(pkg)
[10:22:51.788]                         base::library(pkg, character.only = TRUE)
[10:22:51.788]                       }
[10:22:51.788]                     })
[10:22:51.788]                   }
[10:22:51.788]                   options(future.plan = NULL)
[10:22:51.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.788]                 }
[10:22:51.788]                 ...future.workdir <- getwd()
[10:22:51.788]             }
[10:22:51.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.788]         }
[10:22:51.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.788]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.788]             base::names(...future.oldOptions))
[10:22:51.788]     }
[10:22:51.788]     if (FALSE) {
[10:22:51.788]     }
[10:22:51.788]     else {
[10:22:51.788]         if (TRUE) {
[10:22:51.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.788]                 open = "w")
[10:22:51.788]         }
[10:22:51.788]         else {
[10:22:51.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.788]         }
[10:22:51.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.788]             base::sink(type = "output", split = FALSE)
[10:22:51.788]             base::close(...future.stdout)
[10:22:51.788]         }, add = TRUE)
[10:22:51.788]     }
[10:22:51.788]     ...future.frame <- base::sys.nframe()
[10:22:51.788]     ...future.conditions <- base::list()
[10:22:51.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.788]     if (FALSE) {
[10:22:51.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.788]     }
[10:22:51.788]     ...future.result <- base::tryCatch({
[10:22:51.788]         base::withCallingHandlers({
[10:22:51.788]             ...future.value <- base::withVisible(base::local({
[10:22:51.788]                 ...future.makeSendCondition <- base::local({
[10:22:51.788]                   sendCondition <- NULL
[10:22:51.788]                   function(frame = 1L) {
[10:22:51.788]                     if (is.function(sendCondition)) 
[10:22:51.788]                       return(sendCondition)
[10:22:51.788]                     ns <- getNamespace("parallel")
[10:22:51.788]                     if (exists("sendData", mode = "function", 
[10:22:51.788]                       envir = ns)) {
[10:22:51.788]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.788]                         envir = ns)
[10:22:51.788]                       envir <- sys.frame(frame)
[10:22:51.788]                       master <- NULL
[10:22:51.788]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.788]                         !identical(envir, emptyenv())) {
[10:22:51.788]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.788]                           inherits = FALSE)) {
[10:22:51.788]                           master <- get("master", mode = "list", 
[10:22:51.788]                             envir = envir, inherits = FALSE)
[10:22:51.788]                           if (inherits(master, c("SOCKnode", 
[10:22:51.788]                             "SOCK0node"))) {
[10:22:51.788]                             sendCondition <<- function(cond) {
[10:22:51.788]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.788]                                 success = TRUE)
[10:22:51.788]                               parallel_sendData(master, data)
[10:22:51.788]                             }
[10:22:51.788]                             return(sendCondition)
[10:22:51.788]                           }
[10:22:51.788]                         }
[10:22:51.788]                         frame <- frame + 1L
[10:22:51.788]                         envir <- sys.frame(frame)
[10:22:51.788]                       }
[10:22:51.788]                     }
[10:22:51.788]                     sendCondition <<- function(cond) NULL
[10:22:51.788]                   }
[10:22:51.788]                 })
[10:22:51.788]                 withCallingHandlers({
[10:22:51.788]                   {
[10:22:51.788]                     do.call(function(...) {
[10:22:51.788]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.788]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.788]                         ...future.globals.maxSize)) {
[10:22:51.788]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.788]                         on.exit(options(oopts), add = TRUE)
[10:22:51.788]                       }
[10:22:51.788]                       {
[10:22:51.788]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.788]                           FUN = function(jj) {
[10:22:51.788]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.788]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.788]                           })
[10:22:51.788]                       }
[10:22:51.788]                     }, args = future.call.arguments)
[10:22:51.788]                   }
[10:22:51.788]                 }, immediateCondition = function(cond) {
[10:22:51.788]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.788]                   sendCondition(cond)
[10:22:51.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.788]                   {
[10:22:51.788]                     inherits <- base::inherits
[10:22:51.788]                     invokeRestart <- base::invokeRestart
[10:22:51.788]                     is.null <- base::is.null
[10:22:51.788]                     muffled <- FALSE
[10:22:51.788]                     if (inherits(cond, "message")) {
[10:22:51.788]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.788]                       if (muffled) 
[10:22:51.788]                         invokeRestart("muffleMessage")
[10:22:51.788]                     }
[10:22:51.788]                     else if (inherits(cond, "warning")) {
[10:22:51.788]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.788]                       if (muffled) 
[10:22:51.788]                         invokeRestart("muffleWarning")
[10:22:51.788]                     }
[10:22:51.788]                     else if (inherits(cond, "condition")) {
[10:22:51.788]                       if (!is.null(pattern)) {
[10:22:51.788]                         computeRestarts <- base::computeRestarts
[10:22:51.788]                         grepl <- base::grepl
[10:22:51.788]                         restarts <- computeRestarts(cond)
[10:22:51.788]                         for (restart in restarts) {
[10:22:51.788]                           name <- restart$name
[10:22:51.788]                           if (is.null(name)) 
[10:22:51.788]                             next
[10:22:51.788]                           if (!grepl(pattern, name)) 
[10:22:51.788]                             next
[10:22:51.788]                           invokeRestart(restart)
[10:22:51.788]                           muffled <- TRUE
[10:22:51.788]                           break
[10:22:51.788]                         }
[10:22:51.788]                       }
[10:22:51.788]                     }
[10:22:51.788]                     invisible(muffled)
[10:22:51.788]                   }
[10:22:51.788]                   muffleCondition(cond)
[10:22:51.788]                 })
[10:22:51.788]             }))
[10:22:51.788]             future::FutureResult(value = ...future.value$value, 
[10:22:51.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.788]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.788]                     ...future.globalenv.names))
[10:22:51.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.788]         }, condition = base::local({
[10:22:51.788]             c <- base::c
[10:22:51.788]             inherits <- base::inherits
[10:22:51.788]             invokeRestart <- base::invokeRestart
[10:22:51.788]             length <- base::length
[10:22:51.788]             list <- base::list
[10:22:51.788]             seq.int <- base::seq.int
[10:22:51.788]             signalCondition <- base::signalCondition
[10:22:51.788]             sys.calls <- base::sys.calls
[10:22:51.788]             `[[` <- base::`[[`
[10:22:51.788]             `+` <- base::`+`
[10:22:51.788]             `<<-` <- base::`<<-`
[10:22:51.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.788]                   3L)]
[10:22:51.788]             }
[10:22:51.788]             function(cond) {
[10:22:51.788]                 is_error <- inherits(cond, "error")
[10:22:51.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.788]                   NULL)
[10:22:51.788]                 if (is_error) {
[10:22:51.788]                   sessionInformation <- function() {
[10:22:51.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.788]                       search = base::search(), system = base::Sys.info())
[10:22:51.788]                   }
[10:22:51.788]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.788]                     cond$call), session = sessionInformation(), 
[10:22:51.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.788]                   signalCondition(cond)
[10:22:51.788]                 }
[10:22:51.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.788]                 "immediateCondition"))) {
[10:22:51.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.788]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.788]                   if (TRUE && !signal) {
[10:22:51.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.788]                     {
[10:22:51.788]                       inherits <- base::inherits
[10:22:51.788]                       invokeRestart <- base::invokeRestart
[10:22:51.788]                       is.null <- base::is.null
[10:22:51.788]                       muffled <- FALSE
[10:22:51.788]                       if (inherits(cond, "message")) {
[10:22:51.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.788]                         if (muffled) 
[10:22:51.788]                           invokeRestart("muffleMessage")
[10:22:51.788]                       }
[10:22:51.788]                       else if (inherits(cond, "warning")) {
[10:22:51.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.788]                         if (muffled) 
[10:22:51.788]                           invokeRestart("muffleWarning")
[10:22:51.788]                       }
[10:22:51.788]                       else if (inherits(cond, "condition")) {
[10:22:51.788]                         if (!is.null(pattern)) {
[10:22:51.788]                           computeRestarts <- base::computeRestarts
[10:22:51.788]                           grepl <- base::grepl
[10:22:51.788]                           restarts <- computeRestarts(cond)
[10:22:51.788]                           for (restart in restarts) {
[10:22:51.788]                             name <- restart$name
[10:22:51.788]                             if (is.null(name)) 
[10:22:51.788]                               next
[10:22:51.788]                             if (!grepl(pattern, name)) 
[10:22:51.788]                               next
[10:22:51.788]                             invokeRestart(restart)
[10:22:51.788]                             muffled <- TRUE
[10:22:51.788]                             break
[10:22:51.788]                           }
[10:22:51.788]                         }
[10:22:51.788]                       }
[10:22:51.788]                       invisible(muffled)
[10:22:51.788]                     }
[10:22:51.788]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.788]                   }
[10:22:51.788]                 }
[10:22:51.788]                 else {
[10:22:51.788]                   if (TRUE) {
[10:22:51.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.788]                     {
[10:22:51.788]                       inherits <- base::inherits
[10:22:51.788]                       invokeRestart <- base::invokeRestart
[10:22:51.788]                       is.null <- base::is.null
[10:22:51.788]                       muffled <- FALSE
[10:22:51.788]                       if (inherits(cond, "message")) {
[10:22:51.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.788]                         if (muffled) 
[10:22:51.788]                           invokeRestart("muffleMessage")
[10:22:51.788]                       }
[10:22:51.788]                       else if (inherits(cond, "warning")) {
[10:22:51.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.788]                         if (muffled) 
[10:22:51.788]                           invokeRestart("muffleWarning")
[10:22:51.788]                       }
[10:22:51.788]                       else if (inherits(cond, "condition")) {
[10:22:51.788]                         if (!is.null(pattern)) {
[10:22:51.788]                           computeRestarts <- base::computeRestarts
[10:22:51.788]                           grepl <- base::grepl
[10:22:51.788]                           restarts <- computeRestarts(cond)
[10:22:51.788]                           for (restart in restarts) {
[10:22:51.788]                             name <- restart$name
[10:22:51.788]                             if (is.null(name)) 
[10:22:51.788]                               next
[10:22:51.788]                             if (!grepl(pattern, name)) 
[10:22:51.788]                               next
[10:22:51.788]                             invokeRestart(restart)
[10:22:51.788]                             muffled <- TRUE
[10:22:51.788]                             break
[10:22:51.788]                           }
[10:22:51.788]                         }
[10:22:51.788]                       }
[10:22:51.788]                       invisible(muffled)
[10:22:51.788]                     }
[10:22:51.788]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.788]                   }
[10:22:51.788]                 }
[10:22:51.788]             }
[10:22:51.788]         }))
[10:22:51.788]     }, error = function(ex) {
[10:22:51.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.788]                 ...future.rng), started = ...future.startTime, 
[10:22:51.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.788]             version = "1.8"), class = "FutureResult")
[10:22:51.788]     }, finally = {
[10:22:51.788]         if (!identical(...future.workdir, getwd())) 
[10:22:51.788]             setwd(...future.workdir)
[10:22:51.788]         {
[10:22:51.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.788]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.788]             }
[10:22:51.788]             base::options(...future.oldOptions)
[10:22:51.788]             if (.Platform$OS.type == "windows") {
[10:22:51.788]                 old_names <- names(...future.oldEnvVars)
[10:22:51.788]                 envs <- base::Sys.getenv()
[10:22:51.788]                 names <- names(envs)
[10:22:51.788]                 common <- intersect(names, old_names)
[10:22:51.788]                 added <- setdiff(names, old_names)
[10:22:51.788]                 removed <- setdiff(old_names, names)
[10:22:51.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.788]                   envs[common]]
[10:22:51.788]                 NAMES <- toupper(changed)
[10:22:51.788]                 args <- list()
[10:22:51.788]                 for (kk in seq_along(NAMES)) {
[10:22:51.788]                   name <- changed[[kk]]
[10:22:51.788]                   NAME <- NAMES[[kk]]
[10:22:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.788]                     next
[10:22:51.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.788]                 }
[10:22:51.788]                 NAMES <- toupper(added)
[10:22:51.788]                 for (kk in seq_along(NAMES)) {
[10:22:51.788]                   name <- added[[kk]]
[10:22:51.788]                   NAME <- NAMES[[kk]]
[10:22:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.788]                     next
[10:22:51.788]                   args[[name]] <- ""
[10:22:51.788]                 }
[10:22:51.788]                 NAMES <- toupper(removed)
[10:22:51.788]                 for (kk in seq_along(NAMES)) {
[10:22:51.788]                   name <- removed[[kk]]
[10:22:51.788]                   NAME <- NAMES[[kk]]
[10:22:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.788]                     next
[10:22:51.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.788]                 }
[10:22:51.788]                 if (length(args) > 0) 
[10:22:51.788]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.788]             }
[10:22:51.788]             else {
[10:22:51.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.788]             }
[10:22:51.788]             {
[10:22:51.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.788]                   0L) {
[10:22:51.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.788]                   base::options(opts)
[10:22:51.788]                 }
[10:22:51.788]                 {
[10:22:51.788]                   {
[10:22:51.788]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.788]                     NULL
[10:22:51.788]                   }
[10:22:51.788]                   options(future.plan = NULL)
[10:22:51.788]                   if (is.na(NA_character_)) 
[10:22:51.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.788]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.788]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.788]                     envir = parent.frame()) 
[10:22:51.788]                   {
[10:22:51.788]                     if (is.function(workers)) 
[10:22:51.788]                       workers <- workers()
[10:22:51.788]                     workers <- structure(as.integer(workers), 
[10:22:51.788]                       class = class(workers))
[10:22:51.788]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.788]                       workers >= 1)
[10:22:51.788]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.788]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.788]                     }
[10:22:51.788]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.788]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.788]                       envir = envir)
[10:22:51.788]                     if (!future$lazy) 
[10:22:51.788]                       future <- run(future)
[10:22:51.788]                     invisible(future)
[10:22:51.788]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.788]                 }
[10:22:51.788]             }
[10:22:51.788]         }
[10:22:51.788]     })
[10:22:51.788]     if (TRUE) {
[10:22:51.788]         base::sink(type = "output", split = FALSE)
[10:22:51.788]         if (TRUE) {
[10:22:51.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.788]         }
[10:22:51.788]         else {
[10:22:51.788]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.788]         }
[10:22:51.788]         base::close(...future.stdout)
[10:22:51.788]         ...future.stdout <- NULL
[10:22:51.788]     }
[10:22:51.788]     ...future.result$conditions <- ...future.conditions
[10:22:51.788]     ...future.result$finished <- base::Sys.time()
[10:22:51.788]     ...future.result
[10:22:51.788] }
[10:22:51.790] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[10:22:51.790] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[10:22:51.791] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[10:22:51.791] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[10:22:51.791] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[10:22:51.791] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[10:22:51.792] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[10:22:51.792] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:51.792] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.792] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:22:51.793] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:22:51.793] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:51.793] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.793] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:22:51.794] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.794] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[10:22:51.794] MultisessionFuture started
[10:22:51.794] - Launch lazy future ... done
[10:22:51.794] run() for ‘MultisessionFuture’ ... done
[10:22:51.795] Created future:
[10:22:51.795] MultisessionFuture:
[10:22:51.795] Label: ‘future_by-2’
[10:22:51.795] Expression:
[10:22:51.795] {
[10:22:51.795]     do.call(function(...) {
[10:22:51.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.795]             on.exit(options(oopts), add = TRUE)
[10:22:51.795]         }
[10:22:51.795]         {
[10:22:51.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.795]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.795]             })
[10:22:51.795]         }
[10:22:51.795]     }, args = future.call.arguments)
[10:22:51.795] }
[10:22:51.795] Lazy evaluation: FALSE
[10:22:51.795] Asynchronous evaluation: TRUE
[10:22:51.795] Local evaluation: TRUE
[10:22:51.795] Environment: 0x55f63a78f0f0
[10:22:51.795] Capture standard output: TRUE
[10:22:51.795] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.795] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[10:22:51.795] Packages: 1 packages (‘stats’)
[10:22:51.795] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.795] Resolved: FALSE
[10:22:51.795] Value: <not collected>
[10:22:51.795] Conditions captured: <none>
[10:22:51.795] Early signaling: FALSE
[10:22:51.795] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.795] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.806] Chunk #2 of 2 ... DONE
[10:22:51.806] Launching 2 futures (chunks) ... DONE
[10:22:51.807] Resolving 2 futures (chunks) ...
[10:22:51.807] resolve() on list ...
[10:22:51.807]  recursive: 0
[10:22:51.807]  length: 2
[10:22:51.807] 
[10:22:51.807] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.807] - Validating connection of MultisessionFuture
[10:22:51.808] - received message: FutureResult
[10:22:51.808] - Received FutureResult
[10:22:51.808] - Erased future from FutureRegistry
[10:22:51.808] result() for ClusterFuture ...
[10:22:51.808] - result already collected: FutureResult
[10:22:51.808] result() for ClusterFuture ... done
[10:22:51.808] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.808] Future #1
[10:22:51.808] result() for ClusterFuture ...
[10:22:51.809] - result already collected: FutureResult
[10:22:51.809] result() for ClusterFuture ... done
[10:22:51.809] result() for ClusterFuture ...
[10:22:51.809] - result already collected: FutureResult
[10:22:51.809] result() for ClusterFuture ... done
[10:22:51.809] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:51.809] - nx: 2
[10:22:51.809] - relay: TRUE
[10:22:51.809] - stdout: TRUE
[10:22:51.809] - signal: TRUE
[10:22:51.810] - resignal: FALSE
[10:22:51.810] - force: TRUE
[10:22:51.810] - relayed: [n=2] FALSE, FALSE
[10:22:51.810] - queued futures: [n=2] FALSE, FALSE
[10:22:51.810]  - until=1
[10:22:51.810]  - relaying element #1
[10:22:51.810] result() for ClusterFuture ...
[10:22:51.810] - result already collected: FutureResult
[10:22:51.810] result() for ClusterFuture ... done
[10:22:51.810] result() for ClusterFuture ...
[10:22:51.810] - result already collected: FutureResult
[10:22:51.810] result() for ClusterFuture ... done
[10:22:51.811] result() for ClusterFuture ...
[10:22:51.811] - result already collected: FutureResult
[10:22:51.811] result() for ClusterFuture ... done
[10:22:51.811] result() for ClusterFuture ...
[10:22:51.811] - result already collected: FutureResult
[10:22:51.811] result() for ClusterFuture ... done
[10:22:51.811] - relayed: [n=2] TRUE, FALSE
[10:22:51.811] - queued futures: [n=2] TRUE, FALSE
[10:22:51.811] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:51.811]  length: 1 (resolved future 1)
[10:22:51.853] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.853] - Validating connection of MultisessionFuture
[10:22:51.854] - received message: FutureResult
[10:22:51.854] - Received FutureResult
[10:22:51.854] - Erased future from FutureRegistry
[10:22:51.854] result() for ClusterFuture ...
[10:22:51.854] - result already collected: FutureResult
[10:22:51.854] result() for ClusterFuture ... done
[10:22:51.854] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.854] Future #2
[10:22:51.854] result() for ClusterFuture ...
[10:22:51.854] - result already collected: FutureResult
[10:22:51.854] result() for ClusterFuture ... done
[10:22:51.855] result() for ClusterFuture ...
[10:22:51.855] - result already collected: FutureResult
[10:22:51.855] result() for ClusterFuture ... done
[10:22:51.855] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:51.855] - nx: 2
[10:22:51.855] - relay: TRUE
[10:22:51.855] - stdout: TRUE
[10:22:51.855] - signal: TRUE
[10:22:51.855] - resignal: FALSE
[10:22:51.855] - force: TRUE
[10:22:51.855] - relayed: [n=2] TRUE, FALSE
[10:22:51.855] - queued futures: [n=2] TRUE, FALSE
[10:22:51.856]  - until=2
[10:22:51.856]  - relaying element #2
[10:22:51.856] result() for ClusterFuture ...
[10:22:51.856] - result already collected: FutureResult
[10:22:51.856] result() for ClusterFuture ... done
[10:22:51.856] result() for ClusterFuture ...
[10:22:51.856] - result already collected: FutureResult
[10:22:51.856] result() for ClusterFuture ... done
[10:22:51.856] result() for ClusterFuture ...
[10:22:51.856] - result already collected: FutureResult
[10:22:51.856] result() for ClusterFuture ... done
[10:22:51.857] result() for ClusterFuture ...
[10:22:51.857] - result already collected: FutureResult
[10:22:51.857] result() for ClusterFuture ... done
[10:22:51.857] - relayed: [n=2] TRUE, TRUE
[10:22:51.857] - queued futures: [n=2] TRUE, TRUE
[10:22:51.857] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:51.857]  length: 0 (resolved future 2)
[10:22:51.857] Relaying remaining futures
[10:22:51.857] signalConditionsASAP(NULL, pos=0) ...
[10:22:51.857] - nx: 2
[10:22:51.857] - relay: TRUE
[10:22:51.857] - stdout: TRUE
[10:22:51.858] - signal: TRUE
[10:22:51.858] - resignal: FALSE
[10:22:51.858] - force: TRUE
[10:22:51.858] - relayed: [n=2] TRUE, TRUE
[10:22:51.858] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:51.858] - relayed: [n=2] TRUE, TRUE
[10:22:51.858] - queued futures: [n=2] TRUE, TRUE
[10:22:51.858] signalConditionsASAP(NULL, pos=0) ... done
[10:22:51.858] resolve() on list ... DONE
[10:22:51.858] result() for ClusterFuture ...
[10:22:51.858] - result already collected: FutureResult
[10:22:51.858] result() for ClusterFuture ... done
[10:22:51.859] result() for ClusterFuture ...
[10:22:51.859] - result already collected: FutureResult
[10:22:51.859] result() for ClusterFuture ... done
[10:22:51.859] result() for ClusterFuture ...
[10:22:51.859] - result already collected: FutureResult
[10:22:51.859] result() for ClusterFuture ... done
[10:22:51.859] result() for ClusterFuture ...
[10:22:51.859] - result already collected: FutureResult
[10:22:51.859] result() for ClusterFuture ... done
[10:22:51.859]  - Number of value chunks collected: 2
[10:22:51.859] Resolving 2 futures (chunks) ... DONE
[10:22:51.860] Reducing values from 2 chunks ...
[10:22:51.860]  - Number of values collected after concatenation: 3
[10:22:51.860]  - Number of values expected: 3
[10:22:51.860] Reducing values from 2 chunks ... DONE
[10:22:51.860] future_lapply() ... DONE
[10:22:51.860] future_by_internal() ... DONE
[10:22:51.860] future_by_internal() ...
[10:22:51.861] future_lapply() ...
[10:22:51.865] Number of chunks: 2
[10:22:51.865] getGlobalsAndPackagesXApply() ...
[10:22:51.865]  - future.globals: TRUE
[10:22:51.865] getGlobalsAndPackages() ...
[10:22:51.865] Searching for globals...
[10:22:51.866] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:51.866] Searching for globals ... DONE
[10:22:51.866] Resolving globals: FALSE
[10:22:51.867] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:51.867] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:51.867] - globals: [1] ‘FUN’
[10:22:51.867] 
[10:22:51.867] getGlobalsAndPackages() ... DONE
[10:22:51.867]  - globals found/used: [n=1] ‘FUN’
[10:22:51.868]  - needed namespaces: [n=0] 
[10:22:51.868] Finding globals ... DONE
[10:22:51.868]  - use_args: TRUE
[10:22:51.868]  - Getting '...' globals ...
[10:22:51.868] resolve() on list ...
[10:22:51.868]  recursive: 0
[10:22:51.868]  length: 1
[10:22:51.868]  elements: ‘...’
[10:22:51.868]  length: 0 (resolved future 1)
[10:22:51.869] resolve() on list ... DONE
[10:22:51.869]    - '...' content: [n=0] 
[10:22:51.869] List of 1
[10:22:51.869]  $ ...: list()
[10:22:51.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.869]  - attr(*, "where")=List of 1
[10:22:51.869]   ..$ ...:<environment: 0x55f63b184fc8> 
[10:22:51.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.869]  - attr(*, "resolved")= logi TRUE
[10:22:51.869]  - attr(*, "total_size")= num NA
[10:22:51.871]  - Getting '...' globals ... DONE
[10:22:51.871] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:51.872] List of 2
[10:22:51.872]  $ ...future.FUN:function (object, ...)  
[10:22:51.872]  $ ...          : list()
[10:22:51.872]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:51.872]  - attr(*, "where")=List of 2
[10:22:51.872]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:51.872]   ..$ ...          :<environment: 0x55f63b184fc8> 
[10:22:51.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:51.872]  - attr(*, "resolved")= logi FALSE
[10:22:51.872]  - attr(*, "total_size")= num 1240
[10:22:51.874] Packages to be attached in all futures: [n=0] 
[10:22:51.874] getGlobalsAndPackagesXApply() ... DONE
[10:22:51.874] Number of futures (= number of chunks): 2
[10:22:51.875] Launching 2 futures (chunks) ...
[10:22:51.875] Chunk #1 of 2 ...
[10:22:51.875]  - Finding globals in 'X' for chunk #1 ...
[10:22:51.875] getGlobalsAndPackages() ...
[10:22:51.875] Searching for globals...
[10:22:51.875] 
[10:22:51.875] Searching for globals ... DONE
[10:22:51.875] - globals: [0] <none>
[10:22:51.876] getGlobalsAndPackages() ... DONE
[10:22:51.876]    + additional globals found: [n=0] 
[10:22:51.876]    + additional namespaces needed: [n=0] 
[10:22:51.876]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:51.876]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.876]  - seeds: <none>
[10:22:51.876]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.876] getGlobalsAndPackages() ...
[10:22:51.876] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.876] Resolving globals: FALSE
[10:22:51.876] Tweak future expression to call with '...' arguments ...
[10:22:51.877] {
[10:22:51.877]     do.call(function(...) {
[10:22:51.877]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.877]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.877]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.877]             on.exit(options(oopts), add = TRUE)
[10:22:51.877]         }
[10:22:51.877]         {
[10:22:51.877]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.877]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.877]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.877]             })
[10:22:51.877]         }
[10:22:51.877]     }, args = future.call.arguments)
[10:22:51.877] }
[10:22:51.877] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.877] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.877] 
[10:22:51.877] getGlobalsAndPackages() ... DONE
[10:22:51.878] run() for ‘Future’ ...
[10:22:51.878] - state: ‘created’
[10:22:51.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.891] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.891]   - Field: ‘node’
[10:22:51.892]   - Field: ‘label’
[10:22:51.892]   - Field: ‘local’
[10:22:51.892]   - Field: ‘owner’
[10:22:51.892]   - Field: ‘envir’
[10:22:51.892]   - Field: ‘workers’
[10:22:51.892]   - Field: ‘packages’
[10:22:51.892]   - Field: ‘gc’
[10:22:51.892]   - Field: ‘conditions’
[10:22:51.892]   - Field: ‘persistent’
[10:22:51.892]   - Field: ‘expr’
[10:22:51.892]   - Field: ‘uuid’
[10:22:51.893]   - Field: ‘seed’
[10:22:51.893]   - Field: ‘version’
[10:22:51.893]   - Field: ‘result’
[10:22:51.893]   - Field: ‘asynchronous’
[10:22:51.893]   - Field: ‘calls’
[10:22:51.893]   - Field: ‘globals’
[10:22:51.893]   - Field: ‘stdout’
[10:22:51.893]   - Field: ‘earlySignal’
[10:22:51.893]   - Field: ‘lazy’
[10:22:51.893]   - Field: ‘state’
[10:22:51.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.894] - Launch lazy future ...
[10:22:51.894] Packages needed by the future expression (n = 0): <none>
[10:22:51.894] Packages needed by future strategies (n = 0): <none>
[10:22:51.894] {
[10:22:51.894]     {
[10:22:51.894]         {
[10:22:51.894]             ...future.startTime <- base::Sys.time()
[10:22:51.894]             {
[10:22:51.894]                 {
[10:22:51.894]                   {
[10:22:51.894]                     {
[10:22:51.894]                       base::local({
[10:22:51.894]                         has_future <- base::requireNamespace("future", 
[10:22:51.894]                           quietly = TRUE)
[10:22:51.894]                         if (has_future) {
[10:22:51.894]                           ns <- base::getNamespace("future")
[10:22:51.894]                           version <- ns[[".package"]][["version"]]
[10:22:51.894]                           if (is.null(version)) 
[10:22:51.894]                             version <- utils::packageVersion("future")
[10:22:51.894]                         }
[10:22:51.894]                         else {
[10:22:51.894]                           version <- NULL
[10:22:51.894]                         }
[10:22:51.894]                         if (!has_future || version < "1.8.0") {
[10:22:51.894]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.894]                             "", base::R.version$version.string), 
[10:22:51.894]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.894]                               "release", "version")], collapse = " "), 
[10:22:51.894]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.894]                             info)
[10:22:51.894]                           info <- base::paste(info, collapse = "; ")
[10:22:51.894]                           if (!has_future) {
[10:22:51.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.894]                               info)
[10:22:51.894]                           }
[10:22:51.894]                           else {
[10:22:51.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.894]                               info, version)
[10:22:51.894]                           }
[10:22:51.894]                           base::stop(msg)
[10:22:51.894]                         }
[10:22:51.894]                       })
[10:22:51.894]                     }
[10:22:51.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.894]                     base::options(mc.cores = 1L)
[10:22:51.894]                   }
[10:22:51.894]                   options(future.plan = NULL)
[10:22:51.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.894]                 }
[10:22:51.894]                 ...future.workdir <- getwd()
[10:22:51.894]             }
[10:22:51.894]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.894]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.894]         }
[10:22:51.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.894]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.894]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.894]             base::names(...future.oldOptions))
[10:22:51.894]     }
[10:22:51.894]     if (FALSE) {
[10:22:51.894]     }
[10:22:51.894]     else {
[10:22:51.894]         if (TRUE) {
[10:22:51.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.894]                 open = "w")
[10:22:51.894]         }
[10:22:51.894]         else {
[10:22:51.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.894]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.894]         }
[10:22:51.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.894]             base::sink(type = "output", split = FALSE)
[10:22:51.894]             base::close(...future.stdout)
[10:22:51.894]         }, add = TRUE)
[10:22:51.894]     }
[10:22:51.894]     ...future.frame <- base::sys.nframe()
[10:22:51.894]     ...future.conditions <- base::list()
[10:22:51.894]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.894]     if (FALSE) {
[10:22:51.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.894]     }
[10:22:51.894]     ...future.result <- base::tryCatch({
[10:22:51.894]         base::withCallingHandlers({
[10:22:51.894]             ...future.value <- base::withVisible(base::local({
[10:22:51.894]                 ...future.makeSendCondition <- base::local({
[10:22:51.894]                   sendCondition <- NULL
[10:22:51.894]                   function(frame = 1L) {
[10:22:51.894]                     if (is.function(sendCondition)) 
[10:22:51.894]                       return(sendCondition)
[10:22:51.894]                     ns <- getNamespace("parallel")
[10:22:51.894]                     if (exists("sendData", mode = "function", 
[10:22:51.894]                       envir = ns)) {
[10:22:51.894]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.894]                         envir = ns)
[10:22:51.894]                       envir <- sys.frame(frame)
[10:22:51.894]                       master <- NULL
[10:22:51.894]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.894]                         !identical(envir, emptyenv())) {
[10:22:51.894]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.894]                           inherits = FALSE)) {
[10:22:51.894]                           master <- get("master", mode = "list", 
[10:22:51.894]                             envir = envir, inherits = FALSE)
[10:22:51.894]                           if (inherits(master, c("SOCKnode", 
[10:22:51.894]                             "SOCK0node"))) {
[10:22:51.894]                             sendCondition <<- function(cond) {
[10:22:51.894]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.894]                                 success = TRUE)
[10:22:51.894]                               parallel_sendData(master, data)
[10:22:51.894]                             }
[10:22:51.894]                             return(sendCondition)
[10:22:51.894]                           }
[10:22:51.894]                         }
[10:22:51.894]                         frame <- frame + 1L
[10:22:51.894]                         envir <- sys.frame(frame)
[10:22:51.894]                       }
[10:22:51.894]                     }
[10:22:51.894]                     sendCondition <<- function(cond) NULL
[10:22:51.894]                   }
[10:22:51.894]                 })
[10:22:51.894]                 withCallingHandlers({
[10:22:51.894]                   {
[10:22:51.894]                     do.call(function(...) {
[10:22:51.894]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.894]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.894]                         ...future.globals.maxSize)) {
[10:22:51.894]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.894]                         on.exit(options(oopts), add = TRUE)
[10:22:51.894]                       }
[10:22:51.894]                       {
[10:22:51.894]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.894]                           FUN = function(jj) {
[10:22:51.894]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.894]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.894]                           })
[10:22:51.894]                       }
[10:22:51.894]                     }, args = future.call.arguments)
[10:22:51.894]                   }
[10:22:51.894]                 }, immediateCondition = function(cond) {
[10:22:51.894]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.894]                   sendCondition(cond)
[10:22:51.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.894]                   {
[10:22:51.894]                     inherits <- base::inherits
[10:22:51.894]                     invokeRestart <- base::invokeRestart
[10:22:51.894]                     is.null <- base::is.null
[10:22:51.894]                     muffled <- FALSE
[10:22:51.894]                     if (inherits(cond, "message")) {
[10:22:51.894]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.894]                       if (muffled) 
[10:22:51.894]                         invokeRestart("muffleMessage")
[10:22:51.894]                     }
[10:22:51.894]                     else if (inherits(cond, "warning")) {
[10:22:51.894]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.894]                       if (muffled) 
[10:22:51.894]                         invokeRestart("muffleWarning")
[10:22:51.894]                     }
[10:22:51.894]                     else if (inherits(cond, "condition")) {
[10:22:51.894]                       if (!is.null(pattern)) {
[10:22:51.894]                         computeRestarts <- base::computeRestarts
[10:22:51.894]                         grepl <- base::grepl
[10:22:51.894]                         restarts <- computeRestarts(cond)
[10:22:51.894]                         for (restart in restarts) {
[10:22:51.894]                           name <- restart$name
[10:22:51.894]                           if (is.null(name)) 
[10:22:51.894]                             next
[10:22:51.894]                           if (!grepl(pattern, name)) 
[10:22:51.894]                             next
[10:22:51.894]                           invokeRestart(restart)
[10:22:51.894]                           muffled <- TRUE
[10:22:51.894]                           break
[10:22:51.894]                         }
[10:22:51.894]                       }
[10:22:51.894]                     }
[10:22:51.894]                     invisible(muffled)
[10:22:51.894]                   }
[10:22:51.894]                   muffleCondition(cond)
[10:22:51.894]                 })
[10:22:51.894]             }))
[10:22:51.894]             future::FutureResult(value = ...future.value$value, 
[10:22:51.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.894]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.894]                     ...future.globalenv.names))
[10:22:51.894]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.894]         }, condition = base::local({
[10:22:51.894]             c <- base::c
[10:22:51.894]             inherits <- base::inherits
[10:22:51.894]             invokeRestart <- base::invokeRestart
[10:22:51.894]             length <- base::length
[10:22:51.894]             list <- base::list
[10:22:51.894]             seq.int <- base::seq.int
[10:22:51.894]             signalCondition <- base::signalCondition
[10:22:51.894]             sys.calls <- base::sys.calls
[10:22:51.894]             `[[` <- base::`[[`
[10:22:51.894]             `+` <- base::`+`
[10:22:51.894]             `<<-` <- base::`<<-`
[10:22:51.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.894]                   3L)]
[10:22:51.894]             }
[10:22:51.894]             function(cond) {
[10:22:51.894]                 is_error <- inherits(cond, "error")
[10:22:51.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.894]                   NULL)
[10:22:51.894]                 if (is_error) {
[10:22:51.894]                   sessionInformation <- function() {
[10:22:51.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.894]                       search = base::search(), system = base::Sys.info())
[10:22:51.894]                   }
[10:22:51.894]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.894]                     cond$call), session = sessionInformation(), 
[10:22:51.894]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.894]                   signalCondition(cond)
[10:22:51.894]                 }
[10:22:51.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.894]                 "immediateCondition"))) {
[10:22:51.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.894]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.894]                   if (TRUE && !signal) {
[10:22:51.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.894]                     {
[10:22:51.894]                       inherits <- base::inherits
[10:22:51.894]                       invokeRestart <- base::invokeRestart
[10:22:51.894]                       is.null <- base::is.null
[10:22:51.894]                       muffled <- FALSE
[10:22:51.894]                       if (inherits(cond, "message")) {
[10:22:51.894]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.894]                         if (muffled) 
[10:22:51.894]                           invokeRestart("muffleMessage")
[10:22:51.894]                       }
[10:22:51.894]                       else if (inherits(cond, "warning")) {
[10:22:51.894]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.894]                         if (muffled) 
[10:22:51.894]                           invokeRestart("muffleWarning")
[10:22:51.894]                       }
[10:22:51.894]                       else if (inherits(cond, "condition")) {
[10:22:51.894]                         if (!is.null(pattern)) {
[10:22:51.894]                           computeRestarts <- base::computeRestarts
[10:22:51.894]                           grepl <- base::grepl
[10:22:51.894]                           restarts <- computeRestarts(cond)
[10:22:51.894]                           for (restart in restarts) {
[10:22:51.894]                             name <- restart$name
[10:22:51.894]                             if (is.null(name)) 
[10:22:51.894]                               next
[10:22:51.894]                             if (!grepl(pattern, name)) 
[10:22:51.894]                               next
[10:22:51.894]                             invokeRestart(restart)
[10:22:51.894]                             muffled <- TRUE
[10:22:51.894]                             break
[10:22:51.894]                           }
[10:22:51.894]                         }
[10:22:51.894]                       }
[10:22:51.894]                       invisible(muffled)
[10:22:51.894]                     }
[10:22:51.894]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.894]                   }
[10:22:51.894]                 }
[10:22:51.894]                 else {
[10:22:51.894]                   if (TRUE) {
[10:22:51.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.894]                     {
[10:22:51.894]                       inherits <- base::inherits
[10:22:51.894]                       invokeRestart <- base::invokeRestart
[10:22:51.894]                       is.null <- base::is.null
[10:22:51.894]                       muffled <- FALSE
[10:22:51.894]                       if (inherits(cond, "message")) {
[10:22:51.894]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.894]                         if (muffled) 
[10:22:51.894]                           invokeRestart("muffleMessage")
[10:22:51.894]                       }
[10:22:51.894]                       else if (inherits(cond, "warning")) {
[10:22:51.894]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.894]                         if (muffled) 
[10:22:51.894]                           invokeRestart("muffleWarning")
[10:22:51.894]                       }
[10:22:51.894]                       else if (inherits(cond, "condition")) {
[10:22:51.894]                         if (!is.null(pattern)) {
[10:22:51.894]                           computeRestarts <- base::computeRestarts
[10:22:51.894]                           grepl <- base::grepl
[10:22:51.894]                           restarts <- computeRestarts(cond)
[10:22:51.894]                           for (restart in restarts) {
[10:22:51.894]                             name <- restart$name
[10:22:51.894]                             if (is.null(name)) 
[10:22:51.894]                               next
[10:22:51.894]                             if (!grepl(pattern, name)) 
[10:22:51.894]                               next
[10:22:51.894]                             invokeRestart(restart)
[10:22:51.894]                             muffled <- TRUE
[10:22:51.894]                             break
[10:22:51.894]                           }
[10:22:51.894]                         }
[10:22:51.894]                       }
[10:22:51.894]                       invisible(muffled)
[10:22:51.894]                     }
[10:22:51.894]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.894]                   }
[10:22:51.894]                 }
[10:22:51.894]             }
[10:22:51.894]         }))
[10:22:51.894]     }, error = function(ex) {
[10:22:51.894]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.894]                 ...future.rng), started = ...future.startTime, 
[10:22:51.894]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.894]             version = "1.8"), class = "FutureResult")
[10:22:51.894]     }, finally = {
[10:22:51.894]         if (!identical(...future.workdir, getwd())) 
[10:22:51.894]             setwd(...future.workdir)
[10:22:51.894]         {
[10:22:51.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.894]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.894]             }
[10:22:51.894]             base::options(...future.oldOptions)
[10:22:51.894]             if (.Platform$OS.type == "windows") {
[10:22:51.894]                 old_names <- names(...future.oldEnvVars)
[10:22:51.894]                 envs <- base::Sys.getenv()
[10:22:51.894]                 names <- names(envs)
[10:22:51.894]                 common <- intersect(names, old_names)
[10:22:51.894]                 added <- setdiff(names, old_names)
[10:22:51.894]                 removed <- setdiff(old_names, names)
[10:22:51.894]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.894]                   envs[common]]
[10:22:51.894]                 NAMES <- toupper(changed)
[10:22:51.894]                 args <- list()
[10:22:51.894]                 for (kk in seq_along(NAMES)) {
[10:22:51.894]                   name <- changed[[kk]]
[10:22:51.894]                   NAME <- NAMES[[kk]]
[10:22:51.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.894]                     next
[10:22:51.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.894]                 }
[10:22:51.894]                 NAMES <- toupper(added)
[10:22:51.894]                 for (kk in seq_along(NAMES)) {
[10:22:51.894]                   name <- added[[kk]]
[10:22:51.894]                   NAME <- NAMES[[kk]]
[10:22:51.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.894]                     next
[10:22:51.894]                   args[[name]] <- ""
[10:22:51.894]                 }
[10:22:51.894]                 NAMES <- toupper(removed)
[10:22:51.894]                 for (kk in seq_along(NAMES)) {
[10:22:51.894]                   name <- removed[[kk]]
[10:22:51.894]                   NAME <- NAMES[[kk]]
[10:22:51.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.894]                     next
[10:22:51.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.894]                 }
[10:22:51.894]                 if (length(args) > 0) 
[10:22:51.894]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.894]             }
[10:22:51.894]             else {
[10:22:51.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.894]             }
[10:22:51.894]             {
[10:22:51.894]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.894]                   0L) {
[10:22:51.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.894]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.894]                   base::options(opts)
[10:22:51.894]                 }
[10:22:51.894]                 {
[10:22:51.894]                   {
[10:22:51.894]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.894]                     NULL
[10:22:51.894]                   }
[10:22:51.894]                   options(future.plan = NULL)
[10:22:51.894]                   if (is.na(NA_character_)) 
[10:22:51.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.894]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.894]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.894]                     envir = parent.frame()) 
[10:22:51.894]                   {
[10:22:51.894]                     if (is.function(workers)) 
[10:22:51.894]                       workers <- workers()
[10:22:51.894]                     workers <- structure(as.integer(workers), 
[10:22:51.894]                       class = class(workers))
[10:22:51.894]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.894]                       workers >= 1)
[10:22:51.894]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.894]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.894]                     }
[10:22:51.894]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.894]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.894]                       envir = envir)
[10:22:51.894]                     if (!future$lazy) 
[10:22:51.894]                       future <- run(future)
[10:22:51.894]                     invisible(future)
[10:22:51.894]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.894]                 }
[10:22:51.894]             }
[10:22:51.894]         }
[10:22:51.894]     })
[10:22:51.894]     if (TRUE) {
[10:22:51.894]         base::sink(type = "output", split = FALSE)
[10:22:51.894]         if (TRUE) {
[10:22:51.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.894]         }
[10:22:51.894]         else {
[10:22:51.894]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.894]         }
[10:22:51.894]         base::close(...future.stdout)
[10:22:51.894]         ...future.stdout <- NULL
[10:22:51.894]     }
[10:22:51.894]     ...future.result$conditions <- ...future.conditions
[10:22:51.894]     ...future.result$finished <- base::Sys.time()
[10:22:51.894]     ...future.result
[10:22:51.894] }
[10:22:51.897] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:22:51.897] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:22:51.898] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:22:51.898] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:51.898] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.898] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:22:51.899] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:22:51.899] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:51.899] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.899] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:22:51.900] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:22:51.900] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:22:51.900] MultisessionFuture started
[10:22:51.900] - Launch lazy future ... done
[10:22:51.900] run() for ‘MultisessionFuture’ ... done
[10:22:51.901] Created future:
[10:22:51.901] MultisessionFuture:
[10:22:51.901] Label: ‘future_by-1’
[10:22:51.901] Expression:
[10:22:51.901] {
[10:22:51.901]     do.call(function(...) {
[10:22:51.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.901]             on.exit(options(oopts), add = TRUE)
[10:22:51.901]         }
[10:22:51.901]         {
[10:22:51.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.901]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.901]             })
[10:22:51.901]         }
[10:22:51.901]     }, args = future.call.arguments)
[10:22:51.901] }
[10:22:51.901] Lazy evaluation: FALSE
[10:22:51.901] Asynchronous evaluation: TRUE
[10:22:51.901] Local evaluation: TRUE
[10:22:51.901] Environment: 0x55f63b1af898
[10:22:51.901] Capture standard output: TRUE
[10:22:51.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.901] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.901] Packages: <none>
[10:22:51.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.901] Resolved: FALSE
[10:22:51.901] Value: <not collected>
[10:22:51.901] Conditions captured: <none>
[10:22:51.901] Early signaling: FALSE
[10:22:51.901] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.901] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.912] Chunk #1 of 2 ... DONE
[10:22:51.912] Chunk #2 of 2 ...
[10:22:51.912]  - Finding globals in 'X' for chunk #2 ...
[10:22:51.913] getGlobalsAndPackages() ...
[10:22:51.913] Searching for globals...
[10:22:51.913] 
[10:22:51.913] Searching for globals ... DONE
[10:22:51.913] - globals: [0] <none>
[10:22:51.913] getGlobalsAndPackages() ... DONE
[10:22:51.914]    + additional globals found: [n=0] 
[10:22:51.914]    + additional namespaces needed: [n=0] 
[10:22:51.914]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:51.914]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:51.914]  - seeds: <none>
[10:22:51.914]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.914] getGlobalsAndPackages() ...
[10:22:51.914] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.914] Resolving globals: FALSE
[10:22:51.914] Tweak future expression to call with '...' arguments ...
[10:22:51.915] {
[10:22:51.915]     do.call(function(...) {
[10:22:51.915]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.915]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.915]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.915]             on.exit(options(oopts), add = TRUE)
[10:22:51.915]         }
[10:22:51.915]         {
[10:22:51.915]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.915]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.915]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.915]             })
[10:22:51.915]         }
[10:22:51.915]     }, args = future.call.arguments)
[10:22:51.915] }
[10:22:51.915] Tweak future expression to call with '...' arguments ... DONE
[10:22:51.915] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:51.915] 
[10:22:51.915] getGlobalsAndPackages() ... DONE
[10:22:51.916] run() for ‘Future’ ...
[10:22:51.916] - state: ‘created’
[10:22:51.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:51.930] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:51.930]   - Field: ‘node’
[10:22:51.930]   - Field: ‘label’
[10:22:51.930]   - Field: ‘local’
[10:22:51.931]   - Field: ‘owner’
[10:22:51.931]   - Field: ‘envir’
[10:22:51.931]   - Field: ‘workers’
[10:22:51.931]   - Field: ‘packages’
[10:22:51.931]   - Field: ‘gc’
[10:22:51.931]   - Field: ‘conditions’
[10:22:51.931]   - Field: ‘persistent’
[10:22:51.931]   - Field: ‘expr’
[10:22:51.931]   - Field: ‘uuid’
[10:22:51.931]   - Field: ‘seed’
[10:22:51.931]   - Field: ‘version’
[10:22:51.932]   - Field: ‘result’
[10:22:51.932]   - Field: ‘asynchronous’
[10:22:51.932]   - Field: ‘calls’
[10:22:51.932]   - Field: ‘globals’
[10:22:51.932]   - Field: ‘stdout’
[10:22:51.932]   - Field: ‘earlySignal’
[10:22:51.932]   - Field: ‘lazy’
[10:22:51.932]   - Field: ‘state’
[10:22:51.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:51.932] - Launch lazy future ...
[10:22:51.933] Packages needed by the future expression (n = 0): <none>
[10:22:51.933] Packages needed by future strategies (n = 0): <none>
[10:22:51.933] {
[10:22:51.933]     {
[10:22:51.933]         {
[10:22:51.933]             ...future.startTime <- base::Sys.time()
[10:22:51.933]             {
[10:22:51.933]                 {
[10:22:51.933]                   {
[10:22:51.933]                     {
[10:22:51.933]                       base::local({
[10:22:51.933]                         has_future <- base::requireNamespace("future", 
[10:22:51.933]                           quietly = TRUE)
[10:22:51.933]                         if (has_future) {
[10:22:51.933]                           ns <- base::getNamespace("future")
[10:22:51.933]                           version <- ns[[".package"]][["version"]]
[10:22:51.933]                           if (is.null(version)) 
[10:22:51.933]                             version <- utils::packageVersion("future")
[10:22:51.933]                         }
[10:22:51.933]                         else {
[10:22:51.933]                           version <- NULL
[10:22:51.933]                         }
[10:22:51.933]                         if (!has_future || version < "1.8.0") {
[10:22:51.933]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:51.933]                             "", base::R.version$version.string), 
[10:22:51.933]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:51.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:51.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:51.933]                               "release", "version")], collapse = " "), 
[10:22:51.933]                             hostname = base::Sys.info()[["nodename"]])
[10:22:51.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:51.933]                             info)
[10:22:51.933]                           info <- base::paste(info, collapse = "; ")
[10:22:51.933]                           if (!has_future) {
[10:22:51.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:51.933]                               info)
[10:22:51.933]                           }
[10:22:51.933]                           else {
[10:22:51.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:51.933]                               info, version)
[10:22:51.933]                           }
[10:22:51.933]                           base::stop(msg)
[10:22:51.933]                         }
[10:22:51.933]                       })
[10:22:51.933]                     }
[10:22:51.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:51.933]                     base::options(mc.cores = 1L)
[10:22:51.933]                   }
[10:22:51.933]                   options(future.plan = NULL)
[10:22:51.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:51.933]                 }
[10:22:51.933]                 ...future.workdir <- getwd()
[10:22:51.933]             }
[10:22:51.933]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:51.933]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:51.933]         }
[10:22:51.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:51.933]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:51.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:51.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:51.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:51.933]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:51.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:51.933]             base::names(...future.oldOptions))
[10:22:51.933]     }
[10:22:51.933]     if (FALSE) {
[10:22:51.933]     }
[10:22:51.933]     else {
[10:22:51.933]         if (TRUE) {
[10:22:51.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:51.933]                 open = "w")
[10:22:51.933]         }
[10:22:51.933]         else {
[10:22:51.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:51.933]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:51.933]         }
[10:22:51.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:51.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:51.933]             base::sink(type = "output", split = FALSE)
[10:22:51.933]             base::close(...future.stdout)
[10:22:51.933]         }, add = TRUE)
[10:22:51.933]     }
[10:22:51.933]     ...future.frame <- base::sys.nframe()
[10:22:51.933]     ...future.conditions <- base::list()
[10:22:51.933]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:51.933]     if (FALSE) {
[10:22:51.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:51.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:51.933]     }
[10:22:51.933]     ...future.result <- base::tryCatch({
[10:22:51.933]         base::withCallingHandlers({
[10:22:51.933]             ...future.value <- base::withVisible(base::local({
[10:22:51.933]                 ...future.makeSendCondition <- base::local({
[10:22:51.933]                   sendCondition <- NULL
[10:22:51.933]                   function(frame = 1L) {
[10:22:51.933]                     if (is.function(sendCondition)) 
[10:22:51.933]                       return(sendCondition)
[10:22:51.933]                     ns <- getNamespace("parallel")
[10:22:51.933]                     if (exists("sendData", mode = "function", 
[10:22:51.933]                       envir = ns)) {
[10:22:51.933]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:51.933]                         envir = ns)
[10:22:51.933]                       envir <- sys.frame(frame)
[10:22:51.933]                       master <- NULL
[10:22:51.933]                       while (!identical(envir, .GlobalEnv) && 
[10:22:51.933]                         !identical(envir, emptyenv())) {
[10:22:51.933]                         if (exists("master", mode = "list", envir = envir, 
[10:22:51.933]                           inherits = FALSE)) {
[10:22:51.933]                           master <- get("master", mode = "list", 
[10:22:51.933]                             envir = envir, inherits = FALSE)
[10:22:51.933]                           if (inherits(master, c("SOCKnode", 
[10:22:51.933]                             "SOCK0node"))) {
[10:22:51.933]                             sendCondition <<- function(cond) {
[10:22:51.933]                               data <- list(type = "VALUE", value = cond, 
[10:22:51.933]                                 success = TRUE)
[10:22:51.933]                               parallel_sendData(master, data)
[10:22:51.933]                             }
[10:22:51.933]                             return(sendCondition)
[10:22:51.933]                           }
[10:22:51.933]                         }
[10:22:51.933]                         frame <- frame + 1L
[10:22:51.933]                         envir <- sys.frame(frame)
[10:22:51.933]                       }
[10:22:51.933]                     }
[10:22:51.933]                     sendCondition <<- function(cond) NULL
[10:22:51.933]                   }
[10:22:51.933]                 })
[10:22:51.933]                 withCallingHandlers({
[10:22:51.933]                   {
[10:22:51.933]                     do.call(function(...) {
[10:22:51.933]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.933]                       if (!identical(...future.globals.maxSize.org, 
[10:22:51.933]                         ...future.globals.maxSize)) {
[10:22:51.933]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.933]                         on.exit(options(oopts), add = TRUE)
[10:22:51.933]                       }
[10:22:51.933]                       {
[10:22:51.933]                         lapply(seq_along(...future.elements_ii), 
[10:22:51.933]                           FUN = function(jj) {
[10:22:51.933]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.933]                             ...future.FUN(...future.X_jj, ...)
[10:22:51.933]                           })
[10:22:51.933]                       }
[10:22:51.933]                     }, args = future.call.arguments)
[10:22:51.933]                   }
[10:22:51.933]                 }, immediateCondition = function(cond) {
[10:22:51.933]                   sendCondition <- ...future.makeSendCondition()
[10:22:51.933]                   sendCondition(cond)
[10:22:51.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.933]                   {
[10:22:51.933]                     inherits <- base::inherits
[10:22:51.933]                     invokeRestart <- base::invokeRestart
[10:22:51.933]                     is.null <- base::is.null
[10:22:51.933]                     muffled <- FALSE
[10:22:51.933]                     if (inherits(cond, "message")) {
[10:22:51.933]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:51.933]                       if (muffled) 
[10:22:51.933]                         invokeRestart("muffleMessage")
[10:22:51.933]                     }
[10:22:51.933]                     else if (inherits(cond, "warning")) {
[10:22:51.933]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:51.933]                       if (muffled) 
[10:22:51.933]                         invokeRestart("muffleWarning")
[10:22:51.933]                     }
[10:22:51.933]                     else if (inherits(cond, "condition")) {
[10:22:51.933]                       if (!is.null(pattern)) {
[10:22:51.933]                         computeRestarts <- base::computeRestarts
[10:22:51.933]                         grepl <- base::grepl
[10:22:51.933]                         restarts <- computeRestarts(cond)
[10:22:51.933]                         for (restart in restarts) {
[10:22:51.933]                           name <- restart$name
[10:22:51.933]                           if (is.null(name)) 
[10:22:51.933]                             next
[10:22:51.933]                           if (!grepl(pattern, name)) 
[10:22:51.933]                             next
[10:22:51.933]                           invokeRestart(restart)
[10:22:51.933]                           muffled <- TRUE
[10:22:51.933]                           break
[10:22:51.933]                         }
[10:22:51.933]                       }
[10:22:51.933]                     }
[10:22:51.933]                     invisible(muffled)
[10:22:51.933]                   }
[10:22:51.933]                   muffleCondition(cond)
[10:22:51.933]                 })
[10:22:51.933]             }))
[10:22:51.933]             future::FutureResult(value = ...future.value$value, 
[10:22:51.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.933]                   ...future.rng), globalenv = if (FALSE) 
[10:22:51.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:51.933]                     ...future.globalenv.names))
[10:22:51.933]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:51.933]         }, condition = base::local({
[10:22:51.933]             c <- base::c
[10:22:51.933]             inherits <- base::inherits
[10:22:51.933]             invokeRestart <- base::invokeRestart
[10:22:51.933]             length <- base::length
[10:22:51.933]             list <- base::list
[10:22:51.933]             seq.int <- base::seq.int
[10:22:51.933]             signalCondition <- base::signalCondition
[10:22:51.933]             sys.calls <- base::sys.calls
[10:22:51.933]             `[[` <- base::`[[`
[10:22:51.933]             `+` <- base::`+`
[10:22:51.933]             `<<-` <- base::`<<-`
[10:22:51.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:51.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:51.933]                   3L)]
[10:22:51.933]             }
[10:22:51.933]             function(cond) {
[10:22:51.933]                 is_error <- inherits(cond, "error")
[10:22:51.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:51.933]                   NULL)
[10:22:51.933]                 if (is_error) {
[10:22:51.933]                   sessionInformation <- function() {
[10:22:51.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:51.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:51.933]                       search = base::search(), system = base::Sys.info())
[10:22:51.933]                   }
[10:22:51.933]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:51.933]                     cond$call), session = sessionInformation(), 
[10:22:51.933]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:51.933]                   signalCondition(cond)
[10:22:51.933]                 }
[10:22:51.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:51.933]                 "immediateCondition"))) {
[10:22:51.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:51.933]                   ...future.conditions[[length(...future.conditions) + 
[10:22:51.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:51.933]                   if (TRUE && !signal) {
[10:22:51.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.933]                     {
[10:22:51.933]                       inherits <- base::inherits
[10:22:51.933]                       invokeRestart <- base::invokeRestart
[10:22:51.933]                       is.null <- base::is.null
[10:22:51.933]                       muffled <- FALSE
[10:22:51.933]                       if (inherits(cond, "message")) {
[10:22:51.933]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.933]                         if (muffled) 
[10:22:51.933]                           invokeRestart("muffleMessage")
[10:22:51.933]                       }
[10:22:51.933]                       else if (inherits(cond, "warning")) {
[10:22:51.933]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.933]                         if (muffled) 
[10:22:51.933]                           invokeRestart("muffleWarning")
[10:22:51.933]                       }
[10:22:51.933]                       else if (inherits(cond, "condition")) {
[10:22:51.933]                         if (!is.null(pattern)) {
[10:22:51.933]                           computeRestarts <- base::computeRestarts
[10:22:51.933]                           grepl <- base::grepl
[10:22:51.933]                           restarts <- computeRestarts(cond)
[10:22:51.933]                           for (restart in restarts) {
[10:22:51.933]                             name <- restart$name
[10:22:51.933]                             if (is.null(name)) 
[10:22:51.933]                               next
[10:22:51.933]                             if (!grepl(pattern, name)) 
[10:22:51.933]                               next
[10:22:51.933]                             invokeRestart(restart)
[10:22:51.933]                             muffled <- TRUE
[10:22:51.933]                             break
[10:22:51.933]                           }
[10:22:51.933]                         }
[10:22:51.933]                       }
[10:22:51.933]                       invisible(muffled)
[10:22:51.933]                     }
[10:22:51.933]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.933]                   }
[10:22:51.933]                 }
[10:22:51.933]                 else {
[10:22:51.933]                   if (TRUE) {
[10:22:51.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:51.933]                     {
[10:22:51.933]                       inherits <- base::inherits
[10:22:51.933]                       invokeRestart <- base::invokeRestart
[10:22:51.933]                       is.null <- base::is.null
[10:22:51.933]                       muffled <- FALSE
[10:22:51.933]                       if (inherits(cond, "message")) {
[10:22:51.933]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:51.933]                         if (muffled) 
[10:22:51.933]                           invokeRestart("muffleMessage")
[10:22:51.933]                       }
[10:22:51.933]                       else if (inherits(cond, "warning")) {
[10:22:51.933]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:51.933]                         if (muffled) 
[10:22:51.933]                           invokeRestart("muffleWarning")
[10:22:51.933]                       }
[10:22:51.933]                       else if (inherits(cond, "condition")) {
[10:22:51.933]                         if (!is.null(pattern)) {
[10:22:51.933]                           computeRestarts <- base::computeRestarts
[10:22:51.933]                           grepl <- base::grepl
[10:22:51.933]                           restarts <- computeRestarts(cond)
[10:22:51.933]                           for (restart in restarts) {
[10:22:51.933]                             name <- restart$name
[10:22:51.933]                             if (is.null(name)) 
[10:22:51.933]                               next
[10:22:51.933]                             if (!grepl(pattern, name)) 
[10:22:51.933]                               next
[10:22:51.933]                             invokeRestart(restart)
[10:22:51.933]                             muffled <- TRUE
[10:22:51.933]                             break
[10:22:51.933]                           }
[10:22:51.933]                         }
[10:22:51.933]                       }
[10:22:51.933]                       invisible(muffled)
[10:22:51.933]                     }
[10:22:51.933]                     muffleCondition(cond, pattern = "^muffle")
[10:22:51.933]                   }
[10:22:51.933]                 }
[10:22:51.933]             }
[10:22:51.933]         }))
[10:22:51.933]     }, error = function(ex) {
[10:22:51.933]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:51.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:51.933]                 ...future.rng), started = ...future.startTime, 
[10:22:51.933]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:51.933]             version = "1.8"), class = "FutureResult")
[10:22:51.933]     }, finally = {
[10:22:51.933]         if (!identical(...future.workdir, getwd())) 
[10:22:51.933]             setwd(...future.workdir)
[10:22:51.933]         {
[10:22:51.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:51.933]                 ...future.oldOptions$nwarnings <- NULL
[10:22:51.933]             }
[10:22:51.933]             base::options(...future.oldOptions)
[10:22:51.933]             if (.Platform$OS.type == "windows") {
[10:22:51.933]                 old_names <- names(...future.oldEnvVars)
[10:22:51.933]                 envs <- base::Sys.getenv()
[10:22:51.933]                 names <- names(envs)
[10:22:51.933]                 common <- intersect(names, old_names)
[10:22:51.933]                 added <- setdiff(names, old_names)
[10:22:51.933]                 removed <- setdiff(old_names, names)
[10:22:51.933]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:51.933]                   envs[common]]
[10:22:51.933]                 NAMES <- toupper(changed)
[10:22:51.933]                 args <- list()
[10:22:51.933]                 for (kk in seq_along(NAMES)) {
[10:22:51.933]                   name <- changed[[kk]]
[10:22:51.933]                   NAME <- NAMES[[kk]]
[10:22:51.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.933]                     next
[10:22:51.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.933]                 }
[10:22:51.933]                 NAMES <- toupper(added)
[10:22:51.933]                 for (kk in seq_along(NAMES)) {
[10:22:51.933]                   name <- added[[kk]]
[10:22:51.933]                   NAME <- NAMES[[kk]]
[10:22:51.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.933]                     next
[10:22:51.933]                   args[[name]] <- ""
[10:22:51.933]                 }
[10:22:51.933]                 NAMES <- toupper(removed)
[10:22:51.933]                 for (kk in seq_along(NAMES)) {
[10:22:51.933]                   name <- removed[[kk]]
[10:22:51.933]                   NAME <- NAMES[[kk]]
[10:22:51.933]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:51.933]                     next
[10:22:51.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:51.933]                 }
[10:22:51.933]                 if (length(args) > 0) 
[10:22:51.933]                   base::do.call(base::Sys.setenv, args = args)
[10:22:51.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:51.933]             }
[10:22:51.933]             else {
[10:22:51.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:51.933]             }
[10:22:51.933]             {
[10:22:51.933]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:51.933]                   0L) {
[10:22:51.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:51.933]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:51.933]                   base::options(opts)
[10:22:51.933]                 }
[10:22:51.933]                 {
[10:22:51.933]                   {
[10:22:51.933]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:51.933]                     NULL
[10:22:51.933]                   }
[10:22:51.933]                   options(future.plan = NULL)
[10:22:51.933]                   if (is.na(NA_character_)) 
[10:22:51.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:51.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:51.933]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:51.933]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:51.933]                     envir = parent.frame()) 
[10:22:51.933]                   {
[10:22:51.933]                     if (is.function(workers)) 
[10:22:51.933]                       workers <- workers()
[10:22:51.933]                     workers <- structure(as.integer(workers), 
[10:22:51.933]                       class = class(workers))
[10:22:51.933]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:51.933]                       workers >= 1)
[10:22:51.933]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:51.933]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:51.933]                     }
[10:22:51.933]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:51.933]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:51.933]                       envir = envir)
[10:22:51.933]                     if (!future$lazy) 
[10:22:51.933]                       future <- run(future)
[10:22:51.933]                     invisible(future)
[10:22:51.933]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:51.933]                 }
[10:22:51.933]             }
[10:22:51.933]         }
[10:22:51.933]     })
[10:22:51.933]     if (TRUE) {
[10:22:51.933]         base::sink(type = "output", split = FALSE)
[10:22:51.933]         if (TRUE) {
[10:22:51.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:51.933]         }
[10:22:51.933]         else {
[10:22:51.933]             ...future.result["stdout"] <- base::list(NULL)
[10:22:51.933]         }
[10:22:51.933]         base::close(...future.stdout)
[10:22:51.933]         ...future.stdout <- NULL
[10:22:51.933]     }
[10:22:51.933]     ...future.result$conditions <- ...future.conditions
[10:22:51.933]     ...future.result$finished <- base::Sys.time()
[10:22:51.933]     ...future.result
[10:22:51.933] }
[10:22:51.936] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:22:51.936] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:22:51.937] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:22:51.937] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:51.937] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.937] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:22:51.938] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:22:51.938] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:51.938] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.938] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:22:51.939] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:22:51.939] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:22:51.939] MultisessionFuture started
[10:22:51.939] - Launch lazy future ... done
[10:22:51.939] run() for ‘MultisessionFuture’ ... done
[10:22:51.940] Created future:
[10:22:51.940] MultisessionFuture:
[10:22:51.940] Label: ‘future_by-2’
[10:22:51.940] Expression:
[10:22:51.940] {
[10:22:51.940]     do.call(function(...) {
[10:22:51.940]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:51.940]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:51.940]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:51.940]             on.exit(options(oopts), add = TRUE)
[10:22:51.940]         }
[10:22:51.940]         {
[10:22:51.940]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:51.940]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:51.940]                 ...future.FUN(...future.X_jj, ...)
[10:22:51.940]             })
[10:22:51.940]         }
[10:22:51.940]     }, args = future.call.arguments)
[10:22:51.940] }
[10:22:51.940] Lazy evaluation: FALSE
[10:22:51.940] Asynchronous evaluation: TRUE
[10:22:51.940] Local evaluation: TRUE
[10:22:51.940] Environment: 0x55f63b1af898
[10:22:51.940] Capture standard output: TRUE
[10:22:51.940] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:51.940] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:51.940] Packages: <none>
[10:22:51.940] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:51.940] Resolved: FALSE
[10:22:51.940] Value: <not collected>
[10:22:51.940] Conditions captured: <none>
[10:22:51.940] Early signaling: FALSE
[10:22:51.940] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:51.940] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:51.954] Chunk #2 of 2 ... DONE
[10:22:51.954] Launching 2 futures (chunks) ... DONE
[10:22:51.954] Resolving 2 futures (chunks) ...
[10:22:51.954] resolve() on list ...
[10:22:51.954]  recursive: 0
[10:22:51.954]  length: 2
[10:22:51.954] 
[10:22:51.955] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.955] - Validating connection of MultisessionFuture
[10:22:51.955] - received message: FutureResult
[10:22:51.955] - Received FutureResult
[10:22:51.955] - Erased future from FutureRegistry
[10:22:51.955] result() for ClusterFuture ...
[10:22:51.955] - result already collected: FutureResult
[10:22:51.956] result() for ClusterFuture ... done
[10:22:51.956] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.956] Future #1
[10:22:51.956] result() for ClusterFuture ...
[10:22:51.956] - result already collected: FutureResult
[10:22:51.956] result() for ClusterFuture ... done
[10:22:51.956] result() for ClusterFuture ...
[10:22:51.956] - result already collected: FutureResult
[10:22:51.956] result() for ClusterFuture ... done
[10:22:51.956] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:51.956] - nx: 2
[10:22:51.956] - relay: TRUE
[10:22:51.957] - stdout: TRUE
[10:22:51.957] - signal: TRUE
[10:22:51.957] - resignal: FALSE
[10:22:51.957] - force: TRUE
[10:22:51.957] - relayed: [n=2] FALSE, FALSE
[10:22:51.957] - queued futures: [n=2] FALSE, FALSE
[10:22:51.957]  - until=1
[10:22:51.957]  - relaying element #1
[10:22:51.957] result() for ClusterFuture ...
[10:22:51.957] - result already collected: FutureResult
[10:22:51.957] result() for ClusterFuture ... done
[10:22:51.958] result() for ClusterFuture ...
[10:22:51.958] - result already collected: FutureResult
[10:22:51.958] result() for ClusterFuture ... done
[10:22:51.958] result() for ClusterFuture ...
[10:22:51.958] - result already collected: FutureResult
[10:22:51.958] result() for ClusterFuture ... done
[10:22:51.958] result() for ClusterFuture ...
[10:22:51.958] - result already collected: FutureResult
[10:22:51.958] result() for ClusterFuture ... done
[10:22:51.958] - relayed: [n=2] TRUE, FALSE
[10:22:51.958] - queued futures: [n=2] TRUE, FALSE
[10:22:51.958] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:51.959]  length: 1 (resolved future 1)
[10:22:51.987] receiveMessageFromWorker() for ClusterFuture ...
[10:22:51.987] - Validating connection of MultisessionFuture
[10:22:51.987] - received message: FutureResult
[10:22:51.988] - Received FutureResult
[10:22:51.988] - Erased future from FutureRegistry
[10:22:51.988] result() for ClusterFuture ...
[10:22:51.988] - result already collected: FutureResult
[10:22:51.988] result() for ClusterFuture ... done
[10:22:51.988] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:51.988] Future #2
[10:22:51.988] result() for ClusterFuture ...
[10:22:51.988] - result already collected: FutureResult
[10:22:51.988] result() for ClusterFuture ... done
[10:22:51.988] result() for ClusterFuture ...
[10:22:51.988] - result already collected: FutureResult
[10:22:51.989] result() for ClusterFuture ... done
[10:22:51.989] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:51.989] - nx: 2
[10:22:51.989] - relay: TRUE
[10:22:51.989] - stdout: TRUE
[10:22:51.989] - signal: TRUE
[10:22:51.989] - resignal: FALSE
[10:22:51.989] - force: TRUE
[10:22:51.989] - relayed: [n=2] TRUE, FALSE
[10:22:51.989] - queued futures: [n=2] TRUE, FALSE
[10:22:51.989]  - until=2
[10:22:51.990]  - relaying element #2
[10:22:51.990] result() for ClusterFuture ...
[10:22:51.990] - result already collected: FutureResult
[10:22:51.990] result() for ClusterFuture ... done
[10:22:51.990] result() for ClusterFuture ...
[10:22:51.990] - result already collected: FutureResult
[10:22:51.990] result() for ClusterFuture ... done
[10:22:51.990] result() for ClusterFuture ...
[10:22:51.990] - result already collected: FutureResult
[10:22:51.990] result() for ClusterFuture ... done
[10:22:51.990] result() for ClusterFuture ...
[10:22:51.990] - result already collected: FutureResult
[10:22:51.991] result() for ClusterFuture ... done
[10:22:51.991] - relayed: [n=2] TRUE, TRUE
[10:22:51.991] - queued futures: [n=2] TRUE, TRUE
[10:22:51.991] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:51.991]  length: 0 (resolved future 2)
[10:22:51.991] Relaying remaining futures
[10:22:51.991] signalConditionsASAP(NULL, pos=0) ...
[10:22:51.991] - nx: 2
[10:22:51.991] - relay: TRUE
[10:22:51.991] - stdout: TRUE
[10:22:51.991] - signal: TRUE
[10:22:51.992] - resignal: FALSE
[10:22:51.992] - force: TRUE
[10:22:51.992] - relayed: [n=2] TRUE, TRUE
[10:22:51.992] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:51.992] - relayed: [n=2] TRUE, TRUE
[10:22:51.992] - queued futures: [n=2] TRUE, TRUE
[10:22:51.992] signalConditionsASAP(NULL, pos=0) ... done
[10:22:51.992] resolve() on list ... DONE
[10:22:51.992] result() for ClusterFuture ...
[10:22:51.992] - result already collected: FutureResult
[10:22:51.992] result() for ClusterFuture ... done
[10:22:51.992] result() for ClusterFuture ...
[10:22:51.993] - result already collected: FutureResult
[10:22:51.993] result() for ClusterFuture ... done
[10:22:51.993] result() for ClusterFuture ...
[10:22:51.993] - result already collected: FutureResult
[10:22:51.993] result() for ClusterFuture ... done
[10:22:51.993] result() for ClusterFuture ...
[10:22:51.993] - result already collected: FutureResult
[10:22:51.993] result() for ClusterFuture ... done
[10:22:51.993]  - Number of value chunks collected: 2
[10:22:51.993] Resolving 2 futures (chunks) ... DONE
[10:22:51.993] Reducing values from 2 chunks ...
[10:22:51.994]  - Number of values collected after concatenation: 3
[10:22:51.994]  - Number of values expected: 3
[10:22:51.994] Reducing values from 2 chunks ... DONE
[10:22:51.994] future_lapply() ... DONE
[10:22:51.994] future_by_internal() ... DONE
[10:22:51.995] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:22:51.995] future_lapply() ...
[10:22:51.999] Number of chunks: 2
[10:22:51.999] getGlobalsAndPackagesXApply() ...
[10:22:51.999]  - future.globals: TRUE
[10:22:51.999] getGlobalsAndPackages() ...
[10:22:51.999] Searching for globals...
[10:22:52.000] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:52.000] Searching for globals ... DONE
[10:22:52.001] Resolving globals: FALSE
[10:22:52.001] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:22:52.001] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:22:52.001] - globals: [1] ‘FUN’
[10:22:52.001] 
[10:22:52.002] getGlobalsAndPackages() ... DONE
[10:22:52.002]  - globals found/used: [n=1] ‘FUN’
[10:22:52.002]  - needed namespaces: [n=0] 
[10:22:52.002] Finding globals ... DONE
[10:22:52.002]  - use_args: TRUE
[10:22:52.002]  - Getting '...' globals ...
[10:22:52.002] resolve() on list ...
[10:22:52.002]  recursive: 0
[10:22:52.002]  length: 1
[10:22:52.003]  elements: ‘...’
[10:22:52.003]  length: 0 (resolved future 1)
[10:22:52.003] resolve() on list ... DONE
[10:22:52.003]    - '...' content: [n=0] 
[10:22:52.003] List of 1
[10:22:52.003]  $ ...: list()
[10:22:52.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:52.003]  - attr(*, "where")=List of 1
[10:22:52.003]   ..$ ...:<environment: 0x55f63ba2f0a0> 
[10:22:52.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:52.003]  - attr(*, "resolved")= logi TRUE
[10:22:52.003]  - attr(*, "total_size")= num NA
[10:22:52.005]  - Getting '...' globals ... DONE
[10:22:52.006] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:52.006] List of 2
[10:22:52.006]  $ ...future.FUN:function (object, ...)  
[10:22:52.006]  $ ...          : list()
[10:22:52.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:52.006]  - attr(*, "where")=List of 2
[10:22:52.006]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:52.006]   ..$ ...          :<environment: 0x55f63ba2f0a0> 
[10:22:52.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:52.006]  - attr(*, "resolved")= logi FALSE
[10:22:52.006]  - attr(*, "total_size")= num 1240
[10:22:52.008] Packages to be attached in all futures: [n=0] 
[10:22:52.008] getGlobalsAndPackagesXApply() ... DONE
[10:22:52.008] Number of futures (= number of chunks): 2
[10:22:52.009] Launching 2 futures (chunks) ...
[10:22:52.009] Chunk #1 of 2 ...
[10:22:52.009]  - Finding globals in 'X' for chunk #1 ...
[10:22:52.009] getGlobalsAndPackages() ...
[10:22:52.009] Searching for globals...
[10:22:52.009] 
[10:22:52.009] Searching for globals ... DONE
[10:22:52.009] - globals: [0] <none>
[10:22:52.010] getGlobalsAndPackages() ... DONE
[10:22:52.010]    + additional globals found: [n=0] 
[10:22:52.010]    + additional namespaces needed: [n=0] 
[10:22:52.010]  - Finding globals in 'X' for chunk #1 ... DONE
[10:22:52.010]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:52.010]  - seeds: <none>
[10:22:52.010]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:52.010] getGlobalsAndPackages() ...
[10:22:52.010] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:52.010] Resolving globals: FALSE
[10:22:52.010] Tweak future expression to call with '...' arguments ...
[10:22:52.011] {
[10:22:52.011]     do.call(function(...) {
[10:22:52.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:52.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:52.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:52.011]             on.exit(options(oopts), add = TRUE)
[10:22:52.011]         }
[10:22:52.011]         {
[10:22:52.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:52.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:52.011]                 ...future.FUN(...future.X_jj, ...)
[10:22:52.011]             })
[10:22:52.011]         }
[10:22:52.011]     }, args = future.call.arguments)
[10:22:52.011] }
[10:22:52.011] Tweak future expression to call with '...' arguments ... DONE
[10:22:52.011] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:52.011] 
[10:22:52.011] getGlobalsAndPackages() ... DONE
[10:22:52.012] run() for ‘Future’ ...
[10:22:52.012] - state: ‘created’
[10:22:52.012] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:52.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:52.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:52.026]   - Field: ‘node’
[10:22:52.026]   - Field: ‘label’
[10:22:52.026]   - Field: ‘local’
[10:22:52.026]   - Field: ‘owner’
[10:22:52.026]   - Field: ‘envir’
[10:22:52.026]   - Field: ‘workers’
[10:22:52.026]   - Field: ‘packages’
[10:22:52.026]   - Field: ‘gc’
[10:22:52.026]   - Field: ‘conditions’
[10:22:52.026]   - Field: ‘persistent’
[10:22:52.026]   - Field: ‘expr’
[10:22:52.027]   - Field: ‘uuid’
[10:22:52.027]   - Field: ‘seed’
[10:22:52.027]   - Field: ‘version’
[10:22:52.027]   - Field: ‘result’
[10:22:52.027]   - Field: ‘asynchronous’
[10:22:52.027]   - Field: ‘calls’
[10:22:52.027]   - Field: ‘globals’
[10:22:52.027]   - Field: ‘stdout’
[10:22:52.027]   - Field: ‘earlySignal’
[10:22:52.027]   - Field: ‘lazy’
[10:22:52.027]   - Field: ‘state’
[10:22:52.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:52.028] - Launch lazy future ...
[10:22:52.028] Packages needed by the future expression (n = 0): <none>
[10:22:52.028] Packages needed by future strategies (n = 0): <none>
[10:22:52.028] {
[10:22:52.028]     {
[10:22:52.028]         {
[10:22:52.028]             ...future.startTime <- base::Sys.time()
[10:22:52.028]             {
[10:22:52.028]                 {
[10:22:52.028]                   {
[10:22:52.028]                     {
[10:22:52.028]                       base::local({
[10:22:52.028]                         has_future <- base::requireNamespace("future", 
[10:22:52.028]                           quietly = TRUE)
[10:22:52.028]                         if (has_future) {
[10:22:52.028]                           ns <- base::getNamespace("future")
[10:22:52.028]                           version <- ns[[".package"]][["version"]]
[10:22:52.028]                           if (is.null(version)) 
[10:22:52.028]                             version <- utils::packageVersion("future")
[10:22:52.028]                         }
[10:22:52.028]                         else {
[10:22:52.028]                           version <- NULL
[10:22:52.028]                         }
[10:22:52.028]                         if (!has_future || version < "1.8.0") {
[10:22:52.028]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:52.028]                             "", base::R.version$version.string), 
[10:22:52.028]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:52.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:52.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:52.028]                               "release", "version")], collapse = " "), 
[10:22:52.028]                             hostname = base::Sys.info()[["nodename"]])
[10:22:52.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:52.028]                             info)
[10:22:52.028]                           info <- base::paste(info, collapse = "; ")
[10:22:52.028]                           if (!has_future) {
[10:22:52.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:52.028]                               info)
[10:22:52.028]                           }
[10:22:52.028]                           else {
[10:22:52.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:52.028]                               info, version)
[10:22:52.028]                           }
[10:22:52.028]                           base::stop(msg)
[10:22:52.028]                         }
[10:22:52.028]                       })
[10:22:52.028]                     }
[10:22:52.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:52.028]                     base::options(mc.cores = 1L)
[10:22:52.028]                   }
[10:22:52.028]                   options(future.plan = NULL)
[10:22:52.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:52.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:52.028]                 }
[10:22:52.028]                 ...future.workdir <- getwd()
[10:22:52.028]             }
[10:22:52.028]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:52.028]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:52.028]         }
[10:22:52.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:52.028]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:52.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:52.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:52.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:52.028]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:52.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:52.028]             base::names(...future.oldOptions))
[10:22:52.028]     }
[10:22:52.028]     if (FALSE) {
[10:22:52.028]     }
[10:22:52.028]     else {
[10:22:52.028]         if (TRUE) {
[10:22:52.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:52.028]                 open = "w")
[10:22:52.028]         }
[10:22:52.028]         else {
[10:22:52.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:52.028]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:52.028]         }
[10:22:52.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:52.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:52.028]             base::sink(type = "output", split = FALSE)
[10:22:52.028]             base::close(...future.stdout)
[10:22:52.028]         }, add = TRUE)
[10:22:52.028]     }
[10:22:52.028]     ...future.frame <- base::sys.nframe()
[10:22:52.028]     ...future.conditions <- base::list()
[10:22:52.028]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:52.028]     if (FALSE) {
[10:22:52.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:52.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:52.028]     }
[10:22:52.028]     ...future.result <- base::tryCatch({
[10:22:52.028]         base::withCallingHandlers({
[10:22:52.028]             ...future.value <- base::withVisible(base::local({
[10:22:52.028]                 ...future.makeSendCondition <- base::local({
[10:22:52.028]                   sendCondition <- NULL
[10:22:52.028]                   function(frame = 1L) {
[10:22:52.028]                     if (is.function(sendCondition)) 
[10:22:52.028]                       return(sendCondition)
[10:22:52.028]                     ns <- getNamespace("parallel")
[10:22:52.028]                     if (exists("sendData", mode = "function", 
[10:22:52.028]                       envir = ns)) {
[10:22:52.028]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:52.028]                         envir = ns)
[10:22:52.028]                       envir <- sys.frame(frame)
[10:22:52.028]                       master <- NULL
[10:22:52.028]                       while (!identical(envir, .GlobalEnv) && 
[10:22:52.028]                         !identical(envir, emptyenv())) {
[10:22:52.028]                         if (exists("master", mode = "list", envir = envir, 
[10:22:52.028]                           inherits = FALSE)) {
[10:22:52.028]                           master <- get("master", mode = "list", 
[10:22:52.028]                             envir = envir, inherits = FALSE)
[10:22:52.028]                           if (inherits(master, c("SOCKnode", 
[10:22:52.028]                             "SOCK0node"))) {
[10:22:52.028]                             sendCondition <<- function(cond) {
[10:22:52.028]                               data <- list(type = "VALUE", value = cond, 
[10:22:52.028]                                 success = TRUE)
[10:22:52.028]                               parallel_sendData(master, data)
[10:22:52.028]                             }
[10:22:52.028]                             return(sendCondition)
[10:22:52.028]                           }
[10:22:52.028]                         }
[10:22:52.028]                         frame <- frame + 1L
[10:22:52.028]                         envir <- sys.frame(frame)
[10:22:52.028]                       }
[10:22:52.028]                     }
[10:22:52.028]                     sendCondition <<- function(cond) NULL
[10:22:52.028]                   }
[10:22:52.028]                 })
[10:22:52.028]                 withCallingHandlers({
[10:22:52.028]                   {
[10:22:52.028]                     do.call(function(...) {
[10:22:52.028]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:52.028]                       if (!identical(...future.globals.maxSize.org, 
[10:22:52.028]                         ...future.globals.maxSize)) {
[10:22:52.028]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:52.028]                         on.exit(options(oopts), add = TRUE)
[10:22:52.028]                       }
[10:22:52.028]                       {
[10:22:52.028]                         lapply(seq_along(...future.elements_ii), 
[10:22:52.028]                           FUN = function(jj) {
[10:22:52.028]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:52.028]                             ...future.FUN(...future.X_jj, ...)
[10:22:52.028]                           })
[10:22:52.028]                       }
[10:22:52.028]                     }, args = future.call.arguments)
[10:22:52.028]                   }
[10:22:52.028]                 }, immediateCondition = function(cond) {
[10:22:52.028]                   sendCondition <- ...future.makeSendCondition()
[10:22:52.028]                   sendCondition(cond)
[10:22:52.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:52.028]                   {
[10:22:52.028]                     inherits <- base::inherits
[10:22:52.028]                     invokeRestart <- base::invokeRestart
[10:22:52.028]                     is.null <- base::is.null
[10:22:52.028]                     muffled <- FALSE
[10:22:52.028]                     if (inherits(cond, "message")) {
[10:22:52.028]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:52.028]                       if (muffled) 
[10:22:52.028]                         invokeRestart("muffleMessage")
[10:22:52.028]                     }
[10:22:52.028]                     else if (inherits(cond, "warning")) {
[10:22:52.028]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:52.028]                       if (muffled) 
[10:22:52.028]                         invokeRestart("muffleWarning")
[10:22:52.028]                     }
[10:22:52.028]                     else if (inherits(cond, "condition")) {
[10:22:52.028]                       if (!is.null(pattern)) {
[10:22:52.028]                         computeRestarts <- base::computeRestarts
[10:22:52.028]                         grepl <- base::grepl
[10:22:52.028]                         restarts <- computeRestarts(cond)
[10:22:52.028]                         for (restart in restarts) {
[10:22:52.028]                           name <- restart$name
[10:22:52.028]                           if (is.null(name)) 
[10:22:52.028]                             next
[10:22:52.028]                           if (!grepl(pattern, name)) 
[10:22:52.028]                             next
[10:22:52.028]                           invokeRestart(restart)
[10:22:52.028]                           muffled <- TRUE
[10:22:52.028]                           break
[10:22:52.028]                         }
[10:22:52.028]                       }
[10:22:52.028]                     }
[10:22:52.028]                     invisible(muffled)
[10:22:52.028]                   }
[10:22:52.028]                   muffleCondition(cond)
[10:22:52.028]                 })
[10:22:52.028]             }))
[10:22:52.028]             future::FutureResult(value = ...future.value$value, 
[10:22:52.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:52.028]                   ...future.rng), globalenv = if (FALSE) 
[10:22:52.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:52.028]                     ...future.globalenv.names))
[10:22:52.028]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:52.028]         }, condition = base::local({
[10:22:52.028]             c <- base::c
[10:22:52.028]             inherits <- base::inherits
[10:22:52.028]             invokeRestart <- base::invokeRestart
[10:22:52.028]             length <- base::length
[10:22:52.028]             list <- base::list
[10:22:52.028]             seq.int <- base::seq.int
[10:22:52.028]             signalCondition <- base::signalCondition
[10:22:52.028]             sys.calls <- base::sys.calls
[10:22:52.028]             `[[` <- base::`[[`
[10:22:52.028]             `+` <- base::`+`
[10:22:52.028]             `<<-` <- base::`<<-`
[10:22:52.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:52.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:52.028]                   3L)]
[10:22:52.028]             }
[10:22:52.028]             function(cond) {
[10:22:52.028]                 is_error <- inherits(cond, "error")
[10:22:52.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:52.028]                   NULL)
[10:22:52.028]                 if (is_error) {
[10:22:52.028]                   sessionInformation <- function() {
[10:22:52.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:52.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:52.028]                       search = base::search(), system = base::Sys.info())
[10:22:52.028]                   }
[10:22:52.028]                   ...future.conditions[[length(...future.conditions) + 
[10:22:52.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:52.028]                     cond$call), session = sessionInformation(), 
[10:22:52.028]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:52.028]                   signalCondition(cond)
[10:22:52.028]                 }
[10:22:52.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:52.028]                 "immediateCondition"))) {
[10:22:52.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:52.028]                   ...future.conditions[[length(...future.conditions) + 
[10:22:52.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:52.028]                   if (TRUE && !signal) {
[10:22:52.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:52.028]                     {
[10:22:52.028]                       inherits <- base::inherits
[10:22:52.028]                       invokeRestart <- base::invokeRestart
[10:22:52.028]                       is.null <- base::is.null
[10:22:52.028]                       muffled <- FALSE
[10:22:52.028]                       if (inherits(cond, "message")) {
[10:22:52.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:52.028]                         if (muffled) 
[10:22:52.028]                           invokeRestart("muffleMessage")
[10:22:52.028]                       }
[10:22:52.028]                       else if (inherits(cond, "warning")) {
[10:22:52.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:52.028]                         if (muffled) 
[10:22:52.028]                           invokeRestart("muffleWarning")
[10:22:52.028]                       }
[10:22:52.028]                       else if (inherits(cond, "condition")) {
[10:22:52.028]                         if (!is.null(pattern)) {
[10:22:52.028]                           computeRestarts <- base::computeRestarts
[10:22:52.028]                           grepl <- base::grepl
[10:22:52.028]                           restarts <- computeRestarts(cond)
[10:22:52.028]                           for (restart in restarts) {
[10:22:52.028]                             name <- restart$name
[10:22:52.028]                             if (is.null(name)) 
[10:22:52.028]                               next
[10:22:52.028]                             if (!grepl(pattern, name)) 
[10:22:52.028]                               next
[10:22:52.028]                             invokeRestart(restart)
[10:22:52.028]                             muffled <- TRUE
[10:22:52.028]                             break
[10:22:52.028]                           }
[10:22:52.028]                         }
[10:22:52.028]                       }
[10:22:52.028]                       invisible(muffled)
[10:22:52.028]                     }
[10:22:52.028]                     muffleCondition(cond, pattern = "^muffle")
[10:22:52.028]                   }
[10:22:52.028]                 }
[10:22:52.028]                 else {
[10:22:52.028]                   if (TRUE) {
[10:22:52.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:52.028]                     {
[10:22:52.028]                       inherits <- base::inherits
[10:22:52.028]                       invokeRestart <- base::invokeRestart
[10:22:52.028]                       is.null <- base::is.null
[10:22:52.028]                       muffled <- FALSE
[10:22:52.028]                       if (inherits(cond, "message")) {
[10:22:52.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:52.028]                         if (muffled) 
[10:22:52.028]                           invokeRestart("muffleMessage")
[10:22:52.028]                       }
[10:22:52.028]                       else if (inherits(cond, "warning")) {
[10:22:52.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:52.028]                         if (muffled) 
[10:22:52.028]                           invokeRestart("muffleWarning")
[10:22:52.028]                       }
[10:22:52.028]                       else if (inherits(cond, "condition")) {
[10:22:52.028]                         if (!is.null(pattern)) {
[10:22:52.028]                           computeRestarts <- base::computeRestarts
[10:22:52.028]                           grepl <- base::grepl
[10:22:52.028]                           restarts <- computeRestarts(cond)
[10:22:52.028]                           for (restart in restarts) {
[10:22:52.028]                             name <- restart$name
[10:22:52.028]                             if (is.null(name)) 
[10:22:52.028]                               next
[10:22:52.028]                             if (!grepl(pattern, name)) 
[10:22:52.028]                               next
[10:22:52.028]                             invokeRestart(restart)
[10:22:52.028]                             muffled <- TRUE
[10:22:52.028]                             break
[10:22:52.028]                           }
[10:22:52.028]                         }
[10:22:52.028]                       }
[10:22:52.028]                       invisible(muffled)
[10:22:52.028]                     }
[10:22:52.028]                     muffleCondition(cond, pattern = "^muffle")
[10:22:52.028]                   }
[10:22:52.028]                 }
[10:22:52.028]             }
[10:22:52.028]         }))
[10:22:52.028]     }, error = function(ex) {
[10:22:52.028]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:52.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:52.028]                 ...future.rng), started = ...future.startTime, 
[10:22:52.028]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:52.028]             version = "1.8"), class = "FutureResult")
[10:22:52.028]     }, finally = {
[10:22:52.028]         if (!identical(...future.workdir, getwd())) 
[10:22:52.028]             setwd(...future.workdir)
[10:22:52.028]         {
[10:22:52.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:52.028]                 ...future.oldOptions$nwarnings <- NULL
[10:22:52.028]             }
[10:22:52.028]             base::options(...future.oldOptions)
[10:22:52.028]             if (.Platform$OS.type == "windows") {
[10:22:52.028]                 old_names <- names(...future.oldEnvVars)
[10:22:52.028]                 envs <- base::Sys.getenv()
[10:22:52.028]                 names <- names(envs)
[10:22:52.028]                 common <- intersect(names, old_names)
[10:22:52.028]                 added <- setdiff(names, old_names)
[10:22:52.028]                 removed <- setdiff(old_names, names)
[10:22:52.028]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:52.028]                   envs[common]]
[10:22:52.028]                 NAMES <- toupper(changed)
[10:22:52.028]                 args <- list()
[10:22:52.028]                 for (kk in seq_along(NAMES)) {
[10:22:52.028]                   name <- changed[[kk]]
[10:22:52.028]                   NAME <- NAMES[[kk]]
[10:22:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:52.028]                     next
[10:22:52.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:52.028]                 }
[10:22:52.028]                 NAMES <- toupper(added)
[10:22:52.028]                 for (kk in seq_along(NAMES)) {
[10:22:52.028]                   name <- added[[kk]]
[10:22:52.028]                   NAME <- NAMES[[kk]]
[10:22:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:52.028]                     next
[10:22:52.028]                   args[[name]] <- ""
[10:22:52.028]                 }
[10:22:52.028]                 NAMES <- toupper(removed)
[10:22:52.028]                 for (kk in seq_along(NAMES)) {
[10:22:52.028]                   name <- removed[[kk]]
[10:22:52.028]                   NAME <- NAMES[[kk]]
[10:22:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:52.028]                     next
[10:22:52.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:52.028]                 }
[10:22:52.028]                 if (length(args) > 0) 
[10:22:52.028]                   base::do.call(base::Sys.setenv, args = args)
[10:22:52.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:52.028]             }
[10:22:52.028]             else {
[10:22:52.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:52.028]             }
[10:22:52.028]             {
[10:22:52.028]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:52.028]                   0L) {
[10:22:52.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:52.028]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:52.028]                   base::options(opts)
[10:22:52.028]                 }
[10:22:52.028]                 {
[10:22:52.028]                   {
[10:22:52.028]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:52.028]                     NULL
[10:22:52.028]                   }
[10:22:52.028]                   options(future.plan = NULL)
[10:22:52.028]                   if (is.na(NA_character_)) 
[10:22:52.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:52.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:52.028]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:52.028]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:52.028]                     envir = parent.frame()) 
[10:22:52.028]                   {
[10:22:52.028]                     if (is.function(workers)) 
[10:22:52.028]                       workers <- workers()
[10:22:52.028]                     workers <- structure(as.integer(workers), 
[10:22:52.028]                       class = class(workers))
[10:22:52.028]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:52.028]                       workers >= 1)
[10:22:52.028]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:52.028]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:52.028]                     }
[10:22:52.028]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:52.028]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:52.028]                       envir = envir)
[10:22:52.028]                     if (!future$lazy) 
[10:22:52.028]                       future <- run(future)
[10:22:52.028]                     invisible(future)
[10:22:52.028]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:52.028]                 }
[10:22:52.028]             }
[10:22:52.028]         }
[10:22:52.028]     })
[10:22:52.028]     if (TRUE) {
[10:22:52.028]         base::sink(type = "output", split = FALSE)
[10:22:52.028]         if (TRUE) {
[10:22:52.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:52.028]         }
[10:22:52.028]         else {
[10:22:52.028]             ...future.result["stdout"] <- base::list(NULL)
[10:22:52.028]         }
[10:22:52.028]         base::close(...future.stdout)
[10:22:52.028]         ...future.stdout <- NULL
[10:22:52.028]     }
[10:22:52.028]     ...future.result$conditions <- ...future.conditions
[10:22:52.028]     ...future.result$finished <- base::Sys.time()
[10:22:52.028]     ...future.result
[10:22:52.028] }
[10:22:52.031] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:22:52.031] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:22:52.032] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:22:52.032] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:52.032] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:52.033] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:22:52.033] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:22:52.033] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:52.033] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:52.034] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:22:52.034] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:22:52.034] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:22:52.035] MultisessionFuture started
[10:22:52.035] - Launch lazy future ... done
[10:22:52.035] run() for ‘MultisessionFuture’ ... done
[10:22:52.035] Created future:
[10:22:52.035] MultisessionFuture:
[10:22:52.035] Label: ‘future_by-1’
[10:22:52.035] Expression:
[10:22:52.035] {
[10:22:52.035]     do.call(function(...) {
[10:22:52.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:52.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:52.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:52.035]             on.exit(options(oopts), add = TRUE)
[10:22:52.035]         }
[10:22:52.035]         {
[10:22:52.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:52.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:52.035]                 ...future.FUN(...future.X_jj, ...)
[10:22:52.035]             })
[10:22:52.035]         }
[10:22:52.035]     }, args = future.call.arguments)
[10:22:52.035] }
[10:22:52.035] Lazy evaluation: FALSE
[10:22:52.035] Asynchronous evaluation: TRUE
[10:22:52.035] Local evaluation: TRUE
[10:22:52.035] Environment: 0x55f63ba65e40
[10:22:52.035] Capture standard output: TRUE
[10:22:52.035] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:52.035] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:52.035] Packages: <none>
[10:22:52.035] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:52.035] Resolved: FALSE
[10:22:52.035] Value: <not collected>
[10:22:52.035] Conditions captured: <none>
[10:22:52.035] Early signaling: FALSE
[10:22:52.035] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:52.035] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:52.047] Chunk #1 of 2 ... DONE
[10:22:52.047] Chunk #2 of 2 ...
[10:22:52.047]  - Finding globals in 'X' for chunk #2 ...
[10:22:52.047] getGlobalsAndPackages() ...
[10:22:52.047] Searching for globals...
[10:22:52.047] 
[10:22:52.048] Searching for globals ... DONE
[10:22:52.048] - globals: [0] <none>
[10:22:52.048] getGlobalsAndPackages() ... DONE
[10:22:52.048]    + additional globals found: [n=0] 
[10:22:52.048]    + additional namespaces needed: [n=0] 
[10:22:52.048]  - Finding globals in 'X' for chunk #2 ... DONE
[10:22:52.048]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:22:52.048]  - seeds: <none>
[10:22:52.048]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:52.048] getGlobalsAndPackages() ...
[10:22:52.048] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:52.049] Resolving globals: FALSE
[10:22:52.049] Tweak future expression to call with '...' arguments ...
[10:22:52.049] {
[10:22:52.049]     do.call(function(...) {
[10:22:52.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:52.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:52.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:52.049]             on.exit(options(oopts), add = TRUE)
[10:22:52.049]         }
[10:22:52.049]         {
[10:22:52.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:52.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:52.049]                 ...future.FUN(...future.X_jj, ...)
[10:22:52.049]             })
[10:22:52.049]         }
[10:22:52.049]     }, args = future.call.arguments)
[10:22:52.049] }
[10:22:52.049] Tweak future expression to call with '...' arguments ... DONE
[10:22:52.049] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:52.049] 
[10:22:52.050] getGlobalsAndPackages() ... DONE
[10:22:52.050] run() for ‘Future’ ...
[10:22:52.050] - state: ‘created’
[10:22:52.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:52.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:52.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:52.064]   - Field: ‘node’
[10:22:52.064]   - Field: ‘label’
[10:22:52.064]   - Field: ‘local’
[10:22:52.064]   - Field: ‘owner’
[10:22:52.064]   - Field: ‘envir’
[10:22:52.064]   - Field: ‘workers’
[10:22:52.064]   - Field: ‘packages’
[10:22:52.064]   - Field: ‘gc’
[10:22:52.064]   - Field: ‘conditions’
[10:22:52.065]   - Field: ‘persistent’
[10:22:52.065]   - Field: ‘expr’
[10:22:52.065]   - Field: ‘uuid’
[10:22:52.065]   - Field: ‘seed’
[10:22:52.065]   - Field: ‘version’
[10:22:52.065]   - Field: ‘result’
[10:22:52.065]   - Field: ‘asynchronous’
[10:22:52.065]   - Field: ‘calls’
[10:22:52.065]   - Field: ‘globals’
[10:22:52.065]   - Field: ‘stdout’
[10:22:52.065]   - Field: ‘earlySignal’
[10:22:52.066]   - Field: ‘lazy’
[10:22:52.066]   - Field: ‘state’
[10:22:52.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:52.066] - Launch lazy future ...
[10:22:52.066] Packages needed by the future expression (n = 0): <none>
[10:22:52.066] Packages needed by future strategies (n = 0): <none>
[10:22:52.067] {
[10:22:52.067]     {
[10:22:52.067]         {
[10:22:52.067]             ...future.startTime <- base::Sys.time()
[10:22:52.067]             {
[10:22:52.067]                 {
[10:22:52.067]                   {
[10:22:52.067]                     {
[10:22:52.067]                       base::local({
[10:22:52.067]                         has_future <- base::requireNamespace("future", 
[10:22:52.067]                           quietly = TRUE)
[10:22:52.067]                         if (has_future) {
[10:22:52.067]                           ns <- base::getNamespace("future")
[10:22:52.067]                           version <- ns[[".package"]][["version"]]
[10:22:52.067]                           if (is.null(version)) 
[10:22:52.067]                             version <- utils::packageVersion("future")
[10:22:52.067]                         }
[10:22:52.067]                         else {
[10:22:52.067]                           version <- NULL
[10:22:52.067]                         }
[10:22:52.067]                         if (!has_future || version < "1.8.0") {
[10:22:52.067]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:52.067]                             "", base::R.version$version.string), 
[10:22:52.067]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:52.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:52.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:52.067]                               "release", "version")], collapse = " "), 
[10:22:52.067]                             hostname = base::Sys.info()[["nodename"]])
[10:22:52.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:52.067]                             info)
[10:22:52.067]                           info <- base::paste(info, collapse = "; ")
[10:22:52.067]                           if (!has_future) {
[10:22:52.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:52.067]                               info)
[10:22:52.067]                           }
[10:22:52.067]                           else {
[10:22:52.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:52.067]                               info, version)
[10:22:52.067]                           }
[10:22:52.067]                           base::stop(msg)
[10:22:52.067]                         }
[10:22:52.067]                       })
[10:22:52.067]                     }
[10:22:52.067]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:52.067]                     base::options(mc.cores = 1L)
[10:22:52.067]                   }
[10:22:52.067]                   options(future.plan = NULL)
[10:22:52.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:52.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:52.067]                 }
[10:22:52.067]                 ...future.workdir <- getwd()
[10:22:52.067]             }
[10:22:52.067]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:52.067]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:52.067]         }
[10:22:52.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:52.067]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:22:52.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:52.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:52.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:52.067]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:52.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:52.067]             base::names(...future.oldOptions))
[10:22:52.067]     }
[10:22:52.067]     if (FALSE) {
[10:22:52.067]     }
[10:22:52.067]     else {
[10:22:52.067]         if (TRUE) {
[10:22:52.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:52.067]                 open = "w")
[10:22:52.067]         }
[10:22:52.067]         else {
[10:22:52.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:52.067]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:52.067]         }
[10:22:52.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:52.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:52.067]             base::sink(type = "output", split = FALSE)
[10:22:52.067]             base::close(...future.stdout)
[10:22:52.067]         }, add = TRUE)
[10:22:52.067]     }
[10:22:52.067]     ...future.frame <- base::sys.nframe()
[10:22:52.067]     ...future.conditions <- base::list()
[10:22:52.067]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:52.067]     if (FALSE) {
[10:22:52.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:52.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:52.067]     }
[10:22:52.067]     ...future.result <- base::tryCatch({
[10:22:52.067]         base::withCallingHandlers({
[10:22:52.067]             ...future.value <- base::withVisible(base::local({
[10:22:52.067]                 ...future.makeSendCondition <- base::local({
[10:22:52.067]                   sendCondition <- NULL
[10:22:52.067]                   function(frame = 1L) {
[10:22:52.067]                     if (is.function(sendCondition)) 
[10:22:52.067]                       return(sendCondition)
[10:22:52.067]                     ns <- getNamespace("parallel")
[10:22:52.067]                     if (exists("sendData", mode = "function", 
[10:22:52.067]                       envir = ns)) {
[10:22:52.067]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:52.067]                         envir = ns)
[10:22:52.067]                       envir <- sys.frame(frame)
[10:22:52.067]                       master <- NULL
[10:22:52.067]                       while (!identical(envir, .GlobalEnv) && 
[10:22:52.067]                         !identical(envir, emptyenv())) {
[10:22:52.067]                         if (exists("master", mode = "list", envir = envir, 
[10:22:52.067]                           inherits = FALSE)) {
[10:22:52.067]                           master <- get("master", mode = "list", 
[10:22:52.067]                             envir = envir, inherits = FALSE)
[10:22:52.067]                           if (inherits(master, c("SOCKnode", 
[10:22:52.067]                             "SOCK0node"))) {
[10:22:52.067]                             sendCondition <<- function(cond) {
[10:22:52.067]                               data <- list(type = "VALUE", value = cond, 
[10:22:52.067]                                 success = TRUE)
[10:22:52.067]                               parallel_sendData(master, data)
[10:22:52.067]                             }
[10:22:52.067]                             return(sendCondition)
[10:22:52.067]                           }
[10:22:52.067]                         }
[10:22:52.067]                         frame <- frame + 1L
[10:22:52.067]                         envir <- sys.frame(frame)
[10:22:52.067]                       }
[10:22:52.067]                     }
[10:22:52.067]                     sendCondition <<- function(cond) NULL
[10:22:52.067]                   }
[10:22:52.067]                 })
[10:22:52.067]                 withCallingHandlers({
[10:22:52.067]                   {
[10:22:52.067]                     do.call(function(...) {
[10:22:52.067]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:52.067]                       if (!identical(...future.globals.maxSize.org, 
[10:22:52.067]                         ...future.globals.maxSize)) {
[10:22:52.067]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:52.067]                         on.exit(options(oopts), add = TRUE)
[10:22:52.067]                       }
[10:22:52.067]                       {
[10:22:52.067]                         lapply(seq_along(...future.elements_ii), 
[10:22:52.067]                           FUN = function(jj) {
[10:22:52.067]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:52.067]                             ...future.FUN(...future.X_jj, ...)
[10:22:52.067]                           })
[10:22:52.067]                       }
[10:22:52.067]                     }, args = future.call.arguments)
[10:22:52.067]                   }
[10:22:52.067]                 }, immediateCondition = function(cond) {
[10:22:52.067]                   sendCondition <- ...future.makeSendCondition()
[10:22:52.067]                   sendCondition(cond)
[10:22:52.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:52.067]                   {
[10:22:52.067]                     inherits <- base::inherits
[10:22:52.067]                     invokeRestart <- base::invokeRestart
[10:22:52.067]                     is.null <- base::is.null
[10:22:52.067]                     muffled <- FALSE
[10:22:52.067]                     if (inherits(cond, "message")) {
[10:22:52.067]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:52.067]                       if (muffled) 
[10:22:52.067]                         invokeRestart("muffleMessage")
[10:22:52.067]                     }
[10:22:52.067]                     else if (inherits(cond, "warning")) {
[10:22:52.067]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:52.067]                       if (muffled) 
[10:22:52.067]                         invokeRestart("muffleWarning")
[10:22:52.067]                     }
[10:22:52.067]                     else if (inherits(cond, "condition")) {
[10:22:52.067]                       if (!is.null(pattern)) {
[10:22:52.067]                         computeRestarts <- base::computeRestarts
[10:22:52.067]                         grepl <- base::grepl
[10:22:52.067]                         restarts <- computeRestarts(cond)
[10:22:52.067]                         for (restart in restarts) {
[10:22:52.067]                           name <- restart$name
[10:22:52.067]                           if (is.null(name)) 
[10:22:52.067]                             next
[10:22:52.067]                           if (!grepl(pattern, name)) 
[10:22:52.067]                             next
[10:22:52.067]                           invokeRestart(restart)
[10:22:52.067]                           muffled <- TRUE
[10:22:52.067]                           break
[10:22:52.067]                         }
[10:22:52.067]                       }
[10:22:52.067]                     }
[10:22:52.067]                     invisible(muffled)
[10:22:52.067]                   }
[10:22:52.067]                   muffleCondition(cond)
[10:22:52.067]                 })
[10:22:52.067]             }))
[10:22:52.067]             future::FutureResult(value = ...future.value$value, 
[10:22:52.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:52.067]                   ...future.rng), globalenv = if (FALSE) 
[10:22:52.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:52.067]                     ...future.globalenv.names))
[10:22:52.067]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:52.067]         }, condition = base::local({
[10:22:52.067]             c <- base::c
[10:22:52.067]             inherits <- base::inherits
[10:22:52.067]             invokeRestart <- base::invokeRestart
[10:22:52.067]             length <- base::length
[10:22:52.067]             list <- base::list
[10:22:52.067]             seq.int <- base::seq.int
[10:22:52.067]             signalCondition <- base::signalCondition
[10:22:52.067]             sys.calls <- base::sys.calls
[10:22:52.067]             `[[` <- base::`[[`
[10:22:52.067]             `+` <- base::`+`
[10:22:52.067]             `<<-` <- base::`<<-`
[10:22:52.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:52.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:52.067]                   3L)]
[10:22:52.067]             }
[10:22:52.067]             function(cond) {
[10:22:52.067]                 is_error <- inherits(cond, "error")
[10:22:52.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:52.067]                   NULL)
[10:22:52.067]                 if (is_error) {
[10:22:52.067]                   sessionInformation <- function() {
[10:22:52.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:52.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:52.067]                       search = base::search(), system = base::Sys.info())
[10:22:52.067]                   }
[10:22:52.067]                   ...future.conditions[[length(...future.conditions) + 
[10:22:52.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:52.067]                     cond$call), session = sessionInformation(), 
[10:22:52.067]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:52.067]                   signalCondition(cond)
[10:22:52.067]                 }
[10:22:52.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:52.067]                 "immediateCondition"))) {
[10:22:52.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:52.067]                   ...future.conditions[[length(...future.conditions) + 
[10:22:52.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:52.067]                   if (TRUE && !signal) {
[10:22:52.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:52.067]                     {
[10:22:52.067]                       inherits <- base::inherits
[10:22:52.067]                       invokeRestart <- base::invokeRestart
[10:22:52.067]                       is.null <- base::is.null
[10:22:52.067]                       muffled <- FALSE
[10:22:52.067]                       if (inherits(cond, "message")) {
[10:22:52.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:52.067]                         if (muffled) 
[10:22:52.067]                           invokeRestart("muffleMessage")
[10:22:52.067]                       }
[10:22:52.067]                       else if (inherits(cond, "warning")) {
[10:22:52.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:52.067]                         if (muffled) 
[10:22:52.067]                           invokeRestart("muffleWarning")
[10:22:52.067]                       }
[10:22:52.067]                       else if (inherits(cond, "condition")) {
[10:22:52.067]                         if (!is.null(pattern)) {
[10:22:52.067]                           computeRestarts <- base::computeRestarts
[10:22:52.067]                           grepl <- base::grepl
[10:22:52.067]                           restarts <- computeRestarts(cond)
[10:22:52.067]                           for (restart in restarts) {
[10:22:52.067]                             name <- restart$name
[10:22:52.067]                             if (is.null(name)) 
[10:22:52.067]                               next
[10:22:52.067]                             if (!grepl(pattern, name)) 
[10:22:52.067]                               next
[10:22:52.067]                             invokeRestart(restart)
[10:22:52.067]                             muffled <- TRUE
[10:22:52.067]                             break
[10:22:52.067]                           }
[10:22:52.067]                         }
[10:22:52.067]                       }
[10:22:52.067]                       invisible(muffled)
[10:22:52.067]                     }
[10:22:52.067]                     muffleCondition(cond, pattern = "^muffle")
[10:22:52.067]                   }
[10:22:52.067]                 }
[10:22:52.067]                 else {
[10:22:52.067]                   if (TRUE) {
[10:22:52.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:52.067]                     {
[10:22:52.067]                       inherits <- base::inherits
[10:22:52.067]                       invokeRestart <- base::invokeRestart
[10:22:52.067]                       is.null <- base::is.null
[10:22:52.067]                       muffled <- FALSE
[10:22:52.067]                       if (inherits(cond, "message")) {
[10:22:52.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:52.067]                         if (muffled) 
[10:22:52.067]                           invokeRestart("muffleMessage")
[10:22:52.067]                       }
[10:22:52.067]                       else if (inherits(cond, "warning")) {
[10:22:52.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:52.067]                         if (muffled) 
[10:22:52.067]                           invokeRestart("muffleWarning")
[10:22:52.067]                       }
[10:22:52.067]                       else if (inherits(cond, "condition")) {
[10:22:52.067]                         if (!is.null(pattern)) {
[10:22:52.067]                           computeRestarts <- base::computeRestarts
[10:22:52.067]                           grepl <- base::grepl
[10:22:52.067]                           restarts <- computeRestarts(cond)
[10:22:52.067]                           for (restart in restarts) {
[10:22:52.067]                             name <- restart$name
[10:22:52.067]                             if (is.null(name)) 
[10:22:52.067]                               next
[10:22:52.067]                             if (!grepl(pattern, name)) 
[10:22:52.067]                               next
[10:22:52.067]                             invokeRestart(restart)
[10:22:52.067]                             muffled <- TRUE
[10:22:52.067]                             break
[10:22:52.067]                           }
[10:22:52.067]                         }
[10:22:52.067]                       }
[10:22:52.067]                       invisible(muffled)
[10:22:52.067]                     }
[10:22:52.067]                     muffleCondition(cond, pattern = "^muffle")
[10:22:52.067]                   }
[10:22:52.067]                 }
[10:22:52.067]             }
[10:22:52.067]         }))
[10:22:52.067]     }, error = function(ex) {
[10:22:52.067]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:52.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:52.067]                 ...future.rng), started = ...future.startTime, 
[10:22:52.067]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:52.067]             version = "1.8"), class = "FutureResult")
[10:22:52.067]     }, finally = {
[10:22:52.067]         if (!identical(...future.workdir, getwd())) 
[10:22:52.067]             setwd(...future.workdir)
[10:22:52.067]         {
[10:22:52.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:52.067]                 ...future.oldOptions$nwarnings <- NULL
[10:22:52.067]             }
[10:22:52.067]             base::options(...future.oldOptions)
[10:22:52.067]             if (.Platform$OS.type == "windows") {
[10:22:52.067]                 old_names <- names(...future.oldEnvVars)
[10:22:52.067]                 envs <- base::Sys.getenv()
[10:22:52.067]                 names <- names(envs)
[10:22:52.067]                 common <- intersect(names, old_names)
[10:22:52.067]                 added <- setdiff(names, old_names)
[10:22:52.067]                 removed <- setdiff(old_names, names)
[10:22:52.067]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:52.067]                   envs[common]]
[10:22:52.067]                 NAMES <- toupper(changed)
[10:22:52.067]                 args <- list()
[10:22:52.067]                 for (kk in seq_along(NAMES)) {
[10:22:52.067]                   name <- changed[[kk]]
[10:22:52.067]                   NAME <- NAMES[[kk]]
[10:22:52.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:52.067]                     next
[10:22:52.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:52.067]                 }
[10:22:52.067]                 NAMES <- toupper(added)
[10:22:52.067]                 for (kk in seq_along(NAMES)) {
[10:22:52.067]                   name <- added[[kk]]
[10:22:52.067]                   NAME <- NAMES[[kk]]
[10:22:52.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:52.067]                     next
[10:22:52.067]                   args[[name]] <- ""
[10:22:52.067]                 }
[10:22:52.067]                 NAMES <- toupper(removed)
[10:22:52.067]                 for (kk in seq_along(NAMES)) {
[10:22:52.067]                   name <- removed[[kk]]
[10:22:52.067]                   NAME <- NAMES[[kk]]
[10:22:52.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:52.067]                     next
[10:22:52.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:52.067]                 }
[10:22:52.067]                 if (length(args) > 0) 
[10:22:52.067]                   base::do.call(base::Sys.setenv, args = args)
[10:22:52.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:52.067]             }
[10:22:52.067]             else {
[10:22:52.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:52.067]             }
[10:22:52.067]             {
[10:22:52.067]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:52.067]                   0L) {
[10:22:52.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:52.067]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:52.067]                   base::options(opts)
[10:22:52.067]                 }
[10:22:52.067]                 {
[10:22:52.067]                   {
[10:22:52.067]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:52.067]                     NULL
[10:22:52.067]                   }
[10:22:52.067]                   options(future.plan = NULL)
[10:22:52.067]                   if (is.na(NA_character_)) 
[10:22:52.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:52.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:52.067]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:52.067]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:52.067]                     envir = parent.frame()) 
[10:22:52.067]                   {
[10:22:52.067]                     if (is.function(workers)) 
[10:22:52.067]                       workers <- workers()
[10:22:52.067]                     workers <- structure(as.integer(workers), 
[10:22:52.067]                       class = class(workers))
[10:22:52.067]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:52.067]                       workers >= 1)
[10:22:52.067]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:52.067]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:52.067]                     }
[10:22:52.067]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:52.067]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:52.067]                       envir = envir)
[10:22:52.067]                     if (!future$lazy) 
[10:22:52.067]                       future <- run(future)
[10:22:52.067]                     invisible(future)
[10:22:52.067]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:52.067]                 }
[10:22:52.067]             }
[10:22:52.067]         }
[10:22:52.067]     })
[10:22:52.067]     if (TRUE) {
[10:22:52.067]         base::sink(type = "output", split = FALSE)
[10:22:52.067]         if (TRUE) {
[10:22:52.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:52.067]         }
[10:22:52.067]         else {
[10:22:52.067]             ...future.result["stdout"] <- base::list(NULL)
[10:22:52.067]         }
[10:22:52.067]         base::close(...future.stdout)
[10:22:52.067]         ...future.stdout <- NULL
[10:22:52.067]     }
[10:22:52.067]     ...future.result$conditions <- ...future.conditions
[10:22:52.067]     ...future.result$finished <- base::Sys.time()
[10:22:52.067]     ...future.result
[10:22:52.067] }
[10:22:52.069] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:22:52.070] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:22:52.070] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:22:52.070] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:52.070] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:52.071] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:22:52.071] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:22:52.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:52.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:52.072] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:22:52.072] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:22:52.072] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:22:52.072] MultisessionFuture started
[10:22:52.073] - Launch lazy future ... done
[10:22:52.073] run() for ‘MultisessionFuture’ ... done
[10:22:52.073] Created future:
[10:22:52.073] MultisessionFuture:
[10:22:52.073] Label: ‘future_by-2’
[10:22:52.073] Expression:
[10:22:52.073] {
[10:22:52.073]     do.call(function(...) {
[10:22:52.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:52.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:52.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:52.073]             on.exit(options(oopts), add = TRUE)
[10:22:52.073]         }
[10:22:52.073]         {
[10:22:52.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:52.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:52.073]                 ...future.FUN(...future.X_jj, ...)
[10:22:52.073]             })
[10:22:52.073]         }
[10:22:52.073]     }, args = future.call.arguments)
[10:22:52.073] }
[10:22:52.073] Lazy evaluation: FALSE
[10:22:52.073] Asynchronous evaluation: TRUE
[10:22:52.073] Local evaluation: TRUE
[10:22:52.073] Environment: 0x55f63ba65e40
[10:22:52.073] Capture standard output: TRUE
[10:22:52.073] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:52.073] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:22:52.073] Packages: <none>
[10:22:52.073] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:52.073] Resolved: FALSE
[10:22:52.073] Value: <not collected>
[10:22:52.073] Conditions captured: <none>
[10:22:52.073] Early signaling: FALSE
[10:22:52.073] Owner process: e53eed97-2a49-ddc6-5f9b-1a6635de41bb
[10:22:52.073] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:52.085] Chunk #2 of 2 ... DONE
[10:22:52.085] Launching 2 futures (chunks) ... DONE
[10:22:52.085] Resolving 2 futures (chunks) ...
[10:22:52.085] resolve() on list ...
[10:22:52.085]  recursive: 0
[10:22:52.085]  length: 2
[10:22:52.085] 
[10:22:52.086] receiveMessageFromWorker() for ClusterFuture ...
[10:22:52.086] - Validating connection of MultisessionFuture
[10:22:52.086] - received message: FutureResult
[10:22:52.086] - Received FutureResult
[10:22:52.086] - Erased future from FutureRegistry
[10:22:52.086] result() for ClusterFuture ...
[10:22:52.086] - result already collected: FutureResult
[10:22:52.086] result() for ClusterFuture ... done
[10:22:52.087] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:52.087] Future #1
[10:22:52.087] result() for ClusterFuture ...
[10:22:52.087] - result already collected: FutureResult
[10:22:52.087] result() for ClusterFuture ... done
[10:22:52.087] result() for ClusterFuture ...
[10:22:52.087] - result already collected: FutureResult
[10:22:52.087] result() for ClusterFuture ... done
[10:22:52.087] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:52.087] - nx: 2
[10:22:52.087] - relay: TRUE
[10:22:52.088] - stdout: TRUE
[10:22:52.088] - signal: TRUE
[10:22:52.088] - resignal: FALSE
[10:22:52.088] - force: TRUE
[10:22:52.088] - relayed: [n=2] FALSE, FALSE
[10:22:52.088] - queued futures: [n=2] FALSE, FALSE
[10:22:52.088]  - until=1
[10:22:52.088]  - relaying element #1
[10:22:52.088] result() for ClusterFuture ...
[10:22:52.088] - result already collected: FutureResult
[10:22:52.088] result() for ClusterFuture ... done
[10:22:52.088] result() for ClusterFuture ...
[10:22:52.089] - result already collected: FutureResult
[10:22:52.089] result() for ClusterFuture ... done
[10:22:52.089] result() for ClusterFuture ...
[10:22:52.089] - result already collected: FutureResult
[10:22:52.089] result() for ClusterFuture ... done
[10:22:52.089] result() for ClusterFuture ...
[10:22:52.089] - result already collected: FutureResult
[10:22:52.089] result() for ClusterFuture ... done
[10:22:52.089] - relayed: [n=2] TRUE, FALSE
[10:22:52.089] - queued futures: [n=2] TRUE, FALSE
[10:22:52.089] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:52.090]  length: 1 (resolved future 1)
[10:22:52.119] receiveMessageFromWorker() for ClusterFuture ...
[10:22:52.119] - Validating connection of MultisessionFuture
[10:22:52.120] - received message: FutureResult
[10:22:52.120] - Received FutureResult
[10:22:52.120] - Erased future from FutureRegistry
[10:22:52.120] result() for ClusterFuture ...
[10:22:52.120] - result already collected: FutureResult
[10:22:52.120] result() for ClusterFuture ... done
[10:22:52.120] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:52.120] Future #2
[10:22:52.120] result() for ClusterFuture ...
[10:22:52.120] - result already collected: FutureResult
[10:22:52.121] result() for ClusterFuture ... done
[10:22:52.121] result() for ClusterFuture ...
[10:22:52.121] - result already collected: FutureResult
[10:22:52.121] result() for ClusterFuture ... done
[10:22:52.121] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:52.121] - nx: 2
[10:22:52.121] - relay: TRUE
[10:22:52.121] - stdout: TRUE
[10:22:52.121] - signal: TRUE
[10:22:52.121] - resignal: FALSE
[10:22:52.121] - force: TRUE
[10:22:52.122] - relayed: [n=2] TRUE, FALSE
[10:22:52.122] - queued futures: [n=2] TRUE, FALSE
[10:22:52.122]  - until=2
[10:22:52.122]  - relaying element #2
[10:22:52.122] result() for ClusterFuture ...
[10:22:52.122] - result already collected: FutureResult
[10:22:52.122] result() for ClusterFuture ... done
[10:22:52.122] result() for ClusterFuture ...
[10:22:52.122] - result already collected: FutureResult
[10:22:52.122] result() for ClusterFuture ... done
[10:22:52.122] result() for ClusterFuture ...
[10:22:52.122] - result already collected: FutureResult
[10:22:52.123] result() for ClusterFuture ... done
[10:22:52.123] result() for ClusterFuture ...
[10:22:52.123] - result already collected: FutureResult
[10:22:52.123] result() for ClusterFuture ... done
[10:22:52.123] - relayed: [n=2] TRUE, TRUE
[10:22:52.123] - queued futures: [n=2] TRUE, TRUE
[10:22:52.123] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:52.123]  length: 0 (resolved future 2)
[10:22:52.123] Relaying remaining futures
[10:22:52.123] signalConditionsASAP(NULL, pos=0) ...
[10:22:52.123] - nx: 2
[10:22:52.124] - relay: TRUE
[10:22:52.124] - stdout: TRUE
[10:22:52.124] - signal: TRUE
[10:22:52.124] - resignal: FALSE
[10:22:52.124] - force: TRUE
[10:22:52.124] - relayed: [n=2] TRUE, TRUE
[10:22:52.124] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:52.124] - relayed: [n=2] TRUE, TRUE
[10:22:52.124] - queued futures: [n=2] TRUE, TRUE
[10:22:52.124] signalConditionsASAP(NULL, pos=0) ... done
[10:22:52.124] resolve() on list ... DONE
[10:22:52.125] result() for ClusterFuture ...
[10:22:52.125] - result already collected: FutureResult
[10:22:52.125] result() for ClusterFuture ... done
[10:22:52.125] result() for ClusterFuture ...
[10:22:52.125] - result already collected: FutureResult
[10:22:52.125] result() for ClusterFuture ... done
[10:22:52.125] result() for ClusterFuture ...
[10:22:52.125] - result already collected: FutureResult
[10:22:52.125] result() for ClusterFuture ... done
[10:22:52.125] result() for ClusterFuture ...
[10:22:52.126] - result already collected: FutureResult
[10:22:52.126] result() for ClusterFuture ... done
[10:22:52.126]  - Number of value chunks collected: 2
[10:22:52.126] Resolving 2 futures (chunks) ... DONE
[10:22:52.126] Reducing values from 2 chunks ...
[10:22:52.126]  - Number of values collected after concatenation: 3
[10:22:52.126]  - Number of values expected: 3
[10:22:52.126] Reducing values from 2 chunks ... DONE
[10:22:52.126] future_lapply() ... DONE
[10:22:52.126] future_by_internal() ... DONE
[10:22:52.127] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[10:22:52.128] plan(): Setting new future strategy stack:
[10:22:52.128] List of future strategies:
[10:22:52.128] 1. FutureStrategy:
[10:22:52.128]    - args: function (..., envir = parent.frame())
[10:22:52.128]    - tweaked: FALSE
[10:22:52.128]    - call: future::plan(oplan)
[10:22:52.129] plan(): nbrOfWorkers() = 1
> 
