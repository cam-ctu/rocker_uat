
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:20:01.533] plan(): Setting new future strategy stack:
[13:20:01.534] List of future strategies:
[13:20:01.534] 1. sequential:
[13:20:01.534]    - args: function (..., envir = parent.frame())
[13:20:01.534]    - tweaked: FALSE
[13:20:01.534]    - call: future::plan("sequential")
[13:20:01.549] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[13:20:01.607] plan(): Setting new future strategy stack:
[13:20:01.607] List of future strategies:
[13:20:01.607] 1. sequential:
[13:20:01.607]    - args: function (..., envir = parent.frame())
[13:20:01.607]    - tweaked: FALSE
[13:20:01.607]    - call: plan(strategy)
[13:20:01.620] plan(): nbrOfWorkers() = 1
[13:20:01.620] future_by_internal() ...
[13:20:01.621] future_lapply() ...
[13:20:01.625] Number of chunks: 1
[13:20:01.626] getGlobalsAndPackagesXApply() ...
[13:20:01.626]  - future.globals: TRUE
[13:20:01.626] getGlobalsAndPackages() ...
[13:20:01.626] Searching for globals...
[13:20:01.629] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:01.629] Searching for globals ... DONE
[13:20:01.629] Resolving globals: FALSE
[13:20:01.630] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:01.631] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:01.631] - globals: [1] ‘FUN’
[13:20:01.631] 
[13:20:01.631] getGlobalsAndPackages() ... DONE
[13:20:01.631]  - globals found/used: [n=1] ‘FUN’
[13:20:01.631]  - needed namespaces: [n=0] 
[13:20:01.631] Finding globals ... DONE
[13:20:01.631]  - use_args: TRUE
[13:20:01.631]  - Getting '...' globals ...
[13:20:01.632] resolve() on list ...
[13:20:01.632]  recursive: 0
[13:20:01.633]  length: 1
[13:20:01.633]  elements: ‘...’
[13:20:01.633]  length: 0 (resolved future 1)
[13:20:01.633] resolve() on list ... DONE
[13:20:01.633]    - '...' content: [n=0] 
[13:20:01.633] List of 1
[13:20:01.633]  $ ...: list()
[13:20:01.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.633]  - attr(*, "where")=List of 1
[13:20:01.633]   ..$ ...:<environment: 0x55acec8794d8> 
[13:20:01.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.633]  - attr(*, "resolved")= logi TRUE
[13:20:01.633]  - attr(*, "total_size")= num NA
[13:20:01.638]  - Getting '...' globals ... DONE
[13:20:01.638] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.638] List of 2
[13:20:01.638]  $ ...future.FUN:function (object, ...)  
[13:20:01.638]  $ ...          : list()
[13:20:01.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.638]  - attr(*, "where")=List of 2
[13:20:01.638]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.638]   ..$ ...          :<environment: 0x55acec8794d8> 
[13:20:01.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.638]  - attr(*, "resolved")= logi FALSE
[13:20:01.638]  - attr(*, "total_size")= num 1240
[13:20:01.641] Packages to be attached in all futures: [n=0] 
[13:20:01.641] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.641] Number of futures (= number of chunks): 1
[13:20:01.641] Launching 1 futures (chunks) ...
[13:20:01.641] Chunk #1 of 1 ...
[13:20:01.642]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.642] getGlobalsAndPackages() ...
[13:20:01.642] Searching for globals...
[13:20:01.642] 
[13:20:01.643] Searching for globals ... DONE
[13:20:01.643] - globals: [0] <none>
[13:20:01.643] getGlobalsAndPackages() ... DONE
[13:20:01.643]    + additional globals found: [n=0] 
[13:20:01.643]    + additional namespaces needed: [n=0] 
[13:20:01.643]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.643]  - seeds: <none>
[13:20:01.643]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.643] getGlobalsAndPackages() ...
[13:20:01.643] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.644] Resolving globals: FALSE
[13:20:01.644] Tweak future expression to call with '...' arguments ...
[13:20:01.644] {
[13:20:01.644]     do.call(function(...) {
[13:20:01.644]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.644]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.644]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.644]             on.exit(options(oopts), add = TRUE)
[13:20:01.644]         }
[13:20:01.644]         {
[13:20:01.644]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.644]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.644]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.644]             })
[13:20:01.644]         }
[13:20:01.644]     }, args = future.call.arguments)
[13:20:01.644] }
[13:20:01.644] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.645] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.645] 
[13:20:01.645] getGlobalsAndPackages() ... DONE
[13:20:01.646] run() for ‘Future’ ...
[13:20:01.646] - state: ‘created’
[13:20:01.646] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:01.646] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.646]   - Field: ‘label’
[13:20:01.647]   - Field: ‘local’
[13:20:01.647]   - Field: ‘owner’
[13:20:01.650]   - Field: ‘envir’
[13:20:01.650]   - Field: ‘packages’
[13:20:01.650]   - Field: ‘gc’
[13:20:01.650]   - Field: ‘conditions’
[13:20:01.650]   - Field: ‘expr’
[13:20:01.650]   - Field: ‘uuid’
[13:20:01.650]   - Field: ‘seed’
[13:20:01.650]   - Field: ‘version’
[13:20:01.650]   - Field: ‘result’
[13:20:01.650]   - Field: ‘asynchronous’
[13:20:01.651]   - Field: ‘calls’
[13:20:01.651]   - Field: ‘globals’
[13:20:01.651]   - Field: ‘stdout’
[13:20:01.651]   - Field: ‘earlySignal’
[13:20:01.651]   - Field: ‘lazy’
[13:20:01.651]   - Field: ‘state’
[13:20:01.651] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.651] - Launch lazy future ...
[13:20:01.652] Packages needed by the future expression (n = 0): <none>
[13:20:01.652] Packages needed by future strategies (n = 0): <none>
[13:20:01.653] {
[13:20:01.653]     {
[13:20:01.653]         {
[13:20:01.653]             ...future.startTime <- base::Sys.time()
[13:20:01.653]             {
[13:20:01.653]                 {
[13:20:01.653]                   {
[13:20:01.653]                     base::local({
[13:20:01.653]                       has_future <- base::requireNamespace("future", 
[13:20:01.653]                         quietly = TRUE)
[13:20:01.653]                       if (has_future) {
[13:20:01.653]                         ns <- base::getNamespace("future")
[13:20:01.653]                         version <- ns[[".package"]][["version"]]
[13:20:01.653]                         if (is.null(version)) 
[13:20:01.653]                           version <- utils::packageVersion("future")
[13:20:01.653]                       }
[13:20:01.653]                       else {
[13:20:01.653]                         version <- NULL
[13:20:01.653]                       }
[13:20:01.653]                       if (!has_future || version < "1.8.0") {
[13:20:01.653]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.653]                           "", base::R.version$version.string), 
[13:20:01.653]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:01.653]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.653]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.653]                             "release", "version")], collapse = " "), 
[13:20:01.653]                           hostname = base::Sys.info()[["nodename"]])
[13:20:01.653]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.653]                           info)
[13:20:01.653]                         info <- base::paste(info, collapse = "; ")
[13:20:01.653]                         if (!has_future) {
[13:20:01.653]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.653]                             info)
[13:20:01.653]                         }
[13:20:01.653]                         else {
[13:20:01.653]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.653]                             info, version)
[13:20:01.653]                         }
[13:20:01.653]                         base::stop(msg)
[13:20:01.653]                       }
[13:20:01.653]                     })
[13:20:01.653]                   }
[13:20:01.653]                   options(future.plan = NULL)
[13:20:01.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.653]                 }
[13:20:01.653]                 ...future.workdir <- getwd()
[13:20:01.653]             }
[13:20:01.653]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.653]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.653]         }
[13:20:01.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.653]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.653]             base::names(...future.oldOptions))
[13:20:01.653]     }
[13:20:01.653]     if (FALSE) {
[13:20:01.653]     }
[13:20:01.653]     else {
[13:20:01.653]         if (TRUE) {
[13:20:01.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.653]                 open = "w")
[13:20:01.653]         }
[13:20:01.653]         else {
[13:20:01.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.653]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.653]         }
[13:20:01.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.653]             base::sink(type = "output", split = FALSE)
[13:20:01.653]             base::close(...future.stdout)
[13:20:01.653]         }, add = TRUE)
[13:20:01.653]     }
[13:20:01.653]     ...future.frame <- base::sys.nframe()
[13:20:01.653]     ...future.conditions <- base::list()
[13:20:01.653]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.653]     if (FALSE) {
[13:20:01.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.653]     }
[13:20:01.653]     ...future.result <- base::tryCatch({
[13:20:01.653]         base::withCallingHandlers({
[13:20:01.653]             ...future.value <- base::withVisible(base::local({
[13:20:01.653]                 do.call(function(...) {
[13:20:01.653]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.653]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.653]                     ...future.globals.maxSize)) {
[13:20:01.653]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.653]                     on.exit(options(oopts), add = TRUE)
[13:20:01.653]                   }
[13:20:01.653]                   {
[13:20:01.653]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.653]                       FUN = function(jj) {
[13:20:01.653]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.653]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.653]                       })
[13:20:01.653]                   }
[13:20:01.653]                 }, args = future.call.arguments)
[13:20:01.653]             }))
[13:20:01.653]             future::FutureResult(value = ...future.value$value, 
[13:20:01.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.653]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.653]                     ...future.globalenv.names))
[13:20:01.653]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.653]         }, condition = base::local({
[13:20:01.653]             c <- base::c
[13:20:01.653]             inherits <- base::inherits
[13:20:01.653]             invokeRestart <- base::invokeRestart
[13:20:01.653]             length <- base::length
[13:20:01.653]             list <- base::list
[13:20:01.653]             seq.int <- base::seq.int
[13:20:01.653]             signalCondition <- base::signalCondition
[13:20:01.653]             sys.calls <- base::sys.calls
[13:20:01.653]             `[[` <- base::`[[`
[13:20:01.653]             `+` <- base::`+`
[13:20:01.653]             `<<-` <- base::`<<-`
[13:20:01.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.653]                   3L)]
[13:20:01.653]             }
[13:20:01.653]             function(cond) {
[13:20:01.653]                 is_error <- inherits(cond, "error")
[13:20:01.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.653]                   NULL)
[13:20:01.653]                 if (is_error) {
[13:20:01.653]                   sessionInformation <- function() {
[13:20:01.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.653]                       search = base::search(), system = base::Sys.info())
[13:20:01.653]                   }
[13:20:01.653]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.653]                     cond$call), session = sessionInformation(), 
[13:20:01.653]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.653]                   signalCondition(cond)
[13:20:01.653]                 }
[13:20:01.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.653]                 "immediateCondition"))) {
[13:20:01.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.653]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.653]                   if (TRUE && !signal) {
[13:20:01.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.653]                     {
[13:20:01.653]                       inherits <- base::inherits
[13:20:01.653]                       invokeRestart <- base::invokeRestart
[13:20:01.653]                       is.null <- base::is.null
[13:20:01.653]                       muffled <- FALSE
[13:20:01.653]                       if (inherits(cond, "message")) {
[13:20:01.653]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.653]                         if (muffled) 
[13:20:01.653]                           invokeRestart("muffleMessage")
[13:20:01.653]                       }
[13:20:01.653]                       else if (inherits(cond, "warning")) {
[13:20:01.653]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.653]                         if (muffled) 
[13:20:01.653]                           invokeRestart("muffleWarning")
[13:20:01.653]                       }
[13:20:01.653]                       else if (inherits(cond, "condition")) {
[13:20:01.653]                         if (!is.null(pattern)) {
[13:20:01.653]                           computeRestarts <- base::computeRestarts
[13:20:01.653]                           grepl <- base::grepl
[13:20:01.653]                           restarts <- computeRestarts(cond)
[13:20:01.653]                           for (restart in restarts) {
[13:20:01.653]                             name <- restart$name
[13:20:01.653]                             if (is.null(name)) 
[13:20:01.653]                               next
[13:20:01.653]                             if (!grepl(pattern, name)) 
[13:20:01.653]                               next
[13:20:01.653]                             invokeRestart(restart)
[13:20:01.653]                             muffled <- TRUE
[13:20:01.653]                             break
[13:20:01.653]                           }
[13:20:01.653]                         }
[13:20:01.653]                       }
[13:20:01.653]                       invisible(muffled)
[13:20:01.653]                     }
[13:20:01.653]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.653]                   }
[13:20:01.653]                 }
[13:20:01.653]                 else {
[13:20:01.653]                   if (TRUE) {
[13:20:01.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.653]                     {
[13:20:01.653]                       inherits <- base::inherits
[13:20:01.653]                       invokeRestart <- base::invokeRestart
[13:20:01.653]                       is.null <- base::is.null
[13:20:01.653]                       muffled <- FALSE
[13:20:01.653]                       if (inherits(cond, "message")) {
[13:20:01.653]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.653]                         if (muffled) 
[13:20:01.653]                           invokeRestart("muffleMessage")
[13:20:01.653]                       }
[13:20:01.653]                       else if (inherits(cond, "warning")) {
[13:20:01.653]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.653]                         if (muffled) 
[13:20:01.653]                           invokeRestart("muffleWarning")
[13:20:01.653]                       }
[13:20:01.653]                       else if (inherits(cond, "condition")) {
[13:20:01.653]                         if (!is.null(pattern)) {
[13:20:01.653]                           computeRestarts <- base::computeRestarts
[13:20:01.653]                           grepl <- base::grepl
[13:20:01.653]                           restarts <- computeRestarts(cond)
[13:20:01.653]                           for (restart in restarts) {
[13:20:01.653]                             name <- restart$name
[13:20:01.653]                             if (is.null(name)) 
[13:20:01.653]                               next
[13:20:01.653]                             if (!grepl(pattern, name)) 
[13:20:01.653]                               next
[13:20:01.653]                             invokeRestart(restart)
[13:20:01.653]                             muffled <- TRUE
[13:20:01.653]                             break
[13:20:01.653]                           }
[13:20:01.653]                         }
[13:20:01.653]                       }
[13:20:01.653]                       invisible(muffled)
[13:20:01.653]                     }
[13:20:01.653]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.653]                   }
[13:20:01.653]                 }
[13:20:01.653]             }
[13:20:01.653]         }))
[13:20:01.653]     }, error = function(ex) {
[13:20:01.653]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.653]                 ...future.rng), started = ...future.startTime, 
[13:20:01.653]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.653]             version = "1.8"), class = "FutureResult")
[13:20:01.653]     }, finally = {
[13:20:01.653]         if (!identical(...future.workdir, getwd())) 
[13:20:01.653]             setwd(...future.workdir)
[13:20:01.653]         {
[13:20:01.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.653]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.653]             }
[13:20:01.653]             base::options(...future.oldOptions)
[13:20:01.653]             if (.Platform$OS.type == "windows") {
[13:20:01.653]                 old_names <- names(...future.oldEnvVars)
[13:20:01.653]                 envs <- base::Sys.getenv()
[13:20:01.653]                 names <- names(envs)
[13:20:01.653]                 common <- intersect(names, old_names)
[13:20:01.653]                 added <- setdiff(names, old_names)
[13:20:01.653]                 removed <- setdiff(old_names, names)
[13:20:01.653]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.653]                   envs[common]]
[13:20:01.653]                 NAMES <- toupper(changed)
[13:20:01.653]                 args <- list()
[13:20:01.653]                 for (kk in seq_along(NAMES)) {
[13:20:01.653]                   name <- changed[[kk]]
[13:20:01.653]                   NAME <- NAMES[[kk]]
[13:20:01.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.653]                     next
[13:20:01.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.653]                 }
[13:20:01.653]                 NAMES <- toupper(added)
[13:20:01.653]                 for (kk in seq_along(NAMES)) {
[13:20:01.653]                   name <- added[[kk]]
[13:20:01.653]                   NAME <- NAMES[[kk]]
[13:20:01.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.653]                     next
[13:20:01.653]                   args[[name]] <- ""
[13:20:01.653]                 }
[13:20:01.653]                 NAMES <- toupper(removed)
[13:20:01.653]                 for (kk in seq_along(NAMES)) {
[13:20:01.653]                   name <- removed[[kk]]
[13:20:01.653]                   NAME <- NAMES[[kk]]
[13:20:01.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.653]                     next
[13:20:01.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.653]                 }
[13:20:01.653]                 if (length(args) > 0) 
[13:20:01.653]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.653]             }
[13:20:01.653]             else {
[13:20:01.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.653]             }
[13:20:01.653]             {
[13:20:01.653]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.653]                   0L) {
[13:20:01.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.653]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.653]                   base::options(opts)
[13:20:01.653]                 }
[13:20:01.653]                 {
[13:20:01.653]                   {
[13:20:01.653]                     NULL
[13:20:01.653]                     RNGkind("Mersenne-Twister")
[13:20:01.653]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.653]                       inherits = FALSE)
[13:20:01.653]                   }
[13:20:01.653]                   options(future.plan = NULL)
[13:20:01.653]                   if (is.na(NA_character_)) 
[13:20:01.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.653]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:01.653]                   {
[13:20:01.653]                     future <- SequentialFuture(..., envir = envir)
[13:20:01.653]                     if (!future$lazy) 
[13:20:01.653]                       future <- run(future)
[13:20:01.653]                     invisible(future)
[13:20:01.653]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.653]                 }
[13:20:01.653]             }
[13:20:01.653]         }
[13:20:01.653]     })
[13:20:01.653]     if (TRUE) {
[13:20:01.653]         base::sink(type = "output", split = FALSE)
[13:20:01.653]         if (TRUE) {
[13:20:01.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.653]         }
[13:20:01.653]         else {
[13:20:01.653]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.653]         }
[13:20:01.653]         base::close(...future.stdout)
[13:20:01.653]         ...future.stdout <- NULL
[13:20:01.653]     }
[13:20:01.653]     ...future.result$conditions <- ...future.conditions
[13:20:01.653]     ...future.result$finished <- base::Sys.time()
[13:20:01.653]     ...future.result
[13:20:01.653] }
[13:20:01.655] assign_globals() ...
[13:20:01.655] List of 5
[13:20:01.655]  $ ...future.FUN            :function (object, ...)  
[13:20:01.655]  $ future.call.arguments    : list()
[13:20:01.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.655]  $ ...future.elements_ii    :List of 3
[13:20:01.655]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:01.655]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:01.655]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.655]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:01.655]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:01.655]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.655]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:01.655]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:01.655]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.655]  $ ...future.seeds_ii       : NULL
[13:20:01.655]  $ ...future.globals.maxSize: NULL
[13:20:01.655]  - attr(*, "where")=List of 5
[13:20:01.655]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.655]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.655]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.655]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.655]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.655]  - attr(*, "resolved")= logi FALSE
[13:20:01.655]  - attr(*, "total_size")= num 1240
[13:20:01.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.655]  - attr(*, "already-done")= logi TRUE
[13:20:01.663] - copied ‘...future.FUN’ to environment
[13:20:01.664] - copied ‘future.call.arguments’ to environment
[13:20:01.664] - copied ‘...future.elements_ii’ to environment
[13:20:01.664] - copied ‘...future.seeds_ii’ to environment
[13:20:01.664] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.664] assign_globals() ... done
[13:20:01.664] plan(): Setting new future strategy stack:
[13:20:01.664] List of future strategies:
[13:20:01.664] 1. sequential:
[13:20:01.664]    - args: function (..., envir = parent.frame())
[13:20:01.664]    - tweaked: FALSE
[13:20:01.664]    - call: NULL
[13:20:01.665] plan(): nbrOfWorkers() = 1
[13:20:01.668] plan(): Setting new future strategy stack:
[13:20:01.668] List of future strategies:
[13:20:01.668] 1. sequential:
[13:20:01.668]    - args: function (..., envir = parent.frame())
[13:20:01.668]    - tweaked: FALSE
[13:20:01.668]    - call: plan(strategy)
[13:20:01.668] plan(): nbrOfWorkers() = 1
[13:20:01.668] SequentialFuture started (and completed)
[13:20:01.669] - Launch lazy future ... done
[13:20:01.669] run() for ‘SequentialFuture’ ... done
[13:20:01.669] Created future:
[13:20:01.669] SequentialFuture:
[13:20:01.669] Label: ‘future_by-1’
[13:20:01.669] Expression:
[13:20:01.669] {
[13:20:01.669]     do.call(function(...) {
[13:20:01.669]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.669]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.669]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.669]             on.exit(options(oopts), add = TRUE)
[13:20:01.669]         }
[13:20:01.669]         {
[13:20:01.669]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.669]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.669]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.669]             })
[13:20:01.669]         }
[13:20:01.669]     }, args = future.call.arguments)
[13:20:01.669] }
[13:20:01.669] Lazy evaluation: FALSE
[13:20:01.669] Asynchronous evaluation: FALSE
[13:20:01.669] Local evaluation: TRUE
[13:20:01.669] Environment: R_GlobalEnv
[13:20:01.669] Capture standard output: TRUE
[13:20:01.669] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.669] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:01.669] Packages: <none>
[13:20:01.669] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.669] Resolved: TRUE
[13:20:01.669] Value: 4.62 KiB of class ‘list’
[13:20:01.669] Early signaling: FALSE
[13:20:01.669] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.669] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.671] Chunk #1 of 1 ... DONE
[13:20:01.671] Launching 1 futures (chunks) ... DONE
[13:20:01.671] Resolving 1 futures (chunks) ...
[13:20:01.671] resolve() on list ...
[13:20:01.671]  recursive: 0
[13:20:01.671]  length: 1
[13:20:01.672] 
[13:20:01.672] resolved() for ‘SequentialFuture’ ...
[13:20:01.672] - state: ‘finished’
[13:20:01.672] - run: TRUE
[13:20:01.672] - result: ‘FutureResult’
[13:20:01.672] resolved() for ‘SequentialFuture’ ... done
[13:20:01.672] Future #1
[13:20:01.673] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.673] - nx: 1
[13:20:01.673] - relay: TRUE
[13:20:01.673] - stdout: TRUE
[13:20:01.673] - signal: TRUE
[13:20:01.673] - resignal: FALSE
[13:20:01.673] - force: TRUE
[13:20:01.673] - relayed: [n=1] FALSE
[13:20:01.673] - queued futures: [n=1] FALSE
[13:20:01.673]  - until=1
[13:20:01.674]  - relaying element #1
[13:20:01.674] - relayed: [n=1] TRUE
[13:20:01.674] - queued futures: [n=1] TRUE
[13:20:01.674] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.674]  length: 0 (resolved future 1)
[13:20:01.674] Relaying remaining futures
[13:20:01.674] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.674] - nx: 1
[13:20:01.675] - relay: TRUE
[13:20:01.675] - stdout: TRUE
[13:20:01.675] - signal: TRUE
[13:20:01.675] - resignal: FALSE
[13:20:01.675] - force: TRUE
[13:20:01.675] - relayed: [n=1] TRUE
[13:20:01.675] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.675] - relayed: [n=1] TRUE
[13:20:01.675] - queued futures: [n=1] TRUE
[13:20:01.675] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.675] resolve() on list ... DONE
[13:20:01.676]  - Number of value chunks collected: 1
[13:20:01.676] Resolving 1 futures (chunks) ... DONE
[13:20:01.676] Reducing values from 1 chunks ...
[13:20:01.676]  - Number of values collected after concatenation: 3
[13:20:01.676]  - Number of values expected: 3
[13:20:01.676] Reducing values from 1 chunks ... DONE
[13:20:01.676] future_lapply() ... DONE
[13:20:01.676] future_by_internal() ... DONE
[13:20:01.680] future_by_internal() ...
[13:20:01.680] future_lapply() ...
[13:20:01.681] Number of chunks: 1
[13:20:01.681] getGlobalsAndPackagesXApply() ...
[13:20:01.681]  - future.globals: TRUE
[13:20:01.681] getGlobalsAndPackages() ...
[13:20:01.681] Searching for globals...
[13:20:01.682] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:01.682] Searching for globals ... DONE
[13:20:01.682] Resolving globals: FALSE
[13:20:01.683] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:01.683] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:01.683] - globals: [1] ‘FUN’
[13:20:01.683] 
[13:20:01.684] getGlobalsAndPackages() ... DONE
[13:20:01.684]  - globals found/used: [n=1] ‘FUN’
[13:20:01.684]  - needed namespaces: [n=0] 
[13:20:01.684] Finding globals ... DONE
[13:20:01.684]  - use_args: TRUE
[13:20:01.684]  - Getting '...' globals ...
[13:20:01.684] resolve() on list ...
[13:20:01.684]  recursive: 0
[13:20:01.685]  length: 1
[13:20:01.685]  elements: ‘...’
[13:20:01.685]  length: 0 (resolved future 1)
[13:20:01.685] resolve() on list ... DONE
[13:20:01.685]    - '...' content: [n=1] ‘digits’
[13:20:01.685] List of 1
[13:20:01.685]  $ ...:List of 1
[13:20:01.685]   ..$ digits: int 2
[13:20:01.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.685]  - attr(*, "where")=List of 1
[13:20:01.685]   ..$ ...:<environment: 0x55acede03410> 
[13:20:01.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.685]  - attr(*, "resolved")= logi TRUE
[13:20:01.685]  - attr(*, "total_size")= num NA
[13:20:01.688]  - Getting '...' globals ... DONE
[13:20:01.688] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.689] List of 2
[13:20:01.689]  $ ...future.FUN:function (object, ...)  
[13:20:01.689]  $ ...          :List of 1
[13:20:01.689]   ..$ digits: int 2
[13:20:01.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.689]  - attr(*, "where")=List of 2
[13:20:01.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.689]   ..$ ...          :<environment: 0x55acede03410> 
[13:20:01.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.689]  - attr(*, "resolved")= logi FALSE
[13:20:01.689]  - attr(*, "total_size")= num 1296
[13:20:01.692] Packages to be attached in all futures: [n=0] 
[13:20:01.692] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.692] Number of futures (= number of chunks): 1
[13:20:01.692] Launching 1 futures (chunks) ...
[13:20:01.692] Chunk #1 of 1 ...
[13:20:01.692]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.692] getGlobalsAndPackages() ...
[13:20:01.692] Searching for globals...
[13:20:01.693] 
[13:20:01.693] Searching for globals ... DONE
[13:20:01.693] - globals: [0] <none>
[13:20:01.693] getGlobalsAndPackages() ... DONE
[13:20:01.693]    + additional globals found: [n=0] 
[13:20:01.693]    + additional namespaces needed: [n=0] 
[13:20:01.693]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.693]  - seeds: <none>
[13:20:01.693]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.694] getGlobalsAndPackages() ...
[13:20:01.694] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.694] Resolving globals: FALSE
[13:20:01.694] Tweak future expression to call with '...' arguments ...
[13:20:01.694] {
[13:20:01.694]     do.call(function(...) {
[13:20:01.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.694]             on.exit(options(oopts), add = TRUE)
[13:20:01.694]         }
[13:20:01.694]         {
[13:20:01.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.694]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.694]             })
[13:20:01.694]         }
[13:20:01.694]     }, args = future.call.arguments)
[13:20:01.694] }
[13:20:01.694] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.695] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.695] 
[13:20:01.695] getGlobalsAndPackages() ... DONE
[13:20:01.695] run() for ‘Future’ ...
[13:20:01.695] - state: ‘created’
[13:20:01.695] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:01.696] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.696]   - Field: ‘label’
[13:20:01.696]   - Field: ‘local’
[13:20:01.696]   - Field: ‘owner’
[13:20:01.696]   - Field: ‘envir’
[13:20:01.696]   - Field: ‘packages’
[13:20:01.696]   - Field: ‘gc’
[13:20:01.696]   - Field: ‘conditions’
[13:20:01.696]   - Field: ‘expr’
[13:20:01.697]   - Field: ‘uuid’
[13:20:01.697]   - Field: ‘seed’
[13:20:01.697]   - Field: ‘version’
[13:20:01.697]   - Field: ‘result’
[13:20:01.697]   - Field: ‘asynchronous’
[13:20:01.697]   - Field: ‘calls’
[13:20:01.697]   - Field: ‘globals’
[13:20:01.697]   - Field: ‘stdout’
[13:20:01.697]   - Field: ‘earlySignal’
[13:20:01.697]   - Field: ‘lazy’
[13:20:01.697]   - Field: ‘state’
[13:20:01.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.698] - Launch lazy future ...
[13:20:01.698] Packages needed by the future expression (n = 0): <none>
[13:20:01.698] Packages needed by future strategies (n = 0): <none>
[13:20:01.698] {
[13:20:01.698]     {
[13:20:01.698]         {
[13:20:01.698]             ...future.startTime <- base::Sys.time()
[13:20:01.698]             {
[13:20:01.698]                 {
[13:20:01.698]                   {
[13:20:01.698]                     base::local({
[13:20:01.698]                       has_future <- base::requireNamespace("future", 
[13:20:01.698]                         quietly = TRUE)
[13:20:01.698]                       if (has_future) {
[13:20:01.698]                         ns <- base::getNamespace("future")
[13:20:01.698]                         version <- ns[[".package"]][["version"]]
[13:20:01.698]                         if (is.null(version)) 
[13:20:01.698]                           version <- utils::packageVersion("future")
[13:20:01.698]                       }
[13:20:01.698]                       else {
[13:20:01.698]                         version <- NULL
[13:20:01.698]                       }
[13:20:01.698]                       if (!has_future || version < "1.8.0") {
[13:20:01.698]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.698]                           "", base::R.version$version.string), 
[13:20:01.698]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:01.698]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.698]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.698]                             "release", "version")], collapse = " "), 
[13:20:01.698]                           hostname = base::Sys.info()[["nodename"]])
[13:20:01.698]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.698]                           info)
[13:20:01.698]                         info <- base::paste(info, collapse = "; ")
[13:20:01.698]                         if (!has_future) {
[13:20:01.698]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.698]                             info)
[13:20:01.698]                         }
[13:20:01.698]                         else {
[13:20:01.698]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.698]                             info, version)
[13:20:01.698]                         }
[13:20:01.698]                         base::stop(msg)
[13:20:01.698]                       }
[13:20:01.698]                     })
[13:20:01.698]                   }
[13:20:01.698]                   options(future.plan = NULL)
[13:20:01.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.698]                 }
[13:20:01.698]                 ...future.workdir <- getwd()
[13:20:01.698]             }
[13:20:01.698]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.698]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.698]         }
[13:20:01.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.698]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.698]             base::names(...future.oldOptions))
[13:20:01.698]     }
[13:20:01.698]     if (FALSE) {
[13:20:01.698]     }
[13:20:01.698]     else {
[13:20:01.698]         if (TRUE) {
[13:20:01.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.698]                 open = "w")
[13:20:01.698]         }
[13:20:01.698]         else {
[13:20:01.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.698]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.698]         }
[13:20:01.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.698]             base::sink(type = "output", split = FALSE)
[13:20:01.698]             base::close(...future.stdout)
[13:20:01.698]         }, add = TRUE)
[13:20:01.698]     }
[13:20:01.698]     ...future.frame <- base::sys.nframe()
[13:20:01.698]     ...future.conditions <- base::list()
[13:20:01.698]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.698]     if (FALSE) {
[13:20:01.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.698]     }
[13:20:01.698]     ...future.result <- base::tryCatch({
[13:20:01.698]         base::withCallingHandlers({
[13:20:01.698]             ...future.value <- base::withVisible(base::local({
[13:20:01.698]                 do.call(function(...) {
[13:20:01.698]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.698]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.698]                     ...future.globals.maxSize)) {
[13:20:01.698]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.698]                     on.exit(options(oopts), add = TRUE)
[13:20:01.698]                   }
[13:20:01.698]                   {
[13:20:01.698]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.698]                       FUN = function(jj) {
[13:20:01.698]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.698]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.698]                       })
[13:20:01.698]                   }
[13:20:01.698]                 }, args = future.call.arguments)
[13:20:01.698]             }))
[13:20:01.698]             future::FutureResult(value = ...future.value$value, 
[13:20:01.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.698]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.698]                     ...future.globalenv.names))
[13:20:01.698]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.698]         }, condition = base::local({
[13:20:01.698]             c <- base::c
[13:20:01.698]             inherits <- base::inherits
[13:20:01.698]             invokeRestart <- base::invokeRestart
[13:20:01.698]             length <- base::length
[13:20:01.698]             list <- base::list
[13:20:01.698]             seq.int <- base::seq.int
[13:20:01.698]             signalCondition <- base::signalCondition
[13:20:01.698]             sys.calls <- base::sys.calls
[13:20:01.698]             `[[` <- base::`[[`
[13:20:01.698]             `+` <- base::`+`
[13:20:01.698]             `<<-` <- base::`<<-`
[13:20:01.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.698]                   3L)]
[13:20:01.698]             }
[13:20:01.698]             function(cond) {
[13:20:01.698]                 is_error <- inherits(cond, "error")
[13:20:01.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.698]                   NULL)
[13:20:01.698]                 if (is_error) {
[13:20:01.698]                   sessionInformation <- function() {
[13:20:01.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.698]                       search = base::search(), system = base::Sys.info())
[13:20:01.698]                   }
[13:20:01.698]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.698]                     cond$call), session = sessionInformation(), 
[13:20:01.698]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.698]                   signalCondition(cond)
[13:20:01.698]                 }
[13:20:01.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.698]                 "immediateCondition"))) {
[13:20:01.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.698]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.698]                   if (TRUE && !signal) {
[13:20:01.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.698]                     {
[13:20:01.698]                       inherits <- base::inherits
[13:20:01.698]                       invokeRestart <- base::invokeRestart
[13:20:01.698]                       is.null <- base::is.null
[13:20:01.698]                       muffled <- FALSE
[13:20:01.698]                       if (inherits(cond, "message")) {
[13:20:01.698]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.698]                         if (muffled) 
[13:20:01.698]                           invokeRestart("muffleMessage")
[13:20:01.698]                       }
[13:20:01.698]                       else if (inherits(cond, "warning")) {
[13:20:01.698]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.698]                         if (muffled) 
[13:20:01.698]                           invokeRestart("muffleWarning")
[13:20:01.698]                       }
[13:20:01.698]                       else if (inherits(cond, "condition")) {
[13:20:01.698]                         if (!is.null(pattern)) {
[13:20:01.698]                           computeRestarts <- base::computeRestarts
[13:20:01.698]                           grepl <- base::grepl
[13:20:01.698]                           restarts <- computeRestarts(cond)
[13:20:01.698]                           for (restart in restarts) {
[13:20:01.698]                             name <- restart$name
[13:20:01.698]                             if (is.null(name)) 
[13:20:01.698]                               next
[13:20:01.698]                             if (!grepl(pattern, name)) 
[13:20:01.698]                               next
[13:20:01.698]                             invokeRestart(restart)
[13:20:01.698]                             muffled <- TRUE
[13:20:01.698]                             break
[13:20:01.698]                           }
[13:20:01.698]                         }
[13:20:01.698]                       }
[13:20:01.698]                       invisible(muffled)
[13:20:01.698]                     }
[13:20:01.698]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.698]                   }
[13:20:01.698]                 }
[13:20:01.698]                 else {
[13:20:01.698]                   if (TRUE) {
[13:20:01.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.698]                     {
[13:20:01.698]                       inherits <- base::inherits
[13:20:01.698]                       invokeRestart <- base::invokeRestart
[13:20:01.698]                       is.null <- base::is.null
[13:20:01.698]                       muffled <- FALSE
[13:20:01.698]                       if (inherits(cond, "message")) {
[13:20:01.698]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.698]                         if (muffled) 
[13:20:01.698]                           invokeRestart("muffleMessage")
[13:20:01.698]                       }
[13:20:01.698]                       else if (inherits(cond, "warning")) {
[13:20:01.698]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.698]                         if (muffled) 
[13:20:01.698]                           invokeRestart("muffleWarning")
[13:20:01.698]                       }
[13:20:01.698]                       else if (inherits(cond, "condition")) {
[13:20:01.698]                         if (!is.null(pattern)) {
[13:20:01.698]                           computeRestarts <- base::computeRestarts
[13:20:01.698]                           grepl <- base::grepl
[13:20:01.698]                           restarts <- computeRestarts(cond)
[13:20:01.698]                           for (restart in restarts) {
[13:20:01.698]                             name <- restart$name
[13:20:01.698]                             if (is.null(name)) 
[13:20:01.698]                               next
[13:20:01.698]                             if (!grepl(pattern, name)) 
[13:20:01.698]                               next
[13:20:01.698]                             invokeRestart(restart)
[13:20:01.698]                             muffled <- TRUE
[13:20:01.698]                             break
[13:20:01.698]                           }
[13:20:01.698]                         }
[13:20:01.698]                       }
[13:20:01.698]                       invisible(muffled)
[13:20:01.698]                     }
[13:20:01.698]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.698]                   }
[13:20:01.698]                 }
[13:20:01.698]             }
[13:20:01.698]         }))
[13:20:01.698]     }, error = function(ex) {
[13:20:01.698]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.698]                 ...future.rng), started = ...future.startTime, 
[13:20:01.698]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.698]             version = "1.8"), class = "FutureResult")
[13:20:01.698]     }, finally = {
[13:20:01.698]         if (!identical(...future.workdir, getwd())) 
[13:20:01.698]             setwd(...future.workdir)
[13:20:01.698]         {
[13:20:01.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.698]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.698]             }
[13:20:01.698]             base::options(...future.oldOptions)
[13:20:01.698]             if (.Platform$OS.type == "windows") {
[13:20:01.698]                 old_names <- names(...future.oldEnvVars)
[13:20:01.698]                 envs <- base::Sys.getenv()
[13:20:01.698]                 names <- names(envs)
[13:20:01.698]                 common <- intersect(names, old_names)
[13:20:01.698]                 added <- setdiff(names, old_names)
[13:20:01.698]                 removed <- setdiff(old_names, names)
[13:20:01.698]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.698]                   envs[common]]
[13:20:01.698]                 NAMES <- toupper(changed)
[13:20:01.698]                 args <- list()
[13:20:01.698]                 for (kk in seq_along(NAMES)) {
[13:20:01.698]                   name <- changed[[kk]]
[13:20:01.698]                   NAME <- NAMES[[kk]]
[13:20:01.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.698]                     next
[13:20:01.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.698]                 }
[13:20:01.698]                 NAMES <- toupper(added)
[13:20:01.698]                 for (kk in seq_along(NAMES)) {
[13:20:01.698]                   name <- added[[kk]]
[13:20:01.698]                   NAME <- NAMES[[kk]]
[13:20:01.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.698]                     next
[13:20:01.698]                   args[[name]] <- ""
[13:20:01.698]                 }
[13:20:01.698]                 NAMES <- toupper(removed)
[13:20:01.698]                 for (kk in seq_along(NAMES)) {
[13:20:01.698]                   name <- removed[[kk]]
[13:20:01.698]                   NAME <- NAMES[[kk]]
[13:20:01.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.698]                     next
[13:20:01.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.698]                 }
[13:20:01.698]                 if (length(args) > 0) 
[13:20:01.698]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.698]             }
[13:20:01.698]             else {
[13:20:01.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.698]             }
[13:20:01.698]             {
[13:20:01.698]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.698]                   0L) {
[13:20:01.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.698]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.698]                   base::options(opts)
[13:20:01.698]                 }
[13:20:01.698]                 {
[13:20:01.698]                   {
[13:20:01.698]                     NULL
[13:20:01.698]                     RNGkind("Mersenne-Twister")
[13:20:01.698]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.698]                       inherits = FALSE)
[13:20:01.698]                   }
[13:20:01.698]                   options(future.plan = NULL)
[13:20:01.698]                   if (is.na(NA_character_)) 
[13:20:01.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.698]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:01.698]                   {
[13:20:01.698]                     future <- SequentialFuture(..., envir = envir)
[13:20:01.698]                     if (!future$lazy) 
[13:20:01.698]                       future <- run(future)
[13:20:01.698]                     invisible(future)
[13:20:01.698]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.698]                 }
[13:20:01.698]             }
[13:20:01.698]         }
[13:20:01.698]     })
[13:20:01.698]     if (TRUE) {
[13:20:01.698]         base::sink(type = "output", split = FALSE)
[13:20:01.698]         if (TRUE) {
[13:20:01.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.698]         }
[13:20:01.698]         else {
[13:20:01.698]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.698]         }
[13:20:01.698]         base::close(...future.stdout)
[13:20:01.698]         ...future.stdout <- NULL
[13:20:01.698]     }
[13:20:01.698]     ...future.result$conditions <- ...future.conditions
[13:20:01.698]     ...future.result$finished <- base::Sys.time()
[13:20:01.698]     ...future.result
[13:20:01.698] }
[13:20:01.700] assign_globals() ...
[13:20:01.700] List of 5
[13:20:01.700]  $ ...future.FUN            :function (object, ...)  
[13:20:01.700]  $ future.call.arguments    :List of 1
[13:20:01.700]   ..$ digits: int 2
[13:20:01.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.700]  $ ...future.elements_ii    :List of 6
[13:20:01.700]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:20:01.700]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:20:01.700]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:20:01.700]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:20:01.700]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:20:01.700]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:20:01.700]  $ ...future.seeds_ii       : NULL
[13:20:01.700]  $ ...future.globals.maxSize: NULL
[13:20:01.700]  - attr(*, "where")=List of 5
[13:20:01.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.700]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.700]  - attr(*, "resolved")= logi FALSE
[13:20:01.700]  - attr(*, "total_size")= num 1296
[13:20:01.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.700]  - attr(*, "already-done")= logi TRUE
[13:20:01.709] - copied ‘...future.FUN’ to environment
[13:20:01.709] - copied ‘future.call.arguments’ to environment
[13:20:01.709] - copied ‘...future.elements_ii’ to environment
[13:20:01.709] - copied ‘...future.seeds_ii’ to environment
[13:20:01.709] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.709] assign_globals() ... done
[13:20:01.710] plan(): Setting new future strategy stack:
[13:20:01.710] List of future strategies:
[13:20:01.710] 1. sequential:
[13:20:01.710]    - args: function (..., envir = parent.frame())
[13:20:01.710]    - tweaked: FALSE
[13:20:01.710]    - call: NULL
[13:20:01.710] plan(): nbrOfWorkers() = 1
[13:20:01.711] plan(): Setting new future strategy stack:
[13:20:01.712] List of future strategies:
[13:20:01.712] 1. sequential:
[13:20:01.712]    - args: function (..., envir = parent.frame())
[13:20:01.712]    - tweaked: FALSE
[13:20:01.712]    - call: plan(strategy)
[13:20:01.712] plan(): nbrOfWorkers() = 1
[13:20:01.712] SequentialFuture started (and completed)
[13:20:01.712] - Launch lazy future ... done
[13:20:01.712] run() for ‘SequentialFuture’ ... done
[13:20:01.712] Created future:
[13:20:01.712] SequentialFuture:
[13:20:01.712] Label: ‘future_by-1’
[13:20:01.712] Expression:
[13:20:01.712] {
[13:20:01.712]     do.call(function(...) {
[13:20:01.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.712]             on.exit(options(oopts), add = TRUE)
[13:20:01.712]         }
[13:20:01.712]         {
[13:20:01.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.712]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.712]             })
[13:20:01.712]         }
[13:20:01.712]     }, args = future.call.arguments)
[13:20:01.712] }
[13:20:01.712] Lazy evaluation: FALSE
[13:20:01.712] Asynchronous evaluation: FALSE
[13:20:01.712] Local evaluation: TRUE
[13:20:01.712] Environment: R_GlobalEnv
[13:20:01.712] Capture standard output: TRUE
[13:20:01.712] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.712] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:01.712] Packages: <none>
[13:20:01.712] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.712] Resolved: TRUE
[13:20:01.712] Value: 5.48 KiB of class ‘list’
[13:20:01.712] Early signaling: FALSE
[13:20:01.712] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.712] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.714] Chunk #1 of 1 ... DONE
[13:20:01.714] Launching 1 futures (chunks) ... DONE
[13:20:01.714] Resolving 1 futures (chunks) ...
[13:20:01.714] resolve() on list ...
[13:20:01.714]  recursive: 0
[13:20:01.714]  length: 1
[13:20:01.714] 
[13:20:01.714] resolved() for ‘SequentialFuture’ ...
[13:20:01.714] - state: ‘finished’
[13:20:01.714] - run: TRUE
[13:20:01.714] - result: ‘FutureResult’
[13:20:01.715] resolved() for ‘SequentialFuture’ ... done
[13:20:01.715] Future #1
[13:20:01.715] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.715] - nx: 1
[13:20:01.715] - relay: TRUE
[13:20:01.715] - stdout: TRUE
[13:20:01.715] - signal: TRUE
[13:20:01.715] - resignal: FALSE
[13:20:01.715] - force: TRUE
[13:20:01.715] - relayed: [n=1] FALSE
[13:20:01.715] - queued futures: [n=1] FALSE
[13:20:01.716]  - until=1
[13:20:01.716]  - relaying element #1
[13:20:01.716] - relayed: [n=1] TRUE
[13:20:01.716] - queued futures: [n=1] TRUE
[13:20:01.716] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.716]  length: 0 (resolved future 1)
[13:20:01.716] Relaying remaining futures
[13:20:01.716] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.716] - nx: 1
[13:20:01.717] - relay: TRUE
[13:20:01.717] - stdout: TRUE
[13:20:01.717] - signal: TRUE
[13:20:01.717] - resignal: FALSE
[13:20:01.717] - force: TRUE
[13:20:01.717] - relayed: [n=1] TRUE
[13:20:01.717] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.717] - relayed: [n=1] TRUE
[13:20:01.717] - queued futures: [n=1] TRUE
[13:20:01.717] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.717] resolve() on list ... DONE
[13:20:01.718]  - Number of value chunks collected: 1
[13:20:01.718] Resolving 1 futures (chunks) ... DONE
[13:20:01.718] Reducing values from 1 chunks ...
[13:20:01.718]  - Number of values collected after concatenation: 6
[13:20:01.718]  - Number of values expected: 6
[13:20:01.718] Reducing values from 1 chunks ... DONE
[13:20:01.718] future_lapply() ... DONE
[13:20:01.718] future_by_internal() ... DONE
[13:20:01.722] future_by_internal() ...
[13:20:01.722] future_lapply() ...
[13:20:01.723] Number of chunks: 1
[13:20:01.723] getGlobalsAndPackagesXApply() ...
[13:20:01.723]  - future.globals: TRUE
[13:20:01.723] getGlobalsAndPackages() ...
[13:20:01.723] Searching for globals...
[13:20:01.727] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:01.727] Searching for globals ... DONE
[13:20:01.727] Resolving globals: FALSE
[13:20:01.727] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:20:01.728] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:20:01.728] - globals: [1] ‘FUN’
[13:20:01.728] - packages: [1] ‘stats’
[13:20:01.728] getGlobalsAndPackages() ... DONE
[13:20:01.728]  - globals found/used: [n=1] ‘FUN’
[13:20:01.728]  - needed namespaces: [n=1] ‘stats’
[13:20:01.729] Finding globals ... DONE
[13:20:01.729]  - use_args: TRUE
[13:20:01.729]  - Getting '...' globals ...
[13:20:01.729] resolve() on list ...
[13:20:01.729]  recursive: 0
[13:20:01.729]  length: 1
[13:20:01.729]  elements: ‘...’
[13:20:01.729]  length: 0 (resolved future 1)
[13:20:01.730] resolve() on list ... DONE
[13:20:01.730]    - '...' content: [n=1] ‘singular.ok’
[13:20:01.730] List of 1
[13:20:01.730]  $ ...:List of 1
[13:20:01.730]   ..$ singular.ok: logi FALSE
[13:20:01.730]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.730]  - attr(*, "where")=List of 1
[13:20:01.730]   ..$ ...:<environment: 0x55aceee8c950> 
[13:20:01.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.730]  - attr(*, "resolved")= logi TRUE
[13:20:01.730]  - attr(*, "total_size")= num NA
[13:20:01.733]  - Getting '...' globals ... DONE
[13:20:01.733] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.733] List of 2
[13:20:01.733]  $ ...future.FUN:function (x, ...)  
[13:20:01.733]  $ ...          :List of 1
[13:20:01.733]   ..$ singular.ok: logi FALSE
[13:20:01.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.733]  - attr(*, "where")=List of 2
[13:20:01.733]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.733]   ..$ ...          :<environment: 0x55aceee8c950> 
[13:20:01.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.733]  - attr(*, "resolved")= logi FALSE
[13:20:01.733]  - attr(*, "total_size")= num 5384
[13:20:01.736] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:01.736] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.737] Number of futures (= number of chunks): 1
[13:20:01.737] Launching 1 futures (chunks) ...
[13:20:01.737] Chunk #1 of 1 ...
[13:20:01.737]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.737] getGlobalsAndPackages() ...
[13:20:01.737] Searching for globals...
[13:20:01.738] 
[13:20:01.738] Searching for globals ... DONE
[13:20:01.738] - globals: [0] <none>
[13:20:01.738] getGlobalsAndPackages() ... DONE
[13:20:01.738]    + additional globals found: [n=0] 
[13:20:01.738]    + additional namespaces needed: [n=0] 
[13:20:01.738]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.738]  - seeds: <none>
[13:20:01.738]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.738] getGlobalsAndPackages() ...
[13:20:01.739] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.739] Resolving globals: FALSE
[13:20:01.739] Tweak future expression to call with '...' arguments ...
[13:20:01.739] {
[13:20:01.739]     do.call(function(...) {
[13:20:01.739]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.739]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.739]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.739]             on.exit(options(oopts), add = TRUE)
[13:20:01.739]         }
[13:20:01.739]         {
[13:20:01.739]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.739]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.739]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.739]             })
[13:20:01.739]         }
[13:20:01.739]     }, args = future.call.arguments)
[13:20:01.739] }
[13:20:01.739] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.739] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.740] 
[13:20:01.740] getGlobalsAndPackages() ... DONE
[13:20:01.740] run() for ‘Future’ ...
[13:20:01.740] - state: ‘created’
[13:20:01.740] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:01.741] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.741]   - Field: ‘label’
[13:20:01.741]   - Field: ‘local’
[13:20:01.741]   - Field: ‘owner’
[13:20:01.741]   - Field: ‘envir’
[13:20:01.741]   - Field: ‘packages’
[13:20:01.741]   - Field: ‘gc’
[13:20:01.741]   - Field: ‘conditions’
[13:20:01.741]   - Field: ‘expr’
[13:20:01.742]   - Field: ‘uuid’
[13:20:01.742]   - Field: ‘seed’
[13:20:01.742]   - Field: ‘version’
[13:20:01.742]   - Field: ‘result’
[13:20:01.742]   - Field: ‘asynchronous’
[13:20:01.742]   - Field: ‘calls’
[13:20:01.742]   - Field: ‘globals’
[13:20:01.742]   - Field: ‘stdout’
[13:20:01.742]   - Field: ‘earlySignal’
[13:20:01.742]   - Field: ‘lazy’
[13:20:01.742]   - Field: ‘state’
[13:20:01.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.743] - Launch lazy future ...
[13:20:01.743] Packages needed by the future expression (n = 1): ‘stats’
[13:20:01.743] Packages needed by future strategies (n = 0): <none>
[13:20:01.743] {
[13:20:01.743]     {
[13:20:01.743]         {
[13:20:01.743]             ...future.startTime <- base::Sys.time()
[13:20:01.743]             {
[13:20:01.743]                 {
[13:20:01.743]                   {
[13:20:01.743]                     {
[13:20:01.743]                       base::local({
[13:20:01.743]                         has_future <- base::requireNamespace("future", 
[13:20:01.743]                           quietly = TRUE)
[13:20:01.743]                         if (has_future) {
[13:20:01.743]                           ns <- base::getNamespace("future")
[13:20:01.743]                           version <- ns[[".package"]][["version"]]
[13:20:01.743]                           if (is.null(version)) 
[13:20:01.743]                             version <- utils::packageVersion("future")
[13:20:01.743]                         }
[13:20:01.743]                         else {
[13:20:01.743]                           version <- NULL
[13:20:01.743]                         }
[13:20:01.743]                         if (!has_future || version < "1.8.0") {
[13:20:01.743]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.743]                             "", base::R.version$version.string), 
[13:20:01.743]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:01.743]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.743]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.743]                               "release", "version")], collapse = " "), 
[13:20:01.743]                             hostname = base::Sys.info()[["nodename"]])
[13:20:01.743]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.743]                             info)
[13:20:01.743]                           info <- base::paste(info, collapse = "; ")
[13:20:01.743]                           if (!has_future) {
[13:20:01.743]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.743]                               info)
[13:20:01.743]                           }
[13:20:01.743]                           else {
[13:20:01.743]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.743]                               info, version)
[13:20:01.743]                           }
[13:20:01.743]                           base::stop(msg)
[13:20:01.743]                         }
[13:20:01.743]                       })
[13:20:01.743]                     }
[13:20:01.743]                     base::local({
[13:20:01.743]                       for (pkg in "stats") {
[13:20:01.743]                         base::loadNamespace(pkg)
[13:20:01.743]                         base::library(pkg, character.only = TRUE)
[13:20:01.743]                       }
[13:20:01.743]                     })
[13:20:01.743]                   }
[13:20:01.743]                   options(future.plan = NULL)
[13:20:01.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.743]                 }
[13:20:01.743]                 ...future.workdir <- getwd()
[13:20:01.743]             }
[13:20:01.743]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.743]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.743]         }
[13:20:01.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.743]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.743]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.743]             base::names(...future.oldOptions))
[13:20:01.743]     }
[13:20:01.743]     if (FALSE) {
[13:20:01.743]     }
[13:20:01.743]     else {
[13:20:01.743]         if (TRUE) {
[13:20:01.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.743]                 open = "w")
[13:20:01.743]         }
[13:20:01.743]         else {
[13:20:01.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.743]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.743]         }
[13:20:01.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.743]             base::sink(type = "output", split = FALSE)
[13:20:01.743]             base::close(...future.stdout)
[13:20:01.743]         }, add = TRUE)
[13:20:01.743]     }
[13:20:01.743]     ...future.frame <- base::sys.nframe()
[13:20:01.743]     ...future.conditions <- base::list()
[13:20:01.743]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.743]     if (FALSE) {
[13:20:01.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.743]     }
[13:20:01.743]     ...future.result <- base::tryCatch({
[13:20:01.743]         base::withCallingHandlers({
[13:20:01.743]             ...future.value <- base::withVisible(base::local({
[13:20:01.743]                 do.call(function(...) {
[13:20:01.743]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.743]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.743]                     ...future.globals.maxSize)) {
[13:20:01.743]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.743]                     on.exit(options(oopts), add = TRUE)
[13:20:01.743]                   }
[13:20:01.743]                   {
[13:20:01.743]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.743]                       FUN = function(jj) {
[13:20:01.743]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.743]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.743]                       })
[13:20:01.743]                   }
[13:20:01.743]                 }, args = future.call.arguments)
[13:20:01.743]             }))
[13:20:01.743]             future::FutureResult(value = ...future.value$value, 
[13:20:01.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.743]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.743]                     ...future.globalenv.names))
[13:20:01.743]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.743]         }, condition = base::local({
[13:20:01.743]             c <- base::c
[13:20:01.743]             inherits <- base::inherits
[13:20:01.743]             invokeRestart <- base::invokeRestart
[13:20:01.743]             length <- base::length
[13:20:01.743]             list <- base::list
[13:20:01.743]             seq.int <- base::seq.int
[13:20:01.743]             signalCondition <- base::signalCondition
[13:20:01.743]             sys.calls <- base::sys.calls
[13:20:01.743]             `[[` <- base::`[[`
[13:20:01.743]             `+` <- base::`+`
[13:20:01.743]             `<<-` <- base::`<<-`
[13:20:01.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.743]                   3L)]
[13:20:01.743]             }
[13:20:01.743]             function(cond) {
[13:20:01.743]                 is_error <- inherits(cond, "error")
[13:20:01.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.743]                   NULL)
[13:20:01.743]                 if (is_error) {
[13:20:01.743]                   sessionInformation <- function() {
[13:20:01.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.743]                       search = base::search(), system = base::Sys.info())
[13:20:01.743]                   }
[13:20:01.743]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.743]                     cond$call), session = sessionInformation(), 
[13:20:01.743]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.743]                   signalCondition(cond)
[13:20:01.743]                 }
[13:20:01.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.743]                 "immediateCondition"))) {
[13:20:01.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.743]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.743]                   if (TRUE && !signal) {
[13:20:01.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.743]                     {
[13:20:01.743]                       inherits <- base::inherits
[13:20:01.743]                       invokeRestart <- base::invokeRestart
[13:20:01.743]                       is.null <- base::is.null
[13:20:01.743]                       muffled <- FALSE
[13:20:01.743]                       if (inherits(cond, "message")) {
[13:20:01.743]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.743]                         if (muffled) 
[13:20:01.743]                           invokeRestart("muffleMessage")
[13:20:01.743]                       }
[13:20:01.743]                       else if (inherits(cond, "warning")) {
[13:20:01.743]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.743]                         if (muffled) 
[13:20:01.743]                           invokeRestart("muffleWarning")
[13:20:01.743]                       }
[13:20:01.743]                       else if (inherits(cond, "condition")) {
[13:20:01.743]                         if (!is.null(pattern)) {
[13:20:01.743]                           computeRestarts <- base::computeRestarts
[13:20:01.743]                           grepl <- base::grepl
[13:20:01.743]                           restarts <- computeRestarts(cond)
[13:20:01.743]                           for (restart in restarts) {
[13:20:01.743]                             name <- restart$name
[13:20:01.743]                             if (is.null(name)) 
[13:20:01.743]                               next
[13:20:01.743]                             if (!grepl(pattern, name)) 
[13:20:01.743]                               next
[13:20:01.743]                             invokeRestart(restart)
[13:20:01.743]                             muffled <- TRUE
[13:20:01.743]                             break
[13:20:01.743]                           }
[13:20:01.743]                         }
[13:20:01.743]                       }
[13:20:01.743]                       invisible(muffled)
[13:20:01.743]                     }
[13:20:01.743]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.743]                   }
[13:20:01.743]                 }
[13:20:01.743]                 else {
[13:20:01.743]                   if (TRUE) {
[13:20:01.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.743]                     {
[13:20:01.743]                       inherits <- base::inherits
[13:20:01.743]                       invokeRestart <- base::invokeRestart
[13:20:01.743]                       is.null <- base::is.null
[13:20:01.743]                       muffled <- FALSE
[13:20:01.743]                       if (inherits(cond, "message")) {
[13:20:01.743]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.743]                         if (muffled) 
[13:20:01.743]                           invokeRestart("muffleMessage")
[13:20:01.743]                       }
[13:20:01.743]                       else if (inherits(cond, "warning")) {
[13:20:01.743]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.743]                         if (muffled) 
[13:20:01.743]                           invokeRestart("muffleWarning")
[13:20:01.743]                       }
[13:20:01.743]                       else if (inherits(cond, "condition")) {
[13:20:01.743]                         if (!is.null(pattern)) {
[13:20:01.743]                           computeRestarts <- base::computeRestarts
[13:20:01.743]                           grepl <- base::grepl
[13:20:01.743]                           restarts <- computeRestarts(cond)
[13:20:01.743]                           for (restart in restarts) {
[13:20:01.743]                             name <- restart$name
[13:20:01.743]                             if (is.null(name)) 
[13:20:01.743]                               next
[13:20:01.743]                             if (!grepl(pattern, name)) 
[13:20:01.743]                               next
[13:20:01.743]                             invokeRestart(restart)
[13:20:01.743]                             muffled <- TRUE
[13:20:01.743]                             break
[13:20:01.743]                           }
[13:20:01.743]                         }
[13:20:01.743]                       }
[13:20:01.743]                       invisible(muffled)
[13:20:01.743]                     }
[13:20:01.743]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.743]                   }
[13:20:01.743]                 }
[13:20:01.743]             }
[13:20:01.743]         }))
[13:20:01.743]     }, error = function(ex) {
[13:20:01.743]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.743]                 ...future.rng), started = ...future.startTime, 
[13:20:01.743]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.743]             version = "1.8"), class = "FutureResult")
[13:20:01.743]     }, finally = {
[13:20:01.743]         if (!identical(...future.workdir, getwd())) 
[13:20:01.743]             setwd(...future.workdir)
[13:20:01.743]         {
[13:20:01.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.743]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.743]             }
[13:20:01.743]             base::options(...future.oldOptions)
[13:20:01.743]             if (.Platform$OS.type == "windows") {
[13:20:01.743]                 old_names <- names(...future.oldEnvVars)
[13:20:01.743]                 envs <- base::Sys.getenv()
[13:20:01.743]                 names <- names(envs)
[13:20:01.743]                 common <- intersect(names, old_names)
[13:20:01.743]                 added <- setdiff(names, old_names)
[13:20:01.743]                 removed <- setdiff(old_names, names)
[13:20:01.743]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.743]                   envs[common]]
[13:20:01.743]                 NAMES <- toupper(changed)
[13:20:01.743]                 args <- list()
[13:20:01.743]                 for (kk in seq_along(NAMES)) {
[13:20:01.743]                   name <- changed[[kk]]
[13:20:01.743]                   NAME <- NAMES[[kk]]
[13:20:01.743]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.743]                     next
[13:20:01.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.743]                 }
[13:20:01.743]                 NAMES <- toupper(added)
[13:20:01.743]                 for (kk in seq_along(NAMES)) {
[13:20:01.743]                   name <- added[[kk]]
[13:20:01.743]                   NAME <- NAMES[[kk]]
[13:20:01.743]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.743]                     next
[13:20:01.743]                   args[[name]] <- ""
[13:20:01.743]                 }
[13:20:01.743]                 NAMES <- toupper(removed)
[13:20:01.743]                 for (kk in seq_along(NAMES)) {
[13:20:01.743]                   name <- removed[[kk]]
[13:20:01.743]                   NAME <- NAMES[[kk]]
[13:20:01.743]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.743]                     next
[13:20:01.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.743]                 }
[13:20:01.743]                 if (length(args) > 0) 
[13:20:01.743]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.743]             }
[13:20:01.743]             else {
[13:20:01.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.743]             }
[13:20:01.743]             {
[13:20:01.743]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.743]                   0L) {
[13:20:01.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.743]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.743]                   base::options(opts)
[13:20:01.743]                 }
[13:20:01.743]                 {
[13:20:01.743]                   {
[13:20:01.743]                     NULL
[13:20:01.743]                     RNGkind("Mersenne-Twister")
[13:20:01.743]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.743]                       inherits = FALSE)
[13:20:01.743]                   }
[13:20:01.743]                   options(future.plan = NULL)
[13:20:01.743]                   if (is.na(NA_character_)) 
[13:20:01.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.743]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:01.743]                   {
[13:20:01.743]                     future <- SequentialFuture(..., envir = envir)
[13:20:01.743]                     if (!future$lazy) 
[13:20:01.743]                       future <- run(future)
[13:20:01.743]                     invisible(future)
[13:20:01.743]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.743]                 }
[13:20:01.743]             }
[13:20:01.743]         }
[13:20:01.743]     })
[13:20:01.743]     if (TRUE) {
[13:20:01.743]         base::sink(type = "output", split = FALSE)
[13:20:01.743]         if (TRUE) {
[13:20:01.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.743]         }
[13:20:01.743]         else {
[13:20:01.743]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.743]         }
[13:20:01.743]         base::close(...future.stdout)
[13:20:01.743]         ...future.stdout <- NULL
[13:20:01.743]     }
[13:20:01.743]     ...future.result$conditions <- ...future.conditions
[13:20:01.743]     ...future.result$finished <- base::Sys.time()
[13:20:01.743]     ...future.result
[13:20:01.743] }
[13:20:01.745] assign_globals() ...
[13:20:01.745] List of 5
[13:20:01.745]  $ ...future.FUN            :function (x, ...)  
[13:20:01.745]  $ future.call.arguments    :List of 1
[13:20:01.745]   ..$ singular.ok: logi FALSE
[13:20:01.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.745]  $ ...future.elements_ii    :List of 3
[13:20:01.745]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.745]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:01.745]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.745]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:01.745]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.745]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:01.745]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.745]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:01.745]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.745]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:01.745]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.745]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:01.745]  $ ...future.seeds_ii       : NULL
[13:20:01.745]  $ ...future.globals.maxSize: NULL
[13:20:01.745]  - attr(*, "where")=List of 5
[13:20:01.745]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.745]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.745]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.745]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.745]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.745]  - attr(*, "resolved")= logi FALSE
[13:20:01.745]  - attr(*, "total_size")= num 5384
[13:20:01.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.745]  - attr(*, "already-done")= logi TRUE
[13:20:01.757] - reassign environment for ‘...future.FUN’
[13:20:01.757] - copied ‘...future.FUN’ to environment
[13:20:01.757] - copied ‘future.call.arguments’ to environment
[13:20:01.757] - copied ‘...future.elements_ii’ to environment
[13:20:01.757] - copied ‘...future.seeds_ii’ to environment
[13:20:01.757] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.757] assign_globals() ... done
[13:20:01.758] plan(): Setting new future strategy stack:
[13:20:01.758] List of future strategies:
[13:20:01.758] 1. sequential:
[13:20:01.758]    - args: function (..., envir = parent.frame())
[13:20:01.758]    - tweaked: FALSE
[13:20:01.758]    - call: NULL
[13:20:01.758] plan(): nbrOfWorkers() = 1
[13:20:01.761] plan(): Setting new future strategy stack:
[13:20:01.761] List of future strategies:
[13:20:01.761] 1. sequential:
[13:20:01.761]    - args: function (..., envir = parent.frame())
[13:20:01.761]    - tweaked: FALSE
[13:20:01.761]    - call: plan(strategy)
[13:20:01.762] plan(): nbrOfWorkers() = 1
[13:20:01.762] SequentialFuture started (and completed)
[13:20:01.762] - Launch lazy future ... done
[13:20:01.762] run() for ‘SequentialFuture’ ... done
[13:20:01.762] Created future:
[13:20:01.762] SequentialFuture:
[13:20:01.762] Label: ‘future_by-1’
[13:20:01.762] Expression:
[13:20:01.762] {
[13:20:01.762]     do.call(function(...) {
[13:20:01.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.762]             on.exit(options(oopts), add = TRUE)
[13:20:01.762]         }
[13:20:01.762]         {
[13:20:01.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.762]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.762]             })
[13:20:01.762]         }
[13:20:01.762]     }, args = future.call.arguments)
[13:20:01.762] }
[13:20:01.762] Lazy evaluation: FALSE
[13:20:01.762] Asynchronous evaluation: FALSE
[13:20:01.762] Local evaluation: TRUE
[13:20:01.762] Environment: R_GlobalEnv
[13:20:01.762] Capture standard output: TRUE
[13:20:01.762] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.762] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:01.762] Packages: 1 packages (‘stats’)
[13:20:01.762] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.762] Resolved: TRUE
[13:20:01.762] Value: 26.06 KiB of class ‘list’
[13:20:01.762] Early signaling: FALSE
[13:20:01.762] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.762] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.764] Chunk #1 of 1 ... DONE
[13:20:01.764] Launching 1 futures (chunks) ... DONE
[13:20:01.764] Resolving 1 futures (chunks) ...
[13:20:01.764] resolve() on list ...
[13:20:01.764]  recursive: 0
[13:20:01.764]  length: 1
[13:20:01.764] 
[13:20:01.764] resolved() for ‘SequentialFuture’ ...
[13:20:01.765] - state: ‘finished’
[13:20:01.765] - run: TRUE
[13:20:01.765] - result: ‘FutureResult’
[13:20:01.765] resolved() for ‘SequentialFuture’ ... done
[13:20:01.765] Future #1
[13:20:01.765] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.765] - nx: 1
[13:20:01.765] - relay: TRUE
[13:20:01.765] - stdout: TRUE
[13:20:01.765] - signal: TRUE
[13:20:01.766] - resignal: FALSE
[13:20:01.766] - force: TRUE
[13:20:01.766] - relayed: [n=1] FALSE
[13:20:01.766] - queued futures: [n=1] FALSE
[13:20:01.766]  - until=1
[13:20:01.766]  - relaying element #1
[13:20:01.766] - relayed: [n=1] TRUE
[13:20:01.766] - queued futures: [n=1] TRUE
[13:20:01.766] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.766]  length: 0 (resolved future 1)
[13:20:01.767] Relaying remaining futures
[13:20:01.767] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.767] - nx: 1
[13:20:01.767] - relay: TRUE
[13:20:01.767] - stdout: TRUE
[13:20:01.767] - signal: TRUE
[13:20:01.767] - resignal: FALSE
[13:20:01.767] - force: TRUE
[13:20:01.767] - relayed: [n=1] TRUE
[13:20:01.767] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.767] - relayed: [n=1] TRUE
[13:20:01.768] - queued futures: [n=1] TRUE
[13:20:01.768] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.768] resolve() on list ... DONE
[13:20:01.768]  - Number of value chunks collected: 1
[13:20:01.768] Resolving 1 futures (chunks) ... DONE
[13:20:01.768] Reducing values from 1 chunks ...
[13:20:01.768]  - Number of values collected after concatenation: 3
[13:20:01.768]  - Number of values expected: 3
[13:20:01.768] Reducing values from 1 chunks ... DONE
[13:20:01.768] future_lapply() ... DONE
[13:20:01.769] future_by_internal() ... DONE
[13:20:01.775] future_by_internal() ...
[13:20:01.775] future_lapply() ...
[13:20:01.776] Number of chunks: 1
[13:20:01.776] getGlobalsAndPackagesXApply() ...
[13:20:01.776]  - future.globals: TRUE
[13:20:01.777] getGlobalsAndPackages() ...
[13:20:01.777] Searching for globals...
[13:20:01.779] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:01.779] Searching for globals ... DONE
[13:20:01.779] Resolving globals: FALSE
[13:20:01.779] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:20:01.780] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:20:01.780] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:01.780] - packages: [1] ‘stats’
[13:20:01.780] getGlobalsAndPackages() ... DONE
[13:20:01.780]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:01.780]  - needed namespaces: [n=1] ‘stats’
[13:20:01.780] Finding globals ... DONE
[13:20:01.781]  - use_args: TRUE
[13:20:01.781]  - Getting '...' globals ...
[13:20:01.781] resolve() on list ...
[13:20:01.781]  recursive: 0
[13:20:01.781]  length: 1
[13:20:01.781]  elements: ‘...’
[13:20:01.781]  length: 0 (resolved future 1)
[13:20:01.781] resolve() on list ... DONE
[13:20:01.782]    - '...' content: [n=0] 
[13:20:01.782] List of 1
[13:20:01.782]  $ ...: list()
[13:20:01.782]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.782]  - attr(*, "where")=List of 1
[13:20:01.782]   ..$ ...:<environment: 0x55aced4868f0> 
[13:20:01.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.782]  - attr(*, "resolved")= logi TRUE
[13:20:01.782]  - attr(*, "total_size")= num NA
[13:20:01.784]  - Getting '...' globals ... DONE
[13:20:01.784] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:20:01.785] List of 4
[13:20:01.785]  $ ...future.FUN:function (x)  
[13:20:01.785]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:01.785]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:01.785]  $ ...          : list()
[13:20:01.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.785]  - attr(*, "where")=List of 4
[13:20:01.785]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.785]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:20:01.785]   ..$ wool         :<environment: R_EmptyEnv> 
[13:20:01.785]   ..$ ...          :<environment: 0x55aced4868f0> 
[13:20:01.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.785]  - attr(*, "resolved")= logi FALSE
[13:20:01.785]  - attr(*, "total_size")= num 2320
[13:20:01.788] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:01.789] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.789] Number of futures (= number of chunks): 1
[13:20:01.791] Launching 1 futures (chunks) ...
[13:20:01.791] Chunk #1 of 1 ...
[13:20:01.791]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.791] getGlobalsAndPackages() ...
[13:20:01.791] Searching for globals...
[13:20:01.792] 
[13:20:01.792] Searching for globals ... DONE
[13:20:01.792] - globals: [0] <none>
[13:20:01.792] getGlobalsAndPackages() ... DONE
[13:20:01.792]    + additional globals found: [n=0] 
[13:20:01.792]    + additional namespaces needed: [n=0] 
[13:20:01.793]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.793]  - seeds: <none>
[13:20:01.793]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.793] getGlobalsAndPackages() ...
[13:20:01.793] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.793] Resolving globals: FALSE
[13:20:01.793] Tweak future expression to call with '...' arguments ...
[13:20:01.793] {
[13:20:01.793]     do.call(function(...) {
[13:20:01.793]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.793]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.793]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.793]             on.exit(options(oopts), add = TRUE)
[13:20:01.793]         }
[13:20:01.793]         {
[13:20:01.793]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.793]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.793]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.793]             })
[13:20:01.793]         }
[13:20:01.793]     }, args = future.call.arguments)
[13:20:01.793] }
[13:20:01.793] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.794] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.794] 
[13:20:01.794] getGlobalsAndPackages() ... DONE
[13:20:01.794] run() for ‘Future’ ...
[13:20:01.794] - state: ‘created’
[13:20:01.795] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:01.795] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.795]   - Field: ‘label’
[13:20:01.795]   - Field: ‘local’
[13:20:01.795]   - Field: ‘owner’
[13:20:01.795]   - Field: ‘envir’
[13:20:01.796]   - Field: ‘packages’
[13:20:01.796]   - Field: ‘gc’
[13:20:01.796]   - Field: ‘conditions’
[13:20:01.796]   - Field: ‘expr’
[13:20:01.796]   - Field: ‘uuid’
[13:20:01.796]   - Field: ‘seed’
[13:20:01.796]   - Field: ‘version’
[13:20:01.796]   - Field: ‘result’
[13:20:01.796]   - Field: ‘asynchronous’
[13:20:01.796]   - Field: ‘calls’
[13:20:01.796]   - Field: ‘globals’
[13:20:01.797]   - Field: ‘stdout’
[13:20:01.797]   - Field: ‘earlySignal’
[13:20:01.797]   - Field: ‘lazy’
[13:20:01.797]   - Field: ‘state’
[13:20:01.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.797] - Launch lazy future ...
[13:20:01.797] Packages needed by the future expression (n = 1): ‘stats’
[13:20:01.797] Packages needed by future strategies (n = 0): <none>
[13:20:01.798] {
[13:20:01.798]     {
[13:20:01.798]         {
[13:20:01.798]             ...future.startTime <- base::Sys.time()
[13:20:01.798]             {
[13:20:01.798]                 {
[13:20:01.798]                   {
[13:20:01.798]                     {
[13:20:01.798]                       base::local({
[13:20:01.798]                         has_future <- base::requireNamespace("future", 
[13:20:01.798]                           quietly = TRUE)
[13:20:01.798]                         if (has_future) {
[13:20:01.798]                           ns <- base::getNamespace("future")
[13:20:01.798]                           version <- ns[[".package"]][["version"]]
[13:20:01.798]                           if (is.null(version)) 
[13:20:01.798]                             version <- utils::packageVersion("future")
[13:20:01.798]                         }
[13:20:01.798]                         else {
[13:20:01.798]                           version <- NULL
[13:20:01.798]                         }
[13:20:01.798]                         if (!has_future || version < "1.8.0") {
[13:20:01.798]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.798]                             "", base::R.version$version.string), 
[13:20:01.798]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:01.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.798]                               "release", "version")], collapse = " "), 
[13:20:01.798]                             hostname = base::Sys.info()[["nodename"]])
[13:20:01.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.798]                             info)
[13:20:01.798]                           info <- base::paste(info, collapse = "; ")
[13:20:01.798]                           if (!has_future) {
[13:20:01.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.798]                               info)
[13:20:01.798]                           }
[13:20:01.798]                           else {
[13:20:01.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.798]                               info, version)
[13:20:01.798]                           }
[13:20:01.798]                           base::stop(msg)
[13:20:01.798]                         }
[13:20:01.798]                       })
[13:20:01.798]                     }
[13:20:01.798]                     base::local({
[13:20:01.798]                       for (pkg in "stats") {
[13:20:01.798]                         base::loadNamespace(pkg)
[13:20:01.798]                         base::library(pkg, character.only = TRUE)
[13:20:01.798]                       }
[13:20:01.798]                     })
[13:20:01.798]                   }
[13:20:01.798]                   options(future.plan = NULL)
[13:20:01.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.798]                 }
[13:20:01.798]                 ...future.workdir <- getwd()
[13:20:01.798]             }
[13:20:01.798]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.798]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.798]         }
[13:20:01.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.798]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.798]             base::names(...future.oldOptions))
[13:20:01.798]     }
[13:20:01.798]     if (FALSE) {
[13:20:01.798]     }
[13:20:01.798]     else {
[13:20:01.798]         if (TRUE) {
[13:20:01.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.798]                 open = "w")
[13:20:01.798]         }
[13:20:01.798]         else {
[13:20:01.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.798]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.798]         }
[13:20:01.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.798]             base::sink(type = "output", split = FALSE)
[13:20:01.798]             base::close(...future.stdout)
[13:20:01.798]         }, add = TRUE)
[13:20:01.798]     }
[13:20:01.798]     ...future.frame <- base::sys.nframe()
[13:20:01.798]     ...future.conditions <- base::list()
[13:20:01.798]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.798]     if (FALSE) {
[13:20:01.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.798]     }
[13:20:01.798]     ...future.result <- base::tryCatch({
[13:20:01.798]         base::withCallingHandlers({
[13:20:01.798]             ...future.value <- base::withVisible(base::local({
[13:20:01.798]                 do.call(function(...) {
[13:20:01.798]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.798]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.798]                     ...future.globals.maxSize)) {
[13:20:01.798]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.798]                     on.exit(options(oopts), add = TRUE)
[13:20:01.798]                   }
[13:20:01.798]                   {
[13:20:01.798]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.798]                       FUN = function(jj) {
[13:20:01.798]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.798]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.798]                       })
[13:20:01.798]                   }
[13:20:01.798]                 }, args = future.call.arguments)
[13:20:01.798]             }))
[13:20:01.798]             future::FutureResult(value = ...future.value$value, 
[13:20:01.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.798]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.798]                     ...future.globalenv.names))
[13:20:01.798]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.798]         }, condition = base::local({
[13:20:01.798]             c <- base::c
[13:20:01.798]             inherits <- base::inherits
[13:20:01.798]             invokeRestart <- base::invokeRestart
[13:20:01.798]             length <- base::length
[13:20:01.798]             list <- base::list
[13:20:01.798]             seq.int <- base::seq.int
[13:20:01.798]             signalCondition <- base::signalCondition
[13:20:01.798]             sys.calls <- base::sys.calls
[13:20:01.798]             `[[` <- base::`[[`
[13:20:01.798]             `+` <- base::`+`
[13:20:01.798]             `<<-` <- base::`<<-`
[13:20:01.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.798]                   3L)]
[13:20:01.798]             }
[13:20:01.798]             function(cond) {
[13:20:01.798]                 is_error <- inherits(cond, "error")
[13:20:01.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.798]                   NULL)
[13:20:01.798]                 if (is_error) {
[13:20:01.798]                   sessionInformation <- function() {
[13:20:01.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.798]                       search = base::search(), system = base::Sys.info())
[13:20:01.798]                   }
[13:20:01.798]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.798]                     cond$call), session = sessionInformation(), 
[13:20:01.798]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.798]                   signalCondition(cond)
[13:20:01.798]                 }
[13:20:01.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.798]                 "immediateCondition"))) {
[13:20:01.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.798]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.798]                   if (TRUE && !signal) {
[13:20:01.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.798]                     {
[13:20:01.798]                       inherits <- base::inherits
[13:20:01.798]                       invokeRestart <- base::invokeRestart
[13:20:01.798]                       is.null <- base::is.null
[13:20:01.798]                       muffled <- FALSE
[13:20:01.798]                       if (inherits(cond, "message")) {
[13:20:01.798]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.798]                         if (muffled) 
[13:20:01.798]                           invokeRestart("muffleMessage")
[13:20:01.798]                       }
[13:20:01.798]                       else if (inherits(cond, "warning")) {
[13:20:01.798]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.798]                         if (muffled) 
[13:20:01.798]                           invokeRestart("muffleWarning")
[13:20:01.798]                       }
[13:20:01.798]                       else if (inherits(cond, "condition")) {
[13:20:01.798]                         if (!is.null(pattern)) {
[13:20:01.798]                           computeRestarts <- base::computeRestarts
[13:20:01.798]                           grepl <- base::grepl
[13:20:01.798]                           restarts <- computeRestarts(cond)
[13:20:01.798]                           for (restart in restarts) {
[13:20:01.798]                             name <- restart$name
[13:20:01.798]                             if (is.null(name)) 
[13:20:01.798]                               next
[13:20:01.798]                             if (!grepl(pattern, name)) 
[13:20:01.798]                               next
[13:20:01.798]                             invokeRestart(restart)
[13:20:01.798]                             muffled <- TRUE
[13:20:01.798]                             break
[13:20:01.798]                           }
[13:20:01.798]                         }
[13:20:01.798]                       }
[13:20:01.798]                       invisible(muffled)
[13:20:01.798]                     }
[13:20:01.798]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.798]                   }
[13:20:01.798]                 }
[13:20:01.798]                 else {
[13:20:01.798]                   if (TRUE) {
[13:20:01.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.798]                     {
[13:20:01.798]                       inherits <- base::inherits
[13:20:01.798]                       invokeRestart <- base::invokeRestart
[13:20:01.798]                       is.null <- base::is.null
[13:20:01.798]                       muffled <- FALSE
[13:20:01.798]                       if (inherits(cond, "message")) {
[13:20:01.798]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.798]                         if (muffled) 
[13:20:01.798]                           invokeRestart("muffleMessage")
[13:20:01.798]                       }
[13:20:01.798]                       else if (inherits(cond, "warning")) {
[13:20:01.798]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.798]                         if (muffled) 
[13:20:01.798]                           invokeRestart("muffleWarning")
[13:20:01.798]                       }
[13:20:01.798]                       else if (inherits(cond, "condition")) {
[13:20:01.798]                         if (!is.null(pattern)) {
[13:20:01.798]                           computeRestarts <- base::computeRestarts
[13:20:01.798]                           grepl <- base::grepl
[13:20:01.798]                           restarts <- computeRestarts(cond)
[13:20:01.798]                           for (restart in restarts) {
[13:20:01.798]                             name <- restart$name
[13:20:01.798]                             if (is.null(name)) 
[13:20:01.798]                               next
[13:20:01.798]                             if (!grepl(pattern, name)) 
[13:20:01.798]                               next
[13:20:01.798]                             invokeRestart(restart)
[13:20:01.798]                             muffled <- TRUE
[13:20:01.798]                             break
[13:20:01.798]                           }
[13:20:01.798]                         }
[13:20:01.798]                       }
[13:20:01.798]                       invisible(muffled)
[13:20:01.798]                     }
[13:20:01.798]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.798]                   }
[13:20:01.798]                 }
[13:20:01.798]             }
[13:20:01.798]         }))
[13:20:01.798]     }, error = function(ex) {
[13:20:01.798]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.798]                 ...future.rng), started = ...future.startTime, 
[13:20:01.798]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.798]             version = "1.8"), class = "FutureResult")
[13:20:01.798]     }, finally = {
[13:20:01.798]         if (!identical(...future.workdir, getwd())) 
[13:20:01.798]             setwd(...future.workdir)
[13:20:01.798]         {
[13:20:01.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.798]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.798]             }
[13:20:01.798]             base::options(...future.oldOptions)
[13:20:01.798]             if (.Platform$OS.type == "windows") {
[13:20:01.798]                 old_names <- names(...future.oldEnvVars)
[13:20:01.798]                 envs <- base::Sys.getenv()
[13:20:01.798]                 names <- names(envs)
[13:20:01.798]                 common <- intersect(names, old_names)
[13:20:01.798]                 added <- setdiff(names, old_names)
[13:20:01.798]                 removed <- setdiff(old_names, names)
[13:20:01.798]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.798]                   envs[common]]
[13:20:01.798]                 NAMES <- toupper(changed)
[13:20:01.798]                 args <- list()
[13:20:01.798]                 for (kk in seq_along(NAMES)) {
[13:20:01.798]                   name <- changed[[kk]]
[13:20:01.798]                   NAME <- NAMES[[kk]]
[13:20:01.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.798]                     next
[13:20:01.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.798]                 }
[13:20:01.798]                 NAMES <- toupper(added)
[13:20:01.798]                 for (kk in seq_along(NAMES)) {
[13:20:01.798]                   name <- added[[kk]]
[13:20:01.798]                   NAME <- NAMES[[kk]]
[13:20:01.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.798]                     next
[13:20:01.798]                   args[[name]] <- ""
[13:20:01.798]                 }
[13:20:01.798]                 NAMES <- toupper(removed)
[13:20:01.798]                 for (kk in seq_along(NAMES)) {
[13:20:01.798]                   name <- removed[[kk]]
[13:20:01.798]                   NAME <- NAMES[[kk]]
[13:20:01.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.798]                     next
[13:20:01.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.798]                 }
[13:20:01.798]                 if (length(args) > 0) 
[13:20:01.798]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.798]             }
[13:20:01.798]             else {
[13:20:01.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.798]             }
[13:20:01.798]             {
[13:20:01.798]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.798]                   0L) {
[13:20:01.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.798]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.798]                   base::options(opts)
[13:20:01.798]                 }
[13:20:01.798]                 {
[13:20:01.798]                   {
[13:20:01.798]                     NULL
[13:20:01.798]                     RNGkind("Mersenne-Twister")
[13:20:01.798]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.798]                       inherits = FALSE)
[13:20:01.798]                   }
[13:20:01.798]                   options(future.plan = NULL)
[13:20:01.798]                   if (is.na(NA_character_)) 
[13:20:01.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.798]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:01.798]                   {
[13:20:01.798]                     future <- SequentialFuture(..., envir = envir)
[13:20:01.798]                     if (!future$lazy) 
[13:20:01.798]                       future <- run(future)
[13:20:01.798]                     invisible(future)
[13:20:01.798]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.798]                 }
[13:20:01.798]             }
[13:20:01.798]         }
[13:20:01.798]     })
[13:20:01.798]     if (TRUE) {
[13:20:01.798]         base::sink(type = "output", split = FALSE)
[13:20:01.798]         if (TRUE) {
[13:20:01.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.798]         }
[13:20:01.798]         else {
[13:20:01.798]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.798]         }
[13:20:01.798]         base::close(...future.stdout)
[13:20:01.798]         ...future.stdout <- NULL
[13:20:01.798]     }
[13:20:01.798]     ...future.result$conditions <- ...future.conditions
[13:20:01.798]     ...future.result$finished <- base::Sys.time()
[13:20:01.798]     ...future.result
[13:20:01.798] }
[13:20:01.800] assign_globals() ...
[13:20:01.800] List of 7
[13:20:01.800]  $ ...future.FUN            :function (x)  
[13:20:01.800]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:01.800]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:01.800]  $ future.call.arguments    : list()
[13:20:01.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.800]  $ ...future.elements_ii    :List of 3
[13:20:01.800]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.800]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:01.800]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.800]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:01.800]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.800]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:01.800]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.800]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:01.800]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.800]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:01.800]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.800]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:01.800]  $ ...future.seeds_ii       : NULL
[13:20:01.800]  $ ...future.globals.maxSize: NULL
[13:20:01.800]  - attr(*, "where")=List of 7
[13:20:01.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.800]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:20:01.800]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:20:01.800]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.800]  - attr(*, "resolved")= logi FALSE
[13:20:01.800]  - attr(*, "total_size")= num 2320
[13:20:01.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.800]  - attr(*, "already-done")= logi TRUE
[13:20:01.810] - reassign environment for ‘...future.FUN’
[13:20:01.810] - copied ‘...future.FUN’ to environment
[13:20:01.810] - copied ‘breaks’ to environment
[13:20:01.810] - copied ‘wool’ to environment
[13:20:01.810] - copied ‘future.call.arguments’ to environment
[13:20:01.810] - copied ‘...future.elements_ii’ to environment
[13:20:01.810] - copied ‘...future.seeds_ii’ to environment
[13:20:01.810] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.811] assign_globals() ... done
[13:20:01.811] plan(): Setting new future strategy stack:
[13:20:01.811] List of future strategies:
[13:20:01.811] 1. sequential:
[13:20:01.811]    - args: function (..., envir = parent.frame())
[13:20:01.811]    - tweaked: FALSE
[13:20:01.811]    - call: NULL
[13:20:01.811] plan(): nbrOfWorkers() = 1
[13:20:01.816] plan(): Setting new future strategy stack:
[13:20:01.816] List of future strategies:
[13:20:01.816] 1. sequential:
[13:20:01.816]    - args: function (..., envir = parent.frame())
[13:20:01.816]    - tweaked: FALSE
[13:20:01.816]    - call: plan(strategy)
[13:20:01.817] plan(): nbrOfWorkers() = 1
[13:20:01.817] SequentialFuture started (and completed)
[13:20:01.817] - Launch lazy future ... done
[13:20:01.817] run() for ‘SequentialFuture’ ... done
[13:20:01.817] Created future:
[13:20:01.817] SequentialFuture:
[13:20:01.817] Label: ‘future_by-1’
[13:20:01.817] Expression:
[13:20:01.817] {
[13:20:01.817]     do.call(function(...) {
[13:20:01.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.817]             on.exit(options(oopts), add = TRUE)
[13:20:01.817]         }
[13:20:01.817]         {
[13:20:01.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.817]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.817]             })
[13:20:01.817]         }
[13:20:01.817]     }, args = future.call.arguments)
[13:20:01.817] }
[13:20:01.817] Lazy evaluation: FALSE
[13:20:01.817] Asynchronous evaluation: FALSE
[13:20:01.817] Local evaluation: TRUE
[13:20:01.817] Environment: 0x55acec523a10
[13:20:01.817] Capture standard output: TRUE
[13:20:01.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.817] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:20:01.817] Packages: 1 packages (‘stats’)
[13:20:01.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.817] Resolved: TRUE
[13:20:01.817] Value: 25.57 KiB of class ‘list’
[13:20:01.817] Early signaling: FALSE
[13:20:01.817] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.817] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.819] Chunk #1 of 1 ... DONE
[13:20:01.819] Launching 1 futures (chunks) ... DONE
[13:20:01.819] Resolving 1 futures (chunks) ...
[13:20:01.819] resolve() on list ...
[13:20:01.819]  recursive: 0
[13:20:01.819]  length: 1
[13:20:01.819] 
[13:20:01.820] resolved() for ‘SequentialFuture’ ...
[13:20:01.820] - state: ‘finished’
[13:20:01.820] - run: TRUE
[13:20:01.820] - result: ‘FutureResult’
[13:20:01.820] resolved() for ‘SequentialFuture’ ... done
[13:20:01.820] Future #1
[13:20:01.820] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.820] - nx: 1
[13:20:01.820] - relay: TRUE
[13:20:01.820] - stdout: TRUE
[13:20:01.821] - signal: TRUE
[13:20:01.821] - resignal: FALSE
[13:20:01.821] - force: TRUE
[13:20:01.821] - relayed: [n=1] FALSE
[13:20:01.821] - queued futures: [n=1] FALSE
[13:20:01.821]  - until=1
[13:20:01.821]  - relaying element #1
[13:20:01.821] - relayed: [n=1] TRUE
[13:20:01.821] - queued futures: [n=1] TRUE
[13:20:01.821] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.822]  length: 0 (resolved future 1)
[13:20:01.822] Relaying remaining futures
[13:20:01.822] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.822] - nx: 1
[13:20:01.822] - relay: TRUE
[13:20:01.822] - stdout: TRUE
[13:20:01.822] - signal: TRUE
[13:20:01.822] - resignal: FALSE
[13:20:01.822] - force: TRUE
[13:20:01.822] - relayed: [n=1] TRUE
[13:20:01.822] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.823] - relayed: [n=1] TRUE
[13:20:01.823] - queued futures: [n=1] TRUE
[13:20:01.823] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.823] resolve() on list ... DONE
[13:20:01.823]  - Number of value chunks collected: 1
[13:20:01.823] Resolving 1 futures (chunks) ... DONE
[13:20:01.823] Reducing values from 1 chunks ...
[13:20:01.823]  - Number of values collected after concatenation: 3
[13:20:01.823]  - Number of values expected: 3
[13:20:01.823] Reducing values from 1 chunks ... DONE
[13:20:01.824] future_lapply() ... DONE
[13:20:01.824] future_by_internal() ... DONE
[13:20:01.824] future_by_internal() ...
[13:20:01.824] future_lapply() ...
[13:20:01.825] Number of chunks: 1
[13:20:01.825] getGlobalsAndPackagesXApply() ...
[13:20:01.825]  - future.globals: TRUE
[13:20:01.825] getGlobalsAndPackages() ...
[13:20:01.825] Searching for globals...
[13:20:01.826] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:01.827] Searching for globals ... DONE
[13:20:01.827] Resolving globals: FALSE
[13:20:01.827] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:01.827] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:01.827] - globals: [1] ‘FUN’
[13:20:01.828] 
[13:20:01.828] getGlobalsAndPackages() ... DONE
[13:20:01.828]  - globals found/used: [n=1] ‘FUN’
[13:20:01.828]  - needed namespaces: [n=0] 
[13:20:01.828] Finding globals ... DONE
[13:20:01.828]  - use_args: TRUE
[13:20:01.828]  - Getting '...' globals ...
[13:20:01.828] resolve() on list ...
[13:20:01.828]  recursive: 0
[13:20:01.829]  length: 1
[13:20:01.829]  elements: ‘...’
[13:20:01.829]  length: 0 (resolved future 1)
[13:20:01.829] resolve() on list ... DONE
[13:20:01.829]    - '...' content: [n=0] 
[13:20:01.829] List of 1
[13:20:01.829]  $ ...: list()
[13:20:01.829]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.829]  - attr(*, "where")=List of 1
[13:20:01.829]   ..$ ...:<environment: 0x55acee87ee78> 
[13:20:01.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.829]  - attr(*, "resolved")= logi TRUE
[13:20:01.829]  - attr(*, "total_size")= num NA
[13:20:01.832]  - Getting '...' globals ... DONE
[13:20:01.832] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.832] List of 2
[13:20:01.832]  $ ...future.FUN:function (object, ...)  
[13:20:01.832]  $ ...          : list()
[13:20:01.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.832]  - attr(*, "where")=List of 2
[13:20:01.832]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.832]   ..$ ...          :<environment: 0x55acee87ee78> 
[13:20:01.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.832]  - attr(*, "resolved")= logi FALSE
[13:20:01.832]  - attr(*, "total_size")= num 1240
[13:20:01.836] Packages to be attached in all futures: [n=0] 
[13:20:01.836] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.837] Number of futures (= number of chunks): 1
[13:20:01.837] Launching 1 futures (chunks) ...
[13:20:01.837] Chunk #1 of 1 ...
[13:20:01.837]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.837] getGlobalsAndPackages() ...
[13:20:01.837] Searching for globals...
[13:20:01.838] 
[13:20:01.838] Searching for globals ... DONE
[13:20:01.838] - globals: [0] <none>
[13:20:01.838] getGlobalsAndPackages() ... DONE
[13:20:01.838]    + additional globals found: [n=0] 
[13:20:01.838]    + additional namespaces needed: [n=0] 
[13:20:01.838]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.838]  - seeds: <none>
[13:20:01.838]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.838] getGlobalsAndPackages() ...
[13:20:01.839] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.839] Resolving globals: FALSE
[13:20:01.839] Tweak future expression to call with '...' arguments ...
[13:20:01.839] {
[13:20:01.839]     do.call(function(...) {
[13:20:01.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.839]             on.exit(options(oopts), add = TRUE)
[13:20:01.839]         }
[13:20:01.839]         {
[13:20:01.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.839]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.839]             })
[13:20:01.839]         }
[13:20:01.839]     }, args = future.call.arguments)
[13:20:01.839] }
[13:20:01.839] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.839] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.840] 
[13:20:01.840] getGlobalsAndPackages() ... DONE
[13:20:01.840] run() for ‘Future’ ...
[13:20:01.840] - state: ‘created’
[13:20:01.840] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:01.841] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.841]   - Field: ‘label’
[13:20:01.841]   - Field: ‘local’
[13:20:01.841]   - Field: ‘owner’
[13:20:01.841]   - Field: ‘envir’
[13:20:01.841]   - Field: ‘packages’
[13:20:01.841]   - Field: ‘gc’
[13:20:01.841]   - Field: ‘conditions’
[13:20:01.841]   - Field: ‘expr’
[13:20:01.842]   - Field: ‘uuid’
[13:20:01.842]   - Field: ‘seed’
[13:20:01.842]   - Field: ‘version’
[13:20:01.842]   - Field: ‘result’
[13:20:01.842]   - Field: ‘asynchronous’
[13:20:01.842]   - Field: ‘calls’
[13:20:01.842]   - Field: ‘globals’
[13:20:01.842]   - Field: ‘stdout’
[13:20:01.842]   - Field: ‘earlySignal’
[13:20:01.842]   - Field: ‘lazy’
[13:20:01.843]   - Field: ‘state’
[13:20:01.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.843] - Launch lazy future ...
[13:20:01.843] Packages needed by the future expression (n = 0): <none>
[13:20:01.843] Packages needed by future strategies (n = 0): <none>
[13:20:01.843] {
[13:20:01.843]     {
[13:20:01.843]         {
[13:20:01.843]             ...future.startTime <- base::Sys.time()
[13:20:01.843]             {
[13:20:01.843]                 {
[13:20:01.843]                   {
[13:20:01.843]                     base::local({
[13:20:01.843]                       has_future <- base::requireNamespace("future", 
[13:20:01.843]                         quietly = TRUE)
[13:20:01.843]                       if (has_future) {
[13:20:01.843]                         ns <- base::getNamespace("future")
[13:20:01.843]                         version <- ns[[".package"]][["version"]]
[13:20:01.843]                         if (is.null(version)) 
[13:20:01.843]                           version <- utils::packageVersion("future")
[13:20:01.843]                       }
[13:20:01.843]                       else {
[13:20:01.843]                         version <- NULL
[13:20:01.843]                       }
[13:20:01.843]                       if (!has_future || version < "1.8.0") {
[13:20:01.843]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.843]                           "", base::R.version$version.string), 
[13:20:01.843]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:01.843]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.843]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.843]                             "release", "version")], collapse = " "), 
[13:20:01.843]                           hostname = base::Sys.info()[["nodename"]])
[13:20:01.843]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.843]                           info)
[13:20:01.843]                         info <- base::paste(info, collapse = "; ")
[13:20:01.843]                         if (!has_future) {
[13:20:01.843]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.843]                             info)
[13:20:01.843]                         }
[13:20:01.843]                         else {
[13:20:01.843]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.843]                             info, version)
[13:20:01.843]                         }
[13:20:01.843]                         base::stop(msg)
[13:20:01.843]                       }
[13:20:01.843]                     })
[13:20:01.843]                   }
[13:20:01.843]                   options(future.plan = NULL)
[13:20:01.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.843]                 }
[13:20:01.843]                 ...future.workdir <- getwd()
[13:20:01.843]             }
[13:20:01.843]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.843]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.843]         }
[13:20:01.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.843]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.843]             base::names(...future.oldOptions))
[13:20:01.843]     }
[13:20:01.843]     if (FALSE) {
[13:20:01.843]     }
[13:20:01.843]     else {
[13:20:01.843]         if (TRUE) {
[13:20:01.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.843]                 open = "w")
[13:20:01.843]         }
[13:20:01.843]         else {
[13:20:01.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.843]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.843]         }
[13:20:01.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.843]             base::sink(type = "output", split = FALSE)
[13:20:01.843]             base::close(...future.stdout)
[13:20:01.843]         }, add = TRUE)
[13:20:01.843]     }
[13:20:01.843]     ...future.frame <- base::sys.nframe()
[13:20:01.843]     ...future.conditions <- base::list()
[13:20:01.843]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.843]     if (FALSE) {
[13:20:01.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.843]     }
[13:20:01.843]     ...future.result <- base::tryCatch({
[13:20:01.843]         base::withCallingHandlers({
[13:20:01.843]             ...future.value <- base::withVisible(base::local({
[13:20:01.843]                 do.call(function(...) {
[13:20:01.843]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.843]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.843]                     ...future.globals.maxSize)) {
[13:20:01.843]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.843]                     on.exit(options(oopts), add = TRUE)
[13:20:01.843]                   }
[13:20:01.843]                   {
[13:20:01.843]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.843]                       FUN = function(jj) {
[13:20:01.843]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.843]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.843]                       })
[13:20:01.843]                   }
[13:20:01.843]                 }, args = future.call.arguments)
[13:20:01.843]             }))
[13:20:01.843]             future::FutureResult(value = ...future.value$value, 
[13:20:01.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.843]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.843]                     ...future.globalenv.names))
[13:20:01.843]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.843]         }, condition = base::local({
[13:20:01.843]             c <- base::c
[13:20:01.843]             inherits <- base::inherits
[13:20:01.843]             invokeRestart <- base::invokeRestart
[13:20:01.843]             length <- base::length
[13:20:01.843]             list <- base::list
[13:20:01.843]             seq.int <- base::seq.int
[13:20:01.843]             signalCondition <- base::signalCondition
[13:20:01.843]             sys.calls <- base::sys.calls
[13:20:01.843]             `[[` <- base::`[[`
[13:20:01.843]             `+` <- base::`+`
[13:20:01.843]             `<<-` <- base::`<<-`
[13:20:01.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.843]                   3L)]
[13:20:01.843]             }
[13:20:01.843]             function(cond) {
[13:20:01.843]                 is_error <- inherits(cond, "error")
[13:20:01.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.843]                   NULL)
[13:20:01.843]                 if (is_error) {
[13:20:01.843]                   sessionInformation <- function() {
[13:20:01.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.843]                       search = base::search(), system = base::Sys.info())
[13:20:01.843]                   }
[13:20:01.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.843]                     cond$call), session = sessionInformation(), 
[13:20:01.843]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.843]                   signalCondition(cond)
[13:20:01.843]                 }
[13:20:01.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.843]                 "immediateCondition"))) {
[13:20:01.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.843]                   if (TRUE && !signal) {
[13:20:01.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.843]                     {
[13:20:01.843]                       inherits <- base::inherits
[13:20:01.843]                       invokeRestart <- base::invokeRestart
[13:20:01.843]                       is.null <- base::is.null
[13:20:01.843]                       muffled <- FALSE
[13:20:01.843]                       if (inherits(cond, "message")) {
[13:20:01.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.843]                         if (muffled) 
[13:20:01.843]                           invokeRestart("muffleMessage")
[13:20:01.843]                       }
[13:20:01.843]                       else if (inherits(cond, "warning")) {
[13:20:01.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.843]                         if (muffled) 
[13:20:01.843]                           invokeRestart("muffleWarning")
[13:20:01.843]                       }
[13:20:01.843]                       else if (inherits(cond, "condition")) {
[13:20:01.843]                         if (!is.null(pattern)) {
[13:20:01.843]                           computeRestarts <- base::computeRestarts
[13:20:01.843]                           grepl <- base::grepl
[13:20:01.843]                           restarts <- computeRestarts(cond)
[13:20:01.843]                           for (restart in restarts) {
[13:20:01.843]                             name <- restart$name
[13:20:01.843]                             if (is.null(name)) 
[13:20:01.843]                               next
[13:20:01.843]                             if (!grepl(pattern, name)) 
[13:20:01.843]                               next
[13:20:01.843]                             invokeRestart(restart)
[13:20:01.843]                             muffled <- TRUE
[13:20:01.843]                             break
[13:20:01.843]                           }
[13:20:01.843]                         }
[13:20:01.843]                       }
[13:20:01.843]                       invisible(muffled)
[13:20:01.843]                     }
[13:20:01.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.843]                   }
[13:20:01.843]                 }
[13:20:01.843]                 else {
[13:20:01.843]                   if (TRUE) {
[13:20:01.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.843]                     {
[13:20:01.843]                       inherits <- base::inherits
[13:20:01.843]                       invokeRestart <- base::invokeRestart
[13:20:01.843]                       is.null <- base::is.null
[13:20:01.843]                       muffled <- FALSE
[13:20:01.843]                       if (inherits(cond, "message")) {
[13:20:01.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.843]                         if (muffled) 
[13:20:01.843]                           invokeRestart("muffleMessage")
[13:20:01.843]                       }
[13:20:01.843]                       else if (inherits(cond, "warning")) {
[13:20:01.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.843]                         if (muffled) 
[13:20:01.843]                           invokeRestart("muffleWarning")
[13:20:01.843]                       }
[13:20:01.843]                       else if (inherits(cond, "condition")) {
[13:20:01.843]                         if (!is.null(pattern)) {
[13:20:01.843]                           computeRestarts <- base::computeRestarts
[13:20:01.843]                           grepl <- base::grepl
[13:20:01.843]                           restarts <- computeRestarts(cond)
[13:20:01.843]                           for (restart in restarts) {
[13:20:01.843]                             name <- restart$name
[13:20:01.843]                             if (is.null(name)) 
[13:20:01.843]                               next
[13:20:01.843]                             if (!grepl(pattern, name)) 
[13:20:01.843]                               next
[13:20:01.843]                             invokeRestart(restart)
[13:20:01.843]                             muffled <- TRUE
[13:20:01.843]                             break
[13:20:01.843]                           }
[13:20:01.843]                         }
[13:20:01.843]                       }
[13:20:01.843]                       invisible(muffled)
[13:20:01.843]                     }
[13:20:01.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.843]                   }
[13:20:01.843]                 }
[13:20:01.843]             }
[13:20:01.843]         }))
[13:20:01.843]     }, error = function(ex) {
[13:20:01.843]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.843]                 ...future.rng), started = ...future.startTime, 
[13:20:01.843]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.843]             version = "1.8"), class = "FutureResult")
[13:20:01.843]     }, finally = {
[13:20:01.843]         if (!identical(...future.workdir, getwd())) 
[13:20:01.843]             setwd(...future.workdir)
[13:20:01.843]         {
[13:20:01.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.843]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.843]             }
[13:20:01.843]             base::options(...future.oldOptions)
[13:20:01.843]             if (.Platform$OS.type == "windows") {
[13:20:01.843]                 old_names <- names(...future.oldEnvVars)
[13:20:01.843]                 envs <- base::Sys.getenv()
[13:20:01.843]                 names <- names(envs)
[13:20:01.843]                 common <- intersect(names, old_names)
[13:20:01.843]                 added <- setdiff(names, old_names)
[13:20:01.843]                 removed <- setdiff(old_names, names)
[13:20:01.843]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.843]                   envs[common]]
[13:20:01.843]                 NAMES <- toupper(changed)
[13:20:01.843]                 args <- list()
[13:20:01.843]                 for (kk in seq_along(NAMES)) {
[13:20:01.843]                   name <- changed[[kk]]
[13:20:01.843]                   NAME <- NAMES[[kk]]
[13:20:01.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.843]                     next
[13:20:01.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.843]                 }
[13:20:01.843]                 NAMES <- toupper(added)
[13:20:01.843]                 for (kk in seq_along(NAMES)) {
[13:20:01.843]                   name <- added[[kk]]
[13:20:01.843]                   NAME <- NAMES[[kk]]
[13:20:01.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.843]                     next
[13:20:01.843]                   args[[name]] <- ""
[13:20:01.843]                 }
[13:20:01.843]                 NAMES <- toupper(removed)
[13:20:01.843]                 for (kk in seq_along(NAMES)) {
[13:20:01.843]                   name <- removed[[kk]]
[13:20:01.843]                   NAME <- NAMES[[kk]]
[13:20:01.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.843]                     next
[13:20:01.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.843]                 }
[13:20:01.843]                 if (length(args) > 0) 
[13:20:01.843]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.843]             }
[13:20:01.843]             else {
[13:20:01.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.843]             }
[13:20:01.843]             {
[13:20:01.843]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.843]                   0L) {
[13:20:01.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.843]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.843]                   base::options(opts)
[13:20:01.843]                 }
[13:20:01.843]                 {
[13:20:01.843]                   {
[13:20:01.843]                     NULL
[13:20:01.843]                     RNGkind("Mersenne-Twister")
[13:20:01.843]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.843]                       inherits = FALSE)
[13:20:01.843]                   }
[13:20:01.843]                   options(future.plan = NULL)
[13:20:01.843]                   if (is.na(NA_character_)) 
[13:20:01.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.843]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:01.843]                   {
[13:20:01.843]                     future <- SequentialFuture(..., envir = envir)
[13:20:01.843]                     if (!future$lazy) 
[13:20:01.843]                       future <- run(future)
[13:20:01.843]                     invisible(future)
[13:20:01.843]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.843]                 }
[13:20:01.843]             }
[13:20:01.843]         }
[13:20:01.843]     })
[13:20:01.843]     if (TRUE) {
[13:20:01.843]         base::sink(type = "output", split = FALSE)
[13:20:01.843]         if (TRUE) {
[13:20:01.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.843]         }
[13:20:01.843]         else {
[13:20:01.843]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.843]         }
[13:20:01.843]         base::close(...future.stdout)
[13:20:01.843]         ...future.stdout <- NULL
[13:20:01.843]     }
[13:20:01.843]     ...future.result$conditions <- ...future.conditions
[13:20:01.843]     ...future.result$finished <- base::Sys.time()
[13:20:01.843]     ...future.result
[13:20:01.843] }
[13:20:01.845] assign_globals() ...
[13:20:01.845] List of 5
[13:20:01.845]  $ ...future.FUN            :function (object, ...)  
[13:20:01.845]  $ future.call.arguments    : list()
[13:20:01.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.845]  $ ...future.elements_ii    :List of 3
[13:20:01.845]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.845]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:01.845]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.845]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:01.845]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.845]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:01.845]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.845]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:01.845]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.845]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:01.845]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.845]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:01.845]  $ ...future.seeds_ii       : NULL
[13:20:01.845]  $ ...future.globals.maxSize: NULL
[13:20:01.845]  - attr(*, "where")=List of 5
[13:20:01.845]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.845]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.845]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.845]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.845]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.845]  - attr(*, "resolved")= logi FALSE
[13:20:01.845]  - attr(*, "total_size")= num 1240
[13:20:01.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.845]  - attr(*, "already-done")= logi TRUE
[13:20:01.854] - copied ‘...future.FUN’ to environment
[13:20:01.854] - copied ‘future.call.arguments’ to environment
[13:20:01.854] - copied ‘...future.elements_ii’ to environment
[13:20:01.854] - copied ‘...future.seeds_ii’ to environment
[13:20:01.854] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.854] assign_globals() ... done
[13:20:01.854] plan(): Setting new future strategy stack:
[13:20:01.854] List of future strategies:
[13:20:01.854] 1. sequential:
[13:20:01.854]    - args: function (..., envir = parent.frame())
[13:20:01.854]    - tweaked: FALSE
[13:20:01.854]    - call: NULL
[13:20:01.857] plan(): nbrOfWorkers() = 1
[13:20:01.859] plan(): Setting new future strategy stack:
[13:20:01.859] List of future strategies:
[13:20:01.859] 1. sequential:
[13:20:01.859]    - args: function (..., envir = parent.frame())
[13:20:01.859]    - tweaked: FALSE
[13:20:01.859]    - call: plan(strategy)
[13:20:01.860] plan(): nbrOfWorkers() = 1
[13:20:01.860] SequentialFuture started (and completed)
[13:20:01.860] - Launch lazy future ... done
[13:20:01.860] run() for ‘SequentialFuture’ ... done
[13:20:01.860] Created future:
[13:20:01.860] SequentialFuture:
[13:20:01.860] Label: ‘future_by-1’
[13:20:01.860] Expression:
[13:20:01.860] {
[13:20:01.860]     do.call(function(...) {
[13:20:01.860]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.860]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.860]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.860]             on.exit(options(oopts), add = TRUE)
[13:20:01.860]         }
[13:20:01.860]         {
[13:20:01.860]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.860]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.860]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.860]             })
[13:20:01.860]         }
[13:20:01.860]     }, args = future.call.arguments)
[13:20:01.860] }
[13:20:01.860] Lazy evaluation: FALSE
[13:20:01.860] Asynchronous evaluation: FALSE
[13:20:01.860] Local evaluation: TRUE
[13:20:01.860] Environment: 0x55acee836668
[13:20:01.860] Capture standard output: TRUE
[13:20:01.860] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.860] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:01.860] Packages: <none>
[13:20:01.860] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.860] Resolved: TRUE
[13:20:01.860] Value: 5.37 KiB of class ‘list’
[13:20:01.860] Early signaling: FALSE
[13:20:01.860] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.860] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.861] Chunk #1 of 1 ... DONE
[13:20:01.862] Launching 1 futures (chunks) ... DONE
[13:20:01.862] Resolving 1 futures (chunks) ...
[13:20:01.862] resolve() on list ...
[13:20:01.862]  recursive: 0
[13:20:01.862]  length: 1
[13:20:01.862] 
[13:20:01.862] resolved() for ‘SequentialFuture’ ...
[13:20:01.862] - state: ‘finished’
[13:20:01.862] - run: TRUE
[13:20:01.862] - result: ‘FutureResult’
[13:20:01.862] resolved() for ‘SequentialFuture’ ... done
[13:20:01.863] Future #1
[13:20:01.863] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.863] - nx: 1
[13:20:01.863] - relay: TRUE
[13:20:01.863] - stdout: TRUE
[13:20:01.863] - signal: TRUE
[13:20:01.863] - resignal: FALSE
[13:20:01.863] - force: TRUE
[13:20:01.863] - relayed: [n=1] FALSE
[13:20:01.863] - queued futures: [n=1] FALSE
[13:20:01.864]  - until=1
[13:20:01.864]  - relaying element #1
[13:20:01.864] - relayed: [n=1] TRUE
[13:20:01.864] - queued futures: [n=1] TRUE
[13:20:01.864] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.864]  length: 0 (resolved future 1)
[13:20:01.864] Relaying remaining futures
[13:20:01.864] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.864] - nx: 1
[13:20:01.864] - relay: TRUE
[13:20:01.865] - stdout: TRUE
[13:20:01.865] - signal: TRUE
[13:20:01.865] - resignal: FALSE
[13:20:01.865] - force: TRUE
[13:20:01.865] - relayed: [n=1] TRUE
[13:20:01.865] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.865] - relayed: [n=1] TRUE
[13:20:01.865] - queued futures: [n=1] TRUE
[13:20:01.865] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.865] resolve() on list ... DONE
[13:20:01.866]  - Number of value chunks collected: 1
[13:20:01.866] Resolving 1 futures (chunks) ... DONE
[13:20:01.866] Reducing values from 1 chunks ...
[13:20:01.866]  - Number of values collected after concatenation: 3
[13:20:01.866]  - Number of values expected: 3
[13:20:01.866] Reducing values from 1 chunks ... DONE
[13:20:01.866] future_lapply() ... DONE
[13:20:01.866] future_by_internal() ... DONE
[13:20:01.868] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:20:01.869] future_lapply() ...
[13:20:01.869] Number of chunks: 1
[13:20:01.869] getGlobalsAndPackagesXApply() ...
[13:20:01.869]  - future.globals: TRUE
[13:20:01.870] getGlobalsAndPackages() ...
[13:20:01.870] Searching for globals...
[13:20:01.871] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:01.871] Searching for globals ... DONE
[13:20:01.871] Resolving globals: FALSE
[13:20:01.871] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:01.872] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:01.872] - globals: [1] ‘FUN’
[13:20:01.872] 
[13:20:01.872] getGlobalsAndPackages() ... DONE
[13:20:01.872]  - globals found/used: [n=1] ‘FUN’
[13:20:01.872]  - needed namespaces: [n=0] 
[13:20:01.872] Finding globals ... DONE
[13:20:01.872]  - use_args: TRUE
[13:20:01.872]  - Getting '...' globals ...
[13:20:01.873] resolve() on list ...
[13:20:01.873]  recursive: 0
[13:20:01.873]  length: 1
[13:20:01.873]  elements: ‘...’
[13:20:01.873]  length: 0 (resolved future 1)
[13:20:01.873] resolve() on list ... DONE
[13:20:01.873]    - '...' content: [n=0] 
[13:20:01.873] List of 1
[13:20:01.873]  $ ...: list()
[13:20:01.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.873]  - attr(*, "where")=List of 1
[13:20:01.873]   ..$ ...:<environment: 0x55acee9ecd80> 
[13:20:01.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.873]  - attr(*, "resolved")= logi TRUE
[13:20:01.873]  - attr(*, "total_size")= num NA
[13:20:01.878]  - Getting '...' globals ... DONE
[13:20:01.878] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.878] List of 2
[13:20:01.878]  $ ...future.FUN:function (object, ...)  
[13:20:01.878]  $ ...          : list()
[13:20:01.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.878]  - attr(*, "where")=List of 2
[13:20:01.878]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.878]   ..$ ...          :<environment: 0x55acee9ecd80> 
[13:20:01.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.878]  - attr(*, "resolved")= logi FALSE
[13:20:01.878]  - attr(*, "total_size")= num 1240
[13:20:01.881] Packages to be attached in all futures: [n=0] 
[13:20:01.881] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.881] Number of futures (= number of chunks): 1
[13:20:01.881] Launching 1 futures (chunks) ...
[13:20:01.881] Chunk #1 of 1 ...
[13:20:01.882]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.882] getGlobalsAndPackages() ...
[13:20:01.882] Searching for globals...
[13:20:01.882] 
[13:20:01.882] Searching for globals ... DONE
[13:20:01.882] - globals: [0] <none>
[13:20:01.882] getGlobalsAndPackages() ... DONE
[13:20:01.883]    + additional globals found: [n=0] 
[13:20:01.883]    + additional namespaces needed: [n=0] 
[13:20:01.883]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.883]  - seeds: <none>
[13:20:01.883]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.883] getGlobalsAndPackages() ...
[13:20:01.883] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.883] Resolving globals: FALSE
[13:20:01.883] Tweak future expression to call with '...' arguments ...
[13:20:01.883] {
[13:20:01.883]     do.call(function(...) {
[13:20:01.883]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.883]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.883]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.883]             on.exit(options(oopts), add = TRUE)
[13:20:01.883]         }
[13:20:01.883]         {
[13:20:01.883]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.883]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.883]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.883]             })
[13:20:01.883]         }
[13:20:01.883]     }, args = future.call.arguments)
[13:20:01.883] }
[13:20:01.884] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.884] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.884] 
[13:20:01.884] getGlobalsAndPackages() ... DONE
[13:20:01.885] run() for ‘Future’ ...
[13:20:01.885] - state: ‘created’
[13:20:01.885] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:01.885] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.885]   - Field: ‘label’
[13:20:01.885]   - Field: ‘local’
[13:20:01.886]   - Field: ‘owner’
[13:20:01.886]   - Field: ‘envir’
[13:20:01.886]   - Field: ‘packages’
[13:20:01.886]   - Field: ‘gc’
[13:20:01.886]   - Field: ‘conditions’
[13:20:01.886]   - Field: ‘expr’
[13:20:01.886]   - Field: ‘uuid’
[13:20:01.886]   - Field: ‘seed’
[13:20:01.886]   - Field: ‘version’
[13:20:01.886]   - Field: ‘result’
[13:20:01.886]   - Field: ‘asynchronous’
[13:20:01.887]   - Field: ‘calls’
[13:20:01.887]   - Field: ‘globals’
[13:20:01.887]   - Field: ‘stdout’
[13:20:01.887]   - Field: ‘earlySignal’
[13:20:01.887]   - Field: ‘lazy’
[13:20:01.887]   - Field: ‘state’
[13:20:01.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.887] - Launch lazy future ...
[13:20:01.887] Packages needed by the future expression (n = 0): <none>
[13:20:01.888] Packages needed by future strategies (n = 0): <none>
[13:20:01.888] {
[13:20:01.888]     {
[13:20:01.888]         {
[13:20:01.888]             ...future.startTime <- base::Sys.time()
[13:20:01.888]             {
[13:20:01.888]                 {
[13:20:01.888]                   {
[13:20:01.888]                     base::local({
[13:20:01.888]                       has_future <- base::requireNamespace("future", 
[13:20:01.888]                         quietly = TRUE)
[13:20:01.888]                       if (has_future) {
[13:20:01.888]                         ns <- base::getNamespace("future")
[13:20:01.888]                         version <- ns[[".package"]][["version"]]
[13:20:01.888]                         if (is.null(version)) 
[13:20:01.888]                           version <- utils::packageVersion("future")
[13:20:01.888]                       }
[13:20:01.888]                       else {
[13:20:01.888]                         version <- NULL
[13:20:01.888]                       }
[13:20:01.888]                       if (!has_future || version < "1.8.0") {
[13:20:01.888]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.888]                           "", base::R.version$version.string), 
[13:20:01.888]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:01.888]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.888]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.888]                             "release", "version")], collapse = " "), 
[13:20:01.888]                           hostname = base::Sys.info()[["nodename"]])
[13:20:01.888]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.888]                           info)
[13:20:01.888]                         info <- base::paste(info, collapse = "; ")
[13:20:01.888]                         if (!has_future) {
[13:20:01.888]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.888]                             info)
[13:20:01.888]                         }
[13:20:01.888]                         else {
[13:20:01.888]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.888]                             info, version)
[13:20:01.888]                         }
[13:20:01.888]                         base::stop(msg)
[13:20:01.888]                       }
[13:20:01.888]                     })
[13:20:01.888]                   }
[13:20:01.888]                   options(future.plan = NULL)
[13:20:01.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.888]                 }
[13:20:01.888]                 ...future.workdir <- getwd()
[13:20:01.888]             }
[13:20:01.888]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.888]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.888]         }
[13:20:01.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.888]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.888]             base::names(...future.oldOptions))
[13:20:01.888]     }
[13:20:01.888]     if (FALSE) {
[13:20:01.888]     }
[13:20:01.888]     else {
[13:20:01.888]         if (TRUE) {
[13:20:01.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.888]                 open = "w")
[13:20:01.888]         }
[13:20:01.888]         else {
[13:20:01.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.888]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.888]         }
[13:20:01.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.888]             base::sink(type = "output", split = FALSE)
[13:20:01.888]             base::close(...future.stdout)
[13:20:01.888]         }, add = TRUE)
[13:20:01.888]     }
[13:20:01.888]     ...future.frame <- base::sys.nframe()
[13:20:01.888]     ...future.conditions <- base::list()
[13:20:01.888]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.888]     if (FALSE) {
[13:20:01.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.888]     }
[13:20:01.888]     ...future.result <- base::tryCatch({
[13:20:01.888]         base::withCallingHandlers({
[13:20:01.888]             ...future.value <- base::withVisible(base::local({
[13:20:01.888]                 do.call(function(...) {
[13:20:01.888]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.888]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.888]                     ...future.globals.maxSize)) {
[13:20:01.888]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.888]                     on.exit(options(oopts), add = TRUE)
[13:20:01.888]                   }
[13:20:01.888]                   {
[13:20:01.888]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.888]                       FUN = function(jj) {
[13:20:01.888]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.888]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.888]                       })
[13:20:01.888]                   }
[13:20:01.888]                 }, args = future.call.arguments)
[13:20:01.888]             }))
[13:20:01.888]             future::FutureResult(value = ...future.value$value, 
[13:20:01.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.888]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.888]                     ...future.globalenv.names))
[13:20:01.888]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.888]         }, condition = base::local({
[13:20:01.888]             c <- base::c
[13:20:01.888]             inherits <- base::inherits
[13:20:01.888]             invokeRestart <- base::invokeRestart
[13:20:01.888]             length <- base::length
[13:20:01.888]             list <- base::list
[13:20:01.888]             seq.int <- base::seq.int
[13:20:01.888]             signalCondition <- base::signalCondition
[13:20:01.888]             sys.calls <- base::sys.calls
[13:20:01.888]             `[[` <- base::`[[`
[13:20:01.888]             `+` <- base::`+`
[13:20:01.888]             `<<-` <- base::`<<-`
[13:20:01.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.888]                   3L)]
[13:20:01.888]             }
[13:20:01.888]             function(cond) {
[13:20:01.888]                 is_error <- inherits(cond, "error")
[13:20:01.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.888]                   NULL)
[13:20:01.888]                 if (is_error) {
[13:20:01.888]                   sessionInformation <- function() {
[13:20:01.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.888]                       search = base::search(), system = base::Sys.info())
[13:20:01.888]                   }
[13:20:01.888]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.888]                     cond$call), session = sessionInformation(), 
[13:20:01.888]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.888]                   signalCondition(cond)
[13:20:01.888]                 }
[13:20:01.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.888]                 "immediateCondition"))) {
[13:20:01.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.888]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.888]                   if (TRUE && !signal) {
[13:20:01.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.888]                     {
[13:20:01.888]                       inherits <- base::inherits
[13:20:01.888]                       invokeRestart <- base::invokeRestart
[13:20:01.888]                       is.null <- base::is.null
[13:20:01.888]                       muffled <- FALSE
[13:20:01.888]                       if (inherits(cond, "message")) {
[13:20:01.888]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.888]                         if (muffled) 
[13:20:01.888]                           invokeRestart("muffleMessage")
[13:20:01.888]                       }
[13:20:01.888]                       else if (inherits(cond, "warning")) {
[13:20:01.888]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.888]                         if (muffled) 
[13:20:01.888]                           invokeRestart("muffleWarning")
[13:20:01.888]                       }
[13:20:01.888]                       else if (inherits(cond, "condition")) {
[13:20:01.888]                         if (!is.null(pattern)) {
[13:20:01.888]                           computeRestarts <- base::computeRestarts
[13:20:01.888]                           grepl <- base::grepl
[13:20:01.888]                           restarts <- computeRestarts(cond)
[13:20:01.888]                           for (restart in restarts) {
[13:20:01.888]                             name <- restart$name
[13:20:01.888]                             if (is.null(name)) 
[13:20:01.888]                               next
[13:20:01.888]                             if (!grepl(pattern, name)) 
[13:20:01.888]                               next
[13:20:01.888]                             invokeRestart(restart)
[13:20:01.888]                             muffled <- TRUE
[13:20:01.888]                             break
[13:20:01.888]                           }
[13:20:01.888]                         }
[13:20:01.888]                       }
[13:20:01.888]                       invisible(muffled)
[13:20:01.888]                     }
[13:20:01.888]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.888]                   }
[13:20:01.888]                 }
[13:20:01.888]                 else {
[13:20:01.888]                   if (TRUE) {
[13:20:01.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.888]                     {
[13:20:01.888]                       inherits <- base::inherits
[13:20:01.888]                       invokeRestart <- base::invokeRestart
[13:20:01.888]                       is.null <- base::is.null
[13:20:01.888]                       muffled <- FALSE
[13:20:01.888]                       if (inherits(cond, "message")) {
[13:20:01.888]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.888]                         if (muffled) 
[13:20:01.888]                           invokeRestart("muffleMessage")
[13:20:01.888]                       }
[13:20:01.888]                       else if (inherits(cond, "warning")) {
[13:20:01.888]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.888]                         if (muffled) 
[13:20:01.888]                           invokeRestart("muffleWarning")
[13:20:01.888]                       }
[13:20:01.888]                       else if (inherits(cond, "condition")) {
[13:20:01.888]                         if (!is.null(pattern)) {
[13:20:01.888]                           computeRestarts <- base::computeRestarts
[13:20:01.888]                           grepl <- base::grepl
[13:20:01.888]                           restarts <- computeRestarts(cond)
[13:20:01.888]                           for (restart in restarts) {
[13:20:01.888]                             name <- restart$name
[13:20:01.888]                             if (is.null(name)) 
[13:20:01.888]                               next
[13:20:01.888]                             if (!grepl(pattern, name)) 
[13:20:01.888]                               next
[13:20:01.888]                             invokeRestart(restart)
[13:20:01.888]                             muffled <- TRUE
[13:20:01.888]                             break
[13:20:01.888]                           }
[13:20:01.888]                         }
[13:20:01.888]                       }
[13:20:01.888]                       invisible(muffled)
[13:20:01.888]                     }
[13:20:01.888]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.888]                   }
[13:20:01.888]                 }
[13:20:01.888]             }
[13:20:01.888]         }))
[13:20:01.888]     }, error = function(ex) {
[13:20:01.888]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.888]                 ...future.rng), started = ...future.startTime, 
[13:20:01.888]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.888]             version = "1.8"), class = "FutureResult")
[13:20:01.888]     }, finally = {
[13:20:01.888]         if (!identical(...future.workdir, getwd())) 
[13:20:01.888]             setwd(...future.workdir)
[13:20:01.888]         {
[13:20:01.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.888]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.888]             }
[13:20:01.888]             base::options(...future.oldOptions)
[13:20:01.888]             if (.Platform$OS.type == "windows") {
[13:20:01.888]                 old_names <- names(...future.oldEnvVars)
[13:20:01.888]                 envs <- base::Sys.getenv()
[13:20:01.888]                 names <- names(envs)
[13:20:01.888]                 common <- intersect(names, old_names)
[13:20:01.888]                 added <- setdiff(names, old_names)
[13:20:01.888]                 removed <- setdiff(old_names, names)
[13:20:01.888]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.888]                   envs[common]]
[13:20:01.888]                 NAMES <- toupper(changed)
[13:20:01.888]                 args <- list()
[13:20:01.888]                 for (kk in seq_along(NAMES)) {
[13:20:01.888]                   name <- changed[[kk]]
[13:20:01.888]                   NAME <- NAMES[[kk]]
[13:20:01.888]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.888]                     next
[13:20:01.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.888]                 }
[13:20:01.888]                 NAMES <- toupper(added)
[13:20:01.888]                 for (kk in seq_along(NAMES)) {
[13:20:01.888]                   name <- added[[kk]]
[13:20:01.888]                   NAME <- NAMES[[kk]]
[13:20:01.888]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.888]                     next
[13:20:01.888]                   args[[name]] <- ""
[13:20:01.888]                 }
[13:20:01.888]                 NAMES <- toupper(removed)
[13:20:01.888]                 for (kk in seq_along(NAMES)) {
[13:20:01.888]                   name <- removed[[kk]]
[13:20:01.888]                   NAME <- NAMES[[kk]]
[13:20:01.888]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.888]                     next
[13:20:01.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.888]                 }
[13:20:01.888]                 if (length(args) > 0) 
[13:20:01.888]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.888]             }
[13:20:01.888]             else {
[13:20:01.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.888]             }
[13:20:01.888]             {
[13:20:01.888]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.888]                   0L) {
[13:20:01.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.888]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.888]                   base::options(opts)
[13:20:01.888]                 }
[13:20:01.888]                 {
[13:20:01.888]                   {
[13:20:01.888]                     NULL
[13:20:01.888]                     RNGkind("Mersenne-Twister")
[13:20:01.888]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.888]                       inherits = FALSE)
[13:20:01.888]                   }
[13:20:01.888]                   options(future.plan = NULL)
[13:20:01.888]                   if (is.na(NA_character_)) 
[13:20:01.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.888]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:01.888]                   {
[13:20:01.888]                     future <- SequentialFuture(..., envir = envir)
[13:20:01.888]                     if (!future$lazy) 
[13:20:01.888]                       future <- run(future)
[13:20:01.888]                     invisible(future)
[13:20:01.888]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.888]                 }
[13:20:01.888]             }
[13:20:01.888]         }
[13:20:01.888]     })
[13:20:01.888]     if (TRUE) {
[13:20:01.888]         base::sink(type = "output", split = FALSE)
[13:20:01.888]         if (TRUE) {
[13:20:01.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.888]         }
[13:20:01.888]         else {
[13:20:01.888]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.888]         }
[13:20:01.888]         base::close(...future.stdout)
[13:20:01.888]         ...future.stdout <- NULL
[13:20:01.888]     }
[13:20:01.888]     ...future.result$conditions <- ...future.conditions
[13:20:01.888]     ...future.result$finished <- base::Sys.time()
[13:20:01.888]     ...future.result
[13:20:01.888] }
[13:20:01.890] assign_globals() ...
[13:20:01.890] List of 5
[13:20:01.890]  $ ...future.FUN            :function (object, ...)  
[13:20:01.890]  $ future.call.arguments    : list()
[13:20:01.890]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.890]  $ ...future.elements_ii    :List of 3
[13:20:01.890]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.890]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:01.890]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.890]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:01.890]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.890]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:01.890]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.890]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:01.890]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:01.890]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:01.890]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.890]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:01.890]  $ ...future.seeds_ii       : NULL
[13:20:01.890]  $ ...future.globals.maxSize: NULL
[13:20:01.890]  - attr(*, "where")=List of 5
[13:20:01.890]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.890]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.890]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.890]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.890]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.890]  - attr(*, "resolved")= logi FALSE
[13:20:01.890]  - attr(*, "total_size")= num 1240
[13:20:01.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.890]  - attr(*, "already-done")= logi TRUE
[13:20:01.900] - copied ‘...future.FUN’ to environment
[13:20:01.901] - copied ‘future.call.arguments’ to environment
[13:20:01.901] - copied ‘...future.elements_ii’ to environment
[13:20:01.901] - copied ‘...future.seeds_ii’ to environment
[13:20:01.901] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.901] assign_globals() ... done
[13:20:01.901] plan(): Setting new future strategy stack:
[13:20:01.901] List of future strategies:
[13:20:01.901] 1. sequential:
[13:20:01.901]    - args: function (..., envir = parent.frame())
[13:20:01.901]    - tweaked: FALSE
[13:20:01.901]    - call: NULL
[13:20:01.902] plan(): nbrOfWorkers() = 1
[13:20:01.904] plan(): Setting new future strategy stack:
[13:20:01.904] List of future strategies:
[13:20:01.904] 1. sequential:
[13:20:01.904]    - args: function (..., envir = parent.frame())
[13:20:01.904]    - tweaked: FALSE
[13:20:01.904]    - call: plan(strategy)
[13:20:01.904] plan(): nbrOfWorkers() = 1
[13:20:01.905] SequentialFuture started (and completed)
[13:20:01.905] - Launch lazy future ... done
[13:20:01.905] run() for ‘SequentialFuture’ ... done
[13:20:01.905] Created future:
[13:20:01.905] SequentialFuture:
[13:20:01.905] Label: ‘future_by-1’
[13:20:01.905] Expression:
[13:20:01.905] {
[13:20:01.905]     do.call(function(...) {
[13:20:01.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.905]             on.exit(options(oopts), add = TRUE)
[13:20:01.905]         }
[13:20:01.905]         {
[13:20:01.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.905]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.905]             })
[13:20:01.905]         }
[13:20:01.905]     }, args = future.call.arguments)
[13:20:01.905] }
[13:20:01.905] Lazy evaluation: FALSE
[13:20:01.905] Asynchronous evaluation: FALSE
[13:20:01.905] Local evaluation: TRUE
[13:20:01.905] Environment: 0x55acee838c98
[13:20:01.905] Capture standard output: TRUE
[13:20:01.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.905] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:01.905] Packages: <none>
[13:20:01.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.905] Resolved: TRUE
[13:20:01.905] Value: 5.37 KiB of class ‘list’
[13:20:01.905] Early signaling: FALSE
[13:20:01.905] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.905] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.906] Chunk #1 of 1 ... DONE
[13:20:01.906] Launching 1 futures (chunks) ... DONE
[13:20:01.907] Resolving 1 futures (chunks) ...
[13:20:01.907] resolve() on list ...
[13:20:01.907]  recursive: 0
[13:20:01.907]  length: 1
[13:20:01.907] 
[13:20:01.907] resolved() for ‘SequentialFuture’ ...
[13:20:01.907] - state: ‘finished’
[13:20:01.907] - run: TRUE
[13:20:01.907] - result: ‘FutureResult’
[13:20:01.907] resolved() for ‘SequentialFuture’ ... done
[13:20:01.907] Future #1
[13:20:01.908] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.908] - nx: 1
[13:20:01.908] - relay: TRUE
[13:20:01.908] - stdout: TRUE
[13:20:01.908] - signal: TRUE
[13:20:01.908] - resignal: FALSE
[13:20:01.908] - force: TRUE
[13:20:01.908] - relayed: [n=1] FALSE
[13:20:01.908] - queued futures: [n=1] FALSE
[13:20:01.908]  - until=1
[13:20:01.908]  - relaying element #1
[13:20:01.909] - relayed: [n=1] TRUE
[13:20:01.909] - queued futures: [n=1] TRUE
[13:20:01.909] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.909]  length: 0 (resolved future 1)
[13:20:01.909] Relaying remaining futures
[13:20:01.909] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.909] - nx: 1
[13:20:01.909] - relay: TRUE
[13:20:01.909] - stdout: TRUE
[13:20:01.909] - signal: TRUE
[13:20:01.910] - resignal: FALSE
[13:20:01.910] - force: TRUE
[13:20:01.910] - relayed: [n=1] TRUE
[13:20:01.910] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.910] - relayed: [n=1] TRUE
[13:20:01.910] - queued futures: [n=1] TRUE
[13:20:01.910] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.910] resolve() on list ... DONE
[13:20:01.910]  - Number of value chunks collected: 1
[13:20:01.910] Resolving 1 futures (chunks) ... DONE
[13:20:01.910] Reducing values from 1 chunks ...
[13:20:01.911]  - Number of values collected after concatenation: 3
[13:20:01.911]  - Number of values expected: 3
[13:20:01.911] Reducing values from 1 chunks ... DONE
[13:20:01.911] future_lapply() ... DONE
[13:20:01.911] future_by_internal() ... DONE
[13:20:01.912] future_by_internal() ...
- plan('multicore') ...
[13:20:01.912] plan(): Setting new future strategy stack:
[13:20:01.912] List of future strategies:
[13:20:01.912] 1. multicore:
[13:20:01.912]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:01.912]    - tweaked: FALSE
[13:20:01.912]    - call: plan(strategy)
[13:20:01.916] plan(): nbrOfWorkers() = 1
[13:20:01.917] future_by_internal() ...
[13:20:01.917] future_lapply() ...
[13:20:01.921] Number of chunks: 1
[13:20:01.921] getGlobalsAndPackagesXApply() ...
[13:20:01.921]  - future.globals: TRUE
[13:20:01.921] getGlobalsAndPackages() ...
[13:20:01.921] Searching for globals...
[13:20:01.922] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:01.922] Searching for globals ... DONE
[13:20:01.922] Resolving globals: FALSE
[13:20:01.923] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:01.923] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:01.923] - globals: [1] ‘FUN’
[13:20:01.923] 
[13:20:01.923] getGlobalsAndPackages() ... DONE
[13:20:01.923]  - globals found/used: [n=1] ‘FUN’
[13:20:01.926]  - needed namespaces: [n=0] 
[13:20:01.926] Finding globals ... DONE
[13:20:01.926]  - use_args: TRUE
[13:20:01.926]  - Getting '...' globals ...
[13:20:01.926] resolve() on list ...
[13:20:01.926]  recursive: 0
[13:20:01.926]  length: 1
[13:20:01.927]  elements: ‘...’
[13:20:01.927]  length: 0 (resolved future 1)
[13:20:01.927] resolve() on list ... DONE
[13:20:01.927]    - '...' content: [n=0] 
[13:20:01.927] List of 1
[13:20:01.927]  $ ...: list()
[13:20:01.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.927]  - attr(*, "where")=List of 1
[13:20:01.927]   ..$ ...:<environment: 0x55aceeb72178> 
[13:20:01.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.927]  - attr(*, "resolved")= logi TRUE
[13:20:01.927]  - attr(*, "total_size")= num NA
[13:20:01.930]  - Getting '...' globals ... DONE
[13:20:01.930] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.930] List of 2
[13:20:01.930]  $ ...future.FUN:function (object, ...)  
[13:20:01.930]  $ ...          : list()
[13:20:01.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.930]  - attr(*, "where")=List of 2
[13:20:01.930]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.930]   ..$ ...          :<environment: 0x55aceeb72178> 
[13:20:01.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.930]  - attr(*, "resolved")= logi FALSE
[13:20:01.930]  - attr(*, "total_size")= num 1240
[13:20:01.933] Packages to be attached in all futures: [n=0] 
[13:20:01.933] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.933] Number of futures (= number of chunks): 1
[13:20:01.933] Launching 1 futures (chunks) ...
[13:20:01.933] Chunk #1 of 1 ...
[13:20:01.934]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.934] getGlobalsAndPackages() ...
[13:20:01.934] Searching for globals...
[13:20:01.934] 
[13:20:01.934] Searching for globals ... DONE
[13:20:01.934] - globals: [0] <none>
[13:20:01.935] getGlobalsAndPackages() ... DONE
[13:20:01.935]    + additional globals found: [n=0] 
[13:20:01.935]    + additional namespaces needed: [n=0] 
[13:20:01.935]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.935]  - seeds: <none>
[13:20:01.935]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.935] getGlobalsAndPackages() ...
[13:20:01.935] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.935] Resolving globals: FALSE
[13:20:01.935] Tweak future expression to call with '...' arguments ...
[13:20:01.936] {
[13:20:01.936]     do.call(function(...) {
[13:20:01.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.936]             on.exit(options(oopts), add = TRUE)
[13:20:01.936]         }
[13:20:01.936]         {
[13:20:01.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.936]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.936]             })
[13:20:01.936]         }
[13:20:01.936]     }, args = future.call.arguments)
[13:20:01.936] }
[13:20:01.936] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.936] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.936] 
[13:20:01.936] getGlobalsAndPackages() ... DONE
[13:20:01.937] run() for ‘Future’ ...
[13:20:01.937] - state: ‘created’
[13:20:01.937] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:01.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.941]   - Field: ‘label’
[13:20:01.941]   - Field: ‘local’
[13:20:01.941]   - Field: ‘owner’
[13:20:01.941]   - Field: ‘envir’
[13:20:01.941]   - Field: ‘packages’
[13:20:01.942]   - Field: ‘gc’
[13:20:01.942]   - Field: ‘conditions’
[13:20:01.942]   - Field: ‘expr’
[13:20:01.942]   - Field: ‘uuid’
[13:20:01.942]   - Field: ‘seed’
[13:20:01.942]   - Field: ‘version’
[13:20:01.942]   - Field: ‘result’
[13:20:01.942]   - Field: ‘asynchronous’
[13:20:01.942]   - Field: ‘calls’
[13:20:01.942]   - Field: ‘globals’
[13:20:01.942]   - Field: ‘stdout’
[13:20:01.943]   - Field: ‘earlySignal’
[13:20:01.943]   - Field: ‘lazy’
[13:20:01.943]   - Field: ‘state’
[13:20:01.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.943] - Launch lazy future ...
[13:20:01.943] Packages needed by the future expression (n = 0): <none>
[13:20:01.943] Packages needed by future strategies (n = 0): <none>
[13:20:01.944] {
[13:20:01.944]     {
[13:20:01.944]         {
[13:20:01.944]             ...future.startTime <- base::Sys.time()
[13:20:01.944]             {
[13:20:01.944]                 {
[13:20:01.944]                   {
[13:20:01.944]                     base::local({
[13:20:01.944]                       has_future <- base::requireNamespace("future", 
[13:20:01.944]                         quietly = TRUE)
[13:20:01.944]                       if (has_future) {
[13:20:01.944]                         ns <- base::getNamespace("future")
[13:20:01.944]                         version <- ns[[".package"]][["version"]]
[13:20:01.944]                         if (is.null(version)) 
[13:20:01.944]                           version <- utils::packageVersion("future")
[13:20:01.944]                       }
[13:20:01.944]                       else {
[13:20:01.944]                         version <- NULL
[13:20:01.944]                       }
[13:20:01.944]                       if (!has_future || version < "1.8.0") {
[13:20:01.944]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.944]                           "", base::R.version$version.string), 
[13:20:01.944]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:01.944]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.944]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.944]                             "release", "version")], collapse = " "), 
[13:20:01.944]                           hostname = base::Sys.info()[["nodename"]])
[13:20:01.944]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.944]                           info)
[13:20:01.944]                         info <- base::paste(info, collapse = "; ")
[13:20:01.944]                         if (!has_future) {
[13:20:01.944]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.944]                             info)
[13:20:01.944]                         }
[13:20:01.944]                         else {
[13:20:01.944]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.944]                             info, version)
[13:20:01.944]                         }
[13:20:01.944]                         base::stop(msg)
[13:20:01.944]                       }
[13:20:01.944]                     })
[13:20:01.944]                   }
[13:20:01.944]                   options(future.plan = NULL)
[13:20:01.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.944]                 }
[13:20:01.944]                 ...future.workdir <- getwd()
[13:20:01.944]             }
[13:20:01.944]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.944]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.944]         }
[13:20:01.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.944]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.944]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.944]             base::names(...future.oldOptions))
[13:20:01.944]     }
[13:20:01.944]     if (FALSE) {
[13:20:01.944]     }
[13:20:01.944]     else {
[13:20:01.944]         if (TRUE) {
[13:20:01.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.944]                 open = "w")
[13:20:01.944]         }
[13:20:01.944]         else {
[13:20:01.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.944]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.944]         }
[13:20:01.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.944]             base::sink(type = "output", split = FALSE)
[13:20:01.944]             base::close(...future.stdout)
[13:20:01.944]         }, add = TRUE)
[13:20:01.944]     }
[13:20:01.944]     ...future.frame <- base::sys.nframe()
[13:20:01.944]     ...future.conditions <- base::list()
[13:20:01.944]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.944]     if (FALSE) {
[13:20:01.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.944]     }
[13:20:01.944]     ...future.result <- base::tryCatch({
[13:20:01.944]         base::withCallingHandlers({
[13:20:01.944]             ...future.value <- base::withVisible(base::local({
[13:20:01.944]                 do.call(function(...) {
[13:20:01.944]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.944]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.944]                     ...future.globals.maxSize)) {
[13:20:01.944]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.944]                     on.exit(options(oopts), add = TRUE)
[13:20:01.944]                   }
[13:20:01.944]                   {
[13:20:01.944]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.944]                       FUN = function(jj) {
[13:20:01.944]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.944]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.944]                       })
[13:20:01.944]                   }
[13:20:01.944]                 }, args = future.call.arguments)
[13:20:01.944]             }))
[13:20:01.944]             future::FutureResult(value = ...future.value$value, 
[13:20:01.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.944]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.944]                     ...future.globalenv.names))
[13:20:01.944]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.944]         }, condition = base::local({
[13:20:01.944]             c <- base::c
[13:20:01.944]             inherits <- base::inherits
[13:20:01.944]             invokeRestart <- base::invokeRestart
[13:20:01.944]             length <- base::length
[13:20:01.944]             list <- base::list
[13:20:01.944]             seq.int <- base::seq.int
[13:20:01.944]             signalCondition <- base::signalCondition
[13:20:01.944]             sys.calls <- base::sys.calls
[13:20:01.944]             `[[` <- base::`[[`
[13:20:01.944]             `+` <- base::`+`
[13:20:01.944]             `<<-` <- base::`<<-`
[13:20:01.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.944]                   3L)]
[13:20:01.944]             }
[13:20:01.944]             function(cond) {
[13:20:01.944]                 is_error <- inherits(cond, "error")
[13:20:01.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.944]                   NULL)
[13:20:01.944]                 if (is_error) {
[13:20:01.944]                   sessionInformation <- function() {
[13:20:01.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.944]                       search = base::search(), system = base::Sys.info())
[13:20:01.944]                   }
[13:20:01.944]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.944]                     cond$call), session = sessionInformation(), 
[13:20:01.944]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.944]                   signalCondition(cond)
[13:20:01.944]                 }
[13:20:01.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.944]                 "immediateCondition"))) {
[13:20:01.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.944]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.944]                   if (TRUE && !signal) {
[13:20:01.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.944]                     {
[13:20:01.944]                       inherits <- base::inherits
[13:20:01.944]                       invokeRestart <- base::invokeRestart
[13:20:01.944]                       is.null <- base::is.null
[13:20:01.944]                       muffled <- FALSE
[13:20:01.944]                       if (inherits(cond, "message")) {
[13:20:01.944]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.944]                         if (muffled) 
[13:20:01.944]                           invokeRestart("muffleMessage")
[13:20:01.944]                       }
[13:20:01.944]                       else if (inherits(cond, "warning")) {
[13:20:01.944]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.944]                         if (muffled) 
[13:20:01.944]                           invokeRestart("muffleWarning")
[13:20:01.944]                       }
[13:20:01.944]                       else if (inherits(cond, "condition")) {
[13:20:01.944]                         if (!is.null(pattern)) {
[13:20:01.944]                           computeRestarts <- base::computeRestarts
[13:20:01.944]                           grepl <- base::grepl
[13:20:01.944]                           restarts <- computeRestarts(cond)
[13:20:01.944]                           for (restart in restarts) {
[13:20:01.944]                             name <- restart$name
[13:20:01.944]                             if (is.null(name)) 
[13:20:01.944]                               next
[13:20:01.944]                             if (!grepl(pattern, name)) 
[13:20:01.944]                               next
[13:20:01.944]                             invokeRestart(restart)
[13:20:01.944]                             muffled <- TRUE
[13:20:01.944]                             break
[13:20:01.944]                           }
[13:20:01.944]                         }
[13:20:01.944]                       }
[13:20:01.944]                       invisible(muffled)
[13:20:01.944]                     }
[13:20:01.944]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.944]                   }
[13:20:01.944]                 }
[13:20:01.944]                 else {
[13:20:01.944]                   if (TRUE) {
[13:20:01.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.944]                     {
[13:20:01.944]                       inherits <- base::inherits
[13:20:01.944]                       invokeRestart <- base::invokeRestart
[13:20:01.944]                       is.null <- base::is.null
[13:20:01.944]                       muffled <- FALSE
[13:20:01.944]                       if (inherits(cond, "message")) {
[13:20:01.944]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.944]                         if (muffled) 
[13:20:01.944]                           invokeRestart("muffleMessage")
[13:20:01.944]                       }
[13:20:01.944]                       else if (inherits(cond, "warning")) {
[13:20:01.944]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.944]                         if (muffled) 
[13:20:01.944]                           invokeRestart("muffleWarning")
[13:20:01.944]                       }
[13:20:01.944]                       else if (inherits(cond, "condition")) {
[13:20:01.944]                         if (!is.null(pattern)) {
[13:20:01.944]                           computeRestarts <- base::computeRestarts
[13:20:01.944]                           grepl <- base::grepl
[13:20:01.944]                           restarts <- computeRestarts(cond)
[13:20:01.944]                           for (restart in restarts) {
[13:20:01.944]                             name <- restart$name
[13:20:01.944]                             if (is.null(name)) 
[13:20:01.944]                               next
[13:20:01.944]                             if (!grepl(pattern, name)) 
[13:20:01.944]                               next
[13:20:01.944]                             invokeRestart(restart)
[13:20:01.944]                             muffled <- TRUE
[13:20:01.944]                             break
[13:20:01.944]                           }
[13:20:01.944]                         }
[13:20:01.944]                       }
[13:20:01.944]                       invisible(muffled)
[13:20:01.944]                     }
[13:20:01.944]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.944]                   }
[13:20:01.944]                 }
[13:20:01.944]             }
[13:20:01.944]         }))
[13:20:01.944]     }, error = function(ex) {
[13:20:01.944]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.944]                 ...future.rng), started = ...future.startTime, 
[13:20:01.944]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.944]             version = "1.8"), class = "FutureResult")
[13:20:01.944]     }, finally = {
[13:20:01.944]         if (!identical(...future.workdir, getwd())) 
[13:20:01.944]             setwd(...future.workdir)
[13:20:01.944]         {
[13:20:01.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.944]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.944]             }
[13:20:01.944]             base::options(...future.oldOptions)
[13:20:01.944]             if (.Platform$OS.type == "windows") {
[13:20:01.944]                 old_names <- names(...future.oldEnvVars)
[13:20:01.944]                 envs <- base::Sys.getenv()
[13:20:01.944]                 names <- names(envs)
[13:20:01.944]                 common <- intersect(names, old_names)
[13:20:01.944]                 added <- setdiff(names, old_names)
[13:20:01.944]                 removed <- setdiff(old_names, names)
[13:20:01.944]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.944]                   envs[common]]
[13:20:01.944]                 NAMES <- toupper(changed)
[13:20:01.944]                 args <- list()
[13:20:01.944]                 for (kk in seq_along(NAMES)) {
[13:20:01.944]                   name <- changed[[kk]]
[13:20:01.944]                   NAME <- NAMES[[kk]]
[13:20:01.944]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.944]                     next
[13:20:01.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.944]                 }
[13:20:01.944]                 NAMES <- toupper(added)
[13:20:01.944]                 for (kk in seq_along(NAMES)) {
[13:20:01.944]                   name <- added[[kk]]
[13:20:01.944]                   NAME <- NAMES[[kk]]
[13:20:01.944]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.944]                     next
[13:20:01.944]                   args[[name]] <- ""
[13:20:01.944]                 }
[13:20:01.944]                 NAMES <- toupper(removed)
[13:20:01.944]                 for (kk in seq_along(NAMES)) {
[13:20:01.944]                   name <- removed[[kk]]
[13:20:01.944]                   NAME <- NAMES[[kk]]
[13:20:01.944]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.944]                     next
[13:20:01.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.944]                 }
[13:20:01.944]                 if (length(args) > 0) 
[13:20:01.944]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.944]             }
[13:20:01.944]             else {
[13:20:01.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.944]             }
[13:20:01.944]             {
[13:20:01.944]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.944]                   0L) {
[13:20:01.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.944]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.944]                   base::options(opts)
[13:20:01.944]                 }
[13:20:01.944]                 {
[13:20:01.944]                   {
[13:20:01.944]                     NULL
[13:20:01.944]                     RNGkind("Mersenne-Twister")
[13:20:01.944]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.944]                       inherits = FALSE)
[13:20:01.944]                   }
[13:20:01.944]                   options(future.plan = NULL)
[13:20:01.944]                   if (is.na(NA_character_)) 
[13:20:01.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.944]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:01.944]                     envir = parent.frame()) 
[13:20:01.944]                   {
[13:20:01.944]                     default_workers <- missing(workers)
[13:20:01.944]                     if (is.function(workers)) 
[13:20:01.944]                       workers <- workers()
[13:20:01.944]                     workers <- structure(as.integer(workers), 
[13:20:01.944]                       class = class(workers))
[13:20:01.944]                     stop_if_not(is.finite(workers), workers >= 
[13:20:01.944]                       1L)
[13:20:01.944]                     if ((workers == 1L && !inherits(workers, 
[13:20:01.944]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:01.944]                       if (default_workers) 
[13:20:01.944]                         supportsMulticore(warn = TRUE)
[13:20:01.944]                       return(sequential(..., envir = envir))
[13:20:01.944]                     }
[13:20:01.944]                     oopts <- options(mc.cores = workers)
[13:20:01.944]                     on.exit(options(oopts))
[13:20:01.944]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:01.944]                       envir = envir)
[13:20:01.944]                     if (!future$lazy) 
[13:20:01.944]                       future <- run(future)
[13:20:01.944]                     invisible(future)
[13:20:01.944]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.944]                 }
[13:20:01.944]             }
[13:20:01.944]         }
[13:20:01.944]     })
[13:20:01.944]     if (TRUE) {
[13:20:01.944]         base::sink(type = "output", split = FALSE)
[13:20:01.944]         if (TRUE) {
[13:20:01.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.944]         }
[13:20:01.944]         else {
[13:20:01.944]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.944]         }
[13:20:01.944]         base::close(...future.stdout)
[13:20:01.944]         ...future.stdout <- NULL
[13:20:01.944]     }
[13:20:01.944]     ...future.result$conditions <- ...future.conditions
[13:20:01.944]     ...future.result$finished <- base::Sys.time()
[13:20:01.944]     ...future.result
[13:20:01.944] }
[13:20:01.946] assign_globals() ...
[13:20:01.946] List of 5
[13:20:01.946]  $ ...future.FUN            :function (object, ...)  
[13:20:01.946]  $ future.call.arguments    : list()
[13:20:01.946]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.946]  $ ...future.elements_ii    :List of 3
[13:20:01.946]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:01.946]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:01.946]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.946]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:01.946]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:01.946]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.946]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:01.946]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:01.946]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:01.946]  $ ...future.seeds_ii       : NULL
[13:20:01.946]  $ ...future.globals.maxSize: NULL
[13:20:01.946]  - attr(*, "where")=List of 5
[13:20:01.946]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:01.946]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:01.946]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:01.946]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:01.946]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:01.946]  - attr(*, "resolved")= logi FALSE
[13:20:01.946]  - attr(*, "total_size")= num 1240
[13:20:01.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.946]  - attr(*, "already-done")= logi TRUE
[13:20:01.956] - copied ‘...future.FUN’ to environment
[13:20:01.956] - copied ‘future.call.arguments’ to environment
[13:20:01.956] - copied ‘...future.elements_ii’ to environment
[13:20:01.956] - copied ‘...future.seeds_ii’ to environment
[13:20:01.956] - copied ‘...future.globals.maxSize’ to environment
[13:20:01.956] assign_globals() ... done
[13:20:01.956] plan(): Setting new future strategy stack:
[13:20:01.957] List of future strategies:
[13:20:01.957] 1. sequential:
[13:20:01.957]    - args: function (..., envir = parent.frame())
[13:20:01.957]    - tweaked: FALSE
[13:20:01.957]    - call: NULL
[13:20:01.957] plan(): nbrOfWorkers() = 1
[13:20:01.959] plan(): Setting new future strategy stack:
[13:20:01.959] List of future strategies:
[13:20:01.959] 1. multicore:
[13:20:01.959]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:01.959]    - tweaked: FALSE
[13:20:01.959]    - call: plan(strategy)
[13:20:01.963] plan(): nbrOfWorkers() = 1
[13:20:01.963] SequentialFuture started (and completed)
[13:20:01.963] - Launch lazy future ... done
[13:20:01.963] run() for ‘SequentialFuture’ ... done
[13:20:01.963] Created future:
[13:20:01.964] SequentialFuture:
[13:20:01.964] Label: ‘future_by-1’
[13:20:01.964] Expression:
[13:20:01.964] {
[13:20:01.964]     do.call(function(...) {
[13:20:01.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.964]             on.exit(options(oopts), add = TRUE)
[13:20:01.964]         }
[13:20:01.964]         {
[13:20:01.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.964]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.964]             })
[13:20:01.964]         }
[13:20:01.964]     }, args = future.call.arguments)
[13:20:01.964] }
[13:20:01.964] Lazy evaluation: FALSE
[13:20:01.964] Asynchronous evaluation: FALSE
[13:20:01.964] Local evaluation: TRUE
[13:20:01.964] Environment: R_GlobalEnv
[13:20:01.964] Capture standard output: TRUE
[13:20:01.964] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:01.964] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:01.964] Packages: <none>
[13:20:01.964] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:01.964] Resolved: TRUE
[13:20:01.964] Value: 4.62 KiB of class ‘list’
[13:20:01.964] Early signaling: FALSE
[13:20:01.964] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:01.964] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.965] Chunk #1 of 1 ... DONE
[13:20:01.965] Launching 1 futures (chunks) ... DONE
[13:20:01.965] Resolving 1 futures (chunks) ...
[13:20:01.965] resolve() on list ...
[13:20:01.965]  recursive: 0
[13:20:01.965]  length: 1
[13:20:01.965] 
[13:20:01.966] resolved() for ‘SequentialFuture’ ...
[13:20:01.966] - state: ‘finished’
[13:20:01.966] - run: TRUE
[13:20:01.966] - result: ‘FutureResult’
[13:20:01.966] resolved() for ‘SequentialFuture’ ... done
[13:20:01.966] Future #1
[13:20:01.966] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:01.966] - nx: 1
[13:20:01.966] - relay: TRUE
[13:20:01.966] - stdout: TRUE
[13:20:01.966] - signal: TRUE
[13:20:01.967] - resignal: FALSE
[13:20:01.967] - force: TRUE
[13:20:01.967] - relayed: [n=1] FALSE
[13:20:01.967] - queued futures: [n=1] FALSE
[13:20:01.967]  - until=1
[13:20:01.967]  - relaying element #1
[13:20:01.967] - relayed: [n=1] TRUE
[13:20:01.967] - queued futures: [n=1] TRUE
[13:20:01.967] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:01.967]  length: 0 (resolved future 1)
[13:20:01.968] Relaying remaining futures
[13:20:01.968] signalConditionsASAP(NULL, pos=0) ...
[13:20:01.968] - nx: 1
[13:20:01.968] - relay: TRUE
[13:20:01.968] - stdout: TRUE
[13:20:01.968] - signal: TRUE
[13:20:01.968] - resignal: FALSE
[13:20:01.968] - force: TRUE
[13:20:01.968] - relayed: [n=1] TRUE
[13:20:01.968] - queued futures: [n=1] TRUE
 - flush all
[13:20:01.969] - relayed: [n=1] TRUE
[13:20:01.969] - queued futures: [n=1] TRUE
[13:20:01.969] signalConditionsASAP(NULL, pos=0) ... done
[13:20:01.969] resolve() on list ... DONE
[13:20:01.969]  - Number of value chunks collected: 1
[13:20:01.969] Resolving 1 futures (chunks) ... DONE
[13:20:01.969] Reducing values from 1 chunks ...
[13:20:01.969]  - Number of values collected after concatenation: 3
[13:20:01.969]  - Number of values expected: 3
[13:20:01.969] Reducing values from 1 chunks ... DONE
[13:20:01.969] future_lapply() ... DONE
[13:20:01.970] future_by_internal() ... DONE
[13:20:01.970] future_by_internal() ...
[13:20:01.970] future_lapply() ...
[13:20:01.974] Number of chunks: 1
[13:20:01.974] getGlobalsAndPackagesXApply() ...
[13:20:01.974]  - future.globals: TRUE
[13:20:01.975] getGlobalsAndPackages() ...
[13:20:01.975] Searching for globals...
[13:20:01.978] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:01.978] Searching for globals ... DONE
[13:20:01.978] Resolving globals: FALSE
[13:20:01.978] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:01.979] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:01.979] - globals: [1] ‘FUN’
[13:20:01.979] 
[13:20:01.979] getGlobalsAndPackages() ... DONE
[13:20:01.979]  - globals found/used: [n=1] ‘FUN’
[13:20:01.979]  - needed namespaces: [n=0] 
[13:20:01.979] Finding globals ... DONE
[13:20:01.980]  - use_args: TRUE
[13:20:01.980]  - Getting '...' globals ...
[13:20:01.980] resolve() on list ...
[13:20:01.980]  recursive: 0
[13:20:01.980]  length: 1
[13:20:01.980]  elements: ‘...’
[13:20:01.980]  length: 0 (resolved future 1)
[13:20:01.981] resolve() on list ... DONE
[13:20:01.981]    - '...' content: [n=1] ‘digits’
[13:20:01.981] List of 1
[13:20:01.981]  $ ...:List of 1
[13:20:01.981]   ..$ digits: int 2
[13:20:01.981]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.981]  - attr(*, "where")=List of 1
[13:20:01.981]   ..$ ...:<environment: 0x55aceece7500> 
[13:20:01.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.981]  - attr(*, "resolved")= logi TRUE
[13:20:01.981]  - attr(*, "total_size")= num NA
[13:20:01.984]  - Getting '...' globals ... DONE
[13:20:01.984] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:01.984] List of 2
[13:20:01.984]  $ ...future.FUN:function (object, ...)  
[13:20:01.984]  $ ...          :List of 1
[13:20:01.984]   ..$ digits: int 2
[13:20:01.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:01.984]  - attr(*, "where")=List of 2
[13:20:01.984]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:01.984]   ..$ ...          :<environment: 0x55aceece7500> 
[13:20:01.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:01.984]  - attr(*, "resolved")= logi FALSE
[13:20:01.984]  - attr(*, "total_size")= num 1296
[13:20:01.987] Packages to be attached in all futures: [n=0] 
[13:20:01.987] getGlobalsAndPackagesXApply() ... DONE
[13:20:01.988] Number of futures (= number of chunks): 1
[13:20:01.988] Launching 1 futures (chunks) ...
[13:20:01.988] Chunk #1 of 1 ...
[13:20:01.988]  - Finding globals in 'X' for chunk #1 ...
[13:20:01.988] getGlobalsAndPackages() ...
[13:20:01.988] Searching for globals...
[13:20:01.988] 
[13:20:01.989] Searching for globals ... DONE
[13:20:01.989] - globals: [0] <none>
[13:20:01.989] getGlobalsAndPackages() ... DONE
[13:20:01.989]    + additional globals found: [n=0] 
[13:20:01.989]    + additional namespaces needed: [n=0] 
[13:20:01.989]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:01.989]  - seeds: <none>
[13:20:01.989]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.989] getGlobalsAndPackages() ...
[13:20:01.989] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.990] Resolving globals: FALSE
[13:20:01.990] Tweak future expression to call with '...' arguments ...
[13:20:01.990] {
[13:20:01.990]     do.call(function(...) {
[13:20:01.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:01.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.990]             on.exit(options(oopts), add = TRUE)
[13:20:01.990]         }
[13:20:01.990]         {
[13:20:01.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:01.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.990]                 ...future.FUN(...future.X_jj, ...)
[13:20:01.990]             })
[13:20:01.990]         }
[13:20:01.990]     }, args = future.call.arguments)
[13:20:01.990] }
[13:20:01.990] Tweak future expression to call with '...' arguments ... DONE
[13:20:01.990] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:01.990] 
[13:20:01.991] getGlobalsAndPackages() ... DONE
[13:20:01.991] run() for ‘Future’ ...
[13:20:01.991] - state: ‘created’
[13:20:01.991] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:01.995] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:01.995] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:01.995]   - Field: ‘label’
[13:20:01.995]   - Field: ‘local’
[13:20:01.995]   - Field: ‘owner’
[13:20:01.995]   - Field: ‘envir’
[13:20:01.995]   - Field: ‘packages’
[13:20:01.996]   - Field: ‘gc’
[13:20:01.996]   - Field: ‘conditions’
[13:20:01.996]   - Field: ‘expr’
[13:20:01.996]   - Field: ‘uuid’
[13:20:01.996]   - Field: ‘seed’
[13:20:01.996]   - Field: ‘version’
[13:20:01.996]   - Field: ‘result’
[13:20:01.996]   - Field: ‘asynchronous’
[13:20:01.996]   - Field: ‘calls’
[13:20:01.996]   - Field: ‘globals’
[13:20:01.997]   - Field: ‘stdout’
[13:20:01.997]   - Field: ‘earlySignal’
[13:20:01.997]   - Field: ‘lazy’
[13:20:01.997]   - Field: ‘state’
[13:20:01.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:01.997] - Launch lazy future ...
[13:20:01.997] Packages needed by the future expression (n = 0): <none>
[13:20:01.997] Packages needed by future strategies (n = 0): <none>
[13:20:01.998] {
[13:20:01.998]     {
[13:20:01.998]         {
[13:20:01.998]             ...future.startTime <- base::Sys.time()
[13:20:01.998]             {
[13:20:01.998]                 {
[13:20:01.998]                   {
[13:20:01.998]                     base::local({
[13:20:01.998]                       has_future <- base::requireNamespace("future", 
[13:20:01.998]                         quietly = TRUE)
[13:20:01.998]                       if (has_future) {
[13:20:01.998]                         ns <- base::getNamespace("future")
[13:20:01.998]                         version <- ns[[".package"]][["version"]]
[13:20:01.998]                         if (is.null(version)) 
[13:20:01.998]                           version <- utils::packageVersion("future")
[13:20:01.998]                       }
[13:20:01.998]                       else {
[13:20:01.998]                         version <- NULL
[13:20:01.998]                       }
[13:20:01.998]                       if (!has_future || version < "1.8.0") {
[13:20:01.998]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:01.998]                           "", base::R.version$version.string), 
[13:20:01.998]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:01.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:01.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:01.998]                             "release", "version")], collapse = " "), 
[13:20:01.998]                           hostname = base::Sys.info()[["nodename"]])
[13:20:01.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:01.998]                           info)
[13:20:01.998]                         info <- base::paste(info, collapse = "; ")
[13:20:01.998]                         if (!has_future) {
[13:20:01.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:01.998]                             info)
[13:20:01.998]                         }
[13:20:01.998]                         else {
[13:20:01.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:01.998]                             info, version)
[13:20:01.998]                         }
[13:20:01.998]                         base::stop(msg)
[13:20:01.998]                       }
[13:20:01.998]                     })
[13:20:01.998]                   }
[13:20:01.998]                   options(future.plan = NULL)
[13:20:01.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:01.998]                 }
[13:20:01.998]                 ...future.workdir <- getwd()
[13:20:01.998]             }
[13:20:01.998]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:01.998]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:01.998]         }
[13:20:01.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:01.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:01.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:01.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:01.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:01.998]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:01.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:01.998]             base::names(...future.oldOptions))
[13:20:01.998]     }
[13:20:01.998]     if (FALSE) {
[13:20:01.998]     }
[13:20:01.998]     else {
[13:20:01.998]         if (TRUE) {
[13:20:01.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:01.998]                 open = "w")
[13:20:01.998]         }
[13:20:01.998]         else {
[13:20:01.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:01.998]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:01.998]         }
[13:20:01.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:01.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:01.998]             base::sink(type = "output", split = FALSE)
[13:20:01.998]             base::close(...future.stdout)
[13:20:01.998]         }, add = TRUE)
[13:20:01.998]     }
[13:20:01.998]     ...future.frame <- base::sys.nframe()
[13:20:01.998]     ...future.conditions <- base::list()
[13:20:01.998]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:01.998]     if (FALSE) {
[13:20:01.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:01.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:01.998]     }
[13:20:01.998]     ...future.result <- base::tryCatch({
[13:20:01.998]         base::withCallingHandlers({
[13:20:01.998]             ...future.value <- base::withVisible(base::local({
[13:20:01.998]                 do.call(function(...) {
[13:20:01.998]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:01.998]                   if (!identical(...future.globals.maxSize.org, 
[13:20:01.998]                     ...future.globals.maxSize)) {
[13:20:01.998]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:01.998]                     on.exit(options(oopts), add = TRUE)
[13:20:01.998]                   }
[13:20:01.998]                   {
[13:20:01.998]                     lapply(seq_along(...future.elements_ii), 
[13:20:01.998]                       FUN = function(jj) {
[13:20:01.998]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:01.998]                         ...future.FUN(...future.X_jj, ...)
[13:20:01.998]                       })
[13:20:01.998]                   }
[13:20:01.998]                 }, args = future.call.arguments)
[13:20:01.998]             }))
[13:20:01.998]             future::FutureResult(value = ...future.value$value, 
[13:20:01.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.998]                   ...future.rng), globalenv = if (FALSE) 
[13:20:01.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:01.998]                     ...future.globalenv.names))
[13:20:01.998]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:01.998]         }, condition = base::local({
[13:20:01.998]             c <- base::c
[13:20:01.998]             inherits <- base::inherits
[13:20:01.998]             invokeRestart <- base::invokeRestart
[13:20:01.998]             length <- base::length
[13:20:01.998]             list <- base::list
[13:20:01.998]             seq.int <- base::seq.int
[13:20:01.998]             signalCondition <- base::signalCondition
[13:20:01.998]             sys.calls <- base::sys.calls
[13:20:01.998]             `[[` <- base::`[[`
[13:20:01.998]             `+` <- base::`+`
[13:20:01.998]             `<<-` <- base::`<<-`
[13:20:01.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:01.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:01.998]                   3L)]
[13:20:01.998]             }
[13:20:01.998]             function(cond) {
[13:20:01.998]                 is_error <- inherits(cond, "error")
[13:20:01.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:01.998]                   NULL)
[13:20:01.998]                 if (is_error) {
[13:20:01.998]                   sessionInformation <- function() {
[13:20:01.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:01.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:01.998]                       search = base::search(), system = base::Sys.info())
[13:20:01.998]                   }
[13:20:01.998]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:01.998]                     cond$call), session = sessionInformation(), 
[13:20:01.998]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:01.998]                   signalCondition(cond)
[13:20:01.998]                 }
[13:20:01.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:01.998]                 "immediateCondition"))) {
[13:20:01.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:01.998]                   ...future.conditions[[length(...future.conditions) + 
[13:20:01.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:01.998]                   if (TRUE && !signal) {
[13:20:01.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.998]                     {
[13:20:01.998]                       inherits <- base::inherits
[13:20:01.998]                       invokeRestart <- base::invokeRestart
[13:20:01.998]                       is.null <- base::is.null
[13:20:01.998]                       muffled <- FALSE
[13:20:01.998]                       if (inherits(cond, "message")) {
[13:20:01.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.998]                         if (muffled) 
[13:20:01.998]                           invokeRestart("muffleMessage")
[13:20:01.998]                       }
[13:20:01.998]                       else if (inherits(cond, "warning")) {
[13:20:01.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.998]                         if (muffled) 
[13:20:01.998]                           invokeRestart("muffleWarning")
[13:20:01.998]                       }
[13:20:01.998]                       else if (inherits(cond, "condition")) {
[13:20:01.998]                         if (!is.null(pattern)) {
[13:20:01.998]                           computeRestarts <- base::computeRestarts
[13:20:01.998]                           grepl <- base::grepl
[13:20:01.998]                           restarts <- computeRestarts(cond)
[13:20:01.998]                           for (restart in restarts) {
[13:20:01.998]                             name <- restart$name
[13:20:01.998]                             if (is.null(name)) 
[13:20:01.998]                               next
[13:20:01.998]                             if (!grepl(pattern, name)) 
[13:20:01.998]                               next
[13:20:01.998]                             invokeRestart(restart)
[13:20:01.998]                             muffled <- TRUE
[13:20:01.998]                             break
[13:20:01.998]                           }
[13:20:01.998]                         }
[13:20:01.998]                       }
[13:20:01.998]                       invisible(muffled)
[13:20:01.998]                     }
[13:20:01.998]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.998]                   }
[13:20:01.998]                 }
[13:20:01.998]                 else {
[13:20:01.998]                   if (TRUE) {
[13:20:01.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:01.998]                     {
[13:20:01.998]                       inherits <- base::inherits
[13:20:01.998]                       invokeRestart <- base::invokeRestart
[13:20:01.998]                       is.null <- base::is.null
[13:20:01.998]                       muffled <- FALSE
[13:20:01.998]                       if (inherits(cond, "message")) {
[13:20:01.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:01.998]                         if (muffled) 
[13:20:01.998]                           invokeRestart("muffleMessage")
[13:20:01.998]                       }
[13:20:01.998]                       else if (inherits(cond, "warning")) {
[13:20:01.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:01.998]                         if (muffled) 
[13:20:01.998]                           invokeRestart("muffleWarning")
[13:20:01.998]                       }
[13:20:01.998]                       else if (inherits(cond, "condition")) {
[13:20:01.998]                         if (!is.null(pattern)) {
[13:20:01.998]                           computeRestarts <- base::computeRestarts
[13:20:01.998]                           grepl <- base::grepl
[13:20:01.998]                           restarts <- computeRestarts(cond)
[13:20:01.998]                           for (restart in restarts) {
[13:20:01.998]                             name <- restart$name
[13:20:01.998]                             if (is.null(name)) 
[13:20:01.998]                               next
[13:20:01.998]                             if (!grepl(pattern, name)) 
[13:20:01.998]                               next
[13:20:01.998]                             invokeRestart(restart)
[13:20:01.998]                             muffled <- TRUE
[13:20:01.998]                             break
[13:20:01.998]                           }
[13:20:01.998]                         }
[13:20:01.998]                       }
[13:20:01.998]                       invisible(muffled)
[13:20:01.998]                     }
[13:20:01.998]                     muffleCondition(cond, pattern = "^muffle")
[13:20:01.998]                   }
[13:20:01.998]                 }
[13:20:01.998]             }
[13:20:01.998]         }))
[13:20:01.998]     }, error = function(ex) {
[13:20:01.998]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:01.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:01.998]                 ...future.rng), started = ...future.startTime, 
[13:20:01.998]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:01.998]             version = "1.8"), class = "FutureResult")
[13:20:01.998]     }, finally = {
[13:20:01.998]         if (!identical(...future.workdir, getwd())) 
[13:20:01.998]             setwd(...future.workdir)
[13:20:01.998]         {
[13:20:01.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:01.998]                 ...future.oldOptions$nwarnings <- NULL
[13:20:01.998]             }
[13:20:01.998]             base::options(...future.oldOptions)
[13:20:01.998]             if (.Platform$OS.type == "windows") {
[13:20:01.998]                 old_names <- names(...future.oldEnvVars)
[13:20:01.998]                 envs <- base::Sys.getenv()
[13:20:01.998]                 names <- names(envs)
[13:20:01.998]                 common <- intersect(names, old_names)
[13:20:01.998]                 added <- setdiff(names, old_names)
[13:20:01.998]                 removed <- setdiff(old_names, names)
[13:20:01.998]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:01.998]                   envs[common]]
[13:20:01.998]                 NAMES <- toupper(changed)
[13:20:01.998]                 args <- list()
[13:20:01.998]                 for (kk in seq_along(NAMES)) {
[13:20:01.998]                   name <- changed[[kk]]
[13:20:01.998]                   NAME <- NAMES[[kk]]
[13:20:01.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.998]                     next
[13:20:01.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.998]                 }
[13:20:01.998]                 NAMES <- toupper(added)
[13:20:01.998]                 for (kk in seq_along(NAMES)) {
[13:20:01.998]                   name <- added[[kk]]
[13:20:01.998]                   NAME <- NAMES[[kk]]
[13:20:01.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.998]                     next
[13:20:01.998]                   args[[name]] <- ""
[13:20:01.998]                 }
[13:20:01.998]                 NAMES <- toupper(removed)
[13:20:01.998]                 for (kk in seq_along(NAMES)) {
[13:20:01.998]                   name <- removed[[kk]]
[13:20:01.998]                   NAME <- NAMES[[kk]]
[13:20:01.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:01.998]                     next
[13:20:01.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:01.998]                 }
[13:20:01.998]                 if (length(args) > 0) 
[13:20:01.998]                   base::do.call(base::Sys.setenv, args = args)
[13:20:01.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:01.998]             }
[13:20:01.998]             else {
[13:20:01.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:01.998]             }
[13:20:01.998]             {
[13:20:01.998]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:01.998]                   0L) {
[13:20:01.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:01.998]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:01.998]                   base::options(opts)
[13:20:01.998]                 }
[13:20:01.998]                 {
[13:20:01.998]                   {
[13:20:01.998]                     NULL
[13:20:01.998]                     RNGkind("Mersenne-Twister")
[13:20:01.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:01.998]                       inherits = FALSE)
[13:20:01.998]                   }
[13:20:01.998]                   options(future.plan = NULL)
[13:20:01.998]                   if (is.na(NA_character_)) 
[13:20:01.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:01.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:01.998]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:01.998]                     envir = parent.frame()) 
[13:20:01.998]                   {
[13:20:01.998]                     default_workers <- missing(workers)
[13:20:01.998]                     if (is.function(workers)) 
[13:20:01.998]                       workers <- workers()
[13:20:01.998]                     workers <- structure(as.integer(workers), 
[13:20:01.998]                       class = class(workers))
[13:20:01.998]                     stop_if_not(is.finite(workers), workers >= 
[13:20:01.998]                       1L)
[13:20:01.998]                     if ((workers == 1L && !inherits(workers, 
[13:20:01.998]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:01.998]                       if (default_workers) 
[13:20:01.998]                         supportsMulticore(warn = TRUE)
[13:20:01.998]                       return(sequential(..., envir = envir))
[13:20:01.998]                     }
[13:20:01.998]                     oopts <- options(mc.cores = workers)
[13:20:01.998]                     on.exit(options(oopts))
[13:20:01.998]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:01.998]                       envir = envir)
[13:20:01.998]                     if (!future$lazy) 
[13:20:01.998]                       future <- run(future)
[13:20:01.998]                     invisible(future)
[13:20:01.998]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:01.998]                 }
[13:20:01.998]             }
[13:20:01.998]         }
[13:20:01.998]     })
[13:20:01.998]     if (TRUE) {
[13:20:01.998]         base::sink(type = "output", split = FALSE)
[13:20:01.998]         if (TRUE) {
[13:20:01.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:01.998]         }
[13:20:01.998]         else {
[13:20:01.998]             ...future.result["stdout"] <- base::list(NULL)
[13:20:01.998]         }
[13:20:01.998]         base::close(...future.stdout)
[13:20:01.998]         ...future.stdout <- NULL
[13:20:01.998]     }
[13:20:01.998]     ...future.result$conditions <- ...future.conditions
[13:20:01.998]     ...future.result$finished <- base::Sys.time()
[13:20:01.998]     ...future.result
[13:20:01.998] }
[13:20:02.000] assign_globals() ...
[13:20:02.002] List of 5
[13:20:02.002]  $ ...future.FUN            :function (object, ...)  
[13:20:02.002]  $ future.call.arguments    :List of 1
[13:20:02.002]   ..$ digits: int 2
[13:20:02.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.002]  $ ...future.elements_ii    :List of 6
[13:20:02.002]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:20:02.002]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:20:02.002]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:20:02.002]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:20:02.002]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:20:02.002]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:20:02.002]  $ ...future.seeds_ii       : NULL
[13:20:02.002]  $ ...future.globals.maxSize: NULL
[13:20:02.002]  - attr(*, "where")=List of 5
[13:20:02.002]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.002]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.002]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.002]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.002]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.002]  - attr(*, "resolved")= logi FALSE
[13:20:02.002]  - attr(*, "total_size")= num 1296
[13:20:02.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.002]  - attr(*, "already-done")= logi TRUE
[13:20:02.009] - copied ‘...future.FUN’ to environment
[13:20:02.009] - copied ‘future.call.arguments’ to environment
[13:20:02.009] - copied ‘...future.elements_ii’ to environment
[13:20:02.009] - copied ‘...future.seeds_ii’ to environment
[13:20:02.009] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.009] assign_globals() ... done
[13:20:02.009] plan(): Setting new future strategy stack:
[13:20:02.009] List of future strategies:
[13:20:02.009] 1. sequential:
[13:20:02.009]    - args: function (..., envir = parent.frame())
[13:20:02.009]    - tweaked: FALSE
[13:20:02.009]    - call: NULL
[13:20:02.010] plan(): nbrOfWorkers() = 1
[13:20:02.011] plan(): Setting new future strategy stack:
[13:20:02.011] List of future strategies:
[13:20:02.011] 1. multicore:
[13:20:02.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.011]    - tweaked: FALSE
[13:20:02.011]    - call: plan(strategy)
[13:20:02.015] plan(): nbrOfWorkers() = 1
[13:20:02.015] SequentialFuture started (and completed)
[13:20:02.015] - Launch lazy future ... done
[13:20:02.015] run() for ‘SequentialFuture’ ... done
[13:20:02.015] Created future:
[13:20:02.015] SequentialFuture:
[13:20:02.015] Label: ‘future_by-1’
[13:20:02.015] Expression:
[13:20:02.015] {
[13:20:02.015]     do.call(function(...) {
[13:20:02.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.015]             on.exit(options(oopts), add = TRUE)
[13:20:02.015]         }
[13:20:02.015]         {
[13:20:02.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.015]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.015]             })
[13:20:02.015]         }
[13:20:02.015]     }, args = future.call.arguments)
[13:20:02.015] }
[13:20:02.015] Lazy evaluation: FALSE
[13:20:02.015] Asynchronous evaluation: FALSE
[13:20:02.015] Local evaluation: TRUE
[13:20:02.015] Environment: R_GlobalEnv
[13:20:02.015] Capture standard output: TRUE
[13:20:02.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.015] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.015] Packages: <none>
[13:20:02.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.015] Resolved: TRUE
[13:20:02.015] Value: 5.48 KiB of class ‘list’
[13:20:02.015] Early signaling: FALSE
[13:20:02.015] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.015] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.017] Chunk #1 of 1 ... DONE
[13:20:02.017] Launching 1 futures (chunks) ... DONE
[13:20:02.017] Resolving 1 futures (chunks) ...
[13:20:02.017] resolve() on list ...
[13:20:02.017]  recursive: 0
[13:20:02.017]  length: 1
[13:20:02.017] 
[13:20:02.017] resolved() for ‘SequentialFuture’ ...
[13:20:02.017] - state: ‘finished’
[13:20:02.017] - run: TRUE
[13:20:02.018] - result: ‘FutureResult’
[13:20:02.018] resolved() for ‘SequentialFuture’ ... done
[13:20:02.018] Future #1
[13:20:02.018] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.018] - nx: 1
[13:20:02.018] - relay: TRUE
[13:20:02.018] - stdout: TRUE
[13:20:02.018] - signal: TRUE
[13:20:02.018] - resignal: FALSE
[13:20:02.018] - force: TRUE
[13:20:02.018] - relayed: [n=1] FALSE
[13:20:02.019] - queued futures: [n=1] FALSE
[13:20:02.019]  - until=1
[13:20:02.019]  - relaying element #1
[13:20:02.019] - relayed: [n=1] TRUE
[13:20:02.019] - queued futures: [n=1] TRUE
[13:20:02.019] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.019]  length: 0 (resolved future 1)
[13:20:02.019] Relaying remaining futures
[13:20:02.019] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.020] - nx: 1
[13:20:02.020] - relay: TRUE
[13:20:02.020] - stdout: TRUE
[13:20:02.020] - signal: TRUE
[13:20:02.020] - resignal: FALSE
[13:20:02.020] - force: TRUE
[13:20:02.020] - relayed: [n=1] TRUE
[13:20:02.020] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.020] - relayed: [n=1] TRUE
[13:20:02.020] - queued futures: [n=1] TRUE
[13:20:02.020] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.021] resolve() on list ... DONE
[13:20:02.021]  - Number of value chunks collected: 1
[13:20:02.021] Resolving 1 futures (chunks) ... DONE
[13:20:02.021] Reducing values from 1 chunks ...
[13:20:02.021]  - Number of values collected after concatenation: 6
[13:20:02.021]  - Number of values expected: 6
[13:20:02.021] Reducing values from 1 chunks ... DONE
[13:20:02.021] future_lapply() ... DONE
[13:20:02.021] future_by_internal() ... DONE
[13:20:02.053] future_by_internal() ...
[13:20:02.054] future_lapply() ...
[13:20:02.058] Number of chunks: 1
[13:20:02.058] getGlobalsAndPackagesXApply() ...
[13:20:02.058]  - future.globals: TRUE
[13:20:02.059] getGlobalsAndPackages() ...
[13:20:02.059] Searching for globals...
[13:20:02.060] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:02.061] Searching for globals ... DONE
[13:20:02.061] Resolving globals: FALSE
[13:20:02.061] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:20:02.061] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:20:02.062] - globals: [1] ‘FUN’
[13:20:02.062] - packages: [1] ‘stats’
[13:20:02.062] getGlobalsAndPackages() ... DONE
[13:20:02.062]  - globals found/used: [n=1] ‘FUN’
[13:20:02.062]  - needed namespaces: [n=1] ‘stats’
[13:20:02.062] Finding globals ... DONE
[13:20:02.062]  - use_args: TRUE
[13:20:02.062]  - Getting '...' globals ...
[13:20:02.063] resolve() on list ...
[13:20:02.063]  recursive: 0
[13:20:02.063]  length: 1
[13:20:02.063]  elements: ‘...’
[13:20:02.063]  length: 0 (resolved future 1)
[13:20:02.063] resolve() on list ... DONE
[13:20:02.063]    - '...' content: [n=1] ‘singular.ok’
[13:20:02.063] List of 1
[13:20:02.063]  $ ...:List of 1
[13:20:02.063]   ..$ singular.ok: logi FALSE
[13:20:02.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.063]  - attr(*, "where")=List of 1
[13:20:02.063]   ..$ ...:<environment: 0x55aceef65978> 
[13:20:02.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.063]  - attr(*, "resolved")= logi TRUE
[13:20:02.063]  - attr(*, "total_size")= num NA
[13:20:02.066]  - Getting '...' globals ... DONE
[13:20:02.067] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.067] List of 2
[13:20:02.067]  $ ...future.FUN:function (x, ...)  
[13:20:02.067]  $ ...          :List of 1
[13:20:02.067]   ..$ singular.ok: logi FALSE
[13:20:02.067]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.067]  - attr(*, "where")=List of 2
[13:20:02.067]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.067]   ..$ ...          :<environment: 0x55aceef65978> 
[13:20:02.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.067]  - attr(*, "resolved")= logi FALSE
[13:20:02.067]  - attr(*, "total_size")= num 5384
[13:20:02.070] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:02.070] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.070] Number of futures (= number of chunks): 1
[13:20:02.070] Launching 1 futures (chunks) ...
[13:20:02.070] Chunk #1 of 1 ...
[13:20:02.071]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.071] getGlobalsAndPackages() ...
[13:20:02.071] Searching for globals...
[13:20:02.071] 
[13:20:02.071] Searching for globals ... DONE
[13:20:02.071] - globals: [0] <none>
[13:20:02.071] getGlobalsAndPackages() ... DONE
[13:20:02.072]    + additional globals found: [n=0] 
[13:20:02.072]    + additional namespaces needed: [n=0] 
[13:20:02.072]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.072]  - seeds: <none>
[13:20:02.072]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.072] getGlobalsAndPackages() ...
[13:20:02.072] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.072] Resolving globals: FALSE
[13:20:02.072] Tweak future expression to call with '...' arguments ...
[13:20:02.072] {
[13:20:02.072]     do.call(function(...) {
[13:20:02.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.072]             on.exit(options(oopts), add = TRUE)
[13:20:02.072]         }
[13:20:02.072]         {
[13:20:02.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.072]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.072]             })
[13:20:02.072]         }
[13:20:02.072]     }, args = future.call.arguments)
[13:20:02.072] }
[13:20:02.073] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.073] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.073] 
[13:20:02.073] getGlobalsAndPackages() ... DONE
[13:20:02.074] run() for ‘Future’ ...
[13:20:02.074] - state: ‘created’
[13:20:02.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.078]   - Field: ‘label’
[13:20:02.078]   - Field: ‘local’
[13:20:02.078]   - Field: ‘owner’
[13:20:02.078]   - Field: ‘envir’
[13:20:02.078]   - Field: ‘packages’
[13:20:02.078]   - Field: ‘gc’
[13:20:02.079]   - Field: ‘conditions’
[13:20:02.079]   - Field: ‘expr’
[13:20:02.079]   - Field: ‘uuid’
[13:20:02.079]   - Field: ‘seed’
[13:20:02.079]   - Field: ‘version’
[13:20:02.079]   - Field: ‘result’
[13:20:02.079]   - Field: ‘asynchronous’
[13:20:02.079]   - Field: ‘calls’
[13:20:02.081]   - Field: ‘globals’
[13:20:02.081]   - Field: ‘stdout’
[13:20:02.081]   - Field: ‘earlySignal’
[13:20:02.081]   - Field: ‘lazy’
[13:20:02.081]   - Field: ‘state’
[13:20:02.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.082] - Launch lazy future ...
[13:20:02.082] Packages needed by the future expression (n = 1): ‘stats’
[13:20:02.082] Packages needed by future strategies (n = 0): <none>
[13:20:02.083] {
[13:20:02.083]     {
[13:20:02.083]         {
[13:20:02.083]             ...future.startTime <- base::Sys.time()
[13:20:02.083]             {
[13:20:02.083]                 {
[13:20:02.083]                   {
[13:20:02.083]                     {
[13:20:02.083]                       base::local({
[13:20:02.083]                         has_future <- base::requireNamespace("future", 
[13:20:02.083]                           quietly = TRUE)
[13:20:02.083]                         if (has_future) {
[13:20:02.083]                           ns <- base::getNamespace("future")
[13:20:02.083]                           version <- ns[[".package"]][["version"]]
[13:20:02.083]                           if (is.null(version)) 
[13:20:02.083]                             version <- utils::packageVersion("future")
[13:20:02.083]                         }
[13:20:02.083]                         else {
[13:20:02.083]                           version <- NULL
[13:20:02.083]                         }
[13:20:02.083]                         if (!has_future || version < "1.8.0") {
[13:20:02.083]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.083]                             "", base::R.version$version.string), 
[13:20:02.083]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.083]                               "release", "version")], collapse = " "), 
[13:20:02.083]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.083]                             info)
[13:20:02.083]                           info <- base::paste(info, collapse = "; ")
[13:20:02.083]                           if (!has_future) {
[13:20:02.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.083]                               info)
[13:20:02.083]                           }
[13:20:02.083]                           else {
[13:20:02.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.083]                               info, version)
[13:20:02.083]                           }
[13:20:02.083]                           base::stop(msg)
[13:20:02.083]                         }
[13:20:02.083]                       })
[13:20:02.083]                     }
[13:20:02.083]                     base::local({
[13:20:02.083]                       for (pkg in "stats") {
[13:20:02.083]                         base::loadNamespace(pkg)
[13:20:02.083]                         base::library(pkg, character.only = TRUE)
[13:20:02.083]                       }
[13:20:02.083]                     })
[13:20:02.083]                   }
[13:20:02.083]                   options(future.plan = NULL)
[13:20:02.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.083]                 }
[13:20:02.083]                 ...future.workdir <- getwd()
[13:20:02.083]             }
[13:20:02.083]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.083]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.083]         }
[13:20:02.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.083]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.083]             base::names(...future.oldOptions))
[13:20:02.083]     }
[13:20:02.083]     if (FALSE) {
[13:20:02.083]     }
[13:20:02.083]     else {
[13:20:02.083]         if (TRUE) {
[13:20:02.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.083]                 open = "w")
[13:20:02.083]         }
[13:20:02.083]         else {
[13:20:02.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.083]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.083]         }
[13:20:02.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.083]             base::sink(type = "output", split = FALSE)
[13:20:02.083]             base::close(...future.stdout)
[13:20:02.083]         }, add = TRUE)
[13:20:02.083]     }
[13:20:02.083]     ...future.frame <- base::sys.nframe()
[13:20:02.083]     ...future.conditions <- base::list()
[13:20:02.083]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.083]     if (FALSE) {
[13:20:02.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.083]     }
[13:20:02.083]     ...future.result <- base::tryCatch({
[13:20:02.083]         base::withCallingHandlers({
[13:20:02.083]             ...future.value <- base::withVisible(base::local({
[13:20:02.083]                 do.call(function(...) {
[13:20:02.083]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.083]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.083]                     ...future.globals.maxSize)) {
[13:20:02.083]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.083]                     on.exit(options(oopts), add = TRUE)
[13:20:02.083]                   }
[13:20:02.083]                   {
[13:20:02.083]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.083]                       FUN = function(jj) {
[13:20:02.083]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.083]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.083]                       })
[13:20:02.083]                   }
[13:20:02.083]                 }, args = future.call.arguments)
[13:20:02.083]             }))
[13:20:02.083]             future::FutureResult(value = ...future.value$value, 
[13:20:02.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.083]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.083]                     ...future.globalenv.names))
[13:20:02.083]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.083]         }, condition = base::local({
[13:20:02.083]             c <- base::c
[13:20:02.083]             inherits <- base::inherits
[13:20:02.083]             invokeRestart <- base::invokeRestart
[13:20:02.083]             length <- base::length
[13:20:02.083]             list <- base::list
[13:20:02.083]             seq.int <- base::seq.int
[13:20:02.083]             signalCondition <- base::signalCondition
[13:20:02.083]             sys.calls <- base::sys.calls
[13:20:02.083]             `[[` <- base::`[[`
[13:20:02.083]             `+` <- base::`+`
[13:20:02.083]             `<<-` <- base::`<<-`
[13:20:02.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.083]                   3L)]
[13:20:02.083]             }
[13:20:02.083]             function(cond) {
[13:20:02.083]                 is_error <- inherits(cond, "error")
[13:20:02.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.083]                   NULL)
[13:20:02.083]                 if (is_error) {
[13:20:02.083]                   sessionInformation <- function() {
[13:20:02.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.083]                       search = base::search(), system = base::Sys.info())
[13:20:02.083]                   }
[13:20:02.083]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.083]                     cond$call), session = sessionInformation(), 
[13:20:02.083]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.083]                   signalCondition(cond)
[13:20:02.083]                 }
[13:20:02.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.083]                 "immediateCondition"))) {
[13:20:02.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.083]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.083]                   if (TRUE && !signal) {
[13:20:02.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.083]                     {
[13:20:02.083]                       inherits <- base::inherits
[13:20:02.083]                       invokeRestart <- base::invokeRestart
[13:20:02.083]                       is.null <- base::is.null
[13:20:02.083]                       muffled <- FALSE
[13:20:02.083]                       if (inherits(cond, "message")) {
[13:20:02.083]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.083]                         if (muffled) 
[13:20:02.083]                           invokeRestart("muffleMessage")
[13:20:02.083]                       }
[13:20:02.083]                       else if (inherits(cond, "warning")) {
[13:20:02.083]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.083]                         if (muffled) 
[13:20:02.083]                           invokeRestart("muffleWarning")
[13:20:02.083]                       }
[13:20:02.083]                       else if (inherits(cond, "condition")) {
[13:20:02.083]                         if (!is.null(pattern)) {
[13:20:02.083]                           computeRestarts <- base::computeRestarts
[13:20:02.083]                           grepl <- base::grepl
[13:20:02.083]                           restarts <- computeRestarts(cond)
[13:20:02.083]                           for (restart in restarts) {
[13:20:02.083]                             name <- restart$name
[13:20:02.083]                             if (is.null(name)) 
[13:20:02.083]                               next
[13:20:02.083]                             if (!grepl(pattern, name)) 
[13:20:02.083]                               next
[13:20:02.083]                             invokeRestart(restart)
[13:20:02.083]                             muffled <- TRUE
[13:20:02.083]                             break
[13:20:02.083]                           }
[13:20:02.083]                         }
[13:20:02.083]                       }
[13:20:02.083]                       invisible(muffled)
[13:20:02.083]                     }
[13:20:02.083]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.083]                   }
[13:20:02.083]                 }
[13:20:02.083]                 else {
[13:20:02.083]                   if (TRUE) {
[13:20:02.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.083]                     {
[13:20:02.083]                       inherits <- base::inherits
[13:20:02.083]                       invokeRestart <- base::invokeRestart
[13:20:02.083]                       is.null <- base::is.null
[13:20:02.083]                       muffled <- FALSE
[13:20:02.083]                       if (inherits(cond, "message")) {
[13:20:02.083]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.083]                         if (muffled) 
[13:20:02.083]                           invokeRestart("muffleMessage")
[13:20:02.083]                       }
[13:20:02.083]                       else if (inherits(cond, "warning")) {
[13:20:02.083]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.083]                         if (muffled) 
[13:20:02.083]                           invokeRestart("muffleWarning")
[13:20:02.083]                       }
[13:20:02.083]                       else if (inherits(cond, "condition")) {
[13:20:02.083]                         if (!is.null(pattern)) {
[13:20:02.083]                           computeRestarts <- base::computeRestarts
[13:20:02.083]                           grepl <- base::grepl
[13:20:02.083]                           restarts <- computeRestarts(cond)
[13:20:02.083]                           for (restart in restarts) {
[13:20:02.083]                             name <- restart$name
[13:20:02.083]                             if (is.null(name)) 
[13:20:02.083]                               next
[13:20:02.083]                             if (!grepl(pattern, name)) 
[13:20:02.083]                               next
[13:20:02.083]                             invokeRestart(restart)
[13:20:02.083]                             muffled <- TRUE
[13:20:02.083]                             break
[13:20:02.083]                           }
[13:20:02.083]                         }
[13:20:02.083]                       }
[13:20:02.083]                       invisible(muffled)
[13:20:02.083]                     }
[13:20:02.083]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.083]                   }
[13:20:02.083]                 }
[13:20:02.083]             }
[13:20:02.083]         }))
[13:20:02.083]     }, error = function(ex) {
[13:20:02.083]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.083]                 ...future.rng), started = ...future.startTime, 
[13:20:02.083]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.083]             version = "1.8"), class = "FutureResult")
[13:20:02.083]     }, finally = {
[13:20:02.083]         if (!identical(...future.workdir, getwd())) 
[13:20:02.083]             setwd(...future.workdir)
[13:20:02.083]         {
[13:20:02.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.083]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.083]             }
[13:20:02.083]             base::options(...future.oldOptions)
[13:20:02.083]             if (.Platform$OS.type == "windows") {
[13:20:02.083]                 old_names <- names(...future.oldEnvVars)
[13:20:02.083]                 envs <- base::Sys.getenv()
[13:20:02.083]                 names <- names(envs)
[13:20:02.083]                 common <- intersect(names, old_names)
[13:20:02.083]                 added <- setdiff(names, old_names)
[13:20:02.083]                 removed <- setdiff(old_names, names)
[13:20:02.083]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.083]                   envs[common]]
[13:20:02.083]                 NAMES <- toupper(changed)
[13:20:02.083]                 args <- list()
[13:20:02.083]                 for (kk in seq_along(NAMES)) {
[13:20:02.083]                   name <- changed[[kk]]
[13:20:02.083]                   NAME <- NAMES[[kk]]
[13:20:02.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.083]                     next
[13:20:02.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.083]                 }
[13:20:02.083]                 NAMES <- toupper(added)
[13:20:02.083]                 for (kk in seq_along(NAMES)) {
[13:20:02.083]                   name <- added[[kk]]
[13:20:02.083]                   NAME <- NAMES[[kk]]
[13:20:02.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.083]                     next
[13:20:02.083]                   args[[name]] <- ""
[13:20:02.083]                 }
[13:20:02.083]                 NAMES <- toupper(removed)
[13:20:02.083]                 for (kk in seq_along(NAMES)) {
[13:20:02.083]                   name <- removed[[kk]]
[13:20:02.083]                   NAME <- NAMES[[kk]]
[13:20:02.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.083]                     next
[13:20:02.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.083]                 }
[13:20:02.083]                 if (length(args) > 0) 
[13:20:02.083]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.083]             }
[13:20:02.083]             else {
[13:20:02.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.083]             }
[13:20:02.083]             {
[13:20:02.083]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.083]                   0L) {
[13:20:02.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.083]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.083]                   base::options(opts)
[13:20:02.083]                 }
[13:20:02.083]                 {
[13:20:02.083]                   {
[13:20:02.083]                     NULL
[13:20:02.083]                     RNGkind("Mersenne-Twister")
[13:20:02.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.083]                       inherits = FALSE)
[13:20:02.083]                   }
[13:20:02.083]                   options(future.plan = NULL)
[13:20:02.083]                   if (is.na(NA_character_)) 
[13:20:02.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.083]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:02.083]                     envir = parent.frame()) 
[13:20:02.083]                   {
[13:20:02.083]                     default_workers <- missing(workers)
[13:20:02.083]                     if (is.function(workers)) 
[13:20:02.083]                       workers <- workers()
[13:20:02.083]                     workers <- structure(as.integer(workers), 
[13:20:02.083]                       class = class(workers))
[13:20:02.083]                     stop_if_not(is.finite(workers), workers >= 
[13:20:02.083]                       1L)
[13:20:02.083]                     if ((workers == 1L && !inherits(workers, 
[13:20:02.083]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:02.083]                       if (default_workers) 
[13:20:02.083]                         supportsMulticore(warn = TRUE)
[13:20:02.083]                       return(sequential(..., envir = envir))
[13:20:02.083]                     }
[13:20:02.083]                     oopts <- options(mc.cores = workers)
[13:20:02.083]                     on.exit(options(oopts))
[13:20:02.083]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:02.083]                       envir = envir)
[13:20:02.083]                     if (!future$lazy) 
[13:20:02.083]                       future <- run(future)
[13:20:02.083]                     invisible(future)
[13:20:02.083]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.083]                 }
[13:20:02.083]             }
[13:20:02.083]         }
[13:20:02.083]     })
[13:20:02.083]     if (TRUE) {
[13:20:02.083]         base::sink(type = "output", split = FALSE)
[13:20:02.083]         if (TRUE) {
[13:20:02.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.083]         }
[13:20:02.083]         else {
[13:20:02.083]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.083]         }
[13:20:02.083]         base::close(...future.stdout)
[13:20:02.083]         ...future.stdout <- NULL
[13:20:02.083]     }
[13:20:02.083]     ...future.result$conditions <- ...future.conditions
[13:20:02.083]     ...future.result$finished <- base::Sys.time()
[13:20:02.083]     ...future.result
[13:20:02.083] }
[13:20:02.085] assign_globals() ...
[13:20:02.085] List of 5
[13:20:02.085]  $ ...future.FUN            :function (x, ...)  
[13:20:02.085]  $ future.call.arguments    :List of 1
[13:20:02.085]   ..$ singular.ok: logi FALSE
[13:20:02.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.085]  $ ...future.elements_ii    :List of 3
[13:20:02.085]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.085]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.085]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.085]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.085]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.085]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.085]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.085]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.085]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.085]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.085]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.085]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.085]  $ ...future.seeds_ii       : NULL
[13:20:02.085]  $ ...future.globals.maxSize: NULL
[13:20:02.085]  - attr(*, "where")=List of 5
[13:20:02.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.085]  - attr(*, "resolved")= logi FALSE
[13:20:02.085]  - attr(*, "total_size")= num 5384
[13:20:02.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.085]  - attr(*, "already-done")= logi TRUE
[13:20:02.094] - reassign environment for ‘...future.FUN’
[13:20:02.094] - copied ‘...future.FUN’ to environment
[13:20:02.095] - copied ‘future.call.arguments’ to environment
[13:20:02.095] - copied ‘...future.elements_ii’ to environment
[13:20:02.095] - copied ‘...future.seeds_ii’ to environment
[13:20:02.095] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.095] assign_globals() ... done
[13:20:02.095] plan(): Setting new future strategy stack:
[13:20:02.095] List of future strategies:
[13:20:02.095] 1. sequential:
[13:20:02.095]    - args: function (..., envir = parent.frame())
[13:20:02.095]    - tweaked: FALSE
[13:20:02.095]    - call: NULL
[13:20:02.096] plan(): nbrOfWorkers() = 1
[13:20:02.099] plan(): Setting new future strategy stack:
[13:20:02.099] List of future strategies:
[13:20:02.099] 1. multicore:
[13:20:02.099]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.099]    - tweaked: FALSE
[13:20:02.099]    - call: plan(strategy)
[13:20:02.102] plan(): nbrOfWorkers() = 1
[13:20:02.103] SequentialFuture started (and completed)
[13:20:02.103] - Launch lazy future ... done
[13:20:02.103] run() for ‘SequentialFuture’ ... done
[13:20:02.103] Created future:
[13:20:02.103] SequentialFuture:
[13:20:02.103] Label: ‘future_by-1’
[13:20:02.103] Expression:
[13:20:02.103] {
[13:20:02.103]     do.call(function(...) {
[13:20:02.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.103]             on.exit(options(oopts), add = TRUE)
[13:20:02.103]         }
[13:20:02.103]         {
[13:20:02.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.103]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.103]             })
[13:20:02.103]         }
[13:20:02.103]     }, args = future.call.arguments)
[13:20:02.103] }
[13:20:02.103] Lazy evaluation: FALSE
[13:20:02.103] Asynchronous evaluation: FALSE
[13:20:02.103] Local evaluation: TRUE
[13:20:02.103] Environment: R_GlobalEnv
[13:20:02.103] Capture standard output: TRUE
[13:20:02.103] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.103] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.103] Packages: 1 packages (‘stats’)
[13:20:02.103] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.103] Resolved: TRUE
[13:20:02.103] Value: 26.06 KiB of class ‘list’
[13:20:02.103] Early signaling: FALSE
[13:20:02.103] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.103] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.105] Chunk #1 of 1 ... DONE
[13:20:02.105] Launching 1 futures (chunks) ... DONE
[13:20:02.105] Resolving 1 futures (chunks) ...
[13:20:02.105] resolve() on list ...
[13:20:02.105]  recursive: 0
[13:20:02.105]  length: 1
[13:20:02.105] 
[13:20:02.105] resolved() for ‘SequentialFuture’ ...
[13:20:02.105] - state: ‘finished’
[13:20:02.105] - run: TRUE
[13:20:02.106] - result: ‘FutureResult’
[13:20:02.106] resolved() for ‘SequentialFuture’ ... done
[13:20:02.106] Future #1
[13:20:02.106] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.106] - nx: 1
[13:20:02.106] - relay: TRUE
[13:20:02.106] - stdout: TRUE
[13:20:02.106] - signal: TRUE
[13:20:02.106] - resignal: FALSE
[13:20:02.106] - force: TRUE
[13:20:02.107] - relayed: [n=1] FALSE
[13:20:02.107] - queued futures: [n=1] FALSE
[13:20:02.108]  - until=1
[13:20:02.108]  - relaying element #1
[13:20:02.109] - relayed: [n=1] TRUE
[13:20:02.109] - queued futures: [n=1] TRUE
[13:20:02.109] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.109]  length: 0 (resolved future 1)
[13:20:02.109] Relaying remaining futures
[13:20:02.109] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.109] - nx: 1
[13:20:02.109] - relay: TRUE
[13:20:02.110] - stdout: TRUE
[13:20:02.110] - signal: TRUE
[13:20:02.110] - resignal: FALSE
[13:20:02.110] - force: TRUE
[13:20:02.110] - relayed: [n=1] TRUE
[13:20:02.110] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.110] - relayed: [n=1] TRUE
[13:20:02.110] - queued futures: [n=1] TRUE
[13:20:02.110] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.111] resolve() on list ... DONE
[13:20:02.111]  - Number of value chunks collected: 1
[13:20:02.111] Resolving 1 futures (chunks) ... DONE
[13:20:02.111] Reducing values from 1 chunks ...
[13:20:02.111]  - Number of values collected after concatenation: 3
[13:20:02.111]  - Number of values expected: 3
[13:20:02.111] Reducing values from 1 chunks ... DONE
[13:20:02.111] future_lapply() ... DONE
[13:20:02.111] future_by_internal() ... DONE
[13:20:02.116] future_by_internal() ...
[13:20:02.116] future_lapply() ...
[13:20:02.120] Number of chunks: 1
[13:20:02.120] getGlobalsAndPackagesXApply() ...
[13:20:02.120]  - future.globals: TRUE
[13:20:02.121] getGlobalsAndPackages() ...
[13:20:02.121] Searching for globals...
[13:20:02.122] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:02.123] Searching for globals ... DONE
[13:20:02.123] Resolving globals: FALSE
[13:20:02.123] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:20:02.124] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:20:02.124] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:02.124] - packages: [1] ‘stats’
[13:20:02.124] getGlobalsAndPackages() ... DONE
[13:20:02.124]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:02.124]  - needed namespaces: [n=1] ‘stats’
[13:20:02.124] Finding globals ... DONE
[13:20:02.124]  - use_args: TRUE
[13:20:02.124]  - Getting '...' globals ...
[13:20:02.125] resolve() on list ...
[13:20:02.125]  recursive: 0
[13:20:02.125]  length: 1
[13:20:02.125]  elements: ‘...’
[13:20:02.125]  length: 0 (resolved future 1)
[13:20:02.125] resolve() on list ... DONE
[13:20:02.125]    - '...' content: [n=0] 
[13:20:02.125] List of 1
[13:20:02.125]  $ ...: list()
[13:20:02.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.125]  - attr(*, "where")=List of 1
[13:20:02.125]   ..$ ...:<environment: 0x55acece7e5b8> 
[13:20:02.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.125]  - attr(*, "resolved")= logi TRUE
[13:20:02.125]  - attr(*, "total_size")= num NA
[13:20:02.128]  - Getting '...' globals ... DONE
[13:20:02.128] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:20:02.128] List of 4
[13:20:02.128]  $ ...future.FUN:function (x)  
[13:20:02.128]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:02.128]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.128]  $ ...          : list()
[13:20:02.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.128]  - attr(*, "where")=List of 4
[13:20:02.128]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.128]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:20:02.128]   ..$ wool         :<environment: R_EmptyEnv> 
[13:20:02.128]   ..$ ...          :<environment: 0x55acece7e5b8> 
[13:20:02.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.128]  - attr(*, "resolved")= logi FALSE
[13:20:02.128]  - attr(*, "total_size")= num 2320
[13:20:02.135] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:02.135] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.135] Number of futures (= number of chunks): 1
[13:20:02.135] Launching 1 futures (chunks) ...
[13:20:02.135] Chunk #1 of 1 ...
[13:20:02.135]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.135] getGlobalsAndPackages() ...
[13:20:02.135] Searching for globals...
[13:20:02.136] 
[13:20:02.136] Searching for globals ... DONE
[13:20:02.136] - globals: [0] <none>
[13:20:02.136] getGlobalsAndPackages() ... DONE
[13:20:02.136]    + additional globals found: [n=0] 
[13:20:02.136]    + additional namespaces needed: [n=0] 
[13:20:02.137]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.137]  - seeds: <none>
[13:20:02.137]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.137] getGlobalsAndPackages() ...
[13:20:02.137] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.137] Resolving globals: FALSE
[13:20:02.137] Tweak future expression to call with '...' arguments ...
[13:20:02.137] {
[13:20:02.137]     do.call(function(...) {
[13:20:02.137]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.137]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.137]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.137]             on.exit(options(oopts), add = TRUE)
[13:20:02.137]         }
[13:20:02.137]         {
[13:20:02.137]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.137]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.137]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.137]             })
[13:20:02.137]         }
[13:20:02.137]     }, args = future.call.arguments)
[13:20:02.137] }
[13:20:02.138] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.138] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.138] 
[13:20:02.138] getGlobalsAndPackages() ... DONE
[13:20:02.139] run() for ‘Future’ ...
[13:20:02.139] - state: ‘created’
[13:20:02.139] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.143] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.143]   - Field: ‘label’
[13:20:02.143]   - Field: ‘local’
[13:20:02.143]   - Field: ‘owner’
[13:20:02.143]   - Field: ‘envir’
[13:20:02.143]   - Field: ‘packages’
[13:20:02.143]   - Field: ‘gc’
[13:20:02.143]   - Field: ‘conditions’
[13:20:02.144]   - Field: ‘expr’
[13:20:02.144]   - Field: ‘uuid’
[13:20:02.144]   - Field: ‘seed’
[13:20:02.144]   - Field: ‘version’
[13:20:02.144]   - Field: ‘result’
[13:20:02.144]   - Field: ‘asynchronous’
[13:20:02.144]   - Field: ‘calls’
[13:20:02.144]   - Field: ‘globals’
[13:20:02.144]   - Field: ‘stdout’
[13:20:02.144]   - Field: ‘earlySignal’
[13:20:02.145]   - Field: ‘lazy’
[13:20:02.145]   - Field: ‘state’
[13:20:02.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.145] - Launch lazy future ...
[13:20:02.145] Packages needed by the future expression (n = 1): ‘stats’
[13:20:02.145] Packages needed by future strategies (n = 0): <none>
[13:20:02.146] {
[13:20:02.146]     {
[13:20:02.146]         {
[13:20:02.146]             ...future.startTime <- base::Sys.time()
[13:20:02.146]             {
[13:20:02.146]                 {
[13:20:02.146]                   {
[13:20:02.146]                     {
[13:20:02.146]                       base::local({
[13:20:02.146]                         has_future <- base::requireNamespace("future", 
[13:20:02.146]                           quietly = TRUE)
[13:20:02.146]                         if (has_future) {
[13:20:02.146]                           ns <- base::getNamespace("future")
[13:20:02.146]                           version <- ns[[".package"]][["version"]]
[13:20:02.146]                           if (is.null(version)) 
[13:20:02.146]                             version <- utils::packageVersion("future")
[13:20:02.146]                         }
[13:20:02.146]                         else {
[13:20:02.146]                           version <- NULL
[13:20:02.146]                         }
[13:20:02.146]                         if (!has_future || version < "1.8.0") {
[13:20:02.146]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.146]                             "", base::R.version$version.string), 
[13:20:02.146]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.146]                               "release", "version")], collapse = " "), 
[13:20:02.146]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.146]                             info)
[13:20:02.146]                           info <- base::paste(info, collapse = "; ")
[13:20:02.146]                           if (!has_future) {
[13:20:02.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.146]                               info)
[13:20:02.146]                           }
[13:20:02.146]                           else {
[13:20:02.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.146]                               info, version)
[13:20:02.146]                           }
[13:20:02.146]                           base::stop(msg)
[13:20:02.146]                         }
[13:20:02.146]                       })
[13:20:02.146]                     }
[13:20:02.146]                     base::local({
[13:20:02.146]                       for (pkg in "stats") {
[13:20:02.146]                         base::loadNamespace(pkg)
[13:20:02.146]                         base::library(pkg, character.only = TRUE)
[13:20:02.146]                       }
[13:20:02.146]                     })
[13:20:02.146]                   }
[13:20:02.146]                   options(future.plan = NULL)
[13:20:02.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.146]                 }
[13:20:02.146]                 ...future.workdir <- getwd()
[13:20:02.146]             }
[13:20:02.146]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.146]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.146]         }
[13:20:02.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.146]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.146]             base::names(...future.oldOptions))
[13:20:02.146]     }
[13:20:02.146]     if (FALSE) {
[13:20:02.146]     }
[13:20:02.146]     else {
[13:20:02.146]         if (TRUE) {
[13:20:02.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.146]                 open = "w")
[13:20:02.146]         }
[13:20:02.146]         else {
[13:20:02.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.146]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.146]         }
[13:20:02.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.146]             base::sink(type = "output", split = FALSE)
[13:20:02.146]             base::close(...future.stdout)
[13:20:02.146]         }, add = TRUE)
[13:20:02.146]     }
[13:20:02.146]     ...future.frame <- base::sys.nframe()
[13:20:02.146]     ...future.conditions <- base::list()
[13:20:02.146]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.146]     if (FALSE) {
[13:20:02.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.146]     }
[13:20:02.146]     ...future.result <- base::tryCatch({
[13:20:02.146]         base::withCallingHandlers({
[13:20:02.146]             ...future.value <- base::withVisible(base::local({
[13:20:02.146]                 do.call(function(...) {
[13:20:02.146]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.146]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.146]                     ...future.globals.maxSize)) {
[13:20:02.146]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.146]                     on.exit(options(oopts), add = TRUE)
[13:20:02.146]                   }
[13:20:02.146]                   {
[13:20:02.146]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.146]                       FUN = function(jj) {
[13:20:02.146]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.146]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.146]                       })
[13:20:02.146]                   }
[13:20:02.146]                 }, args = future.call.arguments)
[13:20:02.146]             }))
[13:20:02.146]             future::FutureResult(value = ...future.value$value, 
[13:20:02.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.146]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.146]                     ...future.globalenv.names))
[13:20:02.146]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.146]         }, condition = base::local({
[13:20:02.146]             c <- base::c
[13:20:02.146]             inherits <- base::inherits
[13:20:02.146]             invokeRestart <- base::invokeRestart
[13:20:02.146]             length <- base::length
[13:20:02.146]             list <- base::list
[13:20:02.146]             seq.int <- base::seq.int
[13:20:02.146]             signalCondition <- base::signalCondition
[13:20:02.146]             sys.calls <- base::sys.calls
[13:20:02.146]             `[[` <- base::`[[`
[13:20:02.146]             `+` <- base::`+`
[13:20:02.146]             `<<-` <- base::`<<-`
[13:20:02.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.146]                   3L)]
[13:20:02.146]             }
[13:20:02.146]             function(cond) {
[13:20:02.146]                 is_error <- inherits(cond, "error")
[13:20:02.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.146]                   NULL)
[13:20:02.146]                 if (is_error) {
[13:20:02.146]                   sessionInformation <- function() {
[13:20:02.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.146]                       search = base::search(), system = base::Sys.info())
[13:20:02.146]                   }
[13:20:02.146]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.146]                     cond$call), session = sessionInformation(), 
[13:20:02.146]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.146]                   signalCondition(cond)
[13:20:02.146]                 }
[13:20:02.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.146]                 "immediateCondition"))) {
[13:20:02.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.146]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.146]                   if (TRUE && !signal) {
[13:20:02.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.146]                     {
[13:20:02.146]                       inherits <- base::inherits
[13:20:02.146]                       invokeRestart <- base::invokeRestart
[13:20:02.146]                       is.null <- base::is.null
[13:20:02.146]                       muffled <- FALSE
[13:20:02.146]                       if (inherits(cond, "message")) {
[13:20:02.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.146]                         if (muffled) 
[13:20:02.146]                           invokeRestart("muffleMessage")
[13:20:02.146]                       }
[13:20:02.146]                       else if (inherits(cond, "warning")) {
[13:20:02.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.146]                         if (muffled) 
[13:20:02.146]                           invokeRestart("muffleWarning")
[13:20:02.146]                       }
[13:20:02.146]                       else if (inherits(cond, "condition")) {
[13:20:02.146]                         if (!is.null(pattern)) {
[13:20:02.146]                           computeRestarts <- base::computeRestarts
[13:20:02.146]                           grepl <- base::grepl
[13:20:02.146]                           restarts <- computeRestarts(cond)
[13:20:02.146]                           for (restart in restarts) {
[13:20:02.146]                             name <- restart$name
[13:20:02.146]                             if (is.null(name)) 
[13:20:02.146]                               next
[13:20:02.146]                             if (!grepl(pattern, name)) 
[13:20:02.146]                               next
[13:20:02.146]                             invokeRestart(restart)
[13:20:02.146]                             muffled <- TRUE
[13:20:02.146]                             break
[13:20:02.146]                           }
[13:20:02.146]                         }
[13:20:02.146]                       }
[13:20:02.146]                       invisible(muffled)
[13:20:02.146]                     }
[13:20:02.146]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.146]                   }
[13:20:02.146]                 }
[13:20:02.146]                 else {
[13:20:02.146]                   if (TRUE) {
[13:20:02.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.146]                     {
[13:20:02.146]                       inherits <- base::inherits
[13:20:02.146]                       invokeRestart <- base::invokeRestart
[13:20:02.146]                       is.null <- base::is.null
[13:20:02.146]                       muffled <- FALSE
[13:20:02.146]                       if (inherits(cond, "message")) {
[13:20:02.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.146]                         if (muffled) 
[13:20:02.146]                           invokeRestart("muffleMessage")
[13:20:02.146]                       }
[13:20:02.146]                       else if (inherits(cond, "warning")) {
[13:20:02.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.146]                         if (muffled) 
[13:20:02.146]                           invokeRestart("muffleWarning")
[13:20:02.146]                       }
[13:20:02.146]                       else if (inherits(cond, "condition")) {
[13:20:02.146]                         if (!is.null(pattern)) {
[13:20:02.146]                           computeRestarts <- base::computeRestarts
[13:20:02.146]                           grepl <- base::grepl
[13:20:02.146]                           restarts <- computeRestarts(cond)
[13:20:02.146]                           for (restart in restarts) {
[13:20:02.146]                             name <- restart$name
[13:20:02.146]                             if (is.null(name)) 
[13:20:02.146]                               next
[13:20:02.146]                             if (!grepl(pattern, name)) 
[13:20:02.146]                               next
[13:20:02.146]                             invokeRestart(restart)
[13:20:02.146]                             muffled <- TRUE
[13:20:02.146]                             break
[13:20:02.146]                           }
[13:20:02.146]                         }
[13:20:02.146]                       }
[13:20:02.146]                       invisible(muffled)
[13:20:02.146]                     }
[13:20:02.146]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.146]                   }
[13:20:02.146]                 }
[13:20:02.146]             }
[13:20:02.146]         }))
[13:20:02.146]     }, error = function(ex) {
[13:20:02.146]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.146]                 ...future.rng), started = ...future.startTime, 
[13:20:02.146]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.146]             version = "1.8"), class = "FutureResult")
[13:20:02.146]     }, finally = {
[13:20:02.146]         if (!identical(...future.workdir, getwd())) 
[13:20:02.146]             setwd(...future.workdir)
[13:20:02.146]         {
[13:20:02.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.146]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.146]             }
[13:20:02.146]             base::options(...future.oldOptions)
[13:20:02.146]             if (.Platform$OS.type == "windows") {
[13:20:02.146]                 old_names <- names(...future.oldEnvVars)
[13:20:02.146]                 envs <- base::Sys.getenv()
[13:20:02.146]                 names <- names(envs)
[13:20:02.146]                 common <- intersect(names, old_names)
[13:20:02.146]                 added <- setdiff(names, old_names)
[13:20:02.146]                 removed <- setdiff(old_names, names)
[13:20:02.146]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.146]                   envs[common]]
[13:20:02.146]                 NAMES <- toupper(changed)
[13:20:02.146]                 args <- list()
[13:20:02.146]                 for (kk in seq_along(NAMES)) {
[13:20:02.146]                   name <- changed[[kk]]
[13:20:02.146]                   NAME <- NAMES[[kk]]
[13:20:02.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.146]                     next
[13:20:02.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.146]                 }
[13:20:02.146]                 NAMES <- toupper(added)
[13:20:02.146]                 for (kk in seq_along(NAMES)) {
[13:20:02.146]                   name <- added[[kk]]
[13:20:02.146]                   NAME <- NAMES[[kk]]
[13:20:02.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.146]                     next
[13:20:02.146]                   args[[name]] <- ""
[13:20:02.146]                 }
[13:20:02.146]                 NAMES <- toupper(removed)
[13:20:02.146]                 for (kk in seq_along(NAMES)) {
[13:20:02.146]                   name <- removed[[kk]]
[13:20:02.146]                   NAME <- NAMES[[kk]]
[13:20:02.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.146]                     next
[13:20:02.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.146]                 }
[13:20:02.146]                 if (length(args) > 0) 
[13:20:02.146]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.146]             }
[13:20:02.146]             else {
[13:20:02.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.146]             }
[13:20:02.146]             {
[13:20:02.146]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.146]                   0L) {
[13:20:02.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.146]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.146]                   base::options(opts)
[13:20:02.146]                 }
[13:20:02.146]                 {
[13:20:02.146]                   {
[13:20:02.146]                     NULL
[13:20:02.146]                     RNGkind("Mersenne-Twister")
[13:20:02.146]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.146]                       inherits = FALSE)
[13:20:02.146]                   }
[13:20:02.146]                   options(future.plan = NULL)
[13:20:02.146]                   if (is.na(NA_character_)) 
[13:20:02.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.146]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:02.146]                     envir = parent.frame()) 
[13:20:02.146]                   {
[13:20:02.146]                     default_workers <- missing(workers)
[13:20:02.146]                     if (is.function(workers)) 
[13:20:02.146]                       workers <- workers()
[13:20:02.146]                     workers <- structure(as.integer(workers), 
[13:20:02.146]                       class = class(workers))
[13:20:02.146]                     stop_if_not(is.finite(workers), workers >= 
[13:20:02.146]                       1L)
[13:20:02.146]                     if ((workers == 1L && !inherits(workers, 
[13:20:02.146]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:02.146]                       if (default_workers) 
[13:20:02.146]                         supportsMulticore(warn = TRUE)
[13:20:02.146]                       return(sequential(..., envir = envir))
[13:20:02.146]                     }
[13:20:02.146]                     oopts <- options(mc.cores = workers)
[13:20:02.146]                     on.exit(options(oopts))
[13:20:02.146]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:02.146]                       envir = envir)
[13:20:02.146]                     if (!future$lazy) 
[13:20:02.146]                       future <- run(future)
[13:20:02.146]                     invisible(future)
[13:20:02.146]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.146]                 }
[13:20:02.146]             }
[13:20:02.146]         }
[13:20:02.146]     })
[13:20:02.146]     if (TRUE) {
[13:20:02.146]         base::sink(type = "output", split = FALSE)
[13:20:02.146]         if (TRUE) {
[13:20:02.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.146]         }
[13:20:02.146]         else {
[13:20:02.146]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.146]         }
[13:20:02.146]         base::close(...future.stdout)
[13:20:02.146]         ...future.stdout <- NULL
[13:20:02.146]     }
[13:20:02.146]     ...future.result$conditions <- ...future.conditions
[13:20:02.146]     ...future.result$finished <- base::Sys.time()
[13:20:02.146]     ...future.result
[13:20:02.146] }
[13:20:02.148] assign_globals() ...
[13:20:02.148] List of 7
[13:20:02.148]  $ ...future.FUN            :function (x)  
[13:20:02.148]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:02.148]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.148]  $ future.call.arguments    : list()
[13:20:02.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.148]  $ ...future.elements_ii    :List of 3
[13:20:02.148]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.148]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.148]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.148]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.148]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.148]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.148]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.148]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.148]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.148]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.148]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.148]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.148]  $ ...future.seeds_ii       : NULL
[13:20:02.148]  $ ...future.globals.maxSize: NULL
[13:20:02.148]  - attr(*, "where")=List of 7
[13:20:02.148]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.148]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:20:02.148]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:20:02.148]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.148]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.148]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.148]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.148]  - attr(*, "resolved")= logi FALSE
[13:20:02.148]  - attr(*, "total_size")= num 2320
[13:20:02.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.148]  - attr(*, "already-done")= logi TRUE
[13:20:02.160] - reassign environment for ‘...future.FUN’
[13:20:02.160] - copied ‘...future.FUN’ to environment
[13:20:02.160] - copied ‘breaks’ to environment
[13:20:02.160] - copied ‘wool’ to environment
[13:20:02.160] - copied ‘future.call.arguments’ to environment
[13:20:02.160] - copied ‘...future.elements_ii’ to environment
[13:20:02.160] - copied ‘...future.seeds_ii’ to environment
[13:20:02.161] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.161] assign_globals() ... done
[13:20:02.161] plan(): Setting new future strategy stack:
[13:20:02.161] List of future strategies:
[13:20:02.161] 1. sequential:
[13:20:02.161]    - args: function (..., envir = parent.frame())
[13:20:02.161]    - tweaked: FALSE
[13:20:02.161]    - call: NULL
[13:20:02.162] plan(): nbrOfWorkers() = 1
[13:20:02.165] plan(): Setting new future strategy stack:
[13:20:02.165] List of future strategies:
[13:20:02.165] 1. multicore:
[13:20:02.165]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.165]    - tweaked: FALSE
[13:20:02.165]    - call: plan(strategy)
[13:20:02.169] plan(): nbrOfWorkers() = 1
[13:20:02.169] SequentialFuture started (and completed)
[13:20:02.169] - Launch lazy future ... done
[13:20:02.169] run() for ‘SequentialFuture’ ... done
[13:20:02.169] Created future:
[13:20:02.169] SequentialFuture:
[13:20:02.169] Label: ‘future_by-1’
[13:20:02.169] Expression:
[13:20:02.169] {
[13:20:02.169]     do.call(function(...) {
[13:20:02.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.169]             on.exit(options(oopts), add = TRUE)
[13:20:02.169]         }
[13:20:02.169]         {
[13:20:02.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.169]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.169]             })
[13:20:02.169]         }
[13:20:02.169]     }, args = future.call.arguments)
[13:20:02.169] }
[13:20:02.169] Lazy evaluation: FALSE
[13:20:02.169] Asynchronous evaluation: FALSE
[13:20:02.169] Local evaluation: TRUE
[13:20:02.169] Environment: 0x55aced0ef5e0
[13:20:02.169] Capture standard output: TRUE
[13:20:02.169] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.169] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:20:02.169] Packages: 1 packages (‘stats’)
[13:20:02.169] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.169] Resolved: TRUE
[13:20:02.169] Value: 25.57 KiB of class ‘list’
[13:20:02.169] Early signaling: FALSE
[13:20:02.169] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.169] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.171] Chunk #1 of 1 ... DONE
[13:20:02.171] Launching 1 futures (chunks) ... DONE
[13:20:02.171] Resolving 1 futures (chunks) ...
[13:20:02.171] resolve() on list ...
[13:20:02.171]  recursive: 0
[13:20:02.171]  length: 1
[13:20:02.172] 
[13:20:02.172] resolved() for ‘SequentialFuture’ ...
[13:20:02.172] - state: ‘finished’
[13:20:02.172] - run: TRUE
[13:20:02.172] - result: ‘FutureResult’
[13:20:02.172] resolved() for ‘SequentialFuture’ ... done
[13:20:02.172] Future #1
[13:20:02.172] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.172] - nx: 1
[13:20:02.172] - relay: TRUE
[13:20:02.173] - stdout: TRUE
[13:20:02.173] - signal: TRUE
[13:20:02.173] - resignal: FALSE
[13:20:02.173] - force: TRUE
[13:20:02.173] - relayed: [n=1] FALSE
[13:20:02.173] - queued futures: [n=1] FALSE
[13:20:02.173]  - until=1
[13:20:02.173]  - relaying element #1
[13:20:02.173] - relayed: [n=1] TRUE
[13:20:02.173] - queued futures: [n=1] TRUE
[13:20:02.174] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.174]  length: 0 (resolved future 1)
[13:20:02.174] Relaying remaining futures
[13:20:02.174] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.174] - nx: 1
[13:20:02.174] - relay: TRUE
[13:20:02.174] - stdout: TRUE
[13:20:02.174] - signal: TRUE
[13:20:02.174] - resignal: FALSE
[13:20:02.174] - force: TRUE
[13:20:02.174] - relayed: [n=1] TRUE
[13:20:02.174] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.175] - relayed: [n=1] TRUE
[13:20:02.175] - queued futures: [n=1] TRUE
[13:20:02.175] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.175] resolve() on list ... DONE
[13:20:02.175]  - Number of value chunks collected: 1
[13:20:02.175] Resolving 1 futures (chunks) ... DONE
[13:20:02.175] Reducing values from 1 chunks ...
[13:20:02.175]  - Number of values collected after concatenation: 3
[13:20:02.175]  - Number of values expected: 3
[13:20:02.175] Reducing values from 1 chunks ... DONE
[13:20:02.176] future_lapply() ... DONE
[13:20:02.176] future_by_internal() ... DONE
[13:20:02.176] future_by_internal() ...
[13:20:02.176] future_lapply() ...
[13:20:02.180] Number of chunks: 1
[13:20:02.180] getGlobalsAndPackagesXApply() ...
[13:20:02.181]  - future.globals: TRUE
[13:20:02.181] getGlobalsAndPackages() ...
[13:20:02.181] Searching for globals...
[13:20:02.182] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.182] Searching for globals ... DONE
[13:20:02.182] Resolving globals: FALSE
[13:20:02.182] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.183] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.183] - globals: [1] ‘FUN’
[13:20:02.183] 
[13:20:02.183] getGlobalsAndPackages() ... DONE
[13:20:02.183]  - globals found/used: [n=1] ‘FUN’
[13:20:02.183]  - needed namespaces: [n=0] 
[13:20:02.183] Finding globals ... DONE
[13:20:02.183]  - use_args: TRUE
[13:20:02.184]  - Getting '...' globals ...
[13:20:02.184] resolve() on list ...
[13:20:02.184]  recursive: 0
[13:20:02.184]  length: 1
[13:20:02.184]  elements: ‘...’
[13:20:02.184]  length: 0 (resolved future 1)
[13:20:02.184] resolve() on list ... DONE
[13:20:02.185]    - '...' content: [n=0] 
[13:20:02.185] List of 1
[13:20:02.185]  $ ...: list()
[13:20:02.185]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.185]  - attr(*, "where")=List of 1
[13:20:02.185]   ..$ ...:<environment: 0x55acee9ea7c0> 
[13:20:02.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.185]  - attr(*, "resolved")= logi TRUE
[13:20:02.185]  - attr(*, "total_size")= num NA
[13:20:02.189]  - Getting '...' globals ... DONE
[13:20:02.190] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.190] List of 2
[13:20:02.190]  $ ...future.FUN:function (object, ...)  
[13:20:02.190]  $ ...          : list()
[13:20:02.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.190]  - attr(*, "where")=List of 2
[13:20:02.190]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.190]   ..$ ...          :<environment: 0x55acee9ea7c0> 
[13:20:02.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.190]  - attr(*, "resolved")= logi FALSE
[13:20:02.190]  - attr(*, "total_size")= num 1240
[13:20:02.193] Packages to be attached in all futures: [n=0] 
[13:20:02.193] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.193] Number of futures (= number of chunks): 1
[13:20:02.193] Launching 1 futures (chunks) ...
[13:20:02.193] Chunk #1 of 1 ...
[13:20:02.193]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.193] getGlobalsAndPackages() ...
[13:20:02.193] Searching for globals...
[13:20:02.194] 
[13:20:02.194] Searching for globals ... DONE
[13:20:02.194] - globals: [0] <none>
[13:20:02.194] getGlobalsAndPackages() ... DONE
[13:20:02.194]    + additional globals found: [n=0] 
[13:20:02.194]    + additional namespaces needed: [n=0] 
[13:20:02.194]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.194]  - seeds: <none>
[13:20:02.195]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.195] getGlobalsAndPackages() ...
[13:20:02.195] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.195] Resolving globals: FALSE
[13:20:02.195] Tweak future expression to call with '...' arguments ...
[13:20:02.195] {
[13:20:02.195]     do.call(function(...) {
[13:20:02.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.195]             on.exit(options(oopts), add = TRUE)
[13:20:02.195]         }
[13:20:02.195]         {
[13:20:02.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.195]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.195]             })
[13:20:02.195]         }
[13:20:02.195]     }, args = future.call.arguments)
[13:20:02.195] }
[13:20:02.195] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.196] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.196] 
[13:20:02.196] getGlobalsAndPackages() ... DONE
[13:20:02.196] run() for ‘Future’ ...
[13:20:02.196] - state: ‘created’
[13:20:02.196] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.200] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.200]   - Field: ‘label’
[13:20:02.200]   - Field: ‘local’
[13:20:02.200]   - Field: ‘owner’
[13:20:02.201]   - Field: ‘envir’
[13:20:02.201]   - Field: ‘packages’
[13:20:02.201]   - Field: ‘gc’
[13:20:02.201]   - Field: ‘conditions’
[13:20:02.201]   - Field: ‘expr’
[13:20:02.201]   - Field: ‘uuid’
[13:20:02.201]   - Field: ‘seed’
[13:20:02.201]   - Field: ‘version’
[13:20:02.201]   - Field: ‘result’
[13:20:02.201]   - Field: ‘asynchronous’
[13:20:02.201]   - Field: ‘calls’
[13:20:02.202]   - Field: ‘globals’
[13:20:02.202]   - Field: ‘stdout’
[13:20:02.202]   - Field: ‘earlySignal’
[13:20:02.202]   - Field: ‘lazy’
[13:20:02.202]   - Field: ‘state’
[13:20:02.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.202] - Launch lazy future ...
[13:20:02.202] Packages needed by the future expression (n = 0): <none>
[13:20:02.202] Packages needed by future strategies (n = 0): <none>
[13:20:02.203] {
[13:20:02.203]     {
[13:20:02.203]         {
[13:20:02.203]             ...future.startTime <- base::Sys.time()
[13:20:02.203]             {
[13:20:02.203]                 {
[13:20:02.203]                   {
[13:20:02.203]                     base::local({
[13:20:02.203]                       has_future <- base::requireNamespace("future", 
[13:20:02.203]                         quietly = TRUE)
[13:20:02.203]                       if (has_future) {
[13:20:02.203]                         ns <- base::getNamespace("future")
[13:20:02.203]                         version <- ns[[".package"]][["version"]]
[13:20:02.203]                         if (is.null(version)) 
[13:20:02.203]                           version <- utils::packageVersion("future")
[13:20:02.203]                       }
[13:20:02.203]                       else {
[13:20:02.203]                         version <- NULL
[13:20:02.203]                       }
[13:20:02.203]                       if (!has_future || version < "1.8.0") {
[13:20:02.203]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.203]                           "", base::R.version$version.string), 
[13:20:02.203]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.203]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.203]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.203]                             "release", "version")], collapse = " "), 
[13:20:02.203]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.203]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.203]                           info)
[13:20:02.203]                         info <- base::paste(info, collapse = "; ")
[13:20:02.203]                         if (!has_future) {
[13:20:02.203]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.203]                             info)
[13:20:02.203]                         }
[13:20:02.203]                         else {
[13:20:02.203]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.203]                             info, version)
[13:20:02.203]                         }
[13:20:02.203]                         base::stop(msg)
[13:20:02.203]                       }
[13:20:02.203]                     })
[13:20:02.203]                   }
[13:20:02.203]                   options(future.plan = NULL)
[13:20:02.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.203]                 }
[13:20:02.203]                 ...future.workdir <- getwd()
[13:20:02.203]             }
[13:20:02.203]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.203]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.203]         }
[13:20:02.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.203]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.203]             base::names(...future.oldOptions))
[13:20:02.203]     }
[13:20:02.203]     if (FALSE) {
[13:20:02.203]     }
[13:20:02.203]     else {
[13:20:02.203]         if (TRUE) {
[13:20:02.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.203]                 open = "w")
[13:20:02.203]         }
[13:20:02.203]         else {
[13:20:02.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.203]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.203]         }
[13:20:02.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.203]             base::sink(type = "output", split = FALSE)
[13:20:02.203]             base::close(...future.stdout)
[13:20:02.203]         }, add = TRUE)
[13:20:02.203]     }
[13:20:02.203]     ...future.frame <- base::sys.nframe()
[13:20:02.203]     ...future.conditions <- base::list()
[13:20:02.203]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.203]     if (FALSE) {
[13:20:02.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.203]     }
[13:20:02.203]     ...future.result <- base::tryCatch({
[13:20:02.203]         base::withCallingHandlers({
[13:20:02.203]             ...future.value <- base::withVisible(base::local({
[13:20:02.203]                 do.call(function(...) {
[13:20:02.203]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.203]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.203]                     ...future.globals.maxSize)) {
[13:20:02.203]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.203]                     on.exit(options(oopts), add = TRUE)
[13:20:02.203]                   }
[13:20:02.203]                   {
[13:20:02.203]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.203]                       FUN = function(jj) {
[13:20:02.203]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.203]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.203]                       })
[13:20:02.203]                   }
[13:20:02.203]                 }, args = future.call.arguments)
[13:20:02.203]             }))
[13:20:02.203]             future::FutureResult(value = ...future.value$value, 
[13:20:02.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.203]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.203]                     ...future.globalenv.names))
[13:20:02.203]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.203]         }, condition = base::local({
[13:20:02.203]             c <- base::c
[13:20:02.203]             inherits <- base::inherits
[13:20:02.203]             invokeRestart <- base::invokeRestart
[13:20:02.203]             length <- base::length
[13:20:02.203]             list <- base::list
[13:20:02.203]             seq.int <- base::seq.int
[13:20:02.203]             signalCondition <- base::signalCondition
[13:20:02.203]             sys.calls <- base::sys.calls
[13:20:02.203]             `[[` <- base::`[[`
[13:20:02.203]             `+` <- base::`+`
[13:20:02.203]             `<<-` <- base::`<<-`
[13:20:02.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.203]                   3L)]
[13:20:02.203]             }
[13:20:02.203]             function(cond) {
[13:20:02.203]                 is_error <- inherits(cond, "error")
[13:20:02.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.203]                   NULL)
[13:20:02.203]                 if (is_error) {
[13:20:02.203]                   sessionInformation <- function() {
[13:20:02.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.203]                       search = base::search(), system = base::Sys.info())
[13:20:02.203]                   }
[13:20:02.203]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.203]                     cond$call), session = sessionInformation(), 
[13:20:02.203]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.203]                   signalCondition(cond)
[13:20:02.203]                 }
[13:20:02.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.203]                 "immediateCondition"))) {
[13:20:02.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.203]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.203]                   if (TRUE && !signal) {
[13:20:02.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.203]                     {
[13:20:02.203]                       inherits <- base::inherits
[13:20:02.203]                       invokeRestart <- base::invokeRestart
[13:20:02.203]                       is.null <- base::is.null
[13:20:02.203]                       muffled <- FALSE
[13:20:02.203]                       if (inherits(cond, "message")) {
[13:20:02.203]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.203]                         if (muffled) 
[13:20:02.203]                           invokeRestart("muffleMessage")
[13:20:02.203]                       }
[13:20:02.203]                       else if (inherits(cond, "warning")) {
[13:20:02.203]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.203]                         if (muffled) 
[13:20:02.203]                           invokeRestart("muffleWarning")
[13:20:02.203]                       }
[13:20:02.203]                       else if (inherits(cond, "condition")) {
[13:20:02.203]                         if (!is.null(pattern)) {
[13:20:02.203]                           computeRestarts <- base::computeRestarts
[13:20:02.203]                           grepl <- base::grepl
[13:20:02.203]                           restarts <- computeRestarts(cond)
[13:20:02.203]                           for (restart in restarts) {
[13:20:02.203]                             name <- restart$name
[13:20:02.203]                             if (is.null(name)) 
[13:20:02.203]                               next
[13:20:02.203]                             if (!grepl(pattern, name)) 
[13:20:02.203]                               next
[13:20:02.203]                             invokeRestart(restart)
[13:20:02.203]                             muffled <- TRUE
[13:20:02.203]                             break
[13:20:02.203]                           }
[13:20:02.203]                         }
[13:20:02.203]                       }
[13:20:02.203]                       invisible(muffled)
[13:20:02.203]                     }
[13:20:02.203]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.203]                   }
[13:20:02.203]                 }
[13:20:02.203]                 else {
[13:20:02.203]                   if (TRUE) {
[13:20:02.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.203]                     {
[13:20:02.203]                       inherits <- base::inherits
[13:20:02.203]                       invokeRestart <- base::invokeRestart
[13:20:02.203]                       is.null <- base::is.null
[13:20:02.203]                       muffled <- FALSE
[13:20:02.203]                       if (inherits(cond, "message")) {
[13:20:02.203]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.203]                         if (muffled) 
[13:20:02.203]                           invokeRestart("muffleMessage")
[13:20:02.203]                       }
[13:20:02.203]                       else if (inherits(cond, "warning")) {
[13:20:02.203]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.203]                         if (muffled) 
[13:20:02.203]                           invokeRestart("muffleWarning")
[13:20:02.203]                       }
[13:20:02.203]                       else if (inherits(cond, "condition")) {
[13:20:02.203]                         if (!is.null(pattern)) {
[13:20:02.203]                           computeRestarts <- base::computeRestarts
[13:20:02.203]                           grepl <- base::grepl
[13:20:02.203]                           restarts <- computeRestarts(cond)
[13:20:02.203]                           for (restart in restarts) {
[13:20:02.203]                             name <- restart$name
[13:20:02.203]                             if (is.null(name)) 
[13:20:02.203]                               next
[13:20:02.203]                             if (!grepl(pattern, name)) 
[13:20:02.203]                               next
[13:20:02.203]                             invokeRestart(restart)
[13:20:02.203]                             muffled <- TRUE
[13:20:02.203]                             break
[13:20:02.203]                           }
[13:20:02.203]                         }
[13:20:02.203]                       }
[13:20:02.203]                       invisible(muffled)
[13:20:02.203]                     }
[13:20:02.203]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.203]                   }
[13:20:02.203]                 }
[13:20:02.203]             }
[13:20:02.203]         }))
[13:20:02.203]     }, error = function(ex) {
[13:20:02.203]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.203]                 ...future.rng), started = ...future.startTime, 
[13:20:02.203]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.203]             version = "1.8"), class = "FutureResult")
[13:20:02.203]     }, finally = {
[13:20:02.203]         if (!identical(...future.workdir, getwd())) 
[13:20:02.203]             setwd(...future.workdir)
[13:20:02.203]         {
[13:20:02.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.203]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.203]             }
[13:20:02.203]             base::options(...future.oldOptions)
[13:20:02.203]             if (.Platform$OS.type == "windows") {
[13:20:02.203]                 old_names <- names(...future.oldEnvVars)
[13:20:02.203]                 envs <- base::Sys.getenv()
[13:20:02.203]                 names <- names(envs)
[13:20:02.203]                 common <- intersect(names, old_names)
[13:20:02.203]                 added <- setdiff(names, old_names)
[13:20:02.203]                 removed <- setdiff(old_names, names)
[13:20:02.203]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.203]                   envs[common]]
[13:20:02.203]                 NAMES <- toupper(changed)
[13:20:02.203]                 args <- list()
[13:20:02.203]                 for (kk in seq_along(NAMES)) {
[13:20:02.203]                   name <- changed[[kk]]
[13:20:02.203]                   NAME <- NAMES[[kk]]
[13:20:02.203]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.203]                     next
[13:20:02.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.203]                 }
[13:20:02.203]                 NAMES <- toupper(added)
[13:20:02.203]                 for (kk in seq_along(NAMES)) {
[13:20:02.203]                   name <- added[[kk]]
[13:20:02.203]                   NAME <- NAMES[[kk]]
[13:20:02.203]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.203]                     next
[13:20:02.203]                   args[[name]] <- ""
[13:20:02.203]                 }
[13:20:02.203]                 NAMES <- toupper(removed)
[13:20:02.203]                 for (kk in seq_along(NAMES)) {
[13:20:02.203]                   name <- removed[[kk]]
[13:20:02.203]                   NAME <- NAMES[[kk]]
[13:20:02.203]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.203]                     next
[13:20:02.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.203]                 }
[13:20:02.203]                 if (length(args) > 0) 
[13:20:02.203]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.203]             }
[13:20:02.203]             else {
[13:20:02.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.203]             }
[13:20:02.203]             {
[13:20:02.203]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.203]                   0L) {
[13:20:02.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.203]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.203]                   base::options(opts)
[13:20:02.203]                 }
[13:20:02.203]                 {
[13:20:02.203]                   {
[13:20:02.203]                     NULL
[13:20:02.203]                     RNGkind("Mersenne-Twister")
[13:20:02.203]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.203]                       inherits = FALSE)
[13:20:02.203]                   }
[13:20:02.203]                   options(future.plan = NULL)
[13:20:02.203]                   if (is.na(NA_character_)) 
[13:20:02.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.203]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:02.203]                     envir = parent.frame()) 
[13:20:02.203]                   {
[13:20:02.203]                     default_workers <- missing(workers)
[13:20:02.203]                     if (is.function(workers)) 
[13:20:02.203]                       workers <- workers()
[13:20:02.203]                     workers <- structure(as.integer(workers), 
[13:20:02.203]                       class = class(workers))
[13:20:02.203]                     stop_if_not(is.finite(workers), workers >= 
[13:20:02.203]                       1L)
[13:20:02.203]                     if ((workers == 1L && !inherits(workers, 
[13:20:02.203]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:02.203]                       if (default_workers) 
[13:20:02.203]                         supportsMulticore(warn = TRUE)
[13:20:02.203]                       return(sequential(..., envir = envir))
[13:20:02.203]                     }
[13:20:02.203]                     oopts <- options(mc.cores = workers)
[13:20:02.203]                     on.exit(options(oopts))
[13:20:02.203]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:02.203]                       envir = envir)
[13:20:02.203]                     if (!future$lazy) 
[13:20:02.203]                       future <- run(future)
[13:20:02.203]                     invisible(future)
[13:20:02.203]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.203]                 }
[13:20:02.203]             }
[13:20:02.203]         }
[13:20:02.203]     })
[13:20:02.203]     if (TRUE) {
[13:20:02.203]         base::sink(type = "output", split = FALSE)
[13:20:02.203]         if (TRUE) {
[13:20:02.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.203]         }
[13:20:02.203]         else {
[13:20:02.203]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.203]         }
[13:20:02.203]         base::close(...future.stdout)
[13:20:02.203]         ...future.stdout <- NULL
[13:20:02.203]     }
[13:20:02.203]     ...future.result$conditions <- ...future.conditions
[13:20:02.203]     ...future.result$finished <- base::Sys.time()
[13:20:02.203]     ...future.result
[13:20:02.203] }
[13:20:02.205] assign_globals() ...
[13:20:02.205] List of 5
[13:20:02.205]  $ ...future.FUN            :function (object, ...)  
[13:20:02.205]  $ future.call.arguments    : list()
[13:20:02.205]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.205]  $ ...future.elements_ii    :List of 3
[13:20:02.205]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.205]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.205]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.205]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.205]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.205]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.205]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.205]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.205]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.205]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.205]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.205]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.205]  $ ...future.seeds_ii       : NULL
[13:20:02.205]  $ ...future.globals.maxSize: NULL
[13:20:02.205]  - attr(*, "where")=List of 5
[13:20:02.205]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.205]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.205]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.205]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.205]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.205]  - attr(*, "resolved")= logi FALSE
[13:20:02.205]  - attr(*, "total_size")= num 1240
[13:20:02.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.205]  - attr(*, "already-done")= logi TRUE
[13:20:02.215] - copied ‘...future.FUN’ to environment
[13:20:02.215] - copied ‘future.call.arguments’ to environment
[13:20:02.215] - copied ‘...future.elements_ii’ to environment
[13:20:02.216] - copied ‘...future.seeds_ii’ to environment
[13:20:02.216] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.216] assign_globals() ... done
[13:20:02.216] plan(): Setting new future strategy stack:
[13:20:02.216] List of future strategies:
[13:20:02.216] 1. sequential:
[13:20:02.216]    - args: function (..., envir = parent.frame())
[13:20:02.216]    - tweaked: FALSE
[13:20:02.216]    - call: NULL
[13:20:02.216] plan(): nbrOfWorkers() = 1
[13:20:02.219] plan(): Setting new future strategy stack:
[13:20:02.219] List of future strategies:
[13:20:02.219] 1. multicore:
[13:20:02.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.219]    - tweaked: FALSE
[13:20:02.219]    - call: plan(strategy)
[13:20:02.223] plan(): nbrOfWorkers() = 1
[13:20:02.223] SequentialFuture started (and completed)
[13:20:02.223] - Launch lazy future ... done
[13:20:02.223] run() for ‘SequentialFuture’ ... done
[13:20:02.224] Created future:
[13:20:02.224] SequentialFuture:
[13:20:02.224] Label: ‘future_by-1’
[13:20:02.224] Expression:
[13:20:02.224] {
[13:20:02.224]     do.call(function(...) {
[13:20:02.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.224]             on.exit(options(oopts), add = TRUE)
[13:20:02.224]         }
[13:20:02.224]         {
[13:20:02.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.224]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.224]             })
[13:20:02.224]         }
[13:20:02.224]     }, args = future.call.arguments)
[13:20:02.224] }
[13:20:02.224] Lazy evaluation: FALSE
[13:20:02.224] Asynchronous evaluation: FALSE
[13:20:02.224] Local evaluation: TRUE
[13:20:02.224] Environment: 0x55acee9af4e8
[13:20:02.224] Capture standard output: TRUE
[13:20:02.224] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.224] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.224] Packages: <none>
[13:20:02.224] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.224] Resolved: TRUE
[13:20:02.224] Value: 5.37 KiB of class ‘list’
[13:20:02.224] Early signaling: FALSE
[13:20:02.224] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.224] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.225] Chunk #1 of 1 ... DONE
[13:20:02.225] Launching 1 futures (chunks) ... DONE
[13:20:02.225] Resolving 1 futures (chunks) ...
[13:20:02.226] resolve() on list ...
[13:20:02.226]  recursive: 0
[13:20:02.226]  length: 1
[13:20:02.226] 
[13:20:02.226] resolved() for ‘SequentialFuture’ ...
[13:20:02.226] - state: ‘finished’
[13:20:02.226] - run: TRUE
[13:20:02.226] - result: ‘FutureResult’
[13:20:02.226] resolved() for ‘SequentialFuture’ ... done
[13:20:02.226] Future #1
[13:20:02.227] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.227] - nx: 1
[13:20:02.227] - relay: TRUE
[13:20:02.227] - stdout: TRUE
[13:20:02.227] - signal: TRUE
[13:20:02.227] - resignal: FALSE
[13:20:02.227] - force: TRUE
[13:20:02.227] - relayed: [n=1] FALSE
[13:20:02.227] - queued futures: [n=1] FALSE
[13:20:02.227]  - until=1
[13:20:02.228]  - relaying element #1
[13:20:02.228] - relayed: [n=1] TRUE
[13:20:02.228] - queued futures: [n=1] TRUE
[13:20:02.228] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.228]  length: 0 (resolved future 1)
[13:20:02.228] Relaying remaining futures
[13:20:02.228] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.228] - nx: 1
[13:20:02.228] - relay: TRUE
[13:20:02.229] - stdout: TRUE
[13:20:02.229] - signal: TRUE
[13:20:02.229] - resignal: FALSE
[13:20:02.229] - force: TRUE
[13:20:02.229] - relayed: [n=1] TRUE
[13:20:02.229] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.229] - relayed: [n=1] TRUE
[13:20:02.229] - queued futures: [n=1] TRUE
[13:20:02.229] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.229] resolve() on list ... DONE
[13:20:02.230]  - Number of value chunks collected: 1
[13:20:02.230] Resolving 1 futures (chunks) ... DONE
[13:20:02.230] Reducing values from 1 chunks ...
[13:20:02.230]  - Number of values collected after concatenation: 3
[13:20:02.230]  - Number of values expected: 3
[13:20:02.230] Reducing values from 1 chunks ... DONE
[13:20:02.230] future_lapply() ... DONE
[13:20:02.230] future_by_internal() ... DONE
[13:20:02.231] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:20:02.232] future_lapply() ...
[13:20:02.235] Number of chunks: 1
[13:20:02.235] getGlobalsAndPackagesXApply() ...
[13:20:02.236]  - future.globals: TRUE
[13:20:02.236] getGlobalsAndPackages() ...
[13:20:02.236] Searching for globals...
[13:20:02.237] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.237] Searching for globals ... DONE
[13:20:02.237] Resolving globals: FALSE
[13:20:02.237] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.238] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.238] - globals: [1] ‘FUN’
[13:20:02.238] 
[13:20:02.238] getGlobalsAndPackages() ... DONE
[13:20:02.238]  - globals found/used: [n=1] ‘FUN’
[13:20:02.238]  - needed namespaces: [n=0] 
[13:20:02.238] Finding globals ... DONE
[13:20:02.238]  - use_args: TRUE
[13:20:02.239]  - Getting '...' globals ...
[13:20:02.239] resolve() on list ...
[13:20:02.239]  recursive: 0
[13:20:02.239]  length: 1
[13:20:02.239]  elements: ‘...’
[13:20:02.239]  length: 0 (resolved future 1)
[13:20:02.239] resolve() on list ... DONE
[13:20:02.239]    - '...' content: [n=0] 
[13:20:02.240] List of 1
[13:20:02.240]  $ ...: list()
[13:20:02.240]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.240]  - attr(*, "where")=List of 1
[13:20:02.240]   ..$ ...:<environment: 0x55aceea2ebb8> 
[13:20:02.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.240]  - attr(*, "resolved")= logi TRUE
[13:20:02.240]  - attr(*, "total_size")= num NA
[13:20:02.245]  - Getting '...' globals ... DONE
[13:20:02.245] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.245] List of 2
[13:20:02.245]  $ ...future.FUN:function (object, ...)  
[13:20:02.245]  $ ...          : list()
[13:20:02.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.245]  - attr(*, "where")=List of 2
[13:20:02.245]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.245]   ..$ ...          :<environment: 0x55aceea2ebb8> 
[13:20:02.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.245]  - attr(*, "resolved")= logi FALSE
[13:20:02.245]  - attr(*, "total_size")= num 1240
[13:20:02.248] Packages to be attached in all futures: [n=0] 
[13:20:02.248] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.249] Number of futures (= number of chunks): 1
[13:20:02.249] Launching 1 futures (chunks) ...
[13:20:02.249] Chunk #1 of 1 ...
[13:20:02.249]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.249] getGlobalsAndPackages() ...
[13:20:02.249] Searching for globals...
[13:20:02.250] 
[13:20:02.250] Searching for globals ... DONE
[13:20:02.250] - globals: [0] <none>
[13:20:02.250] getGlobalsAndPackages() ... DONE
[13:20:02.250]    + additional globals found: [n=0] 
[13:20:02.250]    + additional namespaces needed: [n=0] 
[13:20:02.250]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.250]  - seeds: <none>
[13:20:02.250]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.250] getGlobalsAndPackages() ...
[13:20:02.251] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.251] Resolving globals: FALSE
[13:20:02.251] Tweak future expression to call with '...' arguments ...
[13:20:02.251] {
[13:20:02.251]     do.call(function(...) {
[13:20:02.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.251]             on.exit(options(oopts), add = TRUE)
[13:20:02.251]         }
[13:20:02.251]         {
[13:20:02.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.251]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.251]             })
[13:20:02.251]         }
[13:20:02.251]     }, args = future.call.arguments)
[13:20:02.251] }
[13:20:02.251] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.252] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.252] 
[13:20:02.252] getGlobalsAndPackages() ... DONE
[13:20:02.252] run() for ‘Future’ ...
[13:20:02.252] - state: ‘created’
[13:20:02.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.256]   - Field: ‘label’
[13:20:02.257]   - Field: ‘local’
[13:20:02.257]   - Field: ‘owner’
[13:20:02.257]   - Field: ‘envir’
[13:20:02.257]   - Field: ‘packages’
[13:20:02.257]   - Field: ‘gc’
[13:20:02.257]   - Field: ‘conditions’
[13:20:02.257]   - Field: ‘expr’
[13:20:02.257]   - Field: ‘uuid’
[13:20:02.257]   - Field: ‘seed’
[13:20:02.257]   - Field: ‘version’
[13:20:02.258]   - Field: ‘result’
[13:20:02.258]   - Field: ‘asynchronous’
[13:20:02.258]   - Field: ‘calls’
[13:20:02.258]   - Field: ‘globals’
[13:20:02.258]   - Field: ‘stdout’
[13:20:02.258]   - Field: ‘earlySignal’
[13:20:02.258]   - Field: ‘lazy’
[13:20:02.258]   - Field: ‘state’
[13:20:02.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.258] - Launch lazy future ...
[13:20:02.259] Packages needed by the future expression (n = 0): <none>
[13:20:02.259] Packages needed by future strategies (n = 0): <none>
[13:20:02.259] {
[13:20:02.259]     {
[13:20:02.259]         {
[13:20:02.259]             ...future.startTime <- base::Sys.time()
[13:20:02.259]             {
[13:20:02.259]                 {
[13:20:02.259]                   {
[13:20:02.259]                     base::local({
[13:20:02.259]                       has_future <- base::requireNamespace("future", 
[13:20:02.259]                         quietly = TRUE)
[13:20:02.259]                       if (has_future) {
[13:20:02.259]                         ns <- base::getNamespace("future")
[13:20:02.259]                         version <- ns[[".package"]][["version"]]
[13:20:02.259]                         if (is.null(version)) 
[13:20:02.259]                           version <- utils::packageVersion("future")
[13:20:02.259]                       }
[13:20:02.259]                       else {
[13:20:02.259]                         version <- NULL
[13:20:02.259]                       }
[13:20:02.259]                       if (!has_future || version < "1.8.0") {
[13:20:02.259]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.259]                           "", base::R.version$version.string), 
[13:20:02.259]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.259]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.259]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.259]                             "release", "version")], collapse = " "), 
[13:20:02.259]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.259]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.259]                           info)
[13:20:02.259]                         info <- base::paste(info, collapse = "; ")
[13:20:02.259]                         if (!has_future) {
[13:20:02.259]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.259]                             info)
[13:20:02.259]                         }
[13:20:02.259]                         else {
[13:20:02.259]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.259]                             info, version)
[13:20:02.259]                         }
[13:20:02.259]                         base::stop(msg)
[13:20:02.259]                       }
[13:20:02.259]                     })
[13:20:02.259]                   }
[13:20:02.259]                   options(future.plan = NULL)
[13:20:02.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.259]                 }
[13:20:02.259]                 ...future.workdir <- getwd()
[13:20:02.259]             }
[13:20:02.259]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.259]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.259]         }
[13:20:02.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.259]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.259]             base::names(...future.oldOptions))
[13:20:02.259]     }
[13:20:02.259]     if (FALSE) {
[13:20:02.259]     }
[13:20:02.259]     else {
[13:20:02.259]         if (TRUE) {
[13:20:02.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.259]                 open = "w")
[13:20:02.259]         }
[13:20:02.259]         else {
[13:20:02.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.259]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.259]         }
[13:20:02.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.259]             base::sink(type = "output", split = FALSE)
[13:20:02.259]             base::close(...future.stdout)
[13:20:02.259]         }, add = TRUE)
[13:20:02.259]     }
[13:20:02.259]     ...future.frame <- base::sys.nframe()
[13:20:02.259]     ...future.conditions <- base::list()
[13:20:02.259]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.259]     if (FALSE) {
[13:20:02.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.259]     }
[13:20:02.259]     ...future.result <- base::tryCatch({
[13:20:02.259]         base::withCallingHandlers({
[13:20:02.259]             ...future.value <- base::withVisible(base::local({
[13:20:02.259]                 do.call(function(...) {
[13:20:02.259]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.259]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.259]                     ...future.globals.maxSize)) {
[13:20:02.259]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.259]                     on.exit(options(oopts), add = TRUE)
[13:20:02.259]                   }
[13:20:02.259]                   {
[13:20:02.259]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.259]                       FUN = function(jj) {
[13:20:02.259]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.259]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.259]                       })
[13:20:02.259]                   }
[13:20:02.259]                 }, args = future.call.arguments)
[13:20:02.259]             }))
[13:20:02.259]             future::FutureResult(value = ...future.value$value, 
[13:20:02.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.259]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.259]                     ...future.globalenv.names))
[13:20:02.259]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.259]         }, condition = base::local({
[13:20:02.259]             c <- base::c
[13:20:02.259]             inherits <- base::inherits
[13:20:02.259]             invokeRestart <- base::invokeRestart
[13:20:02.259]             length <- base::length
[13:20:02.259]             list <- base::list
[13:20:02.259]             seq.int <- base::seq.int
[13:20:02.259]             signalCondition <- base::signalCondition
[13:20:02.259]             sys.calls <- base::sys.calls
[13:20:02.259]             `[[` <- base::`[[`
[13:20:02.259]             `+` <- base::`+`
[13:20:02.259]             `<<-` <- base::`<<-`
[13:20:02.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.259]                   3L)]
[13:20:02.259]             }
[13:20:02.259]             function(cond) {
[13:20:02.259]                 is_error <- inherits(cond, "error")
[13:20:02.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.259]                   NULL)
[13:20:02.259]                 if (is_error) {
[13:20:02.259]                   sessionInformation <- function() {
[13:20:02.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.259]                       search = base::search(), system = base::Sys.info())
[13:20:02.259]                   }
[13:20:02.259]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.259]                     cond$call), session = sessionInformation(), 
[13:20:02.259]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.259]                   signalCondition(cond)
[13:20:02.259]                 }
[13:20:02.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.259]                 "immediateCondition"))) {
[13:20:02.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.259]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.259]                   if (TRUE && !signal) {
[13:20:02.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.259]                     {
[13:20:02.259]                       inherits <- base::inherits
[13:20:02.259]                       invokeRestart <- base::invokeRestart
[13:20:02.259]                       is.null <- base::is.null
[13:20:02.259]                       muffled <- FALSE
[13:20:02.259]                       if (inherits(cond, "message")) {
[13:20:02.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.259]                         if (muffled) 
[13:20:02.259]                           invokeRestart("muffleMessage")
[13:20:02.259]                       }
[13:20:02.259]                       else if (inherits(cond, "warning")) {
[13:20:02.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.259]                         if (muffled) 
[13:20:02.259]                           invokeRestart("muffleWarning")
[13:20:02.259]                       }
[13:20:02.259]                       else if (inherits(cond, "condition")) {
[13:20:02.259]                         if (!is.null(pattern)) {
[13:20:02.259]                           computeRestarts <- base::computeRestarts
[13:20:02.259]                           grepl <- base::grepl
[13:20:02.259]                           restarts <- computeRestarts(cond)
[13:20:02.259]                           for (restart in restarts) {
[13:20:02.259]                             name <- restart$name
[13:20:02.259]                             if (is.null(name)) 
[13:20:02.259]                               next
[13:20:02.259]                             if (!grepl(pattern, name)) 
[13:20:02.259]                               next
[13:20:02.259]                             invokeRestart(restart)
[13:20:02.259]                             muffled <- TRUE
[13:20:02.259]                             break
[13:20:02.259]                           }
[13:20:02.259]                         }
[13:20:02.259]                       }
[13:20:02.259]                       invisible(muffled)
[13:20:02.259]                     }
[13:20:02.259]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.259]                   }
[13:20:02.259]                 }
[13:20:02.259]                 else {
[13:20:02.259]                   if (TRUE) {
[13:20:02.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.259]                     {
[13:20:02.259]                       inherits <- base::inherits
[13:20:02.259]                       invokeRestart <- base::invokeRestart
[13:20:02.259]                       is.null <- base::is.null
[13:20:02.259]                       muffled <- FALSE
[13:20:02.259]                       if (inherits(cond, "message")) {
[13:20:02.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.259]                         if (muffled) 
[13:20:02.259]                           invokeRestart("muffleMessage")
[13:20:02.259]                       }
[13:20:02.259]                       else if (inherits(cond, "warning")) {
[13:20:02.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.259]                         if (muffled) 
[13:20:02.259]                           invokeRestart("muffleWarning")
[13:20:02.259]                       }
[13:20:02.259]                       else if (inherits(cond, "condition")) {
[13:20:02.259]                         if (!is.null(pattern)) {
[13:20:02.259]                           computeRestarts <- base::computeRestarts
[13:20:02.259]                           grepl <- base::grepl
[13:20:02.259]                           restarts <- computeRestarts(cond)
[13:20:02.259]                           for (restart in restarts) {
[13:20:02.259]                             name <- restart$name
[13:20:02.259]                             if (is.null(name)) 
[13:20:02.259]                               next
[13:20:02.259]                             if (!grepl(pattern, name)) 
[13:20:02.259]                               next
[13:20:02.259]                             invokeRestart(restart)
[13:20:02.259]                             muffled <- TRUE
[13:20:02.259]                             break
[13:20:02.259]                           }
[13:20:02.259]                         }
[13:20:02.259]                       }
[13:20:02.259]                       invisible(muffled)
[13:20:02.259]                     }
[13:20:02.259]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.259]                   }
[13:20:02.259]                 }
[13:20:02.259]             }
[13:20:02.259]         }))
[13:20:02.259]     }, error = function(ex) {
[13:20:02.259]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.259]                 ...future.rng), started = ...future.startTime, 
[13:20:02.259]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.259]             version = "1.8"), class = "FutureResult")
[13:20:02.259]     }, finally = {
[13:20:02.259]         if (!identical(...future.workdir, getwd())) 
[13:20:02.259]             setwd(...future.workdir)
[13:20:02.259]         {
[13:20:02.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.259]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.259]             }
[13:20:02.259]             base::options(...future.oldOptions)
[13:20:02.259]             if (.Platform$OS.type == "windows") {
[13:20:02.259]                 old_names <- names(...future.oldEnvVars)
[13:20:02.259]                 envs <- base::Sys.getenv()
[13:20:02.259]                 names <- names(envs)
[13:20:02.259]                 common <- intersect(names, old_names)
[13:20:02.259]                 added <- setdiff(names, old_names)
[13:20:02.259]                 removed <- setdiff(old_names, names)
[13:20:02.259]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.259]                   envs[common]]
[13:20:02.259]                 NAMES <- toupper(changed)
[13:20:02.259]                 args <- list()
[13:20:02.259]                 for (kk in seq_along(NAMES)) {
[13:20:02.259]                   name <- changed[[kk]]
[13:20:02.259]                   NAME <- NAMES[[kk]]
[13:20:02.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.259]                     next
[13:20:02.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.259]                 }
[13:20:02.259]                 NAMES <- toupper(added)
[13:20:02.259]                 for (kk in seq_along(NAMES)) {
[13:20:02.259]                   name <- added[[kk]]
[13:20:02.259]                   NAME <- NAMES[[kk]]
[13:20:02.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.259]                     next
[13:20:02.259]                   args[[name]] <- ""
[13:20:02.259]                 }
[13:20:02.259]                 NAMES <- toupper(removed)
[13:20:02.259]                 for (kk in seq_along(NAMES)) {
[13:20:02.259]                   name <- removed[[kk]]
[13:20:02.259]                   NAME <- NAMES[[kk]]
[13:20:02.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.259]                     next
[13:20:02.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.259]                 }
[13:20:02.259]                 if (length(args) > 0) 
[13:20:02.259]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.259]             }
[13:20:02.259]             else {
[13:20:02.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.259]             }
[13:20:02.259]             {
[13:20:02.259]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.259]                   0L) {
[13:20:02.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.259]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.259]                   base::options(opts)
[13:20:02.259]                 }
[13:20:02.259]                 {
[13:20:02.259]                   {
[13:20:02.259]                     NULL
[13:20:02.259]                     RNGkind("Mersenne-Twister")
[13:20:02.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.259]                       inherits = FALSE)
[13:20:02.259]                   }
[13:20:02.259]                   options(future.plan = NULL)
[13:20:02.259]                   if (is.na(NA_character_)) 
[13:20:02.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.259]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:02.259]                     envir = parent.frame()) 
[13:20:02.259]                   {
[13:20:02.259]                     default_workers <- missing(workers)
[13:20:02.259]                     if (is.function(workers)) 
[13:20:02.259]                       workers <- workers()
[13:20:02.259]                     workers <- structure(as.integer(workers), 
[13:20:02.259]                       class = class(workers))
[13:20:02.259]                     stop_if_not(is.finite(workers), workers >= 
[13:20:02.259]                       1L)
[13:20:02.259]                     if ((workers == 1L && !inherits(workers, 
[13:20:02.259]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:02.259]                       if (default_workers) 
[13:20:02.259]                         supportsMulticore(warn = TRUE)
[13:20:02.259]                       return(sequential(..., envir = envir))
[13:20:02.259]                     }
[13:20:02.259]                     oopts <- options(mc.cores = workers)
[13:20:02.259]                     on.exit(options(oopts))
[13:20:02.259]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:02.259]                       envir = envir)
[13:20:02.259]                     if (!future$lazy) 
[13:20:02.259]                       future <- run(future)
[13:20:02.259]                     invisible(future)
[13:20:02.259]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.259]                 }
[13:20:02.259]             }
[13:20:02.259]         }
[13:20:02.259]     })
[13:20:02.259]     if (TRUE) {
[13:20:02.259]         base::sink(type = "output", split = FALSE)
[13:20:02.259]         if (TRUE) {
[13:20:02.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.259]         }
[13:20:02.259]         else {
[13:20:02.259]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.259]         }
[13:20:02.259]         base::close(...future.stdout)
[13:20:02.259]         ...future.stdout <- NULL
[13:20:02.259]     }
[13:20:02.259]     ...future.result$conditions <- ...future.conditions
[13:20:02.259]     ...future.result$finished <- base::Sys.time()
[13:20:02.259]     ...future.result
[13:20:02.259] }
[13:20:02.261] assign_globals() ...
[13:20:02.261] List of 5
[13:20:02.261]  $ ...future.FUN            :function (object, ...)  
[13:20:02.261]  $ future.call.arguments    : list()
[13:20:02.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.261]  $ ...future.elements_ii    :List of 3
[13:20:02.261]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.261]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.261]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.261]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.261]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.261]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.261]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.261]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.261]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.261]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.261]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.261]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.261]  $ ...future.seeds_ii       : NULL
[13:20:02.261]  $ ...future.globals.maxSize: NULL
[13:20:02.261]  - attr(*, "where")=List of 5
[13:20:02.261]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.261]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.261]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.261]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.261]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.261]  - attr(*, "resolved")= logi FALSE
[13:20:02.261]  - attr(*, "total_size")= num 1240
[13:20:02.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.261]  - attr(*, "already-done")= logi TRUE
[13:20:02.273] - copied ‘...future.FUN’ to environment
[13:20:02.273] - copied ‘future.call.arguments’ to environment
[13:20:02.273] - copied ‘...future.elements_ii’ to environment
[13:20:02.273] - copied ‘...future.seeds_ii’ to environment
[13:20:02.273] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.273] assign_globals() ... done
[13:20:02.273] plan(): Setting new future strategy stack:
[13:20:02.274] List of future strategies:
[13:20:02.274] 1. sequential:
[13:20:02.274]    - args: function (..., envir = parent.frame())
[13:20:02.274]    - tweaked: FALSE
[13:20:02.274]    - call: NULL
[13:20:02.274] plan(): nbrOfWorkers() = 1
[13:20:02.276] plan(): Setting new future strategy stack:
[13:20:02.276] List of future strategies:
[13:20:02.276] 1. multicore:
[13:20:02.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.276]    - tweaked: FALSE
[13:20:02.276]    - call: plan(strategy)
[13:20:02.280] plan(): nbrOfWorkers() = 1
[13:20:02.280] SequentialFuture started (and completed)
[13:20:02.281] - Launch lazy future ... done
[13:20:02.281] run() for ‘SequentialFuture’ ... done
[13:20:02.281] Created future:
[13:20:02.281] SequentialFuture:
[13:20:02.281] Label: ‘future_by-1’
[13:20:02.281] Expression:
[13:20:02.281] {
[13:20:02.281]     do.call(function(...) {
[13:20:02.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.281]             on.exit(options(oopts), add = TRUE)
[13:20:02.281]         }
[13:20:02.281]         {
[13:20:02.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.281]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.281]             })
[13:20:02.281]         }
[13:20:02.281]     }, args = future.call.arguments)
[13:20:02.281] }
[13:20:02.281] Lazy evaluation: FALSE
[13:20:02.281] Asynchronous evaluation: FALSE
[13:20:02.281] Local evaluation: TRUE
[13:20:02.281] Environment: 0x55acee9f8b38
[13:20:02.281] Capture standard output: TRUE
[13:20:02.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.281] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.281] Packages: <none>
[13:20:02.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.281] Resolved: TRUE
[13:20:02.281] Value: 5.37 KiB of class ‘list’
[13:20:02.281] Early signaling: FALSE
[13:20:02.281] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.281] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.282] Chunk #1 of 1 ... DONE
[13:20:02.282] Launching 1 futures (chunks) ... DONE
[13:20:02.282] Resolving 1 futures (chunks) ...
[13:20:02.283] resolve() on list ...
[13:20:02.283]  recursive: 0
[13:20:02.283]  length: 1
[13:20:02.283] 
[13:20:02.283] resolved() for ‘SequentialFuture’ ...
[13:20:02.283] - state: ‘finished’
[13:20:02.283] - run: TRUE
[13:20:02.283] - result: ‘FutureResult’
[13:20:02.283] resolved() for ‘SequentialFuture’ ... done
[13:20:02.283] Future #1
[13:20:02.284] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.284] - nx: 1
[13:20:02.284] - relay: TRUE
[13:20:02.284] - stdout: TRUE
[13:20:02.284] - signal: TRUE
[13:20:02.284] - resignal: FALSE
[13:20:02.284] - force: TRUE
[13:20:02.284] - relayed: [n=1] FALSE
[13:20:02.284] - queued futures: [n=1] FALSE
[13:20:02.284]  - until=1
[13:20:02.284]  - relaying element #1
[13:20:02.285] - relayed: [n=1] TRUE
[13:20:02.285] - queued futures: [n=1] TRUE
[13:20:02.285] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.285]  length: 0 (resolved future 1)
[13:20:02.285] Relaying remaining futures
[13:20:02.285] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.285] - nx: 1
[13:20:02.285] - relay: TRUE
[13:20:02.285] - stdout: TRUE
[13:20:02.285] - signal: TRUE
[13:20:02.286] - resignal: FALSE
[13:20:02.286] - force: TRUE
[13:20:02.286] - relayed: [n=1] TRUE
[13:20:02.286] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.286] - relayed: [n=1] TRUE
[13:20:02.286] - queued futures: [n=1] TRUE
[13:20:02.286] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.286] resolve() on list ... DONE
[13:20:02.286]  - Number of value chunks collected: 1
[13:20:02.286] Resolving 1 futures (chunks) ... DONE
[13:20:02.287] Reducing values from 1 chunks ...
[13:20:02.287]  - Number of values collected after concatenation: 3
[13:20:02.287]  - Number of values expected: 3
[13:20:02.287] Reducing values from 1 chunks ... DONE
[13:20:02.287] future_lapply() ... DONE
[13:20:02.287] future_by_internal() ... DONE
[13:20:02.288] future_by_internal() ...
- plan('multisession') ...
[13:20:02.289] plan(): Setting new future strategy stack:
[13:20:02.289] List of future strategies:
[13:20:02.289] 1. multisession:
[13:20:02.289]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.289]    - tweaked: FALSE
[13:20:02.289]    - call: plan(strategy)
[13:20:02.289] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:02.289] multisession:
[13:20:02.289] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.289] - tweaked: FALSE
[13:20:02.289] - call: plan(strategy)
[13:20:02.293] getGlobalsAndPackages() ...
[13:20:02.293] Not searching for globals
[13:20:02.293] - globals: [0] <none>
[13:20:02.293] getGlobalsAndPackages() ... DONE
[13:20:02.293] Packages needed by the future expression (n = 0): <none>
[13:20:02.294] Packages needed by future strategies (n = 0): <none>
[13:20:02.294] {
[13:20:02.294]     {
[13:20:02.294]         {
[13:20:02.294]             ...future.startTime <- base::Sys.time()
[13:20:02.294]             {
[13:20:02.294]                 {
[13:20:02.294]                   {
[13:20:02.294]                     base::local({
[13:20:02.294]                       has_future <- base::requireNamespace("future", 
[13:20:02.294]                         quietly = TRUE)
[13:20:02.294]                       if (has_future) {
[13:20:02.294]                         ns <- base::getNamespace("future")
[13:20:02.294]                         version <- ns[[".package"]][["version"]]
[13:20:02.294]                         if (is.null(version)) 
[13:20:02.294]                           version <- utils::packageVersion("future")
[13:20:02.294]                       }
[13:20:02.294]                       else {
[13:20:02.294]                         version <- NULL
[13:20:02.294]                       }
[13:20:02.294]                       if (!has_future || version < "1.8.0") {
[13:20:02.294]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.294]                           "", base::R.version$version.string), 
[13:20:02.294]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.294]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.294]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.294]                             "release", "version")], collapse = " "), 
[13:20:02.294]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.294]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.294]                           info)
[13:20:02.294]                         info <- base::paste(info, collapse = "; ")
[13:20:02.294]                         if (!has_future) {
[13:20:02.294]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.294]                             info)
[13:20:02.294]                         }
[13:20:02.294]                         else {
[13:20:02.294]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.294]                             info, version)
[13:20:02.294]                         }
[13:20:02.294]                         base::stop(msg)
[13:20:02.294]                       }
[13:20:02.294]                     })
[13:20:02.294]                   }
[13:20:02.294]                   options(future.plan = NULL)
[13:20:02.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.294]                 }
[13:20:02.294]                 ...future.workdir <- getwd()
[13:20:02.294]             }
[13:20:02.294]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.294]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.294]         }
[13:20:02.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.294]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.294]             base::names(...future.oldOptions))
[13:20:02.294]     }
[13:20:02.294]     if (FALSE) {
[13:20:02.294]     }
[13:20:02.294]     else {
[13:20:02.294]         if (TRUE) {
[13:20:02.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.294]                 open = "w")
[13:20:02.294]         }
[13:20:02.294]         else {
[13:20:02.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.294]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.294]         }
[13:20:02.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.294]             base::sink(type = "output", split = FALSE)
[13:20:02.294]             base::close(...future.stdout)
[13:20:02.294]         }, add = TRUE)
[13:20:02.294]     }
[13:20:02.294]     ...future.frame <- base::sys.nframe()
[13:20:02.294]     ...future.conditions <- base::list()
[13:20:02.294]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.294]     if (FALSE) {
[13:20:02.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.294]     }
[13:20:02.294]     ...future.result <- base::tryCatch({
[13:20:02.294]         base::withCallingHandlers({
[13:20:02.294]             ...future.value <- base::withVisible(base::local(NA))
[13:20:02.294]             future::FutureResult(value = ...future.value$value, 
[13:20:02.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.294]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.294]                     ...future.globalenv.names))
[13:20:02.294]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.294]         }, condition = base::local({
[13:20:02.294]             c <- base::c
[13:20:02.294]             inherits <- base::inherits
[13:20:02.294]             invokeRestart <- base::invokeRestart
[13:20:02.294]             length <- base::length
[13:20:02.294]             list <- base::list
[13:20:02.294]             seq.int <- base::seq.int
[13:20:02.294]             signalCondition <- base::signalCondition
[13:20:02.294]             sys.calls <- base::sys.calls
[13:20:02.294]             `[[` <- base::`[[`
[13:20:02.294]             `+` <- base::`+`
[13:20:02.294]             `<<-` <- base::`<<-`
[13:20:02.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.294]                   3L)]
[13:20:02.294]             }
[13:20:02.294]             function(cond) {
[13:20:02.294]                 is_error <- inherits(cond, "error")
[13:20:02.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.294]                   NULL)
[13:20:02.294]                 if (is_error) {
[13:20:02.294]                   sessionInformation <- function() {
[13:20:02.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.294]                       search = base::search(), system = base::Sys.info())
[13:20:02.294]                   }
[13:20:02.294]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.294]                     cond$call), session = sessionInformation(), 
[13:20:02.294]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.294]                   signalCondition(cond)
[13:20:02.294]                 }
[13:20:02.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.294]                 "immediateCondition"))) {
[13:20:02.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.294]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.294]                   if (TRUE && !signal) {
[13:20:02.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.294]                     {
[13:20:02.294]                       inherits <- base::inherits
[13:20:02.294]                       invokeRestart <- base::invokeRestart
[13:20:02.294]                       is.null <- base::is.null
[13:20:02.294]                       muffled <- FALSE
[13:20:02.294]                       if (inherits(cond, "message")) {
[13:20:02.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.294]                         if (muffled) 
[13:20:02.294]                           invokeRestart("muffleMessage")
[13:20:02.294]                       }
[13:20:02.294]                       else if (inherits(cond, "warning")) {
[13:20:02.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.294]                         if (muffled) 
[13:20:02.294]                           invokeRestart("muffleWarning")
[13:20:02.294]                       }
[13:20:02.294]                       else if (inherits(cond, "condition")) {
[13:20:02.294]                         if (!is.null(pattern)) {
[13:20:02.294]                           computeRestarts <- base::computeRestarts
[13:20:02.294]                           grepl <- base::grepl
[13:20:02.294]                           restarts <- computeRestarts(cond)
[13:20:02.294]                           for (restart in restarts) {
[13:20:02.294]                             name <- restart$name
[13:20:02.294]                             if (is.null(name)) 
[13:20:02.294]                               next
[13:20:02.294]                             if (!grepl(pattern, name)) 
[13:20:02.294]                               next
[13:20:02.294]                             invokeRestart(restart)
[13:20:02.294]                             muffled <- TRUE
[13:20:02.294]                             break
[13:20:02.294]                           }
[13:20:02.294]                         }
[13:20:02.294]                       }
[13:20:02.294]                       invisible(muffled)
[13:20:02.294]                     }
[13:20:02.294]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.294]                   }
[13:20:02.294]                 }
[13:20:02.294]                 else {
[13:20:02.294]                   if (TRUE) {
[13:20:02.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.294]                     {
[13:20:02.294]                       inherits <- base::inherits
[13:20:02.294]                       invokeRestart <- base::invokeRestart
[13:20:02.294]                       is.null <- base::is.null
[13:20:02.294]                       muffled <- FALSE
[13:20:02.294]                       if (inherits(cond, "message")) {
[13:20:02.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.294]                         if (muffled) 
[13:20:02.294]                           invokeRestart("muffleMessage")
[13:20:02.294]                       }
[13:20:02.294]                       else if (inherits(cond, "warning")) {
[13:20:02.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.294]                         if (muffled) 
[13:20:02.294]                           invokeRestart("muffleWarning")
[13:20:02.294]                       }
[13:20:02.294]                       else if (inherits(cond, "condition")) {
[13:20:02.294]                         if (!is.null(pattern)) {
[13:20:02.294]                           computeRestarts <- base::computeRestarts
[13:20:02.294]                           grepl <- base::grepl
[13:20:02.294]                           restarts <- computeRestarts(cond)
[13:20:02.294]                           for (restart in restarts) {
[13:20:02.294]                             name <- restart$name
[13:20:02.294]                             if (is.null(name)) 
[13:20:02.294]                               next
[13:20:02.294]                             if (!grepl(pattern, name)) 
[13:20:02.294]                               next
[13:20:02.294]                             invokeRestart(restart)
[13:20:02.294]                             muffled <- TRUE
[13:20:02.294]                             break
[13:20:02.294]                           }
[13:20:02.294]                         }
[13:20:02.294]                       }
[13:20:02.294]                       invisible(muffled)
[13:20:02.294]                     }
[13:20:02.294]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.294]                   }
[13:20:02.294]                 }
[13:20:02.294]             }
[13:20:02.294]         }))
[13:20:02.294]     }, error = function(ex) {
[13:20:02.294]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.294]                 ...future.rng), started = ...future.startTime, 
[13:20:02.294]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.294]             version = "1.8"), class = "FutureResult")
[13:20:02.294]     }, finally = {
[13:20:02.294]         if (!identical(...future.workdir, getwd())) 
[13:20:02.294]             setwd(...future.workdir)
[13:20:02.294]         {
[13:20:02.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.294]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.294]             }
[13:20:02.294]             base::options(...future.oldOptions)
[13:20:02.294]             if (.Platform$OS.type == "windows") {
[13:20:02.294]                 old_names <- names(...future.oldEnvVars)
[13:20:02.294]                 envs <- base::Sys.getenv()
[13:20:02.294]                 names <- names(envs)
[13:20:02.294]                 common <- intersect(names, old_names)
[13:20:02.294]                 added <- setdiff(names, old_names)
[13:20:02.294]                 removed <- setdiff(old_names, names)
[13:20:02.294]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.294]                   envs[common]]
[13:20:02.294]                 NAMES <- toupper(changed)
[13:20:02.294]                 args <- list()
[13:20:02.294]                 for (kk in seq_along(NAMES)) {
[13:20:02.294]                   name <- changed[[kk]]
[13:20:02.294]                   NAME <- NAMES[[kk]]
[13:20:02.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.294]                     next
[13:20:02.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.294]                 }
[13:20:02.294]                 NAMES <- toupper(added)
[13:20:02.294]                 for (kk in seq_along(NAMES)) {
[13:20:02.294]                   name <- added[[kk]]
[13:20:02.294]                   NAME <- NAMES[[kk]]
[13:20:02.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.294]                     next
[13:20:02.294]                   args[[name]] <- ""
[13:20:02.294]                 }
[13:20:02.294]                 NAMES <- toupper(removed)
[13:20:02.294]                 for (kk in seq_along(NAMES)) {
[13:20:02.294]                   name <- removed[[kk]]
[13:20:02.294]                   NAME <- NAMES[[kk]]
[13:20:02.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.294]                     next
[13:20:02.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.294]                 }
[13:20:02.294]                 if (length(args) > 0) 
[13:20:02.294]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.294]             }
[13:20:02.294]             else {
[13:20:02.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.294]             }
[13:20:02.294]             {
[13:20:02.294]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.294]                   0L) {
[13:20:02.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.294]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.294]                   base::options(opts)
[13:20:02.294]                 }
[13:20:02.294]                 {
[13:20:02.294]                   {
[13:20:02.294]                     NULL
[13:20:02.294]                     RNGkind("Mersenne-Twister")
[13:20:02.294]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.294]                       inherits = FALSE)
[13:20:02.294]                   }
[13:20:02.294]                   options(future.plan = NULL)
[13:20:02.294]                   if (is.na(NA_character_)) 
[13:20:02.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.294]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.294]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.294]                     envir = parent.frame()) 
[13:20:02.294]                   {
[13:20:02.294]                     if (is.function(workers)) 
[13:20:02.294]                       workers <- workers()
[13:20:02.294]                     workers <- structure(as.integer(workers), 
[13:20:02.294]                       class = class(workers))
[13:20:02.294]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.294]                       workers >= 1)
[13:20:02.294]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.294]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.294]                     }
[13:20:02.294]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.294]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.294]                       envir = envir)
[13:20:02.294]                     if (!future$lazy) 
[13:20:02.294]                       future <- run(future)
[13:20:02.294]                     invisible(future)
[13:20:02.294]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.294]                 }
[13:20:02.294]             }
[13:20:02.294]         }
[13:20:02.294]     })
[13:20:02.294]     if (TRUE) {
[13:20:02.294]         base::sink(type = "output", split = FALSE)
[13:20:02.294]         if (TRUE) {
[13:20:02.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.294]         }
[13:20:02.294]         else {
[13:20:02.294]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.294]         }
[13:20:02.294]         base::close(...future.stdout)
[13:20:02.294]         ...future.stdout <- NULL
[13:20:02.294]     }
[13:20:02.294]     ...future.result$conditions <- ...future.conditions
[13:20:02.294]     ...future.result$finished <- base::Sys.time()
[13:20:02.294]     ...future.result
[13:20:02.294] }
[13:20:02.296] plan(): Setting new future strategy stack:
[13:20:02.296] List of future strategies:
[13:20:02.296] 1. sequential:
[13:20:02.296]    - args: function (..., envir = parent.frame())
[13:20:02.296]    - tweaked: FALSE
[13:20:02.296]    - call: NULL
[13:20:02.296] plan(): nbrOfWorkers() = 1
[13:20:02.297] plan(): Setting new future strategy stack:
[13:20:02.299] List of future strategies:
[13:20:02.299] 1. multisession:
[13:20:02.299]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.299]    - tweaked: FALSE
[13:20:02.299]    - call: plan(strategy)
[13:20:02.303] plan(): nbrOfWorkers() = 1
[13:20:02.303] SequentialFuture started (and completed)
[13:20:02.303] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:02.306] plan(): nbrOfWorkers() = 1
[13:20:02.307] future_by_internal() ...
[13:20:02.307] future_lapply() ...
[13:20:02.311] Number of chunks: 1
[13:20:02.311] getGlobalsAndPackagesXApply() ...
[13:20:02.311]  - future.globals: TRUE
[13:20:02.311] getGlobalsAndPackages() ...
[13:20:02.311] Searching for globals...
[13:20:02.312] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.312] Searching for globals ... DONE
[13:20:02.312] Resolving globals: FALSE
[13:20:02.313] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.313] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.313] - globals: [1] ‘FUN’
[13:20:02.313] 
[13:20:02.313] getGlobalsAndPackages() ... DONE
[13:20:02.313]  - globals found/used: [n=1] ‘FUN’
[13:20:02.314]  - needed namespaces: [n=0] 
[13:20:02.314] Finding globals ... DONE
[13:20:02.314]  - use_args: TRUE
[13:20:02.314]  - Getting '...' globals ...
[13:20:02.314] resolve() on list ...
[13:20:02.314]  recursive: 0
[13:20:02.314]  length: 1
[13:20:02.314]  elements: ‘...’
[13:20:02.315]  length: 0 (resolved future 1)
[13:20:02.315] resolve() on list ... DONE
[13:20:02.315]    - '...' content: [n=0] 
[13:20:02.315] List of 1
[13:20:02.315]  $ ...: list()
[13:20:02.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.315]  - attr(*, "where")=List of 1
[13:20:02.315]   ..$ ...:<environment: 0x55acedd86ae8> 
[13:20:02.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.315]  - attr(*, "resolved")= logi TRUE
[13:20:02.315]  - attr(*, "total_size")= num NA
[13:20:02.317]  - Getting '...' globals ... DONE
[13:20:02.318] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.318] List of 2
[13:20:02.318]  $ ...future.FUN:function (object, ...)  
[13:20:02.318]  $ ...          : list()
[13:20:02.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.318]  - attr(*, "where")=List of 2
[13:20:02.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.318]   ..$ ...          :<environment: 0x55acedd86ae8> 
[13:20:02.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.318]  - attr(*, "resolved")= logi FALSE
[13:20:02.318]  - attr(*, "total_size")= num 1240
[13:20:02.320] Packages to be attached in all futures: [n=0] 
[13:20:02.321] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.321] Number of futures (= number of chunks): 1
[13:20:02.321] Launching 1 futures (chunks) ...
[13:20:02.321] Chunk #1 of 1 ...
[13:20:02.321]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.321] getGlobalsAndPackages() ...
[13:20:02.321] Searching for globals...
[13:20:02.322] 
[13:20:02.322] Searching for globals ... DONE
[13:20:02.322] - globals: [0] <none>
[13:20:02.322] getGlobalsAndPackages() ... DONE
[13:20:02.322]    + additional globals found: [n=0] 
[13:20:02.322]    + additional namespaces needed: [n=0] 
[13:20:02.322]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.322]  - seeds: <none>
[13:20:02.322]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.323] getGlobalsAndPackages() ...
[13:20:02.323] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.323] Resolving globals: FALSE
[13:20:02.323] Tweak future expression to call with '...' arguments ...
[13:20:02.323] {
[13:20:02.323]     do.call(function(...) {
[13:20:02.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.323]             on.exit(options(oopts), add = TRUE)
[13:20:02.323]         }
[13:20:02.323]         {
[13:20:02.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.323]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.323]             })
[13:20:02.323]         }
[13:20:02.323]     }, args = future.call.arguments)
[13:20:02.323] }
[13:20:02.323] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.324] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.324] 
[13:20:02.324] getGlobalsAndPackages() ... DONE
[13:20:02.324] run() for ‘Future’ ...
[13:20:02.324] - state: ‘created’
[13:20:02.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.328]   - Field: ‘label’
[13:20:02.329]   - Field: ‘local’
[13:20:02.330]   - Field: ‘owner’
[13:20:02.331]   - Field: ‘envir’
[13:20:02.331]   - Field: ‘packages’
[13:20:02.331]   - Field: ‘gc’
[13:20:02.331]   - Field: ‘conditions’
[13:20:02.331]   - Field: ‘expr’
[13:20:02.331]   - Field: ‘uuid’
[13:20:02.331]   - Field: ‘seed’
[13:20:02.331]   - Field: ‘version’
[13:20:02.332]   - Field: ‘result’
[13:20:02.332]   - Field: ‘asynchronous’
[13:20:02.332]   - Field: ‘calls’
[13:20:02.332]   - Field: ‘globals’
[13:20:02.332]   - Field: ‘stdout’
[13:20:02.332]   - Field: ‘earlySignal’
[13:20:02.332]   - Field: ‘lazy’
[13:20:02.332]   - Field: ‘state’
[13:20:02.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.333] - Launch lazy future ...
[13:20:02.333] Packages needed by the future expression (n = 0): <none>
[13:20:02.333] Packages needed by future strategies (n = 0): <none>
[13:20:02.334] {
[13:20:02.334]     {
[13:20:02.334]         {
[13:20:02.334]             ...future.startTime <- base::Sys.time()
[13:20:02.334]             {
[13:20:02.334]                 {
[13:20:02.334]                   {
[13:20:02.334]                     base::local({
[13:20:02.334]                       has_future <- base::requireNamespace("future", 
[13:20:02.334]                         quietly = TRUE)
[13:20:02.334]                       if (has_future) {
[13:20:02.334]                         ns <- base::getNamespace("future")
[13:20:02.334]                         version <- ns[[".package"]][["version"]]
[13:20:02.334]                         if (is.null(version)) 
[13:20:02.334]                           version <- utils::packageVersion("future")
[13:20:02.334]                       }
[13:20:02.334]                       else {
[13:20:02.334]                         version <- NULL
[13:20:02.334]                       }
[13:20:02.334]                       if (!has_future || version < "1.8.0") {
[13:20:02.334]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.334]                           "", base::R.version$version.string), 
[13:20:02.334]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.334]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.334]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.334]                             "release", "version")], collapse = " "), 
[13:20:02.334]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.334]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.334]                           info)
[13:20:02.334]                         info <- base::paste(info, collapse = "; ")
[13:20:02.334]                         if (!has_future) {
[13:20:02.334]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.334]                             info)
[13:20:02.334]                         }
[13:20:02.334]                         else {
[13:20:02.334]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.334]                             info, version)
[13:20:02.334]                         }
[13:20:02.334]                         base::stop(msg)
[13:20:02.334]                       }
[13:20:02.334]                     })
[13:20:02.334]                   }
[13:20:02.334]                   options(future.plan = NULL)
[13:20:02.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.334]                 }
[13:20:02.334]                 ...future.workdir <- getwd()
[13:20:02.334]             }
[13:20:02.334]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.334]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.334]         }
[13:20:02.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.334]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.334]             base::names(...future.oldOptions))
[13:20:02.334]     }
[13:20:02.334]     if (FALSE) {
[13:20:02.334]     }
[13:20:02.334]     else {
[13:20:02.334]         if (TRUE) {
[13:20:02.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.334]                 open = "w")
[13:20:02.334]         }
[13:20:02.334]         else {
[13:20:02.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.334]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.334]         }
[13:20:02.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.334]             base::sink(type = "output", split = FALSE)
[13:20:02.334]             base::close(...future.stdout)
[13:20:02.334]         }, add = TRUE)
[13:20:02.334]     }
[13:20:02.334]     ...future.frame <- base::sys.nframe()
[13:20:02.334]     ...future.conditions <- base::list()
[13:20:02.334]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.334]     if (FALSE) {
[13:20:02.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.334]     }
[13:20:02.334]     ...future.result <- base::tryCatch({
[13:20:02.334]         base::withCallingHandlers({
[13:20:02.334]             ...future.value <- base::withVisible(base::local({
[13:20:02.334]                 do.call(function(...) {
[13:20:02.334]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.334]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.334]                     ...future.globals.maxSize)) {
[13:20:02.334]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.334]                     on.exit(options(oopts), add = TRUE)
[13:20:02.334]                   }
[13:20:02.334]                   {
[13:20:02.334]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.334]                       FUN = function(jj) {
[13:20:02.334]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.334]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.334]                       })
[13:20:02.334]                   }
[13:20:02.334]                 }, args = future.call.arguments)
[13:20:02.334]             }))
[13:20:02.334]             future::FutureResult(value = ...future.value$value, 
[13:20:02.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.334]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.334]                     ...future.globalenv.names))
[13:20:02.334]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.334]         }, condition = base::local({
[13:20:02.334]             c <- base::c
[13:20:02.334]             inherits <- base::inherits
[13:20:02.334]             invokeRestart <- base::invokeRestart
[13:20:02.334]             length <- base::length
[13:20:02.334]             list <- base::list
[13:20:02.334]             seq.int <- base::seq.int
[13:20:02.334]             signalCondition <- base::signalCondition
[13:20:02.334]             sys.calls <- base::sys.calls
[13:20:02.334]             `[[` <- base::`[[`
[13:20:02.334]             `+` <- base::`+`
[13:20:02.334]             `<<-` <- base::`<<-`
[13:20:02.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.334]                   3L)]
[13:20:02.334]             }
[13:20:02.334]             function(cond) {
[13:20:02.334]                 is_error <- inherits(cond, "error")
[13:20:02.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.334]                   NULL)
[13:20:02.334]                 if (is_error) {
[13:20:02.334]                   sessionInformation <- function() {
[13:20:02.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.334]                       search = base::search(), system = base::Sys.info())
[13:20:02.334]                   }
[13:20:02.334]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.334]                     cond$call), session = sessionInformation(), 
[13:20:02.334]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.334]                   signalCondition(cond)
[13:20:02.334]                 }
[13:20:02.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.334]                 "immediateCondition"))) {
[13:20:02.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.334]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.334]                   if (TRUE && !signal) {
[13:20:02.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.334]                     {
[13:20:02.334]                       inherits <- base::inherits
[13:20:02.334]                       invokeRestart <- base::invokeRestart
[13:20:02.334]                       is.null <- base::is.null
[13:20:02.334]                       muffled <- FALSE
[13:20:02.334]                       if (inherits(cond, "message")) {
[13:20:02.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.334]                         if (muffled) 
[13:20:02.334]                           invokeRestart("muffleMessage")
[13:20:02.334]                       }
[13:20:02.334]                       else if (inherits(cond, "warning")) {
[13:20:02.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.334]                         if (muffled) 
[13:20:02.334]                           invokeRestart("muffleWarning")
[13:20:02.334]                       }
[13:20:02.334]                       else if (inherits(cond, "condition")) {
[13:20:02.334]                         if (!is.null(pattern)) {
[13:20:02.334]                           computeRestarts <- base::computeRestarts
[13:20:02.334]                           grepl <- base::grepl
[13:20:02.334]                           restarts <- computeRestarts(cond)
[13:20:02.334]                           for (restart in restarts) {
[13:20:02.334]                             name <- restart$name
[13:20:02.334]                             if (is.null(name)) 
[13:20:02.334]                               next
[13:20:02.334]                             if (!grepl(pattern, name)) 
[13:20:02.334]                               next
[13:20:02.334]                             invokeRestart(restart)
[13:20:02.334]                             muffled <- TRUE
[13:20:02.334]                             break
[13:20:02.334]                           }
[13:20:02.334]                         }
[13:20:02.334]                       }
[13:20:02.334]                       invisible(muffled)
[13:20:02.334]                     }
[13:20:02.334]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.334]                   }
[13:20:02.334]                 }
[13:20:02.334]                 else {
[13:20:02.334]                   if (TRUE) {
[13:20:02.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.334]                     {
[13:20:02.334]                       inherits <- base::inherits
[13:20:02.334]                       invokeRestart <- base::invokeRestart
[13:20:02.334]                       is.null <- base::is.null
[13:20:02.334]                       muffled <- FALSE
[13:20:02.334]                       if (inherits(cond, "message")) {
[13:20:02.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.334]                         if (muffled) 
[13:20:02.334]                           invokeRestart("muffleMessage")
[13:20:02.334]                       }
[13:20:02.334]                       else if (inherits(cond, "warning")) {
[13:20:02.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.334]                         if (muffled) 
[13:20:02.334]                           invokeRestart("muffleWarning")
[13:20:02.334]                       }
[13:20:02.334]                       else if (inherits(cond, "condition")) {
[13:20:02.334]                         if (!is.null(pattern)) {
[13:20:02.334]                           computeRestarts <- base::computeRestarts
[13:20:02.334]                           grepl <- base::grepl
[13:20:02.334]                           restarts <- computeRestarts(cond)
[13:20:02.334]                           for (restart in restarts) {
[13:20:02.334]                             name <- restart$name
[13:20:02.334]                             if (is.null(name)) 
[13:20:02.334]                               next
[13:20:02.334]                             if (!grepl(pattern, name)) 
[13:20:02.334]                               next
[13:20:02.334]                             invokeRestart(restart)
[13:20:02.334]                             muffled <- TRUE
[13:20:02.334]                             break
[13:20:02.334]                           }
[13:20:02.334]                         }
[13:20:02.334]                       }
[13:20:02.334]                       invisible(muffled)
[13:20:02.334]                     }
[13:20:02.334]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.334]                   }
[13:20:02.334]                 }
[13:20:02.334]             }
[13:20:02.334]         }))
[13:20:02.334]     }, error = function(ex) {
[13:20:02.334]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.334]                 ...future.rng), started = ...future.startTime, 
[13:20:02.334]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.334]             version = "1.8"), class = "FutureResult")
[13:20:02.334]     }, finally = {
[13:20:02.334]         if (!identical(...future.workdir, getwd())) 
[13:20:02.334]             setwd(...future.workdir)
[13:20:02.334]         {
[13:20:02.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.334]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.334]             }
[13:20:02.334]             base::options(...future.oldOptions)
[13:20:02.334]             if (.Platform$OS.type == "windows") {
[13:20:02.334]                 old_names <- names(...future.oldEnvVars)
[13:20:02.334]                 envs <- base::Sys.getenv()
[13:20:02.334]                 names <- names(envs)
[13:20:02.334]                 common <- intersect(names, old_names)
[13:20:02.334]                 added <- setdiff(names, old_names)
[13:20:02.334]                 removed <- setdiff(old_names, names)
[13:20:02.334]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.334]                   envs[common]]
[13:20:02.334]                 NAMES <- toupper(changed)
[13:20:02.334]                 args <- list()
[13:20:02.334]                 for (kk in seq_along(NAMES)) {
[13:20:02.334]                   name <- changed[[kk]]
[13:20:02.334]                   NAME <- NAMES[[kk]]
[13:20:02.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.334]                     next
[13:20:02.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.334]                 }
[13:20:02.334]                 NAMES <- toupper(added)
[13:20:02.334]                 for (kk in seq_along(NAMES)) {
[13:20:02.334]                   name <- added[[kk]]
[13:20:02.334]                   NAME <- NAMES[[kk]]
[13:20:02.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.334]                     next
[13:20:02.334]                   args[[name]] <- ""
[13:20:02.334]                 }
[13:20:02.334]                 NAMES <- toupper(removed)
[13:20:02.334]                 for (kk in seq_along(NAMES)) {
[13:20:02.334]                   name <- removed[[kk]]
[13:20:02.334]                   NAME <- NAMES[[kk]]
[13:20:02.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.334]                     next
[13:20:02.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.334]                 }
[13:20:02.334]                 if (length(args) > 0) 
[13:20:02.334]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.334]             }
[13:20:02.334]             else {
[13:20:02.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.334]             }
[13:20:02.334]             {
[13:20:02.334]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.334]                   0L) {
[13:20:02.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.334]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.334]                   base::options(opts)
[13:20:02.334]                 }
[13:20:02.334]                 {
[13:20:02.334]                   {
[13:20:02.334]                     NULL
[13:20:02.334]                     RNGkind("Mersenne-Twister")
[13:20:02.334]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.334]                       inherits = FALSE)
[13:20:02.334]                   }
[13:20:02.334]                   options(future.plan = NULL)
[13:20:02.334]                   if (is.na(NA_character_)) 
[13:20:02.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.334]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.334]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.334]                     envir = parent.frame()) 
[13:20:02.334]                   {
[13:20:02.334]                     if (is.function(workers)) 
[13:20:02.334]                       workers <- workers()
[13:20:02.334]                     workers <- structure(as.integer(workers), 
[13:20:02.334]                       class = class(workers))
[13:20:02.334]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.334]                       workers >= 1)
[13:20:02.334]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.334]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.334]                     }
[13:20:02.334]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.334]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.334]                       envir = envir)
[13:20:02.334]                     if (!future$lazy) 
[13:20:02.334]                       future <- run(future)
[13:20:02.334]                     invisible(future)
[13:20:02.334]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.334]                 }
[13:20:02.334]             }
[13:20:02.334]         }
[13:20:02.334]     })
[13:20:02.334]     if (TRUE) {
[13:20:02.334]         base::sink(type = "output", split = FALSE)
[13:20:02.334]         if (TRUE) {
[13:20:02.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.334]         }
[13:20:02.334]         else {
[13:20:02.334]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.334]         }
[13:20:02.334]         base::close(...future.stdout)
[13:20:02.334]         ...future.stdout <- NULL
[13:20:02.334]     }
[13:20:02.334]     ...future.result$conditions <- ...future.conditions
[13:20:02.334]     ...future.result$finished <- base::Sys.time()
[13:20:02.334]     ...future.result
[13:20:02.334] }
[13:20:02.335] assign_globals() ...
[13:20:02.336] List of 5
[13:20:02.336]  $ ...future.FUN            :function (object, ...)  
[13:20:02.336]  $ future.call.arguments    : list()
[13:20:02.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.336]  $ ...future.elements_ii    :List of 3
[13:20:02.336]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.336]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.336]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.336]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.336]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.336]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.336]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.336]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.336]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.336]  $ ...future.seeds_ii       : NULL
[13:20:02.336]  $ ...future.globals.maxSize: NULL
[13:20:02.336]  - attr(*, "where")=List of 5
[13:20:02.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.336]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.336]  - attr(*, "resolved")= logi FALSE
[13:20:02.336]  - attr(*, "total_size")= num 1240
[13:20:02.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.336]  - attr(*, "already-done")= logi TRUE
[13:20:02.343] - copied ‘...future.FUN’ to environment
[13:20:02.343] - copied ‘future.call.arguments’ to environment
[13:20:02.344] - copied ‘...future.elements_ii’ to environment
[13:20:02.344] - copied ‘...future.seeds_ii’ to environment
[13:20:02.344] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.344] assign_globals() ... done
[13:20:02.344] plan(): Setting new future strategy stack:
[13:20:02.344] List of future strategies:
[13:20:02.344] 1. sequential:
[13:20:02.344]    - args: function (..., envir = parent.frame())
[13:20:02.344]    - tweaked: FALSE
[13:20:02.344]    - call: NULL
[13:20:02.345] plan(): nbrOfWorkers() = 1
[13:20:02.347] plan(): Setting new future strategy stack:
[13:20:02.347] List of future strategies:
[13:20:02.347] 1. multisession:
[13:20:02.347]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.347]    - tweaked: FALSE
[13:20:02.347]    - call: plan(strategy)
[13:20:02.350] plan(): nbrOfWorkers() = 1
[13:20:02.351] SequentialFuture started (and completed)
[13:20:02.351] - Launch lazy future ... done
[13:20:02.351] run() for ‘SequentialFuture’ ... done
[13:20:02.351] Created future:
[13:20:02.351] SequentialFuture:
[13:20:02.351] Label: ‘future_by-1’
[13:20:02.351] Expression:
[13:20:02.351] {
[13:20:02.351]     do.call(function(...) {
[13:20:02.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.351]             on.exit(options(oopts), add = TRUE)
[13:20:02.351]         }
[13:20:02.351]         {
[13:20:02.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.351]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.351]             })
[13:20:02.351]         }
[13:20:02.351]     }, args = future.call.arguments)
[13:20:02.351] }
[13:20:02.351] Lazy evaluation: FALSE
[13:20:02.351] Asynchronous evaluation: FALSE
[13:20:02.351] Local evaluation: TRUE
[13:20:02.351] Environment: R_GlobalEnv
[13:20:02.351] Capture standard output: TRUE
[13:20:02.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.351] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.351] Packages: <none>
[13:20:02.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.351] Resolved: TRUE
[13:20:02.351] Value: 4.62 KiB of class ‘list’
[13:20:02.351] Early signaling: FALSE
[13:20:02.351] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.351] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.352] Chunk #1 of 1 ... DONE
[13:20:02.353] Launching 1 futures (chunks) ... DONE
[13:20:02.353] Resolving 1 futures (chunks) ...
[13:20:02.353] resolve() on list ...
[13:20:02.353]  recursive: 0
[13:20:02.353]  length: 1
[13:20:02.353] 
[13:20:02.353] resolved() for ‘SequentialFuture’ ...
[13:20:02.353] - state: ‘finished’
[13:20:02.353] - run: TRUE
[13:20:02.353] - result: ‘FutureResult’
[13:20:02.354] resolved() for ‘SequentialFuture’ ... done
[13:20:02.354] Future #1
[13:20:02.354] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.354] - nx: 1
[13:20:02.354] - relay: TRUE
[13:20:02.354] - stdout: TRUE
[13:20:02.354] - signal: TRUE
[13:20:02.354] - resignal: FALSE
[13:20:02.354] - force: TRUE
[13:20:02.354] - relayed: [n=1] FALSE
[13:20:02.354] - queued futures: [n=1] FALSE
[13:20:02.355]  - until=1
[13:20:02.355]  - relaying element #1
[13:20:02.355] - relayed: [n=1] TRUE
[13:20:02.355] - queued futures: [n=1] TRUE
[13:20:02.357] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.357]  length: 0 (resolved future 1)
[13:20:02.357] Relaying remaining futures
[13:20:02.357] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.357] - nx: 1
[13:20:02.357] - relay: TRUE
[13:20:02.357] - stdout: TRUE
[13:20:02.357] - signal: TRUE
[13:20:02.358] - resignal: FALSE
[13:20:02.358] - force: TRUE
[13:20:02.358] - relayed: [n=1] TRUE
[13:20:02.358] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.358] - relayed: [n=1] TRUE
[13:20:02.358] - queued futures: [n=1] TRUE
[13:20:02.358] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.358] resolve() on list ... DONE
[13:20:02.359]  - Number of value chunks collected: 1
[13:20:02.359] Resolving 1 futures (chunks) ... DONE
[13:20:02.359] Reducing values from 1 chunks ...
[13:20:02.359]  - Number of values collected after concatenation: 3
[13:20:02.359]  - Number of values expected: 3
[13:20:02.359] Reducing values from 1 chunks ... DONE
[13:20:02.359] future_lapply() ... DONE
[13:20:02.359] future_by_internal() ... DONE
[13:20:02.360] future_by_internal() ...
[13:20:02.360] future_lapply() ...
[13:20:02.364] Number of chunks: 1
[13:20:02.364] getGlobalsAndPackagesXApply() ...
[13:20:02.364]  - future.globals: TRUE
[13:20:02.364] getGlobalsAndPackages() ...
[13:20:02.364] Searching for globals...
[13:20:02.366] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.366] Searching for globals ... DONE
[13:20:02.366] Resolving globals: FALSE
[13:20:02.366] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.367] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.367] - globals: [1] ‘FUN’
[13:20:02.367] 
[13:20:02.367] getGlobalsAndPackages() ... DONE
[13:20:02.367]  - globals found/used: [n=1] ‘FUN’
[13:20:02.367]  - needed namespaces: [n=0] 
[13:20:02.367] Finding globals ... DONE
[13:20:02.367]  - use_args: TRUE
[13:20:02.368]  - Getting '...' globals ...
[13:20:02.368] resolve() on list ...
[13:20:02.368]  recursive: 0
[13:20:02.368]  length: 1
[13:20:02.368]  elements: ‘...’
[13:20:02.368]  length: 0 (resolved future 1)
[13:20:02.368] resolve() on list ... DONE
[13:20:02.369]    - '...' content: [n=1] ‘digits’
[13:20:02.369] List of 1
[13:20:02.369]  $ ...:List of 1
[13:20:02.369]   ..$ digits: int 2
[13:20:02.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.369]  - attr(*, "where")=List of 1
[13:20:02.369]   ..$ ...:<environment: 0x55aceddc8520> 
[13:20:02.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.369]  - attr(*, "resolved")= logi TRUE
[13:20:02.369]  - attr(*, "total_size")= num NA
[13:20:02.372]  - Getting '...' globals ... DONE
[13:20:02.372] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.372] List of 2
[13:20:02.372]  $ ...future.FUN:function (object, ...)  
[13:20:02.372]  $ ...          :List of 1
[13:20:02.372]   ..$ digits: int 2
[13:20:02.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.372]  - attr(*, "where")=List of 2
[13:20:02.372]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.372]   ..$ ...          :<environment: 0x55aceddc8520> 
[13:20:02.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.372]  - attr(*, "resolved")= logi FALSE
[13:20:02.372]  - attr(*, "total_size")= num 1296
[13:20:02.375] Packages to be attached in all futures: [n=0] 
[13:20:02.375] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.375] Number of futures (= number of chunks): 1
[13:20:02.376] Launching 1 futures (chunks) ...
[13:20:02.376] Chunk #1 of 1 ...
[13:20:02.376]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.376] getGlobalsAndPackages() ...
[13:20:02.376] Searching for globals...
[13:20:02.376] 
[13:20:02.376] Searching for globals ... DONE
[13:20:02.377] - globals: [0] <none>
[13:20:02.377] getGlobalsAndPackages() ... DONE
[13:20:02.377]    + additional globals found: [n=0] 
[13:20:02.377]    + additional namespaces needed: [n=0] 
[13:20:02.377]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.377]  - seeds: <none>
[13:20:02.377]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.377] getGlobalsAndPackages() ...
[13:20:02.377] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.377] Resolving globals: FALSE
[13:20:02.378] Tweak future expression to call with '...' arguments ...
[13:20:02.378] {
[13:20:02.378]     do.call(function(...) {
[13:20:02.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.378]             on.exit(options(oopts), add = TRUE)
[13:20:02.378]         }
[13:20:02.378]         {
[13:20:02.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.378]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.378]             })
[13:20:02.378]         }
[13:20:02.378]     }, args = future.call.arguments)
[13:20:02.378] }
[13:20:02.378] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.378] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.378] 
[13:20:02.378] getGlobalsAndPackages() ... DONE
[13:20:02.379] run() for ‘Future’ ...
[13:20:02.379] - state: ‘created’
[13:20:02.379] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.385]   - Field: ‘label’
[13:20:02.385]   - Field: ‘local’
[13:20:02.385]   - Field: ‘owner’
[13:20:02.386]   - Field: ‘envir’
[13:20:02.386]   - Field: ‘packages’
[13:20:02.386]   - Field: ‘gc’
[13:20:02.386]   - Field: ‘conditions’
[13:20:02.386]   - Field: ‘expr’
[13:20:02.386]   - Field: ‘uuid’
[13:20:02.386]   - Field: ‘seed’
[13:20:02.386]   - Field: ‘version’
[13:20:02.386]   - Field: ‘result’
[13:20:02.387]   - Field: ‘asynchronous’
[13:20:02.387]   - Field: ‘calls’
[13:20:02.387]   - Field: ‘globals’
[13:20:02.387]   - Field: ‘stdout’
[13:20:02.387]   - Field: ‘earlySignal’
[13:20:02.387]   - Field: ‘lazy’
[13:20:02.387]   - Field: ‘state’
[13:20:02.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.387] - Launch lazy future ...
[13:20:02.388] Packages needed by the future expression (n = 0): <none>
[13:20:02.388] Packages needed by future strategies (n = 0): <none>
[13:20:02.388] {
[13:20:02.388]     {
[13:20:02.388]         {
[13:20:02.388]             ...future.startTime <- base::Sys.time()
[13:20:02.388]             {
[13:20:02.388]                 {
[13:20:02.388]                   {
[13:20:02.388]                     base::local({
[13:20:02.388]                       has_future <- base::requireNamespace("future", 
[13:20:02.388]                         quietly = TRUE)
[13:20:02.388]                       if (has_future) {
[13:20:02.388]                         ns <- base::getNamespace("future")
[13:20:02.388]                         version <- ns[[".package"]][["version"]]
[13:20:02.388]                         if (is.null(version)) 
[13:20:02.388]                           version <- utils::packageVersion("future")
[13:20:02.388]                       }
[13:20:02.388]                       else {
[13:20:02.388]                         version <- NULL
[13:20:02.388]                       }
[13:20:02.388]                       if (!has_future || version < "1.8.0") {
[13:20:02.388]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.388]                           "", base::R.version$version.string), 
[13:20:02.388]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.388]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.388]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.388]                             "release", "version")], collapse = " "), 
[13:20:02.388]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.388]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.388]                           info)
[13:20:02.388]                         info <- base::paste(info, collapse = "; ")
[13:20:02.388]                         if (!has_future) {
[13:20:02.388]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.388]                             info)
[13:20:02.388]                         }
[13:20:02.388]                         else {
[13:20:02.388]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.388]                             info, version)
[13:20:02.388]                         }
[13:20:02.388]                         base::stop(msg)
[13:20:02.388]                       }
[13:20:02.388]                     })
[13:20:02.388]                   }
[13:20:02.388]                   options(future.plan = NULL)
[13:20:02.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.388]                 }
[13:20:02.388]                 ...future.workdir <- getwd()
[13:20:02.388]             }
[13:20:02.388]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.388]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.388]         }
[13:20:02.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.388]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.388]             base::names(...future.oldOptions))
[13:20:02.388]     }
[13:20:02.388]     if (FALSE) {
[13:20:02.388]     }
[13:20:02.388]     else {
[13:20:02.388]         if (TRUE) {
[13:20:02.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.388]                 open = "w")
[13:20:02.388]         }
[13:20:02.388]         else {
[13:20:02.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.388]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.388]         }
[13:20:02.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.388]             base::sink(type = "output", split = FALSE)
[13:20:02.388]             base::close(...future.stdout)
[13:20:02.388]         }, add = TRUE)
[13:20:02.388]     }
[13:20:02.388]     ...future.frame <- base::sys.nframe()
[13:20:02.388]     ...future.conditions <- base::list()
[13:20:02.388]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.388]     if (FALSE) {
[13:20:02.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.388]     }
[13:20:02.388]     ...future.result <- base::tryCatch({
[13:20:02.388]         base::withCallingHandlers({
[13:20:02.388]             ...future.value <- base::withVisible(base::local({
[13:20:02.388]                 do.call(function(...) {
[13:20:02.388]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.388]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.388]                     ...future.globals.maxSize)) {
[13:20:02.388]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.388]                     on.exit(options(oopts), add = TRUE)
[13:20:02.388]                   }
[13:20:02.388]                   {
[13:20:02.388]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.388]                       FUN = function(jj) {
[13:20:02.388]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.388]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.388]                       })
[13:20:02.388]                   }
[13:20:02.388]                 }, args = future.call.arguments)
[13:20:02.388]             }))
[13:20:02.388]             future::FutureResult(value = ...future.value$value, 
[13:20:02.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.388]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.388]                     ...future.globalenv.names))
[13:20:02.388]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.388]         }, condition = base::local({
[13:20:02.388]             c <- base::c
[13:20:02.388]             inherits <- base::inherits
[13:20:02.388]             invokeRestart <- base::invokeRestart
[13:20:02.388]             length <- base::length
[13:20:02.388]             list <- base::list
[13:20:02.388]             seq.int <- base::seq.int
[13:20:02.388]             signalCondition <- base::signalCondition
[13:20:02.388]             sys.calls <- base::sys.calls
[13:20:02.388]             `[[` <- base::`[[`
[13:20:02.388]             `+` <- base::`+`
[13:20:02.388]             `<<-` <- base::`<<-`
[13:20:02.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.388]                   3L)]
[13:20:02.388]             }
[13:20:02.388]             function(cond) {
[13:20:02.388]                 is_error <- inherits(cond, "error")
[13:20:02.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.388]                   NULL)
[13:20:02.388]                 if (is_error) {
[13:20:02.388]                   sessionInformation <- function() {
[13:20:02.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.388]                       search = base::search(), system = base::Sys.info())
[13:20:02.388]                   }
[13:20:02.388]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.388]                     cond$call), session = sessionInformation(), 
[13:20:02.388]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.388]                   signalCondition(cond)
[13:20:02.388]                 }
[13:20:02.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.388]                 "immediateCondition"))) {
[13:20:02.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.388]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.388]                   if (TRUE && !signal) {
[13:20:02.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.388]                     {
[13:20:02.388]                       inherits <- base::inherits
[13:20:02.388]                       invokeRestart <- base::invokeRestart
[13:20:02.388]                       is.null <- base::is.null
[13:20:02.388]                       muffled <- FALSE
[13:20:02.388]                       if (inherits(cond, "message")) {
[13:20:02.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.388]                         if (muffled) 
[13:20:02.388]                           invokeRestart("muffleMessage")
[13:20:02.388]                       }
[13:20:02.388]                       else if (inherits(cond, "warning")) {
[13:20:02.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.388]                         if (muffled) 
[13:20:02.388]                           invokeRestart("muffleWarning")
[13:20:02.388]                       }
[13:20:02.388]                       else if (inherits(cond, "condition")) {
[13:20:02.388]                         if (!is.null(pattern)) {
[13:20:02.388]                           computeRestarts <- base::computeRestarts
[13:20:02.388]                           grepl <- base::grepl
[13:20:02.388]                           restarts <- computeRestarts(cond)
[13:20:02.388]                           for (restart in restarts) {
[13:20:02.388]                             name <- restart$name
[13:20:02.388]                             if (is.null(name)) 
[13:20:02.388]                               next
[13:20:02.388]                             if (!grepl(pattern, name)) 
[13:20:02.388]                               next
[13:20:02.388]                             invokeRestart(restart)
[13:20:02.388]                             muffled <- TRUE
[13:20:02.388]                             break
[13:20:02.388]                           }
[13:20:02.388]                         }
[13:20:02.388]                       }
[13:20:02.388]                       invisible(muffled)
[13:20:02.388]                     }
[13:20:02.388]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.388]                   }
[13:20:02.388]                 }
[13:20:02.388]                 else {
[13:20:02.388]                   if (TRUE) {
[13:20:02.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.388]                     {
[13:20:02.388]                       inherits <- base::inherits
[13:20:02.388]                       invokeRestart <- base::invokeRestart
[13:20:02.388]                       is.null <- base::is.null
[13:20:02.388]                       muffled <- FALSE
[13:20:02.388]                       if (inherits(cond, "message")) {
[13:20:02.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.388]                         if (muffled) 
[13:20:02.388]                           invokeRestart("muffleMessage")
[13:20:02.388]                       }
[13:20:02.388]                       else if (inherits(cond, "warning")) {
[13:20:02.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.388]                         if (muffled) 
[13:20:02.388]                           invokeRestart("muffleWarning")
[13:20:02.388]                       }
[13:20:02.388]                       else if (inherits(cond, "condition")) {
[13:20:02.388]                         if (!is.null(pattern)) {
[13:20:02.388]                           computeRestarts <- base::computeRestarts
[13:20:02.388]                           grepl <- base::grepl
[13:20:02.388]                           restarts <- computeRestarts(cond)
[13:20:02.388]                           for (restart in restarts) {
[13:20:02.388]                             name <- restart$name
[13:20:02.388]                             if (is.null(name)) 
[13:20:02.388]                               next
[13:20:02.388]                             if (!grepl(pattern, name)) 
[13:20:02.388]                               next
[13:20:02.388]                             invokeRestart(restart)
[13:20:02.388]                             muffled <- TRUE
[13:20:02.388]                             break
[13:20:02.388]                           }
[13:20:02.388]                         }
[13:20:02.388]                       }
[13:20:02.388]                       invisible(muffled)
[13:20:02.388]                     }
[13:20:02.388]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.388]                   }
[13:20:02.388]                 }
[13:20:02.388]             }
[13:20:02.388]         }))
[13:20:02.388]     }, error = function(ex) {
[13:20:02.388]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.388]                 ...future.rng), started = ...future.startTime, 
[13:20:02.388]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.388]             version = "1.8"), class = "FutureResult")
[13:20:02.388]     }, finally = {
[13:20:02.388]         if (!identical(...future.workdir, getwd())) 
[13:20:02.388]             setwd(...future.workdir)
[13:20:02.388]         {
[13:20:02.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.388]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.388]             }
[13:20:02.388]             base::options(...future.oldOptions)
[13:20:02.388]             if (.Platform$OS.type == "windows") {
[13:20:02.388]                 old_names <- names(...future.oldEnvVars)
[13:20:02.388]                 envs <- base::Sys.getenv()
[13:20:02.388]                 names <- names(envs)
[13:20:02.388]                 common <- intersect(names, old_names)
[13:20:02.388]                 added <- setdiff(names, old_names)
[13:20:02.388]                 removed <- setdiff(old_names, names)
[13:20:02.388]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.388]                   envs[common]]
[13:20:02.388]                 NAMES <- toupper(changed)
[13:20:02.388]                 args <- list()
[13:20:02.388]                 for (kk in seq_along(NAMES)) {
[13:20:02.388]                   name <- changed[[kk]]
[13:20:02.388]                   NAME <- NAMES[[kk]]
[13:20:02.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.388]                     next
[13:20:02.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.388]                 }
[13:20:02.388]                 NAMES <- toupper(added)
[13:20:02.388]                 for (kk in seq_along(NAMES)) {
[13:20:02.388]                   name <- added[[kk]]
[13:20:02.388]                   NAME <- NAMES[[kk]]
[13:20:02.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.388]                     next
[13:20:02.388]                   args[[name]] <- ""
[13:20:02.388]                 }
[13:20:02.388]                 NAMES <- toupper(removed)
[13:20:02.388]                 for (kk in seq_along(NAMES)) {
[13:20:02.388]                   name <- removed[[kk]]
[13:20:02.388]                   NAME <- NAMES[[kk]]
[13:20:02.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.388]                     next
[13:20:02.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.388]                 }
[13:20:02.388]                 if (length(args) > 0) 
[13:20:02.388]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.388]             }
[13:20:02.388]             else {
[13:20:02.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.388]             }
[13:20:02.388]             {
[13:20:02.388]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.388]                   0L) {
[13:20:02.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.388]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.388]                   base::options(opts)
[13:20:02.388]                 }
[13:20:02.388]                 {
[13:20:02.388]                   {
[13:20:02.388]                     NULL
[13:20:02.388]                     RNGkind("Mersenne-Twister")
[13:20:02.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.388]                       inherits = FALSE)
[13:20:02.388]                   }
[13:20:02.388]                   options(future.plan = NULL)
[13:20:02.388]                   if (is.na(NA_character_)) 
[13:20:02.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.388]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.388]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.388]                     envir = parent.frame()) 
[13:20:02.388]                   {
[13:20:02.388]                     if (is.function(workers)) 
[13:20:02.388]                       workers <- workers()
[13:20:02.388]                     workers <- structure(as.integer(workers), 
[13:20:02.388]                       class = class(workers))
[13:20:02.388]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.388]                       workers >= 1)
[13:20:02.388]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.388]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.388]                     }
[13:20:02.388]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.388]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.388]                       envir = envir)
[13:20:02.388]                     if (!future$lazy) 
[13:20:02.388]                       future <- run(future)
[13:20:02.388]                     invisible(future)
[13:20:02.388]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.388]                 }
[13:20:02.388]             }
[13:20:02.388]         }
[13:20:02.388]     })
[13:20:02.388]     if (TRUE) {
[13:20:02.388]         base::sink(type = "output", split = FALSE)
[13:20:02.388]         if (TRUE) {
[13:20:02.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.388]         }
[13:20:02.388]         else {
[13:20:02.388]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.388]         }
[13:20:02.388]         base::close(...future.stdout)
[13:20:02.388]         ...future.stdout <- NULL
[13:20:02.388]     }
[13:20:02.388]     ...future.result$conditions <- ...future.conditions
[13:20:02.388]     ...future.result$finished <- base::Sys.time()
[13:20:02.388]     ...future.result
[13:20:02.388] }
[13:20:02.390] assign_globals() ...
[13:20:02.390] List of 5
[13:20:02.390]  $ ...future.FUN            :function (object, ...)  
[13:20:02.390]  $ future.call.arguments    :List of 1
[13:20:02.390]   ..$ digits: int 2
[13:20:02.390]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.390]  $ ...future.elements_ii    :List of 6
[13:20:02.390]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:20:02.390]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:20:02.390]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:20:02.390]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:20:02.390]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:20:02.390]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:20:02.390]  $ ...future.seeds_ii       : NULL
[13:20:02.390]  $ ...future.globals.maxSize: NULL
[13:20:02.390]  - attr(*, "where")=List of 5
[13:20:02.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.390]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.390]  - attr(*, "resolved")= logi FALSE
[13:20:02.390]  - attr(*, "total_size")= num 1296
[13:20:02.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.390]  - attr(*, "already-done")= logi TRUE
[13:20:02.397] - copied ‘...future.FUN’ to environment
[13:20:02.397] - copied ‘future.call.arguments’ to environment
[13:20:02.397] - copied ‘...future.elements_ii’ to environment
[13:20:02.397] - copied ‘...future.seeds_ii’ to environment
[13:20:02.397] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.398] assign_globals() ... done
[13:20:02.398] plan(): Setting new future strategy stack:
[13:20:02.398] List of future strategies:
[13:20:02.398] 1. sequential:
[13:20:02.398]    - args: function (..., envir = parent.frame())
[13:20:02.398]    - tweaked: FALSE
[13:20:02.398]    - call: NULL
[13:20:02.398] plan(): nbrOfWorkers() = 1
[13:20:02.400] plan(): Setting new future strategy stack:
[13:20:02.400] List of future strategies:
[13:20:02.400] 1. multisession:
[13:20:02.400]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.400]    - tweaked: FALSE
[13:20:02.400]    - call: plan(strategy)
[13:20:02.403] plan(): nbrOfWorkers() = 1
[13:20:02.403] SequentialFuture started (and completed)
[13:20:02.404] - Launch lazy future ... done
[13:20:02.404] run() for ‘SequentialFuture’ ... done
[13:20:02.404] Created future:
[13:20:02.404] SequentialFuture:
[13:20:02.404] Label: ‘future_by-1’
[13:20:02.404] Expression:
[13:20:02.404] {
[13:20:02.404]     do.call(function(...) {
[13:20:02.404]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.404]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.404]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.404]             on.exit(options(oopts), add = TRUE)
[13:20:02.404]         }
[13:20:02.404]         {
[13:20:02.404]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.404]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.404]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.404]             })
[13:20:02.404]         }
[13:20:02.404]     }, args = future.call.arguments)
[13:20:02.404] }
[13:20:02.404] Lazy evaluation: FALSE
[13:20:02.404] Asynchronous evaluation: FALSE
[13:20:02.404] Local evaluation: TRUE
[13:20:02.404] Environment: R_GlobalEnv
[13:20:02.404] Capture standard output: TRUE
[13:20:02.404] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.404] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.404] Packages: <none>
[13:20:02.404] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.404] Resolved: TRUE
[13:20:02.404] Value: 5.48 KiB of class ‘list’
[13:20:02.404] Early signaling: FALSE
[13:20:02.404] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.404] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.405] Chunk #1 of 1 ... DONE
[13:20:02.405] Launching 1 futures (chunks) ... DONE
[13:20:02.405] Resolving 1 futures (chunks) ...
[13:20:02.405] resolve() on list ...
[13:20:02.405]  recursive: 0
[13:20:02.405]  length: 1
[13:20:02.406] 
[13:20:02.406] resolved() for ‘SequentialFuture’ ...
[13:20:02.406] - state: ‘finished’
[13:20:02.406] - run: TRUE
[13:20:02.406] - result: ‘FutureResult’
[13:20:02.406] resolved() for ‘SequentialFuture’ ... done
[13:20:02.406] Future #1
[13:20:02.406] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.406] - nx: 1
[13:20:02.406] - relay: TRUE
[13:20:02.407] - stdout: TRUE
[13:20:02.407] - signal: TRUE
[13:20:02.407] - resignal: FALSE
[13:20:02.407] - force: TRUE
[13:20:02.407] - relayed: [n=1] FALSE
[13:20:02.407] - queued futures: [n=1] FALSE
[13:20:02.407]  - until=1
[13:20:02.407]  - relaying element #1
[13:20:02.407] - relayed: [n=1] TRUE
[13:20:02.407] - queued futures: [n=1] TRUE
[13:20:02.407] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.408]  length: 0 (resolved future 1)
[13:20:02.408] Relaying remaining futures
[13:20:02.408] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.408] - nx: 1
[13:20:02.409] - relay: TRUE
[13:20:02.410] - stdout: TRUE
[13:20:02.410] - signal: TRUE
[13:20:02.410] - resignal: FALSE
[13:20:02.410] - force: TRUE
[13:20:02.410] - relayed: [n=1] TRUE
[13:20:02.410] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.410] - relayed: [n=1] TRUE
[13:20:02.410] - queued futures: [n=1] TRUE
[13:20:02.410] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.411] resolve() on list ... DONE
[13:20:02.411]  - Number of value chunks collected: 1
[13:20:02.411] Resolving 1 futures (chunks) ... DONE
[13:20:02.411] Reducing values from 1 chunks ...
[13:20:02.411]  - Number of values collected after concatenation: 6
[13:20:02.411]  - Number of values expected: 6
[13:20:02.411] Reducing values from 1 chunks ... DONE
[13:20:02.411] future_lapply() ... DONE
[13:20:02.411] future_by_internal() ... DONE
[13:20:02.413] future_by_internal() ...
[13:20:02.413] future_lapply() ...
[13:20:02.417] Number of chunks: 1
[13:20:02.417] getGlobalsAndPackagesXApply() ...
[13:20:02.417]  - future.globals: TRUE
[13:20:02.418] getGlobalsAndPackages() ...
[13:20:02.418] Searching for globals...
[13:20:02.419] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:02.419] Searching for globals ... DONE
[13:20:02.419] Resolving globals: FALSE
[13:20:02.420] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:20:02.420] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:20:02.421] - globals: [1] ‘FUN’
[13:20:02.421] - packages: [1] ‘stats’
[13:20:02.421] getGlobalsAndPackages() ... DONE
[13:20:02.421]  - globals found/used: [n=1] ‘FUN’
[13:20:02.421]  - needed namespaces: [n=1] ‘stats’
[13:20:02.421] Finding globals ... DONE
[13:20:02.421]  - use_args: TRUE
[13:20:02.421]  - Getting '...' globals ...
[13:20:02.422] resolve() on list ...
[13:20:02.422]  recursive: 0
[13:20:02.422]  length: 1
[13:20:02.422]  elements: ‘...’
[13:20:02.422]  length: 0 (resolved future 1)
[13:20:02.422] resolve() on list ... DONE
[13:20:02.422]    - '...' content: [n=1] ‘singular.ok’
[13:20:02.422] List of 1
[13:20:02.422]  $ ...:List of 1
[13:20:02.422]   ..$ singular.ok: logi FALSE
[13:20:02.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.422]  - attr(*, "where")=List of 1
[13:20:02.422]   ..$ ...:<environment: 0x55aced56ecf8> 
[13:20:02.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.422]  - attr(*, "resolved")= logi TRUE
[13:20:02.422]  - attr(*, "total_size")= num NA
[13:20:02.425]  - Getting '...' globals ... DONE
[13:20:02.426] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.426] List of 2
[13:20:02.426]  $ ...future.FUN:function (x, ...)  
[13:20:02.426]  $ ...          :List of 1
[13:20:02.426]   ..$ singular.ok: logi FALSE
[13:20:02.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.426]  - attr(*, "where")=List of 2
[13:20:02.426]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.426]   ..$ ...          :<environment: 0x55aced56ecf8> 
[13:20:02.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.426]  - attr(*, "resolved")= logi FALSE
[13:20:02.426]  - attr(*, "total_size")= num 5384
[13:20:02.429] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:02.429] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.429] Number of futures (= number of chunks): 1
[13:20:02.429] Launching 1 futures (chunks) ...
[13:20:02.429] Chunk #1 of 1 ...
[13:20:02.430]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.430] getGlobalsAndPackages() ...
[13:20:02.430] Searching for globals...
[13:20:02.430] 
[13:20:02.430] Searching for globals ... DONE
[13:20:02.430] - globals: [0] <none>
[13:20:02.430] getGlobalsAndPackages() ... DONE
[13:20:02.431]    + additional globals found: [n=0] 
[13:20:02.431]    + additional namespaces needed: [n=0] 
[13:20:02.431]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.433]  - seeds: <none>
[13:20:02.433]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.433] getGlobalsAndPackages() ...
[13:20:02.433] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.433] Resolving globals: FALSE
[13:20:02.433] Tweak future expression to call with '...' arguments ...
[13:20:02.434] {
[13:20:02.434]     do.call(function(...) {
[13:20:02.434]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.434]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.434]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.434]             on.exit(options(oopts), add = TRUE)
[13:20:02.434]         }
[13:20:02.434]         {
[13:20:02.434]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.434]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.434]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.434]             })
[13:20:02.434]         }
[13:20:02.434]     }, args = future.call.arguments)
[13:20:02.434] }
[13:20:02.434] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.434] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.435] 
[13:20:02.435] getGlobalsAndPackages() ... DONE
[13:20:02.435] run() for ‘Future’ ...
[13:20:02.435] - state: ‘created’
[13:20:02.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.439] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.439]   - Field: ‘label’
[13:20:02.440]   - Field: ‘local’
[13:20:02.440]   - Field: ‘owner’
[13:20:02.440]   - Field: ‘envir’
[13:20:02.440]   - Field: ‘packages’
[13:20:02.440]   - Field: ‘gc’
[13:20:02.440]   - Field: ‘conditions’
[13:20:02.440]   - Field: ‘expr’
[13:20:02.440]   - Field: ‘uuid’
[13:20:02.440]   - Field: ‘seed’
[13:20:02.441]   - Field: ‘version’
[13:20:02.441]   - Field: ‘result’
[13:20:02.441]   - Field: ‘asynchronous’
[13:20:02.441]   - Field: ‘calls’
[13:20:02.441]   - Field: ‘globals’
[13:20:02.441]   - Field: ‘stdout’
[13:20:02.441]   - Field: ‘earlySignal’
[13:20:02.441]   - Field: ‘lazy’
[13:20:02.441]   - Field: ‘state’
[13:20:02.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.441] - Launch lazy future ...
[13:20:02.442] Packages needed by the future expression (n = 1): ‘stats’
[13:20:02.442] Packages needed by future strategies (n = 0): <none>
[13:20:02.442] {
[13:20:02.442]     {
[13:20:02.442]         {
[13:20:02.442]             ...future.startTime <- base::Sys.time()
[13:20:02.442]             {
[13:20:02.442]                 {
[13:20:02.442]                   {
[13:20:02.442]                     {
[13:20:02.442]                       base::local({
[13:20:02.442]                         has_future <- base::requireNamespace("future", 
[13:20:02.442]                           quietly = TRUE)
[13:20:02.442]                         if (has_future) {
[13:20:02.442]                           ns <- base::getNamespace("future")
[13:20:02.442]                           version <- ns[[".package"]][["version"]]
[13:20:02.442]                           if (is.null(version)) 
[13:20:02.442]                             version <- utils::packageVersion("future")
[13:20:02.442]                         }
[13:20:02.442]                         else {
[13:20:02.442]                           version <- NULL
[13:20:02.442]                         }
[13:20:02.442]                         if (!has_future || version < "1.8.0") {
[13:20:02.442]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.442]                             "", base::R.version$version.string), 
[13:20:02.442]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.442]                               "release", "version")], collapse = " "), 
[13:20:02.442]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.442]                             info)
[13:20:02.442]                           info <- base::paste(info, collapse = "; ")
[13:20:02.442]                           if (!has_future) {
[13:20:02.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.442]                               info)
[13:20:02.442]                           }
[13:20:02.442]                           else {
[13:20:02.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.442]                               info, version)
[13:20:02.442]                           }
[13:20:02.442]                           base::stop(msg)
[13:20:02.442]                         }
[13:20:02.442]                       })
[13:20:02.442]                     }
[13:20:02.442]                     base::local({
[13:20:02.442]                       for (pkg in "stats") {
[13:20:02.442]                         base::loadNamespace(pkg)
[13:20:02.442]                         base::library(pkg, character.only = TRUE)
[13:20:02.442]                       }
[13:20:02.442]                     })
[13:20:02.442]                   }
[13:20:02.442]                   options(future.plan = NULL)
[13:20:02.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.442]                 }
[13:20:02.442]                 ...future.workdir <- getwd()
[13:20:02.442]             }
[13:20:02.442]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.442]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.442]         }
[13:20:02.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.442]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.442]             base::names(...future.oldOptions))
[13:20:02.442]     }
[13:20:02.442]     if (FALSE) {
[13:20:02.442]     }
[13:20:02.442]     else {
[13:20:02.442]         if (TRUE) {
[13:20:02.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.442]                 open = "w")
[13:20:02.442]         }
[13:20:02.442]         else {
[13:20:02.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.442]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.442]         }
[13:20:02.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.442]             base::sink(type = "output", split = FALSE)
[13:20:02.442]             base::close(...future.stdout)
[13:20:02.442]         }, add = TRUE)
[13:20:02.442]     }
[13:20:02.442]     ...future.frame <- base::sys.nframe()
[13:20:02.442]     ...future.conditions <- base::list()
[13:20:02.442]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.442]     if (FALSE) {
[13:20:02.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.442]     }
[13:20:02.442]     ...future.result <- base::tryCatch({
[13:20:02.442]         base::withCallingHandlers({
[13:20:02.442]             ...future.value <- base::withVisible(base::local({
[13:20:02.442]                 do.call(function(...) {
[13:20:02.442]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.442]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.442]                     ...future.globals.maxSize)) {
[13:20:02.442]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.442]                     on.exit(options(oopts), add = TRUE)
[13:20:02.442]                   }
[13:20:02.442]                   {
[13:20:02.442]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.442]                       FUN = function(jj) {
[13:20:02.442]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.442]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.442]                       })
[13:20:02.442]                   }
[13:20:02.442]                 }, args = future.call.arguments)
[13:20:02.442]             }))
[13:20:02.442]             future::FutureResult(value = ...future.value$value, 
[13:20:02.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.442]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.442]                     ...future.globalenv.names))
[13:20:02.442]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.442]         }, condition = base::local({
[13:20:02.442]             c <- base::c
[13:20:02.442]             inherits <- base::inherits
[13:20:02.442]             invokeRestart <- base::invokeRestart
[13:20:02.442]             length <- base::length
[13:20:02.442]             list <- base::list
[13:20:02.442]             seq.int <- base::seq.int
[13:20:02.442]             signalCondition <- base::signalCondition
[13:20:02.442]             sys.calls <- base::sys.calls
[13:20:02.442]             `[[` <- base::`[[`
[13:20:02.442]             `+` <- base::`+`
[13:20:02.442]             `<<-` <- base::`<<-`
[13:20:02.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.442]                   3L)]
[13:20:02.442]             }
[13:20:02.442]             function(cond) {
[13:20:02.442]                 is_error <- inherits(cond, "error")
[13:20:02.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.442]                   NULL)
[13:20:02.442]                 if (is_error) {
[13:20:02.442]                   sessionInformation <- function() {
[13:20:02.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.442]                       search = base::search(), system = base::Sys.info())
[13:20:02.442]                   }
[13:20:02.442]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.442]                     cond$call), session = sessionInformation(), 
[13:20:02.442]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.442]                   signalCondition(cond)
[13:20:02.442]                 }
[13:20:02.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.442]                 "immediateCondition"))) {
[13:20:02.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.442]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.442]                   if (TRUE && !signal) {
[13:20:02.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.442]                     {
[13:20:02.442]                       inherits <- base::inherits
[13:20:02.442]                       invokeRestart <- base::invokeRestart
[13:20:02.442]                       is.null <- base::is.null
[13:20:02.442]                       muffled <- FALSE
[13:20:02.442]                       if (inherits(cond, "message")) {
[13:20:02.442]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.442]                         if (muffled) 
[13:20:02.442]                           invokeRestart("muffleMessage")
[13:20:02.442]                       }
[13:20:02.442]                       else if (inherits(cond, "warning")) {
[13:20:02.442]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.442]                         if (muffled) 
[13:20:02.442]                           invokeRestart("muffleWarning")
[13:20:02.442]                       }
[13:20:02.442]                       else if (inherits(cond, "condition")) {
[13:20:02.442]                         if (!is.null(pattern)) {
[13:20:02.442]                           computeRestarts <- base::computeRestarts
[13:20:02.442]                           grepl <- base::grepl
[13:20:02.442]                           restarts <- computeRestarts(cond)
[13:20:02.442]                           for (restart in restarts) {
[13:20:02.442]                             name <- restart$name
[13:20:02.442]                             if (is.null(name)) 
[13:20:02.442]                               next
[13:20:02.442]                             if (!grepl(pattern, name)) 
[13:20:02.442]                               next
[13:20:02.442]                             invokeRestart(restart)
[13:20:02.442]                             muffled <- TRUE
[13:20:02.442]                             break
[13:20:02.442]                           }
[13:20:02.442]                         }
[13:20:02.442]                       }
[13:20:02.442]                       invisible(muffled)
[13:20:02.442]                     }
[13:20:02.442]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.442]                   }
[13:20:02.442]                 }
[13:20:02.442]                 else {
[13:20:02.442]                   if (TRUE) {
[13:20:02.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.442]                     {
[13:20:02.442]                       inherits <- base::inherits
[13:20:02.442]                       invokeRestart <- base::invokeRestart
[13:20:02.442]                       is.null <- base::is.null
[13:20:02.442]                       muffled <- FALSE
[13:20:02.442]                       if (inherits(cond, "message")) {
[13:20:02.442]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.442]                         if (muffled) 
[13:20:02.442]                           invokeRestart("muffleMessage")
[13:20:02.442]                       }
[13:20:02.442]                       else if (inherits(cond, "warning")) {
[13:20:02.442]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.442]                         if (muffled) 
[13:20:02.442]                           invokeRestart("muffleWarning")
[13:20:02.442]                       }
[13:20:02.442]                       else if (inherits(cond, "condition")) {
[13:20:02.442]                         if (!is.null(pattern)) {
[13:20:02.442]                           computeRestarts <- base::computeRestarts
[13:20:02.442]                           grepl <- base::grepl
[13:20:02.442]                           restarts <- computeRestarts(cond)
[13:20:02.442]                           for (restart in restarts) {
[13:20:02.442]                             name <- restart$name
[13:20:02.442]                             if (is.null(name)) 
[13:20:02.442]                               next
[13:20:02.442]                             if (!grepl(pattern, name)) 
[13:20:02.442]                               next
[13:20:02.442]                             invokeRestart(restart)
[13:20:02.442]                             muffled <- TRUE
[13:20:02.442]                             break
[13:20:02.442]                           }
[13:20:02.442]                         }
[13:20:02.442]                       }
[13:20:02.442]                       invisible(muffled)
[13:20:02.442]                     }
[13:20:02.442]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.442]                   }
[13:20:02.442]                 }
[13:20:02.442]             }
[13:20:02.442]         }))
[13:20:02.442]     }, error = function(ex) {
[13:20:02.442]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.442]                 ...future.rng), started = ...future.startTime, 
[13:20:02.442]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.442]             version = "1.8"), class = "FutureResult")
[13:20:02.442]     }, finally = {
[13:20:02.442]         if (!identical(...future.workdir, getwd())) 
[13:20:02.442]             setwd(...future.workdir)
[13:20:02.442]         {
[13:20:02.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.442]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.442]             }
[13:20:02.442]             base::options(...future.oldOptions)
[13:20:02.442]             if (.Platform$OS.type == "windows") {
[13:20:02.442]                 old_names <- names(...future.oldEnvVars)
[13:20:02.442]                 envs <- base::Sys.getenv()
[13:20:02.442]                 names <- names(envs)
[13:20:02.442]                 common <- intersect(names, old_names)
[13:20:02.442]                 added <- setdiff(names, old_names)
[13:20:02.442]                 removed <- setdiff(old_names, names)
[13:20:02.442]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.442]                   envs[common]]
[13:20:02.442]                 NAMES <- toupper(changed)
[13:20:02.442]                 args <- list()
[13:20:02.442]                 for (kk in seq_along(NAMES)) {
[13:20:02.442]                   name <- changed[[kk]]
[13:20:02.442]                   NAME <- NAMES[[kk]]
[13:20:02.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.442]                     next
[13:20:02.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.442]                 }
[13:20:02.442]                 NAMES <- toupper(added)
[13:20:02.442]                 for (kk in seq_along(NAMES)) {
[13:20:02.442]                   name <- added[[kk]]
[13:20:02.442]                   NAME <- NAMES[[kk]]
[13:20:02.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.442]                     next
[13:20:02.442]                   args[[name]] <- ""
[13:20:02.442]                 }
[13:20:02.442]                 NAMES <- toupper(removed)
[13:20:02.442]                 for (kk in seq_along(NAMES)) {
[13:20:02.442]                   name <- removed[[kk]]
[13:20:02.442]                   NAME <- NAMES[[kk]]
[13:20:02.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.442]                     next
[13:20:02.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.442]                 }
[13:20:02.442]                 if (length(args) > 0) 
[13:20:02.442]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.442]             }
[13:20:02.442]             else {
[13:20:02.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.442]             }
[13:20:02.442]             {
[13:20:02.442]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.442]                   0L) {
[13:20:02.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.442]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.442]                   base::options(opts)
[13:20:02.442]                 }
[13:20:02.442]                 {
[13:20:02.442]                   {
[13:20:02.442]                     NULL
[13:20:02.442]                     RNGkind("Mersenne-Twister")
[13:20:02.442]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.442]                       inherits = FALSE)
[13:20:02.442]                   }
[13:20:02.442]                   options(future.plan = NULL)
[13:20:02.442]                   if (is.na(NA_character_)) 
[13:20:02.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.442]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.442]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.442]                     envir = parent.frame()) 
[13:20:02.442]                   {
[13:20:02.442]                     if (is.function(workers)) 
[13:20:02.442]                       workers <- workers()
[13:20:02.442]                     workers <- structure(as.integer(workers), 
[13:20:02.442]                       class = class(workers))
[13:20:02.442]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.442]                       workers >= 1)
[13:20:02.442]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.442]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.442]                     }
[13:20:02.442]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.442]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.442]                       envir = envir)
[13:20:02.442]                     if (!future$lazy) 
[13:20:02.442]                       future <- run(future)
[13:20:02.442]                     invisible(future)
[13:20:02.442]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.442]                 }
[13:20:02.442]             }
[13:20:02.442]         }
[13:20:02.442]     })
[13:20:02.442]     if (TRUE) {
[13:20:02.442]         base::sink(type = "output", split = FALSE)
[13:20:02.442]         if (TRUE) {
[13:20:02.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.442]         }
[13:20:02.442]         else {
[13:20:02.442]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.442]         }
[13:20:02.442]         base::close(...future.stdout)
[13:20:02.442]         ...future.stdout <- NULL
[13:20:02.442]     }
[13:20:02.442]     ...future.result$conditions <- ...future.conditions
[13:20:02.442]     ...future.result$finished <- base::Sys.time()
[13:20:02.442]     ...future.result
[13:20:02.442] }
[13:20:02.444] assign_globals() ...
[13:20:02.444] List of 5
[13:20:02.444]  $ ...future.FUN            :function (x, ...)  
[13:20:02.444]  $ future.call.arguments    :List of 1
[13:20:02.444]   ..$ singular.ok: logi FALSE
[13:20:02.444]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.444]  $ ...future.elements_ii    :List of 3
[13:20:02.444]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.444]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.444]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.444]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.444]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.444]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.444]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.444]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.444]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.444]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.444]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.444]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.444]  $ ...future.seeds_ii       : NULL
[13:20:02.444]  $ ...future.globals.maxSize: NULL
[13:20:02.444]  - attr(*, "where")=List of 5
[13:20:02.444]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.444]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.444]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.444]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.444]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.444]  - attr(*, "resolved")= logi FALSE
[13:20:02.444]  - attr(*, "total_size")= num 5384
[13:20:02.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.444]  - attr(*, "already-done")= logi TRUE
[13:20:02.454] - reassign environment for ‘...future.FUN’
[13:20:02.454] - copied ‘...future.FUN’ to environment
[13:20:02.454] - copied ‘future.call.arguments’ to environment
[13:20:02.454] - copied ‘...future.elements_ii’ to environment
[13:20:02.454] - copied ‘...future.seeds_ii’ to environment
[13:20:02.454] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.454] assign_globals() ... done
[13:20:02.455] plan(): Setting new future strategy stack:
[13:20:02.455] List of future strategies:
[13:20:02.455] 1. sequential:
[13:20:02.455]    - args: function (..., envir = parent.frame())
[13:20:02.455]    - tweaked: FALSE
[13:20:02.455]    - call: NULL
[13:20:02.455] plan(): nbrOfWorkers() = 1
[13:20:02.460] plan(): Setting new future strategy stack:
[13:20:02.460] List of future strategies:
[13:20:02.460] 1. multisession:
[13:20:02.460]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.460]    - tweaked: FALSE
[13:20:02.460]    - call: plan(strategy)
[13:20:02.464] plan(): nbrOfWorkers() = 1
[13:20:02.464] SequentialFuture started (and completed)
[13:20:02.465] - Launch lazy future ... done
[13:20:02.465] run() for ‘SequentialFuture’ ... done
[13:20:02.465] Created future:
[13:20:02.465] SequentialFuture:
[13:20:02.465] Label: ‘future_by-1’
[13:20:02.465] Expression:
[13:20:02.465] {
[13:20:02.465]     do.call(function(...) {
[13:20:02.465]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.465]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.465]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.465]             on.exit(options(oopts), add = TRUE)
[13:20:02.465]         }
[13:20:02.465]         {
[13:20:02.465]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.465]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.465]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.465]             })
[13:20:02.465]         }
[13:20:02.465]     }, args = future.call.arguments)
[13:20:02.465] }
[13:20:02.465] Lazy evaluation: FALSE
[13:20:02.465] Asynchronous evaluation: FALSE
[13:20:02.465] Local evaluation: TRUE
[13:20:02.465] Environment: R_GlobalEnv
[13:20:02.465] Capture standard output: TRUE
[13:20:02.465] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.465] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.465] Packages: 1 packages (‘stats’)
[13:20:02.465] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.465] Resolved: TRUE
[13:20:02.465] Value: 26.06 KiB of class ‘list’
[13:20:02.465] Early signaling: FALSE
[13:20:02.465] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.465] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.467] Chunk #1 of 1 ... DONE
[13:20:02.467] Launching 1 futures (chunks) ... DONE
[13:20:02.467] Resolving 1 futures (chunks) ...
[13:20:02.467] resolve() on list ...
[13:20:02.467]  recursive: 0
[13:20:02.467]  length: 1
[13:20:02.467] 
[13:20:02.467] resolved() for ‘SequentialFuture’ ...
[13:20:02.467] - state: ‘finished’
[13:20:02.467] - run: TRUE
[13:20:02.467] - result: ‘FutureResult’
[13:20:02.468] resolved() for ‘SequentialFuture’ ... done
[13:20:02.468] Future #1
[13:20:02.468] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.468] - nx: 1
[13:20:02.468] - relay: TRUE
[13:20:02.468] - stdout: TRUE
[13:20:02.468] - signal: TRUE
[13:20:02.468] - resignal: FALSE
[13:20:02.468] - force: TRUE
[13:20:02.468] - relayed: [n=1] FALSE
[13:20:02.469] - queued futures: [n=1] FALSE
[13:20:02.469]  - until=1
[13:20:02.469]  - relaying element #1
[13:20:02.469] - relayed: [n=1] TRUE
[13:20:02.469] - queued futures: [n=1] TRUE
[13:20:02.469] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.469]  length: 0 (resolved future 1)
[13:20:02.469] Relaying remaining futures
[13:20:02.469] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.470] - nx: 1
[13:20:02.470] - relay: TRUE
[13:20:02.470] - stdout: TRUE
[13:20:02.470] - signal: TRUE
[13:20:02.470] - resignal: FALSE
[13:20:02.470] - force: TRUE
[13:20:02.470] - relayed: [n=1] TRUE
[13:20:02.470] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.470] - relayed: [n=1] TRUE
[13:20:02.470] - queued futures: [n=1] TRUE
[13:20:02.470] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.470] resolve() on list ... DONE
[13:20:02.471]  - Number of value chunks collected: 1
[13:20:02.471] Resolving 1 futures (chunks) ... DONE
[13:20:02.471] Reducing values from 1 chunks ...
[13:20:02.471]  - Number of values collected after concatenation: 3
[13:20:02.471]  - Number of values expected: 3
[13:20:02.471] Reducing values from 1 chunks ... DONE
[13:20:02.471] future_lapply() ... DONE
[13:20:02.471] future_by_internal() ... DONE
[13:20:02.475] future_by_internal() ...
[13:20:02.476] future_lapply() ...
[13:20:02.480] Number of chunks: 1
[13:20:02.480] getGlobalsAndPackagesXApply() ...
[13:20:02.480]  - future.globals: TRUE
[13:20:02.480] getGlobalsAndPackages() ...
[13:20:02.480] Searching for globals...
[13:20:02.484] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:02.485] Searching for globals ... DONE
[13:20:02.485] Resolving globals: FALSE
[13:20:02.485] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:20:02.486] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:20:02.486] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:02.486] - packages: [1] ‘stats’
[13:20:02.486] getGlobalsAndPackages() ... DONE
[13:20:02.486]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:02.486]  - needed namespaces: [n=1] ‘stats’
[13:20:02.486] Finding globals ... DONE
[13:20:02.487]  - use_args: TRUE
[13:20:02.487]  - Getting '...' globals ...
[13:20:02.487] resolve() on list ...
[13:20:02.487]  recursive: 0
[13:20:02.487]  length: 1
[13:20:02.487]  elements: ‘...’
[13:20:02.487]  length: 0 (resolved future 1)
[13:20:02.487] resolve() on list ... DONE
[13:20:02.488]    - '...' content: [n=0] 
[13:20:02.488] List of 1
[13:20:02.488]  $ ...: list()
[13:20:02.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.488]  - attr(*, "where")=List of 1
[13:20:02.488]   ..$ ...:<environment: 0x55aceeb4a898> 
[13:20:02.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.488]  - attr(*, "resolved")= logi TRUE
[13:20:02.488]  - attr(*, "total_size")= num NA
[13:20:02.490]  - Getting '...' globals ... DONE
[13:20:02.491] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:20:02.491] List of 4
[13:20:02.491]  $ ...future.FUN:function (x)  
[13:20:02.491]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:02.491]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.491]  $ ...          : list()
[13:20:02.491]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.491]  - attr(*, "where")=List of 4
[13:20:02.491]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.491]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:20:02.491]   ..$ wool         :<environment: R_EmptyEnv> 
[13:20:02.491]   ..$ ...          :<environment: 0x55aceeb4a898> 
[13:20:02.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.491]  - attr(*, "resolved")= logi FALSE
[13:20:02.491]  - attr(*, "total_size")= num 2320
[13:20:02.495] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:02.495] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.495] Number of futures (= number of chunks): 1
[13:20:02.495] Launching 1 futures (chunks) ...
[13:20:02.495] Chunk #1 of 1 ...
[13:20:02.495]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.495] getGlobalsAndPackages() ...
[13:20:02.496] Searching for globals...
[13:20:02.496] 
[13:20:02.496] Searching for globals ... DONE
[13:20:02.496] - globals: [0] <none>
[13:20:02.496] getGlobalsAndPackages() ... DONE
[13:20:02.496]    + additional globals found: [n=0] 
[13:20:02.497]    + additional namespaces needed: [n=0] 
[13:20:02.497]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.497]  - seeds: <none>
[13:20:02.497]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.497] getGlobalsAndPackages() ...
[13:20:02.497] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.497] Resolving globals: FALSE
[13:20:02.497] Tweak future expression to call with '...' arguments ...
[13:20:02.497] {
[13:20:02.497]     do.call(function(...) {
[13:20:02.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.497]             on.exit(options(oopts), add = TRUE)
[13:20:02.497]         }
[13:20:02.497]         {
[13:20:02.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.497]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.497]             })
[13:20:02.497]         }
[13:20:02.497]     }, args = future.call.arguments)
[13:20:02.497] }
[13:20:02.498] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.498] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.498] 
[13:20:02.498] getGlobalsAndPackages() ... DONE
[13:20:02.499] run() for ‘Future’ ...
[13:20:02.499] - state: ‘created’
[13:20:02.499] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.503] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.503]   - Field: ‘label’
[13:20:02.503]   - Field: ‘local’
[13:20:02.503]   - Field: ‘owner’
[13:20:02.503]   - Field: ‘envir’
[13:20:02.503]   - Field: ‘packages’
[13:20:02.503]   - Field: ‘gc’
[13:20:02.503]   - Field: ‘conditions’
[13:20:02.504]   - Field: ‘expr’
[13:20:02.504]   - Field: ‘uuid’
[13:20:02.504]   - Field: ‘seed’
[13:20:02.504]   - Field: ‘version’
[13:20:02.504]   - Field: ‘result’
[13:20:02.504]   - Field: ‘asynchronous’
[13:20:02.504]   - Field: ‘calls’
[13:20:02.504]   - Field: ‘globals’
[13:20:02.504]   - Field: ‘stdout’
[13:20:02.504]   - Field: ‘earlySignal’
[13:20:02.505]   - Field: ‘lazy’
[13:20:02.505]   - Field: ‘state’
[13:20:02.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.505] - Launch lazy future ...
[13:20:02.505] Packages needed by the future expression (n = 1): ‘stats’
[13:20:02.507] Packages needed by future strategies (n = 0): <none>
[13:20:02.507] {
[13:20:02.507]     {
[13:20:02.507]         {
[13:20:02.507]             ...future.startTime <- base::Sys.time()
[13:20:02.507]             {
[13:20:02.507]                 {
[13:20:02.507]                   {
[13:20:02.507]                     {
[13:20:02.507]                       base::local({
[13:20:02.507]                         has_future <- base::requireNamespace("future", 
[13:20:02.507]                           quietly = TRUE)
[13:20:02.507]                         if (has_future) {
[13:20:02.507]                           ns <- base::getNamespace("future")
[13:20:02.507]                           version <- ns[[".package"]][["version"]]
[13:20:02.507]                           if (is.null(version)) 
[13:20:02.507]                             version <- utils::packageVersion("future")
[13:20:02.507]                         }
[13:20:02.507]                         else {
[13:20:02.507]                           version <- NULL
[13:20:02.507]                         }
[13:20:02.507]                         if (!has_future || version < "1.8.0") {
[13:20:02.507]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.507]                             "", base::R.version$version.string), 
[13:20:02.507]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.507]                               "release", "version")], collapse = " "), 
[13:20:02.507]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.507]                             info)
[13:20:02.507]                           info <- base::paste(info, collapse = "; ")
[13:20:02.507]                           if (!has_future) {
[13:20:02.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.507]                               info)
[13:20:02.507]                           }
[13:20:02.507]                           else {
[13:20:02.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.507]                               info, version)
[13:20:02.507]                           }
[13:20:02.507]                           base::stop(msg)
[13:20:02.507]                         }
[13:20:02.507]                       })
[13:20:02.507]                     }
[13:20:02.507]                     base::local({
[13:20:02.507]                       for (pkg in "stats") {
[13:20:02.507]                         base::loadNamespace(pkg)
[13:20:02.507]                         base::library(pkg, character.only = TRUE)
[13:20:02.507]                       }
[13:20:02.507]                     })
[13:20:02.507]                   }
[13:20:02.507]                   options(future.plan = NULL)
[13:20:02.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.507]                 }
[13:20:02.507]                 ...future.workdir <- getwd()
[13:20:02.507]             }
[13:20:02.507]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.507]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.507]         }
[13:20:02.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.507]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.507]             base::names(...future.oldOptions))
[13:20:02.507]     }
[13:20:02.507]     if (FALSE) {
[13:20:02.507]     }
[13:20:02.507]     else {
[13:20:02.507]         if (TRUE) {
[13:20:02.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.507]                 open = "w")
[13:20:02.507]         }
[13:20:02.507]         else {
[13:20:02.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.507]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.507]         }
[13:20:02.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.507]             base::sink(type = "output", split = FALSE)
[13:20:02.507]             base::close(...future.stdout)
[13:20:02.507]         }, add = TRUE)
[13:20:02.507]     }
[13:20:02.507]     ...future.frame <- base::sys.nframe()
[13:20:02.507]     ...future.conditions <- base::list()
[13:20:02.507]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.507]     if (FALSE) {
[13:20:02.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.507]     }
[13:20:02.507]     ...future.result <- base::tryCatch({
[13:20:02.507]         base::withCallingHandlers({
[13:20:02.507]             ...future.value <- base::withVisible(base::local({
[13:20:02.507]                 do.call(function(...) {
[13:20:02.507]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.507]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.507]                     ...future.globals.maxSize)) {
[13:20:02.507]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.507]                     on.exit(options(oopts), add = TRUE)
[13:20:02.507]                   }
[13:20:02.507]                   {
[13:20:02.507]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.507]                       FUN = function(jj) {
[13:20:02.507]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.507]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.507]                       })
[13:20:02.507]                   }
[13:20:02.507]                 }, args = future.call.arguments)
[13:20:02.507]             }))
[13:20:02.507]             future::FutureResult(value = ...future.value$value, 
[13:20:02.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.507]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.507]                     ...future.globalenv.names))
[13:20:02.507]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.507]         }, condition = base::local({
[13:20:02.507]             c <- base::c
[13:20:02.507]             inherits <- base::inherits
[13:20:02.507]             invokeRestart <- base::invokeRestart
[13:20:02.507]             length <- base::length
[13:20:02.507]             list <- base::list
[13:20:02.507]             seq.int <- base::seq.int
[13:20:02.507]             signalCondition <- base::signalCondition
[13:20:02.507]             sys.calls <- base::sys.calls
[13:20:02.507]             `[[` <- base::`[[`
[13:20:02.507]             `+` <- base::`+`
[13:20:02.507]             `<<-` <- base::`<<-`
[13:20:02.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.507]                   3L)]
[13:20:02.507]             }
[13:20:02.507]             function(cond) {
[13:20:02.507]                 is_error <- inherits(cond, "error")
[13:20:02.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.507]                   NULL)
[13:20:02.507]                 if (is_error) {
[13:20:02.507]                   sessionInformation <- function() {
[13:20:02.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.507]                       search = base::search(), system = base::Sys.info())
[13:20:02.507]                   }
[13:20:02.507]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.507]                     cond$call), session = sessionInformation(), 
[13:20:02.507]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.507]                   signalCondition(cond)
[13:20:02.507]                 }
[13:20:02.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.507]                 "immediateCondition"))) {
[13:20:02.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.507]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.507]                   if (TRUE && !signal) {
[13:20:02.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.507]                     {
[13:20:02.507]                       inherits <- base::inherits
[13:20:02.507]                       invokeRestart <- base::invokeRestart
[13:20:02.507]                       is.null <- base::is.null
[13:20:02.507]                       muffled <- FALSE
[13:20:02.507]                       if (inherits(cond, "message")) {
[13:20:02.507]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.507]                         if (muffled) 
[13:20:02.507]                           invokeRestart("muffleMessage")
[13:20:02.507]                       }
[13:20:02.507]                       else if (inherits(cond, "warning")) {
[13:20:02.507]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.507]                         if (muffled) 
[13:20:02.507]                           invokeRestart("muffleWarning")
[13:20:02.507]                       }
[13:20:02.507]                       else if (inherits(cond, "condition")) {
[13:20:02.507]                         if (!is.null(pattern)) {
[13:20:02.507]                           computeRestarts <- base::computeRestarts
[13:20:02.507]                           grepl <- base::grepl
[13:20:02.507]                           restarts <- computeRestarts(cond)
[13:20:02.507]                           for (restart in restarts) {
[13:20:02.507]                             name <- restart$name
[13:20:02.507]                             if (is.null(name)) 
[13:20:02.507]                               next
[13:20:02.507]                             if (!grepl(pattern, name)) 
[13:20:02.507]                               next
[13:20:02.507]                             invokeRestart(restart)
[13:20:02.507]                             muffled <- TRUE
[13:20:02.507]                             break
[13:20:02.507]                           }
[13:20:02.507]                         }
[13:20:02.507]                       }
[13:20:02.507]                       invisible(muffled)
[13:20:02.507]                     }
[13:20:02.507]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.507]                   }
[13:20:02.507]                 }
[13:20:02.507]                 else {
[13:20:02.507]                   if (TRUE) {
[13:20:02.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.507]                     {
[13:20:02.507]                       inherits <- base::inherits
[13:20:02.507]                       invokeRestart <- base::invokeRestart
[13:20:02.507]                       is.null <- base::is.null
[13:20:02.507]                       muffled <- FALSE
[13:20:02.507]                       if (inherits(cond, "message")) {
[13:20:02.507]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.507]                         if (muffled) 
[13:20:02.507]                           invokeRestart("muffleMessage")
[13:20:02.507]                       }
[13:20:02.507]                       else if (inherits(cond, "warning")) {
[13:20:02.507]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.507]                         if (muffled) 
[13:20:02.507]                           invokeRestart("muffleWarning")
[13:20:02.507]                       }
[13:20:02.507]                       else if (inherits(cond, "condition")) {
[13:20:02.507]                         if (!is.null(pattern)) {
[13:20:02.507]                           computeRestarts <- base::computeRestarts
[13:20:02.507]                           grepl <- base::grepl
[13:20:02.507]                           restarts <- computeRestarts(cond)
[13:20:02.507]                           for (restart in restarts) {
[13:20:02.507]                             name <- restart$name
[13:20:02.507]                             if (is.null(name)) 
[13:20:02.507]                               next
[13:20:02.507]                             if (!grepl(pattern, name)) 
[13:20:02.507]                               next
[13:20:02.507]                             invokeRestart(restart)
[13:20:02.507]                             muffled <- TRUE
[13:20:02.507]                             break
[13:20:02.507]                           }
[13:20:02.507]                         }
[13:20:02.507]                       }
[13:20:02.507]                       invisible(muffled)
[13:20:02.507]                     }
[13:20:02.507]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.507]                   }
[13:20:02.507]                 }
[13:20:02.507]             }
[13:20:02.507]         }))
[13:20:02.507]     }, error = function(ex) {
[13:20:02.507]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.507]                 ...future.rng), started = ...future.startTime, 
[13:20:02.507]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.507]             version = "1.8"), class = "FutureResult")
[13:20:02.507]     }, finally = {
[13:20:02.507]         if (!identical(...future.workdir, getwd())) 
[13:20:02.507]             setwd(...future.workdir)
[13:20:02.507]         {
[13:20:02.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.507]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.507]             }
[13:20:02.507]             base::options(...future.oldOptions)
[13:20:02.507]             if (.Platform$OS.type == "windows") {
[13:20:02.507]                 old_names <- names(...future.oldEnvVars)
[13:20:02.507]                 envs <- base::Sys.getenv()
[13:20:02.507]                 names <- names(envs)
[13:20:02.507]                 common <- intersect(names, old_names)
[13:20:02.507]                 added <- setdiff(names, old_names)
[13:20:02.507]                 removed <- setdiff(old_names, names)
[13:20:02.507]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.507]                   envs[common]]
[13:20:02.507]                 NAMES <- toupper(changed)
[13:20:02.507]                 args <- list()
[13:20:02.507]                 for (kk in seq_along(NAMES)) {
[13:20:02.507]                   name <- changed[[kk]]
[13:20:02.507]                   NAME <- NAMES[[kk]]
[13:20:02.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.507]                     next
[13:20:02.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.507]                 }
[13:20:02.507]                 NAMES <- toupper(added)
[13:20:02.507]                 for (kk in seq_along(NAMES)) {
[13:20:02.507]                   name <- added[[kk]]
[13:20:02.507]                   NAME <- NAMES[[kk]]
[13:20:02.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.507]                     next
[13:20:02.507]                   args[[name]] <- ""
[13:20:02.507]                 }
[13:20:02.507]                 NAMES <- toupper(removed)
[13:20:02.507]                 for (kk in seq_along(NAMES)) {
[13:20:02.507]                   name <- removed[[kk]]
[13:20:02.507]                   NAME <- NAMES[[kk]]
[13:20:02.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.507]                     next
[13:20:02.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.507]                 }
[13:20:02.507]                 if (length(args) > 0) 
[13:20:02.507]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.507]             }
[13:20:02.507]             else {
[13:20:02.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.507]             }
[13:20:02.507]             {
[13:20:02.507]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.507]                   0L) {
[13:20:02.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.507]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.507]                   base::options(opts)
[13:20:02.507]                 }
[13:20:02.507]                 {
[13:20:02.507]                   {
[13:20:02.507]                     NULL
[13:20:02.507]                     RNGkind("Mersenne-Twister")
[13:20:02.507]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.507]                       inherits = FALSE)
[13:20:02.507]                   }
[13:20:02.507]                   options(future.plan = NULL)
[13:20:02.507]                   if (is.na(NA_character_)) 
[13:20:02.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.507]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.507]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.507]                     envir = parent.frame()) 
[13:20:02.507]                   {
[13:20:02.507]                     if (is.function(workers)) 
[13:20:02.507]                       workers <- workers()
[13:20:02.507]                     workers <- structure(as.integer(workers), 
[13:20:02.507]                       class = class(workers))
[13:20:02.507]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.507]                       workers >= 1)
[13:20:02.507]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.507]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.507]                     }
[13:20:02.507]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.507]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.507]                       envir = envir)
[13:20:02.507]                     if (!future$lazy) 
[13:20:02.507]                       future <- run(future)
[13:20:02.507]                     invisible(future)
[13:20:02.507]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.507]                 }
[13:20:02.507]             }
[13:20:02.507]         }
[13:20:02.507]     })
[13:20:02.507]     if (TRUE) {
[13:20:02.507]         base::sink(type = "output", split = FALSE)
[13:20:02.507]         if (TRUE) {
[13:20:02.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.507]         }
[13:20:02.507]         else {
[13:20:02.507]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.507]         }
[13:20:02.507]         base::close(...future.stdout)
[13:20:02.507]         ...future.stdout <- NULL
[13:20:02.507]     }
[13:20:02.507]     ...future.result$conditions <- ...future.conditions
[13:20:02.507]     ...future.result$finished <- base::Sys.time()
[13:20:02.507]     ...future.result
[13:20:02.507] }
[13:20:02.509] assign_globals() ...
[13:20:02.510] List of 7
[13:20:02.510]  $ ...future.FUN            :function (x)  
[13:20:02.510]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:02.510]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.510]  $ future.call.arguments    : list()
[13:20:02.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.510]  $ ...future.elements_ii    :List of 3
[13:20:02.510]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.510]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.510]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.510]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.510]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.510]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.510]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.510]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.510]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.510]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.510]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.510]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.510]  $ ...future.seeds_ii       : NULL
[13:20:02.510]  $ ...future.globals.maxSize: NULL
[13:20:02.510]  - attr(*, "where")=List of 7
[13:20:02.510]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.510]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:20:02.510]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:20:02.510]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.510]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.510]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.510]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.510]  - attr(*, "resolved")= logi FALSE
[13:20:02.510]  - attr(*, "total_size")= num 2320
[13:20:02.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.510]  - attr(*, "already-done")= logi TRUE
[13:20:02.520] - reassign environment for ‘...future.FUN’
[13:20:02.520] - copied ‘...future.FUN’ to environment
[13:20:02.520] - copied ‘breaks’ to environment
[13:20:02.520] - copied ‘wool’ to environment
[13:20:02.520] - copied ‘future.call.arguments’ to environment
[13:20:02.520] - copied ‘...future.elements_ii’ to environment
[13:20:02.521] - copied ‘...future.seeds_ii’ to environment
[13:20:02.521] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.521] assign_globals() ... done
[13:20:02.521] plan(): Setting new future strategy stack:
[13:20:02.521] List of future strategies:
[13:20:02.521] 1. sequential:
[13:20:02.521]    - args: function (..., envir = parent.frame())
[13:20:02.521]    - tweaked: FALSE
[13:20:02.521]    - call: NULL
[13:20:02.522] plan(): nbrOfWorkers() = 1
[13:20:02.525] plan(): Setting new future strategy stack:
[13:20:02.525] List of future strategies:
[13:20:02.525] 1. multisession:
[13:20:02.525]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.525]    - tweaked: FALSE
[13:20:02.525]    - call: plan(strategy)
[13:20:02.528] plan(): nbrOfWorkers() = 1
[13:20:02.529] SequentialFuture started (and completed)
[13:20:02.529] - Launch lazy future ... done
[13:20:02.529] run() for ‘SequentialFuture’ ... done
[13:20:02.529] Created future:
[13:20:02.529] SequentialFuture:
[13:20:02.529] Label: ‘future_by-1’
[13:20:02.529] Expression:
[13:20:02.529] {
[13:20:02.529]     do.call(function(...) {
[13:20:02.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.529]             on.exit(options(oopts), add = TRUE)
[13:20:02.529]         }
[13:20:02.529]         {
[13:20:02.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.529]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.529]             })
[13:20:02.529]         }
[13:20:02.529]     }, args = future.call.arguments)
[13:20:02.529] }
[13:20:02.529] Lazy evaluation: FALSE
[13:20:02.529] Asynchronous evaluation: FALSE
[13:20:02.529] Local evaluation: TRUE
[13:20:02.529] Environment: 0x55aceeae7368
[13:20:02.529] Capture standard output: TRUE
[13:20:02.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.529] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:20:02.529] Packages: 1 packages (‘stats’)
[13:20:02.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.529] Resolved: TRUE
[13:20:02.529] Value: 25.57 KiB of class ‘list’
[13:20:02.529] Early signaling: FALSE
[13:20:02.529] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.529] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.533] Chunk #1 of 1 ... DONE
[13:20:02.533] Launching 1 futures (chunks) ... DONE
[13:20:02.533] Resolving 1 futures (chunks) ...
[13:20:02.534] resolve() on list ...
[13:20:02.534]  recursive: 0
[13:20:02.534]  length: 1
[13:20:02.534] 
[13:20:02.534] resolved() for ‘SequentialFuture’ ...
[13:20:02.534] - state: ‘finished’
[13:20:02.534] - run: TRUE
[13:20:02.534] - result: ‘FutureResult’
[13:20:02.535] resolved() for ‘SequentialFuture’ ... done
[13:20:02.535] Future #1
[13:20:02.535] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.535] - nx: 1
[13:20:02.535] - relay: TRUE
[13:20:02.535] - stdout: TRUE
[13:20:02.535] - signal: TRUE
[13:20:02.535] - resignal: FALSE
[13:20:02.535] - force: TRUE
[13:20:02.536] - relayed: [n=1] FALSE
[13:20:02.536] - queued futures: [n=1] FALSE
[13:20:02.536]  - until=1
[13:20:02.536]  - relaying element #1
[13:20:02.536] - relayed: [n=1] TRUE
[13:20:02.536] - queued futures: [n=1] TRUE
[13:20:02.536] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.536]  length: 0 (resolved future 1)
[13:20:02.537] Relaying remaining futures
[13:20:02.537] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.537] - nx: 1
[13:20:02.537] - relay: TRUE
[13:20:02.537] - stdout: TRUE
[13:20:02.537] - signal: TRUE
[13:20:02.537] - resignal: FALSE
[13:20:02.537] - force: TRUE
[13:20:02.537] - relayed: [n=1] TRUE
[13:20:02.537] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.537] - relayed: [n=1] TRUE
[13:20:02.538] - queued futures: [n=1] TRUE
[13:20:02.538] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.538] resolve() on list ... DONE
[13:20:02.538]  - Number of value chunks collected: 1
[13:20:02.538] Resolving 1 futures (chunks) ... DONE
[13:20:02.538] Reducing values from 1 chunks ...
[13:20:02.538]  - Number of values collected after concatenation: 3
[13:20:02.538]  - Number of values expected: 3
[13:20:02.538] Reducing values from 1 chunks ... DONE
[13:20:02.538] future_lapply() ... DONE
[13:20:02.539] future_by_internal() ... DONE
[13:20:02.539] future_by_internal() ...
[13:20:02.539] future_lapply() ...
[13:20:02.543] Number of chunks: 1
[13:20:02.543] getGlobalsAndPackagesXApply() ...
[13:20:02.544]  - future.globals: TRUE
[13:20:02.544] getGlobalsAndPackages() ...
[13:20:02.544] Searching for globals...
[13:20:02.545] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.545] Searching for globals ... DONE
[13:20:02.545] Resolving globals: FALSE
[13:20:02.546] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.546] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.546] - globals: [1] ‘FUN’
[13:20:02.546] 
[13:20:02.546] getGlobalsAndPackages() ... DONE
[13:20:02.546]  - globals found/used: [n=1] ‘FUN’
[13:20:02.546]  - needed namespaces: [n=0] 
[13:20:02.547] Finding globals ... DONE
[13:20:02.547]  - use_args: TRUE
[13:20:02.547]  - Getting '...' globals ...
[13:20:02.547] resolve() on list ...
[13:20:02.547]  recursive: 0
[13:20:02.547]  length: 1
[13:20:02.547]  elements: ‘...’
[13:20:02.547]  length: 0 (resolved future 1)
[13:20:02.548] resolve() on list ... DONE
[13:20:02.548]    - '...' content: [n=0] 
[13:20:02.548] List of 1
[13:20:02.548]  $ ...: list()
[13:20:02.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.548]  - attr(*, "where")=List of 1
[13:20:02.548]   ..$ ...:<environment: 0x55acec7dc898> 
[13:20:02.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.548]  - attr(*, "resolved")= logi TRUE
[13:20:02.548]  - attr(*, "total_size")= num NA
[13:20:02.550]  - Getting '...' globals ... DONE
[13:20:02.551] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.551] List of 2
[13:20:02.551]  $ ...future.FUN:function (object, ...)  
[13:20:02.551]  $ ...          : list()
[13:20:02.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.551]  - attr(*, "where")=List of 2
[13:20:02.551]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.551]   ..$ ...          :<environment: 0x55acec7dc898> 
[13:20:02.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.551]  - attr(*, "resolved")= logi FALSE
[13:20:02.551]  - attr(*, "total_size")= num 1240
[13:20:02.554] Packages to be attached in all futures: [n=0] 
[13:20:02.554] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.554] Number of futures (= number of chunks): 1
[13:20:02.554] Launching 1 futures (chunks) ...
[13:20:02.554] Chunk #1 of 1 ...
[13:20:02.554]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.554] getGlobalsAndPackages() ...
[13:20:02.556] Searching for globals...
[13:20:02.557] 
[13:20:02.557] Searching for globals ... DONE
[13:20:02.557] - globals: [0] <none>
[13:20:02.557] getGlobalsAndPackages() ... DONE
[13:20:02.557]    + additional globals found: [n=0] 
[13:20:02.558]    + additional namespaces needed: [n=0] 
[13:20:02.558]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.558]  - seeds: <none>
[13:20:02.558]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.558] getGlobalsAndPackages() ...
[13:20:02.558] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.558] Resolving globals: FALSE
[13:20:02.558] Tweak future expression to call with '...' arguments ...
[13:20:02.559] {
[13:20:02.559]     do.call(function(...) {
[13:20:02.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.559]             on.exit(options(oopts), add = TRUE)
[13:20:02.559]         }
[13:20:02.559]         {
[13:20:02.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.559]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.559]             })
[13:20:02.559]         }
[13:20:02.559]     }, args = future.call.arguments)
[13:20:02.559] }
[13:20:02.559] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.559] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.559] 
[13:20:02.559] getGlobalsAndPackages() ... DONE
[13:20:02.560] run() for ‘Future’ ...
[13:20:02.560] - state: ‘created’
[13:20:02.560] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.564] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.564]   - Field: ‘label’
[13:20:02.564]   - Field: ‘local’
[13:20:02.564]   - Field: ‘owner’
[13:20:02.564]   - Field: ‘envir’
[13:20:02.564]   - Field: ‘packages’
[13:20:02.565]   - Field: ‘gc’
[13:20:02.565]   - Field: ‘conditions’
[13:20:02.565]   - Field: ‘expr’
[13:20:02.565]   - Field: ‘uuid’
[13:20:02.565]   - Field: ‘seed’
[13:20:02.565]   - Field: ‘version’
[13:20:02.565]   - Field: ‘result’
[13:20:02.565]   - Field: ‘asynchronous’
[13:20:02.565]   - Field: ‘calls’
[13:20:02.565]   - Field: ‘globals’
[13:20:02.565]   - Field: ‘stdout’
[13:20:02.566]   - Field: ‘earlySignal’
[13:20:02.566]   - Field: ‘lazy’
[13:20:02.566]   - Field: ‘state’
[13:20:02.566] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.566] - Launch lazy future ...
[13:20:02.566] Packages needed by the future expression (n = 0): <none>
[13:20:02.566] Packages needed by future strategies (n = 0): <none>
[13:20:02.567] {
[13:20:02.567]     {
[13:20:02.567]         {
[13:20:02.567]             ...future.startTime <- base::Sys.time()
[13:20:02.567]             {
[13:20:02.567]                 {
[13:20:02.567]                   {
[13:20:02.567]                     base::local({
[13:20:02.567]                       has_future <- base::requireNamespace("future", 
[13:20:02.567]                         quietly = TRUE)
[13:20:02.567]                       if (has_future) {
[13:20:02.567]                         ns <- base::getNamespace("future")
[13:20:02.567]                         version <- ns[[".package"]][["version"]]
[13:20:02.567]                         if (is.null(version)) 
[13:20:02.567]                           version <- utils::packageVersion("future")
[13:20:02.567]                       }
[13:20:02.567]                       else {
[13:20:02.567]                         version <- NULL
[13:20:02.567]                       }
[13:20:02.567]                       if (!has_future || version < "1.8.0") {
[13:20:02.567]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.567]                           "", base::R.version$version.string), 
[13:20:02.567]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.567]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.567]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.567]                             "release", "version")], collapse = " "), 
[13:20:02.567]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.567]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.567]                           info)
[13:20:02.567]                         info <- base::paste(info, collapse = "; ")
[13:20:02.567]                         if (!has_future) {
[13:20:02.567]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.567]                             info)
[13:20:02.567]                         }
[13:20:02.567]                         else {
[13:20:02.567]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.567]                             info, version)
[13:20:02.567]                         }
[13:20:02.567]                         base::stop(msg)
[13:20:02.567]                       }
[13:20:02.567]                     })
[13:20:02.567]                   }
[13:20:02.567]                   options(future.plan = NULL)
[13:20:02.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.567]                 }
[13:20:02.567]                 ...future.workdir <- getwd()
[13:20:02.567]             }
[13:20:02.567]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.567]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.567]         }
[13:20:02.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.567]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.567]             base::names(...future.oldOptions))
[13:20:02.567]     }
[13:20:02.567]     if (FALSE) {
[13:20:02.567]     }
[13:20:02.567]     else {
[13:20:02.567]         if (TRUE) {
[13:20:02.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.567]                 open = "w")
[13:20:02.567]         }
[13:20:02.567]         else {
[13:20:02.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.567]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.567]         }
[13:20:02.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.567]             base::sink(type = "output", split = FALSE)
[13:20:02.567]             base::close(...future.stdout)
[13:20:02.567]         }, add = TRUE)
[13:20:02.567]     }
[13:20:02.567]     ...future.frame <- base::sys.nframe()
[13:20:02.567]     ...future.conditions <- base::list()
[13:20:02.567]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.567]     if (FALSE) {
[13:20:02.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.567]     }
[13:20:02.567]     ...future.result <- base::tryCatch({
[13:20:02.567]         base::withCallingHandlers({
[13:20:02.567]             ...future.value <- base::withVisible(base::local({
[13:20:02.567]                 do.call(function(...) {
[13:20:02.567]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.567]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.567]                     ...future.globals.maxSize)) {
[13:20:02.567]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.567]                     on.exit(options(oopts), add = TRUE)
[13:20:02.567]                   }
[13:20:02.567]                   {
[13:20:02.567]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.567]                       FUN = function(jj) {
[13:20:02.567]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.567]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.567]                       })
[13:20:02.567]                   }
[13:20:02.567]                 }, args = future.call.arguments)
[13:20:02.567]             }))
[13:20:02.567]             future::FutureResult(value = ...future.value$value, 
[13:20:02.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.567]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.567]                     ...future.globalenv.names))
[13:20:02.567]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.567]         }, condition = base::local({
[13:20:02.567]             c <- base::c
[13:20:02.567]             inherits <- base::inherits
[13:20:02.567]             invokeRestart <- base::invokeRestart
[13:20:02.567]             length <- base::length
[13:20:02.567]             list <- base::list
[13:20:02.567]             seq.int <- base::seq.int
[13:20:02.567]             signalCondition <- base::signalCondition
[13:20:02.567]             sys.calls <- base::sys.calls
[13:20:02.567]             `[[` <- base::`[[`
[13:20:02.567]             `+` <- base::`+`
[13:20:02.567]             `<<-` <- base::`<<-`
[13:20:02.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.567]                   3L)]
[13:20:02.567]             }
[13:20:02.567]             function(cond) {
[13:20:02.567]                 is_error <- inherits(cond, "error")
[13:20:02.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.567]                   NULL)
[13:20:02.567]                 if (is_error) {
[13:20:02.567]                   sessionInformation <- function() {
[13:20:02.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.567]                       search = base::search(), system = base::Sys.info())
[13:20:02.567]                   }
[13:20:02.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.567]                     cond$call), session = sessionInformation(), 
[13:20:02.567]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.567]                   signalCondition(cond)
[13:20:02.567]                 }
[13:20:02.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.567]                 "immediateCondition"))) {
[13:20:02.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.567]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.567]                   if (TRUE && !signal) {
[13:20:02.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.567]                     {
[13:20:02.567]                       inherits <- base::inherits
[13:20:02.567]                       invokeRestart <- base::invokeRestart
[13:20:02.567]                       is.null <- base::is.null
[13:20:02.567]                       muffled <- FALSE
[13:20:02.567]                       if (inherits(cond, "message")) {
[13:20:02.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.567]                         if (muffled) 
[13:20:02.567]                           invokeRestart("muffleMessage")
[13:20:02.567]                       }
[13:20:02.567]                       else if (inherits(cond, "warning")) {
[13:20:02.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.567]                         if (muffled) 
[13:20:02.567]                           invokeRestart("muffleWarning")
[13:20:02.567]                       }
[13:20:02.567]                       else if (inherits(cond, "condition")) {
[13:20:02.567]                         if (!is.null(pattern)) {
[13:20:02.567]                           computeRestarts <- base::computeRestarts
[13:20:02.567]                           grepl <- base::grepl
[13:20:02.567]                           restarts <- computeRestarts(cond)
[13:20:02.567]                           for (restart in restarts) {
[13:20:02.567]                             name <- restart$name
[13:20:02.567]                             if (is.null(name)) 
[13:20:02.567]                               next
[13:20:02.567]                             if (!grepl(pattern, name)) 
[13:20:02.567]                               next
[13:20:02.567]                             invokeRestart(restart)
[13:20:02.567]                             muffled <- TRUE
[13:20:02.567]                             break
[13:20:02.567]                           }
[13:20:02.567]                         }
[13:20:02.567]                       }
[13:20:02.567]                       invisible(muffled)
[13:20:02.567]                     }
[13:20:02.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.567]                   }
[13:20:02.567]                 }
[13:20:02.567]                 else {
[13:20:02.567]                   if (TRUE) {
[13:20:02.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.567]                     {
[13:20:02.567]                       inherits <- base::inherits
[13:20:02.567]                       invokeRestart <- base::invokeRestart
[13:20:02.567]                       is.null <- base::is.null
[13:20:02.567]                       muffled <- FALSE
[13:20:02.567]                       if (inherits(cond, "message")) {
[13:20:02.567]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.567]                         if (muffled) 
[13:20:02.567]                           invokeRestart("muffleMessage")
[13:20:02.567]                       }
[13:20:02.567]                       else if (inherits(cond, "warning")) {
[13:20:02.567]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.567]                         if (muffled) 
[13:20:02.567]                           invokeRestart("muffleWarning")
[13:20:02.567]                       }
[13:20:02.567]                       else if (inherits(cond, "condition")) {
[13:20:02.567]                         if (!is.null(pattern)) {
[13:20:02.567]                           computeRestarts <- base::computeRestarts
[13:20:02.567]                           grepl <- base::grepl
[13:20:02.567]                           restarts <- computeRestarts(cond)
[13:20:02.567]                           for (restart in restarts) {
[13:20:02.567]                             name <- restart$name
[13:20:02.567]                             if (is.null(name)) 
[13:20:02.567]                               next
[13:20:02.567]                             if (!grepl(pattern, name)) 
[13:20:02.567]                               next
[13:20:02.567]                             invokeRestart(restart)
[13:20:02.567]                             muffled <- TRUE
[13:20:02.567]                             break
[13:20:02.567]                           }
[13:20:02.567]                         }
[13:20:02.567]                       }
[13:20:02.567]                       invisible(muffled)
[13:20:02.567]                     }
[13:20:02.567]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.567]                   }
[13:20:02.567]                 }
[13:20:02.567]             }
[13:20:02.567]         }))
[13:20:02.567]     }, error = function(ex) {
[13:20:02.567]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.567]                 ...future.rng), started = ...future.startTime, 
[13:20:02.567]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.567]             version = "1.8"), class = "FutureResult")
[13:20:02.567]     }, finally = {
[13:20:02.567]         if (!identical(...future.workdir, getwd())) 
[13:20:02.567]             setwd(...future.workdir)
[13:20:02.567]         {
[13:20:02.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.567]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.567]             }
[13:20:02.567]             base::options(...future.oldOptions)
[13:20:02.567]             if (.Platform$OS.type == "windows") {
[13:20:02.567]                 old_names <- names(...future.oldEnvVars)
[13:20:02.567]                 envs <- base::Sys.getenv()
[13:20:02.567]                 names <- names(envs)
[13:20:02.567]                 common <- intersect(names, old_names)
[13:20:02.567]                 added <- setdiff(names, old_names)
[13:20:02.567]                 removed <- setdiff(old_names, names)
[13:20:02.567]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.567]                   envs[common]]
[13:20:02.567]                 NAMES <- toupper(changed)
[13:20:02.567]                 args <- list()
[13:20:02.567]                 for (kk in seq_along(NAMES)) {
[13:20:02.567]                   name <- changed[[kk]]
[13:20:02.567]                   NAME <- NAMES[[kk]]
[13:20:02.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.567]                     next
[13:20:02.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.567]                 }
[13:20:02.567]                 NAMES <- toupper(added)
[13:20:02.567]                 for (kk in seq_along(NAMES)) {
[13:20:02.567]                   name <- added[[kk]]
[13:20:02.567]                   NAME <- NAMES[[kk]]
[13:20:02.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.567]                     next
[13:20:02.567]                   args[[name]] <- ""
[13:20:02.567]                 }
[13:20:02.567]                 NAMES <- toupper(removed)
[13:20:02.567]                 for (kk in seq_along(NAMES)) {
[13:20:02.567]                   name <- removed[[kk]]
[13:20:02.567]                   NAME <- NAMES[[kk]]
[13:20:02.567]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.567]                     next
[13:20:02.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.567]                 }
[13:20:02.567]                 if (length(args) > 0) 
[13:20:02.567]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.567]             }
[13:20:02.567]             else {
[13:20:02.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.567]             }
[13:20:02.567]             {
[13:20:02.567]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.567]                   0L) {
[13:20:02.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.567]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.567]                   base::options(opts)
[13:20:02.567]                 }
[13:20:02.567]                 {
[13:20:02.567]                   {
[13:20:02.567]                     NULL
[13:20:02.567]                     RNGkind("Mersenne-Twister")
[13:20:02.567]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.567]                       inherits = FALSE)
[13:20:02.567]                   }
[13:20:02.567]                   options(future.plan = NULL)
[13:20:02.567]                   if (is.na(NA_character_)) 
[13:20:02.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.567]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.567]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.567]                     envir = parent.frame()) 
[13:20:02.567]                   {
[13:20:02.567]                     if (is.function(workers)) 
[13:20:02.567]                       workers <- workers()
[13:20:02.567]                     workers <- structure(as.integer(workers), 
[13:20:02.567]                       class = class(workers))
[13:20:02.567]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.567]                       workers >= 1)
[13:20:02.567]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.567]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.567]                     }
[13:20:02.567]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.567]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.567]                       envir = envir)
[13:20:02.567]                     if (!future$lazy) 
[13:20:02.567]                       future <- run(future)
[13:20:02.567]                     invisible(future)
[13:20:02.567]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.567]                 }
[13:20:02.567]             }
[13:20:02.567]         }
[13:20:02.567]     })
[13:20:02.567]     if (TRUE) {
[13:20:02.567]         base::sink(type = "output", split = FALSE)
[13:20:02.567]         if (TRUE) {
[13:20:02.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.567]         }
[13:20:02.567]         else {
[13:20:02.567]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.567]         }
[13:20:02.567]         base::close(...future.stdout)
[13:20:02.567]         ...future.stdout <- NULL
[13:20:02.567]     }
[13:20:02.567]     ...future.result$conditions <- ...future.conditions
[13:20:02.567]     ...future.result$finished <- base::Sys.time()
[13:20:02.567]     ...future.result
[13:20:02.567] }
[13:20:02.569] assign_globals() ...
[13:20:02.569] List of 5
[13:20:02.569]  $ ...future.FUN            :function (object, ...)  
[13:20:02.569]  $ future.call.arguments    : list()
[13:20:02.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.569]  $ ...future.elements_ii    :List of 3
[13:20:02.569]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.569]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.569]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.569]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.569]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.569]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.569]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.569]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.569]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.569]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.569]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.569]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.569]  $ ...future.seeds_ii       : NULL
[13:20:02.569]  $ ...future.globals.maxSize: NULL
[13:20:02.569]  - attr(*, "where")=List of 5
[13:20:02.569]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.569]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.569]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.569]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.569]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.569]  - attr(*, "resolved")= logi FALSE
[13:20:02.569]  - attr(*, "total_size")= num 1240
[13:20:02.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.569]  - attr(*, "already-done")= logi TRUE
[13:20:02.578] - copied ‘...future.FUN’ to environment
[13:20:02.578] - copied ‘future.call.arguments’ to environment
[13:20:02.578] - copied ‘...future.elements_ii’ to environment
[13:20:02.578] - copied ‘...future.seeds_ii’ to environment
[13:20:02.578] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.578] assign_globals() ... done
[13:20:02.578] plan(): Setting new future strategy stack:
[13:20:02.578] List of future strategies:
[13:20:02.578] 1. sequential:
[13:20:02.578]    - args: function (..., envir = parent.frame())
[13:20:02.578]    - tweaked: FALSE
[13:20:02.578]    - call: NULL
[13:20:02.579] plan(): nbrOfWorkers() = 1
[13:20:02.584] plan(): Setting new future strategy stack:
[13:20:02.584] List of future strategies:
[13:20:02.584] 1. multisession:
[13:20:02.584]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.584]    - tweaked: FALSE
[13:20:02.584]    - call: plan(strategy)
[13:20:02.587] plan(): nbrOfWorkers() = 1
[13:20:02.587] SequentialFuture started (and completed)
[13:20:02.588] - Launch lazy future ... done
[13:20:02.588] run() for ‘SequentialFuture’ ... done
[13:20:02.588] Created future:
[13:20:02.588] SequentialFuture:
[13:20:02.588] Label: ‘future_by-1’
[13:20:02.588] Expression:
[13:20:02.588] {
[13:20:02.588]     do.call(function(...) {
[13:20:02.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.588]             on.exit(options(oopts), add = TRUE)
[13:20:02.588]         }
[13:20:02.588]         {
[13:20:02.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.588]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.588]             })
[13:20:02.588]         }
[13:20:02.588]     }, args = future.call.arguments)
[13:20:02.588] }
[13:20:02.588] Lazy evaluation: FALSE
[13:20:02.588] Asynchronous evaluation: FALSE
[13:20:02.588] Local evaluation: TRUE
[13:20:02.588] Environment: 0x55aceca385b0
[13:20:02.588] Capture standard output: TRUE
[13:20:02.588] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.588] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.588] Packages: <none>
[13:20:02.588] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.588] Resolved: TRUE
[13:20:02.588] Value: 5.37 KiB of class ‘list’
[13:20:02.588] Early signaling: FALSE
[13:20:02.588] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.588] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.589] Chunk #1 of 1 ... DONE
[13:20:02.589] Launching 1 futures (chunks) ... DONE
[13:20:02.590] Resolving 1 futures (chunks) ...
[13:20:02.590] resolve() on list ...
[13:20:02.590]  recursive: 0
[13:20:02.590]  length: 1
[13:20:02.590] 
[13:20:02.590] resolved() for ‘SequentialFuture’ ...
[13:20:02.590] - state: ‘finished’
[13:20:02.590] - run: TRUE
[13:20:02.590] - result: ‘FutureResult’
[13:20:02.590] resolved() for ‘SequentialFuture’ ... done
[13:20:02.591] Future #1
[13:20:02.591] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.591] - nx: 1
[13:20:02.591] - relay: TRUE
[13:20:02.591] - stdout: TRUE
[13:20:02.591] - signal: TRUE
[13:20:02.591] - resignal: FALSE
[13:20:02.591] - force: TRUE
[13:20:02.591] - relayed: [n=1] FALSE
[13:20:02.591] - queued futures: [n=1] FALSE
[13:20:02.591]  - until=1
[13:20:02.592]  - relaying element #1
[13:20:02.592] - relayed: [n=1] TRUE
[13:20:02.592] - queued futures: [n=1] TRUE
[13:20:02.592] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.592]  length: 0 (resolved future 1)
[13:20:02.592] Relaying remaining futures
[13:20:02.592] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.592] - nx: 1
[13:20:02.592] - relay: TRUE
[13:20:02.593] - stdout: TRUE
[13:20:02.593] - signal: TRUE
[13:20:02.593] - resignal: FALSE
[13:20:02.593] - force: TRUE
[13:20:02.593] - relayed: [n=1] TRUE
[13:20:02.593] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.593] - relayed: [n=1] TRUE
[13:20:02.593] - queued futures: [n=1] TRUE
[13:20:02.593] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.593] resolve() on list ... DONE
[13:20:02.594]  - Number of value chunks collected: 1
[13:20:02.594] Resolving 1 futures (chunks) ... DONE
[13:20:02.594] Reducing values from 1 chunks ...
[13:20:02.594]  - Number of values collected after concatenation: 3
[13:20:02.594]  - Number of values expected: 3
[13:20:02.594] Reducing values from 1 chunks ... DONE
[13:20:02.594] future_lapply() ... DONE
[13:20:02.594] future_by_internal() ... DONE
[13:20:02.595] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:20:02.595] future_lapply() ...
[13:20:02.599] Number of chunks: 1
[13:20:02.599] getGlobalsAndPackagesXApply() ...
[13:20:02.599]  - future.globals: TRUE
[13:20:02.599] getGlobalsAndPackages() ...
[13:20:02.600] Searching for globals...
[13:20:02.601] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.601] Searching for globals ... DONE
[13:20:02.601] Resolving globals: FALSE
[13:20:02.601] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.602] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.602] - globals: [1] ‘FUN’
[13:20:02.602] 
[13:20:02.602] getGlobalsAndPackages() ... DONE
[13:20:02.602]  - globals found/used: [n=1] ‘FUN’
[13:20:02.602]  - needed namespaces: [n=0] 
[13:20:02.602] Finding globals ... DONE
[13:20:02.602]  - use_args: TRUE
[13:20:02.602]  - Getting '...' globals ...
[13:20:02.603] resolve() on list ...
[13:20:02.603]  recursive: 0
[13:20:02.603]  length: 1
[13:20:02.603]  elements: ‘...’
[13:20:02.603]  length: 0 (resolved future 1)
[13:20:02.603] resolve() on list ... DONE
[13:20:02.603]    - '...' content: [n=0] 
[13:20:02.603] List of 1
[13:20:02.603]  $ ...: list()
[13:20:02.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.603]  - attr(*, "where")=List of 1
[13:20:02.603]   ..$ ...:<environment: 0x55acee78de68> 
[13:20:02.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.603]  - attr(*, "resolved")= logi TRUE
[13:20:02.603]  - attr(*, "total_size")= num NA
[13:20:02.610]  - Getting '...' globals ... DONE
[13:20:02.610] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.610] List of 2
[13:20:02.610]  $ ...future.FUN:function (object, ...)  
[13:20:02.610]  $ ...          : list()
[13:20:02.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.610]  - attr(*, "where")=List of 2
[13:20:02.610]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.610]   ..$ ...          :<environment: 0x55acee78de68> 
[13:20:02.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.610]  - attr(*, "resolved")= logi FALSE
[13:20:02.610]  - attr(*, "total_size")= num 1240
[13:20:02.614] Packages to be attached in all futures: [n=0] 
[13:20:02.614] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.614] Number of futures (= number of chunks): 1
[13:20:02.614] Launching 1 futures (chunks) ...
[13:20:02.614] Chunk #1 of 1 ...
[13:20:02.614]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.614] getGlobalsAndPackages() ...
[13:20:02.615] Searching for globals...
[13:20:02.615] 
[13:20:02.615] Searching for globals ... DONE
[13:20:02.615] - globals: [0] <none>
[13:20:02.615] getGlobalsAndPackages() ... DONE
[13:20:02.615]    + additional globals found: [n=0] 
[13:20:02.615]    + additional namespaces needed: [n=0] 
[13:20:02.616]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.616]  - seeds: <none>
[13:20:02.616]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.616] getGlobalsAndPackages() ...
[13:20:02.616] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.616] Resolving globals: FALSE
[13:20:02.616] Tweak future expression to call with '...' arguments ...
[13:20:02.616] {
[13:20:02.616]     do.call(function(...) {
[13:20:02.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.616]             on.exit(options(oopts), add = TRUE)
[13:20:02.616]         }
[13:20:02.616]         {
[13:20:02.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.616]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.616]             })
[13:20:02.616]         }
[13:20:02.616]     }, args = future.call.arguments)
[13:20:02.616] }
[13:20:02.617] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.617] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.617] 
[13:20:02.617] getGlobalsAndPackages() ... DONE
[13:20:02.618] run() for ‘Future’ ...
[13:20:02.618] - state: ‘created’
[13:20:02.618] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.621] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.622]   - Field: ‘label’
[13:20:02.622]   - Field: ‘local’
[13:20:02.622]   - Field: ‘owner’
[13:20:02.622]   - Field: ‘envir’
[13:20:02.622]   - Field: ‘packages’
[13:20:02.622]   - Field: ‘gc’
[13:20:02.622]   - Field: ‘conditions’
[13:20:02.622]   - Field: ‘expr’
[13:20:02.622]   - Field: ‘uuid’
[13:20:02.623]   - Field: ‘seed’
[13:20:02.623]   - Field: ‘version’
[13:20:02.623]   - Field: ‘result’
[13:20:02.623]   - Field: ‘asynchronous’
[13:20:02.623]   - Field: ‘calls’
[13:20:02.623]   - Field: ‘globals’
[13:20:02.623]   - Field: ‘stdout’
[13:20:02.623]   - Field: ‘earlySignal’
[13:20:02.623]   - Field: ‘lazy’
[13:20:02.623]   - Field: ‘state’
[13:20:02.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.624] - Launch lazy future ...
[13:20:02.624] Packages needed by the future expression (n = 0): <none>
[13:20:02.624] Packages needed by future strategies (n = 0): <none>
[13:20:02.624] {
[13:20:02.624]     {
[13:20:02.624]         {
[13:20:02.624]             ...future.startTime <- base::Sys.time()
[13:20:02.624]             {
[13:20:02.624]                 {
[13:20:02.624]                   {
[13:20:02.624]                     base::local({
[13:20:02.624]                       has_future <- base::requireNamespace("future", 
[13:20:02.624]                         quietly = TRUE)
[13:20:02.624]                       if (has_future) {
[13:20:02.624]                         ns <- base::getNamespace("future")
[13:20:02.624]                         version <- ns[[".package"]][["version"]]
[13:20:02.624]                         if (is.null(version)) 
[13:20:02.624]                           version <- utils::packageVersion("future")
[13:20:02.624]                       }
[13:20:02.624]                       else {
[13:20:02.624]                         version <- NULL
[13:20:02.624]                       }
[13:20:02.624]                       if (!has_future || version < "1.8.0") {
[13:20:02.624]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.624]                           "", base::R.version$version.string), 
[13:20:02.624]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.624]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.624]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.624]                             "release", "version")], collapse = " "), 
[13:20:02.624]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.624]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.624]                           info)
[13:20:02.624]                         info <- base::paste(info, collapse = "; ")
[13:20:02.624]                         if (!has_future) {
[13:20:02.624]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.624]                             info)
[13:20:02.624]                         }
[13:20:02.624]                         else {
[13:20:02.624]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.624]                             info, version)
[13:20:02.624]                         }
[13:20:02.624]                         base::stop(msg)
[13:20:02.624]                       }
[13:20:02.624]                     })
[13:20:02.624]                   }
[13:20:02.624]                   options(future.plan = NULL)
[13:20:02.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.624]                 }
[13:20:02.624]                 ...future.workdir <- getwd()
[13:20:02.624]             }
[13:20:02.624]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.624]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.624]         }
[13:20:02.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.624]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.624]             base::names(...future.oldOptions))
[13:20:02.624]     }
[13:20:02.624]     if (FALSE) {
[13:20:02.624]     }
[13:20:02.624]     else {
[13:20:02.624]         if (TRUE) {
[13:20:02.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.624]                 open = "w")
[13:20:02.624]         }
[13:20:02.624]         else {
[13:20:02.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.624]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.624]         }
[13:20:02.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.624]             base::sink(type = "output", split = FALSE)
[13:20:02.624]             base::close(...future.stdout)
[13:20:02.624]         }, add = TRUE)
[13:20:02.624]     }
[13:20:02.624]     ...future.frame <- base::sys.nframe()
[13:20:02.624]     ...future.conditions <- base::list()
[13:20:02.624]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.624]     if (FALSE) {
[13:20:02.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.624]     }
[13:20:02.624]     ...future.result <- base::tryCatch({
[13:20:02.624]         base::withCallingHandlers({
[13:20:02.624]             ...future.value <- base::withVisible(base::local({
[13:20:02.624]                 do.call(function(...) {
[13:20:02.624]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.624]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.624]                     ...future.globals.maxSize)) {
[13:20:02.624]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.624]                     on.exit(options(oopts), add = TRUE)
[13:20:02.624]                   }
[13:20:02.624]                   {
[13:20:02.624]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.624]                       FUN = function(jj) {
[13:20:02.624]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.624]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.624]                       })
[13:20:02.624]                   }
[13:20:02.624]                 }, args = future.call.arguments)
[13:20:02.624]             }))
[13:20:02.624]             future::FutureResult(value = ...future.value$value, 
[13:20:02.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.624]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.624]                     ...future.globalenv.names))
[13:20:02.624]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.624]         }, condition = base::local({
[13:20:02.624]             c <- base::c
[13:20:02.624]             inherits <- base::inherits
[13:20:02.624]             invokeRestart <- base::invokeRestart
[13:20:02.624]             length <- base::length
[13:20:02.624]             list <- base::list
[13:20:02.624]             seq.int <- base::seq.int
[13:20:02.624]             signalCondition <- base::signalCondition
[13:20:02.624]             sys.calls <- base::sys.calls
[13:20:02.624]             `[[` <- base::`[[`
[13:20:02.624]             `+` <- base::`+`
[13:20:02.624]             `<<-` <- base::`<<-`
[13:20:02.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.624]                   3L)]
[13:20:02.624]             }
[13:20:02.624]             function(cond) {
[13:20:02.624]                 is_error <- inherits(cond, "error")
[13:20:02.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.624]                   NULL)
[13:20:02.624]                 if (is_error) {
[13:20:02.624]                   sessionInformation <- function() {
[13:20:02.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.624]                       search = base::search(), system = base::Sys.info())
[13:20:02.624]                   }
[13:20:02.624]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.624]                     cond$call), session = sessionInformation(), 
[13:20:02.624]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.624]                   signalCondition(cond)
[13:20:02.624]                 }
[13:20:02.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.624]                 "immediateCondition"))) {
[13:20:02.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.624]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.624]                   if (TRUE && !signal) {
[13:20:02.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.624]                     {
[13:20:02.624]                       inherits <- base::inherits
[13:20:02.624]                       invokeRestart <- base::invokeRestart
[13:20:02.624]                       is.null <- base::is.null
[13:20:02.624]                       muffled <- FALSE
[13:20:02.624]                       if (inherits(cond, "message")) {
[13:20:02.624]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.624]                         if (muffled) 
[13:20:02.624]                           invokeRestart("muffleMessage")
[13:20:02.624]                       }
[13:20:02.624]                       else if (inherits(cond, "warning")) {
[13:20:02.624]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.624]                         if (muffled) 
[13:20:02.624]                           invokeRestart("muffleWarning")
[13:20:02.624]                       }
[13:20:02.624]                       else if (inherits(cond, "condition")) {
[13:20:02.624]                         if (!is.null(pattern)) {
[13:20:02.624]                           computeRestarts <- base::computeRestarts
[13:20:02.624]                           grepl <- base::grepl
[13:20:02.624]                           restarts <- computeRestarts(cond)
[13:20:02.624]                           for (restart in restarts) {
[13:20:02.624]                             name <- restart$name
[13:20:02.624]                             if (is.null(name)) 
[13:20:02.624]                               next
[13:20:02.624]                             if (!grepl(pattern, name)) 
[13:20:02.624]                               next
[13:20:02.624]                             invokeRestart(restart)
[13:20:02.624]                             muffled <- TRUE
[13:20:02.624]                             break
[13:20:02.624]                           }
[13:20:02.624]                         }
[13:20:02.624]                       }
[13:20:02.624]                       invisible(muffled)
[13:20:02.624]                     }
[13:20:02.624]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.624]                   }
[13:20:02.624]                 }
[13:20:02.624]                 else {
[13:20:02.624]                   if (TRUE) {
[13:20:02.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.624]                     {
[13:20:02.624]                       inherits <- base::inherits
[13:20:02.624]                       invokeRestart <- base::invokeRestart
[13:20:02.624]                       is.null <- base::is.null
[13:20:02.624]                       muffled <- FALSE
[13:20:02.624]                       if (inherits(cond, "message")) {
[13:20:02.624]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.624]                         if (muffled) 
[13:20:02.624]                           invokeRestart("muffleMessage")
[13:20:02.624]                       }
[13:20:02.624]                       else if (inherits(cond, "warning")) {
[13:20:02.624]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.624]                         if (muffled) 
[13:20:02.624]                           invokeRestart("muffleWarning")
[13:20:02.624]                       }
[13:20:02.624]                       else if (inherits(cond, "condition")) {
[13:20:02.624]                         if (!is.null(pattern)) {
[13:20:02.624]                           computeRestarts <- base::computeRestarts
[13:20:02.624]                           grepl <- base::grepl
[13:20:02.624]                           restarts <- computeRestarts(cond)
[13:20:02.624]                           for (restart in restarts) {
[13:20:02.624]                             name <- restart$name
[13:20:02.624]                             if (is.null(name)) 
[13:20:02.624]                               next
[13:20:02.624]                             if (!grepl(pattern, name)) 
[13:20:02.624]                               next
[13:20:02.624]                             invokeRestart(restart)
[13:20:02.624]                             muffled <- TRUE
[13:20:02.624]                             break
[13:20:02.624]                           }
[13:20:02.624]                         }
[13:20:02.624]                       }
[13:20:02.624]                       invisible(muffled)
[13:20:02.624]                     }
[13:20:02.624]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.624]                   }
[13:20:02.624]                 }
[13:20:02.624]             }
[13:20:02.624]         }))
[13:20:02.624]     }, error = function(ex) {
[13:20:02.624]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.624]                 ...future.rng), started = ...future.startTime, 
[13:20:02.624]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.624]             version = "1.8"), class = "FutureResult")
[13:20:02.624]     }, finally = {
[13:20:02.624]         if (!identical(...future.workdir, getwd())) 
[13:20:02.624]             setwd(...future.workdir)
[13:20:02.624]         {
[13:20:02.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.624]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.624]             }
[13:20:02.624]             base::options(...future.oldOptions)
[13:20:02.624]             if (.Platform$OS.type == "windows") {
[13:20:02.624]                 old_names <- names(...future.oldEnvVars)
[13:20:02.624]                 envs <- base::Sys.getenv()
[13:20:02.624]                 names <- names(envs)
[13:20:02.624]                 common <- intersect(names, old_names)
[13:20:02.624]                 added <- setdiff(names, old_names)
[13:20:02.624]                 removed <- setdiff(old_names, names)
[13:20:02.624]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.624]                   envs[common]]
[13:20:02.624]                 NAMES <- toupper(changed)
[13:20:02.624]                 args <- list()
[13:20:02.624]                 for (kk in seq_along(NAMES)) {
[13:20:02.624]                   name <- changed[[kk]]
[13:20:02.624]                   NAME <- NAMES[[kk]]
[13:20:02.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.624]                     next
[13:20:02.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.624]                 }
[13:20:02.624]                 NAMES <- toupper(added)
[13:20:02.624]                 for (kk in seq_along(NAMES)) {
[13:20:02.624]                   name <- added[[kk]]
[13:20:02.624]                   NAME <- NAMES[[kk]]
[13:20:02.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.624]                     next
[13:20:02.624]                   args[[name]] <- ""
[13:20:02.624]                 }
[13:20:02.624]                 NAMES <- toupper(removed)
[13:20:02.624]                 for (kk in seq_along(NAMES)) {
[13:20:02.624]                   name <- removed[[kk]]
[13:20:02.624]                   NAME <- NAMES[[kk]]
[13:20:02.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.624]                     next
[13:20:02.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.624]                 }
[13:20:02.624]                 if (length(args) > 0) 
[13:20:02.624]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.624]             }
[13:20:02.624]             else {
[13:20:02.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.624]             }
[13:20:02.624]             {
[13:20:02.624]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.624]                   0L) {
[13:20:02.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.624]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.624]                   base::options(opts)
[13:20:02.624]                 }
[13:20:02.624]                 {
[13:20:02.624]                   {
[13:20:02.624]                     NULL
[13:20:02.624]                     RNGkind("Mersenne-Twister")
[13:20:02.624]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.624]                       inherits = FALSE)
[13:20:02.624]                   }
[13:20:02.624]                   options(future.plan = NULL)
[13:20:02.624]                   if (is.na(NA_character_)) 
[13:20:02.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.624]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:02.624]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:02.624]                     envir = parent.frame()) 
[13:20:02.624]                   {
[13:20:02.624]                     if (is.function(workers)) 
[13:20:02.624]                       workers <- workers()
[13:20:02.624]                     workers <- structure(as.integer(workers), 
[13:20:02.624]                       class = class(workers))
[13:20:02.624]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:02.624]                       workers >= 1)
[13:20:02.624]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:02.624]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:02.624]                     }
[13:20:02.624]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:02.624]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:02.624]                       envir = envir)
[13:20:02.624]                     if (!future$lazy) 
[13:20:02.624]                       future <- run(future)
[13:20:02.624]                     invisible(future)
[13:20:02.624]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.624]                 }
[13:20:02.624]             }
[13:20:02.624]         }
[13:20:02.624]     })
[13:20:02.624]     if (TRUE) {
[13:20:02.624]         base::sink(type = "output", split = FALSE)
[13:20:02.624]         if (TRUE) {
[13:20:02.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.624]         }
[13:20:02.624]         else {
[13:20:02.624]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.624]         }
[13:20:02.624]         base::close(...future.stdout)
[13:20:02.624]         ...future.stdout <- NULL
[13:20:02.624]     }
[13:20:02.624]     ...future.result$conditions <- ...future.conditions
[13:20:02.624]     ...future.result$finished <- base::Sys.time()
[13:20:02.624]     ...future.result
[13:20:02.624] }
[13:20:02.626] assign_globals() ...
[13:20:02.626] List of 5
[13:20:02.626]  $ ...future.FUN            :function (object, ...)  
[13:20:02.626]  $ future.call.arguments    : list()
[13:20:02.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.626]  $ ...future.elements_ii    :List of 3
[13:20:02.626]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.626]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.626]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.626]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.626]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.626]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.626]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.626]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.626]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.626]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.626]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.626]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.626]  $ ...future.seeds_ii       : NULL
[13:20:02.626]  $ ...future.globals.maxSize: NULL
[13:20:02.626]  - attr(*, "where")=List of 5
[13:20:02.626]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.626]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.626]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.626]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.626]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.626]  - attr(*, "resolved")= logi FALSE
[13:20:02.626]  - attr(*, "total_size")= num 1240
[13:20:02.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.626]  - attr(*, "already-done")= logi TRUE
[13:20:02.638] - copied ‘...future.FUN’ to environment
[13:20:02.638] - copied ‘future.call.arguments’ to environment
[13:20:02.638] - copied ‘...future.elements_ii’ to environment
[13:20:02.638] - copied ‘...future.seeds_ii’ to environment
[13:20:02.639] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.639] assign_globals() ... done
[13:20:02.639] plan(): Setting new future strategy stack:
[13:20:02.639] List of future strategies:
[13:20:02.639] 1. sequential:
[13:20:02.639]    - args: function (..., envir = parent.frame())
[13:20:02.639]    - tweaked: FALSE
[13:20:02.639]    - call: NULL
[13:20:02.640] plan(): nbrOfWorkers() = 1
[13:20:02.642] plan(): Setting new future strategy stack:
[13:20:02.642] List of future strategies:
[13:20:02.642] 1. multisession:
[13:20:02.642]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:02.642]    - tweaked: FALSE
[13:20:02.642]    - call: plan(strategy)
[13:20:02.646] plan(): nbrOfWorkers() = 1
[13:20:02.646] SequentialFuture started (and completed)
[13:20:02.647] - Launch lazy future ... done
[13:20:02.647] run() for ‘SequentialFuture’ ... done
[13:20:02.647] Created future:
[13:20:02.647] SequentialFuture:
[13:20:02.647] Label: ‘future_by-1’
[13:20:02.647] Expression:
[13:20:02.647] {
[13:20:02.647]     do.call(function(...) {
[13:20:02.647]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.647]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.647]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.647]             on.exit(options(oopts), add = TRUE)
[13:20:02.647]         }
[13:20:02.647]         {
[13:20:02.647]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.647]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.647]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.647]             })
[13:20:02.647]         }
[13:20:02.647]     }, args = future.call.arguments)
[13:20:02.647] }
[13:20:02.647] Lazy evaluation: FALSE
[13:20:02.647] Asynchronous evaluation: FALSE
[13:20:02.647] Local evaluation: TRUE
[13:20:02.647] Environment: 0x55acee74bd98
[13:20:02.647] Capture standard output: TRUE
[13:20:02.647] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.647] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.647] Packages: <none>
[13:20:02.647] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.647] Resolved: TRUE
[13:20:02.647] Value: 5.37 KiB of class ‘list’
[13:20:02.647] Early signaling: FALSE
[13:20:02.647] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.647] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.648] Chunk #1 of 1 ... DONE
[13:20:02.648] Launching 1 futures (chunks) ... DONE
[13:20:02.649] Resolving 1 futures (chunks) ...
[13:20:02.649] resolve() on list ...
[13:20:02.649]  recursive: 0
[13:20:02.649]  length: 1
[13:20:02.649] 
[13:20:02.649] resolved() for ‘SequentialFuture’ ...
[13:20:02.649] - state: ‘finished’
[13:20:02.649] - run: TRUE
[13:20:02.649] - result: ‘FutureResult’
[13:20:02.649] resolved() for ‘SequentialFuture’ ... done
[13:20:02.650] Future #1
[13:20:02.650] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.650] - nx: 1
[13:20:02.650] - relay: TRUE
[13:20:02.650] - stdout: TRUE
[13:20:02.650] - signal: TRUE
[13:20:02.650] - resignal: FALSE
[13:20:02.650] - force: TRUE
[13:20:02.650] - relayed: [n=1] FALSE
[13:20:02.650] - queued futures: [n=1] FALSE
[13:20:02.651]  - until=1
[13:20:02.651]  - relaying element #1
[13:20:02.651] - relayed: [n=1] TRUE
[13:20:02.651] - queued futures: [n=1] TRUE
[13:20:02.651] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.651]  length: 0 (resolved future 1)
[13:20:02.651] Relaying remaining futures
[13:20:02.651] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.651] - nx: 1
[13:20:02.651] - relay: TRUE
[13:20:02.652] - stdout: TRUE
[13:20:02.652] - signal: TRUE
[13:20:02.652] - resignal: FALSE
[13:20:02.652] - force: TRUE
[13:20:02.652] - relayed: [n=1] TRUE
[13:20:02.652] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.652] - relayed: [n=1] TRUE
[13:20:02.652] - queued futures: [n=1] TRUE
[13:20:02.652] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.652] resolve() on list ... DONE
[13:20:02.653]  - Number of value chunks collected: 1
[13:20:02.653] Resolving 1 futures (chunks) ... DONE
[13:20:02.653] Reducing values from 1 chunks ...
[13:20:02.653]  - Number of values collected after concatenation: 3
[13:20:02.653]  - Number of values expected: 3
[13:20:02.653] Reducing values from 1 chunks ... DONE
[13:20:02.653] future_lapply() ... DONE
[13:20:02.653] future_by_internal() ... DONE
[13:20:02.654] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[13:20:02.655] plan(): Setting new future strategy stack:
[13:20:02.655] List of future strategies:
[13:20:02.655] 1. sequential:
[13:20:02.655]    - args: function (..., envir = parent.frame())
[13:20:02.655]    - tweaked: FALSE
[13:20:02.655]    - call: plan(strategy)
[13:20:02.656] plan(): nbrOfWorkers() = 1
[13:20:02.656] future_by_internal() ...
[13:20:02.656] future_lapply() ...
[13:20:02.657] Number of chunks: 1
[13:20:02.657] getGlobalsAndPackagesXApply() ...
[13:20:02.657]  - future.globals: TRUE
[13:20:02.657] getGlobalsAndPackages() ...
[13:20:02.657] Searching for globals...
[13:20:02.658] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.658] Searching for globals ... DONE
[13:20:02.658] Resolving globals: FALSE
[13:20:02.659] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.659] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.659] - globals: [1] ‘FUN’
[13:20:02.659] 
[13:20:02.659] getGlobalsAndPackages() ... DONE
[13:20:02.659]  - globals found/used: [n=1] ‘FUN’
[13:20:02.660]  - needed namespaces: [n=0] 
[13:20:02.660] Finding globals ... DONE
[13:20:02.660]  - use_args: TRUE
[13:20:02.660]  - Getting '...' globals ...
[13:20:02.660] resolve() on list ...
[13:20:02.660]  recursive: 0
[13:20:02.660]  length: 1
[13:20:02.661]  elements: ‘...’
[13:20:02.661]  length: 0 (resolved future 1)
[13:20:02.661] resolve() on list ... DONE
[13:20:02.661]    - '...' content: [n=0] 
[13:20:02.661] List of 1
[13:20:02.661]  $ ...: list()
[13:20:02.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.661]  - attr(*, "where")=List of 1
[13:20:02.661]   ..$ ...:<environment: 0x55aceea05248> 
[13:20:02.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.661]  - attr(*, "resolved")= logi TRUE
[13:20:02.661]  - attr(*, "total_size")= num NA
[13:20:02.666]  - Getting '...' globals ... DONE
[13:20:02.667] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.667] List of 2
[13:20:02.667]  $ ...future.FUN:function (object, ...)  
[13:20:02.667]  $ ...          : list()
[13:20:02.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.667]  - attr(*, "where")=List of 2
[13:20:02.667]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.667]   ..$ ...          :<environment: 0x55aceea05248> 
[13:20:02.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.667]  - attr(*, "resolved")= logi FALSE
[13:20:02.667]  - attr(*, "total_size")= num 1240
[13:20:02.670] Packages to be attached in all futures: [n=0] 
[13:20:02.670] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.670] Number of futures (= number of chunks): 1
[13:20:02.670] Launching 1 futures (chunks) ...
[13:20:02.670] Chunk #1 of 1 ...
[13:20:02.670]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.670] getGlobalsAndPackages() ...
[13:20:02.671] Searching for globals...
[13:20:02.671] 
[13:20:02.671] Searching for globals ... DONE
[13:20:02.671] - globals: [0] <none>
[13:20:02.671] getGlobalsAndPackages() ... DONE
[13:20:02.671]    + additional globals found: [n=0] 
[13:20:02.672]    + additional namespaces needed: [n=0] 
[13:20:02.672]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.672]  - seeds: <none>
[13:20:02.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.672] getGlobalsAndPackages() ...
[13:20:02.672] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.672] Resolving globals: FALSE
[13:20:02.672] Tweak future expression to call with '...' arguments ...
[13:20:02.672] {
[13:20:02.672]     do.call(function(...) {
[13:20:02.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.672]             on.exit(options(oopts), add = TRUE)
[13:20:02.672]         }
[13:20:02.672]         {
[13:20:02.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.672]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.672]             })
[13:20:02.672]         }
[13:20:02.672]     }, args = future.call.arguments)
[13:20:02.672] }
[13:20:02.673] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.673] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.673] 
[13:20:02.673] getGlobalsAndPackages() ... DONE
[13:20:02.674] run() for ‘Future’ ...
[13:20:02.674] - state: ‘created’
[13:20:02.674] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:02.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.674]   - Field: ‘label’
[13:20:02.675]   - Field: ‘local’
[13:20:02.675]   - Field: ‘owner’
[13:20:02.675]   - Field: ‘envir’
[13:20:02.675]   - Field: ‘packages’
[13:20:02.675]   - Field: ‘gc’
[13:20:02.675]   - Field: ‘conditions’
[13:20:02.675]   - Field: ‘expr’
[13:20:02.675]   - Field: ‘uuid’
[13:20:02.675]   - Field: ‘seed’
[13:20:02.675]   - Field: ‘version’
[13:20:02.675]   - Field: ‘result’
[13:20:02.676]   - Field: ‘asynchronous’
[13:20:02.676]   - Field: ‘calls’
[13:20:02.676]   - Field: ‘globals’
[13:20:02.676]   - Field: ‘stdout’
[13:20:02.676]   - Field: ‘earlySignal’
[13:20:02.676]   - Field: ‘lazy’
[13:20:02.676]   - Field: ‘state’
[13:20:02.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.676] - Launch lazy future ...
[13:20:02.677] Packages needed by the future expression (n = 0): <none>
[13:20:02.677] Packages needed by future strategies (n = 0): <none>
[13:20:02.677] {
[13:20:02.677]     {
[13:20:02.677]         {
[13:20:02.677]             ...future.startTime <- base::Sys.time()
[13:20:02.677]             {
[13:20:02.677]                 {
[13:20:02.677]                   {
[13:20:02.677]                     base::local({
[13:20:02.677]                       has_future <- base::requireNamespace("future", 
[13:20:02.677]                         quietly = TRUE)
[13:20:02.677]                       if (has_future) {
[13:20:02.677]                         ns <- base::getNamespace("future")
[13:20:02.677]                         version <- ns[[".package"]][["version"]]
[13:20:02.677]                         if (is.null(version)) 
[13:20:02.677]                           version <- utils::packageVersion("future")
[13:20:02.677]                       }
[13:20:02.677]                       else {
[13:20:02.677]                         version <- NULL
[13:20:02.677]                       }
[13:20:02.677]                       if (!has_future || version < "1.8.0") {
[13:20:02.677]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.677]                           "", base::R.version$version.string), 
[13:20:02.677]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.677]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.677]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.677]                             "release", "version")], collapse = " "), 
[13:20:02.677]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.677]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.677]                           info)
[13:20:02.677]                         info <- base::paste(info, collapse = "; ")
[13:20:02.677]                         if (!has_future) {
[13:20:02.677]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.677]                             info)
[13:20:02.677]                         }
[13:20:02.677]                         else {
[13:20:02.677]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.677]                             info, version)
[13:20:02.677]                         }
[13:20:02.677]                         base::stop(msg)
[13:20:02.677]                       }
[13:20:02.677]                     })
[13:20:02.677]                   }
[13:20:02.677]                   options(future.plan = NULL)
[13:20:02.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.677]                 }
[13:20:02.677]                 ...future.workdir <- getwd()
[13:20:02.677]             }
[13:20:02.677]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.677]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.677]         }
[13:20:02.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.677]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.677]             base::names(...future.oldOptions))
[13:20:02.677]     }
[13:20:02.677]     if (FALSE) {
[13:20:02.677]     }
[13:20:02.677]     else {
[13:20:02.677]         if (TRUE) {
[13:20:02.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.677]                 open = "w")
[13:20:02.677]         }
[13:20:02.677]         else {
[13:20:02.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.677]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.677]         }
[13:20:02.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.677]             base::sink(type = "output", split = FALSE)
[13:20:02.677]             base::close(...future.stdout)
[13:20:02.677]         }, add = TRUE)
[13:20:02.677]     }
[13:20:02.677]     ...future.frame <- base::sys.nframe()
[13:20:02.677]     ...future.conditions <- base::list()
[13:20:02.677]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.677]     if (FALSE) {
[13:20:02.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.677]     }
[13:20:02.677]     ...future.result <- base::tryCatch({
[13:20:02.677]         base::withCallingHandlers({
[13:20:02.677]             ...future.value <- base::withVisible(base::local({
[13:20:02.677]                 do.call(function(...) {
[13:20:02.677]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.677]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.677]                     ...future.globals.maxSize)) {
[13:20:02.677]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.677]                     on.exit(options(oopts), add = TRUE)
[13:20:02.677]                   }
[13:20:02.677]                   {
[13:20:02.677]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.677]                       FUN = function(jj) {
[13:20:02.677]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.677]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.677]                       })
[13:20:02.677]                   }
[13:20:02.677]                 }, args = future.call.arguments)
[13:20:02.677]             }))
[13:20:02.677]             future::FutureResult(value = ...future.value$value, 
[13:20:02.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.677]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.677]                     ...future.globalenv.names))
[13:20:02.677]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.677]         }, condition = base::local({
[13:20:02.677]             c <- base::c
[13:20:02.677]             inherits <- base::inherits
[13:20:02.677]             invokeRestart <- base::invokeRestart
[13:20:02.677]             length <- base::length
[13:20:02.677]             list <- base::list
[13:20:02.677]             seq.int <- base::seq.int
[13:20:02.677]             signalCondition <- base::signalCondition
[13:20:02.677]             sys.calls <- base::sys.calls
[13:20:02.677]             `[[` <- base::`[[`
[13:20:02.677]             `+` <- base::`+`
[13:20:02.677]             `<<-` <- base::`<<-`
[13:20:02.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.677]                   3L)]
[13:20:02.677]             }
[13:20:02.677]             function(cond) {
[13:20:02.677]                 is_error <- inherits(cond, "error")
[13:20:02.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.677]                   NULL)
[13:20:02.677]                 if (is_error) {
[13:20:02.677]                   sessionInformation <- function() {
[13:20:02.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.677]                       search = base::search(), system = base::Sys.info())
[13:20:02.677]                   }
[13:20:02.677]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.677]                     cond$call), session = sessionInformation(), 
[13:20:02.677]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.677]                   signalCondition(cond)
[13:20:02.677]                 }
[13:20:02.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.677]                 "immediateCondition"))) {
[13:20:02.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.677]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.677]                   if (TRUE && !signal) {
[13:20:02.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.677]                     {
[13:20:02.677]                       inherits <- base::inherits
[13:20:02.677]                       invokeRestart <- base::invokeRestart
[13:20:02.677]                       is.null <- base::is.null
[13:20:02.677]                       muffled <- FALSE
[13:20:02.677]                       if (inherits(cond, "message")) {
[13:20:02.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.677]                         if (muffled) 
[13:20:02.677]                           invokeRestart("muffleMessage")
[13:20:02.677]                       }
[13:20:02.677]                       else if (inherits(cond, "warning")) {
[13:20:02.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.677]                         if (muffled) 
[13:20:02.677]                           invokeRestart("muffleWarning")
[13:20:02.677]                       }
[13:20:02.677]                       else if (inherits(cond, "condition")) {
[13:20:02.677]                         if (!is.null(pattern)) {
[13:20:02.677]                           computeRestarts <- base::computeRestarts
[13:20:02.677]                           grepl <- base::grepl
[13:20:02.677]                           restarts <- computeRestarts(cond)
[13:20:02.677]                           for (restart in restarts) {
[13:20:02.677]                             name <- restart$name
[13:20:02.677]                             if (is.null(name)) 
[13:20:02.677]                               next
[13:20:02.677]                             if (!grepl(pattern, name)) 
[13:20:02.677]                               next
[13:20:02.677]                             invokeRestart(restart)
[13:20:02.677]                             muffled <- TRUE
[13:20:02.677]                             break
[13:20:02.677]                           }
[13:20:02.677]                         }
[13:20:02.677]                       }
[13:20:02.677]                       invisible(muffled)
[13:20:02.677]                     }
[13:20:02.677]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.677]                   }
[13:20:02.677]                 }
[13:20:02.677]                 else {
[13:20:02.677]                   if (TRUE) {
[13:20:02.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.677]                     {
[13:20:02.677]                       inherits <- base::inherits
[13:20:02.677]                       invokeRestart <- base::invokeRestart
[13:20:02.677]                       is.null <- base::is.null
[13:20:02.677]                       muffled <- FALSE
[13:20:02.677]                       if (inherits(cond, "message")) {
[13:20:02.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.677]                         if (muffled) 
[13:20:02.677]                           invokeRestart("muffleMessage")
[13:20:02.677]                       }
[13:20:02.677]                       else if (inherits(cond, "warning")) {
[13:20:02.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.677]                         if (muffled) 
[13:20:02.677]                           invokeRestart("muffleWarning")
[13:20:02.677]                       }
[13:20:02.677]                       else if (inherits(cond, "condition")) {
[13:20:02.677]                         if (!is.null(pattern)) {
[13:20:02.677]                           computeRestarts <- base::computeRestarts
[13:20:02.677]                           grepl <- base::grepl
[13:20:02.677]                           restarts <- computeRestarts(cond)
[13:20:02.677]                           for (restart in restarts) {
[13:20:02.677]                             name <- restart$name
[13:20:02.677]                             if (is.null(name)) 
[13:20:02.677]                               next
[13:20:02.677]                             if (!grepl(pattern, name)) 
[13:20:02.677]                               next
[13:20:02.677]                             invokeRestart(restart)
[13:20:02.677]                             muffled <- TRUE
[13:20:02.677]                             break
[13:20:02.677]                           }
[13:20:02.677]                         }
[13:20:02.677]                       }
[13:20:02.677]                       invisible(muffled)
[13:20:02.677]                     }
[13:20:02.677]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.677]                   }
[13:20:02.677]                 }
[13:20:02.677]             }
[13:20:02.677]         }))
[13:20:02.677]     }, error = function(ex) {
[13:20:02.677]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.677]                 ...future.rng), started = ...future.startTime, 
[13:20:02.677]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.677]             version = "1.8"), class = "FutureResult")
[13:20:02.677]     }, finally = {
[13:20:02.677]         if (!identical(...future.workdir, getwd())) 
[13:20:02.677]             setwd(...future.workdir)
[13:20:02.677]         {
[13:20:02.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.677]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.677]             }
[13:20:02.677]             base::options(...future.oldOptions)
[13:20:02.677]             if (.Platform$OS.type == "windows") {
[13:20:02.677]                 old_names <- names(...future.oldEnvVars)
[13:20:02.677]                 envs <- base::Sys.getenv()
[13:20:02.677]                 names <- names(envs)
[13:20:02.677]                 common <- intersect(names, old_names)
[13:20:02.677]                 added <- setdiff(names, old_names)
[13:20:02.677]                 removed <- setdiff(old_names, names)
[13:20:02.677]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.677]                   envs[common]]
[13:20:02.677]                 NAMES <- toupper(changed)
[13:20:02.677]                 args <- list()
[13:20:02.677]                 for (kk in seq_along(NAMES)) {
[13:20:02.677]                   name <- changed[[kk]]
[13:20:02.677]                   NAME <- NAMES[[kk]]
[13:20:02.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.677]                     next
[13:20:02.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.677]                 }
[13:20:02.677]                 NAMES <- toupper(added)
[13:20:02.677]                 for (kk in seq_along(NAMES)) {
[13:20:02.677]                   name <- added[[kk]]
[13:20:02.677]                   NAME <- NAMES[[kk]]
[13:20:02.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.677]                     next
[13:20:02.677]                   args[[name]] <- ""
[13:20:02.677]                 }
[13:20:02.677]                 NAMES <- toupper(removed)
[13:20:02.677]                 for (kk in seq_along(NAMES)) {
[13:20:02.677]                   name <- removed[[kk]]
[13:20:02.677]                   NAME <- NAMES[[kk]]
[13:20:02.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.677]                     next
[13:20:02.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.677]                 }
[13:20:02.677]                 if (length(args) > 0) 
[13:20:02.677]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.677]             }
[13:20:02.677]             else {
[13:20:02.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.677]             }
[13:20:02.677]             {
[13:20:02.677]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.677]                   0L) {
[13:20:02.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.677]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.677]                   base::options(opts)
[13:20:02.677]                 }
[13:20:02.677]                 {
[13:20:02.677]                   {
[13:20:02.677]                     NULL
[13:20:02.677]                     RNGkind("Mersenne-Twister")
[13:20:02.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.677]                       inherits = FALSE)
[13:20:02.677]                   }
[13:20:02.677]                   options(future.plan = NULL)
[13:20:02.677]                   if (is.na(NA_character_)) 
[13:20:02.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.677]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:02.677]                   {
[13:20:02.677]                     future <- SequentialFuture(..., envir = envir)
[13:20:02.677]                     if (!future$lazy) 
[13:20:02.677]                       future <- run(future)
[13:20:02.677]                     invisible(future)
[13:20:02.677]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.677]                 }
[13:20:02.677]             }
[13:20:02.677]         }
[13:20:02.677]     })
[13:20:02.677]     if (TRUE) {
[13:20:02.677]         base::sink(type = "output", split = FALSE)
[13:20:02.677]         if (TRUE) {
[13:20:02.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.677]         }
[13:20:02.677]         else {
[13:20:02.677]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.677]         }
[13:20:02.677]         base::close(...future.stdout)
[13:20:02.677]         ...future.stdout <- NULL
[13:20:02.677]     }
[13:20:02.677]     ...future.result$conditions <- ...future.conditions
[13:20:02.677]     ...future.result$finished <- base::Sys.time()
[13:20:02.677]     ...future.result
[13:20:02.677] }
[13:20:02.679] assign_globals() ...
[13:20:02.679] List of 5
[13:20:02.679]  $ ...future.FUN            :function (object, ...)  
[13:20:02.679]  $ future.call.arguments    : list()
[13:20:02.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.679]  $ ...future.elements_ii    :List of 3
[13:20:02.679]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.679]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.679]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.679]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.679]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.679]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.679]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.679]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.679]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.679]  $ ...future.seeds_ii       : NULL
[13:20:02.679]  $ ...future.globals.maxSize: NULL
[13:20:02.679]  - attr(*, "where")=List of 5
[13:20:02.679]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.679]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.679]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.679]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.679]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.679]  - attr(*, "resolved")= logi FALSE
[13:20:02.679]  - attr(*, "total_size")= num 1240
[13:20:02.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.679]  - attr(*, "already-done")= logi TRUE
[13:20:02.689] - copied ‘...future.FUN’ to environment
[13:20:02.689] - copied ‘future.call.arguments’ to environment
[13:20:02.690] - copied ‘...future.elements_ii’ to environment
[13:20:02.690] - copied ‘...future.seeds_ii’ to environment
[13:20:02.690] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.690] assign_globals() ... done
[13:20:02.690] plan(): Setting new future strategy stack:
[13:20:02.690] List of future strategies:
[13:20:02.690] 1. sequential:
[13:20:02.690]    - args: function (..., envir = parent.frame())
[13:20:02.690]    - tweaked: FALSE
[13:20:02.690]    - call: NULL
[13:20:02.691] plan(): nbrOfWorkers() = 1
[13:20:02.693] plan(): Setting new future strategy stack:
[13:20:02.693] List of future strategies:
[13:20:02.693] 1. sequential:
[13:20:02.693]    - args: function (..., envir = parent.frame())
[13:20:02.693]    - tweaked: FALSE
[13:20:02.693]    - call: plan(strategy)
[13:20:02.694] plan(): nbrOfWorkers() = 1
[13:20:02.694] SequentialFuture started (and completed)
[13:20:02.694] - Launch lazy future ... done
[13:20:02.694] run() for ‘SequentialFuture’ ... done
[13:20:02.694] Created future:
[13:20:02.695] SequentialFuture:
[13:20:02.695] Label: ‘future_by-1’
[13:20:02.695] Expression:
[13:20:02.695] {
[13:20:02.695]     do.call(function(...) {
[13:20:02.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.695]             on.exit(options(oopts), add = TRUE)
[13:20:02.695]         }
[13:20:02.695]         {
[13:20:02.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.695]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.695]             })
[13:20:02.695]         }
[13:20:02.695]     }, args = future.call.arguments)
[13:20:02.695] }
[13:20:02.695] Lazy evaluation: FALSE
[13:20:02.695] Asynchronous evaluation: FALSE
[13:20:02.695] Local evaluation: TRUE
[13:20:02.695] Environment: R_GlobalEnv
[13:20:02.695] Capture standard output: TRUE
[13:20:02.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.695] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.695] Packages: <none>
[13:20:02.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.695] Resolved: TRUE
[13:20:02.695] Value: 4.62 KiB of class ‘list’
[13:20:02.695] Early signaling: FALSE
[13:20:02.695] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.695] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.696] Chunk #1 of 1 ... DONE
[13:20:02.696] Launching 1 futures (chunks) ... DONE
[13:20:02.696] Resolving 1 futures (chunks) ...
[13:20:02.696] resolve() on list ...
[13:20:02.696]  recursive: 0
[13:20:02.696]  length: 1
[13:20:02.696] 
[13:20:02.697] resolved() for ‘SequentialFuture’ ...
[13:20:02.697] - state: ‘finished’
[13:20:02.697] - run: TRUE
[13:20:02.697] - result: ‘FutureResult’
[13:20:02.697] resolved() for ‘SequentialFuture’ ... done
[13:20:02.697] Future #1
[13:20:02.697] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.697] - nx: 1
[13:20:02.697] - relay: TRUE
[13:20:02.697] - stdout: TRUE
[13:20:02.698] - signal: TRUE
[13:20:02.698] - resignal: FALSE
[13:20:02.698] - force: TRUE
[13:20:02.698] - relayed: [n=1] FALSE
[13:20:02.698] - queued futures: [n=1] FALSE
[13:20:02.698]  - until=1
[13:20:02.698]  - relaying element #1
[13:20:02.698] - relayed: [n=1] TRUE
[13:20:02.698] - queued futures: [n=1] TRUE
[13:20:02.698] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.699]  length: 0 (resolved future 1)
[13:20:02.699] Relaying remaining futures
[13:20:02.699] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.699] - nx: 1
[13:20:02.699] - relay: TRUE
[13:20:02.699] - stdout: TRUE
[13:20:02.699] - signal: TRUE
[13:20:02.699] - resignal: FALSE
[13:20:02.699] - force: TRUE
[13:20:02.699] - relayed: [n=1] TRUE
[13:20:02.699] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.700] - relayed: [n=1] TRUE
[13:20:02.700] - queued futures: [n=1] TRUE
[13:20:02.700] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.700] resolve() on list ... DONE
[13:20:02.700]  - Number of value chunks collected: 1
[13:20:02.700] Resolving 1 futures (chunks) ... DONE
[13:20:02.700] Reducing values from 1 chunks ...
[13:20:02.700]  - Number of values collected after concatenation: 3
[13:20:02.700]  - Number of values expected: 3
[13:20:02.700] Reducing values from 1 chunks ... DONE
[13:20:02.701] future_lapply() ... DONE
[13:20:02.701] future_by_internal() ... DONE
[13:20:02.701] future_by_internal() ...
[13:20:02.701] future_lapply() ...
[13:20:02.702] Number of chunks: 1
[13:20:02.702] getGlobalsAndPackagesXApply() ...
[13:20:02.702]  - future.globals: TRUE
[13:20:02.702] getGlobalsAndPackages() ...
[13:20:02.702] Searching for globals...
[13:20:02.703] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.703] Searching for globals ... DONE
[13:20:02.704] Resolving globals: FALSE
[13:20:02.704] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.704] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.704] - globals: [1] ‘FUN’
[13:20:02.705] 
[13:20:02.705] getGlobalsAndPackages() ... DONE
[13:20:02.705]  - globals found/used: [n=1] ‘FUN’
[13:20:02.705]  - needed namespaces: [n=0] 
[13:20:02.705] Finding globals ... DONE
[13:20:02.705]  - use_args: TRUE
[13:20:02.705]  - Getting '...' globals ...
[13:20:02.705] resolve() on list ...
[13:20:02.705]  recursive: 0
[13:20:02.706]  length: 1
[13:20:02.706]  elements: ‘...’
[13:20:02.706]  length: 0 (resolved future 1)
[13:20:02.706] resolve() on list ... DONE
[13:20:02.706]    - '...' content: [n=1] ‘digits’
[13:20:02.706] List of 1
[13:20:02.706]  $ ...:List of 1
[13:20:02.706]   ..$ digits: int 2
[13:20:02.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.706]  - attr(*, "where")=List of 1
[13:20:02.706]   ..$ ...:<environment: 0x55acee69edf8> 
[13:20:02.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.706]  - attr(*, "resolved")= logi TRUE
[13:20:02.706]  - attr(*, "total_size")= num NA
[13:20:02.709]  - Getting '...' globals ... DONE
[13:20:02.711] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.711] List of 2
[13:20:02.711]  $ ...future.FUN:function (object, ...)  
[13:20:02.711]  $ ...          :List of 1
[13:20:02.711]   ..$ digits: int 2
[13:20:02.711]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.711]  - attr(*, "where")=List of 2
[13:20:02.711]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.711]   ..$ ...          :<environment: 0x55acee69edf8> 
[13:20:02.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.711]  - attr(*, "resolved")= logi FALSE
[13:20:02.711]  - attr(*, "total_size")= num 1296
[13:20:02.716] Packages to be attached in all futures: [n=0] 
[13:20:02.716] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.716] Number of futures (= number of chunks): 1
[13:20:02.716] Launching 1 futures (chunks) ...
[13:20:02.716] Chunk #1 of 1 ...
[13:20:02.716]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.716] getGlobalsAndPackages() ...
[13:20:02.717] Searching for globals...
[13:20:02.717] 
[13:20:02.717] Searching for globals ... DONE
[13:20:02.717] - globals: [0] <none>
[13:20:02.717] getGlobalsAndPackages() ... DONE
[13:20:02.717]    + additional globals found: [n=0] 
[13:20:02.717]    + additional namespaces needed: [n=0] 
[13:20:02.717]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.717]  - seeds: <none>
[13:20:02.718]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.718] getGlobalsAndPackages() ...
[13:20:02.718] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.718] Resolving globals: FALSE
[13:20:02.718] Tweak future expression to call with '...' arguments ...
[13:20:02.718] {
[13:20:02.718]     do.call(function(...) {
[13:20:02.718]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.718]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.718]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.718]             on.exit(options(oopts), add = TRUE)
[13:20:02.718]         }
[13:20:02.718]         {
[13:20:02.718]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.718]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.718]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.718]             })
[13:20:02.718]         }
[13:20:02.718]     }, args = future.call.arguments)
[13:20:02.718] }
[13:20:02.718] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.719] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.719] 
[13:20:02.719] getGlobalsAndPackages() ... DONE
[13:20:02.719] run() for ‘Future’ ...
[13:20:02.719] - state: ‘created’
[13:20:02.719] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:02.720] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.720] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.720]   - Field: ‘label’
[13:20:02.720]   - Field: ‘local’
[13:20:02.720]   - Field: ‘owner’
[13:20:02.720]   - Field: ‘envir’
[13:20:02.720]   - Field: ‘packages’
[13:20:02.721]   - Field: ‘gc’
[13:20:02.721]   - Field: ‘conditions’
[13:20:02.721]   - Field: ‘expr’
[13:20:02.721]   - Field: ‘uuid’
[13:20:02.721]   - Field: ‘seed’
[13:20:02.721]   - Field: ‘version’
[13:20:02.721]   - Field: ‘result’
[13:20:02.721]   - Field: ‘asynchronous’
[13:20:02.721]   - Field: ‘calls’
[13:20:02.721]   - Field: ‘globals’
[13:20:02.721]   - Field: ‘stdout’
[13:20:02.722]   - Field: ‘earlySignal’
[13:20:02.722]   - Field: ‘lazy’
[13:20:02.722]   - Field: ‘state’
[13:20:02.722] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.722] - Launch lazy future ...
[13:20:02.722] Packages needed by the future expression (n = 0): <none>
[13:20:02.722] Packages needed by future strategies (n = 0): <none>
[13:20:02.723] {
[13:20:02.723]     {
[13:20:02.723]         {
[13:20:02.723]             ...future.startTime <- base::Sys.time()
[13:20:02.723]             {
[13:20:02.723]                 {
[13:20:02.723]                   {
[13:20:02.723]                     base::local({
[13:20:02.723]                       has_future <- base::requireNamespace("future", 
[13:20:02.723]                         quietly = TRUE)
[13:20:02.723]                       if (has_future) {
[13:20:02.723]                         ns <- base::getNamespace("future")
[13:20:02.723]                         version <- ns[[".package"]][["version"]]
[13:20:02.723]                         if (is.null(version)) 
[13:20:02.723]                           version <- utils::packageVersion("future")
[13:20:02.723]                       }
[13:20:02.723]                       else {
[13:20:02.723]                         version <- NULL
[13:20:02.723]                       }
[13:20:02.723]                       if (!has_future || version < "1.8.0") {
[13:20:02.723]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.723]                           "", base::R.version$version.string), 
[13:20:02.723]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.723]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.723]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.723]                             "release", "version")], collapse = " "), 
[13:20:02.723]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.723]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.723]                           info)
[13:20:02.723]                         info <- base::paste(info, collapse = "; ")
[13:20:02.723]                         if (!has_future) {
[13:20:02.723]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.723]                             info)
[13:20:02.723]                         }
[13:20:02.723]                         else {
[13:20:02.723]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.723]                             info, version)
[13:20:02.723]                         }
[13:20:02.723]                         base::stop(msg)
[13:20:02.723]                       }
[13:20:02.723]                     })
[13:20:02.723]                   }
[13:20:02.723]                   options(future.plan = NULL)
[13:20:02.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.723]                 }
[13:20:02.723]                 ...future.workdir <- getwd()
[13:20:02.723]             }
[13:20:02.723]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.723]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.723]         }
[13:20:02.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.723]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.723]             base::names(...future.oldOptions))
[13:20:02.723]     }
[13:20:02.723]     if (FALSE) {
[13:20:02.723]     }
[13:20:02.723]     else {
[13:20:02.723]         if (TRUE) {
[13:20:02.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.723]                 open = "w")
[13:20:02.723]         }
[13:20:02.723]         else {
[13:20:02.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.723]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.723]         }
[13:20:02.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.723]             base::sink(type = "output", split = FALSE)
[13:20:02.723]             base::close(...future.stdout)
[13:20:02.723]         }, add = TRUE)
[13:20:02.723]     }
[13:20:02.723]     ...future.frame <- base::sys.nframe()
[13:20:02.723]     ...future.conditions <- base::list()
[13:20:02.723]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.723]     if (FALSE) {
[13:20:02.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.723]     }
[13:20:02.723]     ...future.result <- base::tryCatch({
[13:20:02.723]         base::withCallingHandlers({
[13:20:02.723]             ...future.value <- base::withVisible(base::local({
[13:20:02.723]                 do.call(function(...) {
[13:20:02.723]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.723]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.723]                     ...future.globals.maxSize)) {
[13:20:02.723]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.723]                     on.exit(options(oopts), add = TRUE)
[13:20:02.723]                   }
[13:20:02.723]                   {
[13:20:02.723]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.723]                       FUN = function(jj) {
[13:20:02.723]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.723]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.723]                       })
[13:20:02.723]                   }
[13:20:02.723]                 }, args = future.call.arguments)
[13:20:02.723]             }))
[13:20:02.723]             future::FutureResult(value = ...future.value$value, 
[13:20:02.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.723]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.723]                     ...future.globalenv.names))
[13:20:02.723]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.723]         }, condition = base::local({
[13:20:02.723]             c <- base::c
[13:20:02.723]             inherits <- base::inherits
[13:20:02.723]             invokeRestart <- base::invokeRestart
[13:20:02.723]             length <- base::length
[13:20:02.723]             list <- base::list
[13:20:02.723]             seq.int <- base::seq.int
[13:20:02.723]             signalCondition <- base::signalCondition
[13:20:02.723]             sys.calls <- base::sys.calls
[13:20:02.723]             `[[` <- base::`[[`
[13:20:02.723]             `+` <- base::`+`
[13:20:02.723]             `<<-` <- base::`<<-`
[13:20:02.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.723]                   3L)]
[13:20:02.723]             }
[13:20:02.723]             function(cond) {
[13:20:02.723]                 is_error <- inherits(cond, "error")
[13:20:02.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.723]                   NULL)
[13:20:02.723]                 if (is_error) {
[13:20:02.723]                   sessionInformation <- function() {
[13:20:02.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.723]                       search = base::search(), system = base::Sys.info())
[13:20:02.723]                   }
[13:20:02.723]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.723]                     cond$call), session = sessionInformation(), 
[13:20:02.723]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.723]                   signalCondition(cond)
[13:20:02.723]                 }
[13:20:02.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.723]                 "immediateCondition"))) {
[13:20:02.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.723]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.723]                   if (TRUE && !signal) {
[13:20:02.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.723]                     {
[13:20:02.723]                       inherits <- base::inherits
[13:20:02.723]                       invokeRestart <- base::invokeRestart
[13:20:02.723]                       is.null <- base::is.null
[13:20:02.723]                       muffled <- FALSE
[13:20:02.723]                       if (inherits(cond, "message")) {
[13:20:02.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.723]                         if (muffled) 
[13:20:02.723]                           invokeRestart("muffleMessage")
[13:20:02.723]                       }
[13:20:02.723]                       else if (inherits(cond, "warning")) {
[13:20:02.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.723]                         if (muffled) 
[13:20:02.723]                           invokeRestart("muffleWarning")
[13:20:02.723]                       }
[13:20:02.723]                       else if (inherits(cond, "condition")) {
[13:20:02.723]                         if (!is.null(pattern)) {
[13:20:02.723]                           computeRestarts <- base::computeRestarts
[13:20:02.723]                           grepl <- base::grepl
[13:20:02.723]                           restarts <- computeRestarts(cond)
[13:20:02.723]                           for (restart in restarts) {
[13:20:02.723]                             name <- restart$name
[13:20:02.723]                             if (is.null(name)) 
[13:20:02.723]                               next
[13:20:02.723]                             if (!grepl(pattern, name)) 
[13:20:02.723]                               next
[13:20:02.723]                             invokeRestart(restart)
[13:20:02.723]                             muffled <- TRUE
[13:20:02.723]                             break
[13:20:02.723]                           }
[13:20:02.723]                         }
[13:20:02.723]                       }
[13:20:02.723]                       invisible(muffled)
[13:20:02.723]                     }
[13:20:02.723]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.723]                   }
[13:20:02.723]                 }
[13:20:02.723]                 else {
[13:20:02.723]                   if (TRUE) {
[13:20:02.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.723]                     {
[13:20:02.723]                       inherits <- base::inherits
[13:20:02.723]                       invokeRestart <- base::invokeRestart
[13:20:02.723]                       is.null <- base::is.null
[13:20:02.723]                       muffled <- FALSE
[13:20:02.723]                       if (inherits(cond, "message")) {
[13:20:02.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.723]                         if (muffled) 
[13:20:02.723]                           invokeRestart("muffleMessage")
[13:20:02.723]                       }
[13:20:02.723]                       else if (inherits(cond, "warning")) {
[13:20:02.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.723]                         if (muffled) 
[13:20:02.723]                           invokeRestart("muffleWarning")
[13:20:02.723]                       }
[13:20:02.723]                       else if (inherits(cond, "condition")) {
[13:20:02.723]                         if (!is.null(pattern)) {
[13:20:02.723]                           computeRestarts <- base::computeRestarts
[13:20:02.723]                           grepl <- base::grepl
[13:20:02.723]                           restarts <- computeRestarts(cond)
[13:20:02.723]                           for (restart in restarts) {
[13:20:02.723]                             name <- restart$name
[13:20:02.723]                             if (is.null(name)) 
[13:20:02.723]                               next
[13:20:02.723]                             if (!grepl(pattern, name)) 
[13:20:02.723]                               next
[13:20:02.723]                             invokeRestart(restart)
[13:20:02.723]                             muffled <- TRUE
[13:20:02.723]                             break
[13:20:02.723]                           }
[13:20:02.723]                         }
[13:20:02.723]                       }
[13:20:02.723]                       invisible(muffled)
[13:20:02.723]                     }
[13:20:02.723]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.723]                   }
[13:20:02.723]                 }
[13:20:02.723]             }
[13:20:02.723]         }))
[13:20:02.723]     }, error = function(ex) {
[13:20:02.723]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.723]                 ...future.rng), started = ...future.startTime, 
[13:20:02.723]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.723]             version = "1.8"), class = "FutureResult")
[13:20:02.723]     }, finally = {
[13:20:02.723]         if (!identical(...future.workdir, getwd())) 
[13:20:02.723]             setwd(...future.workdir)
[13:20:02.723]         {
[13:20:02.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.723]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.723]             }
[13:20:02.723]             base::options(...future.oldOptions)
[13:20:02.723]             if (.Platform$OS.type == "windows") {
[13:20:02.723]                 old_names <- names(...future.oldEnvVars)
[13:20:02.723]                 envs <- base::Sys.getenv()
[13:20:02.723]                 names <- names(envs)
[13:20:02.723]                 common <- intersect(names, old_names)
[13:20:02.723]                 added <- setdiff(names, old_names)
[13:20:02.723]                 removed <- setdiff(old_names, names)
[13:20:02.723]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.723]                   envs[common]]
[13:20:02.723]                 NAMES <- toupper(changed)
[13:20:02.723]                 args <- list()
[13:20:02.723]                 for (kk in seq_along(NAMES)) {
[13:20:02.723]                   name <- changed[[kk]]
[13:20:02.723]                   NAME <- NAMES[[kk]]
[13:20:02.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.723]                     next
[13:20:02.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.723]                 }
[13:20:02.723]                 NAMES <- toupper(added)
[13:20:02.723]                 for (kk in seq_along(NAMES)) {
[13:20:02.723]                   name <- added[[kk]]
[13:20:02.723]                   NAME <- NAMES[[kk]]
[13:20:02.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.723]                     next
[13:20:02.723]                   args[[name]] <- ""
[13:20:02.723]                 }
[13:20:02.723]                 NAMES <- toupper(removed)
[13:20:02.723]                 for (kk in seq_along(NAMES)) {
[13:20:02.723]                   name <- removed[[kk]]
[13:20:02.723]                   NAME <- NAMES[[kk]]
[13:20:02.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.723]                     next
[13:20:02.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.723]                 }
[13:20:02.723]                 if (length(args) > 0) 
[13:20:02.723]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.723]             }
[13:20:02.723]             else {
[13:20:02.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.723]             }
[13:20:02.723]             {
[13:20:02.723]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.723]                   0L) {
[13:20:02.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.723]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.723]                   base::options(opts)
[13:20:02.723]                 }
[13:20:02.723]                 {
[13:20:02.723]                   {
[13:20:02.723]                     NULL
[13:20:02.723]                     RNGkind("Mersenne-Twister")
[13:20:02.723]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.723]                       inherits = FALSE)
[13:20:02.723]                   }
[13:20:02.723]                   options(future.plan = NULL)
[13:20:02.723]                   if (is.na(NA_character_)) 
[13:20:02.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.723]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:02.723]                   {
[13:20:02.723]                     future <- SequentialFuture(..., envir = envir)
[13:20:02.723]                     if (!future$lazy) 
[13:20:02.723]                       future <- run(future)
[13:20:02.723]                     invisible(future)
[13:20:02.723]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.723]                 }
[13:20:02.723]             }
[13:20:02.723]         }
[13:20:02.723]     })
[13:20:02.723]     if (TRUE) {
[13:20:02.723]         base::sink(type = "output", split = FALSE)
[13:20:02.723]         if (TRUE) {
[13:20:02.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.723]         }
[13:20:02.723]         else {
[13:20:02.723]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.723]         }
[13:20:02.723]         base::close(...future.stdout)
[13:20:02.723]         ...future.stdout <- NULL
[13:20:02.723]     }
[13:20:02.723]     ...future.result$conditions <- ...future.conditions
[13:20:02.723]     ...future.result$finished <- base::Sys.time()
[13:20:02.723]     ...future.result
[13:20:02.723] }
[13:20:02.725] assign_globals() ...
[13:20:02.725] List of 5
[13:20:02.725]  $ ...future.FUN            :function (object, ...)  
[13:20:02.725]  $ future.call.arguments    :List of 1
[13:20:02.725]   ..$ digits: int 2
[13:20:02.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.725]  $ ...future.elements_ii    :List of 6
[13:20:02.725]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:20:02.725]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:20:02.725]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:20:02.725]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:20:02.725]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:20:02.725]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:20:02.725]  $ ...future.seeds_ii       : NULL
[13:20:02.725]  $ ...future.globals.maxSize: NULL
[13:20:02.725]  - attr(*, "where")=List of 5
[13:20:02.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.725]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.725]  - attr(*, "resolved")= logi FALSE
[13:20:02.725]  - attr(*, "total_size")= num 1296
[13:20:02.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.725]  - attr(*, "already-done")= logi TRUE
[13:20:02.732] - copied ‘...future.FUN’ to environment
[13:20:02.732] - copied ‘future.call.arguments’ to environment
[13:20:02.732] - copied ‘...future.elements_ii’ to environment
[13:20:02.732] - copied ‘...future.seeds_ii’ to environment
[13:20:02.732] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.732] assign_globals() ... done
[13:20:02.732] plan(): Setting new future strategy stack:
[13:20:02.733] List of future strategies:
[13:20:02.733] 1. sequential:
[13:20:02.733]    - args: function (..., envir = parent.frame())
[13:20:02.733]    - tweaked: FALSE
[13:20:02.733]    - call: NULL
[13:20:02.733] plan(): nbrOfWorkers() = 1
[13:20:02.737] plan(): Setting new future strategy stack:
[13:20:02.737] List of future strategies:
[13:20:02.737] 1. sequential:
[13:20:02.737]    - args: function (..., envir = parent.frame())
[13:20:02.737]    - tweaked: FALSE
[13:20:02.737]    - call: plan(strategy)
[13:20:02.737] plan(): nbrOfWorkers() = 1
[13:20:02.737] SequentialFuture started (and completed)
[13:20:02.738] - Launch lazy future ... done
[13:20:02.738] run() for ‘SequentialFuture’ ... done
[13:20:02.738] Created future:
[13:20:02.738] SequentialFuture:
[13:20:02.738] Label: ‘future_by-1’
[13:20:02.738] Expression:
[13:20:02.738] {
[13:20:02.738]     do.call(function(...) {
[13:20:02.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.738]             on.exit(options(oopts), add = TRUE)
[13:20:02.738]         }
[13:20:02.738]         {
[13:20:02.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.738]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.738]             })
[13:20:02.738]         }
[13:20:02.738]     }, args = future.call.arguments)
[13:20:02.738] }
[13:20:02.738] Lazy evaluation: FALSE
[13:20:02.738] Asynchronous evaluation: FALSE
[13:20:02.738] Local evaluation: TRUE
[13:20:02.738] Environment: R_GlobalEnv
[13:20:02.738] Capture standard output: TRUE
[13:20:02.738] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.738] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.738] Packages: <none>
[13:20:02.738] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.738] Resolved: TRUE
[13:20:02.738] Value: 5.48 KiB of class ‘list’
[13:20:02.738] Early signaling: FALSE
[13:20:02.738] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.738] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.739] Chunk #1 of 1 ... DONE
[13:20:02.740] Launching 1 futures (chunks) ... DONE
[13:20:02.740] Resolving 1 futures (chunks) ...
[13:20:02.740] resolve() on list ...
[13:20:02.740]  recursive: 0
[13:20:02.740]  length: 1
[13:20:02.740] 
[13:20:02.740] resolved() for ‘SequentialFuture’ ...
[13:20:02.740] - state: ‘finished’
[13:20:02.740] - run: TRUE
[13:20:02.741] - result: ‘FutureResult’
[13:20:02.741] resolved() for ‘SequentialFuture’ ... done
[13:20:02.741] Future #1
[13:20:02.741] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.741] - nx: 1
[13:20:02.741] - relay: TRUE
[13:20:02.741] - stdout: TRUE
[13:20:02.741] - signal: TRUE
[13:20:02.741] - resignal: FALSE
[13:20:02.742] - force: TRUE
[13:20:02.742] - relayed: [n=1] FALSE
[13:20:02.742] - queued futures: [n=1] FALSE
[13:20:02.742]  - until=1
[13:20:02.742]  - relaying element #1
[13:20:02.742] - relayed: [n=1] TRUE
[13:20:02.742] - queued futures: [n=1] TRUE
[13:20:02.742] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.742]  length: 0 (resolved future 1)
[13:20:02.743] Relaying remaining futures
[13:20:02.743] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.743] - nx: 1
[13:20:02.743] - relay: TRUE
[13:20:02.743] - stdout: TRUE
[13:20:02.743] - signal: TRUE
[13:20:02.743] - resignal: FALSE
[13:20:02.743] - force: TRUE
[13:20:02.743] - relayed: [n=1] TRUE
[13:20:02.743] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.743] - relayed: [n=1] TRUE
[13:20:02.744] - queued futures: [n=1] TRUE
[13:20:02.744] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.744] resolve() on list ... DONE
[13:20:02.744]  - Number of value chunks collected: 1
[13:20:02.744] Resolving 1 futures (chunks) ... DONE
[13:20:02.744] Reducing values from 1 chunks ...
[13:20:02.744]  - Number of values collected after concatenation: 6
[13:20:02.744]  - Number of values expected: 6
[13:20:02.744] Reducing values from 1 chunks ... DONE
[13:20:02.744] future_lapply() ... DONE
[13:20:02.745] future_by_internal() ... DONE
[13:20:02.746] future_by_internal() ...
[13:20:02.746] future_lapply() ...
[13:20:02.747] Number of chunks: 1
[13:20:02.747] getGlobalsAndPackagesXApply() ...
[13:20:02.747]  - future.globals: TRUE
[13:20:02.747] getGlobalsAndPackages() ...
[13:20:02.747] Searching for globals...
[13:20:02.749] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:02.749] Searching for globals ... DONE
[13:20:02.749] Resolving globals: FALSE
[13:20:02.750] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:20:02.750] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:20:02.750] - globals: [1] ‘FUN’
[13:20:02.750] - packages: [1] ‘stats’
[13:20:02.750] getGlobalsAndPackages() ... DONE
[13:20:02.751]  - globals found/used: [n=1] ‘FUN’
[13:20:02.751]  - needed namespaces: [n=1] ‘stats’
[13:20:02.751] Finding globals ... DONE
[13:20:02.751]  - use_args: TRUE
[13:20:02.751]  - Getting '...' globals ...
[13:20:02.751] resolve() on list ...
[13:20:02.751]  recursive: 0
[13:20:02.751]  length: 1
[13:20:02.752]  elements: ‘...’
[13:20:02.752]  length: 0 (resolved future 1)
[13:20:02.752] resolve() on list ... DONE
[13:20:02.752]    - '...' content: [n=1] ‘singular.ok’
[13:20:02.752] List of 1
[13:20:02.752]  $ ...:List of 1
[13:20:02.752]   ..$ singular.ok: logi FALSE
[13:20:02.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.752]  - attr(*, "where")=List of 1
[13:20:02.752]   ..$ ...:<environment: 0x55aced4e88b8> 
[13:20:02.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.752]  - attr(*, "resolved")= logi TRUE
[13:20:02.752]  - attr(*, "total_size")= num NA
[13:20:02.755]  - Getting '...' globals ... DONE
[13:20:02.755] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.755] List of 2
[13:20:02.755]  $ ...future.FUN:function (x, ...)  
[13:20:02.755]  $ ...          :List of 1
[13:20:02.755]   ..$ singular.ok: logi FALSE
[13:20:02.755]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.755]  - attr(*, "where")=List of 2
[13:20:02.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.755]   ..$ ...          :<environment: 0x55aced4e88b8> 
[13:20:02.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.755]  - attr(*, "resolved")= logi FALSE
[13:20:02.755]  - attr(*, "total_size")= num 5384
[13:20:02.762] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:02.762] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.762] Number of futures (= number of chunks): 1
[13:20:02.762] Launching 1 futures (chunks) ...
[13:20:02.762] Chunk #1 of 1 ...
[13:20:02.762]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.762] getGlobalsAndPackages() ...
[13:20:02.763] Searching for globals...
[13:20:02.763] 
[13:20:02.763] Searching for globals ... DONE
[13:20:02.763] - globals: [0] <none>
[13:20:02.763] getGlobalsAndPackages() ... DONE
[13:20:02.764]    + additional globals found: [n=0] 
[13:20:02.764]    + additional namespaces needed: [n=0] 
[13:20:02.764]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.764]  - seeds: <none>
[13:20:02.764]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.764] getGlobalsAndPackages() ...
[13:20:02.764] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.764] Resolving globals: FALSE
[13:20:02.764] Tweak future expression to call with '...' arguments ...
[13:20:02.764] {
[13:20:02.764]     do.call(function(...) {
[13:20:02.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.764]             on.exit(options(oopts), add = TRUE)
[13:20:02.764]         }
[13:20:02.764]         {
[13:20:02.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.764]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.764]             })
[13:20:02.764]         }
[13:20:02.764]     }, args = future.call.arguments)
[13:20:02.764] }
[13:20:02.765] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.765] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.765] 
[13:20:02.765] getGlobalsAndPackages() ... DONE
[13:20:02.766] run() for ‘Future’ ...
[13:20:02.766] - state: ‘created’
[13:20:02.766] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:02.766] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.766] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.766]   - Field: ‘label’
[13:20:02.767]   - Field: ‘local’
[13:20:02.767]   - Field: ‘owner’
[13:20:02.767]   - Field: ‘envir’
[13:20:02.767]   - Field: ‘packages’
[13:20:02.767]   - Field: ‘gc’
[13:20:02.767]   - Field: ‘conditions’
[13:20:02.767]   - Field: ‘expr’
[13:20:02.767]   - Field: ‘uuid’
[13:20:02.767]   - Field: ‘seed’
[13:20:02.767]   - Field: ‘version’
[13:20:02.768]   - Field: ‘result’
[13:20:02.768]   - Field: ‘asynchronous’
[13:20:02.768]   - Field: ‘calls’
[13:20:02.768]   - Field: ‘globals’
[13:20:02.768]   - Field: ‘stdout’
[13:20:02.768]   - Field: ‘earlySignal’
[13:20:02.768]   - Field: ‘lazy’
[13:20:02.768]   - Field: ‘state’
[13:20:02.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.768] - Launch lazy future ...
[13:20:02.769] Packages needed by the future expression (n = 1): ‘stats’
[13:20:02.769] Packages needed by future strategies (n = 0): <none>
[13:20:02.769] {
[13:20:02.769]     {
[13:20:02.769]         {
[13:20:02.769]             ...future.startTime <- base::Sys.time()
[13:20:02.769]             {
[13:20:02.769]                 {
[13:20:02.769]                   {
[13:20:02.769]                     {
[13:20:02.769]                       base::local({
[13:20:02.769]                         has_future <- base::requireNamespace("future", 
[13:20:02.769]                           quietly = TRUE)
[13:20:02.769]                         if (has_future) {
[13:20:02.769]                           ns <- base::getNamespace("future")
[13:20:02.769]                           version <- ns[[".package"]][["version"]]
[13:20:02.769]                           if (is.null(version)) 
[13:20:02.769]                             version <- utils::packageVersion("future")
[13:20:02.769]                         }
[13:20:02.769]                         else {
[13:20:02.769]                           version <- NULL
[13:20:02.769]                         }
[13:20:02.769]                         if (!has_future || version < "1.8.0") {
[13:20:02.769]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.769]                             "", base::R.version$version.string), 
[13:20:02.769]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.769]                               "release", "version")], collapse = " "), 
[13:20:02.769]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.769]                             info)
[13:20:02.769]                           info <- base::paste(info, collapse = "; ")
[13:20:02.769]                           if (!has_future) {
[13:20:02.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.769]                               info)
[13:20:02.769]                           }
[13:20:02.769]                           else {
[13:20:02.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.769]                               info, version)
[13:20:02.769]                           }
[13:20:02.769]                           base::stop(msg)
[13:20:02.769]                         }
[13:20:02.769]                       })
[13:20:02.769]                     }
[13:20:02.769]                     base::local({
[13:20:02.769]                       for (pkg in "stats") {
[13:20:02.769]                         base::loadNamespace(pkg)
[13:20:02.769]                         base::library(pkg, character.only = TRUE)
[13:20:02.769]                       }
[13:20:02.769]                     })
[13:20:02.769]                   }
[13:20:02.769]                   options(future.plan = NULL)
[13:20:02.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.769]                 }
[13:20:02.769]                 ...future.workdir <- getwd()
[13:20:02.769]             }
[13:20:02.769]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.769]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.769]         }
[13:20:02.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.769]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.769]             base::names(...future.oldOptions))
[13:20:02.769]     }
[13:20:02.769]     if (FALSE) {
[13:20:02.769]     }
[13:20:02.769]     else {
[13:20:02.769]         if (TRUE) {
[13:20:02.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.769]                 open = "w")
[13:20:02.769]         }
[13:20:02.769]         else {
[13:20:02.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.769]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.769]         }
[13:20:02.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.769]             base::sink(type = "output", split = FALSE)
[13:20:02.769]             base::close(...future.stdout)
[13:20:02.769]         }, add = TRUE)
[13:20:02.769]     }
[13:20:02.769]     ...future.frame <- base::sys.nframe()
[13:20:02.769]     ...future.conditions <- base::list()
[13:20:02.769]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.769]     if (FALSE) {
[13:20:02.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.769]     }
[13:20:02.769]     ...future.result <- base::tryCatch({
[13:20:02.769]         base::withCallingHandlers({
[13:20:02.769]             ...future.value <- base::withVisible(base::local({
[13:20:02.769]                 do.call(function(...) {
[13:20:02.769]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.769]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.769]                     ...future.globals.maxSize)) {
[13:20:02.769]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.769]                     on.exit(options(oopts), add = TRUE)
[13:20:02.769]                   }
[13:20:02.769]                   {
[13:20:02.769]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.769]                       FUN = function(jj) {
[13:20:02.769]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.769]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.769]                       })
[13:20:02.769]                   }
[13:20:02.769]                 }, args = future.call.arguments)
[13:20:02.769]             }))
[13:20:02.769]             future::FutureResult(value = ...future.value$value, 
[13:20:02.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.769]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.769]                     ...future.globalenv.names))
[13:20:02.769]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.769]         }, condition = base::local({
[13:20:02.769]             c <- base::c
[13:20:02.769]             inherits <- base::inherits
[13:20:02.769]             invokeRestart <- base::invokeRestart
[13:20:02.769]             length <- base::length
[13:20:02.769]             list <- base::list
[13:20:02.769]             seq.int <- base::seq.int
[13:20:02.769]             signalCondition <- base::signalCondition
[13:20:02.769]             sys.calls <- base::sys.calls
[13:20:02.769]             `[[` <- base::`[[`
[13:20:02.769]             `+` <- base::`+`
[13:20:02.769]             `<<-` <- base::`<<-`
[13:20:02.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.769]                   3L)]
[13:20:02.769]             }
[13:20:02.769]             function(cond) {
[13:20:02.769]                 is_error <- inherits(cond, "error")
[13:20:02.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.769]                   NULL)
[13:20:02.769]                 if (is_error) {
[13:20:02.769]                   sessionInformation <- function() {
[13:20:02.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.769]                       search = base::search(), system = base::Sys.info())
[13:20:02.769]                   }
[13:20:02.769]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.769]                     cond$call), session = sessionInformation(), 
[13:20:02.769]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.769]                   signalCondition(cond)
[13:20:02.769]                 }
[13:20:02.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.769]                 "immediateCondition"))) {
[13:20:02.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.769]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.769]                   if (TRUE && !signal) {
[13:20:02.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.769]                     {
[13:20:02.769]                       inherits <- base::inherits
[13:20:02.769]                       invokeRestart <- base::invokeRestart
[13:20:02.769]                       is.null <- base::is.null
[13:20:02.769]                       muffled <- FALSE
[13:20:02.769]                       if (inherits(cond, "message")) {
[13:20:02.769]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.769]                         if (muffled) 
[13:20:02.769]                           invokeRestart("muffleMessage")
[13:20:02.769]                       }
[13:20:02.769]                       else if (inherits(cond, "warning")) {
[13:20:02.769]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.769]                         if (muffled) 
[13:20:02.769]                           invokeRestart("muffleWarning")
[13:20:02.769]                       }
[13:20:02.769]                       else if (inherits(cond, "condition")) {
[13:20:02.769]                         if (!is.null(pattern)) {
[13:20:02.769]                           computeRestarts <- base::computeRestarts
[13:20:02.769]                           grepl <- base::grepl
[13:20:02.769]                           restarts <- computeRestarts(cond)
[13:20:02.769]                           for (restart in restarts) {
[13:20:02.769]                             name <- restart$name
[13:20:02.769]                             if (is.null(name)) 
[13:20:02.769]                               next
[13:20:02.769]                             if (!grepl(pattern, name)) 
[13:20:02.769]                               next
[13:20:02.769]                             invokeRestart(restart)
[13:20:02.769]                             muffled <- TRUE
[13:20:02.769]                             break
[13:20:02.769]                           }
[13:20:02.769]                         }
[13:20:02.769]                       }
[13:20:02.769]                       invisible(muffled)
[13:20:02.769]                     }
[13:20:02.769]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.769]                   }
[13:20:02.769]                 }
[13:20:02.769]                 else {
[13:20:02.769]                   if (TRUE) {
[13:20:02.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.769]                     {
[13:20:02.769]                       inherits <- base::inherits
[13:20:02.769]                       invokeRestart <- base::invokeRestart
[13:20:02.769]                       is.null <- base::is.null
[13:20:02.769]                       muffled <- FALSE
[13:20:02.769]                       if (inherits(cond, "message")) {
[13:20:02.769]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.769]                         if (muffled) 
[13:20:02.769]                           invokeRestart("muffleMessage")
[13:20:02.769]                       }
[13:20:02.769]                       else if (inherits(cond, "warning")) {
[13:20:02.769]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.769]                         if (muffled) 
[13:20:02.769]                           invokeRestart("muffleWarning")
[13:20:02.769]                       }
[13:20:02.769]                       else if (inherits(cond, "condition")) {
[13:20:02.769]                         if (!is.null(pattern)) {
[13:20:02.769]                           computeRestarts <- base::computeRestarts
[13:20:02.769]                           grepl <- base::grepl
[13:20:02.769]                           restarts <- computeRestarts(cond)
[13:20:02.769]                           for (restart in restarts) {
[13:20:02.769]                             name <- restart$name
[13:20:02.769]                             if (is.null(name)) 
[13:20:02.769]                               next
[13:20:02.769]                             if (!grepl(pattern, name)) 
[13:20:02.769]                               next
[13:20:02.769]                             invokeRestart(restart)
[13:20:02.769]                             muffled <- TRUE
[13:20:02.769]                             break
[13:20:02.769]                           }
[13:20:02.769]                         }
[13:20:02.769]                       }
[13:20:02.769]                       invisible(muffled)
[13:20:02.769]                     }
[13:20:02.769]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.769]                   }
[13:20:02.769]                 }
[13:20:02.769]             }
[13:20:02.769]         }))
[13:20:02.769]     }, error = function(ex) {
[13:20:02.769]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.769]                 ...future.rng), started = ...future.startTime, 
[13:20:02.769]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.769]             version = "1.8"), class = "FutureResult")
[13:20:02.769]     }, finally = {
[13:20:02.769]         if (!identical(...future.workdir, getwd())) 
[13:20:02.769]             setwd(...future.workdir)
[13:20:02.769]         {
[13:20:02.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.769]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.769]             }
[13:20:02.769]             base::options(...future.oldOptions)
[13:20:02.769]             if (.Platform$OS.type == "windows") {
[13:20:02.769]                 old_names <- names(...future.oldEnvVars)
[13:20:02.769]                 envs <- base::Sys.getenv()
[13:20:02.769]                 names <- names(envs)
[13:20:02.769]                 common <- intersect(names, old_names)
[13:20:02.769]                 added <- setdiff(names, old_names)
[13:20:02.769]                 removed <- setdiff(old_names, names)
[13:20:02.769]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.769]                   envs[common]]
[13:20:02.769]                 NAMES <- toupper(changed)
[13:20:02.769]                 args <- list()
[13:20:02.769]                 for (kk in seq_along(NAMES)) {
[13:20:02.769]                   name <- changed[[kk]]
[13:20:02.769]                   NAME <- NAMES[[kk]]
[13:20:02.769]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.769]                     next
[13:20:02.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.769]                 }
[13:20:02.769]                 NAMES <- toupper(added)
[13:20:02.769]                 for (kk in seq_along(NAMES)) {
[13:20:02.769]                   name <- added[[kk]]
[13:20:02.769]                   NAME <- NAMES[[kk]]
[13:20:02.769]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.769]                     next
[13:20:02.769]                   args[[name]] <- ""
[13:20:02.769]                 }
[13:20:02.769]                 NAMES <- toupper(removed)
[13:20:02.769]                 for (kk in seq_along(NAMES)) {
[13:20:02.769]                   name <- removed[[kk]]
[13:20:02.769]                   NAME <- NAMES[[kk]]
[13:20:02.769]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.769]                     next
[13:20:02.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.769]                 }
[13:20:02.769]                 if (length(args) > 0) 
[13:20:02.769]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.769]             }
[13:20:02.769]             else {
[13:20:02.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.769]             }
[13:20:02.769]             {
[13:20:02.769]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.769]                   0L) {
[13:20:02.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.769]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.769]                   base::options(opts)
[13:20:02.769]                 }
[13:20:02.769]                 {
[13:20:02.769]                   {
[13:20:02.769]                     NULL
[13:20:02.769]                     RNGkind("Mersenne-Twister")
[13:20:02.769]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.769]                       inherits = FALSE)
[13:20:02.769]                   }
[13:20:02.769]                   options(future.plan = NULL)
[13:20:02.769]                   if (is.na(NA_character_)) 
[13:20:02.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.769]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:02.769]                   {
[13:20:02.769]                     future <- SequentialFuture(..., envir = envir)
[13:20:02.769]                     if (!future$lazy) 
[13:20:02.769]                       future <- run(future)
[13:20:02.769]                     invisible(future)
[13:20:02.769]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.769]                 }
[13:20:02.769]             }
[13:20:02.769]         }
[13:20:02.769]     })
[13:20:02.769]     if (TRUE) {
[13:20:02.769]         base::sink(type = "output", split = FALSE)
[13:20:02.769]         if (TRUE) {
[13:20:02.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.769]         }
[13:20:02.769]         else {
[13:20:02.769]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.769]         }
[13:20:02.769]         base::close(...future.stdout)
[13:20:02.769]         ...future.stdout <- NULL
[13:20:02.769]     }
[13:20:02.769]     ...future.result$conditions <- ...future.conditions
[13:20:02.769]     ...future.result$finished <- base::Sys.time()
[13:20:02.769]     ...future.result
[13:20:02.769] }
[13:20:02.771] assign_globals() ...
[13:20:02.771] List of 5
[13:20:02.771]  $ ...future.FUN            :function (x, ...)  
[13:20:02.771]  $ future.call.arguments    :List of 1
[13:20:02.771]   ..$ singular.ok: logi FALSE
[13:20:02.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.771]  $ ...future.elements_ii    :List of 3
[13:20:02.771]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.771]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.771]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.771]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.771]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.771]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.771]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.771]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.771]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.771]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.771]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.771]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.771]  $ ...future.seeds_ii       : NULL
[13:20:02.771]  $ ...future.globals.maxSize: NULL
[13:20:02.771]  - attr(*, "where")=List of 5
[13:20:02.771]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.771]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.771]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.771]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.771]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.771]  - attr(*, "resolved")= logi FALSE
[13:20:02.771]  - attr(*, "total_size")= num 5384
[13:20:02.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.771]  - attr(*, "already-done")= logi TRUE
[13:20:02.783] - reassign environment for ‘...future.FUN’
[13:20:02.783] - copied ‘...future.FUN’ to environment
[13:20:02.783] - copied ‘future.call.arguments’ to environment
[13:20:02.783] - copied ‘...future.elements_ii’ to environment
[13:20:02.783] - copied ‘...future.seeds_ii’ to environment
[13:20:02.784] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.784] assign_globals() ... done
[13:20:02.784] plan(): Setting new future strategy stack:
[13:20:02.784] List of future strategies:
[13:20:02.784] 1. sequential:
[13:20:02.784]    - args: function (..., envir = parent.frame())
[13:20:02.784]    - tweaked: FALSE
[13:20:02.784]    - call: NULL
[13:20:02.785] plan(): nbrOfWorkers() = 1
[13:20:02.788] plan(): Setting new future strategy stack:
[13:20:02.788] List of future strategies:
[13:20:02.788] 1. sequential:
[13:20:02.788]    - args: function (..., envir = parent.frame())
[13:20:02.788]    - tweaked: FALSE
[13:20:02.788]    - call: plan(strategy)
[13:20:02.789] plan(): nbrOfWorkers() = 1
[13:20:02.789] SequentialFuture started (and completed)
[13:20:02.789] - Launch lazy future ... done
[13:20:02.789] run() for ‘SequentialFuture’ ... done
[13:20:02.789] Created future:
[13:20:02.789] SequentialFuture:
[13:20:02.789] Label: ‘future_by-1’
[13:20:02.789] Expression:
[13:20:02.789] {
[13:20:02.789]     do.call(function(...) {
[13:20:02.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.789]             on.exit(options(oopts), add = TRUE)
[13:20:02.789]         }
[13:20:02.789]         {
[13:20:02.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.789]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.789]             })
[13:20:02.789]         }
[13:20:02.789]     }, args = future.call.arguments)
[13:20:02.789] }
[13:20:02.789] Lazy evaluation: FALSE
[13:20:02.789] Asynchronous evaluation: FALSE
[13:20:02.789] Local evaluation: TRUE
[13:20:02.789] Environment: R_GlobalEnv
[13:20:02.789] Capture standard output: TRUE
[13:20:02.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.789] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.789] Packages: 1 packages (‘stats’)
[13:20:02.789] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.789] Resolved: TRUE
[13:20:02.789] Value: 26.06 KiB of class ‘list’
[13:20:02.789] Early signaling: FALSE
[13:20:02.789] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.789] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.791] Chunk #1 of 1 ... DONE
[13:20:02.791] Launching 1 futures (chunks) ... DONE
[13:20:02.791] Resolving 1 futures (chunks) ...
[13:20:02.791] resolve() on list ...
[13:20:02.791]  recursive: 0
[13:20:02.791]  length: 1
[13:20:02.792] 
[13:20:02.792] resolved() for ‘SequentialFuture’ ...
[13:20:02.792] - state: ‘finished’
[13:20:02.792] - run: TRUE
[13:20:02.792] - result: ‘FutureResult’
[13:20:02.792] resolved() for ‘SequentialFuture’ ... done
[13:20:02.792] Future #1
[13:20:02.792] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.792] - nx: 1
[13:20:02.793] - relay: TRUE
[13:20:02.793] - stdout: TRUE
[13:20:02.793] - signal: TRUE
[13:20:02.793] - resignal: FALSE
[13:20:02.793] - force: TRUE
[13:20:02.793] - relayed: [n=1] FALSE
[13:20:02.793] - queued futures: [n=1] FALSE
[13:20:02.793]  - until=1
[13:20:02.793]  - relaying element #1
[13:20:02.793] - relayed: [n=1] TRUE
[13:20:02.794] - queued futures: [n=1] TRUE
[13:20:02.794] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.794]  length: 0 (resolved future 1)
[13:20:02.794] Relaying remaining futures
[13:20:02.794] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.794] - nx: 1
[13:20:02.794] - relay: TRUE
[13:20:02.794] - stdout: TRUE
[13:20:02.794] - signal: TRUE
[13:20:02.794] - resignal: FALSE
[13:20:02.794] - force: TRUE
[13:20:02.794] - relayed: [n=1] TRUE
[13:20:02.795] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.795] - relayed: [n=1] TRUE
[13:20:02.795] - queued futures: [n=1] TRUE
[13:20:02.795] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.795] resolve() on list ... DONE
[13:20:02.795]  - Number of value chunks collected: 1
[13:20:02.795] Resolving 1 futures (chunks) ... DONE
[13:20:02.795] Reducing values from 1 chunks ...
[13:20:02.795]  - Number of values collected after concatenation: 3
[13:20:02.795]  - Number of values expected: 3
[13:20:02.796] Reducing values from 1 chunks ... DONE
[13:20:02.796] future_lapply() ... DONE
[13:20:02.796] future_by_internal() ... DONE
[13:20:02.800] future_by_internal() ...
[13:20:02.800] future_lapply() ...
[13:20:02.804] Number of chunks: 1
[13:20:02.804] getGlobalsAndPackagesXApply() ...
[13:20:02.804]  - future.globals: TRUE
[13:20:02.804] getGlobalsAndPackages() ...
[13:20:02.804] Searching for globals...
[13:20:02.807] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:02.807] Searching for globals ... DONE
[13:20:02.807] Resolving globals: FALSE
[13:20:02.807] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:20:02.808] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:20:02.808] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:02.808] - packages: [1] ‘stats’
[13:20:02.808] getGlobalsAndPackages() ... DONE
[13:20:02.808]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:02.809]  - needed namespaces: [n=1] ‘stats’
[13:20:02.809] Finding globals ... DONE
[13:20:02.809]  - use_args: TRUE
[13:20:02.809]  - Getting '...' globals ...
[13:20:02.809] resolve() on list ...
[13:20:02.809]  recursive: 0
[13:20:02.809]  length: 1
[13:20:02.809]  elements: ‘...’
[13:20:02.810]  length: 0 (resolved future 1)
[13:20:02.810] resolve() on list ... DONE
[13:20:02.810]    - '...' content: [n=0] 
[13:20:02.810] List of 1
[13:20:02.810]  $ ...: list()
[13:20:02.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.810]  - attr(*, "where")=List of 1
[13:20:02.810]   ..$ ...:<environment: 0x55aceecece70> 
[13:20:02.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.810]  - attr(*, "resolved")= logi TRUE
[13:20:02.810]  - attr(*, "total_size")= num NA
[13:20:02.812]  - Getting '...' globals ... DONE
[13:20:02.813] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:20:02.813] List of 4
[13:20:02.813]  $ ...future.FUN:function (x)  
[13:20:02.813]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:02.813]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.813]  $ ...          : list()
[13:20:02.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.813]  - attr(*, "where")=List of 4
[13:20:02.813]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.813]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:20:02.813]   ..$ wool         :<environment: R_EmptyEnv> 
[13:20:02.813]   ..$ ...          :<environment: 0x55aceecece70> 
[13:20:02.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.813]  - attr(*, "resolved")= logi FALSE
[13:20:02.813]  - attr(*, "total_size")= num 2320
[13:20:02.817] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:02.817] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.817] Number of futures (= number of chunks): 1
[13:20:02.817] Launching 1 futures (chunks) ...
[13:20:02.817] Chunk #1 of 1 ...
[13:20:02.817]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.818] getGlobalsAndPackages() ...
[13:20:02.818] Searching for globals...
[13:20:02.818] 
[13:20:02.818] Searching for globals ... DONE
[13:20:02.818] - globals: [0] <none>
[13:20:02.818] getGlobalsAndPackages() ... DONE
[13:20:02.818]    + additional globals found: [n=0] 
[13:20:02.819]    + additional namespaces needed: [n=0] 
[13:20:02.819]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.819]  - seeds: <none>
[13:20:02.819]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.819] getGlobalsAndPackages() ...
[13:20:02.819] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.819] Resolving globals: FALSE
[13:20:02.819] Tweak future expression to call with '...' arguments ...
[13:20:02.819] {
[13:20:02.819]     do.call(function(...) {
[13:20:02.819]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.819]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.819]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.819]             on.exit(options(oopts), add = TRUE)
[13:20:02.819]         }
[13:20:02.819]         {
[13:20:02.819]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.819]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.819]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.819]             })
[13:20:02.819]         }
[13:20:02.819]     }, args = future.call.arguments)
[13:20:02.819] }
[13:20:02.820] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.820] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.820] 
[13:20:02.820] getGlobalsAndPackages() ... DONE
[13:20:02.821] run() for ‘Future’ ...
[13:20:02.821] - state: ‘created’
[13:20:02.821] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:02.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.821]   - Field: ‘label’
[13:20:02.822]   - Field: ‘local’
[13:20:02.822]   - Field: ‘owner’
[13:20:02.822]   - Field: ‘envir’
[13:20:02.822]   - Field: ‘packages’
[13:20:02.822]   - Field: ‘gc’
[13:20:02.822]   - Field: ‘conditions’
[13:20:02.822]   - Field: ‘expr’
[13:20:02.822]   - Field: ‘uuid’
[13:20:02.822]   - Field: ‘seed’
[13:20:02.822]   - Field: ‘version’
[13:20:02.822]   - Field: ‘result’
[13:20:02.823]   - Field: ‘asynchronous’
[13:20:02.823]   - Field: ‘calls’
[13:20:02.823]   - Field: ‘globals’
[13:20:02.825]   - Field: ‘stdout’
[13:20:02.825]   - Field: ‘earlySignal’
[13:20:02.825]   - Field: ‘lazy’
[13:20:02.825]   - Field: ‘state’
[13:20:02.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.825] - Launch lazy future ...
[13:20:02.826] Packages needed by the future expression (n = 1): ‘stats’
[13:20:02.826] Packages needed by future strategies (n = 0): <none>
[13:20:02.826] {
[13:20:02.826]     {
[13:20:02.826]         {
[13:20:02.826]             ...future.startTime <- base::Sys.time()
[13:20:02.826]             {
[13:20:02.826]                 {
[13:20:02.826]                   {
[13:20:02.826]                     {
[13:20:02.826]                       base::local({
[13:20:02.826]                         has_future <- base::requireNamespace("future", 
[13:20:02.826]                           quietly = TRUE)
[13:20:02.826]                         if (has_future) {
[13:20:02.826]                           ns <- base::getNamespace("future")
[13:20:02.826]                           version <- ns[[".package"]][["version"]]
[13:20:02.826]                           if (is.null(version)) 
[13:20:02.826]                             version <- utils::packageVersion("future")
[13:20:02.826]                         }
[13:20:02.826]                         else {
[13:20:02.826]                           version <- NULL
[13:20:02.826]                         }
[13:20:02.826]                         if (!has_future || version < "1.8.0") {
[13:20:02.826]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.826]                             "", base::R.version$version.string), 
[13:20:02.826]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.826]                               "release", "version")], collapse = " "), 
[13:20:02.826]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.826]                             info)
[13:20:02.826]                           info <- base::paste(info, collapse = "; ")
[13:20:02.826]                           if (!has_future) {
[13:20:02.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.826]                               info)
[13:20:02.826]                           }
[13:20:02.826]                           else {
[13:20:02.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.826]                               info, version)
[13:20:02.826]                           }
[13:20:02.826]                           base::stop(msg)
[13:20:02.826]                         }
[13:20:02.826]                       })
[13:20:02.826]                     }
[13:20:02.826]                     base::local({
[13:20:02.826]                       for (pkg in "stats") {
[13:20:02.826]                         base::loadNamespace(pkg)
[13:20:02.826]                         base::library(pkg, character.only = TRUE)
[13:20:02.826]                       }
[13:20:02.826]                     })
[13:20:02.826]                   }
[13:20:02.826]                   options(future.plan = NULL)
[13:20:02.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.826]                 }
[13:20:02.826]                 ...future.workdir <- getwd()
[13:20:02.826]             }
[13:20:02.826]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.826]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.826]         }
[13:20:02.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.826]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.826]             base::names(...future.oldOptions))
[13:20:02.826]     }
[13:20:02.826]     if (FALSE) {
[13:20:02.826]     }
[13:20:02.826]     else {
[13:20:02.826]         if (TRUE) {
[13:20:02.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.826]                 open = "w")
[13:20:02.826]         }
[13:20:02.826]         else {
[13:20:02.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.826]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.826]         }
[13:20:02.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.826]             base::sink(type = "output", split = FALSE)
[13:20:02.826]             base::close(...future.stdout)
[13:20:02.826]         }, add = TRUE)
[13:20:02.826]     }
[13:20:02.826]     ...future.frame <- base::sys.nframe()
[13:20:02.826]     ...future.conditions <- base::list()
[13:20:02.826]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.826]     if (FALSE) {
[13:20:02.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.826]     }
[13:20:02.826]     ...future.result <- base::tryCatch({
[13:20:02.826]         base::withCallingHandlers({
[13:20:02.826]             ...future.value <- base::withVisible(base::local({
[13:20:02.826]                 do.call(function(...) {
[13:20:02.826]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.826]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.826]                     ...future.globals.maxSize)) {
[13:20:02.826]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.826]                     on.exit(options(oopts), add = TRUE)
[13:20:02.826]                   }
[13:20:02.826]                   {
[13:20:02.826]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.826]                       FUN = function(jj) {
[13:20:02.826]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.826]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.826]                       })
[13:20:02.826]                   }
[13:20:02.826]                 }, args = future.call.arguments)
[13:20:02.826]             }))
[13:20:02.826]             future::FutureResult(value = ...future.value$value, 
[13:20:02.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.826]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.826]                     ...future.globalenv.names))
[13:20:02.826]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.826]         }, condition = base::local({
[13:20:02.826]             c <- base::c
[13:20:02.826]             inherits <- base::inherits
[13:20:02.826]             invokeRestart <- base::invokeRestart
[13:20:02.826]             length <- base::length
[13:20:02.826]             list <- base::list
[13:20:02.826]             seq.int <- base::seq.int
[13:20:02.826]             signalCondition <- base::signalCondition
[13:20:02.826]             sys.calls <- base::sys.calls
[13:20:02.826]             `[[` <- base::`[[`
[13:20:02.826]             `+` <- base::`+`
[13:20:02.826]             `<<-` <- base::`<<-`
[13:20:02.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.826]                   3L)]
[13:20:02.826]             }
[13:20:02.826]             function(cond) {
[13:20:02.826]                 is_error <- inherits(cond, "error")
[13:20:02.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.826]                   NULL)
[13:20:02.826]                 if (is_error) {
[13:20:02.826]                   sessionInformation <- function() {
[13:20:02.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.826]                       search = base::search(), system = base::Sys.info())
[13:20:02.826]                   }
[13:20:02.826]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.826]                     cond$call), session = sessionInformation(), 
[13:20:02.826]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.826]                   signalCondition(cond)
[13:20:02.826]                 }
[13:20:02.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.826]                 "immediateCondition"))) {
[13:20:02.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.826]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.826]                   if (TRUE && !signal) {
[13:20:02.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.826]                     {
[13:20:02.826]                       inherits <- base::inherits
[13:20:02.826]                       invokeRestart <- base::invokeRestart
[13:20:02.826]                       is.null <- base::is.null
[13:20:02.826]                       muffled <- FALSE
[13:20:02.826]                       if (inherits(cond, "message")) {
[13:20:02.826]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.826]                         if (muffled) 
[13:20:02.826]                           invokeRestart("muffleMessage")
[13:20:02.826]                       }
[13:20:02.826]                       else if (inherits(cond, "warning")) {
[13:20:02.826]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.826]                         if (muffled) 
[13:20:02.826]                           invokeRestart("muffleWarning")
[13:20:02.826]                       }
[13:20:02.826]                       else if (inherits(cond, "condition")) {
[13:20:02.826]                         if (!is.null(pattern)) {
[13:20:02.826]                           computeRestarts <- base::computeRestarts
[13:20:02.826]                           grepl <- base::grepl
[13:20:02.826]                           restarts <- computeRestarts(cond)
[13:20:02.826]                           for (restart in restarts) {
[13:20:02.826]                             name <- restart$name
[13:20:02.826]                             if (is.null(name)) 
[13:20:02.826]                               next
[13:20:02.826]                             if (!grepl(pattern, name)) 
[13:20:02.826]                               next
[13:20:02.826]                             invokeRestart(restart)
[13:20:02.826]                             muffled <- TRUE
[13:20:02.826]                             break
[13:20:02.826]                           }
[13:20:02.826]                         }
[13:20:02.826]                       }
[13:20:02.826]                       invisible(muffled)
[13:20:02.826]                     }
[13:20:02.826]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.826]                   }
[13:20:02.826]                 }
[13:20:02.826]                 else {
[13:20:02.826]                   if (TRUE) {
[13:20:02.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.826]                     {
[13:20:02.826]                       inherits <- base::inherits
[13:20:02.826]                       invokeRestart <- base::invokeRestart
[13:20:02.826]                       is.null <- base::is.null
[13:20:02.826]                       muffled <- FALSE
[13:20:02.826]                       if (inherits(cond, "message")) {
[13:20:02.826]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.826]                         if (muffled) 
[13:20:02.826]                           invokeRestart("muffleMessage")
[13:20:02.826]                       }
[13:20:02.826]                       else if (inherits(cond, "warning")) {
[13:20:02.826]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.826]                         if (muffled) 
[13:20:02.826]                           invokeRestart("muffleWarning")
[13:20:02.826]                       }
[13:20:02.826]                       else if (inherits(cond, "condition")) {
[13:20:02.826]                         if (!is.null(pattern)) {
[13:20:02.826]                           computeRestarts <- base::computeRestarts
[13:20:02.826]                           grepl <- base::grepl
[13:20:02.826]                           restarts <- computeRestarts(cond)
[13:20:02.826]                           for (restart in restarts) {
[13:20:02.826]                             name <- restart$name
[13:20:02.826]                             if (is.null(name)) 
[13:20:02.826]                               next
[13:20:02.826]                             if (!grepl(pattern, name)) 
[13:20:02.826]                               next
[13:20:02.826]                             invokeRestart(restart)
[13:20:02.826]                             muffled <- TRUE
[13:20:02.826]                             break
[13:20:02.826]                           }
[13:20:02.826]                         }
[13:20:02.826]                       }
[13:20:02.826]                       invisible(muffled)
[13:20:02.826]                     }
[13:20:02.826]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.826]                   }
[13:20:02.826]                 }
[13:20:02.826]             }
[13:20:02.826]         }))
[13:20:02.826]     }, error = function(ex) {
[13:20:02.826]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.826]                 ...future.rng), started = ...future.startTime, 
[13:20:02.826]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.826]             version = "1.8"), class = "FutureResult")
[13:20:02.826]     }, finally = {
[13:20:02.826]         if (!identical(...future.workdir, getwd())) 
[13:20:02.826]             setwd(...future.workdir)
[13:20:02.826]         {
[13:20:02.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.826]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.826]             }
[13:20:02.826]             base::options(...future.oldOptions)
[13:20:02.826]             if (.Platform$OS.type == "windows") {
[13:20:02.826]                 old_names <- names(...future.oldEnvVars)
[13:20:02.826]                 envs <- base::Sys.getenv()
[13:20:02.826]                 names <- names(envs)
[13:20:02.826]                 common <- intersect(names, old_names)
[13:20:02.826]                 added <- setdiff(names, old_names)
[13:20:02.826]                 removed <- setdiff(old_names, names)
[13:20:02.826]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.826]                   envs[common]]
[13:20:02.826]                 NAMES <- toupper(changed)
[13:20:02.826]                 args <- list()
[13:20:02.826]                 for (kk in seq_along(NAMES)) {
[13:20:02.826]                   name <- changed[[kk]]
[13:20:02.826]                   NAME <- NAMES[[kk]]
[13:20:02.826]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.826]                     next
[13:20:02.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.826]                 }
[13:20:02.826]                 NAMES <- toupper(added)
[13:20:02.826]                 for (kk in seq_along(NAMES)) {
[13:20:02.826]                   name <- added[[kk]]
[13:20:02.826]                   NAME <- NAMES[[kk]]
[13:20:02.826]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.826]                     next
[13:20:02.826]                   args[[name]] <- ""
[13:20:02.826]                 }
[13:20:02.826]                 NAMES <- toupper(removed)
[13:20:02.826]                 for (kk in seq_along(NAMES)) {
[13:20:02.826]                   name <- removed[[kk]]
[13:20:02.826]                   NAME <- NAMES[[kk]]
[13:20:02.826]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.826]                     next
[13:20:02.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.826]                 }
[13:20:02.826]                 if (length(args) > 0) 
[13:20:02.826]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.826]             }
[13:20:02.826]             else {
[13:20:02.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.826]             }
[13:20:02.826]             {
[13:20:02.826]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.826]                   0L) {
[13:20:02.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.826]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.826]                   base::options(opts)
[13:20:02.826]                 }
[13:20:02.826]                 {
[13:20:02.826]                   {
[13:20:02.826]                     NULL
[13:20:02.826]                     RNGkind("Mersenne-Twister")
[13:20:02.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.826]                       inherits = FALSE)
[13:20:02.826]                   }
[13:20:02.826]                   options(future.plan = NULL)
[13:20:02.826]                   if (is.na(NA_character_)) 
[13:20:02.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.826]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:02.826]                   {
[13:20:02.826]                     future <- SequentialFuture(..., envir = envir)
[13:20:02.826]                     if (!future$lazy) 
[13:20:02.826]                       future <- run(future)
[13:20:02.826]                     invisible(future)
[13:20:02.826]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.826]                 }
[13:20:02.826]             }
[13:20:02.826]         }
[13:20:02.826]     })
[13:20:02.826]     if (TRUE) {
[13:20:02.826]         base::sink(type = "output", split = FALSE)
[13:20:02.826]         if (TRUE) {
[13:20:02.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.826]         }
[13:20:02.826]         else {
[13:20:02.826]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.826]         }
[13:20:02.826]         base::close(...future.stdout)
[13:20:02.826]         ...future.stdout <- NULL
[13:20:02.826]     }
[13:20:02.826]     ...future.result$conditions <- ...future.conditions
[13:20:02.826]     ...future.result$finished <- base::Sys.time()
[13:20:02.826]     ...future.result
[13:20:02.826] }
[13:20:02.828] assign_globals() ...
[13:20:02.828] List of 7
[13:20:02.828]  $ ...future.FUN            :function (x)  
[13:20:02.828]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:02.828]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.828]  $ future.call.arguments    : list()
[13:20:02.828]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.828]  $ ...future.elements_ii    :List of 3
[13:20:02.828]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.828]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.828]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.828]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.828]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.828]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.828]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.828]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.828]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.828]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.828]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.828]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.828]  $ ...future.seeds_ii       : NULL
[13:20:02.828]  $ ...future.globals.maxSize: NULL
[13:20:02.828]  - attr(*, "where")=List of 7
[13:20:02.828]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.828]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:20:02.828]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:20:02.828]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.828]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.828]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.828]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.828]  - attr(*, "resolved")= logi FALSE
[13:20:02.828]  - attr(*, "total_size")= num 2320
[13:20:02.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.828]  - attr(*, "already-done")= logi TRUE
[13:20:02.839] - reassign environment for ‘...future.FUN’
[13:20:02.839] - copied ‘...future.FUN’ to environment
[13:20:02.839] - copied ‘breaks’ to environment
[13:20:02.839] - copied ‘wool’ to environment
[13:20:02.839] - copied ‘future.call.arguments’ to environment
[13:20:02.839] - copied ‘...future.elements_ii’ to environment
[13:20:02.840] - copied ‘...future.seeds_ii’ to environment
[13:20:02.840] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.840] assign_globals() ... done
[13:20:02.840] plan(): Setting new future strategy stack:
[13:20:02.840] List of future strategies:
[13:20:02.840] 1. sequential:
[13:20:02.840]    - args: function (..., envir = parent.frame())
[13:20:02.840]    - tweaked: FALSE
[13:20:02.840]    - call: NULL
[13:20:02.841] plan(): nbrOfWorkers() = 1
[13:20:02.844] plan(): Setting new future strategy stack:
[13:20:02.844] List of future strategies:
[13:20:02.844] 1. sequential:
[13:20:02.844]    - args: function (..., envir = parent.frame())
[13:20:02.844]    - tweaked: FALSE
[13:20:02.844]    - call: plan(strategy)
[13:20:02.844] plan(): nbrOfWorkers() = 1
[13:20:02.844] SequentialFuture started (and completed)
[13:20:02.844] - Launch lazy future ... done
[13:20:02.844] run() for ‘SequentialFuture’ ... done
[13:20:02.845] Created future:
[13:20:02.845] SequentialFuture:
[13:20:02.845] Label: ‘future_by-1’
[13:20:02.845] Expression:
[13:20:02.845] {
[13:20:02.845]     do.call(function(...) {
[13:20:02.845]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.845]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.845]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.845]             on.exit(options(oopts), add = TRUE)
[13:20:02.845]         }
[13:20:02.845]         {
[13:20:02.845]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.845]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.845]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.845]             })
[13:20:02.845]         }
[13:20:02.845]     }, args = future.call.arguments)
[13:20:02.845] }
[13:20:02.845] Lazy evaluation: FALSE
[13:20:02.845] Asynchronous evaluation: FALSE
[13:20:02.845] Local evaluation: TRUE
[13:20:02.845] Environment: 0x55aceec65298
[13:20:02.845] Capture standard output: TRUE
[13:20:02.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.845] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:20:02.845] Packages: 1 packages (‘stats’)
[13:20:02.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.845] Resolved: TRUE
[13:20:02.845] Value: 25.57 KiB of class ‘list’
[13:20:02.845] Early signaling: FALSE
[13:20:02.845] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.845] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.848] Chunk #1 of 1 ... DONE
[13:20:02.848] Launching 1 futures (chunks) ... DONE
[13:20:02.849] Resolving 1 futures (chunks) ...
[13:20:02.849] resolve() on list ...
[13:20:02.849]  recursive: 0
[13:20:02.849]  length: 1
[13:20:02.849] 
[13:20:02.849] resolved() for ‘SequentialFuture’ ...
[13:20:02.849] - state: ‘finished’
[13:20:02.849] - run: TRUE
[13:20:02.849] - result: ‘FutureResult’
[13:20:02.850] resolved() for ‘SequentialFuture’ ... done
[13:20:02.850] Future #1
[13:20:02.850] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.850] - nx: 1
[13:20:02.850] - relay: TRUE
[13:20:02.850] - stdout: TRUE
[13:20:02.850] - signal: TRUE
[13:20:02.850] - resignal: FALSE
[13:20:02.850] - force: TRUE
[13:20:02.851] - relayed: [n=1] FALSE
[13:20:02.851] - queued futures: [n=1] FALSE
[13:20:02.851]  - until=1
[13:20:02.851]  - relaying element #1
[13:20:02.851] - relayed: [n=1] TRUE
[13:20:02.851] - queued futures: [n=1] TRUE
[13:20:02.851] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.852]  length: 0 (resolved future 1)
[13:20:02.852] Relaying remaining futures
[13:20:02.852] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.852] - nx: 1
[13:20:02.852] - relay: TRUE
[13:20:02.852] - stdout: TRUE
[13:20:02.852] - signal: TRUE
[13:20:02.852] - resignal: FALSE
[13:20:02.852] - force: TRUE
[13:20:02.852] - relayed: [n=1] TRUE
[13:20:02.852] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.853] - relayed: [n=1] TRUE
[13:20:02.853] - queued futures: [n=1] TRUE
[13:20:02.853] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.853] resolve() on list ... DONE
[13:20:02.853]  - Number of value chunks collected: 1
[13:20:02.853] Resolving 1 futures (chunks) ... DONE
[13:20:02.853] Reducing values from 1 chunks ...
[13:20:02.853]  - Number of values collected after concatenation: 3
[13:20:02.853]  - Number of values expected: 3
[13:20:02.854] Reducing values from 1 chunks ... DONE
[13:20:02.854] future_lapply() ... DONE
[13:20:02.854] future_by_internal() ... DONE
[13:20:02.854] future_by_internal() ...
[13:20:02.854] future_lapply() ...
[13:20:02.855] Number of chunks: 1
[13:20:02.855] getGlobalsAndPackagesXApply() ...
[13:20:02.855]  - future.globals: TRUE
[13:20:02.855] getGlobalsAndPackages() ...
[13:20:02.855] Searching for globals...
[13:20:02.856] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.857] Searching for globals ... DONE
[13:20:02.857] Resolving globals: FALSE
[13:20:02.857] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.857] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.857] - globals: [1] ‘FUN’
[13:20:02.858] 
[13:20:02.858] getGlobalsAndPackages() ... DONE
[13:20:02.858]  - globals found/used: [n=1] ‘FUN’
[13:20:02.858]  - needed namespaces: [n=0] 
[13:20:02.858] Finding globals ... DONE
[13:20:02.858]  - use_args: TRUE
[13:20:02.858]  - Getting '...' globals ...
[13:20:02.858] resolve() on list ...
[13:20:02.859]  recursive: 0
[13:20:02.859]  length: 1
[13:20:02.859]  elements: ‘...’
[13:20:02.859]  length: 0 (resolved future 1)
[13:20:02.859] resolve() on list ... DONE
[13:20:02.859]    - '...' content: [n=0] 
[13:20:02.859] List of 1
[13:20:02.859]  $ ...: list()
[13:20:02.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.859]  - attr(*, "where")=List of 1
[13:20:02.859]   ..$ ...:<environment: 0x55aced1e18e8> 
[13:20:02.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.859]  - attr(*, "resolved")= logi TRUE
[13:20:02.859]  - attr(*, "total_size")= num NA
[13:20:02.862]  - Getting '...' globals ... DONE
[13:20:02.862] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.862] List of 2
[13:20:02.862]  $ ...future.FUN:function (object, ...)  
[13:20:02.862]  $ ...          : list()
[13:20:02.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.862]  - attr(*, "where")=List of 2
[13:20:02.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.862]   ..$ ...          :<environment: 0x55aced1e18e8> 
[13:20:02.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.862]  - attr(*, "resolved")= logi FALSE
[13:20:02.862]  - attr(*, "total_size")= num 1240
[13:20:02.865] Packages to be attached in all futures: [n=0] 
[13:20:02.865] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.865] Number of futures (= number of chunks): 1
[13:20:02.865] Launching 1 futures (chunks) ...
[13:20:02.865] Chunk #1 of 1 ...
[13:20:02.865]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.865] getGlobalsAndPackages() ...
[13:20:02.865] Searching for globals...
[13:20:02.866] 
[13:20:02.866] Searching for globals ... DONE
[13:20:02.866] - globals: [0] <none>
[13:20:02.866] getGlobalsAndPackages() ... DONE
[13:20:02.866]    + additional globals found: [n=0] 
[13:20:02.866]    + additional namespaces needed: [n=0] 
[13:20:02.866]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.868]  - seeds: <none>
[13:20:02.868]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.869] getGlobalsAndPackages() ...
[13:20:02.869] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.869] Resolving globals: FALSE
[13:20:02.869] Tweak future expression to call with '...' arguments ...
[13:20:02.869] {
[13:20:02.869]     do.call(function(...) {
[13:20:02.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.869]             on.exit(options(oopts), add = TRUE)
[13:20:02.869]         }
[13:20:02.869]         {
[13:20:02.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.869]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.869]             })
[13:20:02.869]         }
[13:20:02.869]     }, args = future.call.arguments)
[13:20:02.869] }
[13:20:02.869] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.870] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.870] 
[13:20:02.870] getGlobalsAndPackages() ... DONE
[13:20:02.870] run() for ‘Future’ ...
[13:20:02.871] - state: ‘created’
[13:20:02.871] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:02.871] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.871]   - Field: ‘label’
[13:20:02.871]   - Field: ‘local’
[13:20:02.872]   - Field: ‘owner’
[13:20:02.872]   - Field: ‘envir’
[13:20:02.872]   - Field: ‘packages’
[13:20:02.872]   - Field: ‘gc’
[13:20:02.872]   - Field: ‘conditions’
[13:20:02.872]   - Field: ‘expr’
[13:20:02.872]   - Field: ‘uuid’
[13:20:02.872]   - Field: ‘seed’
[13:20:02.872]   - Field: ‘version’
[13:20:02.873]   - Field: ‘result’
[13:20:02.873]   - Field: ‘asynchronous’
[13:20:02.873]   - Field: ‘calls’
[13:20:02.873]   - Field: ‘globals’
[13:20:02.873]   - Field: ‘stdout’
[13:20:02.873]   - Field: ‘earlySignal’
[13:20:02.873]   - Field: ‘lazy’
[13:20:02.873]   - Field: ‘state’
[13:20:02.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.874] - Launch lazy future ...
[13:20:02.874] Packages needed by the future expression (n = 0): <none>
[13:20:02.874] Packages needed by future strategies (n = 0): <none>
[13:20:02.874] {
[13:20:02.874]     {
[13:20:02.874]         {
[13:20:02.874]             ...future.startTime <- base::Sys.time()
[13:20:02.874]             {
[13:20:02.874]                 {
[13:20:02.874]                   {
[13:20:02.874]                     base::local({
[13:20:02.874]                       has_future <- base::requireNamespace("future", 
[13:20:02.874]                         quietly = TRUE)
[13:20:02.874]                       if (has_future) {
[13:20:02.874]                         ns <- base::getNamespace("future")
[13:20:02.874]                         version <- ns[[".package"]][["version"]]
[13:20:02.874]                         if (is.null(version)) 
[13:20:02.874]                           version <- utils::packageVersion("future")
[13:20:02.874]                       }
[13:20:02.874]                       else {
[13:20:02.874]                         version <- NULL
[13:20:02.874]                       }
[13:20:02.874]                       if (!has_future || version < "1.8.0") {
[13:20:02.874]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.874]                           "", base::R.version$version.string), 
[13:20:02.874]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.874]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.874]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.874]                             "release", "version")], collapse = " "), 
[13:20:02.874]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.874]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.874]                           info)
[13:20:02.874]                         info <- base::paste(info, collapse = "; ")
[13:20:02.874]                         if (!has_future) {
[13:20:02.874]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.874]                             info)
[13:20:02.874]                         }
[13:20:02.874]                         else {
[13:20:02.874]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.874]                             info, version)
[13:20:02.874]                         }
[13:20:02.874]                         base::stop(msg)
[13:20:02.874]                       }
[13:20:02.874]                     })
[13:20:02.874]                   }
[13:20:02.874]                   options(future.plan = NULL)
[13:20:02.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.874]                 }
[13:20:02.874]                 ...future.workdir <- getwd()
[13:20:02.874]             }
[13:20:02.874]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.874]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.874]         }
[13:20:02.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.874]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.874]             base::names(...future.oldOptions))
[13:20:02.874]     }
[13:20:02.874]     if (FALSE) {
[13:20:02.874]     }
[13:20:02.874]     else {
[13:20:02.874]         if (TRUE) {
[13:20:02.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.874]                 open = "w")
[13:20:02.874]         }
[13:20:02.874]         else {
[13:20:02.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.874]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.874]         }
[13:20:02.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.874]             base::sink(type = "output", split = FALSE)
[13:20:02.874]             base::close(...future.stdout)
[13:20:02.874]         }, add = TRUE)
[13:20:02.874]     }
[13:20:02.874]     ...future.frame <- base::sys.nframe()
[13:20:02.874]     ...future.conditions <- base::list()
[13:20:02.874]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.874]     if (FALSE) {
[13:20:02.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.874]     }
[13:20:02.874]     ...future.result <- base::tryCatch({
[13:20:02.874]         base::withCallingHandlers({
[13:20:02.874]             ...future.value <- base::withVisible(base::local({
[13:20:02.874]                 do.call(function(...) {
[13:20:02.874]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.874]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.874]                     ...future.globals.maxSize)) {
[13:20:02.874]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.874]                     on.exit(options(oopts), add = TRUE)
[13:20:02.874]                   }
[13:20:02.874]                   {
[13:20:02.874]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.874]                       FUN = function(jj) {
[13:20:02.874]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.874]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.874]                       })
[13:20:02.874]                   }
[13:20:02.874]                 }, args = future.call.arguments)
[13:20:02.874]             }))
[13:20:02.874]             future::FutureResult(value = ...future.value$value, 
[13:20:02.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.874]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.874]                     ...future.globalenv.names))
[13:20:02.874]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.874]         }, condition = base::local({
[13:20:02.874]             c <- base::c
[13:20:02.874]             inherits <- base::inherits
[13:20:02.874]             invokeRestart <- base::invokeRestart
[13:20:02.874]             length <- base::length
[13:20:02.874]             list <- base::list
[13:20:02.874]             seq.int <- base::seq.int
[13:20:02.874]             signalCondition <- base::signalCondition
[13:20:02.874]             sys.calls <- base::sys.calls
[13:20:02.874]             `[[` <- base::`[[`
[13:20:02.874]             `+` <- base::`+`
[13:20:02.874]             `<<-` <- base::`<<-`
[13:20:02.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.874]                   3L)]
[13:20:02.874]             }
[13:20:02.874]             function(cond) {
[13:20:02.874]                 is_error <- inherits(cond, "error")
[13:20:02.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.874]                   NULL)
[13:20:02.874]                 if (is_error) {
[13:20:02.874]                   sessionInformation <- function() {
[13:20:02.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.874]                       search = base::search(), system = base::Sys.info())
[13:20:02.874]                   }
[13:20:02.874]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.874]                     cond$call), session = sessionInformation(), 
[13:20:02.874]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.874]                   signalCondition(cond)
[13:20:02.874]                 }
[13:20:02.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.874]                 "immediateCondition"))) {
[13:20:02.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.874]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.874]                   if (TRUE && !signal) {
[13:20:02.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.874]                     {
[13:20:02.874]                       inherits <- base::inherits
[13:20:02.874]                       invokeRestart <- base::invokeRestart
[13:20:02.874]                       is.null <- base::is.null
[13:20:02.874]                       muffled <- FALSE
[13:20:02.874]                       if (inherits(cond, "message")) {
[13:20:02.874]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.874]                         if (muffled) 
[13:20:02.874]                           invokeRestart("muffleMessage")
[13:20:02.874]                       }
[13:20:02.874]                       else if (inherits(cond, "warning")) {
[13:20:02.874]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.874]                         if (muffled) 
[13:20:02.874]                           invokeRestart("muffleWarning")
[13:20:02.874]                       }
[13:20:02.874]                       else if (inherits(cond, "condition")) {
[13:20:02.874]                         if (!is.null(pattern)) {
[13:20:02.874]                           computeRestarts <- base::computeRestarts
[13:20:02.874]                           grepl <- base::grepl
[13:20:02.874]                           restarts <- computeRestarts(cond)
[13:20:02.874]                           for (restart in restarts) {
[13:20:02.874]                             name <- restart$name
[13:20:02.874]                             if (is.null(name)) 
[13:20:02.874]                               next
[13:20:02.874]                             if (!grepl(pattern, name)) 
[13:20:02.874]                               next
[13:20:02.874]                             invokeRestart(restart)
[13:20:02.874]                             muffled <- TRUE
[13:20:02.874]                             break
[13:20:02.874]                           }
[13:20:02.874]                         }
[13:20:02.874]                       }
[13:20:02.874]                       invisible(muffled)
[13:20:02.874]                     }
[13:20:02.874]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.874]                   }
[13:20:02.874]                 }
[13:20:02.874]                 else {
[13:20:02.874]                   if (TRUE) {
[13:20:02.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.874]                     {
[13:20:02.874]                       inherits <- base::inherits
[13:20:02.874]                       invokeRestart <- base::invokeRestart
[13:20:02.874]                       is.null <- base::is.null
[13:20:02.874]                       muffled <- FALSE
[13:20:02.874]                       if (inherits(cond, "message")) {
[13:20:02.874]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.874]                         if (muffled) 
[13:20:02.874]                           invokeRestart("muffleMessage")
[13:20:02.874]                       }
[13:20:02.874]                       else if (inherits(cond, "warning")) {
[13:20:02.874]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.874]                         if (muffled) 
[13:20:02.874]                           invokeRestart("muffleWarning")
[13:20:02.874]                       }
[13:20:02.874]                       else if (inherits(cond, "condition")) {
[13:20:02.874]                         if (!is.null(pattern)) {
[13:20:02.874]                           computeRestarts <- base::computeRestarts
[13:20:02.874]                           grepl <- base::grepl
[13:20:02.874]                           restarts <- computeRestarts(cond)
[13:20:02.874]                           for (restart in restarts) {
[13:20:02.874]                             name <- restart$name
[13:20:02.874]                             if (is.null(name)) 
[13:20:02.874]                               next
[13:20:02.874]                             if (!grepl(pattern, name)) 
[13:20:02.874]                               next
[13:20:02.874]                             invokeRestart(restart)
[13:20:02.874]                             muffled <- TRUE
[13:20:02.874]                             break
[13:20:02.874]                           }
[13:20:02.874]                         }
[13:20:02.874]                       }
[13:20:02.874]                       invisible(muffled)
[13:20:02.874]                     }
[13:20:02.874]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.874]                   }
[13:20:02.874]                 }
[13:20:02.874]             }
[13:20:02.874]         }))
[13:20:02.874]     }, error = function(ex) {
[13:20:02.874]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.874]                 ...future.rng), started = ...future.startTime, 
[13:20:02.874]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.874]             version = "1.8"), class = "FutureResult")
[13:20:02.874]     }, finally = {
[13:20:02.874]         if (!identical(...future.workdir, getwd())) 
[13:20:02.874]             setwd(...future.workdir)
[13:20:02.874]         {
[13:20:02.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.874]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.874]             }
[13:20:02.874]             base::options(...future.oldOptions)
[13:20:02.874]             if (.Platform$OS.type == "windows") {
[13:20:02.874]                 old_names <- names(...future.oldEnvVars)
[13:20:02.874]                 envs <- base::Sys.getenv()
[13:20:02.874]                 names <- names(envs)
[13:20:02.874]                 common <- intersect(names, old_names)
[13:20:02.874]                 added <- setdiff(names, old_names)
[13:20:02.874]                 removed <- setdiff(old_names, names)
[13:20:02.874]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.874]                   envs[common]]
[13:20:02.874]                 NAMES <- toupper(changed)
[13:20:02.874]                 args <- list()
[13:20:02.874]                 for (kk in seq_along(NAMES)) {
[13:20:02.874]                   name <- changed[[kk]]
[13:20:02.874]                   NAME <- NAMES[[kk]]
[13:20:02.874]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.874]                     next
[13:20:02.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.874]                 }
[13:20:02.874]                 NAMES <- toupper(added)
[13:20:02.874]                 for (kk in seq_along(NAMES)) {
[13:20:02.874]                   name <- added[[kk]]
[13:20:02.874]                   NAME <- NAMES[[kk]]
[13:20:02.874]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.874]                     next
[13:20:02.874]                   args[[name]] <- ""
[13:20:02.874]                 }
[13:20:02.874]                 NAMES <- toupper(removed)
[13:20:02.874]                 for (kk in seq_along(NAMES)) {
[13:20:02.874]                   name <- removed[[kk]]
[13:20:02.874]                   NAME <- NAMES[[kk]]
[13:20:02.874]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.874]                     next
[13:20:02.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.874]                 }
[13:20:02.874]                 if (length(args) > 0) 
[13:20:02.874]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.874]             }
[13:20:02.874]             else {
[13:20:02.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.874]             }
[13:20:02.874]             {
[13:20:02.874]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.874]                   0L) {
[13:20:02.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.874]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.874]                   base::options(opts)
[13:20:02.874]                 }
[13:20:02.874]                 {
[13:20:02.874]                   {
[13:20:02.874]                     NULL
[13:20:02.874]                     RNGkind("Mersenne-Twister")
[13:20:02.874]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.874]                       inherits = FALSE)
[13:20:02.874]                   }
[13:20:02.874]                   options(future.plan = NULL)
[13:20:02.874]                   if (is.na(NA_character_)) 
[13:20:02.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.874]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:02.874]                   {
[13:20:02.874]                     future <- SequentialFuture(..., envir = envir)
[13:20:02.874]                     if (!future$lazy) 
[13:20:02.874]                       future <- run(future)
[13:20:02.874]                     invisible(future)
[13:20:02.874]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.874]                 }
[13:20:02.874]             }
[13:20:02.874]         }
[13:20:02.874]     })
[13:20:02.874]     if (TRUE) {
[13:20:02.874]         base::sink(type = "output", split = FALSE)
[13:20:02.874]         if (TRUE) {
[13:20:02.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.874]         }
[13:20:02.874]         else {
[13:20:02.874]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.874]         }
[13:20:02.874]         base::close(...future.stdout)
[13:20:02.874]         ...future.stdout <- NULL
[13:20:02.874]     }
[13:20:02.874]     ...future.result$conditions <- ...future.conditions
[13:20:02.874]     ...future.result$finished <- base::Sys.time()
[13:20:02.874]     ...future.result
[13:20:02.874] }
[13:20:02.876] assign_globals() ...
[13:20:02.876] List of 5
[13:20:02.876]  $ ...future.FUN            :function (object, ...)  
[13:20:02.876]  $ future.call.arguments    : list()
[13:20:02.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.876]  $ ...future.elements_ii    :List of 3
[13:20:02.876]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.876]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.876]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.876]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.876]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.876]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.876]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.876]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.876]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.876]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.876]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.876]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.876]  $ ...future.seeds_ii       : NULL
[13:20:02.876]  $ ...future.globals.maxSize: NULL
[13:20:02.876]  - attr(*, "where")=List of 5
[13:20:02.876]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.876]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.876]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.876]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.876]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.876]  - attr(*, "resolved")= logi FALSE
[13:20:02.876]  - attr(*, "total_size")= num 1240
[13:20:02.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.876]  - attr(*, "already-done")= logi TRUE
[13:20:02.885] - copied ‘...future.FUN’ to environment
[13:20:02.885] - copied ‘future.call.arguments’ to environment
[13:20:02.885] - copied ‘...future.elements_ii’ to environment
[13:20:02.885] - copied ‘...future.seeds_ii’ to environment
[13:20:02.885] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.885] assign_globals() ... done
[13:20:02.886] plan(): Setting new future strategy stack:
[13:20:02.886] List of future strategies:
[13:20:02.886] 1. sequential:
[13:20:02.886]    - args: function (..., envir = parent.frame())
[13:20:02.886]    - tweaked: FALSE
[13:20:02.886]    - call: NULL
[13:20:02.886] plan(): nbrOfWorkers() = 1
[13:20:02.889] plan(): Setting new future strategy stack:
[13:20:02.889] List of future strategies:
[13:20:02.889] 1. sequential:
[13:20:02.889]    - args: function (..., envir = parent.frame())
[13:20:02.889]    - tweaked: FALSE
[13:20:02.889]    - call: plan(strategy)
[13:20:02.889] plan(): nbrOfWorkers() = 1
[13:20:02.889] SequentialFuture started (and completed)
[13:20:02.889] - Launch lazy future ... done
[13:20:02.891] run() for ‘SequentialFuture’ ... done
[13:20:02.891] Created future:
[13:20:02.891] SequentialFuture:
[13:20:02.891] Label: ‘future_by-1’
[13:20:02.891] Expression:
[13:20:02.891] {
[13:20:02.891]     do.call(function(...) {
[13:20:02.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.891]             on.exit(options(oopts), add = TRUE)
[13:20:02.891]         }
[13:20:02.891]         {
[13:20:02.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.891]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.891]             })
[13:20:02.891]         }
[13:20:02.891]     }, args = future.call.arguments)
[13:20:02.891] }
[13:20:02.891] Lazy evaluation: FALSE
[13:20:02.891] Asynchronous evaluation: FALSE
[13:20:02.891] Local evaluation: TRUE
[13:20:02.891] Environment: 0x55aced3b6488
[13:20:02.891] Capture standard output: TRUE
[13:20:02.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.891] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.891] Packages: <none>
[13:20:02.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.891] Resolved: TRUE
[13:20:02.891] Value: 5.37 KiB of class ‘list’
[13:20:02.891] Early signaling: FALSE
[13:20:02.891] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.891] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.893] Chunk #1 of 1 ... DONE
[13:20:02.893] Launching 1 futures (chunks) ... DONE
[13:20:02.893] Resolving 1 futures (chunks) ...
[13:20:02.893] resolve() on list ...
[13:20:02.893]  recursive: 0
[13:20:02.893]  length: 1
[13:20:02.894] 
[13:20:02.894] resolved() for ‘SequentialFuture’ ...
[13:20:02.894] - state: ‘finished’
[13:20:02.894] - run: TRUE
[13:20:02.894] - result: ‘FutureResult’
[13:20:02.894] resolved() for ‘SequentialFuture’ ... done
[13:20:02.894] Future #1
[13:20:02.894] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.895] - nx: 1
[13:20:02.895] - relay: TRUE
[13:20:02.895] - stdout: TRUE
[13:20:02.895] - signal: TRUE
[13:20:02.895] - resignal: FALSE
[13:20:02.895] - force: TRUE
[13:20:02.895] - relayed: [n=1] FALSE
[13:20:02.895] - queued futures: [n=1] FALSE
[13:20:02.895]  - until=1
[13:20:02.895]  - relaying element #1
[13:20:02.896] - relayed: [n=1] TRUE
[13:20:02.896] - queued futures: [n=1] TRUE
[13:20:02.896] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.896]  length: 0 (resolved future 1)
[13:20:02.896] Relaying remaining futures
[13:20:02.896] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.896] - nx: 1
[13:20:02.896] - relay: TRUE
[13:20:02.896] - stdout: TRUE
[13:20:02.896] - signal: TRUE
[13:20:02.897] - resignal: FALSE
[13:20:02.897] - force: TRUE
[13:20:02.897] - relayed: [n=1] TRUE
[13:20:02.897] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.897] - relayed: [n=1] TRUE
[13:20:02.897] - queued futures: [n=1] TRUE
[13:20:02.897] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.897] resolve() on list ... DONE
[13:20:02.897]  - Number of value chunks collected: 1
[13:20:02.897] Resolving 1 futures (chunks) ... DONE
[13:20:02.898] Reducing values from 1 chunks ...
[13:20:02.898]  - Number of values collected after concatenation: 3
[13:20:02.898]  - Number of values expected: 3
[13:20:02.898] Reducing values from 1 chunks ... DONE
[13:20:02.898] future_lapply() ... DONE
[13:20:02.898] future_by_internal() ... DONE
[13:20:02.899] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:20:02.899] future_lapply() ...
[13:20:02.900] Number of chunks: 1
[13:20:02.900] getGlobalsAndPackagesXApply() ...
[13:20:02.900]  - future.globals: TRUE
[13:20:02.900] getGlobalsAndPackages() ...
[13:20:02.900] Searching for globals...
[13:20:02.901] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.901] Searching for globals ... DONE
[13:20:02.901] Resolving globals: FALSE
[13:20:02.902] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.902] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.902] - globals: [1] ‘FUN’
[13:20:02.902] 
[13:20:02.902] getGlobalsAndPackages() ... DONE
[13:20:02.902]  - globals found/used: [n=1] ‘FUN’
[13:20:02.903]  - needed namespaces: [n=0] 
[13:20:02.903] Finding globals ... DONE
[13:20:02.903]  - use_args: TRUE
[13:20:02.903]  - Getting '...' globals ...
[13:20:02.903] resolve() on list ...
[13:20:02.903]  recursive: 0
[13:20:02.903]  length: 1
[13:20:02.903]  elements: ‘...’
[13:20:02.904]  length: 0 (resolved future 1)
[13:20:02.904] resolve() on list ... DONE
[13:20:02.904]    - '...' content: [n=0] 
[13:20:02.904] List of 1
[13:20:02.904]  $ ...: list()
[13:20:02.904]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.904]  - attr(*, "where")=List of 1
[13:20:02.904]   ..$ ...:<environment: 0x55acec8360e0> 
[13:20:02.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.904]  - attr(*, "resolved")= logi TRUE
[13:20:02.904]  - attr(*, "total_size")= num NA
[13:20:02.906]  - Getting '...' globals ... DONE
[13:20:02.906] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.906] List of 2
[13:20:02.906]  $ ...future.FUN:function (object, ...)  
[13:20:02.906]  $ ...          : list()
[13:20:02.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.906]  - attr(*, "where")=List of 2
[13:20:02.906]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.906]   ..$ ...          :<environment: 0x55acec8360e0> 
[13:20:02.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.906]  - attr(*, "resolved")= logi FALSE
[13:20:02.906]  - attr(*, "total_size")= num 1240
[13:20:02.909] Packages to be attached in all futures: [n=0] 
[13:20:02.909] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.911] Number of futures (= number of chunks): 1
[13:20:02.911] Launching 1 futures (chunks) ...
[13:20:02.911] Chunk #1 of 1 ...
[13:20:02.911]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.911] getGlobalsAndPackages() ...
[13:20:02.912] Searching for globals...
[13:20:02.912] 
[13:20:02.912] Searching for globals ... DONE
[13:20:02.912] - globals: [0] <none>
[13:20:02.912] getGlobalsAndPackages() ... DONE
[13:20:02.912]    + additional globals found: [n=0] 
[13:20:02.913]    + additional namespaces needed: [n=0] 
[13:20:02.913]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.913]  - seeds: <none>
[13:20:02.913]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.913] getGlobalsAndPackages() ...
[13:20:02.913] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.913] Resolving globals: FALSE
[13:20:02.913] Tweak future expression to call with '...' arguments ...
[13:20:02.913] {
[13:20:02.913]     do.call(function(...) {
[13:20:02.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.913]             on.exit(options(oopts), add = TRUE)
[13:20:02.913]         }
[13:20:02.913]         {
[13:20:02.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.913]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.913]             })
[13:20:02.913]         }
[13:20:02.913]     }, args = future.call.arguments)
[13:20:02.913] }
[13:20:02.914] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.914] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.914] 
[13:20:02.914] getGlobalsAndPackages() ... DONE
[13:20:02.915] run() for ‘Future’ ...
[13:20:02.915] - state: ‘created’
[13:20:02.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:02.915] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:02.915]   - Field: ‘label’
[13:20:02.916]   - Field: ‘local’
[13:20:02.916]   - Field: ‘owner’
[13:20:02.916]   - Field: ‘envir’
[13:20:02.916]   - Field: ‘packages’
[13:20:02.916]   - Field: ‘gc’
[13:20:02.916]   - Field: ‘conditions’
[13:20:02.916]   - Field: ‘expr’
[13:20:02.916]   - Field: ‘uuid’
[13:20:02.916]   - Field: ‘seed’
[13:20:02.916]   - Field: ‘version’
[13:20:02.917]   - Field: ‘result’
[13:20:02.917]   - Field: ‘asynchronous’
[13:20:02.917]   - Field: ‘calls’
[13:20:02.917]   - Field: ‘globals’
[13:20:02.917]   - Field: ‘stdout’
[13:20:02.917]   - Field: ‘earlySignal’
[13:20:02.917]   - Field: ‘lazy’
[13:20:02.917]   - Field: ‘state’
[13:20:02.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:02.917] - Launch lazy future ...
[13:20:02.918] Packages needed by the future expression (n = 0): <none>
[13:20:02.918] Packages needed by future strategies (n = 0): <none>
[13:20:02.918] {
[13:20:02.918]     {
[13:20:02.918]         {
[13:20:02.918]             ...future.startTime <- base::Sys.time()
[13:20:02.918]             {
[13:20:02.918]                 {
[13:20:02.918]                   {
[13:20:02.918]                     base::local({
[13:20:02.918]                       has_future <- base::requireNamespace("future", 
[13:20:02.918]                         quietly = TRUE)
[13:20:02.918]                       if (has_future) {
[13:20:02.918]                         ns <- base::getNamespace("future")
[13:20:02.918]                         version <- ns[[".package"]][["version"]]
[13:20:02.918]                         if (is.null(version)) 
[13:20:02.918]                           version <- utils::packageVersion("future")
[13:20:02.918]                       }
[13:20:02.918]                       else {
[13:20:02.918]                         version <- NULL
[13:20:02.918]                       }
[13:20:02.918]                       if (!has_future || version < "1.8.0") {
[13:20:02.918]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.918]                           "", base::R.version$version.string), 
[13:20:02.918]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:02.918]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.918]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.918]                             "release", "version")], collapse = " "), 
[13:20:02.918]                           hostname = base::Sys.info()[["nodename"]])
[13:20:02.918]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.918]                           info)
[13:20:02.918]                         info <- base::paste(info, collapse = "; ")
[13:20:02.918]                         if (!has_future) {
[13:20:02.918]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.918]                             info)
[13:20:02.918]                         }
[13:20:02.918]                         else {
[13:20:02.918]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.918]                             info, version)
[13:20:02.918]                         }
[13:20:02.918]                         base::stop(msg)
[13:20:02.918]                       }
[13:20:02.918]                     })
[13:20:02.918]                   }
[13:20:02.918]                   options(future.plan = NULL)
[13:20:02.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.918]                 }
[13:20:02.918]                 ...future.workdir <- getwd()
[13:20:02.918]             }
[13:20:02.918]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.918]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.918]         }
[13:20:02.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:02.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.918]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.918]             base::names(...future.oldOptions))
[13:20:02.918]     }
[13:20:02.918]     if (FALSE) {
[13:20:02.918]     }
[13:20:02.918]     else {
[13:20:02.918]         if (TRUE) {
[13:20:02.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.918]                 open = "w")
[13:20:02.918]         }
[13:20:02.918]         else {
[13:20:02.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.918]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.918]         }
[13:20:02.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.918]             base::sink(type = "output", split = FALSE)
[13:20:02.918]             base::close(...future.stdout)
[13:20:02.918]         }, add = TRUE)
[13:20:02.918]     }
[13:20:02.918]     ...future.frame <- base::sys.nframe()
[13:20:02.918]     ...future.conditions <- base::list()
[13:20:02.918]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.918]     if (FALSE) {
[13:20:02.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.918]     }
[13:20:02.918]     ...future.result <- base::tryCatch({
[13:20:02.918]         base::withCallingHandlers({
[13:20:02.918]             ...future.value <- base::withVisible(base::local({
[13:20:02.918]                 do.call(function(...) {
[13:20:02.918]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.918]                   if (!identical(...future.globals.maxSize.org, 
[13:20:02.918]                     ...future.globals.maxSize)) {
[13:20:02.918]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.918]                     on.exit(options(oopts), add = TRUE)
[13:20:02.918]                   }
[13:20:02.918]                   {
[13:20:02.918]                     lapply(seq_along(...future.elements_ii), 
[13:20:02.918]                       FUN = function(jj) {
[13:20:02.918]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.918]                         ...future.FUN(...future.X_jj, ...)
[13:20:02.918]                       })
[13:20:02.918]                   }
[13:20:02.918]                 }, args = future.call.arguments)
[13:20:02.918]             }))
[13:20:02.918]             future::FutureResult(value = ...future.value$value, 
[13:20:02.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.918]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.918]                     ...future.globalenv.names))
[13:20:02.918]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.918]         }, condition = base::local({
[13:20:02.918]             c <- base::c
[13:20:02.918]             inherits <- base::inherits
[13:20:02.918]             invokeRestart <- base::invokeRestart
[13:20:02.918]             length <- base::length
[13:20:02.918]             list <- base::list
[13:20:02.918]             seq.int <- base::seq.int
[13:20:02.918]             signalCondition <- base::signalCondition
[13:20:02.918]             sys.calls <- base::sys.calls
[13:20:02.918]             `[[` <- base::`[[`
[13:20:02.918]             `+` <- base::`+`
[13:20:02.918]             `<<-` <- base::`<<-`
[13:20:02.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.918]                   3L)]
[13:20:02.918]             }
[13:20:02.918]             function(cond) {
[13:20:02.918]                 is_error <- inherits(cond, "error")
[13:20:02.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.918]                   NULL)
[13:20:02.918]                 if (is_error) {
[13:20:02.918]                   sessionInformation <- function() {
[13:20:02.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.918]                       search = base::search(), system = base::Sys.info())
[13:20:02.918]                   }
[13:20:02.918]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.918]                     cond$call), session = sessionInformation(), 
[13:20:02.918]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.918]                   signalCondition(cond)
[13:20:02.918]                 }
[13:20:02.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.918]                 "immediateCondition"))) {
[13:20:02.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.918]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.918]                   if (TRUE && !signal) {
[13:20:02.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.918]                     {
[13:20:02.918]                       inherits <- base::inherits
[13:20:02.918]                       invokeRestart <- base::invokeRestart
[13:20:02.918]                       is.null <- base::is.null
[13:20:02.918]                       muffled <- FALSE
[13:20:02.918]                       if (inherits(cond, "message")) {
[13:20:02.918]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.918]                         if (muffled) 
[13:20:02.918]                           invokeRestart("muffleMessage")
[13:20:02.918]                       }
[13:20:02.918]                       else if (inherits(cond, "warning")) {
[13:20:02.918]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.918]                         if (muffled) 
[13:20:02.918]                           invokeRestart("muffleWarning")
[13:20:02.918]                       }
[13:20:02.918]                       else if (inherits(cond, "condition")) {
[13:20:02.918]                         if (!is.null(pattern)) {
[13:20:02.918]                           computeRestarts <- base::computeRestarts
[13:20:02.918]                           grepl <- base::grepl
[13:20:02.918]                           restarts <- computeRestarts(cond)
[13:20:02.918]                           for (restart in restarts) {
[13:20:02.918]                             name <- restart$name
[13:20:02.918]                             if (is.null(name)) 
[13:20:02.918]                               next
[13:20:02.918]                             if (!grepl(pattern, name)) 
[13:20:02.918]                               next
[13:20:02.918]                             invokeRestart(restart)
[13:20:02.918]                             muffled <- TRUE
[13:20:02.918]                             break
[13:20:02.918]                           }
[13:20:02.918]                         }
[13:20:02.918]                       }
[13:20:02.918]                       invisible(muffled)
[13:20:02.918]                     }
[13:20:02.918]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.918]                   }
[13:20:02.918]                 }
[13:20:02.918]                 else {
[13:20:02.918]                   if (TRUE) {
[13:20:02.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.918]                     {
[13:20:02.918]                       inherits <- base::inherits
[13:20:02.918]                       invokeRestart <- base::invokeRestart
[13:20:02.918]                       is.null <- base::is.null
[13:20:02.918]                       muffled <- FALSE
[13:20:02.918]                       if (inherits(cond, "message")) {
[13:20:02.918]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.918]                         if (muffled) 
[13:20:02.918]                           invokeRestart("muffleMessage")
[13:20:02.918]                       }
[13:20:02.918]                       else if (inherits(cond, "warning")) {
[13:20:02.918]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.918]                         if (muffled) 
[13:20:02.918]                           invokeRestart("muffleWarning")
[13:20:02.918]                       }
[13:20:02.918]                       else if (inherits(cond, "condition")) {
[13:20:02.918]                         if (!is.null(pattern)) {
[13:20:02.918]                           computeRestarts <- base::computeRestarts
[13:20:02.918]                           grepl <- base::grepl
[13:20:02.918]                           restarts <- computeRestarts(cond)
[13:20:02.918]                           for (restart in restarts) {
[13:20:02.918]                             name <- restart$name
[13:20:02.918]                             if (is.null(name)) 
[13:20:02.918]                               next
[13:20:02.918]                             if (!grepl(pattern, name)) 
[13:20:02.918]                               next
[13:20:02.918]                             invokeRestart(restart)
[13:20:02.918]                             muffled <- TRUE
[13:20:02.918]                             break
[13:20:02.918]                           }
[13:20:02.918]                         }
[13:20:02.918]                       }
[13:20:02.918]                       invisible(muffled)
[13:20:02.918]                     }
[13:20:02.918]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.918]                   }
[13:20:02.918]                 }
[13:20:02.918]             }
[13:20:02.918]         }))
[13:20:02.918]     }, error = function(ex) {
[13:20:02.918]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.918]                 ...future.rng), started = ...future.startTime, 
[13:20:02.918]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.918]             version = "1.8"), class = "FutureResult")
[13:20:02.918]     }, finally = {
[13:20:02.918]         if (!identical(...future.workdir, getwd())) 
[13:20:02.918]             setwd(...future.workdir)
[13:20:02.918]         {
[13:20:02.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.918]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.918]             }
[13:20:02.918]             base::options(...future.oldOptions)
[13:20:02.918]             if (.Platform$OS.type == "windows") {
[13:20:02.918]                 old_names <- names(...future.oldEnvVars)
[13:20:02.918]                 envs <- base::Sys.getenv()
[13:20:02.918]                 names <- names(envs)
[13:20:02.918]                 common <- intersect(names, old_names)
[13:20:02.918]                 added <- setdiff(names, old_names)
[13:20:02.918]                 removed <- setdiff(old_names, names)
[13:20:02.918]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.918]                   envs[common]]
[13:20:02.918]                 NAMES <- toupper(changed)
[13:20:02.918]                 args <- list()
[13:20:02.918]                 for (kk in seq_along(NAMES)) {
[13:20:02.918]                   name <- changed[[kk]]
[13:20:02.918]                   NAME <- NAMES[[kk]]
[13:20:02.918]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.918]                     next
[13:20:02.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.918]                 }
[13:20:02.918]                 NAMES <- toupper(added)
[13:20:02.918]                 for (kk in seq_along(NAMES)) {
[13:20:02.918]                   name <- added[[kk]]
[13:20:02.918]                   NAME <- NAMES[[kk]]
[13:20:02.918]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.918]                     next
[13:20:02.918]                   args[[name]] <- ""
[13:20:02.918]                 }
[13:20:02.918]                 NAMES <- toupper(removed)
[13:20:02.918]                 for (kk in seq_along(NAMES)) {
[13:20:02.918]                   name <- removed[[kk]]
[13:20:02.918]                   NAME <- NAMES[[kk]]
[13:20:02.918]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.918]                     next
[13:20:02.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.918]                 }
[13:20:02.918]                 if (length(args) > 0) 
[13:20:02.918]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.918]             }
[13:20:02.918]             else {
[13:20:02.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.918]             }
[13:20:02.918]             {
[13:20:02.918]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.918]                   0L) {
[13:20:02.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.918]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.918]                   base::options(opts)
[13:20:02.918]                 }
[13:20:02.918]                 {
[13:20:02.918]                   {
[13:20:02.918]                     NULL
[13:20:02.918]                     RNGkind("Mersenne-Twister")
[13:20:02.918]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:02.918]                       inherits = FALSE)
[13:20:02.918]                   }
[13:20:02.918]                   options(future.plan = NULL)
[13:20:02.918]                   if (is.na(NA_character_)) 
[13:20:02.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.918]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:02.918]                   {
[13:20:02.918]                     future <- SequentialFuture(..., envir = envir)
[13:20:02.918]                     if (!future$lazy) 
[13:20:02.918]                       future <- run(future)
[13:20:02.918]                     invisible(future)
[13:20:02.918]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.918]                 }
[13:20:02.918]             }
[13:20:02.918]         }
[13:20:02.918]     })
[13:20:02.918]     if (TRUE) {
[13:20:02.918]         base::sink(type = "output", split = FALSE)
[13:20:02.918]         if (TRUE) {
[13:20:02.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.918]         }
[13:20:02.918]         else {
[13:20:02.918]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.918]         }
[13:20:02.918]         base::close(...future.stdout)
[13:20:02.918]         ...future.stdout <- NULL
[13:20:02.918]     }
[13:20:02.918]     ...future.result$conditions <- ...future.conditions
[13:20:02.918]     ...future.result$finished <- base::Sys.time()
[13:20:02.918]     ...future.result
[13:20:02.918] }
[13:20:02.920] assign_globals() ...
[13:20:02.920] List of 5
[13:20:02.920]  $ ...future.FUN            :function (object, ...)  
[13:20:02.920]  $ future.call.arguments    : list()
[13:20:02.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.920]  $ ...future.elements_ii    :List of 3
[13:20:02.920]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.920]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.920]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.920]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:02.920]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.920]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:02.920]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.920]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:02.920]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:02.920]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:02.920]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.920]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:02.920]  $ ...future.seeds_ii       : NULL
[13:20:02.920]  $ ...future.globals.maxSize: NULL
[13:20:02.920]  - attr(*, "where")=List of 5
[13:20:02.920]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.920]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.920]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.920]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.920]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.920]  - attr(*, "resolved")= logi FALSE
[13:20:02.920]  - attr(*, "total_size")= num 1240
[13:20:02.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.920]  - attr(*, "already-done")= logi TRUE
[13:20:02.928] - copied ‘...future.FUN’ to environment
[13:20:02.929] - copied ‘future.call.arguments’ to environment
[13:20:02.929] - copied ‘...future.elements_ii’ to environment
[13:20:02.929] - copied ‘...future.seeds_ii’ to environment
[13:20:02.929] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.929] assign_globals() ... done
[13:20:02.929] plan(): Setting new future strategy stack:
[13:20:02.929] List of future strategies:
[13:20:02.929] 1. sequential:
[13:20:02.929]    - args: function (..., envir = parent.frame())
[13:20:02.929]    - tweaked: FALSE
[13:20:02.929]    - call: NULL
[13:20:02.930] plan(): nbrOfWorkers() = 1
[13:20:02.934] plan(): Setting new future strategy stack:
[13:20:02.934] List of future strategies:
[13:20:02.934] 1. sequential:
[13:20:02.934]    - args: function (..., envir = parent.frame())
[13:20:02.934]    - tweaked: FALSE
[13:20:02.934]    - call: plan(strategy)
[13:20:02.935] plan(): nbrOfWorkers() = 1
[13:20:02.935] SequentialFuture started (and completed)
[13:20:02.935] - Launch lazy future ... done
[13:20:02.935] run() for ‘SequentialFuture’ ... done
[13:20:02.935] Created future:
[13:20:02.935] SequentialFuture:
[13:20:02.935] Label: ‘future_by-1’
[13:20:02.935] Expression:
[13:20:02.935] {
[13:20:02.935]     do.call(function(...) {
[13:20:02.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.935]             on.exit(options(oopts), add = TRUE)
[13:20:02.935]         }
[13:20:02.935]         {
[13:20:02.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.935]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.935]             })
[13:20:02.935]         }
[13:20:02.935]     }, args = future.call.arguments)
[13:20:02.935] }
[13:20:02.935] Lazy evaluation: FALSE
[13:20:02.935] Asynchronous evaluation: FALSE
[13:20:02.935] Local evaluation: TRUE
[13:20:02.935] Environment: 0x55acecf53ee0
[13:20:02.935] Capture standard output: TRUE
[13:20:02.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.935] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.935] Packages: <none>
[13:20:02.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.935] Resolved: TRUE
[13:20:02.935] Value: 5.37 KiB of class ‘list’
[13:20:02.935] Early signaling: FALSE
[13:20:02.935] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.935] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:02.937] Chunk #1 of 1 ... DONE
[13:20:02.937] Launching 1 futures (chunks) ... DONE
[13:20:02.937] Resolving 1 futures (chunks) ...
[13:20:02.937] resolve() on list ...
[13:20:02.937]  recursive: 0
[13:20:02.937]  length: 1
[13:20:02.937] 
[13:20:02.938] resolved() for ‘SequentialFuture’ ...
[13:20:02.938] - state: ‘finished’
[13:20:02.938] - run: TRUE
[13:20:02.938] - result: ‘FutureResult’
[13:20:02.938] resolved() for ‘SequentialFuture’ ... done
[13:20:02.938] Future #1
[13:20:02.938] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:20:02.938] - nx: 1
[13:20:02.938] - relay: TRUE
[13:20:02.938] - stdout: TRUE
[13:20:02.939] - signal: TRUE
[13:20:02.939] - resignal: FALSE
[13:20:02.939] - force: TRUE
[13:20:02.939] - relayed: [n=1] FALSE
[13:20:02.939] - queued futures: [n=1] FALSE
[13:20:02.939]  - until=1
[13:20:02.939]  - relaying element #1
[13:20:02.939] - relayed: [n=1] TRUE
[13:20:02.939] - queued futures: [n=1] TRUE
[13:20:02.939] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:20:02.940]  length: 0 (resolved future 1)
[13:20:02.940] Relaying remaining futures
[13:20:02.940] signalConditionsASAP(NULL, pos=0) ...
[13:20:02.940] - nx: 1
[13:20:02.940] - relay: TRUE
[13:20:02.940] - stdout: TRUE
[13:20:02.940] - signal: TRUE
[13:20:02.940] - resignal: FALSE
[13:20:02.940] - force: TRUE
[13:20:02.940] - relayed: [n=1] TRUE
[13:20:02.940] - queued futures: [n=1] TRUE
 - flush all
[13:20:02.941] - relayed: [n=1] TRUE
[13:20:02.941] - queued futures: [n=1] TRUE
[13:20:02.941] signalConditionsASAP(NULL, pos=0) ... done
[13:20:02.941] resolve() on list ... DONE
[13:20:02.941]  - Number of value chunks collected: 1
[13:20:02.941] Resolving 1 futures (chunks) ... DONE
[13:20:02.941] Reducing values from 1 chunks ...
[13:20:02.941]  - Number of values collected after concatenation: 3
[13:20:02.941]  - Number of values expected: 3
[13:20:02.941] Reducing values from 1 chunks ... DONE
[13:20:02.942] future_lapply() ... DONE
[13:20:02.942] future_by_internal() ... DONE
[13:20:02.942] future_by_internal() ...
- plan('multicore') ...
[13:20:02.943] plan(): Setting new future strategy stack:
[13:20:02.943] List of future strategies:
[13:20:02.943] 1. multicore:
[13:20:02.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.943]    - tweaked: FALSE
[13:20:02.943]    - call: plan(strategy)
[13:20:02.947] plan(): nbrOfWorkers() = 2
[13:20:02.947] future_by_internal() ...
[13:20:02.948] future_lapply() ...
[13:20:02.952] Number of chunks: 2
[13:20:02.952] getGlobalsAndPackagesXApply() ...
[13:20:02.952]  - future.globals: TRUE
[13:20:02.952] getGlobalsAndPackages() ...
[13:20:02.952] Searching for globals...
[13:20:02.953] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:02.954] Searching for globals ... DONE
[13:20:02.954] Resolving globals: FALSE
[13:20:02.954] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:02.954] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:02.954] - globals: [1] ‘FUN’
[13:20:02.955] 
[13:20:02.955] getGlobalsAndPackages() ... DONE
[13:20:02.955]  - globals found/used: [n=1] ‘FUN’
[13:20:02.955]  - needed namespaces: [n=0] 
[13:20:02.955] Finding globals ... DONE
[13:20:02.955]  - use_args: TRUE
[13:20:02.955]  - Getting '...' globals ...
[13:20:02.955] resolve() on list ...
[13:20:02.955]  recursive: 0
[13:20:02.956]  length: 1
[13:20:02.956]  elements: ‘...’
[13:20:02.956]  length: 0 (resolved future 1)
[13:20:02.956] resolve() on list ... DONE
[13:20:02.956]    - '...' content: [n=0] 
[13:20:02.956] List of 1
[13:20:02.956]  $ ...: list()
[13:20:02.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.956]  - attr(*, "where")=List of 1
[13:20:02.956]   ..$ ...:<environment: 0x55acee712468> 
[13:20:02.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.956]  - attr(*, "resolved")= logi TRUE
[13:20:02.956]  - attr(*, "total_size")= num NA
[13:20:02.961]  - Getting '...' globals ... DONE
[13:20:02.961] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:02.961] List of 2
[13:20:02.961]  $ ...future.FUN:function (object, ...)  
[13:20:02.961]  $ ...          : list()
[13:20:02.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.961]  - attr(*, "where")=List of 2
[13:20:02.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:02.961]   ..$ ...          :<environment: 0x55acee712468> 
[13:20:02.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.961]  - attr(*, "resolved")= logi FALSE
[13:20:02.961]  - attr(*, "total_size")= num 1240
[13:20:02.964] Packages to be attached in all futures: [n=0] 
[13:20:02.964] getGlobalsAndPackagesXApply() ... DONE
[13:20:02.964] Number of futures (= number of chunks): 2
[13:20:02.965] Launching 2 futures (chunks) ...
[13:20:02.965] Chunk #1 of 2 ...
[13:20:02.965]  - Finding globals in 'X' for chunk #1 ...
[13:20:02.965] getGlobalsAndPackages() ...
[13:20:02.965] Searching for globals...
[13:20:02.965] 
[13:20:02.965] Searching for globals ... DONE
[13:20:02.966] - globals: [0] <none>
[13:20:02.966] getGlobalsAndPackages() ... DONE
[13:20:02.966]    + additional globals found: [n=0] 
[13:20:02.966]    + additional namespaces needed: [n=0] 
[13:20:02.966]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:02.966]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:02.966]  - seeds: <none>
[13:20:02.966]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.966] getGlobalsAndPackages() ...
[13:20:02.966] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.966] Resolving globals: FALSE
[13:20:02.967] Tweak future expression to call with '...' arguments ...
[13:20:02.967] {
[13:20:02.967]     do.call(function(...) {
[13:20:02.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.967]             on.exit(options(oopts), add = TRUE)
[13:20:02.967]         }
[13:20:02.967]         {
[13:20:02.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.967]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.967]             })
[13:20:02.967]         }
[13:20:02.967]     }, args = future.call.arguments)
[13:20:02.967] }
[13:20:02.967] Tweak future expression to call with '...' arguments ... DONE
[13:20:02.967] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:02.967] 
[13:20:02.967] getGlobalsAndPackages() ... DONE
[13:20:02.968] run() for ‘Future’ ...
[13:20:02.968] - state: ‘created’
[13:20:02.968] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:02.972] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:02.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:02.972]   - Field: ‘label’
[13:20:02.972]   - Field: ‘local’
[13:20:02.972]   - Field: ‘owner’
[13:20:02.972]   - Field: ‘envir’
[13:20:02.972]   - Field: ‘workers’
[13:20:02.972]   - Field: ‘packages’
[13:20:02.973]   - Field: ‘gc’
[13:20:02.973]   - Field: ‘job’
[13:20:02.973]   - Field: ‘conditions’
[13:20:02.973]   - Field: ‘expr’
[13:20:02.973]   - Field: ‘uuid’
[13:20:02.973]   - Field: ‘seed’
[13:20:02.973]   - Field: ‘version’
[13:20:02.973]   - Field: ‘result’
[13:20:02.973]   - Field: ‘asynchronous’
[13:20:02.973]   - Field: ‘calls’
[13:20:02.973]   - Field: ‘globals’
[13:20:02.974]   - Field: ‘stdout’
[13:20:02.974]   - Field: ‘earlySignal’
[13:20:02.974]   - Field: ‘lazy’
[13:20:02.974]   - Field: ‘state’
[13:20:02.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:02.974] - Launch lazy future ...
[13:20:02.975] Packages needed by the future expression (n = 0): <none>
[13:20:02.975] Packages needed by future strategies (n = 0): <none>
[13:20:02.976] {
[13:20:02.976]     {
[13:20:02.976]         {
[13:20:02.976]             ...future.startTime <- base::Sys.time()
[13:20:02.976]             {
[13:20:02.976]                 {
[13:20:02.976]                   {
[13:20:02.976]                     {
[13:20:02.976]                       base::local({
[13:20:02.976]                         has_future <- base::requireNamespace("future", 
[13:20:02.976]                           quietly = TRUE)
[13:20:02.976]                         if (has_future) {
[13:20:02.976]                           ns <- base::getNamespace("future")
[13:20:02.976]                           version <- ns[[".package"]][["version"]]
[13:20:02.976]                           if (is.null(version)) 
[13:20:02.976]                             version <- utils::packageVersion("future")
[13:20:02.976]                         }
[13:20:02.976]                         else {
[13:20:02.976]                           version <- NULL
[13:20:02.976]                         }
[13:20:02.976]                         if (!has_future || version < "1.8.0") {
[13:20:02.976]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:02.976]                             "", base::R.version$version.string), 
[13:20:02.976]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:02.976]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:02.976]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:02.976]                               "release", "version")], collapse = " "), 
[13:20:02.976]                             hostname = base::Sys.info()[["nodename"]])
[13:20:02.976]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:02.976]                             info)
[13:20:02.976]                           info <- base::paste(info, collapse = "; ")
[13:20:02.976]                           if (!has_future) {
[13:20:02.976]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:02.976]                               info)
[13:20:02.976]                           }
[13:20:02.976]                           else {
[13:20:02.976]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:02.976]                               info, version)
[13:20:02.976]                           }
[13:20:02.976]                           base::stop(msg)
[13:20:02.976]                         }
[13:20:02.976]                       })
[13:20:02.976]                     }
[13:20:02.976]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:02.976]                     base::options(mc.cores = 1L)
[13:20:02.976]                   }
[13:20:02.976]                   options(future.plan = NULL)
[13:20:02.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:02.976]                 }
[13:20:02.976]                 ...future.workdir <- getwd()
[13:20:02.976]             }
[13:20:02.976]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:02.976]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:02.976]         }
[13:20:02.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:02.976]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:02.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:02.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:02.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:02.976]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:02.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:02.976]             base::names(...future.oldOptions))
[13:20:02.976]     }
[13:20:02.976]     if (FALSE) {
[13:20:02.976]     }
[13:20:02.976]     else {
[13:20:02.976]         if (TRUE) {
[13:20:02.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:02.976]                 open = "w")
[13:20:02.976]         }
[13:20:02.976]         else {
[13:20:02.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:02.976]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:02.976]         }
[13:20:02.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:02.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:02.976]             base::sink(type = "output", split = FALSE)
[13:20:02.976]             base::close(...future.stdout)
[13:20:02.976]         }, add = TRUE)
[13:20:02.976]     }
[13:20:02.976]     ...future.frame <- base::sys.nframe()
[13:20:02.976]     ...future.conditions <- base::list()
[13:20:02.976]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:02.976]     if (FALSE) {
[13:20:02.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:02.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:02.976]     }
[13:20:02.976]     ...future.result <- base::tryCatch({
[13:20:02.976]         base::withCallingHandlers({
[13:20:02.976]             ...future.value <- base::withVisible(base::local({
[13:20:02.976]                 withCallingHandlers({
[13:20:02.976]                   {
[13:20:02.976]                     do.call(function(...) {
[13:20:02.976]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.976]                       if (!identical(...future.globals.maxSize.org, 
[13:20:02.976]                         ...future.globals.maxSize)) {
[13:20:02.976]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.976]                         on.exit(options(oopts), add = TRUE)
[13:20:02.976]                       }
[13:20:02.976]                       {
[13:20:02.976]                         lapply(seq_along(...future.elements_ii), 
[13:20:02.976]                           FUN = function(jj) {
[13:20:02.976]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.976]                             ...future.FUN(...future.X_jj, ...)
[13:20:02.976]                           })
[13:20:02.976]                       }
[13:20:02.976]                     }, args = future.call.arguments)
[13:20:02.976]                   }
[13:20:02.976]                 }, immediateCondition = function(cond) {
[13:20:02.976]                   save_rds <- function (object, pathname, ...) 
[13:20:02.976]                   {
[13:20:02.976]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:02.976]                     if (file_test("-f", pathname_tmp)) {
[13:20:02.976]                       fi_tmp <- file.info(pathname_tmp)
[13:20:02.976]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:02.976]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:02.976]                         fi_tmp[["mtime"]])
[13:20:02.976]                     }
[13:20:02.976]                     tryCatch({
[13:20:02.976]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:02.976]                     }, error = function(ex) {
[13:20:02.976]                       msg <- conditionMessage(ex)
[13:20:02.976]                       fi_tmp <- file.info(pathname_tmp)
[13:20:02.976]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:02.976]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:02.976]                         fi_tmp[["mtime"]], msg)
[13:20:02.976]                       ex$message <- msg
[13:20:02.976]                       stop(ex)
[13:20:02.976]                     })
[13:20:02.976]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:02.976]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:02.976]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:02.976]                       fi_tmp <- file.info(pathname_tmp)
[13:20:02.976]                       fi <- file.info(pathname)
[13:20:02.976]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:02.976]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:02.976]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:02.976]                         fi[["size"]], fi[["mtime"]])
[13:20:02.976]                       stop(msg)
[13:20:02.976]                     }
[13:20:02.976]                     invisible(pathname)
[13:20:02.976]                   }
[13:20:02.976]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:02.976]                     rootPath = tempdir()) 
[13:20:02.976]                   {
[13:20:02.976]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:02.976]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:02.976]                       tmpdir = path, fileext = ".rds")
[13:20:02.976]                     save_rds(obj, file)
[13:20:02.976]                   }
[13:20:02.976]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:02.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.976]                   {
[13:20:02.976]                     inherits <- base::inherits
[13:20:02.976]                     invokeRestart <- base::invokeRestart
[13:20:02.976]                     is.null <- base::is.null
[13:20:02.976]                     muffled <- FALSE
[13:20:02.976]                     if (inherits(cond, "message")) {
[13:20:02.976]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:02.976]                       if (muffled) 
[13:20:02.976]                         invokeRestart("muffleMessage")
[13:20:02.976]                     }
[13:20:02.976]                     else if (inherits(cond, "warning")) {
[13:20:02.976]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:02.976]                       if (muffled) 
[13:20:02.976]                         invokeRestart("muffleWarning")
[13:20:02.976]                     }
[13:20:02.976]                     else if (inherits(cond, "condition")) {
[13:20:02.976]                       if (!is.null(pattern)) {
[13:20:02.976]                         computeRestarts <- base::computeRestarts
[13:20:02.976]                         grepl <- base::grepl
[13:20:02.976]                         restarts <- computeRestarts(cond)
[13:20:02.976]                         for (restart in restarts) {
[13:20:02.976]                           name <- restart$name
[13:20:02.976]                           if (is.null(name)) 
[13:20:02.976]                             next
[13:20:02.976]                           if (!grepl(pattern, name)) 
[13:20:02.976]                             next
[13:20:02.976]                           invokeRestart(restart)
[13:20:02.976]                           muffled <- TRUE
[13:20:02.976]                           break
[13:20:02.976]                         }
[13:20:02.976]                       }
[13:20:02.976]                     }
[13:20:02.976]                     invisible(muffled)
[13:20:02.976]                   }
[13:20:02.976]                   muffleCondition(cond)
[13:20:02.976]                 })
[13:20:02.976]             }))
[13:20:02.976]             future::FutureResult(value = ...future.value$value, 
[13:20:02.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.976]                   ...future.rng), globalenv = if (FALSE) 
[13:20:02.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:02.976]                     ...future.globalenv.names))
[13:20:02.976]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:02.976]         }, condition = base::local({
[13:20:02.976]             c <- base::c
[13:20:02.976]             inherits <- base::inherits
[13:20:02.976]             invokeRestart <- base::invokeRestart
[13:20:02.976]             length <- base::length
[13:20:02.976]             list <- base::list
[13:20:02.976]             seq.int <- base::seq.int
[13:20:02.976]             signalCondition <- base::signalCondition
[13:20:02.976]             sys.calls <- base::sys.calls
[13:20:02.976]             `[[` <- base::`[[`
[13:20:02.976]             `+` <- base::`+`
[13:20:02.976]             `<<-` <- base::`<<-`
[13:20:02.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:02.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:02.976]                   3L)]
[13:20:02.976]             }
[13:20:02.976]             function(cond) {
[13:20:02.976]                 is_error <- inherits(cond, "error")
[13:20:02.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:02.976]                   NULL)
[13:20:02.976]                 if (is_error) {
[13:20:02.976]                   sessionInformation <- function() {
[13:20:02.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:02.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:02.976]                       search = base::search(), system = base::Sys.info())
[13:20:02.976]                   }
[13:20:02.976]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:02.976]                     cond$call), session = sessionInformation(), 
[13:20:02.976]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:02.976]                   signalCondition(cond)
[13:20:02.976]                 }
[13:20:02.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:02.976]                 "immediateCondition"))) {
[13:20:02.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:02.976]                   ...future.conditions[[length(...future.conditions) + 
[13:20:02.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:02.976]                   if (TRUE && !signal) {
[13:20:02.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.976]                     {
[13:20:02.976]                       inherits <- base::inherits
[13:20:02.976]                       invokeRestart <- base::invokeRestart
[13:20:02.976]                       is.null <- base::is.null
[13:20:02.976]                       muffled <- FALSE
[13:20:02.976]                       if (inherits(cond, "message")) {
[13:20:02.976]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.976]                         if (muffled) 
[13:20:02.976]                           invokeRestart("muffleMessage")
[13:20:02.976]                       }
[13:20:02.976]                       else if (inherits(cond, "warning")) {
[13:20:02.976]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.976]                         if (muffled) 
[13:20:02.976]                           invokeRestart("muffleWarning")
[13:20:02.976]                       }
[13:20:02.976]                       else if (inherits(cond, "condition")) {
[13:20:02.976]                         if (!is.null(pattern)) {
[13:20:02.976]                           computeRestarts <- base::computeRestarts
[13:20:02.976]                           grepl <- base::grepl
[13:20:02.976]                           restarts <- computeRestarts(cond)
[13:20:02.976]                           for (restart in restarts) {
[13:20:02.976]                             name <- restart$name
[13:20:02.976]                             if (is.null(name)) 
[13:20:02.976]                               next
[13:20:02.976]                             if (!grepl(pattern, name)) 
[13:20:02.976]                               next
[13:20:02.976]                             invokeRestart(restart)
[13:20:02.976]                             muffled <- TRUE
[13:20:02.976]                             break
[13:20:02.976]                           }
[13:20:02.976]                         }
[13:20:02.976]                       }
[13:20:02.976]                       invisible(muffled)
[13:20:02.976]                     }
[13:20:02.976]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.976]                   }
[13:20:02.976]                 }
[13:20:02.976]                 else {
[13:20:02.976]                   if (TRUE) {
[13:20:02.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:02.976]                     {
[13:20:02.976]                       inherits <- base::inherits
[13:20:02.976]                       invokeRestart <- base::invokeRestart
[13:20:02.976]                       is.null <- base::is.null
[13:20:02.976]                       muffled <- FALSE
[13:20:02.976]                       if (inherits(cond, "message")) {
[13:20:02.976]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:02.976]                         if (muffled) 
[13:20:02.976]                           invokeRestart("muffleMessage")
[13:20:02.976]                       }
[13:20:02.976]                       else if (inherits(cond, "warning")) {
[13:20:02.976]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:02.976]                         if (muffled) 
[13:20:02.976]                           invokeRestart("muffleWarning")
[13:20:02.976]                       }
[13:20:02.976]                       else if (inherits(cond, "condition")) {
[13:20:02.976]                         if (!is.null(pattern)) {
[13:20:02.976]                           computeRestarts <- base::computeRestarts
[13:20:02.976]                           grepl <- base::grepl
[13:20:02.976]                           restarts <- computeRestarts(cond)
[13:20:02.976]                           for (restart in restarts) {
[13:20:02.976]                             name <- restart$name
[13:20:02.976]                             if (is.null(name)) 
[13:20:02.976]                               next
[13:20:02.976]                             if (!grepl(pattern, name)) 
[13:20:02.976]                               next
[13:20:02.976]                             invokeRestart(restart)
[13:20:02.976]                             muffled <- TRUE
[13:20:02.976]                             break
[13:20:02.976]                           }
[13:20:02.976]                         }
[13:20:02.976]                       }
[13:20:02.976]                       invisible(muffled)
[13:20:02.976]                     }
[13:20:02.976]                     muffleCondition(cond, pattern = "^muffle")
[13:20:02.976]                   }
[13:20:02.976]                 }
[13:20:02.976]             }
[13:20:02.976]         }))
[13:20:02.976]     }, error = function(ex) {
[13:20:02.976]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:02.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:02.976]                 ...future.rng), started = ...future.startTime, 
[13:20:02.976]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:02.976]             version = "1.8"), class = "FutureResult")
[13:20:02.976]     }, finally = {
[13:20:02.976]         if (!identical(...future.workdir, getwd())) 
[13:20:02.976]             setwd(...future.workdir)
[13:20:02.976]         {
[13:20:02.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:02.976]                 ...future.oldOptions$nwarnings <- NULL
[13:20:02.976]             }
[13:20:02.976]             base::options(...future.oldOptions)
[13:20:02.976]             if (.Platform$OS.type == "windows") {
[13:20:02.976]                 old_names <- names(...future.oldEnvVars)
[13:20:02.976]                 envs <- base::Sys.getenv()
[13:20:02.976]                 names <- names(envs)
[13:20:02.976]                 common <- intersect(names, old_names)
[13:20:02.976]                 added <- setdiff(names, old_names)
[13:20:02.976]                 removed <- setdiff(old_names, names)
[13:20:02.976]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:02.976]                   envs[common]]
[13:20:02.976]                 NAMES <- toupper(changed)
[13:20:02.976]                 args <- list()
[13:20:02.976]                 for (kk in seq_along(NAMES)) {
[13:20:02.976]                   name <- changed[[kk]]
[13:20:02.976]                   NAME <- NAMES[[kk]]
[13:20:02.976]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.976]                     next
[13:20:02.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.976]                 }
[13:20:02.976]                 NAMES <- toupper(added)
[13:20:02.976]                 for (kk in seq_along(NAMES)) {
[13:20:02.976]                   name <- added[[kk]]
[13:20:02.976]                   NAME <- NAMES[[kk]]
[13:20:02.976]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.976]                     next
[13:20:02.976]                   args[[name]] <- ""
[13:20:02.976]                 }
[13:20:02.976]                 NAMES <- toupper(removed)
[13:20:02.976]                 for (kk in seq_along(NAMES)) {
[13:20:02.976]                   name <- removed[[kk]]
[13:20:02.976]                   NAME <- NAMES[[kk]]
[13:20:02.976]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:02.976]                     next
[13:20:02.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:02.976]                 }
[13:20:02.976]                 if (length(args) > 0) 
[13:20:02.976]                   base::do.call(base::Sys.setenv, args = args)
[13:20:02.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:02.976]             }
[13:20:02.976]             else {
[13:20:02.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:02.976]             }
[13:20:02.976]             {
[13:20:02.976]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:02.976]                   0L) {
[13:20:02.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:02.976]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:02.976]                   base::options(opts)
[13:20:02.976]                 }
[13:20:02.976]                 {
[13:20:02.976]                   {
[13:20:02.976]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:02.976]                     NULL
[13:20:02.976]                   }
[13:20:02.976]                   options(future.plan = NULL)
[13:20:02.976]                   if (is.na(NA_character_)) 
[13:20:02.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:02.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:02.976]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:02.976]                     envir = parent.frame()) 
[13:20:02.976]                   {
[13:20:02.976]                     default_workers <- missing(workers)
[13:20:02.976]                     if (is.function(workers)) 
[13:20:02.976]                       workers <- workers()
[13:20:02.976]                     workers <- structure(as.integer(workers), 
[13:20:02.976]                       class = class(workers))
[13:20:02.976]                     stop_if_not(is.finite(workers), workers >= 
[13:20:02.976]                       1L)
[13:20:02.976]                     if ((workers == 1L && !inherits(workers, 
[13:20:02.976]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:02.976]                       if (default_workers) 
[13:20:02.976]                         supportsMulticore(warn = TRUE)
[13:20:02.976]                       return(sequential(..., envir = envir))
[13:20:02.976]                     }
[13:20:02.976]                     oopts <- options(mc.cores = workers)
[13:20:02.976]                     on.exit(options(oopts))
[13:20:02.976]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:02.976]                       envir = envir)
[13:20:02.976]                     if (!future$lazy) 
[13:20:02.976]                       future <- run(future)
[13:20:02.976]                     invisible(future)
[13:20:02.976]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:02.976]                 }
[13:20:02.976]             }
[13:20:02.976]         }
[13:20:02.976]     })
[13:20:02.976]     if (TRUE) {
[13:20:02.976]         base::sink(type = "output", split = FALSE)
[13:20:02.976]         if (TRUE) {
[13:20:02.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:02.976]         }
[13:20:02.976]         else {
[13:20:02.976]             ...future.result["stdout"] <- base::list(NULL)
[13:20:02.976]         }
[13:20:02.976]         base::close(...future.stdout)
[13:20:02.976]         ...future.stdout <- NULL
[13:20:02.976]     }
[13:20:02.976]     ...future.result$conditions <- ...future.conditions
[13:20:02.976]     ...future.result$finished <- base::Sys.time()
[13:20:02.976]     ...future.result
[13:20:02.976] }
[13:20:02.978] assign_globals() ...
[13:20:02.979] List of 5
[13:20:02.979]  $ ...future.FUN            :function (object, ...)  
[13:20:02.979]  $ future.call.arguments    : list()
[13:20:02.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:02.979]  $ ...future.elements_ii    :List of 1
[13:20:02.979]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:02.979]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:02.979]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:02.979]  $ ...future.seeds_ii       : NULL
[13:20:02.979]  $ ...future.globals.maxSize: NULL
[13:20:02.979]  - attr(*, "where")=List of 5
[13:20:02.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:02.979]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:02.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:02.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:02.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:02.979]  - attr(*, "resolved")= logi FALSE
[13:20:02.979]  - attr(*, "total_size")= num 1240
[13:20:02.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:02.979]  - attr(*, "already-done")= logi TRUE
[13:20:02.987] - copied ‘...future.FUN’ to environment
[13:20:02.987] - copied ‘future.call.arguments’ to environment
[13:20:02.987] - copied ‘...future.elements_ii’ to environment
[13:20:02.987] - copied ‘...future.seeds_ii’ to environment
[13:20:02.987] - copied ‘...future.globals.maxSize’ to environment
[13:20:02.987] assign_globals() ... done
[13:20:02.988] requestCore(): workers = 2
[13:20:02.991] MulticoreFuture started
[13:20:02.992] - Launch lazy future ... done
[13:20:02.992] plan(): Setting new future strategy stack:
[13:20:02.992] run() for ‘MulticoreFuture’ ... done
[13:20:02.993] Created future:
[13:20:02.993] List of future strategies:
[13:20:02.993] 1. sequential:
[13:20:02.993]    - args: function (..., envir = parent.frame())
[13:20:02.993]    - tweaked: FALSE
[13:20:02.993]    - call: NULL
[13:20:02.994] plan(): nbrOfWorkers() = 1
[13:20:02.998] plan(): Setting new future strategy stack:
[13:20:02.998] List of future strategies:
[13:20:02.998] 1. multicore:
[13:20:02.998]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:02.998]    - tweaked: FALSE
[13:20:02.998]    - call: plan(strategy)
[13:20:03.004] plan(): nbrOfWorkers() = 2
[13:20:02.994] MulticoreFuture:
[13:20:02.994] Label: ‘future_by-1’
[13:20:02.994] Expression:
[13:20:02.994] {
[13:20:02.994]     do.call(function(...) {
[13:20:02.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:02.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:02.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:02.994]             on.exit(options(oopts), add = TRUE)
[13:20:02.994]         }
[13:20:02.994]         {
[13:20:02.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:02.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:02.994]                 ...future.FUN(...future.X_jj, ...)
[13:20:02.994]             })
[13:20:02.994]         }
[13:20:02.994]     }, args = future.call.arguments)
[13:20:02.994] }
[13:20:02.994] Lazy evaluation: FALSE
[13:20:02.994] Asynchronous evaluation: TRUE
[13:20:02.994] Local evaluation: TRUE
[13:20:02.994] Environment: R_GlobalEnv
[13:20:02.994] Capture standard output: TRUE
[13:20:02.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:02.994] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:02.994] Packages: <none>
[13:20:02.994] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:02.994] Resolved: TRUE
[13:20:02.994] Value: <not collected>
[13:20:02.994] Conditions captured: <none>
[13:20:02.994] Early signaling: FALSE
[13:20:02.994] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:02.994] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.005] Chunk #1 of 2 ... DONE
[13:20:03.005] Chunk #2 of 2 ...
[13:20:03.006]  - Finding globals in 'X' for chunk #2 ...
[13:20:03.006] getGlobalsAndPackages() ...
[13:20:03.006] Searching for globals...
[13:20:03.007] 
[13:20:03.007] Searching for globals ... DONE
[13:20:03.007] - globals: [0] <none>
[13:20:03.007] getGlobalsAndPackages() ... DONE
[13:20:03.007]    + additional globals found: [n=0] 
[13:20:03.007]    + additional namespaces needed: [n=0] 
[13:20:03.008]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:03.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.008]  - seeds: <none>
[13:20:03.008]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.008] getGlobalsAndPackages() ...
[13:20:03.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.009] Resolving globals: FALSE
[13:20:03.009] Tweak future expression to call with '...' arguments ...
[13:20:03.009] {
[13:20:03.009]     do.call(function(...) {
[13:20:03.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.009]             on.exit(options(oopts), add = TRUE)
[13:20:03.009]         }
[13:20:03.009]         {
[13:20:03.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.009]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.009]             })
[13:20:03.009]         }
[13:20:03.009]     }, args = future.call.arguments)
[13:20:03.009] }
[13:20:03.010] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.010] 
[13:20:03.011] getGlobalsAndPackages() ... DONE
[13:20:03.011] run() for ‘Future’ ...
[13:20:03.011] - state: ‘created’
[13:20:03.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.017]   - Field: ‘label’
[13:20:03.017]   - Field: ‘local’
[13:20:03.017]   - Field: ‘owner’
[13:20:03.017]   - Field: ‘envir’
[13:20:03.017]   - Field: ‘workers’
[13:20:03.017]   - Field: ‘packages’
[13:20:03.017]   - Field: ‘gc’
[13:20:03.017]   - Field: ‘job’
[13:20:03.018]   - Field: ‘conditions’
[13:20:03.018]   - Field: ‘expr’
[13:20:03.018]   - Field: ‘uuid’
[13:20:03.018]   - Field: ‘seed’
[13:20:03.018]   - Field: ‘version’
[13:20:03.018]   - Field: ‘result’
[13:20:03.019]   - Field: ‘asynchronous’
[13:20:03.019]   - Field: ‘calls’
[13:20:03.019]   - Field: ‘globals’
[13:20:03.019]   - Field: ‘stdout’
[13:20:03.019]   - Field: ‘earlySignal’
[13:20:03.019]   - Field: ‘lazy’
[13:20:03.019]   - Field: ‘state’
[13:20:03.019] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.020] - Launch lazy future ...
[13:20:03.020] Packages needed by the future expression (n = 0): <none>
[13:20:03.020] Packages needed by future strategies (n = 0): <none>
[13:20:03.021] {
[13:20:03.021]     {
[13:20:03.021]         {
[13:20:03.021]             ...future.startTime <- base::Sys.time()
[13:20:03.021]             {
[13:20:03.021]                 {
[13:20:03.021]                   {
[13:20:03.021]                     {
[13:20:03.021]                       base::local({
[13:20:03.021]                         has_future <- base::requireNamespace("future", 
[13:20:03.021]                           quietly = TRUE)
[13:20:03.021]                         if (has_future) {
[13:20:03.021]                           ns <- base::getNamespace("future")
[13:20:03.021]                           version <- ns[[".package"]][["version"]]
[13:20:03.021]                           if (is.null(version)) 
[13:20:03.021]                             version <- utils::packageVersion("future")
[13:20:03.021]                         }
[13:20:03.021]                         else {
[13:20:03.021]                           version <- NULL
[13:20:03.021]                         }
[13:20:03.021]                         if (!has_future || version < "1.8.0") {
[13:20:03.021]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.021]                             "", base::R.version$version.string), 
[13:20:03.021]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.021]                               "release", "version")], collapse = " "), 
[13:20:03.021]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.021]                             info)
[13:20:03.021]                           info <- base::paste(info, collapse = "; ")
[13:20:03.021]                           if (!has_future) {
[13:20:03.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.021]                               info)
[13:20:03.021]                           }
[13:20:03.021]                           else {
[13:20:03.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.021]                               info, version)
[13:20:03.021]                           }
[13:20:03.021]                           base::stop(msg)
[13:20:03.021]                         }
[13:20:03.021]                       })
[13:20:03.021]                     }
[13:20:03.021]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.021]                     base::options(mc.cores = 1L)
[13:20:03.021]                   }
[13:20:03.021]                   options(future.plan = NULL)
[13:20:03.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.021]                 }
[13:20:03.021]                 ...future.workdir <- getwd()
[13:20:03.021]             }
[13:20:03.021]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.021]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.021]         }
[13:20:03.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.021]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.021]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.021]             base::names(...future.oldOptions))
[13:20:03.021]     }
[13:20:03.021]     if (FALSE) {
[13:20:03.021]     }
[13:20:03.021]     else {
[13:20:03.021]         if (TRUE) {
[13:20:03.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.021]                 open = "w")
[13:20:03.021]         }
[13:20:03.021]         else {
[13:20:03.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.021]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.021]         }
[13:20:03.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.021]             base::sink(type = "output", split = FALSE)
[13:20:03.021]             base::close(...future.stdout)
[13:20:03.021]         }, add = TRUE)
[13:20:03.021]     }
[13:20:03.021]     ...future.frame <- base::sys.nframe()
[13:20:03.021]     ...future.conditions <- base::list()
[13:20:03.021]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.021]     if (FALSE) {
[13:20:03.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.021]     }
[13:20:03.021]     ...future.result <- base::tryCatch({
[13:20:03.021]         base::withCallingHandlers({
[13:20:03.021]             ...future.value <- base::withVisible(base::local({
[13:20:03.021]                 withCallingHandlers({
[13:20:03.021]                   {
[13:20:03.021]                     do.call(function(...) {
[13:20:03.021]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.021]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.021]                         ...future.globals.maxSize)) {
[13:20:03.021]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.021]                         on.exit(options(oopts), add = TRUE)
[13:20:03.021]                       }
[13:20:03.021]                       {
[13:20:03.021]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.021]                           FUN = function(jj) {
[13:20:03.021]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.021]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.021]                           })
[13:20:03.021]                       }
[13:20:03.021]                     }, args = future.call.arguments)
[13:20:03.021]                   }
[13:20:03.021]                 }, immediateCondition = function(cond) {
[13:20:03.021]                   save_rds <- function (object, pathname, ...) 
[13:20:03.021]                   {
[13:20:03.021]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.021]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.021]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.021]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.021]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.021]                         fi_tmp[["mtime"]])
[13:20:03.021]                     }
[13:20:03.021]                     tryCatch({
[13:20:03.021]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.021]                     }, error = function(ex) {
[13:20:03.021]                       msg <- conditionMessage(ex)
[13:20:03.021]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.021]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.021]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.021]                         fi_tmp[["mtime"]], msg)
[13:20:03.021]                       ex$message <- msg
[13:20:03.021]                       stop(ex)
[13:20:03.021]                     })
[13:20:03.021]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.021]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.021]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.021]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.021]                       fi <- file.info(pathname)
[13:20:03.021]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.021]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.021]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.021]                         fi[["size"]], fi[["mtime"]])
[13:20:03.021]                       stop(msg)
[13:20:03.021]                     }
[13:20:03.021]                     invisible(pathname)
[13:20:03.021]                   }
[13:20:03.021]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.021]                     rootPath = tempdir()) 
[13:20:03.021]                   {
[13:20:03.021]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.021]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.021]                       tmpdir = path, fileext = ".rds")
[13:20:03.021]                     save_rds(obj, file)
[13:20:03.021]                   }
[13:20:03.021]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.021]                   {
[13:20:03.021]                     inherits <- base::inherits
[13:20:03.021]                     invokeRestart <- base::invokeRestart
[13:20:03.021]                     is.null <- base::is.null
[13:20:03.021]                     muffled <- FALSE
[13:20:03.021]                     if (inherits(cond, "message")) {
[13:20:03.021]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.021]                       if (muffled) 
[13:20:03.021]                         invokeRestart("muffleMessage")
[13:20:03.021]                     }
[13:20:03.021]                     else if (inherits(cond, "warning")) {
[13:20:03.021]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.021]                       if (muffled) 
[13:20:03.021]                         invokeRestart("muffleWarning")
[13:20:03.021]                     }
[13:20:03.021]                     else if (inherits(cond, "condition")) {
[13:20:03.021]                       if (!is.null(pattern)) {
[13:20:03.021]                         computeRestarts <- base::computeRestarts
[13:20:03.021]                         grepl <- base::grepl
[13:20:03.021]                         restarts <- computeRestarts(cond)
[13:20:03.021]                         for (restart in restarts) {
[13:20:03.021]                           name <- restart$name
[13:20:03.021]                           if (is.null(name)) 
[13:20:03.021]                             next
[13:20:03.021]                           if (!grepl(pattern, name)) 
[13:20:03.021]                             next
[13:20:03.021]                           invokeRestart(restart)
[13:20:03.021]                           muffled <- TRUE
[13:20:03.021]                           break
[13:20:03.021]                         }
[13:20:03.021]                       }
[13:20:03.021]                     }
[13:20:03.021]                     invisible(muffled)
[13:20:03.021]                   }
[13:20:03.021]                   muffleCondition(cond)
[13:20:03.021]                 })
[13:20:03.021]             }))
[13:20:03.021]             future::FutureResult(value = ...future.value$value, 
[13:20:03.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.021]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.021]                     ...future.globalenv.names))
[13:20:03.021]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.021]         }, condition = base::local({
[13:20:03.021]             c <- base::c
[13:20:03.021]             inherits <- base::inherits
[13:20:03.021]             invokeRestart <- base::invokeRestart
[13:20:03.021]             length <- base::length
[13:20:03.021]             list <- base::list
[13:20:03.021]             seq.int <- base::seq.int
[13:20:03.021]             signalCondition <- base::signalCondition
[13:20:03.021]             sys.calls <- base::sys.calls
[13:20:03.021]             `[[` <- base::`[[`
[13:20:03.021]             `+` <- base::`+`
[13:20:03.021]             `<<-` <- base::`<<-`
[13:20:03.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.021]                   3L)]
[13:20:03.021]             }
[13:20:03.021]             function(cond) {
[13:20:03.021]                 is_error <- inherits(cond, "error")
[13:20:03.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.021]                   NULL)
[13:20:03.021]                 if (is_error) {
[13:20:03.021]                   sessionInformation <- function() {
[13:20:03.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.021]                       search = base::search(), system = base::Sys.info())
[13:20:03.021]                   }
[13:20:03.021]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.021]                     cond$call), session = sessionInformation(), 
[13:20:03.021]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.021]                   signalCondition(cond)
[13:20:03.021]                 }
[13:20:03.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.021]                 "immediateCondition"))) {
[13:20:03.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.021]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.021]                   if (TRUE && !signal) {
[13:20:03.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.021]                     {
[13:20:03.021]                       inherits <- base::inherits
[13:20:03.021]                       invokeRestart <- base::invokeRestart
[13:20:03.021]                       is.null <- base::is.null
[13:20:03.021]                       muffled <- FALSE
[13:20:03.021]                       if (inherits(cond, "message")) {
[13:20:03.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.021]                         if (muffled) 
[13:20:03.021]                           invokeRestart("muffleMessage")
[13:20:03.021]                       }
[13:20:03.021]                       else if (inherits(cond, "warning")) {
[13:20:03.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.021]                         if (muffled) 
[13:20:03.021]                           invokeRestart("muffleWarning")
[13:20:03.021]                       }
[13:20:03.021]                       else if (inherits(cond, "condition")) {
[13:20:03.021]                         if (!is.null(pattern)) {
[13:20:03.021]                           computeRestarts <- base::computeRestarts
[13:20:03.021]                           grepl <- base::grepl
[13:20:03.021]                           restarts <- computeRestarts(cond)
[13:20:03.021]                           for (restart in restarts) {
[13:20:03.021]                             name <- restart$name
[13:20:03.021]                             if (is.null(name)) 
[13:20:03.021]                               next
[13:20:03.021]                             if (!grepl(pattern, name)) 
[13:20:03.021]                               next
[13:20:03.021]                             invokeRestart(restart)
[13:20:03.021]                             muffled <- TRUE
[13:20:03.021]                             break
[13:20:03.021]                           }
[13:20:03.021]                         }
[13:20:03.021]                       }
[13:20:03.021]                       invisible(muffled)
[13:20:03.021]                     }
[13:20:03.021]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.021]                   }
[13:20:03.021]                 }
[13:20:03.021]                 else {
[13:20:03.021]                   if (TRUE) {
[13:20:03.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.021]                     {
[13:20:03.021]                       inherits <- base::inherits
[13:20:03.021]                       invokeRestart <- base::invokeRestart
[13:20:03.021]                       is.null <- base::is.null
[13:20:03.021]                       muffled <- FALSE
[13:20:03.021]                       if (inherits(cond, "message")) {
[13:20:03.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.021]                         if (muffled) 
[13:20:03.021]                           invokeRestart("muffleMessage")
[13:20:03.021]                       }
[13:20:03.021]                       else if (inherits(cond, "warning")) {
[13:20:03.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.021]                         if (muffled) 
[13:20:03.021]                           invokeRestart("muffleWarning")
[13:20:03.021]                       }
[13:20:03.021]                       else if (inherits(cond, "condition")) {
[13:20:03.021]                         if (!is.null(pattern)) {
[13:20:03.021]                           computeRestarts <- base::computeRestarts
[13:20:03.021]                           grepl <- base::grepl
[13:20:03.021]                           restarts <- computeRestarts(cond)
[13:20:03.021]                           for (restart in restarts) {
[13:20:03.021]                             name <- restart$name
[13:20:03.021]                             if (is.null(name)) 
[13:20:03.021]                               next
[13:20:03.021]                             if (!grepl(pattern, name)) 
[13:20:03.021]                               next
[13:20:03.021]                             invokeRestart(restart)
[13:20:03.021]                             muffled <- TRUE
[13:20:03.021]                             break
[13:20:03.021]                           }
[13:20:03.021]                         }
[13:20:03.021]                       }
[13:20:03.021]                       invisible(muffled)
[13:20:03.021]                     }
[13:20:03.021]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.021]                   }
[13:20:03.021]                 }
[13:20:03.021]             }
[13:20:03.021]         }))
[13:20:03.021]     }, error = function(ex) {
[13:20:03.021]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.021]                 ...future.rng), started = ...future.startTime, 
[13:20:03.021]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.021]             version = "1.8"), class = "FutureResult")
[13:20:03.021]     }, finally = {
[13:20:03.021]         if (!identical(...future.workdir, getwd())) 
[13:20:03.021]             setwd(...future.workdir)
[13:20:03.021]         {
[13:20:03.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.021]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.021]             }
[13:20:03.021]             base::options(...future.oldOptions)
[13:20:03.021]             if (.Platform$OS.type == "windows") {
[13:20:03.021]                 old_names <- names(...future.oldEnvVars)
[13:20:03.021]                 envs <- base::Sys.getenv()
[13:20:03.021]                 names <- names(envs)
[13:20:03.021]                 common <- intersect(names, old_names)
[13:20:03.021]                 added <- setdiff(names, old_names)
[13:20:03.021]                 removed <- setdiff(old_names, names)
[13:20:03.021]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.021]                   envs[common]]
[13:20:03.021]                 NAMES <- toupper(changed)
[13:20:03.021]                 args <- list()
[13:20:03.021]                 for (kk in seq_along(NAMES)) {
[13:20:03.021]                   name <- changed[[kk]]
[13:20:03.021]                   NAME <- NAMES[[kk]]
[13:20:03.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.021]                     next
[13:20:03.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.021]                 }
[13:20:03.021]                 NAMES <- toupper(added)
[13:20:03.021]                 for (kk in seq_along(NAMES)) {
[13:20:03.021]                   name <- added[[kk]]
[13:20:03.021]                   NAME <- NAMES[[kk]]
[13:20:03.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.021]                     next
[13:20:03.021]                   args[[name]] <- ""
[13:20:03.021]                 }
[13:20:03.021]                 NAMES <- toupper(removed)
[13:20:03.021]                 for (kk in seq_along(NAMES)) {
[13:20:03.021]                   name <- removed[[kk]]
[13:20:03.021]                   NAME <- NAMES[[kk]]
[13:20:03.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.021]                     next
[13:20:03.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.021]                 }
[13:20:03.021]                 if (length(args) > 0) 
[13:20:03.021]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.021]             }
[13:20:03.021]             else {
[13:20:03.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.021]             }
[13:20:03.021]             {
[13:20:03.021]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.021]                   0L) {
[13:20:03.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.021]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.021]                   base::options(opts)
[13:20:03.021]                 }
[13:20:03.021]                 {
[13:20:03.021]                   {
[13:20:03.021]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.021]                     NULL
[13:20:03.021]                   }
[13:20:03.021]                   options(future.plan = NULL)
[13:20:03.021]                   if (is.na(NA_character_)) 
[13:20:03.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.021]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.021]                     envir = parent.frame()) 
[13:20:03.021]                   {
[13:20:03.021]                     default_workers <- missing(workers)
[13:20:03.021]                     if (is.function(workers)) 
[13:20:03.021]                       workers <- workers()
[13:20:03.021]                     workers <- structure(as.integer(workers), 
[13:20:03.021]                       class = class(workers))
[13:20:03.021]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.021]                       1L)
[13:20:03.021]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.021]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.021]                       if (default_workers) 
[13:20:03.021]                         supportsMulticore(warn = TRUE)
[13:20:03.021]                       return(sequential(..., envir = envir))
[13:20:03.021]                     }
[13:20:03.021]                     oopts <- options(mc.cores = workers)
[13:20:03.021]                     on.exit(options(oopts))
[13:20:03.021]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.021]                       envir = envir)
[13:20:03.021]                     if (!future$lazy) 
[13:20:03.021]                       future <- run(future)
[13:20:03.021]                     invisible(future)
[13:20:03.021]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.021]                 }
[13:20:03.021]             }
[13:20:03.021]         }
[13:20:03.021]     })
[13:20:03.021]     if (TRUE) {
[13:20:03.021]         base::sink(type = "output", split = FALSE)
[13:20:03.021]         if (TRUE) {
[13:20:03.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.021]         }
[13:20:03.021]         else {
[13:20:03.021]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.021]         }
[13:20:03.021]         base::close(...future.stdout)
[13:20:03.021]         ...future.stdout <- NULL
[13:20:03.021]     }
[13:20:03.021]     ...future.result$conditions <- ...future.conditions
[13:20:03.021]     ...future.result$finished <- base::Sys.time()
[13:20:03.021]     ...future.result
[13:20:03.021] }
[13:20:03.024] assign_globals() ...
[13:20:03.024] List of 5
[13:20:03.024]  $ ...future.FUN            :function (object, ...)  
[13:20:03.024]  $ future.call.arguments    : list()
[13:20:03.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.024]  $ ...future.elements_ii    :List of 2
[13:20:03.024]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:03.024]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:03.024]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.024]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:20:03.024]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:03.024]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.024]  $ ...future.seeds_ii       : NULL
[13:20:03.024]  $ ...future.globals.maxSize: NULL
[13:20:03.024]  - attr(*, "where")=List of 5
[13:20:03.024]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.024]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.024]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.024]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.024]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.024]  - attr(*, "resolved")= logi FALSE
[13:20:03.024]  - attr(*, "total_size")= num 1240
[13:20:03.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.024]  - attr(*, "already-done")= logi TRUE
[13:20:03.037] - copied ‘...future.FUN’ to environment
[13:20:03.038] - copied ‘future.call.arguments’ to environment
[13:20:03.038] - copied ‘...future.elements_ii’ to environment
[13:20:03.038] - copied ‘...future.seeds_ii’ to environment
[13:20:03.038] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.038] assign_globals() ... done
[13:20:03.038] requestCore(): workers = 2
[13:20:03.043] MulticoreFuture started
[13:20:03.044] - Launch lazy future ... done
[13:20:03.044] run() for ‘MulticoreFuture’ ... done
[13:20:03.044] Created future:
[13:20:03.044] plan(): Setting new future strategy stack:
[13:20:03.045] List of future strategies:
[13:20:03.045] 1. sequential:
[13:20:03.045]    - args: function (..., envir = parent.frame())
[13:20:03.045]    - tweaked: FALSE
[13:20:03.045]    - call: NULL
[13:20:03.046] plan(): nbrOfWorkers() = 1
[13:20:03.050] plan(): Setting new future strategy stack:
[13:20:03.050] List of future strategies:
[13:20:03.050] 1. multicore:
[13:20:03.050]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.050]    - tweaked: FALSE
[13:20:03.050]    - call: plan(strategy)
[13:20:03.055] plan(): nbrOfWorkers() = 2
[13:20:03.044] MulticoreFuture:
[13:20:03.044] Label: ‘future_by-2’
[13:20:03.044] Expression:
[13:20:03.044] {
[13:20:03.044]     do.call(function(...) {
[13:20:03.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.044]             on.exit(options(oopts), add = TRUE)
[13:20:03.044]         }
[13:20:03.044]         {
[13:20:03.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.044]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.044]             })
[13:20:03.044]         }
[13:20:03.044]     }, args = future.call.arguments)
[13:20:03.044] }
[13:20:03.044] Lazy evaluation: FALSE
[13:20:03.044] Asynchronous evaluation: TRUE
[13:20:03.044] Local evaluation: TRUE
[13:20:03.044] Environment: R_GlobalEnv
[13:20:03.044] Capture standard output: TRUE
[13:20:03.044] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.044] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.044] Packages: <none>
[13:20:03.044] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.044] Resolved: TRUE
[13:20:03.044] Value: <not collected>
[13:20:03.044] Conditions captured: <none>
[13:20:03.044] Early signaling: FALSE
[13:20:03.044] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.044] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.057] Chunk #2 of 2 ... DONE
[13:20:03.057] Launching 2 futures (chunks) ... DONE
[13:20:03.057] Resolving 2 futures (chunks) ...
[13:20:03.057] resolve() on list ...
[13:20:03.057]  recursive: 0
[13:20:03.057]  length: 2
[13:20:03.058] 
[13:20:03.058] Future #1
[13:20:03.059] result() for MulticoreFuture ...
[13:20:03.061] result() for MulticoreFuture ...
[13:20:03.061] result() for MulticoreFuture ... done
[13:20:03.061] result() for MulticoreFuture ... done
[13:20:03.061] result() for MulticoreFuture ...
[13:20:03.061] result() for MulticoreFuture ... done
[13:20:03.061] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:03.061] - nx: 2
[13:20:03.062] - relay: TRUE
[13:20:03.062] - stdout: TRUE
[13:20:03.062] - signal: TRUE
[13:20:03.062] - resignal: FALSE
[13:20:03.062] - force: TRUE
[13:20:03.062] - relayed: [n=2] FALSE, FALSE
[13:20:03.062] - queued futures: [n=2] FALSE, FALSE
[13:20:03.063]  - until=1
[13:20:03.063]  - relaying element #1
[13:20:03.063] result() for MulticoreFuture ...
[13:20:03.063] result() for MulticoreFuture ... done
[13:20:03.063] result() for MulticoreFuture ...
[13:20:03.063] result() for MulticoreFuture ... done
[13:20:03.064] result() for MulticoreFuture ...
[13:20:03.064] result() for MulticoreFuture ... done
[13:20:03.064] result() for MulticoreFuture ...
[13:20:03.064] result() for MulticoreFuture ... done
[13:20:03.064] - relayed: [n=2] TRUE, FALSE
[13:20:03.064] - queued futures: [n=2] TRUE, FALSE
[13:20:03.065] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:03.065]  length: 1 (resolved future 1)
[13:20:03.065] Future #2
[13:20:03.065] result() for MulticoreFuture ...
[13:20:03.066] result() for MulticoreFuture ...
[13:20:03.066] result() for MulticoreFuture ... done
[13:20:03.066] result() for MulticoreFuture ... done
[13:20:03.066] result() for MulticoreFuture ...
[13:20:03.067] result() for MulticoreFuture ... done
[13:20:03.067] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:03.067] - nx: 2
[13:20:03.067] - relay: TRUE
[13:20:03.067] - stdout: TRUE
[13:20:03.067] - signal: TRUE
[13:20:03.067] - resignal: FALSE
[13:20:03.067] - force: TRUE
[13:20:03.068] - relayed: [n=2] TRUE, FALSE
[13:20:03.068] - queued futures: [n=2] TRUE, FALSE
[13:20:03.068]  - until=2
[13:20:03.068]  - relaying element #2
[13:20:03.068] result() for MulticoreFuture ...
[13:20:03.068] result() for MulticoreFuture ... done
[13:20:03.068] result() for MulticoreFuture ...
[13:20:03.069] result() for MulticoreFuture ... done
[13:20:03.069] result() for MulticoreFuture ...
[13:20:03.069] result() for MulticoreFuture ... done
[13:20:03.069] result() for MulticoreFuture ...
[13:20:03.069] result() for MulticoreFuture ... done
[13:20:03.069] - relayed: [n=2] TRUE, TRUE
[13:20:03.069] - queued futures: [n=2] TRUE, TRUE
[13:20:03.069] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:03.069]  length: 0 (resolved future 2)
[13:20:03.070] Relaying remaining futures
[13:20:03.070] signalConditionsASAP(NULL, pos=0) ...
[13:20:03.070] - nx: 2
[13:20:03.070] - relay: TRUE
[13:20:03.070] - stdout: TRUE
[13:20:03.070] - signal: TRUE
[13:20:03.070] - resignal: FALSE
[13:20:03.070] - force: TRUE
[13:20:03.076] - relayed: [n=2] TRUE, TRUE
[13:20:03.076] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:03.076] - relayed: [n=2] TRUE, TRUE
[13:20:03.076] - queued futures: [n=2] TRUE, TRUE
[13:20:03.076] signalConditionsASAP(NULL, pos=0) ... done
[13:20:03.076] resolve() on list ... DONE
[13:20:03.077] result() for MulticoreFuture ...
[13:20:03.077] result() for MulticoreFuture ... done
[13:20:03.077] result() for MulticoreFuture ...
[13:20:03.077] result() for MulticoreFuture ... done
[13:20:03.077] result() for MulticoreFuture ...
[13:20:03.077] result() for MulticoreFuture ... done
[13:20:03.077] result() for MulticoreFuture ...
[13:20:03.077] result() for MulticoreFuture ... done
[13:20:03.078]  - Number of value chunks collected: 2
[13:20:03.078] Resolving 2 futures (chunks) ... DONE
[13:20:03.078] Reducing values from 2 chunks ...
[13:20:03.078]  - Number of values collected after concatenation: 3
[13:20:03.078]  - Number of values expected: 3
[13:20:03.078] Reducing values from 2 chunks ... DONE
[13:20:03.078] future_lapply() ... DONE
[13:20:03.079] future_by_internal() ... DONE
[13:20:03.079] future_by_internal() ...
[13:20:03.079] future_lapply() ...
[13:20:03.085] Number of chunks: 2
[13:20:03.085] getGlobalsAndPackagesXApply() ...
[13:20:03.085]  - future.globals: TRUE
[13:20:03.085] getGlobalsAndPackages() ...
[13:20:03.086] Searching for globals...
[13:20:03.087] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:03.087] Searching for globals ... DONE
[13:20:03.088] Resolving globals: FALSE
[13:20:03.088] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:03.088] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:03.089] - globals: [1] ‘FUN’
[13:20:03.089] 
[13:20:03.089] getGlobalsAndPackages() ... DONE
[13:20:03.089]  - globals found/used: [n=1] ‘FUN’
[13:20:03.089]  - needed namespaces: [n=0] 
[13:20:03.089] Finding globals ... DONE
[13:20:03.089]  - use_args: TRUE
[13:20:03.089]  - Getting '...' globals ...
[13:20:03.090] resolve() on list ...
[13:20:03.090]  recursive: 0
[13:20:03.090]  length: 1
[13:20:03.090]  elements: ‘...’
[13:20:03.090]  length: 0 (resolved future 1)
[13:20:03.090] resolve() on list ... DONE
[13:20:03.090]    - '...' content: [n=1] ‘digits’
[13:20:03.090] List of 1
[13:20:03.090]  $ ...:List of 1
[13:20:03.090]   ..$ digits: int 2
[13:20:03.090]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.090]  - attr(*, "where")=List of 1
[13:20:03.090]   ..$ ...:<environment: 0x55aceeb10930> 
[13:20:03.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.090]  - attr(*, "resolved")= logi TRUE
[13:20:03.090]  - attr(*, "total_size")= num NA
[13:20:03.094]  - Getting '...' globals ... DONE
[13:20:03.094] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:03.094] List of 2
[13:20:03.094]  $ ...future.FUN:function (object, ...)  
[13:20:03.094]  $ ...          :List of 1
[13:20:03.094]   ..$ digits: int 2
[13:20:03.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.094]  - attr(*, "where")=List of 2
[13:20:03.094]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:03.094]   ..$ ...          :<environment: 0x55aceeb10930> 
[13:20:03.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.094]  - attr(*, "resolved")= logi FALSE
[13:20:03.094]  - attr(*, "total_size")= num 1296
[13:20:03.097] Packages to be attached in all futures: [n=0] 
[13:20:03.097] getGlobalsAndPackagesXApply() ... DONE
[13:20:03.097] Number of futures (= number of chunks): 2
[13:20:03.098] Launching 2 futures (chunks) ...
[13:20:03.098] Chunk #1 of 2 ...
[13:20:03.098]  - Finding globals in 'X' for chunk #1 ...
[13:20:03.098] getGlobalsAndPackages() ...
[13:20:03.098] Searching for globals...
[13:20:03.098] 
[13:20:03.098] Searching for globals ... DONE
[13:20:03.098] - globals: [0] <none>
[13:20:03.099] getGlobalsAndPackages() ... DONE
[13:20:03.099]    + additional globals found: [n=0] 
[13:20:03.099]    + additional namespaces needed: [n=0] 
[13:20:03.099]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:03.099]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.099]  - seeds: <none>
[13:20:03.099]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.099] getGlobalsAndPackages() ...
[13:20:03.099] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.099] Resolving globals: FALSE
[13:20:03.100] Tweak future expression to call with '...' arguments ...
[13:20:03.100] {
[13:20:03.100]     do.call(function(...) {
[13:20:03.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.100]             on.exit(options(oopts), add = TRUE)
[13:20:03.100]         }
[13:20:03.100]         {
[13:20:03.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.100]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.100]             })
[13:20:03.100]         }
[13:20:03.100]     }, args = future.call.arguments)
[13:20:03.100] }
[13:20:03.100] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.100] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.102] 
[13:20:03.102] getGlobalsAndPackages() ... DONE
[13:20:03.103] run() for ‘Future’ ...
[13:20:03.103] - state: ‘created’
[13:20:03.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.107] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.107]   - Field: ‘label’
[13:20:03.108]   - Field: ‘local’
[13:20:03.108]   - Field: ‘owner’
[13:20:03.108]   - Field: ‘envir’
[13:20:03.108]   - Field: ‘workers’
[13:20:03.108]   - Field: ‘packages’
[13:20:03.108]   - Field: ‘gc’
[13:20:03.108]   - Field: ‘job’
[13:20:03.108]   - Field: ‘conditions’
[13:20:03.108]   - Field: ‘expr’
[13:20:03.109]   - Field: ‘uuid’
[13:20:03.109]   - Field: ‘seed’
[13:20:03.109]   - Field: ‘version’
[13:20:03.109]   - Field: ‘result’
[13:20:03.109]   - Field: ‘asynchronous’
[13:20:03.109]   - Field: ‘calls’
[13:20:03.109]   - Field: ‘globals’
[13:20:03.109]   - Field: ‘stdout’
[13:20:03.110]   - Field: ‘earlySignal’
[13:20:03.110]   - Field: ‘lazy’
[13:20:03.110]   - Field: ‘state’
[13:20:03.110] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.110] - Launch lazy future ...
[13:20:03.110] Packages needed by the future expression (n = 0): <none>
[13:20:03.110] Packages needed by future strategies (n = 0): <none>
[13:20:03.111] {
[13:20:03.111]     {
[13:20:03.111]         {
[13:20:03.111]             ...future.startTime <- base::Sys.time()
[13:20:03.111]             {
[13:20:03.111]                 {
[13:20:03.111]                   {
[13:20:03.111]                     {
[13:20:03.111]                       base::local({
[13:20:03.111]                         has_future <- base::requireNamespace("future", 
[13:20:03.111]                           quietly = TRUE)
[13:20:03.111]                         if (has_future) {
[13:20:03.111]                           ns <- base::getNamespace("future")
[13:20:03.111]                           version <- ns[[".package"]][["version"]]
[13:20:03.111]                           if (is.null(version)) 
[13:20:03.111]                             version <- utils::packageVersion("future")
[13:20:03.111]                         }
[13:20:03.111]                         else {
[13:20:03.111]                           version <- NULL
[13:20:03.111]                         }
[13:20:03.111]                         if (!has_future || version < "1.8.0") {
[13:20:03.111]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.111]                             "", base::R.version$version.string), 
[13:20:03.111]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.111]                               "release", "version")], collapse = " "), 
[13:20:03.111]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.111]                             info)
[13:20:03.111]                           info <- base::paste(info, collapse = "; ")
[13:20:03.111]                           if (!has_future) {
[13:20:03.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.111]                               info)
[13:20:03.111]                           }
[13:20:03.111]                           else {
[13:20:03.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.111]                               info, version)
[13:20:03.111]                           }
[13:20:03.111]                           base::stop(msg)
[13:20:03.111]                         }
[13:20:03.111]                       })
[13:20:03.111]                     }
[13:20:03.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.111]                     base::options(mc.cores = 1L)
[13:20:03.111]                   }
[13:20:03.111]                   options(future.plan = NULL)
[13:20:03.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.111]                 }
[13:20:03.111]                 ...future.workdir <- getwd()
[13:20:03.111]             }
[13:20:03.111]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.111]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.111]         }
[13:20:03.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.111]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.111]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.111]             base::names(...future.oldOptions))
[13:20:03.111]     }
[13:20:03.111]     if (FALSE) {
[13:20:03.111]     }
[13:20:03.111]     else {
[13:20:03.111]         if (TRUE) {
[13:20:03.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.111]                 open = "w")
[13:20:03.111]         }
[13:20:03.111]         else {
[13:20:03.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.111]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.111]         }
[13:20:03.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.111]             base::sink(type = "output", split = FALSE)
[13:20:03.111]             base::close(...future.stdout)
[13:20:03.111]         }, add = TRUE)
[13:20:03.111]     }
[13:20:03.111]     ...future.frame <- base::sys.nframe()
[13:20:03.111]     ...future.conditions <- base::list()
[13:20:03.111]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.111]     if (FALSE) {
[13:20:03.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.111]     }
[13:20:03.111]     ...future.result <- base::tryCatch({
[13:20:03.111]         base::withCallingHandlers({
[13:20:03.111]             ...future.value <- base::withVisible(base::local({
[13:20:03.111]                 withCallingHandlers({
[13:20:03.111]                   {
[13:20:03.111]                     do.call(function(...) {
[13:20:03.111]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.111]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.111]                         ...future.globals.maxSize)) {
[13:20:03.111]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.111]                         on.exit(options(oopts), add = TRUE)
[13:20:03.111]                       }
[13:20:03.111]                       {
[13:20:03.111]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.111]                           FUN = function(jj) {
[13:20:03.111]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.111]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.111]                           })
[13:20:03.111]                       }
[13:20:03.111]                     }, args = future.call.arguments)
[13:20:03.111]                   }
[13:20:03.111]                 }, immediateCondition = function(cond) {
[13:20:03.111]                   save_rds <- function (object, pathname, ...) 
[13:20:03.111]                   {
[13:20:03.111]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.111]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.111]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.111]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.111]                         fi_tmp[["mtime"]])
[13:20:03.111]                     }
[13:20:03.111]                     tryCatch({
[13:20:03.111]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.111]                     }, error = function(ex) {
[13:20:03.111]                       msg <- conditionMessage(ex)
[13:20:03.111]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.111]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.111]                         fi_tmp[["mtime"]], msg)
[13:20:03.111]                       ex$message <- msg
[13:20:03.111]                       stop(ex)
[13:20:03.111]                     })
[13:20:03.111]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.111]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.111]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.111]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.111]                       fi <- file.info(pathname)
[13:20:03.111]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.111]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.111]                         fi[["size"]], fi[["mtime"]])
[13:20:03.111]                       stop(msg)
[13:20:03.111]                     }
[13:20:03.111]                     invisible(pathname)
[13:20:03.111]                   }
[13:20:03.111]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.111]                     rootPath = tempdir()) 
[13:20:03.111]                   {
[13:20:03.111]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.111]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.111]                       tmpdir = path, fileext = ".rds")
[13:20:03.111]                     save_rds(obj, file)
[13:20:03.111]                   }
[13:20:03.111]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.111]                   {
[13:20:03.111]                     inherits <- base::inherits
[13:20:03.111]                     invokeRestart <- base::invokeRestart
[13:20:03.111]                     is.null <- base::is.null
[13:20:03.111]                     muffled <- FALSE
[13:20:03.111]                     if (inherits(cond, "message")) {
[13:20:03.111]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.111]                       if (muffled) 
[13:20:03.111]                         invokeRestart("muffleMessage")
[13:20:03.111]                     }
[13:20:03.111]                     else if (inherits(cond, "warning")) {
[13:20:03.111]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.111]                       if (muffled) 
[13:20:03.111]                         invokeRestart("muffleWarning")
[13:20:03.111]                     }
[13:20:03.111]                     else if (inherits(cond, "condition")) {
[13:20:03.111]                       if (!is.null(pattern)) {
[13:20:03.111]                         computeRestarts <- base::computeRestarts
[13:20:03.111]                         grepl <- base::grepl
[13:20:03.111]                         restarts <- computeRestarts(cond)
[13:20:03.111]                         for (restart in restarts) {
[13:20:03.111]                           name <- restart$name
[13:20:03.111]                           if (is.null(name)) 
[13:20:03.111]                             next
[13:20:03.111]                           if (!grepl(pattern, name)) 
[13:20:03.111]                             next
[13:20:03.111]                           invokeRestart(restart)
[13:20:03.111]                           muffled <- TRUE
[13:20:03.111]                           break
[13:20:03.111]                         }
[13:20:03.111]                       }
[13:20:03.111]                     }
[13:20:03.111]                     invisible(muffled)
[13:20:03.111]                   }
[13:20:03.111]                   muffleCondition(cond)
[13:20:03.111]                 })
[13:20:03.111]             }))
[13:20:03.111]             future::FutureResult(value = ...future.value$value, 
[13:20:03.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.111]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.111]                     ...future.globalenv.names))
[13:20:03.111]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.111]         }, condition = base::local({
[13:20:03.111]             c <- base::c
[13:20:03.111]             inherits <- base::inherits
[13:20:03.111]             invokeRestart <- base::invokeRestart
[13:20:03.111]             length <- base::length
[13:20:03.111]             list <- base::list
[13:20:03.111]             seq.int <- base::seq.int
[13:20:03.111]             signalCondition <- base::signalCondition
[13:20:03.111]             sys.calls <- base::sys.calls
[13:20:03.111]             `[[` <- base::`[[`
[13:20:03.111]             `+` <- base::`+`
[13:20:03.111]             `<<-` <- base::`<<-`
[13:20:03.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.111]                   3L)]
[13:20:03.111]             }
[13:20:03.111]             function(cond) {
[13:20:03.111]                 is_error <- inherits(cond, "error")
[13:20:03.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.111]                   NULL)
[13:20:03.111]                 if (is_error) {
[13:20:03.111]                   sessionInformation <- function() {
[13:20:03.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.111]                       search = base::search(), system = base::Sys.info())
[13:20:03.111]                   }
[13:20:03.111]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.111]                     cond$call), session = sessionInformation(), 
[13:20:03.111]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.111]                   signalCondition(cond)
[13:20:03.111]                 }
[13:20:03.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.111]                 "immediateCondition"))) {
[13:20:03.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.111]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.111]                   if (TRUE && !signal) {
[13:20:03.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.111]                     {
[13:20:03.111]                       inherits <- base::inherits
[13:20:03.111]                       invokeRestart <- base::invokeRestart
[13:20:03.111]                       is.null <- base::is.null
[13:20:03.111]                       muffled <- FALSE
[13:20:03.111]                       if (inherits(cond, "message")) {
[13:20:03.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.111]                         if (muffled) 
[13:20:03.111]                           invokeRestart("muffleMessage")
[13:20:03.111]                       }
[13:20:03.111]                       else if (inherits(cond, "warning")) {
[13:20:03.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.111]                         if (muffled) 
[13:20:03.111]                           invokeRestart("muffleWarning")
[13:20:03.111]                       }
[13:20:03.111]                       else if (inherits(cond, "condition")) {
[13:20:03.111]                         if (!is.null(pattern)) {
[13:20:03.111]                           computeRestarts <- base::computeRestarts
[13:20:03.111]                           grepl <- base::grepl
[13:20:03.111]                           restarts <- computeRestarts(cond)
[13:20:03.111]                           for (restart in restarts) {
[13:20:03.111]                             name <- restart$name
[13:20:03.111]                             if (is.null(name)) 
[13:20:03.111]                               next
[13:20:03.111]                             if (!grepl(pattern, name)) 
[13:20:03.111]                               next
[13:20:03.111]                             invokeRestart(restart)
[13:20:03.111]                             muffled <- TRUE
[13:20:03.111]                             break
[13:20:03.111]                           }
[13:20:03.111]                         }
[13:20:03.111]                       }
[13:20:03.111]                       invisible(muffled)
[13:20:03.111]                     }
[13:20:03.111]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.111]                   }
[13:20:03.111]                 }
[13:20:03.111]                 else {
[13:20:03.111]                   if (TRUE) {
[13:20:03.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.111]                     {
[13:20:03.111]                       inherits <- base::inherits
[13:20:03.111]                       invokeRestart <- base::invokeRestart
[13:20:03.111]                       is.null <- base::is.null
[13:20:03.111]                       muffled <- FALSE
[13:20:03.111]                       if (inherits(cond, "message")) {
[13:20:03.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.111]                         if (muffled) 
[13:20:03.111]                           invokeRestart("muffleMessage")
[13:20:03.111]                       }
[13:20:03.111]                       else if (inherits(cond, "warning")) {
[13:20:03.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.111]                         if (muffled) 
[13:20:03.111]                           invokeRestart("muffleWarning")
[13:20:03.111]                       }
[13:20:03.111]                       else if (inherits(cond, "condition")) {
[13:20:03.111]                         if (!is.null(pattern)) {
[13:20:03.111]                           computeRestarts <- base::computeRestarts
[13:20:03.111]                           grepl <- base::grepl
[13:20:03.111]                           restarts <- computeRestarts(cond)
[13:20:03.111]                           for (restart in restarts) {
[13:20:03.111]                             name <- restart$name
[13:20:03.111]                             if (is.null(name)) 
[13:20:03.111]                               next
[13:20:03.111]                             if (!grepl(pattern, name)) 
[13:20:03.111]                               next
[13:20:03.111]                             invokeRestart(restart)
[13:20:03.111]                             muffled <- TRUE
[13:20:03.111]                             break
[13:20:03.111]                           }
[13:20:03.111]                         }
[13:20:03.111]                       }
[13:20:03.111]                       invisible(muffled)
[13:20:03.111]                     }
[13:20:03.111]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.111]                   }
[13:20:03.111]                 }
[13:20:03.111]             }
[13:20:03.111]         }))
[13:20:03.111]     }, error = function(ex) {
[13:20:03.111]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.111]                 ...future.rng), started = ...future.startTime, 
[13:20:03.111]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.111]             version = "1.8"), class = "FutureResult")
[13:20:03.111]     }, finally = {
[13:20:03.111]         if (!identical(...future.workdir, getwd())) 
[13:20:03.111]             setwd(...future.workdir)
[13:20:03.111]         {
[13:20:03.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.111]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.111]             }
[13:20:03.111]             base::options(...future.oldOptions)
[13:20:03.111]             if (.Platform$OS.type == "windows") {
[13:20:03.111]                 old_names <- names(...future.oldEnvVars)
[13:20:03.111]                 envs <- base::Sys.getenv()
[13:20:03.111]                 names <- names(envs)
[13:20:03.111]                 common <- intersect(names, old_names)
[13:20:03.111]                 added <- setdiff(names, old_names)
[13:20:03.111]                 removed <- setdiff(old_names, names)
[13:20:03.111]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.111]                   envs[common]]
[13:20:03.111]                 NAMES <- toupper(changed)
[13:20:03.111]                 args <- list()
[13:20:03.111]                 for (kk in seq_along(NAMES)) {
[13:20:03.111]                   name <- changed[[kk]]
[13:20:03.111]                   NAME <- NAMES[[kk]]
[13:20:03.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.111]                     next
[13:20:03.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.111]                 }
[13:20:03.111]                 NAMES <- toupper(added)
[13:20:03.111]                 for (kk in seq_along(NAMES)) {
[13:20:03.111]                   name <- added[[kk]]
[13:20:03.111]                   NAME <- NAMES[[kk]]
[13:20:03.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.111]                     next
[13:20:03.111]                   args[[name]] <- ""
[13:20:03.111]                 }
[13:20:03.111]                 NAMES <- toupper(removed)
[13:20:03.111]                 for (kk in seq_along(NAMES)) {
[13:20:03.111]                   name <- removed[[kk]]
[13:20:03.111]                   NAME <- NAMES[[kk]]
[13:20:03.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.111]                     next
[13:20:03.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.111]                 }
[13:20:03.111]                 if (length(args) > 0) 
[13:20:03.111]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.111]             }
[13:20:03.111]             else {
[13:20:03.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.111]             }
[13:20:03.111]             {
[13:20:03.111]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.111]                   0L) {
[13:20:03.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.111]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.111]                   base::options(opts)
[13:20:03.111]                 }
[13:20:03.111]                 {
[13:20:03.111]                   {
[13:20:03.111]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.111]                     NULL
[13:20:03.111]                   }
[13:20:03.111]                   options(future.plan = NULL)
[13:20:03.111]                   if (is.na(NA_character_)) 
[13:20:03.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.111]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.111]                     envir = parent.frame()) 
[13:20:03.111]                   {
[13:20:03.111]                     default_workers <- missing(workers)
[13:20:03.111]                     if (is.function(workers)) 
[13:20:03.111]                       workers <- workers()
[13:20:03.111]                     workers <- structure(as.integer(workers), 
[13:20:03.111]                       class = class(workers))
[13:20:03.111]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.111]                       1L)
[13:20:03.111]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.111]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.111]                       if (default_workers) 
[13:20:03.111]                         supportsMulticore(warn = TRUE)
[13:20:03.111]                       return(sequential(..., envir = envir))
[13:20:03.111]                     }
[13:20:03.111]                     oopts <- options(mc.cores = workers)
[13:20:03.111]                     on.exit(options(oopts))
[13:20:03.111]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.111]                       envir = envir)
[13:20:03.111]                     if (!future$lazy) 
[13:20:03.111]                       future <- run(future)
[13:20:03.111]                     invisible(future)
[13:20:03.111]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.111]                 }
[13:20:03.111]             }
[13:20:03.111]         }
[13:20:03.111]     })
[13:20:03.111]     if (TRUE) {
[13:20:03.111]         base::sink(type = "output", split = FALSE)
[13:20:03.111]         if (TRUE) {
[13:20:03.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.111]         }
[13:20:03.111]         else {
[13:20:03.111]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.111]         }
[13:20:03.111]         base::close(...future.stdout)
[13:20:03.111]         ...future.stdout <- NULL
[13:20:03.111]     }
[13:20:03.111]     ...future.result$conditions <- ...future.conditions
[13:20:03.111]     ...future.result$finished <- base::Sys.time()
[13:20:03.111]     ...future.result
[13:20:03.111] }
[13:20:03.114] assign_globals() ...
[13:20:03.114] List of 5
[13:20:03.114]  $ ...future.FUN            :function (object, ...)  
[13:20:03.114]  $ future.call.arguments    :List of 1
[13:20:03.114]   ..$ digits: int 2
[13:20:03.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.114]  $ ...future.elements_ii    :List of 3
[13:20:03.114]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:20:03.114]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:20:03.114]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:20:03.114]  $ ...future.seeds_ii       : NULL
[13:20:03.114]  $ ...future.globals.maxSize: NULL
[13:20:03.114]  - attr(*, "where")=List of 5
[13:20:03.114]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.114]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.114]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.114]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.114]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.114]  - attr(*, "resolved")= logi FALSE
[13:20:03.114]  - attr(*, "total_size")= num 1296
[13:20:03.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.114]  - attr(*, "already-done")= logi TRUE
[13:20:03.120] - copied ‘...future.FUN’ to environment
[13:20:03.120] - copied ‘future.call.arguments’ to environment
[13:20:03.120] - copied ‘...future.elements_ii’ to environment
[13:20:03.120] - copied ‘...future.seeds_ii’ to environment
[13:20:03.120] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.120] assign_globals() ... done
[13:20:03.120] requestCore(): workers = 2
[13:20:03.122] MulticoreFuture started
[13:20:03.123] - Launch lazy future ... done
[13:20:03.123] run() for ‘MulticoreFuture’ ... done
[13:20:03.123] Created future:
[13:20:03.124] plan(): Setting new future strategy stack:
[13:20:03.124] List of future strategies:
[13:20:03.124] 1. sequential:
[13:20:03.124]    - args: function (..., envir = parent.frame())
[13:20:03.124]    - tweaked: FALSE
[13:20:03.124]    - call: NULL
[13:20:03.125] plan(): nbrOfWorkers() = 1
[13:20:03.127] plan(): Setting new future strategy stack:
[13:20:03.128] List of future strategies:
[13:20:03.128] 1. multicore:
[13:20:03.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.128]    - tweaked: FALSE
[13:20:03.128]    - call: plan(strategy)
[13:20:03.133] plan(): nbrOfWorkers() = 2
[13:20:03.124] MulticoreFuture:
[13:20:03.124] Label: ‘future_by-1’
[13:20:03.124] Expression:
[13:20:03.124] {
[13:20:03.124]     do.call(function(...) {
[13:20:03.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.124]             on.exit(options(oopts), add = TRUE)
[13:20:03.124]         }
[13:20:03.124]         {
[13:20:03.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.124]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.124]             })
[13:20:03.124]         }
[13:20:03.124]     }, args = future.call.arguments)
[13:20:03.124] }
[13:20:03.124] Lazy evaluation: FALSE
[13:20:03.124] Asynchronous evaluation: TRUE
[13:20:03.124] Local evaluation: TRUE
[13:20:03.124] Environment: R_GlobalEnv
[13:20:03.124] Capture standard output: TRUE
[13:20:03.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.124] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.124] Packages: <none>
[13:20:03.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.124] Resolved: TRUE
[13:20:03.124] Value: <not collected>
[13:20:03.124] Conditions captured: <none>
[13:20:03.124] Early signaling: FALSE
[13:20:03.124] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.124] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.134] Chunk #1 of 2 ... DONE
[13:20:03.134] Chunk #2 of 2 ...
[13:20:03.134]  - Finding globals in 'X' for chunk #2 ...
[13:20:03.135] getGlobalsAndPackages() ...
[13:20:03.135] Searching for globals...
[13:20:03.135] 
[13:20:03.135] Searching for globals ... DONE
[13:20:03.136] - globals: [0] <none>
[13:20:03.136] getGlobalsAndPackages() ... DONE
[13:20:03.136]    + additional globals found: [n=0] 
[13:20:03.136]    + additional namespaces needed: [n=0] 
[13:20:03.136]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:03.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.136]  - seeds: <none>
[13:20:03.136]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.137] getGlobalsAndPackages() ...
[13:20:03.137] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.137] Resolving globals: FALSE
[13:20:03.137] Tweak future expression to call with '...' arguments ...
[13:20:03.137] {
[13:20:03.137]     do.call(function(...) {
[13:20:03.137]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.137]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.137]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.137]             on.exit(options(oopts), add = TRUE)
[13:20:03.137]         }
[13:20:03.137]         {
[13:20:03.137]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.137]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.137]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.137]             })
[13:20:03.137]         }
[13:20:03.137]     }, args = future.call.arguments)
[13:20:03.137] }
[13:20:03.138] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.138] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.138] 
[13:20:03.139] getGlobalsAndPackages() ... DONE
[13:20:03.139] run() for ‘Future’ ...
[13:20:03.139] - state: ‘created’
[13:20:03.140] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.148] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.149]   - Field: ‘label’
[13:20:03.149]   - Field: ‘local’
[13:20:03.150]   - Field: ‘owner’
[13:20:03.150]   - Field: ‘envir’
[13:20:03.150]   - Field: ‘workers’
[13:20:03.150]   - Field: ‘packages’
[13:20:03.151]   - Field: ‘gc’
[13:20:03.151]   - Field: ‘job’
[13:20:03.151]   - Field: ‘conditions’
[13:20:03.151]   - Field: ‘expr’
[13:20:03.152]   - Field: ‘uuid’
[13:20:03.152]   - Field: ‘seed’
[13:20:03.152]   - Field: ‘version’
[13:20:03.152]   - Field: ‘result’
[13:20:03.153]   - Field: ‘asynchronous’
[13:20:03.153]   - Field: ‘calls’
[13:20:03.153]   - Field: ‘globals’
[13:20:03.153]   - Field: ‘stdout’
[13:20:03.154]   - Field: ‘earlySignal’
[13:20:03.154]   - Field: ‘lazy’
[13:20:03.154]   - Field: ‘state’
[13:20:03.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.154] - Launch lazy future ...
[13:20:03.155] Packages needed by the future expression (n = 0): <none>
[13:20:03.155] Packages needed by future strategies (n = 0): <none>
[13:20:03.156] {
[13:20:03.156]     {
[13:20:03.156]         {
[13:20:03.156]             ...future.startTime <- base::Sys.time()
[13:20:03.156]             {
[13:20:03.156]                 {
[13:20:03.156]                   {
[13:20:03.156]                     {
[13:20:03.156]                       base::local({
[13:20:03.156]                         has_future <- base::requireNamespace("future", 
[13:20:03.156]                           quietly = TRUE)
[13:20:03.156]                         if (has_future) {
[13:20:03.156]                           ns <- base::getNamespace("future")
[13:20:03.156]                           version <- ns[[".package"]][["version"]]
[13:20:03.156]                           if (is.null(version)) 
[13:20:03.156]                             version <- utils::packageVersion("future")
[13:20:03.156]                         }
[13:20:03.156]                         else {
[13:20:03.156]                           version <- NULL
[13:20:03.156]                         }
[13:20:03.156]                         if (!has_future || version < "1.8.0") {
[13:20:03.156]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.156]                             "", base::R.version$version.string), 
[13:20:03.156]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.156]                               "release", "version")], collapse = " "), 
[13:20:03.156]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.156]                             info)
[13:20:03.156]                           info <- base::paste(info, collapse = "; ")
[13:20:03.156]                           if (!has_future) {
[13:20:03.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.156]                               info)
[13:20:03.156]                           }
[13:20:03.156]                           else {
[13:20:03.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.156]                               info, version)
[13:20:03.156]                           }
[13:20:03.156]                           base::stop(msg)
[13:20:03.156]                         }
[13:20:03.156]                       })
[13:20:03.156]                     }
[13:20:03.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.156]                     base::options(mc.cores = 1L)
[13:20:03.156]                   }
[13:20:03.156]                   options(future.plan = NULL)
[13:20:03.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.156]                 }
[13:20:03.156]                 ...future.workdir <- getwd()
[13:20:03.156]             }
[13:20:03.156]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.156]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.156]         }
[13:20:03.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.156]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.156]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.156]             base::names(...future.oldOptions))
[13:20:03.156]     }
[13:20:03.156]     if (FALSE) {
[13:20:03.156]     }
[13:20:03.156]     else {
[13:20:03.156]         if (TRUE) {
[13:20:03.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.156]                 open = "w")
[13:20:03.156]         }
[13:20:03.156]         else {
[13:20:03.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.156]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.156]         }
[13:20:03.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.156]             base::sink(type = "output", split = FALSE)
[13:20:03.156]             base::close(...future.stdout)
[13:20:03.156]         }, add = TRUE)
[13:20:03.156]     }
[13:20:03.156]     ...future.frame <- base::sys.nframe()
[13:20:03.156]     ...future.conditions <- base::list()
[13:20:03.156]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.156]     if (FALSE) {
[13:20:03.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.156]     }
[13:20:03.156]     ...future.result <- base::tryCatch({
[13:20:03.156]         base::withCallingHandlers({
[13:20:03.156]             ...future.value <- base::withVisible(base::local({
[13:20:03.156]                 withCallingHandlers({
[13:20:03.156]                   {
[13:20:03.156]                     do.call(function(...) {
[13:20:03.156]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.156]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.156]                         ...future.globals.maxSize)) {
[13:20:03.156]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.156]                         on.exit(options(oopts), add = TRUE)
[13:20:03.156]                       }
[13:20:03.156]                       {
[13:20:03.156]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.156]                           FUN = function(jj) {
[13:20:03.156]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.156]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.156]                           })
[13:20:03.156]                       }
[13:20:03.156]                     }, args = future.call.arguments)
[13:20:03.156]                   }
[13:20:03.156]                 }, immediateCondition = function(cond) {
[13:20:03.156]                   save_rds <- function (object, pathname, ...) 
[13:20:03.156]                   {
[13:20:03.156]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.156]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.156]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.156]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.156]                         fi_tmp[["mtime"]])
[13:20:03.156]                     }
[13:20:03.156]                     tryCatch({
[13:20:03.156]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.156]                     }, error = function(ex) {
[13:20:03.156]                       msg <- conditionMessage(ex)
[13:20:03.156]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.156]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.156]                         fi_tmp[["mtime"]], msg)
[13:20:03.156]                       ex$message <- msg
[13:20:03.156]                       stop(ex)
[13:20:03.156]                     })
[13:20:03.156]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.156]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.156]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.156]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.156]                       fi <- file.info(pathname)
[13:20:03.156]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.156]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.156]                         fi[["size"]], fi[["mtime"]])
[13:20:03.156]                       stop(msg)
[13:20:03.156]                     }
[13:20:03.156]                     invisible(pathname)
[13:20:03.156]                   }
[13:20:03.156]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.156]                     rootPath = tempdir()) 
[13:20:03.156]                   {
[13:20:03.156]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.156]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.156]                       tmpdir = path, fileext = ".rds")
[13:20:03.156]                     save_rds(obj, file)
[13:20:03.156]                   }
[13:20:03.156]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.156]                   {
[13:20:03.156]                     inherits <- base::inherits
[13:20:03.156]                     invokeRestart <- base::invokeRestart
[13:20:03.156]                     is.null <- base::is.null
[13:20:03.156]                     muffled <- FALSE
[13:20:03.156]                     if (inherits(cond, "message")) {
[13:20:03.156]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.156]                       if (muffled) 
[13:20:03.156]                         invokeRestart("muffleMessage")
[13:20:03.156]                     }
[13:20:03.156]                     else if (inherits(cond, "warning")) {
[13:20:03.156]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.156]                       if (muffled) 
[13:20:03.156]                         invokeRestart("muffleWarning")
[13:20:03.156]                     }
[13:20:03.156]                     else if (inherits(cond, "condition")) {
[13:20:03.156]                       if (!is.null(pattern)) {
[13:20:03.156]                         computeRestarts <- base::computeRestarts
[13:20:03.156]                         grepl <- base::grepl
[13:20:03.156]                         restarts <- computeRestarts(cond)
[13:20:03.156]                         for (restart in restarts) {
[13:20:03.156]                           name <- restart$name
[13:20:03.156]                           if (is.null(name)) 
[13:20:03.156]                             next
[13:20:03.156]                           if (!grepl(pattern, name)) 
[13:20:03.156]                             next
[13:20:03.156]                           invokeRestart(restart)
[13:20:03.156]                           muffled <- TRUE
[13:20:03.156]                           break
[13:20:03.156]                         }
[13:20:03.156]                       }
[13:20:03.156]                     }
[13:20:03.156]                     invisible(muffled)
[13:20:03.156]                   }
[13:20:03.156]                   muffleCondition(cond)
[13:20:03.156]                 })
[13:20:03.156]             }))
[13:20:03.156]             future::FutureResult(value = ...future.value$value, 
[13:20:03.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.156]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.156]                     ...future.globalenv.names))
[13:20:03.156]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.156]         }, condition = base::local({
[13:20:03.156]             c <- base::c
[13:20:03.156]             inherits <- base::inherits
[13:20:03.156]             invokeRestart <- base::invokeRestart
[13:20:03.156]             length <- base::length
[13:20:03.156]             list <- base::list
[13:20:03.156]             seq.int <- base::seq.int
[13:20:03.156]             signalCondition <- base::signalCondition
[13:20:03.156]             sys.calls <- base::sys.calls
[13:20:03.156]             `[[` <- base::`[[`
[13:20:03.156]             `+` <- base::`+`
[13:20:03.156]             `<<-` <- base::`<<-`
[13:20:03.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.156]                   3L)]
[13:20:03.156]             }
[13:20:03.156]             function(cond) {
[13:20:03.156]                 is_error <- inherits(cond, "error")
[13:20:03.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.156]                   NULL)
[13:20:03.156]                 if (is_error) {
[13:20:03.156]                   sessionInformation <- function() {
[13:20:03.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.156]                       search = base::search(), system = base::Sys.info())
[13:20:03.156]                   }
[13:20:03.156]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.156]                     cond$call), session = sessionInformation(), 
[13:20:03.156]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.156]                   signalCondition(cond)
[13:20:03.156]                 }
[13:20:03.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.156]                 "immediateCondition"))) {
[13:20:03.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.156]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.156]                   if (TRUE && !signal) {
[13:20:03.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.156]                     {
[13:20:03.156]                       inherits <- base::inherits
[13:20:03.156]                       invokeRestart <- base::invokeRestart
[13:20:03.156]                       is.null <- base::is.null
[13:20:03.156]                       muffled <- FALSE
[13:20:03.156]                       if (inherits(cond, "message")) {
[13:20:03.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.156]                         if (muffled) 
[13:20:03.156]                           invokeRestart("muffleMessage")
[13:20:03.156]                       }
[13:20:03.156]                       else if (inherits(cond, "warning")) {
[13:20:03.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.156]                         if (muffled) 
[13:20:03.156]                           invokeRestart("muffleWarning")
[13:20:03.156]                       }
[13:20:03.156]                       else if (inherits(cond, "condition")) {
[13:20:03.156]                         if (!is.null(pattern)) {
[13:20:03.156]                           computeRestarts <- base::computeRestarts
[13:20:03.156]                           grepl <- base::grepl
[13:20:03.156]                           restarts <- computeRestarts(cond)
[13:20:03.156]                           for (restart in restarts) {
[13:20:03.156]                             name <- restart$name
[13:20:03.156]                             if (is.null(name)) 
[13:20:03.156]                               next
[13:20:03.156]                             if (!grepl(pattern, name)) 
[13:20:03.156]                               next
[13:20:03.156]                             invokeRestart(restart)
[13:20:03.156]                             muffled <- TRUE
[13:20:03.156]                             break
[13:20:03.156]                           }
[13:20:03.156]                         }
[13:20:03.156]                       }
[13:20:03.156]                       invisible(muffled)
[13:20:03.156]                     }
[13:20:03.156]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.156]                   }
[13:20:03.156]                 }
[13:20:03.156]                 else {
[13:20:03.156]                   if (TRUE) {
[13:20:03.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.156]                     {
[13:20:03.156]                       inherits <- base::inherits
[13:20:03.156]                       invokeRestart <- base::invokeRestart
[13:20:03.156]                       is.null <- base::is.null
[13:20:03.156]                       muffled <- FALSE
[13:20:03.156]                       if (inherits(cond, "message")) {
[13:20:03.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.156]                         if (muffled) 
[13:20:03.156]                           invokeRestart("muffleMessage")
[13:20:03.156]                       }
[13:20:03.156]                       else if (inherits(cond, "warning")) {
[13:20:03.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.156]                         if (muffled) 
[13:20:03.156]                           invokeRestart("muffleWarning")
[13:20:03.156]                       }
[13:20:03.156]                       else if (inherits(cond, "condition")) {
[13:20:03.156]                         if (!is.null(pattern)) {
[13:20:03.156]                           computeRestarts <- base::computeRestarts
[13:20:03.156]                           grepl <- base::grepl
[13:20:03.156]                           restarts <- computeRestarts(cond)
[13:20:03.156]                           for (restart in restarts) {
[13:20:03.156]                             name <- restart$name
[13:20:03.156]                             if (is.null(name)) 
[13:20:03.156]                               next
[13:20:03.156]                             if (!grepl(pattern, name)) 
[13:20:03.156]                               next
[13:20:03.156]                             invokeRestart(restart)
[13:20:03.156]                             muffled <- TRUE
[13:20:03.156]                             break
[13:20:03.156]                           }
[13:20:03.156]                         }
[13:20:03.156]                       }
[13:20:03.156]                       invisible(muffled)
[13:20:03.156]                     }
[13:20:03.156]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.156]                   }
[13:20:03.156]                 }
[13:20:03.156]             }
[13:20:03.156]         }))
[13:20:03.156]     }, error = function(ex) {
[13:20:03.156]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.156]                 ...future.rng), started = ...future.startTime, 
[13:20:03.156]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.156]             version = "1.8"), class = "FutureResult")
[13:20:03.156]     }, finally = {
[13:20:03.156]         if (!identical(...future.workdir, getwd())) 
[13:20:03.156]             setwd(...future.workdir)
[13:20:03.156]         {
[13:20:03.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.156]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.156]             }
[13:20:03.156]             base::options(...future.oldOptions)
[13:20:03.156]             if (.Platform$OS.type == "windows") {
[13:20:03.156]                 old_names <- names(...future.oldEnvVars)
[13:20:03.156]                 envs <- base::Sys.getenv()
[13:20:03.156]                 names <- names(envs)
[13:20:03.156]                 common <- intersect(names, old_names)
[13:20:03.156]                 added <- setdiff(names, old_names)
[13:20:03.156]                 removed <- setdiff(old_names, names)
[13:20:03.156]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.156]                   envs[common]]
[13:20:03.156]                 NAMES <- toupper(changed)
[13:20:03.156]                 args <- list()
[13:20:03.156]                 for (kk in seq_along(NAMES)) {
[13:20:03.156]                   name <- changed[[kk]]
[13:20:03.156]                   NAME <- NAMES[[kk]]
[13:20:03.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.156]                     next
[13:20:03.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.156]                 }
[13:20:03.156]                 NAMES <- toupper(added)
[13:20:03.156]                 for (kk in seq_along(NAMES)) {
[13:20:03.156]                   name <- added[[kk]]
[13:20:03.156]                   NAME <- NAMES[[kk]]
[13:20:03.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.156]                     next
[13:20:03.156]                   args[[name]] <- ""
[13:20:03.156]                 }
[13:20:03.156]                 NAMES <- toupper(removed)
[13:20:03.156]                 for (kk in seq_along(NAMES)) {
[13:20:03.156]                   name <- removed[[kk]]
[13:20:03.156]                   NAME <- NAMES[[kk]]
[13:20:03.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.156]                     next
[13:20:03.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.156]                 }
[13:20:03.156]                 if (length(args) > 0) 
[13:20:03.156]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.156]             }
[13:20:03.156]             else {
[13:20:03.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.156]             }
[13:20:03.156]             {
[13:20:03.156]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.156]                   0L) {
[13:20:03.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.156]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.156]                   base::options(opts)
[13:20:03.156]                 }
[13:20:03.156]                 {
[13:20:03.156]                   {
[13:20:03.156]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.156]                     NULL
[13:20:03.156]                   }
[13:20:03.156]                   options(future.plan = NULL)
[13:20:03.156]                   if (is.na(NA_character_)) 
[13:20:03.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.156]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.156]                     envir = parent.frame()) 
[13:20:03.156]                   {
[13:20:03.156]                     default_workers <- missing(workers)
[13:20:03.156]                     if (is.function(workers)) 
[13:20:03.156]                       workers <- workers()
[13:20:03.156]                     workers <- structure(as.integer(workers), 
[13:20:03.156]                       class = class(workers))
[13:20:03.156]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.156]                       1L)
[13:20:03.156]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.156]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.156]                       if (default_workers) 
[13:20:03.156]                         supportsMulticore(warn = TRUE)
[13:20:03.156]                       return(sequential(..., envir = envir))
[13:20:03.156]                     }
[13:20:03.156]                     oopts <- options(mc.cores = workers)
[13:20:03.156]                     on.exit(options(oopts))
[13:20:03.156]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.156]                       envir = envir)
[13:20:03.156]                     if (!future$lazy) 
[13:20:03.156]                       future <- run(future)
[13:20:03.156]                     invisible(future)
[13:20:03.156]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.156]                 }
[13:20:03.156]             }
[13:20:03.156]         }
[13:20:03.156]     })
[13:20:03.156]     if (TRUE) {
[13:20:03.156]         base::sink(type = "output", split = FALSE)
[13:20:03.156]         if (TRUE) {
[13:20:03.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.156]         }
[13:20:03.156]         else {
[13:20:03.156]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.156]         }
[13:20:03.156]         base::close(...future.stdout)
[13:20:03.156]         ...future.stdout <- NULL
[13:20:03.156]     }
[13:20:03.156]     ...future.result$conditions <- ...future.conditions
[13:20:03.156]     ...future.result$finished <- base::Sys.time()
[13:20:03.156]     ...future.result
[13:20:03.156] }
[13:20:03.159] assign_globals() ...
[13:20:03.160] List of 5
[13:20:03.160]  $ ...future.FUN            :function (object, ...)  
[13:20:03.160]  $ future.call.arguments    :List of 1
[13:20:03.160]   ..$ digits: int 2
[13:20:03.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.160]  $ ...future.elements_ii    :List of 3
[13:20:03.160]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:20:03.160]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:20:03.160]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:20:03.160]  $ ...future.seeds_ii       : NULL
[13:20:03.160]  $ ...future.globals.maxSize: NULL
[13:20:03.160]  - attr(*, "where")=List of 5
[13:20:03.160]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.160]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.160]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.160]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.160]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.160]  - attr(*, "resolved")= logi FALSE
[13:20:03.160]  - attr(*, "total_size")= num 1296
[13:20:03.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.160]  - attr(*, "already-done")= logi TRUE
[13:20:03.168] - copied ‘...future.FUN’ to environment
[13:20:03.169] - copied ‘future.call.arguments’ to environment
[13:20:03.169] - copied ‘...future.elements_ii’ to environment
[13:20:03.169] - copied ‘...future.seeds_ii’ to environment
[13:20:03.169] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.169] assign_globals() ... done
[13:20:03.169] requestCore(): workers = 2
[13:20:03.172] MulticoreFuture started
[13:20:03.172] - Launch lazy future ... done
[13:20:03.172] run() for ‘MulticoreFuture’ ... done
[13:20:03.172] Created future:
[13:20:03.173] plan(): Setting new future strategy stack:
[13:20:03.173] List of future strategies:
[13:20:03.173] 1. sequential:
[13:20:03.173]    - args: function (..., envir = parent.frame())
[13:20:03.173]    - tweaked: FALSE
[13:20:03.173]    - call: NULL
[13:20:03.174] plan(): nbrOfWorkers() = 1
[13:20:03.177] plan(): Setting new future strategy stack:
[13:20:03.177] List of future strategies:
[13:20:03.177] 1. multicore:
[13:20:03.177]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.177]    - tweaked: FALSE
[13:20:03.177]    - call: plan(strategy)
[13:20:03.183] plan(): nbrOfWorkers() = 2
[13:20:03.173] MulticoreFuture:
[13:20:03.173] Label: ‘future_by-2’
[13:20:03.173] Expression:
[13:20:03.173] {
[13:20:03.173]     do.call(function(...) {
[13:20:03.173]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.173]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.173]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.173]             on.exit(options(oopts), add = TRUE)
[13:20:03.173]         }
[13:20:03.173]         {
[13:20:03.173]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.173]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.173]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.173]             })
[13:20:03.173]         }
[13:20:03.173]     }, args = future.call.arguments)
[13:20:03.173] }
[13:20:03.173] Lazy evaluation: FALSE
[13:20:03.173] Asynchronous evaluation: TRUE
[13:20:03.173] Local evaluation: TRUE
[13:20:03.173] Environment: R_GlobalEnv
[13:20:03.173] Capture standard output: TRUE
[13:20:03.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.173] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.173] Packages: <none>
[13:20:03.173] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.173] Resolved: TRUE
[13:20:03.173] Value: <not collected>
[13:20:03.173] Conditions captured: <none>
[13:20:03.173] Early signaling: FALSE
[13:20:03.173] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.173] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.184] Chunk #2 of 2 ... DONE
[13:20:03.184] Launching 2 futures (chunks) ... DONE
[13:20:03.184] Resolving 2 futures (chunks) ...
[13:20:03.185] resolve() on list ...
[13:20:03.185]  recursive: 0
[13:20:03.185]  length: 2
[13:20:03.185] 
[13:20:03.185] Future #1
[13:20:03.186] result() for MulticoreFuture ...
[13:20:03.187] result() for MulticoreFuture ...
[13:20:03.187] result() for MulticoreFuture ... done
[13:20:03.187] result() for MulticoreFuture ... done
[13:20:03.187] result() for MulticoreFuture ...
[13:20:03.187] result() for MulticoreFuture ... done
[13:20:03.187] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:03.187] - nx: 2
[13:20:03.188] - relay: TRUE
[13:20:03.188] - stdout: TRUE
[13:20:03.188] - signal: TRUE
[13:20:03.188] - resignal: FALSE
[13:20:03.188] - force: TRUE
[13:20:03.188] - relayed: [n=2] FALSE, FALSE
[13:20:03.188] - queued futures: [n=2] FALSE, FALSE
[13:20:03.189]  - until=1
[13:20:03.189]  - relaying element #1
[13:20:03.189] result() for MulticoreFuture ...
[13:20:03.189] result() for MulticoreFuture ... done
[13:20:03.189] result() for MulticoreFuture ...
[13:20:03.189] result() for MulticoreFuture ... done
[13:20:03.190] result() for MulticoreFuture ...
[13:20:03.190] result() for MulticoreFuture ... done
[13:20:03.190] result() for MulticoreFuture ...
[13:20:03.190] result() for MulticoreFuture ... done
[13:20:03.190] - relayed: [n=2] TRUE, FALSE
[13:20:03.190] - queued futures: [n=2] TRUE, FALSE
[13:20:03.190] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:03.191]  length: 1 (resolved future 1)
[13:20:03.191] Future #2
[13:20:03.191] result() for MulticoreFuture ...
[13:20:03.192] result() for MulticoreFuture ...
[13:20:03.192] result() for MulticoreFuture ... done
[13:20:03.192] result() for MulticoreFuture ... done
[13:20:03.192] result() for MulticoreFuture ...
[13:20:03.192] result() for MulticoreFuture ... done
[13:20:03.192] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:03.193] - nx: 2
[13:20:03.193] - relay: TRUE
[13:20:03.193] - stdout: TRUE
[13:20:03.193] - signal: TRUE
[13:20:03.196] - resignal: FALSE
[13:20:03.196] - force: TRUE
[13:20:03.196] - relayed: [n=2] TRUE, FALSE
[13:20:03.196] - queued futures: [n=2] TRUE, FALSE
[13:20:03.196]  - until=2
[13:20:03.197]  - relaying element #2
[13:20:03.197] result() for MulticoreFuture ...
[13:20:03.197] result() for MulticoreFuture ... done
[13:20:03.197] result() for MulticoreFuture ...
[13:20:03.197] result() for MulticoreFuture ... done
[13:20:03.198] result() for MulticoreFuture ...
[13:20:03.198] result() for MulticoreFuture ... done
[13:20:03.198] result() for MulticoreFuture ...
[13:20:03.198] result() for MulticoreFuture ... done
[13:20:03.198] - relayed: [n=2] TRUE, TRUE
[13:20:03.198] - queued futures: [n=2] TRUE, TRUE
[13:20:03.199] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:03.199]  length: 0 (resolved future 2)
[13:20:03.199] Relaying remaining futures
[13:20:03.199] signalConditionsASAP(NULL, pos=0) ...
[13:20:03.199] - nx: 2
[13:20:03.199] - relay: TRUE
[13:20:03.200] - stdout: TRUE
[13:20:03.200] - signal: TRUE
[13:20:03.200] - resignal: FALSE
[13:20:03.200] - force: TRUE
[13:20:03.200] - relayed: [n=2] TRUE, TRUE
[13:20:03.200] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:03.201] - relayed: [n=2] TRUE, TRUE
[13:20:03.201] - queued futures: [n=2] TRUE, TRUE
[13:20:03.201] signalConditionsASAP(NULL, pos=0) ... done
[13:20:03.201] resolve() on list ... DONE
[13:20:03.201] result() for MulticoreFuture ...
[13:20:03.201] result() for MulticoreFuture ... done
[13:20:03.201] result() for MulticoreFuture ...
[13:20:03.202] result() for MulticoreFuture ... done
[13:20:03.202] result() for MulticoreFuture ...
[13:20:03.202] result() for MulticoreFuture ... done
[13:20:03.202] result() for MulticoreFuture ...
[13:20:03.202] result() for MulticoreFuture ... done
[13:20:03.202]  - Number of value chunks collected: 2
[13:20:03.203] Resolving 2 futures (chunks) ... DONE
[13:20:03.203] Reducing values from 2 chunks ...
[13:20:03.203]  - Number of values collected after concatenation: 6
[13:20:03.203]  - Number of values expected: 6
[13:20:03.203] Reducing values from 2 chunks ... DONE
[13:20:03.203] future_lapply() ... DONE
[13:20:03.203] future_by_internal() ... DONE
[13:20:03.205] future_by_internal() ...
[13:20:03.205] future_lapply() ...
[13:20:03.210] Number of chunks: 2
[13:20:03.211] getGlobalsAndPackagesXApply() ...
[13:20:03.211]  - future.globals: TRUE
[13:20:03.211] getGlobalsAndPackages() ...
[13:20:03.211] Searching for globals...
[13:20:03.213] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:03.213] Searching for globals ... DONE
[13:20:03.213] Resolving globals: FALSE
[13:20:03.213] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:20:03.214] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:20:03.214] - globals: [1] ‘FUN’
[13:20:03.214] - packages: [1] ‘stats’
[13:20:03.214] getGlobalsAndPackages() ... DONE
[13:20:03.214]  - globals found/used: [n=1] ‘FUN’
[13:20:03.214]  - needed namespaces: [n=1] ‘stats’
[13:20:03.215] Finding globals ... DONE
[13:20:03.215]  - use_args: TRUE
[13:20:03.215]  - Getting '...' globals ...
[13:20:03.215] resolve() on list ...
[13:20:03.215]  recursive: 0
[13:20:03.215]  length: 1
[13:20:03.215]  elements: ‘...’
[13:20:03.215]  length: 0 (resolved future 1)
[13:20:03.216] resolve() on list ... DONE
[13:20:03.216]    - '...' content: [n=1] ‘singular.ok’
[13:20:03.216] List of 1
[13:20:03.216]  $ ...:List of 1
[13:20:03.216]   ..$ singular.ok: logi FALSE
[13:20:03.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.216]  - attr(*, "where")=List of 1
[13:20:03.216]   ..$ ...:<environment: 0x55aced578d48> 
[13:20:03.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.216]  - attr(*, "resolved")= logi TRUE
[13:20:03.216]  - attr(*, "total_size")= num NA
[13:20:03.219]  - Getting '...' globals ... DONE
[13:20:03.219] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:03.219] List of 2
[13:20:03.219]  $ ...future.FUN:function (x, ...)  
[13:20:03.219]  $ ...          :List of 1
[13:20:03.219]   ..$ singular.ok: logi FALSE
[13:20:03.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.219]  - attr(*, "where")=List of 2
[13:20:03.219]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:03.219]   ..$ ...          :<environment: 0x55aced578d48> 
[13:20:03.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.219]  - attr(*, "resolved")= logi FALSE
[13:20:03.219]  - attr(*, "total_size")= num 5384
[13:20:03.225] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:03.225] getGlobalsAndPackagesXApply() ... DONE
[13:20:03.225] Number of futures (= number of chunks): 2
[13:20:03.225] Launching 2 futures (chunks) ...
[13:20:03.225] Chunk #1 of 2 ...
[13:20:03.225]  - Finding globals in 'X' for chunk #1 ...
[13:20:03.226] getGlobalsAndPackages() ...
[13:20:03.226] Searching for globals...
[13:20:03.226] 
[13:20:03.226] Searching for globals ... DONE
[13:20:03.226] - globals: [0] <none>
[13:20:03.226] getGlobalsAndPackages() ... DONE
[13:20:03.227]    + additional globals found: [n=0] 
[13:20:03.227]    + additional namespaces needed: [n=0] 
[13:20:03.227]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:03.227]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.227]  - seeds: <none>
[13:20:03.227]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.227] getGlobalsAndPackages() ...
[13:20:03.227] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.227] Resolving globals: FALSE
[13:20:03.228] Tweak future expression to call with '...' arguments ...
[13:20:03.228] {
[13:20:03.228]     do.call(function(...) {
[13:20:03.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.228]             on.exit(options(oopts), add = TRUE)
[13:20:03.228]         }
[13:20:03.228]         {
[13:20:03.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.228]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.228]             })
[13:20:03.228]         }
[13:20:03.228]     }, args = future.call.arguments)
[13:20:03.228] }
[13:20:03.228] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.228] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.229] 
[13:20:03.229] getGlobalsAndPackages() ... DONE
[13:20:03.229] run() for ‘Future’ ...
[13:20:03.229] - state: ‘created’
[13:20:03.229] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.233] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.233]   - Field: ‘label’
[13:20:03.233]   - Field: ‘local’
[13:20:03.233]   - Field: ‘owner’
[13:20:03.233]   - Field: ‘envir’
[13:20:03.234]   - Field: ‘workers’
[13:20:03.234]   - Field: ‘packages’
[13:20:03.234]   - Field: ‘gc’
[13:20:03.234]   - Field: ‘job’
[13:20:03.234]   - Field: ‘conditions’
[13:20:03.234]   - Field: ‘expr’
[13:20:03.234]   - Field: ‘uuid’
[13:20:03.234]   - Field: ‘seed’
[13:20:03.234]   - Field: ‘version’
[13:20:03.234]   - Field: ‘result’
[13:20:03.235]   - Field: ‘asynchronous’
[13:20:03.235]   - Field: ‘calls’
[13:20:03.235]   - Field: ‘globals’
[13:20:03.235]   - Field: ‘stdout’
[13:20:03.235]   - Field: ‘earlySignal’
[13:20:03.235]   - Field: ‘lazy’
[13:20:03.235]   - Field: ‘state’
[13:20:03.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.235] - Launch lazy future ...
[13:20:03.236] Packages needed by the future expression (n = 1): ‘stats’
[13:20:03.236] Packages needed by future strategies (n = 0): <none>
[13:20:03.236] {
[13:20:03.236]     {
[13:20:03.236]         {
[13:20:03.236]             ...future.startTime <- base::Sys.time()
[13:20:03.236]             {
[13:20:03.236]                 {
[13:20:03.236]                   {
[13:20:03.236]                     {
[13:20:03.236]                       {
[13:20:03.236]                         base::local({
[13:20:03.236]                           has_future <- base::requireNamespace("future", 
[13:20:03.236]                             quietly = TRUE)
[13:20:03.236]                           if (has_future) {
[13:20:03.236]                             ns <- base::getNamespace("future")
[13:20:03.236]                             version <- ns[[".package"]][["version"]]
[13:20:03.236]                             if (is.null(version)) 
[13:20:03.236]                               version <- utils::packageVersion("future")
[13:20:03.236]                           }
[13:20:03.236]                           else {
[13:20:03.236]                             version <- NULL
[13:20:03.236]                           }
[13:20:03.236]                           if (!has_future || version < "1.8.0") {
[13:20:03.236]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.236]                               "", base::R.version$version.string), 
[13:20:03.236]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:03.236]                                 base::R.version$platform, 8 * 
[13:20:03.236]                                   base::.Machine$sizeof.pointer), 
[13:20:03.236]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.236]                                 "release", "version")], collapse = " "), 
[13:20:03.236]                               hostname = base::Sys.info()[["nodename"]])
[13:20:03.236]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.236]                               info)
[13:20:03.236]                             info <- base::paste(info, collapse = "; ")
[13:20:03.236]                             if (!has_future) {
[13:20:03.236]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.236]                                 info)
[13:20:03.236]                             }
[13:20:03.236]                             else {
[13:20:03.236]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.236]                                 info, version)
[13:20:03.236]                             }
[13:20:03.236]                             base::stop(msg)
[13:20:03.236]                           }
[13:20:03.236]                         })
[13:20:03.236]                       }
[13:20:03.236]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.236]                       base::options(mc.cores = 1L)
[13:20:03.236]                     }
[13:20:03.236]                     base::local({
[13:20:03.236]                       for (pkg in "stats") {
[13:20:03.236]                         base::loadNamespace(pkg)
[13:20:03.236]                         base::library(pkg, character.only = TRUE)
[13:20:03.236]                       }
[13:20:03.236]                     })
[13:20:03.236]                   }
[13:20:03.236]                   options(future.plan = NULL)
[13:20:03.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.236]                 }
[13:20:03.236]                 ...future.workdir <- getwd()
[13:20:03.236]             }
[13:20:03.236]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.236]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.236]         }
[13:20:03.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.236]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.236]             base::names(...future.oldOptions))
[13:20:03.236]     }
[13:20:03.236]     if (FALSE) {
[13:20:03.236]     }
[13:20:03.236]     else {
[13:20:03.236]         if (TRUE) {
[13:20:03.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.236]                 open = "w")
[13:20:03.236]         }
[13:20:03.236]         else {
[13:20:03.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.236]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.236]         }
[13:20:03.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.236]             base::sink(type = "output", split = FALSE)
[13:20:03.236]             base::close(...future.stdout)
[13:20:03.236]         }, add = TRUE)
[13:20:03.236]     }
[13:20:03.236]     ...future.frame <- base::sys.nframe()
[13:20:03.236]     ...future.conditions <- base::list()
[13:20:03.236]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.236]     if (FALSE) {
[13:20:03.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.236]     }
[13:20:03.236]     ...future.result <- base::tryCatch({
[13:20:03.236]         base::withCallingHandlers({
[13:20:03.236]             ...future.value <- base::withVisible(base::local({
[13:20:03.236]                 withCallingHandlers({
[13:20:03.236]                   {
[13:20:03.236]                     do.call(function(...) {
[13:20:03.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.236]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.236]                         ...future.globals.maxSize)) {
[13:20:03.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.236]                         on.exit(options(oopts), add = TRUE)
[13:20:03.236]                       }
[13:20:03.236]                       {
[13:20:03.236]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.236]                           FUN = function(jj) {
[13:20:03.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.236]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.236]                           })
[13:20:03.236]                       }
[13:20:03.236]                     }, args = future.call.arguments)
[13:20:03.236]                   }
[13:20:03.236]                 }, immediateCondition = function(cond) {
[13:20:03.236]                   save_rds <- function (object, pathname, ...) 
[13:20:03.236]                   {
[13:20:03.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.236]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.236]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.236]                         fi_tmp[["mtime"]])
[13:20:03.236]                     }
[13:20:03.236]                     tryCatch({
[13:20:03.236]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.236]                     }, error = function(ex) {
[13:20:03.236]                       msg <- conditionMessage(ex)
[13:20:03.236]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.236]                         fi_tmp[["mtime"]], msg)
[13:20:03.236]                       ex$message <- msg
[13:20:03.236]                       stop(ex)
[13:20:03.236]                     })
[13:20:03.236]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.236]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.236]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.236]                       fi <- file.info(pathname)
[13:20:03.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.236]                         fi[["size"]], fi[["mtime"]])
[13:20:03.236]                       stop(msg)
[13:20:03.236]                     }
[13:20:03.236]                     invisible(pathname)
[13:20:03.236]                   }
[13:20:03.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.236]                     rootPath = tempdir()) 
[13:20:03.236]                   {
[13:20:03.236]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.236]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.236]                       tmpdir = path, fileext = ".rds")
[13:20:03.236]                     save_rds(obj, file)
[13:20:03.236]                   }
[13:20:03.236]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.236]                   {
[13:20:03.236]                     inherits <- base::inherits
[13:20:03.236]                     invokeRestart <- base::invokeRestart
[13:20:03.236]                     is.null <- base::is.null
[13:20:03.236]                     muffled <- FALSE
[13:20:03.236]                     if (inherits(cond, "message")) {
[13:20:03.236]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.236]                       if (muffled) 
[13:20:03.236]                         invokeRestart("muffleMessage")
[13:20:03.236]                     }
[13:20:03.236]                     else if (inherits(cond, "warning")) {
[13:20:03.236]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.236]                       if (muffled) 
[13:20:03.236]                         invokeRestart("muffleWarning")
[13:20:03.236]                     }
[13:20:03.236]                     else if (inherits(cond, "condition")) {
[13:20:03.236]                       if (!is.null(pattern)) {
[13:20:03.236]                         computeRestarts <- base::computeRestarts
[13:20:03.236]                         grepl <- base::grepl
[13:20:03.236]                         restarts <- computeRestarts(cond)
[13:20:03.236]                         for (restart in restarts) {
[13:20:03.236]                           name <- restart$name
[13:20:03.236]                           if (is.null(name)) 
[13:20:03.236]                             next
[13:20:03.236]                           if (!grepl(pattern, name)) 
[13:20:03.236]                             next
[13:20:03.236]                           invokeRestart(restart)
[13:20:03.236]                           muffled <- TRUE
[13:20:03.236]                           break
[13:20:03.236]                         }
[13:20:03.236]                       }
[13:20:03.236]                     }
[13:20:03.236]                     invisible(muffled)
[13:20:03.236]                   }
[13:20:03.236]                   muffleCondition(cond)
[13:20:03.236]                 })
[13:20:03.236]             }))
[13:20:03.236]             future::FutureResult(value = ...future.value$value, 
[13:20:03.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.236]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.236]                     ...future.globalenv.names))
[13:20:03.236]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.236]         }, condition = base::local({
[13:20:03.236]             c <- base::c
[13:20:03.236]             inherits <- base::inherits
[13:20:03.236]             invokeRestart <- base::invokeRestart
[13:20:03.236]             length <- base::length
[13:20:03.236]             list <- base::list
[13:20:03.236]             seq.int <- base::seq.int
[13:20:03.236]             signalCondition <- base::signalCondition
[13:20:03.236]             sys.calls <- base::sys.calls
[13:20:03.236]             `[[` <- base::`[[`
[13:20:03.236]             `+` <- base::`+`
[13:20:03.236]             `<<-` <- base::`<<-`
[13:20:03.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.236]                   3L)]
[13:20:03.236]             }
[13:20:03.236]             function(cond) {
[13:20:03.236]                 is_error <- inherits(cond, "error")
[13:20:03.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.236]                   NULL)
[13:20:03.236]                 if (is_error) {
[13:20:03.236]                   sessionInformation <- function() {
[13:20:03.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.236]                       search = base::search(), system = base::Sys.info())
[13:20:03.236]                   }
[13:20:03.236]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.236]                     cond$call), session = sessionInformation(), 
[13:20:03.236]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.236]                   signalCondition(cond)
[13:20:03.236]                 }
[13:20:03.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.236]                 "immediateCondition"))) {
[13:20:03.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.236]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.236]                   if (TRUE && !signal) {
[13:20:03.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.236]                     {
[13:20:03.236]                       inherits <- base::inherits
[13:20:03.236]                       invokeRestart <- base::invokeRestart
[13:20:03.236]                       is.null <- base::is.null
[13:20:03.236]                       muffled <- FALSE
[13:20:03.236]                       if (inherits(cond, "message")) {
[13:20:03.236]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.236]                         if (muffled) 
[13:20:03.236]                           invokeRestart("muffleMessage")
[13:20:03.236]                       }
[13:20:03.236]                       else if (inherits(cond, "warning")) {
[13:20:03.236]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.236]                         if (muffled) 
[13:20:03.236]                           invokeRestart("muffleWarning")
[13:20:03.236]                       }
[13:20:03.236]                       else if (inherits(cond, "condition")) {
[13:20:03.236]                         if (!is.null(pattern)) {
[13:20:03.236]                           computeRestarts <- base::computeRestarts
[13:20:03.236]                           grepl <- base::grepl
[13:20:03.236]                           restarts <- computeRestarts(cond)
[13:20:03.236]                           for (restart in restarts) {
[13:20:03.236]                             name <- restart$name
[13:20:03.236]                             if (is.null(name)) 
[13:20:03.236]                               next
[13:20:03.236]                             if (!grepl(pattern, name)) 
[13:20:03.236]                               next
[13:20:03.236]                             invokeRestart(restart)
[13:20:03.236]                             muffled <- TRUE
[13:20:03.236]                             break
[13:20:03.236]                           }
[13:20:03.236]                         }
[13:20:03.236]                       }
[13:20:03.236]                       invisible(muffled)
[13:20:03.236]                     }
[13:20:03.236]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.236]                   }
[13:20:03.236]                 }
[13:20:03.236]                 else {
[13:20:03.236]                   if (TRUE) {
[13:20:03.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.236]                     {
[13:20:03.236]                       inherits <- base::inherits
[13:20:03.236]                       invokeRestart <- base::invokeRestart
[13:20:03.236]                       is.null <- base::is.null
[13:20:03.236]                       muffled <- FALSE
[13:20:03.236]                       if (inherits(cond, "message")) {
[13:20:03.236]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.236]                         if (muffled) 
[13:20:03.236]                           invokeRestart("muffleMessage")
[13:20:03.236]                       }
[13:20:03.236]                       else if (inherits(cond, "warning")) {
[13:20:03.236]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.236]                         if (muffled) 
[13:20:03.236]                           invokeRestart("muffleWarning")
[13:20:03.236]                       }
[13:20:03.236]                       else if (inherits(cond, "condition")) {
[13:20:03.236]                         if (!is.null(pattern)) {
[13:20:03.236]                           computeRestarts <- base::computeRestarts
[13:20:03.236]                           grepl <- base::grepl
[13:20:03.236]                           restarts <- computeRestarts(cond)
[13:20:03.236]                           for (restart in restarts) {
[13:20:03.236]                             name <- restart$name
[13:20:03.236]                             if (is.null(name)) 
[13:20:03.236]                               next
[13:20:03.236]                             if (!grepl(pattern, name)) 
[13:20:03.236]                               next
[13:20:03.236]                             invokeRestart(restart)
[13:20:03.236]                             muffled <- TRUE
[13:20:03.236]                             break
[13:20:03.236]                           }
[13:20:03.236]                         }
[13:20:03.236]                       }
[13:20:03.236]                       invisible(muffled)
[13:20:03.236]                     }
[13:20:03.236]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.236]                   }
[13:20:03.236]                 }
[13:20:03.236]             }
[13:20:03.236]         }))
[13:20:03.236]     }, error = function(ex) {
[13:20:03.236]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.236]                 ...future.rng), started = ...future.startTime, 
[13:20:03.236]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.236]             version = "1.8"), class = "FutureResult")
[13:20:03.236]     }, finally = {
[13:20:03.236]         if (!identical(...future.workdir, getwd())) 
[13:20:03.236]             setwd(...future.workdir)
[13:20:03.236]         {
[13:20:03.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.236]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.236]             }
[13:20:03.236]             base::options(...future.oldOptions)
[13:20:03.236]             if (.Platform$OS.type == "windows") {
[13:20:03.236]                 old_names <- names(...future.oldEnvVars)
[13:20:03.236]                 envs <- base::Sys.getenv()
[13:20:03.236]                 names <- names(envs)
[13:20:03.236]                 common <- intersect(names, old_names)
[13:20:03.236]                 added <- setdiff(names, old_names)
[13:20:03.236]                 removed <- setdiff(old_names, names)
[13:20:03.236]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.236]                   envs[common]]
[13:20:03.236]                 NAMES <- toupper(changed)
[13:20:03.236]                 args <- list()
[13:20:03.236]                 for (kk in seq_along(NAMES)) {
[13:20:03.236]                   name <- changed[[kk]]
[13:20:03.236]                   NAME <- NAMES[[kk]]
[13:20:03.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.236]                     next
[13:20:03.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.236]                 }
[13:20:03.236]                 NAMES <- toupper(added)
[13:20:03.236]                 for (kk in seq_along(NAMES)) {
[13:20:03.236]                   name <- added[[kk]]
[13:20:03.236]                   NAME <- NAMES[[kk]]
[13:20:03.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.236]                     next
[13:20:03.236]                   args[[name]] <- ""
[13:20:03.236]                 }
[13:20:03.236]                 NAMES <- toupper(removed)
[13:20:03.236]                 for (kk in seq_along(NAMES)) {
[13:20:03.236]                   name <- removed[[kk]]
[13:20:03.236]                   NAME <- NAMES[[kk]]
[13:20:03.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.236]                     next
[13:20:03.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.236]                 }
[13:20:03.236]                 if (length(args) > 0) 
[13:20:03.236]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.236]             }
[13:20:03.236]             else {
[13:20:03.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.236]             }
[13:20:03.236]             {
[13:20:03.236]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.236]                   0L) {
[13:20:03.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.236]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.236]                   base::options(opts)
[13:20:03.236]                 }
[13:20:03.236]                 {
[13:20:03.236]                   {
[13:20:03.236]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.236]                     NULL
[13:20:03.236]                   }
[13:20:03.236]                   options(future.plan = NULL)
[13:20:03.236]                   if (is.na(NA_character_)) 
[13:20:03.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.236]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.236]                     envir = parent.frame()) 
[13:20:03.236]                   {
[13:20:03.236]                     default_workers <- missing(workers)
[13:20:03.236]                     if (is.function(workers)) 
[13:20:03.236]                       workers <- workers()
[13:20:03.236]                     workers <- structure(as.integer(workers), 
[13:20:03.236]                       class = class(workers))
[13:20:03.236]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.236]                       1L)
[13:20:03.236]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.236]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.236]                       if (default_workers) 
[13:20:03.236]                         supportsMulticore(warn = TRUE)
[13:20:03.236]                       return(sequential(..., envir = envir))
[13:20:03.236]                     }
[13:20:03.236]                     oopts <- options(mc.cores = workers)
[13:20:03.236]                     on.exit(options(oopts))
[13:20:03.236]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.236]                       envir = envir)
[13:20:03.236]                     if (!future$lazy) 
[13:20:03.236]                       future <- run(future)
[13:20:03.236]                     invisible(future)
[13:20:03.236]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.236]                 }
[13:20:03.236]             }
[13:20:03.236]         }
[13:20:03.236]     })
[13:20:03.236]     if (TRUE) {
[13:20:03.236]         base::sink(type = "output", split = FALSE)
[13:20:03.236]         if (TRUE) {
[13:20:03.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.236]         }
[13:20:03.236]         else {
[13:20:03.236]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.236]         }
[13:20:03.236]         base::close(...future.stdout)
[13:20:03.236]         ...future.stdout <- NULL
[13:20:03.236]     }
[13:20:03.236]     ...future.result$conditions <- ...future.conditions
[13:20:03.236]     ...future.result$finished <- base::Sys.time()
[13:20:03.236]     ...future.result
[13:20:03.236] }
[13:20:03.239] assign_globals() ...
[13:20:03.239] List of 5
[13:20:03.239]  $ ...future.FUN            :function (x, ...)  
[13:20:03.239]  $ future.call.arguments    :List of 1
[13:20:03.239]   ..$ singular.ok: logi FALSE
[13:20:03.239]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.239]  $ ...future.elements_ii    :List of 1
[13:20:03.239]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.239]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:03.239]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.239]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.239]  $ ...future.seeds_ii       : NULL
[13:20:03.239]  $ ...future.globals.maxSize: NULL
[13:20:03.239]  - attr(*, "where")=List of 5
[13:20:03.239]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.239]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.239]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.239]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.239]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.239]  - attr(*, "resolved")= logi FALSE
[13:20:03.239]  - attr(*, "total_size")= num 5384
[13:20:03.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.239]  - attr(*, "already-done")= logi TRUE
[13:20:03.247] - reassign environment for ‘...future.FUN’
[13:20:03.247] - copied ‘...future.FUN’ to environment
[13:20:03.247] - copied ‘future.call.arguments’ to environment
[13:20:03.247] - copied ‘...future.elements_ii’ to environment
[13:20:03.248] - copied ‘...future.seeds_ii’ to environment
[13:20:03.248] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.248] assign_globals() ... done
[13:20:03.248] requestCore(): workers = 2
[13:20:03.250] MulticoreFuture started
[13:20:03.251] - Launch lazy future ... done
[13:20:03.252] run() for ‘MulticoreFuture’ ... done
[13:20:03.252] Created future:
[13:20:03.253] plan(): Setting new future strategy stack:
[13:20:03.253] List of future strategies:
[13:20:03.253] 1. sequential:
[13:20:03.253]    - args: function (..., envir = parent.frame())
[13:20:03.253]    - tweaked: FALSE
[13:20:03.253]    - call: NULL
[13:20:03.254] plan(): nbrOfWorkers() = 1
[13:20:03.260] plan(): Setting new future strategy stack:
[13:20:03.260] List of future strategies:
[13:20:03.260] 1. multicore:
[13:20:03.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.260]    - tweaked: FALSE
[13:20:03.260]    - call: plan(strategy)
[13:20:03.267] plan(): nbrOfWorkers() = 2
[13:20:03.253] MulticoreFuture:
[13:20:03.253] Label: ‘future_by-1’
[13:20:03.253] Expression:
[13:20:03.253] {
[13:20:03.253]     do.call(function(...) {
[13:20:03.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.253]             on.exit(options(oopts), add = TRUE)
[13:20:03.253]         }
[13:20:03.253]         {
[13:20:03.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.253]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.253]             })
[13:20:03.253]         }
[13:20:03.253]     }, args = future.call.arguments)
[13:20:03.253] }
[13:20:03.253] Lazy evaluation: FALSE
[13:20:03.253] Asynchronous evaluation: TRUE
[13:20:03.253] Local evaluation: TRUE
[13:20:03.253] Environment: R_GlobalEnv
[13:20:03.253] Capture standard output: TRUE
[13:20:03.253] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.253] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.253] Packages: 1 packages (‘stats’)
[13:20:03.253] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.253] Resolved: FALSE
[13:20:03.253] Value: <not collected>
[13:20:03.253] Conditions captured: <none>
[13:20:03.253] Early signaling: FALSE
[13:20:03.253] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.253] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.267] Chunk #1 of 2 ... DONE
[13:20:03.268] Chunk #2 of 2 ...
[13:20:03.268]  - Finding globals in 'X' for chunk #2 ...
[13:20:03.268] getGlobalsAndPackages() ...
[13:20:03.268] Searching for globals...
[13:20:03.269] 
[13:20:03.270] Searching for globals ... DONE
[13:20:03.270] - globals: [0] <none>
[13:20:03.270] getGlobalsAndPackages() ... DONE
[13:20:03.270]    + additional globals found: [n=0] 
[13:20:03.270]    + additional namespaces needed: [n=0] 
[13:20:03.271]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:03.271]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.271]  - seeds: <none>
[13:20:03.271]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.271] getGlobalsAndPackages() ...
[13:20:03.272] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.272] Resolving globals: FALSE
[13:20:03.272] Tweak future expression to call with '...' arguments ...
[13:20:03.272] {
[13:20:03.272]     do.call(function(...) {
[13:20:03.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.272]             on.exit(options(oopts), add = TRUE)
[13:20:03.272]         }
[13:20:03.272]         {
[13:20:03.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.272]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.272]             })
[13:20:03.272]         }
[13:20:03.272]     }, args = future.call.arguments)
[13:20:03.272] }
[13:20:03.273] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.273] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.274] 
[13:20:03.274] getGlobalsAndPackages() ... DONE
[13:20:03.275] run() for ‘Future’ ...
[13:20:03.275] - state: ‘created’
[13:20:03.275] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.280] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.280]   - Field: ‘label’
[13:20:03.280]   - Field: ‘local’
[13:20:03.281]   - Field: ‘owner’
[13:20:03.281]   - Field: ‘envir’
[13:20:03.281]   - Field: ‘workers’
[13:20:03.281]   - Field: ‘packages’
[13:20:03.281]   - Field: ‘gc’
[13:20:03.281]   - Field: ‘job’
[13:20:03.281]   - Field: ‘conditions’
[13:20:03.281]   - Field: ‘expr’
[13:20:03.282]   - Field: ‘uuid’
[13:20:03.282]   - Field: ‘seed’
[13:20:03.282]   - Field: ‘version’
[13:20:03.282]   - Field: ‘result’
[13:20:03.282]   - Field: ‘asynchronous’
[13:20:03.282]   - Field: ‘calls’
[13:20:03.282]   - Field: ‘globals’
[13:20:03.283]   - Field: ‘stdout’
[13:20:03.283]   - Field: ‘earlySignal’
[13:20:03.283]   - Field: ‘lazy’
[13:20:03.283]   - Field: ‘state’
[13:20:03.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.283] - Launch lazy future ...
[13:20:03.283] Packages needed by the future expression (n = 1): ‘stats’
[13:20:03.284] Packages needed by future strategies (n = 0): <none>
[13:20:03.284] {
[13:20:03.284]     {
[13:20:03.284]         {
[13:20:03.284]             ...future.startTime <- base::Sys.time()
[13:20:03.284]             {
[13:20:03.284]                 {
[13:20:03.284]                   {
[13:20:03.284]                     {
[13:20:03.284]                       {
[13:20:03.284]                         base::local({
[13:20:03.284]                           has_future <- base::requireNamespace("future", 
[13:20:03.284]                             quietly = TRUE)
[13:20:03.284]                           if (has_future) {
[13:20:03.284]                             ns <- base::getNamespace("future")
[13:20:03.284]                             version <- ns[[".package"]][["version"]]
[13:20:03.284]                             if (is.null(version)) 
[13:20:03.284]                               version <- utils::packageVersion("future")
[13:20:03.284]                           }
[13:20:03.284]                           else {
[13:20:03.284]                             version <- NULL
[13:20:03.284]                           }
[13:20:03.284]                           if (!has_future || version < "1.8.0") {
[13:20:03.284]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.284]                               "", base::R.version$version.string), 
[13:20:03.284]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:03.284]                                 base::R.version$platform, 8 * 
[13:20:03.284]                                   base::.Machine$sizeof.pointer), 
[13:20:03.284]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.284]                                 "release", "version")], collapse = " "), 
[13:20:03.284]                               hostname = base::Sys.info()[["nodename"]])
[13:20:03.284]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.284]                               info)
[13:20:03.284]                             info <- base::paste(info, collapse = "; ")
[13:20:03.284]                             if (!has_future) {
[13:20:03.284]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.284]                                 info)
[13:20:03.284]                             }
[13:20:03.284]                             else {
[13:20:03.284]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.284]                                 info, version)
[13:20:03.284]                             }
[13:20:03.284]                             base::stop(msg)
[13:20:03.284]                           }
[13:20:03.284]                         })
[13:20:03.284]                       }
[13:20:03.284]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.284]                       base::options(mc.cores = 1L)
[13:20:03.284]                     }
[13:20:03.284]                     base::local({
[13:20:03.284]                       for (pkg in "stats") {
[13:20:03.284]                         base::loadNamespace(pkg)
[13:20:03.284]                         base::library(pkg, character.only = TRUE)
[13:20:03.284]                       }
[13:20:03.284]                     })
[13:20:03.284]                   }
[13:20:03.284]                   options(future.plan = NULL)
[13:20:03.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.284]                 }
[13:20:03.284]                 ...future.workdir <- getwd()
[13:20:03.284]             }
[13:20:03.284]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.284]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.284]         }
[13:20:03.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.284]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.284]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.284]             base::names(...future.oldOptions))
[13:20:03.284]     }
[13:20:03.284]     if (FALSE) {
[13:20:03.284]     }
[13:20:03.284]     else {
[13:20:03.284]         if (TRUE) {
[13:20:03.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.284]                 open = "w")
[13:20:03.284]         }
[13:20:03.284]         else {
[13:20:03.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.284]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.284]         }
[13:20:03.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.284]             base::sink(type = "output", split = FALSE)
[13:20:03.284]             base::close(...future.stdout)
[13:20:03.284]         }, add = TRUE)
[13:20:03.284]     }
[13:20:03.284]     ...future.frame <- base::sys.nframe()
[13:20:03.284]     ...future.conditions <- base::list()
[13:20:03.284]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.284]     if (FALSE) {
[13:20:03.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.284]     }
[13:20:03.284]     ...future.result <- base::tryCatch({
[13:20:03.284]         base::withCallingHandlers({
[13:20:03.284]             ...future.value <- base::withVisible(base::local({
[13:20:03.284]                 withCallingHandlers({
[13:20:03.284]                   {
[13:20:03.284]                     do.call(function(...) {
[13:20:03.284]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.284]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.284]                         ...future.globals.maxSize)) {
[13:20:03.284]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.284]                         on.exit(options(oopts), add = TRUE)
[13:20:03.284]                       }
[13:20:03.284]                       {
[13:20:03.284]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.284]                           FUN = function(jj) {
[13:20:03.284]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.284]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.284]                           })
[13:20:03.284]                       }
[13:20:03.284]                     }, args = future.call.arguments)
[13:20:03.284]                   }
[13:20:03.284]                 }, immediateCondition = function(cond) {
[13:20:03.284]                   save_rds <- function (object, pathname, ...) 
[13:20:03.284]                   {
[13:20:03.284]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.284]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.284]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.284]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.284]                         fi_tmp[["mtime"]])
[13:20:03.284]                     }
[13:20:03.284]                     tryCatch({
[13:20:03.284]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.284]                     }, error = function(ex) {
[13:20:03.284]                       msg <- conditionMessage(ex)
[13:20:03.284]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.284]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.284]                         fi_tmp[["mtime"]], msg)
[13:20:03.284]                       ex$message <- msg
[13:20:03.284]                       stop(ex)
[13:20:03.284]                     })
[13:20:03.284]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.284]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.284]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.284]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.284]                       fi <- file.info(pathname)
[13:20:03.284]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.284]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.284]                         fi[["size"]], fi[["mtime"]])
[13:20:03.284]                       stop(msg)
[13:20:03.284]                     }
[13:20:03.284]                     invisible(pathname)
[13:20:03.284]                   }
[13:20:03.284]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.284]                     rootPath = tempdir()) 
[13:20:03.284]                   {
[13:20:03.284]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.284]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.284]                       tmpdir = path, fileext = ".rds")
[13:20:03.284]                     save_rds(obj, file)
[13:20:03.284]                   }
[13:20:03.284]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.284]                   {
[13:20:03.284]                     inherits <- base::inherits
[13:20:03.284]                     invokeRestart <- base::invokeRestart
[13:20:03.284]                     is.null <- base::is.null
[13:20:03.284]                     muffled <- FALSE
[13:20:03.284]                     if (inherits(cond, "message")) {
[13:20:03.284]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.284]                       if (muffled) 
[13:20:03.284]                         invokeRestart("muffleMessage")
[13:20:03.284]                     }
[13:20:03.284]                     else if (inherits(cond, "warning")) {
[13:20:03.284]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.284]                       if (muffled) 
[13:20:03.284]                         invokeRestart("muffleWarning")
[13:20:03.284]                     }
[13:20:03.284]                     else if (inherits(cond, "condition")) {
[13:20:03.284]                       if (!is.null(pattern)) {
[13:20:03.284]                         computeRestarts <- base::computeRestarts
[13:20:03.284]                         grepl <- base::grepl
[13:20:03.284]                         restarts <- computeRestarts(cond)
[13:20:03.284]                         for (restart in restarts) {
[13:20:03.284]                           name <- restart$name
[13:20:03.284]                           if (is.null(name)) 
[13:20:03.284]                             next
[13:20:03.284]                           if (!grepl(pattern, name)) 
[13:20:03.284]                             next
[13:20:03.284]                           invokeRestart(restart)
[13:20:03.284]                           muffled <- TRUE
[13:20:03.284]                           break
[13:20:03.284]                         }
[13:20:03.284]                       }
[13:20:03.284]                     }
[13:20:03.284]                     invisible(muffled)
[13:20:03.284]                   }
[13:20:03.284]                   muffleCondition(cond)
[13:20:03.284]                 })
[13:20:03.284]             }))
[13:20:03.284]             future::FutureResult(value = ...future.value$value, 
[13:20:03.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.284]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.284]                     ...future.globalenv.names))
[13:20:03.284]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.284]         }, condition = base::local({
[13:20:03.284]             c <- base::c
[13:20:03.284]             inherits <- base::inherits
[13:20:03.284]             invokeRestart <- base::invokeRestart
[13:20:03.284]             length <- base::length
[13:20:03.284]             list <- base::list
[13:20:03.284]             seq.int <- base::seq.int
[13:20:03.284]             signalCondition <- base::signalCondition
[13:20:03.284]             sys.calls <- base::sys.calls
[13:20:03.284]             `[[` <- base::`[[`
[13:20:03.284]             `+` <- base::`+`
[13:20:03.284]             `<<-` <- base::`<<-`
[13:20:03.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.284]                   3L)]
[13:20:03.284]             }
[13:20:03.284]             function(cond) {
[13:20:03.284]                 is_error <- inherits(cond, "error")
[13:20:03.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.284]                   NULL)
[13:20:03.284]                 if (is_error) {
[13:20:03.284]                   sessionInformation <- function() {
[13:20:03.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.284]                       search = base::search(), system = base::Sys.info())
[13:20:03.284]                   }
[13:20:03.284]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.284]                     cond$call), session = sessionInformation(), 
[13:20:03.284]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.284]                   signalCondition(cond)
[13:20:03.284]                 }
[13:20:03.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.284]                 "immediateCondition"))) {
[13:20:03.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.284]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.284]                   if (TRUE && !signal) {
[13:20:03.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.284]                     {
[13:20:03.284]                       inherits <- base::inherits
[13:20:03.284]                       invokeRestart <- base::invokeRestart
[13:20:03.284]                       is.null <- base::is.null
[13:20:03.284]                       muffled <- FALSE
[13:20:03.284]                       if (inherits(cond, "message")) {
[13:20:03.284]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.284]                         if (muffled) 
[13:20:03.284]                           invokeRestart("muffleMessage")
[13:20:03.284]                       }
[13:20:03.284]                       else if (inherits(cond, "warning")) {
[13:20:03.284]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.284]                         if (muffled) 
[13:20:03.284]                           invokeRestart("muffleWarning")
[13:20:03.284]                       }
[13:20:03.284]                       else if (inherits(cond, "condition")) {
[13:20:03.284]                         if (!is.null(pattern)) {
[13:20:03.284]                           computeRestarts <- base::computeRestarts
[13:20:03.284]                           grepl <- base::grepl
[13:20:03.284]                           restarts <- computeRestarts(cond)
[13:20:03.284]                           for (restart in restarts) {
[13:20:03.284]                             name <- restart$name
[13:20:03.284]                             if (is.null(name)) 
[13:20:03.284]                               next
[13:20:03.284]                             if (!grepl(pattern, name)) 
[13:20:03.284]                               next
[13:20:03.284]                             invokeRestart(restart)
[13:20:03.284]                             muffled <- TRUE
[13:20:03.284]                             break
[13:20:03.284]                           }
[13:20:03.284]                         }
[13:20:03.284]                       }
[13:20:03.284]                       invisible(muffled)
[13:20:03.284]                     }
[13:20:03.284]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.284]                   }
[13:20:03.284]                 }
[13:20:03.284]                 else {
[13:20:03.284]                   if (TRUE) {
[13:20:03.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.284]                     {
[13:20:03.284]                       inherits <- base::inherits
[13:20:03.284]                       invokeRestart <- base::invokeRestart
[13:20:03.284]                       is.null <- base::is.null
[13:20:03.284]                       muffled <- FALSE
[13:20:03.284]                       if (inherits(cond, "message")) {
[13:20:03.284]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.284]                         if (muffled) 
[13:20:03.284]                           invokeRestart("muffleMessage")
[13:20:03.284]                       }
[13:20:03.284]                       else if (inherits(cond, "warning")) {
[13:20:03.284]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.284]                         if (muffled) 
[13:20:03.284]                           invokeRestart("muffleWarning")
[13:20:03.284]                       }
[13:20:03.284]                       else if (inherits(cond, "condition")) {
[13:20:03.284]                         if (!is.null(pattern)) {
[13:20:03.284]                           computeRestarts <- base::computeRestarts
[13:20:03.284]                           grepl <- base::grepl
[13:20:03.284]                           restarts <- computeRestarts(cond)
[13:20:03.284]                           for (restart in restarts) {
[13:20:03.284]                             name <- restart$name
[13:20:03.284]                             if (is.null(name)) 
[13:20:03.284]                               next
[13:20:03.284]                             if (!grepl(pattern, name)) 
[13:20:03.284]                               next
[13:20:03.284]                             invokeRestart(restart)
[13:20:03.284]                             muffled <- TRUE
[13:20:03.284]                             break
[13:20:03.284]                           }
[13:20:03.284]                         }
[13:20:03.284]                       }
[13:20:03.284]                       invisible(muffled)
[13:20:03.284]                     }
[13:20:03.284]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.284]                   }
[13:20:03.284]                 }
[13:20:03.284]             }
[13:20:03.284]         }))
[13:20:03.284]     }, error = function(ex) {
[13:20:03.284]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.284]                 ...future.rng), started = ...future.startTime, 
[13:20:03.284]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.284]             version = "1.8"), class = "FutureResult")
[13:20:03.284]     }, finally = {
[13:20:03.284]         if (!identical(...future.workdir, getwd())) 
[13:20:03.284]             setwd(...future.workdir)
[13:20:03.284]         {
[13:20:03.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.284]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.284]             }
[13:20:03.284]             base::options(...future.oldOptions)
[13:20:03.284]             if (.Platform$OS.type == "windows") {
[13:20:03.284]                 old_names <- names(...future.oldEnvVars)
[13:20:03.284]                 envs <- base::Sys.getenv()
[13:20:03.284]                 names <- names(envs)
[13:20:03.284]                 common <- intersect(names, old_names)
[13:20:03.284]                 added <- setdiff(names, old_names)
[13:20:03.284]                 removed <- setdiff(old_names, names)
[13:20:03.284]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.284]                   envs[common]]
[13:20:03.284]                 NAMES <- toupper(changed)
[13:20:03.284]                 args <- list()
[13:20:03.284]                 for (kk in seq_along(NAMES)) {
[13:20:03.284]                   name <- changed[[kk]]
[13:20:03.284]                   NAME <- NAMES[[kk]]
[13:20:03.284]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.284]                     next
[13:20:03.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.284]                 }
[13:20:03.284]                 NAMES <- toupper(added)
[13:20:03.284]                 for (kk in seq_along(NAMES)) {
[13:20:03.284]                   name <- added[[kk]]
[13:20:03.284]                   NAME <- NAMES[[kk]]
[13:20:03.284]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.284]                     next
[13:20:03.284]                   args[[name]] <- ""
[13:20:03.284]                 }
[13:20:03.284]                 NAMES <- toupper(removed)
[13:20:03.284]                 for (kk in seq_along(NAMES)) {
[13:20:03.284]                   name <- removed[[kk]]
[13:20:03.284]                   NAME <- NAMES[[kk]]
[13:20:03.284]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.284]                     next
[13:20:03.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.284]                 }
[13:20:03.284]                 if (length(args) > 0) 
[13:20:03.284]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.284]             }
[13:20:03.284]             else {
[13:20:03.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.284]             }
[13:20:03.284]             {
[13:20:03.284]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.284]                   0L) {
[13:20:03.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.284]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.284]                   base::options(opts)
[13:20:03.284]                 }
[13:20:03.284]                 {
[13:20:03.284]                   {
[13:20:03.284]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.284]                     NULL
[13:20:03.284]                   }
[13:20:03.284]                   options(future.plan = NULL)
[13:20:03.284]                   if (is.na(NA_character_)) 
[13:20:03.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.284]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.284]                     envir = parent.frame()) 
[13:20:03.284]                   {
[13:20:03.284]                     default_workers <- missing(workers)
[13:20:03.284]                     if (is.function(workers)) 
[13:20:03.284]                       workers <- workers()
[13:20:03.284]                     workers <- structure(as.integer(workers), 
[13:20:03.284]                       class = class(workers))
[13:20:03.284]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.284]                       1L)
[13:20:03.284]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.284]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.284]                       if (default_workers) 
[13:20:03.284]                         supportsMulticore(warn = TRUE)
[13:20:03.284]                       return(sequential(..., envir = envir))
[13:20:03.284]                     }
[13:20:03.284]                     oopts <- options(mc.cores = workers)
[13:20:03.284]                     on.exit(options(oopts))
[13:20:03.284]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.284]                       envir = envir)
[13:20:03.284]                     if (!future$lazy) 
[13:20:03.284]                       future <- run(future)
[13:20:03.284]                     invisible(future)
[13:20:03.284]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.284]                 }
[13:20:03.284]             }
[13:20:03.284]         }
[13:20:03.284]     })
[13:20:03.284]     if (TRUE) {
[13:20:03.284]         base::sink(type = "output", split = FALSE)
[13:20:03.284]         if (TRUE) {
[13:20:03.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.284]         }
[13:20:03.284]         else {
[13:20:03.284]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.284]         }
[13:20:03.284]         base::close(...future.stdout)
[13:20:03.284]         ...future.stdout <- NULL
[13:20:03.284]     }
[13:20:03.284]     ...future.result$conditions <- ...future.conditions
[13:20:03.284]     ...future.result$finished <- base::Sys.time()
[13:20:03.284]     ...future.result
[13:20:03.284] }
[13:20:03.288] assign_globals() ...
[13:20:03.288] List of 5
[13:20:03.288]  $ ...future.FUN            :function (x, ...)  
[13:20:03.288]  $ future.call.arguments    :List of 1
[13:20:03.288]   ..$ singular.ok: logi FALSE
[13:20:03.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.288]  $ ...future.elements_ii    :List of 2
[13:20:03.288]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.288]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:03.288]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.288]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:03.288]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.288]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:03.288]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.288]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:03.288]  $ ...future.seeds_ii       : NULL
[13:20:03.288]  $ ...future.globals.maxSize: NULL
[13:20:03.288]  - attr(*, "where")=List of 5
[13:20:03.288]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.288]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.288]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.288]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.288]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.288]  - attr(*, "resolved")= logi FALSE
[13:20:03.288]  - attr(*, "total_size")= num 5384
[13:20:03.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.288]  - attr(*, "already-done")= logi TRUE
[13:20:03.300] - reassign environment for ‘...future.FUN’
[13:20:03.300] - copied ‘...future.FUN’ to environment
[13:20:03.300] - copied ‘future.call.arguments’ to environment
[13:20:03.301] - copied ‘...future.elements_ii’ to environment
[13:20:03.301] - copied ‘...future.seeds_ii’ to environment
[13:20:03.301] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.301] assign_globals() ... done
[13:20:03.301] requestCore(): workers = 2
[13:20:03.304] MulticoreFuture started
[13:20:03.304] - Launch lazy future ... done
[13:20:03.305] run() for ‘MulticoreFuture’ ... done
[13:20:03.306] Created future:
[13:20:03.306] plan(): Setting new future strategy stack:
[13:20:03.306] List of future strategies:
[13:20:03.306] 1. sequential:
[13:20:03.306]    - args: function (..., envir = parent.frame())
[13:20:03.306]    - tweaked: FALSE
[13:20:03.306]    - call: NULL
[13:20:03.307] plan(): nbrOfWorkers() = 1
[13:20:03.315] plan(): Setting new future strategy stack:
[13:20:03.315] List of future strategies:
[13:20:03.315] 1. multicore:
[13:20:03.315]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.315]    - tweaked: FALSE
[13:20:03.315]    - call: plan(strategy)
[13:20:03.321] plan(): nbrOfWorkers() = 2
[13:20:03.306] MulticoreFuture:
[13:20:03.306] Label: ‘future_by-2’
[13:20:03.306] Expression:
[13:20:03.306] {
[13:20:03.306]     do.call(function(...) {
[13:20:03.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.306]             on.exit(options(oopts), add = TRUE)
[13:20:03.306]         }
[13:20:03.306]         {
[13:20:03.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.306]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.306]             })
[13:20:03.306]         }
[13:20:03.306]     }, args = future.call.arguments)
[13:20:03.306] }
[13:20:03.306] Lazy evaluation: FALSE
[13:20:03.306] Asynchronous evaluation: TRUE
[13:20:03.306] Local evaluation: TRUE
[13:20:03.306] Environment: R_GlobalEnv
[13:20:03.306] Capture standard output: TRUE
[13:20:03.306] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.306] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.306] Packages: 1 packages (‘stats’)
[13:20:03.306] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.306] Resolved: FALSE
[13:20:03.306] Value: <not collected>
[13:20:03.306] Conditions captured: <none>
[13:20:03.306] Early signaling: FALSE
[13:20:03.306] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.306] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.321] Chunk #2 of 2 ... DONE
[13:20:03.321] Launching 2 futures (chunks) ... DONE
[13:20:03.322] Resolving 2 futures (chunks) ...
[13:20:03.322] resolve() on list ...
[13:20:03.322]  recursive: 0
[13:20:03.322]  length: 2
[13:20:03.323] 
[13:20:03.323] Future #1
[13:20:03.323] result() for MulticoreFuture ...
[13:20:03.325] result() for MulticoreFuture ...
[13:20:03.325] result() for MulticoreFuture ... done
[13:20:03.325] result() for MulticoreFuture ... done
[13:20:03.325] result() for MulticoreFuture ...
[13:20:03.326] result() for MulticoreFuture ... done
[13:20:03.326] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:03.326] - nx: 2
[13:20:03.326] - relay: TRUE
[13:20:03.326] - stdout: TRUE
[13:20:03.326] - signal: TRUE
[13:20:03.326] - resignal: FALSE
[13:20:03.327] - force: TRUE
[13:20:03.327] - relayed: [n=2] FALSE, FALSE
[13:20:03.327] - queued futures: [n=2] FALSE, FALSE
[13:20:03.327]  - until=1
[13:20:03.327]  - relaying element #1
[13:20:03.327] result() for MulticoreFuture ...
[13:20:03.327] result() for MulticoreFuture ... done
[13:20:03.328] result() for MulticoreFuture ...
[13:20:03.328] result() for MulticoreFuture ... done
[13:20:03.328] result() for MulticoreFuture ...
[13:20:03.328] result() for MulticoreFuture ... done
[13:20:03.328] result() for MulticoreFuture ...
[13:20:03.328] result() for MulticoreFuture ... done
[13:20:03.329] - relayed: [n=2] TRUE, FALSE
[13:20:03.329] - queued futures: [n=2] TRUE, FALSE
[13:20:03.329] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:03.329]  length: 1 (resolved future 1)
[13:20:03.329] Future #2
[13:20:03.330] result() for MulticoreFuture ...
[13:20:03.331] result() for MulticoreFuture ...
[13:20:03.331] result() for MulticoreFuture ... done
[13:20:03.331] result() for MulticoreFuture ... done
[13:20:03.332] result() for MulticoreFuture ...
[13:20:03.332] result() for MulticoreFuture ... done
[13:20:03.332] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:03.332] - nx: 2
[13:20:03.332] - relay: TRUE
[13:20:03.332] - stdout: TRUE
[13:20:03.332] - signal: TRUE
[13:20:03.332] - resignal: FALSE
[13:20:03.332] - force: TRUE
[13:20:03.333] - relayed: [n=2] TRUE, FALSE
[13:20:03.333] - queued futures: [n=2] TRUE, FALSE
[13:20:03.333]  - until=2
[13:20:03.333]  - relaying element #2
[13:20:03.333] result() for MulticoreFuture ...
[13:20:03.333] result() for MulticoreFuture ... done
[13:20:03.333] result() for MulticoreFuture ...
[13:20:03.333] result() for MulticoreFuture ... done
[13:20:03.334] result() for MulticoreFuture ...
[13:20:03.334] result() for MulticoreFuture ... done
[13:20:03.334] result() for MulticoreFuture ...
[13:20:03.334] result() for MulticoreFuture ... done
[13:20:03.334] - relayed: [n=2] TRUE, TRUE
[13:20:03.334] - queued futures: [n=2] TRUE, TRUE
[13:20:03.334] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:03.334]  length: 0 (resolved future 2)
[13:20:03.334] Relaying remaining futures
[13:20:03.334] signalConditionsASAP(NULL, pos=0) ...
[13:20:03.335] - nx: 2
[13:20:03.335] - relay: TRUE
[13:20:03.335] - stdout: TRUE
[13:20:03.335] - signal: TRUE
[13:20:03.335] - resignal: FALSE
[13:20:03.335] - force: TRUE
[13:20:03.335] - relayed: [n=2] TRUE, TRUE
[13:20:03.335] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:03.335] - relayed: [n=2] TRUE, TRUE
[13:20:03.336] - queued futures: [n=2] TRUE, TRUE
[13:20:03.336] signalConditionsASAP(NULL, pos=0) ... done
[13:20:03.336] resolve() on list ... DONE
[13:20:03.336] result() for MulticoreFuture ...
[13:20:03.336] result() for MulticoreFuture ... done
[13:20:03.336] result() for MulticoreFuture ...
[13:20:03.336] result() for MulticoreFuture ... done
[13:20:03.336] result() for MulticoreFuture ...
[13:20:03.337] result() for MulticoreFuture ... done
[13:20:03.337] result() for MulticoreFuture ...
[13:20:03.337] result() for MulticoreFuture ... done
[13:20:03.337]  - Number of value chunks collected: 2
[13:20:03.337] Resolving 2 futures (chunks) ... DONE
[13:20:03.337] Reducing values from 2 chunks ...
[13:20:03.337]  - Number of values collected after concatenation: 3
[13:20:03.337]  - Number of values expected: 3
[13:20:03.337] Reducing values from 2 chunks ... DONE
[13:20:03.337] future_lapply() ... DONE
[13:20:03.338] future_by_internal() ... DONE
[13:20:03.345] future_by_internal() ...
[13:20:03.346] future_lapply() ...
[13:20:03.351] Number of chunks: 2
[13:20:03.351] getGlobalsAndPackagesXApply() ...
[13:20:03.351]  - future.globals: TRUE
[13:20:03.351] getGlobalsAndPackages() ...
[13:20:03.351] Searching for globals...
[13:20:03.353] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:03.353] Searching for globals ... DONE
[13:20:03.354] Resolving globals: FALSE
[13:20:03.354] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:20:03.354] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:20:03.355] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:03.355] - packages: [1] ‘stats’
[13:20:03.355] getGlobalsAndPackages() ... DONE
[13:20:03.355]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:03.355]  - needed namespaces: [n=1] ‘stats’
[13:20:03.355] Finding globals ... DONE
[13:20:03.355]  - use_args: TRUE
[13:20:03.355]  - Getting '...' globals ...
[13:20:03.356] resolve() on list ...
[13:20:03.356]  recursive: 0
[13:20:03.356]  length: 1
[13:20:03.356]  elements: ‘...’
[13:20:03.356]  length: 0 (resolved future 1)
[13:20:03.356] resolve() on list ... DONE
[13:20:03.356]    - '...' content: [n=0] 
[13:20:03.356] List of 1
[13:20:03.356]  $ ...: list()
[13:20:03.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.356]  - attr(*, "where")=List of 1
[13:20:03.356]   ..$ ...:<environment: 0x55aceee6aa90> 
[13:20:03.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.356]  - attr(*, "resolved")= logi TRUE
[13:20:03.356]  - attr(*, "total_size")= num NA
[13:20:03.359]  - Getting '...' globals ... DONE
[13:20:03.359] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:20:03.359] List of 4
[13:20:03.359]  $ ...future.FUN:function (x)  
[13:20:03.359]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:03.359]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.359]  $ ...          : list()
[13:20:03.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.359]  - attr(*, "where")=List of 4
[13:20:03.359]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:03.359]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:20:03.359]   ..$ wool         :<environment: R_EmptyEnv> 
[13:20:03.359]   ..$ ...          :<environment: 0x55aceee6aa90> 
[13:20:03.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.359]  - attr(*, "resolved")= logi FALSE
[13:20:03.359]  - attr(*, "total_size")= num 2320
[13:20:03.366] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:03.366] getGlobalsAndPackagesXApply() ... DONE
[13:20:03.366] Number of futures (= number of chunks): 2
[13:20:03.366] Launching 2 futures (chunks) ...
[13:20:03.367] Chunk #1 of 2 ...
[13:20:03.367]  - Finding globals in 'X' for chunk #1 ...
[13:20:03.367] getGlobalsAndPackages() ...
[13:20:03.367] Searching for globals...
[13:20:03.368] 
[13:20:03.368] Searching for globals ... DONE
[13:20:03.368] - globals: [0] <none>
[13:20:03.368] getGlobalsAndPackages() ... DONE
[13:20:03.368]    + additional globals found: [n=0] 
[13:20:03.369]    + additional namespaces needed: [n=0] 
[13:20:03.369]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:03.369]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.369]  - seeds: <none>
[13:20:03.369]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.369] getGlobalsAndPackages() ...
[13:20:03.370] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.370] Resolving globals: FALSE
[13:20:03.370] Tweak future expression to call with '...' arguments ...
[13:20:03.370] {
[13:20:03.370]     do.call(function(...) {
[13:20:03.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.370]             on.exit(options(oopts), add = TRUE)
[13:20:03.370]         }
[13:20:03.370]         {
[13:20:03.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.370]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.370]             })
[13:20:03.370]         }
[13:20:03.370]     }, args = future.call.arguments)
[13:20:03.370] }
[13:20:03.371] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.371] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.372] 
[13:20:03.372] getGlobalsAndPackages() ... DONE
[13:20:03.372] run() for ‘Future’ ...
[13:20:03.373] - state: ‘created’
[13:20:03.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.378]   - Field: ‘label’
[13:20:03.378]   - Field: ‘local’
[13:20:03.378]   - Field: ‘owner’
[13:20:03.378]   - Field: ‘envir’
[13:20:03.379]   - Field: ‘workers’
[13:20:03.379]   - Field: ‘packages’
[13:20:03.379]   - Field: ‘gc’
[13:20:03.379]   - Field: ‘job’
[13:20:03.379]   - Field: ‘conditions’
[13:20:03.379]   - Field: ‘expr’
[13:20:03.379]   - Field: ‘uuid’
[13:20:03.379]   - Field: ‘seed’
[13:20:03.379]   - Field: ‘version’
[13:20:03.379]   - Field: ‘result’
[13:20:03.380]   - Field: ‘asynchronous’
[13:20:03.380]   - Field: ‘calls’
[13:20:03.380]   - Field: ‘globals’
[13:20:03.380]   - Field: ‘stdout’
[13:20:03.380]   - Field: ‘earlySignal’
[13:20:03.380]   - Field: ‘lazy’
[13:20:03.380]   - Field: ‘state’
[13:20:03.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.380] - Launch lazy future ...
[13:20:03.381] Packages needed by the future expression (n = 1): ‘stats’
[13:20:03.381] Packages needed by future strategies (n = 0): <none>
[13:20:03.381] {
[13:20:03.381]     {
[13:20:03.381]         {
[13:20:03.381]             ...future.startTime <- base::Sys.time()
[13:20:03.381]             {
[13:20:03.381]                 {
[13:20:03.381]                   {
[13:20:03.381]                     {
[13:20:03.381]                       {
[13:20:03.381]                         base::local({
[13:20:03.381]                           has_future <- base::requireNamespace("future", 
[13:20:03.381]                             quietly = TRUE)
[13:20:03.381]                           if (has_future) {
[13:20:03.381]                             ns <- base::getNamespace("future")
[13:20:03.381]                             version <- ns[[".package"]][["version"]]
[13:20:03.381]                             if (is.null(version)) 
[13:20:03.381]                               version <- utils::packageVersion("future")
[13:20:03.381]                           }
[13:20:03.381]                           else {
[13:20:03.381]                             version <- NULL
[13:20:03.381]                           }
[13:20:03.381]                           if (!has_future || version < "1.8.0") {
[13:20:03.381]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.381]                               "", base::R.version$version.string), 
[13:20:03.381]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:03.381]                                 base::R.version$platform, 8 * 
[13:20:03.381]                                   base::.Machine$sizeof.pointer), 
[13:20:03.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.381]                                 "release", "version")], collapse = " "), 
[13:20:03.381]                               hostname = base::Sys.info()[["nodename"]])
[13:20:03.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.381]                               info)
[13:20:03.381]                             info <- base::paste(info, collapse = "; ")
[13:20:03.381]                             if (!has_future) {
[13:20:03.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.381]                                 info)
[13:20:03.381]                             }
[13:20:03.381]                             else {
[13:20:03.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.381]                                 info, version)
[13:20:03.381]                             }
[13:20:03.381]                             base::stop(msg)
[13:20:03.381]                           }
[13:20:03.381]                         })
[13:20:03.381]                       }
[13:20:03.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.381]                       base::options(mc.cores = 1L)
[13:20:03.381]                     }
[13:20:03.381]                     base::local({
[13:20:03.381]                       for (pkg in "stats") {
[13:20:03.381]                         base::loadNamespace(pkg)
[13:20:03.381]                         base::library(pkg, character.only = TRUE)
[13:20:03.381]                       }
[13:20:03.381]                     })
[13:20:03.381]                   }
[13:20:03.381]                   options(future.plan = NULL)
[13:20:03.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.381]                 }
[13:20:03.381]                 ...future.workdir <- getwd()
[13:20:03.381]             }
[13:20:03.381]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.381]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.381]         }
[13:20:03.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.381]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.381]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.381]             base::names(...future.oldOptions))
[13:20:03.381]     }
[13:20:03.381]     if (FALSE) {
[13:20:03.381]     }
[13:20:03.381]     else {
[13:20:03.381]         if (TRUE) {
[13:20:03.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.381]                 open = "w")
[13:20:03.381]         }
[13:20:03.381]         else {
[13:20:03.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.381]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.381]         }
[13:20:03.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.381]             base::sink(type = "output", split = FALSE)
[13:20:03.381]             base::close(...future.stdout)
[13:20:03.381]         }, add = TRUE)
[13:20:03.381]     }
[13:20:03.381]     ...future.frame <- base::sys.nframe()
[13:20:03.381]     ...future.conditions <- base::list()
[13:20:03.381]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.381]     if (FALSE) {
[13:20:03.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.381]     }
[13:20:03.381]     ...future.result <- base::tryCatch({
[13:20:03.381]         base::withCallingHandlers({
[13:20:03.381]             ...future.value <- base::withVisible(base::local({
[13:20:03.381]                 withCallingHandlers({
[13:20:03.381]                   {
[13:20:03.381]                     do.call(function(...) {
[13:20:03.381]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.381]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.381]                         ...future.globals.maxSize)) {
[13:20:03.381]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.381]                         on.exit(options(oopts), add = TRUE)
[13:20:03.381]                       }
[13:20:03.381]                       {
[13:20:03.381]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.381]                           FUN = function(jj) {
[13:20:03.381]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.381]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.381]                           })
[13:20:03.381]                       }
[13:20:03.381]                     }, args = future.call.arguments)
[13:20:03.381]                   }
[13:20:03.381]                 }, immediateCondition = function(cond) {
[13:20:03.381]                   save_rds <- function (object, pathname, ...) 
[13:20:03.381]                   {
[13:20:03.381]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.381]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.381]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.381]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.381]                         fi_tmp[["mtime"]])
[13:20:03.381]                     }
[13:20:03.381]                     tryCatch({
[13:20:03.381]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.381]                     }, error = function(ex) {
[13:20:03.381]                       msg <- conditionMessage(ex)
[13:20:03.381]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.381]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.381]                         fi_tmp[["mtime"]], msg)
[13:20:03.381]                       ex$message <- msg
[13:20:03.381]                       stop(ex)
[13:20:03.381]                     })
[13:20:03.381]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.381]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.381]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.381]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.381]                       fi <- file.info(pathname)
[13:20:03.381]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.381]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.381]                         fi[["size"]], fi[["mtime"]])
[13:20:03.381]                       stop(msg)
[13:20:03.381]                     }
[13:20:03.381]                     invisible(pathname)
[13:20:03.381]                   }
[13:20:03.381]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.381]                     rootPath = tempdir()) 
[13:20:03.381]                   {
[13:20:03.381]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.381]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.381]                       tmpdir = path, fileext = ".rds")
[13:20:03.381]                     save_rds(obj, file)
[13:20:03.381]                   }
[13:20:03.381]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.381]                   {
[13:20:03.381]                     inherits <- base::inherits
[13:20:03.381]                     invokeRestart <- base::invokeRestart
[13:20:03.381]                     is.null <- base::is.null
[13:20:03.381]                     muffled <- FALSE
[13:20:03.381]                     if (inherits(cond, "message")) {
[13:20:03.381]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.381]                       if (muffled) 
[13:20:03.381]                         invokeRestart("muffleMessage")
[13:20:03.381]                     }
[13:20:03.381]                     else if (inherits(cond, "warning")) {
[13:20:03.381]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.381]                       if (muffled) 
[13:20:03.381]                         invokeRestart("muffleWarning")
[13:20:03.381]                     }
[13:20:03.381]                     else if (inherits(cond, "condition")) {
[13:20:03.381]                       if (!is.null(pattern)) {
[13:20:03.381]                         computeRestarts <- base::computeRestarts
[13:20:03.381]                         grepl <- base::grepl
[13:20:03.381]                         restarts <- computeRestarts(cond)
[13:20:03.381]                         for (restart in restarts) {
[13:20:03.381]                           name <- restart$name
[13:20:03.381]                           if (is.null(name)) 
[13:20:03.381]                             next
[13:20:03.381]                           if (!grepl(pattern, name)) 
[13:20:03.381]                             next
[13:20:03.381]                           invokeRestart(restart)
[13:20:03.381]                           muffled <- TRUE
[13:20:03.381]                           break
[13:20:03.381]                         }
[13:20:03.381]                       }
[13:20:03.381]                     }
[13:20:03.381]                     invisible(muffled)
[13:20:03.381]                   }
[13:20:03.381]                   muffleCondition(cond)
[13:20:03.381]                 })
[13:20:03.381]             }))
[13:20:03.381]             future::FutureResult(value = ...future.value$value, 
[13:20:03.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.381]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.381]                     ...future.globalenv.names))
[13:20:03.381]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.381]         }, condition = base::local({
[13:20:03.381]             c <- base::c
[13:20:03.381]             inherits <- base::inherits
[13:20:03.381]             invokeRestart <- base::invokeRestart
[13:20:03.381]             length <- base::length
[13:20:03.381]             list <- base::list
[13:20:03.381]             seq.int <- base::seq.int
[13:20:03.381]             signalCondition <- base::signalCondition
[13:20:03.381]             sys.calls <- base::sys.calls
[13:20:03.381]             `[[` <- base::`[[`
[13:20:03.381]             `+` <- base::`+`
[13:20:03.381]             `<<-` <- base::`<<-`
[13:20:03.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.381]                   3L)]
[13:20:03.381]             }
[13:20:03.381]             function(cond) {
[13:20:03.381]                 is_error <- inherits(cond, "error")
[13:20:03.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.381]                   NULL)
[13:20:03.381]                 if (is_error) {
[13:20:03.381]                   sessionInformation <- function() {
[13:20:03.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.381]                       search = base::search(), system = base::Sys.info())
[13:20:03.381]                   }
[13:20:03.381]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.381]                     cond$call), session = sessionInformation(), 
[13:20:03.381]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.381]                   signalCondition(cond)
[13:20:03.381]                 }
[13:20:03.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.381]                 "immediateCondition"))) {
[13:20:03.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.381]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.381]                   if (TRUE && !signal) {
[13:20:03.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.381]                     {
[13:20:03.381]                       inherits <- base::inherits
[13:20:03.381]                       invokeRestart <- base::invokeRestart
[13:20:03.381]                       is.null <- base::is.null
[13:20:03.381]                       muffled <- FALSE
[13:20:03.381]                       if (inherits(cond, "message")) {
[13:20:03.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.381]                         if (muffled) 
[13:20:03.381]                           invokeRestart("muffleMessage")
[13:20:03.381]                       }
[13:20:03.381]                       else if (inherits(cond, "warning")) {
[13:20:03.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.381]                         if (muffled) 
[13:20:03.381]                           invokeRestart("muffleWarning")
[13:20:03.381]                       }
[13:20:03.381]                       else if (inherits(cond, "condition")) {
[13:20:03.381]                         if (!is.null(pattern)) {
[13:20:03.381]                           computeRestarts <- base::computeRestarts
[13:20:03.381]                           grepl <- base::grepl
[13:20:03.381]                           restarts <- computeRestarts(cond)
[13:20:03.381]                           for (restart in restarts) {
[13:20:03.381]                             name <- restart$name
[13:20:03.381]                             if (is.null(name)) 
[13:20:03.381]                               next
[13:20:03.381]                             if (!grepl(pattern, name)) 
[13:20:03.381]                               next
[13:20:03.381]                             invokeRestart(restart)
[13:20:03.381]                             muffled <- TRUE
[13:20:03.381]                             break
[13:20:03.381]                           }
[13:20:03.381]                         }
[13:20:03.381]                       }
[13:20:03.381]                       invisible(muffled)
[13:20:03.381]                     }
[13:20:03.381]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.381]                   }
[13:20:03.381]                 }
[13:20:03.381]                 else {
[13:20:03.381]                   if (TRUE) {
[13:20:03.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.381]                     {
[13:20:03.381]                       inherits <- base::inherits
[13:20:03.381]                       invokeRestart <- base::invokeRestart
[13:20:03.381]                       is.null <- base::is.null
[13:20:03.381]                       muffled <- FALSE
[13:20:03.381]                       if (inherits(cond, "message")) {
[13:20:03.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.381]                         if (muffled) 
[13:20:03.381]                           invokeRestart("muffleMessage")
[13:20:03.381]                       }
[13:20:03.381]                       else if (inherits(cond, "warning")) {
[13:20:03.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.381]                         if (muffled) 
[13:20:03.381]                           invokeRestart("muffleWarning")
[13:20:03.381]                       }
[13:20:03.381]                       else if (inherits(cond, "condition")) {
[13:20:03.381]                         if (!is.null(pattern)) {
[13:20:03.381]                           computeRestarts <- base::computeRestarts
[13:20:03.381]                           grepl <- base::grepl
[13:20:03.381]                           restarts <- computeRestarts(cond)
[13:20:03.381]                           for (restart in restarts) {
[13:20:03.381]                             name <- restart$name
[13:20:03.381]                             if (is.null(name)) 
[13:20:03.381]                               next
[13:20:03.381]                             if (!grepl(pattern, name)) 
[13:20:03.381]                               next
[13:20:03.381]                             invokeRestart(restart)
[13:20:03.381]                             muffled <- TRUE
[13:20:03.381]                             break
[13:20:03.381]                           }
[13:20:03.381]                         }
[13:20:03.381]                       }
[13:20:03.381]                       invisible(muffled)
[13:20:03.381]                     }
[13:20:03.381]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.381]                   }
[13:20:03.381]                 }
[13:20:03.381]             }
[13:20:03.381]         }))
[13:20:03.381]     }, error = function(ex) {
[13:20:03.381]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.381]                 ...future.rng), started = ...future.startTime, 
[13:20:03.381]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.381]             version = "1.8"), class = "FutureResult")
[13:20:03.381]     }, finally = {
[13:20:03.381]         if (!identical(...future.workdir, getwd())) 
[13:20:03.381]             setwd(...future.workdir)
[13:20:03.381]         {
[13:20:03.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.381]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.381]             }
[13:20:03.381]             base::options(...future.oldOptions)
[13:20:03.381]             if (.Platform$OS.type == "windows") {
[13:20:03.381]                 old_names <- names(...future.oldEnvVars)
[13:20:03.381]                 envs <- base::Sys.getenv()
[13:20:03.381]                 names <- names(envs)
[13:20:03.381]                 common <- intersect(names, old_names)
[13:20:03.381]                 added <- setdiff(names, old_names)
[13:20:03.381]                 removed <- setdiff(old_names, names)
[13:20:03.381]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.381]                   envs[common]]
[13:20:03.381]                 NAMES <- toupper(changed)
[13:20:03.381]                 args <- list()
[13:20:03.381]                 for (kk in seq_along(NAMES)) {
[13:20:03.381]                   name <- changed[[kk]]
[13:20:03.381]                   NAME <- NAMES[[kk]]
[13:20:03.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.381]                     next
[13:20:03.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.381]                 }
[13:20:03.381]                 NAMES <- toupper(added)
[13:20:03.381]                 for (kk in seq_along(NAMES)) {
[13:20:03.381]                   name <- added[[kk]]
[13:20:03.381]                   NAME <- NAMES[[kk]]
[13:20:03.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.381]                     next
[13:20:03.381]                   args[[name]] <- ""
[13:20:03.381]                 }
[13:20:03.381]                 NAMES <- toupper(removed)
[13:20:03.381]                 for (kk in seq_along(NAMES)) {
[13:20:03.381]                   name <- removed[[kk]]
[13:20:03.381]                   NAME <- NAMES[[kk]]
[13:20:03.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.381]                     next
[13:20:03.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.381]                 }
[13:20:03.381]                 if (length(args) > 0) 
[13:20:03.381]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.381]             }
[13:20:03.381]             else {
[13:20:03.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.381]             }
[13:20:03.381]             {
[13:20:03.381]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.381]                   0L) {
[13:20:03.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.381]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.381]                   base::options(opts)
[13:20:03.381]                 }
[13:20:03.381]                 {
[13:20:03.381]                   {
[13:20:03.381]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.381]                     NULL
[13:20:03.381]                   }
[13:20:03.381]                   options(future.plan = NULL)
[13:20:03.381]                   if (is.na(NA_character_)) 
[13:20:03.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.381]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.381]                     envir = parent.frame()) 
[13:20:03.381]                   {
[13:20:03.381]                     default_workers <- missing(workers)
[13:20:03.381]                     if (is.function(workers)) 
[13:20:03.381]                       workers <- workers()
[13:20:03.381]                     workers <- structure(as.integer(workers), 
[13:20:03.381]                       class = class(workers))
[13:20:03.381]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.381]                       1L)
[13:20:03.381]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.381]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.381]                       if (default_workers) 
[13:20:03.381]                         supportsMulticore(warn = TRUE)
[13:20:03.381]                       return(sequential(..., envir = envir))
[13:20:03.381]                     }
[13:20:03.381]                     oopts <- options(mc.cores = workers)
[13:20:03.381]                     on.exit(options(oopts))
[13:20:03.381]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.381]                       envir = envir)
[13:20:03.381]                     if (!future$lazy) 
[13:20:03.381]                       future <- run(future)
[13:20:03.381]                     invisible(future)
[13:20:03.381]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.381]                 }
[13:20:03.381]             }
[13:20:03.381]         }
[13:20:03.381]     })
[13:20:03.381]     if (TRUE) {
[13:20:03.381]         base::sink(type = "output", split = FALSE)
[13:20:03.381]         if (TRUE) {
[13:20:03.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.381]         }
[13:20:03.381]         else {
[13:20:03.381]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.381]         }
[13:20:03.381]         base::close(...future.stdout)
[13:20:03.381]         ...future.stdout <- NULL
[13:20:03.381]     }
[13:20:03.381]     ...future.result$conditions <- ...future.conditions
[13:20:03.381]     ...future.result$finished <- base::Sys.time()
[13:20:03.381]     ...future.result
[13:20:03.381] }
[13:20:03.384] assign_globals() ...
[13:20:03.384] List of 7
[13:20:03.384]  $ ...future.FUN            :function (x)  
[13:20:03.384]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:03.384]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.384]  $ future.call.arguments    : list()
[13:20:03.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.384]  $ ...future.elements_ii    :List of 1
[13:20:03.384]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.384]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:03.384]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.384]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.384]  $ ...future.seeds_ii       : NULL
[13:20:03.384]  $ ...future.globals.maxSize: NULL
[13:20:03.384]  - attr(*, "where")=List of 7
[13:20:03.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.384]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:20:03.384]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:20:03.384]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.384]  - attr(*, "resolved")= logi FALSE
[13:20:03.384]  - attr(*, "total_size")= num 2320
[13:20:03.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.384]  - attr(*, "already-done")= logi TRUE
[13:20:03.395] - reassign environment for ‘...future.FUN’
[13:20:03.395] - copied ‘...future.FUN’ to environment
[13:20:03.395] - copied ‘breaks’ to environment
[13:20:03.395] - copied ‘wool’ to environment
[13:20:03.395] - copied ‘future.call.arguments’ to environment
[13:20:03.396] - copied ‘...future.elements_ii’ to environment
[13:20:03.396] - copied ‘...future.seeds_ii’ to environment
[13:20:03.396] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.396] assign_globals() ... done
[13:20:03.396] requestCore(): workers = 2
[13:20:03.399] MulticoreFuture started
[13:20:03.400] - Launch lazy future ... done
[13:20:03.400] run() for ‘MulticoreFuture’ ... done
[13:20:03.401] Created future:
[13:20:03.402] plan(): Setting new future strategy stack:
[13:20:03.402] List of future strategies:
[13:20:03.402] 1. sequential:
[13:20:03.402]    - args: function (..., envir = parent.frame())
[13:20:03.402]    - tweaked: FALSE
[13:20:03.402]    - call: NULL
[13:20:03.404] plan(): nbrOfWorkers() = 1
[13:20:03.411] plan(): Setting new future strategy stack:
[13:20:03.411] List of future strategies:
[13:20:03.411] 1. multicore:
[13:20:03.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.411]    - tweaked: FALSE
[13:20:03.411]    - call: plan(strategy)
[13:20:03.402] MulticoreFuture:
[13:20:03.402] Label: ‘future_by-1’
[13:20:03.402] Expression:
[13:20:03.402] {
[13:20:03.402]     do.call(function(...) {
[13:20:03.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.402]             on.exit(options(oopts), add = TRUE)
[13:20:03.402]         }
[13:20:03.402]         {
[13:20:03.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.402]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.402]             })
[13:20:03.402]         }
[13:20:03.402]     }, args = future.call.arguments)
[13:20:03.402] }
[13:20:03.402] Lazy evaluation: FALSE
[13:20:03.402] Asynchronous evaluation: TRUE
[13:20:03.402] Local evaluation: TRUE
[13:20:03.402] Environment: 0x55aced01ab20
[13:20:03.402] Capture standard output: TRUE
[13:20:03.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.402] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[13:20:03.402] Packages: 1 packages (‘stats’)
[13:20:03.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.402] Resolved: FALSE
[13:20:03.402] Value: <not collected>
[13:20:03.402] Conditions captured: <none>
[13:20:03.402] Early signaling: FALSE
[13:20:03.402] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.402] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.417] Chunk #1 of 2 ... DONE
[13:20:03.417] Chunk #2 of 2 ...
[13:20:03.418]  - Finding globals in 'X' for chunk #2 ...
[13:20:03.418] getGlobalsAndPackages() ...
[13:20:03.418] Searching for globals...
[13:20:03.419] plan(): nbrOfWorkers() = 2
[13:20:03.419] 
[13:20:03.419] Searching for globals ... DONE
[13:20:03.420] - globals: [0] <none>
[13:20:03.420] getGlobalsAndPackages() ... DONE
[13:20:03.420]    + additional globals found: [n=0] 
[13:20:03.420]    + additional namespaces needed: [n=0] 
[13:20:03.420]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:03.421]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.421]  - seeds: <none>
[13:20:03.421]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.421] getGlobalsAndPackages() ...
[13:20:03.421] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.422] Resolving globals: FALSE
[13:20:03.422] Tweak future expression to call with '...' arguments ...
[13:20:03.422] {
[13:20:03.422]     do.call(function(...) {
[13:20:03.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.422]             on.exit(options(oopts), add = TRUE)
[13:20:03.422]         }
[13:20:03.422]         {
[13:20:03.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.422]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.422]             })
[13:20:03.422]         }
[13:20:03.422]     }, args = future.call.arguments)
[13:20:03.422] }
[13:20:03.423] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.423] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.424] 
[13:20:03.424] getGlobalsAndPackages() ... DONE
[13:20:03.424] run() for ‘Future’ ...
[13:20:03.425] - state: ‘created’
[13:20:03.425] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.429] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.430]   - Field: ‘label’
[13:20:03.430]   - Field: ‘local’
[13:20:03.430]   - Field: ‘owner’
[13:20:03.430]   - Field: ‘envir’
[13:20:03.430]   - Field: ‘workers’
[13:20:03.430]   - Field: ‘packages’
[13:20:03.431]   - Field: ‘gc’
[13:20:03.431]   - Field: ‘job’
[13:20:03.431]   - Field: ‘conditions’
[13:20:03.431]   - Field: ‘expr’
[13:20:03.431]   - Field: ‘uuid’
[13:20:03.431]   - Field: ‘seed’
[13:20:03.431]   - Field: ‘version’
[13:20:03.432]   - Field: ‘result’
[13:20:03.432]   - Field: ‘asynchronous’
[13:20:03.432]   - Field: ‘calls’
[13:20:03.432]   - Field: ‘globals’
[13:20:03.432]   - Field: ‘stdout’
[13:20:03.432]   - Field: ‘earlySignal’
[13:20:03.432]   - Field: ‘lazy’
[13:20:03.432]   - Field: ‘state’
[13:20:03.433] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.433] - Launch lazy future ...
[13:20:03.433] Packages needed by the future expression (n = 1): ‘stats’
[13:20:03.433] Packages needed by future strategies (n = 0): <none>
[13:20:03.434] {
[13:20:03.434]     {
[13:20:03.434]         {
[13:20:03.434]             ...future.startTime <- base::Sys.time()
[13:20:03.434]             {
[13:20:03.434]                 {
[13:20:03.434]                   {
[13:20:03.434]                     {
[13:20:03.434]                       {
[13:20:03.434]                         base::local({
[13:20:03.434]                           has_future <- base::requireNamespace("future", 
[13:20:03.434]                             quietly = TRUE)
[13:20:03.434]                           if (has_future) {
[13:20:03.434]                             ns <- base::getNamespace("future")
[13:20:03.434]                             version <- ns[[".package"]][["version"]]
[13:20:03.434]                             if (is.null(version)) 
[13:20:03.434]                               version <- utils::packageVersion("future")
[13:20:03.434]                           }
[13:20:03.434]                           else {
[13:20:03.434]                             version <- NULL
[13:20:03.434]                           }
[13:20:03.434]                           if (!has_future || version < "1.8.0") {
[13:20:03.434]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.434]                               "", base::R.version$version.string), 
[13:20:03.434]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:03.434]                                 base::R.version$platform, 8 * 
[13:20:03.434]                                   base::.Machine$sizeof.pointer), 
[13:20:03.434]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.434]                                 "release", "version")], collapse = " "), 
[13:20:03.434]                               hostname = base::Sys.info()[["nodename"]])
[13:20:03.434]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.434]                               info)
[13:20:03.434]                             info <- base::paste(info, collapse = "; ")
[13:20:03.434]                             if (!has_future) {
[13:20:03.434]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.434]                                 info)
[13:20:03.434]                             }
[13:20:03.434]                             else {
[13:20:03.434]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.434]                                 info, version)
[13:20:03.434]                             }
[13:20:03.434]                             base::stop(msg)
[13:20:03.434]                           }
[13:20:03.434]                         })
[13:20:03.434]                       }
[13:20:03.434]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.434]                       base::options(mc.cores = 1L)
[13:20:03.434]                     }
[13:20:03.434]                     base::local({
[13:20:03.434]                       for (pkg in "stats") {
[13:20:03.434]                         base::loadNamespace(pkg)
[13:20:03.434]                         base::library(pkg, character.only = TRUE)
[13:20:03.434]                       }
[13:20:03.434]                     })
[13:20:03.434]                   }
[13:20:03.434]                   options(future.plan = NULL)
[13:20:03.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.434]                 }
[13:20:03.434]                 ...future.workdir <- getwd()
[13:20:03.434]             }
[13:20:03.434]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.434]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.434]         }
[13:20:03.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.434]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.434]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.434]             base::names(...future.oldOptions))
[13:20:03.434]     }
[13:20:03.434]     if (FALSE) {
[13:20:03.434]     }
[13:20:03.434]     else {
[13:20:03.434]         if (TRUE) {
[13:20:03.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.434]                 open = "w")
[13:20:03.434]         }
[13:20:03.434]         else {
[13:20:03.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.434]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.434]         }
[13:20:03.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.434]             base::sink(type = "output", split = FALSE)
[13:20:03.434]             base::close(...future.stdout)
[13:20:03.434]         }, add = TRUE)
[13:20:03.434]     }
[13:20:03.434]     ...future.frame <- base::sys.nframe()
[13:20:03.434]     ...future.conditions <- base::list()
[13:20:03.434]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.434]     if (FALSE) {
[13:20:03.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.434]     }
[13:20:03.434]     ...future.result <- base::tryCatch({
[13:20:03.434]         base::withCallingHandlers({
[13:20:03.434]             ...future.value <- base::withVisible(base::local({
[13:20:03.434]                 withCallingHandlers({
[13:20:03.434]                   {
[13:20:03.434]                     do.call(function(...) {
[13:20:03.434]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.434]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.434]                         ...future.globals.maxSize)) {
[13:20:03.434]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.434]                         on.exit(options(oopts), add = TRUE)
[13:20:03.434]                       }
[13:20:03.434]                       {
[13:20:03.434]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.434]                           FUN = function(jj) {
[13:20:03.434]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.434]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.434]                           })
[13:20:03.434]                       }
[13:20:03.434]                     }, args = future.call.arguments)
[13:20:03.434]                   }
[13:20:03.434]                 }, immediateCondition = function(cond) {
[13:20:03.434]                   save_rds <- function (object, pathname, ...) 
[13:20:03.434]                   {
[13:20:03.434]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.434]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.434]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.434]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.434]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.434]                         fi_tmp[["mtime"]])
[13:20:03.434]                     }
[13:20:03.434]                     tryCatch({
[13:20:03.434]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.434]                     }, error = function(ex) {
[13:20:03.434]                       msg <- conditionMessage(ex)
[13:20:03.434]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.434]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.434]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.434]                         fi_tmp[["mtime"]], msg)
[13:20:03.434]                       ex$message <- msg
[13:20:03.434]                       stop(ex)
[13:20:03.434]                     })
[13:20:03.434]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.434]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.434]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.434]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.434]                       fi <- file.info(pathname)
[13:20:03.434]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.434]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.434]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.434]                         fi[["size"]], fi[["mtime"]])
[13:20:03.434]                       stop(msg)
[13:20:03.434]                     }
[13:20:03.434]                     invisible(pathname)
[13:20:03.434]                   }
[13:20:03.434]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.434]                     rootPath = tempdir()) 
[13:20:03.434]                   {
[13:20:03.434]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.434]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.434]                       tmpdir = path, fileext = ".rds")
[13:20:03.434]                     save_rds(obj, file)
[13:20:03.434]                   }
[13:20:03.434]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.434]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.434]                   {
[13:20:03.434]                     inherits <- base::inherits
[13:20:03.434]                     invokeRestart <- base::invokeRestart
[13:20:03.434]                     is.null <- base::is.null
[13:20:03.434]                     muffled <- FALSE
[13:20:03.434]                     if (inherits(cond, "message")) {
[13:20:03.434]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.434]                       if (muffled) 
[13:20:03.434]                         invokeRestart("muffleMessage")
[13:20:03.434]                     }
[13:20:03.434]                     else if (inherits(cond, "warning")) {
[13:20:03.434]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.434]                       if (muffled) 
[13:20:03.434]                         invokeRestart("muffleWarning")
[13:20:03.434]                     }
[13:20:03.434]                     else if (inherits(cond, "condition")) {
[13:20:03.434]                       if (!is.null(pattern)) {
[13:20:03.434]                         computeRestarts <- base::computeRestarts
[13:20:03.434]                         grepl <- base::grepl
[13:20:03.434]                         restarts <- computeRestarts(cond)
[13:20:03.434]                         for (restart in restarts) {
[13:20:03.434]                           name <- restart$name
[13:20:03.434]                           if (is.null(name)) 
[13:20:03.434]                             next
[13:20:03.434]                           if (!grepl(pattern, name)) 
[13:20:03.434]                             next
[13:20:03.434]                           invokeRestart(restart)
[13:20:03.434]                           muffled <- TRUE
[13:20:03.434]                           break
[13:20:03.434]                         }
[13:20:03.434]                       }
[13:20:03.434]                     }
[13:20:03.434]                     invisible(muffled)
[13:20:03.434]                   }
[13:20:03.434]                   muffleCondition(cond)
[13:20:03.434]                 })
[13:20:03.434]             }))
[13:20:03.434]             future::FutureResult(value = ...future.value$value, 
[13:20:03.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.434]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.434]                     ...future.globalenv.names))
[13:20:03.434]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.434]         }, condition = base::local({
[13:20:03.434]             c <- base::c
[13:20:03.434]             inherits <- base::inherits
[13:20:03.434]             invokeRestart <- base::invokeRestart
[13:20:03.434]             length <- base::length
[13:20:03.434]             list <- base::list
[13:20:03.434]             seq.int <- base::seq.int
[13:20:03.434]             signalCondition <- base::signalCondition
[13:20:03.434]             sys.calls <- base::sys.calls
[13:20:03.434]             `[[` <- base::`[[`
[13:20:03.434]             `+` <- base::`+`
[13:20:03.434]             `<<-` <- base::`<<-`
[13:20:03.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.434]                   3L)]
[13:20:03.434]             }
[13:20:03.434]             function(cond) {
[13:20:03.434]                 is_error <- inherits(cond, "error")
[13:20:03.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.434]                   NULL)
[13:20:03.434]                 if (is_error) {
[13:20:03.434]                   sessionInformation <- function() {
[13:20:03.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.434]                       search = base::search(), system = base::Sys.info())
[13:20:03.434]                   }
[13:20:03.434]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.434]                     cond$call), session = sessionInformation(), 
[13:20:03.434]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.434]                   signalCondition(cond)
[13:20:03.434]                 }
[13:20:03.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.434]                 "immediateCondition"))) {
[13:20:03.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.434]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.434]                   if (TRUE && !signal) {
[13:20:03.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.434]                     {
[13:20:03.434]                       inherits <- base::inherits
[13:20:03.434]                       invokeRestart <- base::invokeRestart
[13:20:03.434]                       is.null <- base::is.null
[13:20:03.434]                       muffled <- FALSE
[13:20:03.434]                       if (inherits(cond, "message")) {
[13:20:03.434]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.434]                         if (muffled) 
[13:20:03.434]                           invokeRestart("muffleMessage")
[13:20:03.434]                       }
[13:20:03.434]                       else if (inherits(cond, "warning")) {
[13:20:03.434]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.434]                         if (muffled) 
[13:20:03.434]                           invokeRestart("muffleWarning")
[13:20:03.434]                       }
[13:20:03.434]                       else if (inherits(cond, "condition")) {
[13:20:03.434]                         if (!is.null(pattern)) {
[13:20:03.434]                           computeRestarts <- base::computeRestarts
[13:20:03.434]                           grepl <- base::grepl
[13:20:03.434]                           restarts <- computeRestarts(cond)
[13:20:03.434]                           for (restart in restarts) {
[13:20:03.434]                             name <- restart$name
[13:20:03.434]                             if (is.null(name)) 
[13:20:03.434]                               next
[13:20:03.434]                             if (!grepl(pattern, name)) 
[13:20:03.434]                               next
[13:20:03.434]                             invokeRestart(restart)
[13:20:03.434]                             muffled <- TRUE
[13:20:03.434]                             break
[13:20:03.434]                           }
[13:20:03.434]                         }
[13:20:03.434]                       }
[13:20:03.434]                       invisible(muffled)
[13:20:03.434]                     }
[13:20:03.434]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.434]                   }
[13:20:03.434]                 }
[13:20:03.434]                 else {
[13:20:03.434]                   if (TRUE) {
[13:20:03.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.434]                     {
[13:20:03.434]                       inherits <- base::inherits
[13:20:03.434]                       invokeRestart <- base::invokeRestart
[13:20:03.434]                       is.null <- base::is.null
[13:20:03.434]                       muffled <- FALSE
[13:20:03.434]                       if (inherits(cond, "message")) {
[13:20:03.434]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.434]                         if (muffled) 
[13:20:03.434]                           invokeRestart("muffleMessage")
[13:20:03.434]                       }
[13:20:03.434]                       else if (inherits(cond, "warning")) {
[13:20:03.434]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.434]                         if (muffled) 
[13:20:03.434]                           invokeRestart("muffleWarning")
[13:20:03.434]                       }
[13:20:03.434]                       else if (inherits(cond, "condition")) {
[13:20:03.434]                         if (!is.null(pattern)) {
[13:20:03.434]                           computeRestarts <- base::computeRestarts
[13:20:03.434]                           grepl <- base::grepl
[13:20:03.434]                           restarts <- computeRestarts(cond)
[13:20:03.434]                           for (restart in restarts) {
[13:20:03.434]                             name <- restart$name
[13:20:03.434]                             if (is.null(name)) 
[13:20:03.434]                               next
[13:20:03.434]                             if (!grepl(pattern, name)) 
[13:20:03.434]                               next
[13:20:03.434]                             invokeRestart(restart)
[13:20:03.434]                             muffled <- TRUE
[13:20:03.434]                             break
[13:20:03.434]                           }
[13:20:03.434]                         }
[13:20:03.434]                       }
[13:20:03.434]                       invisible(muffled)
[13:20:03.434]                     }
[13:20:03.434]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.434]                   }
[13:20:03.434]                 }
[13:20:03.434]             }
[13:20:03.434]         }))
[13:20:03.434]     }, error = function(ex) {
[13:20:03.434]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.434]                 ...future.rng), started = ...future.startTime, 
[13:20:03.434]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.434]             version = "1.8"), class = "FutureResult")
[13:20:03.434]     }, finally = {
[13:20:03.434]         if (!identical(...future.workdir, getwd())) 
[13:20:03.434]             setwd(...future.workdir)
[13:20:03.434]         {
[13:20:03.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.434]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.434]             }
[13:20:03.434]             base::options(...future.oldOptions)
[13:20:03.434]             if (.Platform$OS.type == "windows") {
[13:20:03.434]                 old_names <- names(...future.oldEnvVars)
[13:20:03.434]                 envs <- base::Sys.getenv()
[13:20:03.434]                 names <- names(envs)
[13:20:03.434]                 common <- intersect(names, old_names)
[13:20:03.434]                 added <- setdiff(names, old_names)
[13:20:03.434]                 removed <- setdiff(old_names, names)
[13:20:03.434]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.434]                   envs[common]]
[13:20:03.434]                 NAMES <- toupper(changed)
[13:20:03.434]                 args <- list()
[13:20:03.434]                 for (kk in seq_along(NAMES)) {
[13:20:03.434]                   name <- changed[[kk]]
[13:20:03.434]                   NAME <- NAMES[[kk]]
[13:20:03.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.434]                     next
[13:20:03.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.434]                 }
[13:20:03.434]                 NAMES <- toupper(added)
[13:20:03.434]                 for (kk in seq_along(NAMES)) {
[13:20:03.434]                   name <- added[[kk]]
[13:20:03.434]                   NAME <- NAMES[[kk]]
[13:20:03.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.434]                     next
[13:20:03.434]                   args[[name]] <- ""
[13:20:03.434]                 }
[13:20:03.434]                 NAMES <- toupper(removed)
[13:20:03.434]                 for (kk in seq_along(NAMES)) {
[13:20:03.434]                   name <- removed[[kk]]
[13:20:03.434]                   NAME <- NAMES[[kk]]
[13:20:03.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.434]                     next
[13:20:03.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.434]                 }
[13:20:03.434]                 if (length(args) > 0) 
[13:20:03.434]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.434]             }
[13:20:03.434]             else {
[13:20:03.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.434]             }
[13:20:03.434]             {
[13:20:03.434]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.434]                   0L) {
[13:20:03.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.434]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.434]                   base::options(opts)
[13:20:03.434]                 }
[13:20:03.434]                 {
[13:20:03.434]                   {
[13:20:03.434]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.434]                     NULL
[13:20:03.434]                   }
[13:20:03.434]                   options(future.plan = NULL)
[13:20:03.434]                   if (is.na(NA_character_)) 
[13:20:03.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.434]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.434]                     envir = parent.frame()) 
[13:20:03.434]                   {
[13:20:03.434]                     default_workers <- missing(workers)
[13:20:03.434]                     if (is.function(workers)) 
[13:20:03.434]                       workers <- workers()
[13:20:03.434]                     workers <- structure(as.integer(workers), 
[13:20:03.434]                       class = class(workers))
[13:20:03.434]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.434]                       1L)
[13:20:03.434]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.434]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.434]                       if (default_workers) 
[13:20:03.434]                         supportsMulticore(warn = TRUE)
[13:20:03.434]                       return(sequential(..., envir = envir))
[13:20:03.434]                     }
[13:20:03.434]                     oopts <- options(mc.cores = workers)
[13:20:03.434]                     on.exit(options(oopts))
[13:20:03.434]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.434]                       envir = envir)
[13:20:03.434]                     if (!future$lazy) 
[13:20:03.434]                       future <- run(future)
[13:20:03.434]                     invisible(future)
[13:20:03.434]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.434]                 }
[13:20:03.434]             }
[13:20:03.434]         }
[13:20:03.434]     })
[13:20:03.434]     if (TRUE) {
[13:20:03.434]         base::sink(type = "output", split = FALSE)
[13:20:03.434]         if (TRUE) {
[13:20:03.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.434]         }
[13:20:03.434]         else {
[13:20:03.434]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.434]         }
[13:20:03.434]         base::close(...future.stdout)
[13:20:03.434]         ...future.stdout <- NULL
[13:20:03.434]     }
[13:20:03.434]     ...future.result$conditions <- ...future.conditions
[13:20:03.434]     ...future.result$finished <- base::Sys.time()
[13:20:03.434]     ...future.result
[13:20:03.434] }
[13:20:03.438] assign_globals() ...
[13:20:03.438] List of 7
[13:20:03.438]  $ ...future.FUN            :function (x)  
[13:20:03.438]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:03.438]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.438]  $ future.call.arguments    : list()
[13:20:03.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.438]  $ ...future.elements_ii    :List of 2
[13:20:03.438]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.438]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:03.438]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.438]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:03.438]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.438]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:03.438]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.438]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:03.438]  $ ...future.seeds_ii       : NULL
[13:20:03.438]  $ ...future.globals.maxSize: NULL
[13:20:03.438]  - attr(*, "where")=List of 7
[13:20:03.438]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.438]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:20:03.438]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:20:03.438]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.438]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.438]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.438]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.438]  - attr(*, "resolved")= logi FALSE
[13:20:03.438]  - attr(*, "total_size")= num 2320
[13:20:03.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.438]  - attr(*, "already-done")= logi TRUE
[13:20:03.451] - reassign environment for ‘...future.FUN’
[13:20:03.451] - copied ‘...future.FUN’ to environment
[13:20:03.451] - copied ‘breaks’ to environment
[13:20:03.451] - copied ‘wool’ to environment
[13:20:03.451] - copied ‘future.call.arguments’ to environment
[13:20:03.452] - copied ‘...future.elements_ii’ to environment
[13:20:03.452] - copied ‘...future.seeds_ii’ to environment
[13:20:03.452] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.452] assign_globals() ... done
[13:20:03.452] requestCore(): workers = 2
[13:20:03.455] MulticoreFuture started
[13:20:03.455] - Launch lazy future ... done
[13:20:03.456] run() for ‘MulticoreFuture’ ... done
[13:20:03.456] Created future:
[13:20:03.457] plan(): Setting new future strategy stack:
[13:20:03.457] List of future strategies:
[13:20:03.457] 1. sequential:
[13:20:03.457]    - args: function (..., envir = parent.frame())
[13:20:03.457]    - tweaked: FALSE
[13:20:03.457]    - call: NULL
[13:20:03.458] plan(): nbrOfWorkers() = 1
[13:20:03.464] plan(): Setting new future strategy stack:
[13:20:03.464] List of future strategies:
[13:20:03.464] 1. multicore:
[13:20:03.464]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.464]    - tweaked: FALSE
[13:20:03.464]    - call: plan(strategy)
[13:20:03.469] plan(): nbrOfWorkers() = 2
[13:20:03.457] MulticoreFuture:
[13:20:03.457] Label: ‘future_by-2’
[13:20:03.457] Expression:
[13:20:03.457] {
[13:20:03.457]     do.call(function(...) {
[13:20:03.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.457]             on.exit(options(oopts), add = TRUE)
[13:20:03.457]         }
[13:20:03.457]         {
[13:20:03.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.457]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.457]             })
[13:20:03.457]         }
[13:20:03.457]     }, args = future.call.arguments)
[13:20:03.457] }
[13:20:03.457] Lazy evaluation: FALSE
[13:20:03.457] Asynchronous evaluation: TRUE
[13:20:03.457] Local evaluation: TRUE
[13:20:03.457] Environment: 0x55aced01ab20
[13:20:03.457] Capture standard output: TRUE
[13:20:03.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.457] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[13:20:03.457] Packages: 1 packages (‘stats’)
[13:20:03.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.457] Resolved: FALSE
[13:20:03.457] Value: <not collected>
[13:20:03.457] Conditions captured: <none>
[13:20:03.457] Early signaling: FALSE
[13:20:03.457] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.457] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.471] Chunk #2 of 2 ... DONE
[13:20:03.471] Launching 2 futures (chunks) ... DONE
[13:20:03.471] Resolving 2 futures (chunks) ...
[13:20:03.471] resolve() on list ...
[13:20:03.472]  recursive: 0
[13:20:03.472]  length: 2
[13:20:03.472] 
[13:20:03.472] Future #1
[13:20:03.472] result() for MulticoreFuture ...
[13:20:03.474] result() for MulticoreFuture ...
[13:20:03.474] result() for MulticoreFuture ... done
[13:20:03.474] result() for MulticoreFuture ... done
[13:20:03.474] result() for MulticoreFuture ...
[13:20:03.474] result() for MulticoreFuture ... done
[13:20:03.475] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:03.475] - nx: 2
[13:20:03.475] - relay: TRUE
[13:20:03.475] - stdout: TRUE
[13:20:03.475] - signal: TRUE
[13:20:03.475] - resignal: FALSE
[13:20:03.475] - force: TRUE
[13:20:03.475] - relayed: [n=2] FALSE, FALSE
[13:20:03.476] - queued futures: [n=2] FALSE, FALSE
[13:20:03.476]  - until=1
[13:20:03.476]  - relaying element #1
[13:20:03.476] result() for MulticoreFuture ...
[13:20:03.476] result() for MulticoreFuture ... done
[13:20:03.476] result() for MulticoreFuture ...
[13:20:03.477] result() for MulticoreFuture ... done
[13:20:03.477] result() for MulticoreFuture ...
[13:20:03.477] result() for MulticoreFuture ... done
[13:20:03.477] result() for MulticoreFuture ...
[13:20:03.477] result() for MulticoreFuture ... done
[13:20:03.477] - relayed: [n=2] TRUE, FALSE
[13:20:03.478] - queued futures: [n=2] TRUE, FALSE
[13:20:03.478] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:03.478]  length: 1 (resolved future 1)
[13:20:03.478] Future #2
[13:20:03.478] result() for MulticoreFuture ...
[13:20:03.480] result() for MulticoreFuture ...
[13:20:03.480] result() for MulticoreFuture ... done
[13:20:03.480] result() for MulticoreFuture ... done
[13:20:03.480] result() for MulticoreFuture ...
[13:20:03.480] result() for MulticoreFuture ... done
[13:20:03.481] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:03.481] - nx: 2
[13:20:03.481] - relay: TRUE
[13:20:03.481] - stdout: TRUE
[13:20:03.481] - signal: TRUE
[13:20:03.481] - resignal: FALSE
[13:20:03.482] - force: TRUE
[13:20:03.482] - relayed: [n=2] TRUE, FALSE
[13:20:03.482] - queued futures: [n=2] TRUE, FALSE
[13:20:03.482]  - until=2
[13:20:03.482]  - relaying element #2
[13:20:03.482] result() for MulticoreFuture ...
[13:20:03.483] result() for MulticoreFuture ... done
[13:20:03.483] result() for MulticoreFuture ...
[13:20:03.483] result() for MulticoreFuture ... done
[13:20:03.483] result() for MulticoreFuture ...
[13:20:03.483] result() for MulticoreFuture ... done
[13:20:03.483] result() for MulticoreFuture ...
[13:20:03.483] result() for MulticoreFuture ... done
[13:20:03.484] - relayed: [n=2] TRUE, TRUE
[13:20:03.484] - queued futures: [n=2] TRUE, TRUE
[13:20:03.484] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:03.484]  length: 0 (resolved future 2)
[13:20:03.484] Relaying remaining futures
[13:20:03.484] signalConditionsASAP(NULL, pos=0) ...
[13:20:03.484] - nx: 2
[13:20:03.484] - relay: TRUE
[13:20:03.484] - stdout: TRUE
[13:20:03.485] - signal: TRUE
[13:20:03.485] - resignal: FALSE
[13:20:03.485] - force: TRUE
[13:20:03.485] - relayed: [n=2] TRUE, TRUE
[13:20:03.485] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:03.485] - relayed: [n=2] TRUE, TRUE
[13:20:03.485] - queued futures: [n=2] TRUE, TRUE
[13:20:03.485] signalConditionsASAP(NULL, pos=0) ... done
[13:20:03.485] resolve() on list ... DONE
[13:20:03.486] result() for MulticoreFuture ...
[13:20:03.486] result() for MulticoreFuture ... done
[13:20:03.486] result() for MulticoreFuture ...
[13:20:03.486] result() for MulticoreFuture ... done
[13:20:03.486] result() for MulticoreFuture ...
[13:20:03.486] result() for MulticoreFuture ... done
[13:20:03.486] result() for MulticoreFuture ...
[13:20:03.488] result() for MulticoreFuture ... done
[13:20:03.489]  - Number of value chunks collected: 2
[13:20:03.489] Resolving 2 futures (chunks) ... DONE
[13:20:03.489] Reducing values from 2 chunks ...
[13:20:03.489]  - Number of values collected after concatenation: 3
[13:20:03.489]  - Number of values expected: 3
[13:20:03.489] Reducing values from 2 chunks ... DONE
[13:20:03.490] future_lapply() ... DONE
[13:20:03.490] future_by_internal() ... DONE
[13:20:03.490] future_by_internal() ...
[13:20:03.491] future_lapply() ...
[13:20:03.496] Number of chunks: 2
[13:20:03.497] getGlobalsAndPackagesXApply() ...
[13:20:03.497]  - future.globals: TRUE
[13:20:03.497] getGlobalsAndPackages() ...
[13:20:03.498] Searching for globals...
[13:20:03.500] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:03.501] Searching for globals ... DONE
[13:20:03.501] Resolving globals: FALSE
[13:20:03.502] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:03.503] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:03.503] - globals: [1] ‘FUN’
[13:20:03.503] 
[13:20:03.503] getGlobalsAndPackages() ... DONE
[13:20:03.504]  - globals found/used: [n=1] ‘FUN’
[13:20:03.504]  - needed namespaces: [n=0] 
[13:20:03.504] Finding globals ... DONE
[13:20:03.504]  - use_args: TRUE
[13:20:03.504]  - Getting '...' globals ...
[13:20:03.505] resolve() on list ...
[13:20:03.505]  recursive: 0
[13:20:03.505]  length: 1
[13:20:03.505]  elements: ‘...’
[13:20:03.506]  length: 0 (resolved future 1)
[13:20:03.506] resolve() on list ... DONE
[13:20:03.506]    - '...' content: [n=0] 
[13:20:03.506] List of 1
[13:20:03.506]  $ ...: list()
[13:20:03.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.506]  - attr(*, "where")=List of 1
[13:20:03.506]   ..$ ...:<environment: 0x55aced16b138> 
[13:20:03.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.506]  - attr(*, "resolved")= logi TRUE
[13:20:03.506]  - attr(*, "total_size")= num NA
[13:20:03.511]  - Getting '...' globals ... DONE
[13:20:03.511] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:03.512] List of 2
[13:20:03.512]  $ ...future.FUN:function (object, ...)  
[13:20:03.512]  $ ...          : list()
[13:20:03.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.512]  - attr(*, "where")=List of 2
[13:20:03.512]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:03.512]   ..$ ...          :<environment: 0x55aced16b138> 
[13:20:03.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.512]  - attr(*, "resolved")= logi FALSE
[13:20:03.512]  - attr(*, "total_size")= num 1240
[13:20:03.516] Packages to be attached in all futures: [n=0] 
[13:20:03.516] getGlobalsAndPackagesXApply() ... DONE
[13:20:03.516] Number of futures (= number of chunks): 2
[13:20:03.516] Launching 2 futures (chunks) ...
[13:20:03.517] Chunk #1 of 2 ...
[13:20:03.517]  - Finding globals in 'X' for chunk #1 ...
[13:20:03.517] getGlobalsAndPackages() ...
[13:20:03.517] Searching for globals...
[13:20:03.517] 
[13:20:03.518] Searching for globals ... DONE
[13:20:03.518] - globals: [0] <none>
[13:20:03.518] getGlobalsAndPackages() ... DONE
[13:20:03.518]    + additional globals found: [n=0] 
[13:20:03.518]    + additional namespaces needed: [n=0] 
[13:20:03.518]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:03.518]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.519]  - seeds: <none>
[13:20:03.519]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.519] getGlobalsAndPackages() ...
[13:20:03.519] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.519] Resolving globals: FALSE
[13:20:03.519] Tweak future expression to call with '...' arguments ...
[13:20:03.519] {
[13:20:03.519]     do.call(function(...) {
[13:20:03.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.519]             on.exit(options(oopts), add = TRUE)
[13:20:03.519]         }
[13:20:03.519]         {
[13:20:03.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.519]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.519]             })
[13:20:03.519]         }
[13:20:03.519]     }, args = future.call.arguments)
[13:20:03.519] }
[13:20:03.520] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.520] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.564] 
[13:20:03.564] getGlobalsAndPackages() ... DONE
[13:20:03.564] run() for ‘Future’ ...
[13:20:03.564] - state: ‘created’
[13:20:03.564] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.568] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.569]   - Field: ‘label’
[13:20:03.569]   - Field: ‘local’
[13:20:03.569]   - Field: ‘owner’
[13:20:03.569]   - Field: ‘envir’
[13:20:03.569]   - Field: ‘workers’
[13:20:03.569]   - Field: ‘packages’
[13:20:03.569]   - Field: ‘gc’
[13:20:03.569]   - Field: ‘job’
[13:20:03.569]   - Field: ‘conditions’
[13:20:03.569]   - Field: ‘expr’
[13:20:03.570]   - Field: ‘uuid’
[13:20:03.570]   - Field: ‘seed’
[13:20:03.570]   - Field: ‘version’
[13:20:03.570]   - Field: ‘result’
[13:20:03.570]   - Field: ‘asynchronous’
[13:20:03.570]   - Field: ‘calls’
[13:20:03.570]   - Field: ‘globals’
[13:20:03.570]   - Field: ‘stdout’
[13:20:03.570]   - Field: ‘earlySignal’
[13:20:03.570]   - Field: ‘lazy’
[13:20:03.570]   - Field: ‘state’
[13:20:03.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.571] - Launch lazy future ...
[13:20:03.571] Packages needed by the future expression (n = 0): <none>
[13:20:03.571] Packages needed by future strategies (n = 0): <none>
[13:20:03.571] {
[13:20:03.571]     {
[13:20:03.571]         {
[13:20:03.571]             ...future.startTime <- base::Sys.time()
[13:20:03.571]             {
[13:20:03.571]                 {
[13:20:03.571]                   {
[13:20:03.571]                     {
[13:20:03.571]                       base::local({
[13:20:03.571]                         has_future <- base::requireNamespace("future", 
[13:20:03.571]                           quietly = TRUE)
[13:20:03.571]                         if (has_future) {
[13:20:03.571]                           ns <- base::getNamespace("future")
[13:20:03.571]                           version <- ns[[".package"]][["version"]]
[13:20:03.571]                           if (is.null(version)) 
[13:20:03.571]                             version <- utils::packageVersion("future")
[13:20:03.571]                         }
[13:20:03.571]                         else {
[13:20:03.571]                           version <- NULL
[13:20:03.571]                         }
[13:20:03.571]                         if (!has_future || version < "1.8.0") {
[13:20:03.571]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.571]                             "", base::R.version$version.string), 
[13:20:03.571]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.571]                               "release", "version")], collapse = " "), 
[13:20:03.571]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.571]                             info)
[13:20:03.571]                           info <- base::paste(info, collapse = "; ")
[13:20:03.571]                           if (!has_future) {
[13:20:03.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.571]                               info)
[13:20:03.571]                           }
[13:20:03.571]                           else {
[13:20:03.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.571]                               info, version)
[13:20:03.571]                           }
[13:20:03.571]                           base::stop(msg)
[13:20:03.571]                         }
[13:20:03.571]                       })
[13:20:03.571]                     }
[13:20:03.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.571]                     base::options(mc.cores = 1L)
[13:20:03.571]                   }
[13:20:03.571]                   options(future.plan = NULL)
[13:20:03.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.571]                 }
[13:20:03.571]                 ...future.workdir <- getwd()
[13:20:03.571]             }
[13:20:03.571]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.571]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.571]         }
[13:20:03.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.571]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.571]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.571]             base::names(...future.oldOptions))
[13:20:03.571]     }
[13:20:03.571]     if (FALSE) {
[13:20:03.571]     }
[13:20:03.571]     else {
[13:20:03.571]         if (TRUE) {
[13:20:03.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.571]                 open = "w")
[13:20:03.571]         }
[13:20:03.571]         else {
[13:20:03.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.571]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.571]         }
[13:20:03.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.571]             base::sink(type = "output", split = FALSE)
[13:20:03.571]             base::close(...future.stdout)
[13:20:03.571]         }, add = TRUE)
[13:20:03.571]     }
[13:20:03.571]     ...future.frame <- base::sys.nframe()
[13:20:03.571]     ...future.conditions <- base::list()
[13:20:03.571]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.571]     if (FALSE) {
[13:20:03.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.571]     }
[13:20:03.571]     ...future.result <- base::tryCatch({
[13:20:03.571]         base::withCallingHandlers({
[13:20:03.571]             ...future.value <- base::withVisible(base::local({
[13:20:03.571]                 withCallingHandlers({
[13:20:03.571]                   {
[13:20:03.571]                     do.call(function(...) {
[13:20:03.571]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.571]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.571]                         ...future.globals.maxSize)) {
[13:20:03.571]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.571]                         on.exit(options(oopts), add = TRUE)
[13:20:03.571]                       }
[13:20:03.571]                       {
[13:20:03.571]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.571]                           FUN = function(jj) {
[13:20:03.571]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.571]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.571]                           })
[13:20:03.571]                       }
[13:20:03.571]                     }, args = future.call.arguments)
[13:20:03.571]                   }
[13:20:03.571]                 }, immediateCondition = function(cond) {
[13:20:03.571]                   save_rds <- function (object, pathname, ...) 
[13:20:03.571]                   {
[13:20:03.571]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.571]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.571]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.571]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.571]                         fi_tmp[["mtime"]])
[13:20:03.571]                     }
[13:20:03.571]                     tryCatch({
[13:20:03.571]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.571]                     }, error = function(ex) {
[13:20:03.571]                       msg <- conditionMessage(ex)
[13:20:03.571]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.571]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.571]                         fi_tmp[["mtime"]], msg)
[13:20:03.571]                       ex$message <- msg
[13:20:03.571]                       stop(ex)
[13:20:03.571]                     })
[13:20:03.571]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.571]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.571]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.571]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.571]                       fi <- file.info(pathname)
[13:20:03.571]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.571]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.571]                         fi[["size"]], fi[["mtime"]])
[13:20:03.571]                       stop(msg)
[13:20:03.571]                     }
[13:20:03.571]                     invisible(pathname)
[13:20:03.571]                   }
[13:20:03.571]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.571]                     rootPath = tempdir()) 
[13:20:03.571]                   {
[13:20:03.571]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.571]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.571]                       tmpdir = path, fileext = ".rds")
[13:20:03.571]                     save_rds(obj, file)
[13:20:03.571]                   }
[13:20:03.571]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.571]                   {
[13:20:03.571]                     inherits <- base::inherits
[13:20:03.571]                     invokeRestart <- base::invokeRestart
[13:20:03.571]                     is.null <- base::is.null
[13:20:03.571]                     muffled <- FALSE
[13:20:03.571]                     if (inherits(cond, "message")) {
[13:20:03.571]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.571]                       if (muffled) 
[13:20:03.571]                         invokeRestart("muffleMessage")
[13:20:03.571]                     }
[13:20:03.571]                     else if (inherits(cond, "warning")) {
[13:20:03.571]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.571]                       if (muffled) 
[13:20:03.571]                         invokeRestart("muffleWarning")
[13:20:03.571]                     }
[13:20:03.571]                     else if (inherits(cond, "condition")) {
[13:20:03.571]                       if (!is.null(pattern)) {
[13:20:03.571]                         computeRestarts <- base::computeRestarts
[13:20:03.571]                         grepl <- base::grepl
[13:20:03.571]                         restarts <- computeRestarts(cond)
[13:20:03.571]                         for (restart in restarts) {
[13:20:03.571]                           name <- restart$name
[13:20:03.571]                           if (is.null(name)) 
[13:20:03.571]                             next
[13:20:03.571]                           if (!grepl(pattern, name)) 
[13:20:03.571]                             next
[13:20:03.571]                           invokeRestart(restart)
[13:20:03.571]                           muffled <- TRUE
[13:20:03.571]                           break
[13:20:03.571]                         }
[13:20:03.571]                       }
[13:20:03.571]                     }
[13:20:03.571]                     invisible(muffled)
[13:20:03.571]                   }
[13:20:03.571]                   muffleCondition(cond)
[13:20:03.571]                 })
[13:20:03.571]             }))
[13:20:03.571]             future::FutureResult(value = ...future.value$value, 
[13:20:03.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.571]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.571]                     ...future.globalenv.names))
[13:20:03.571]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.571]         }, condition = base::local({
[13:20:03.571]             c <- base::c
[13:20:03.571]             inherits <- base::inherits
[13:20:03.571]             invokeRestart <- base::invokeRestart
[13:20:03.571]             length <- base::length
[13:20:03.571]             list <- base::list
[13:20:03.571]             seq.int <- base::seq.int
[13:20:03.571]             signalCondition <- base::signalCondition
[13:20:03.571]             sys.calls <- base::sys.calls
[13:20:03.571]             `[[` <- base::`[[`
[13:20:03.571]             `+` <- base::`+`
[13:20:03.571]             `<<-` <- base::`<<-`
[13:20:03.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.571]                   3L)]
[13:20:03.571]             }
[13:20:03.571]             function(cond) {
[13:20:03.571]                 is_error <- inherits(cond, "error")
[13:20:03.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.571]                   NULL)
[13:20:03.571]                 if (is_error) {
[13:20:03.571]                   sessionInformation <- function() {
[13:20:03.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.571]                       search = base::search(), system = base::Sys.info())
[13:20:03.571]                   }
[13:20:03.571]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.571]                     cond$call), session = sessionInformation(), 
[13:20:03.571]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.571]                   signalCondition(cond)
[13:20:03.571]                 }
[13:20:03.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.571]                 "immediateCondition"))) {
[13:20:03.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.571]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.571]                   if (TRUE && !signal) {
[13:20:03.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.571]                     {
[13:20:03.571]                       inherits <- base::inherits
[13:20:03.571]                       invokeRestart <- base::invokeRestart
[13:20:03.571]                       is.null <- base::is.null
[13:20:03.571]                       muffled <- FALSE
[13:20:03.571]                       if (inherits(cond, "message")) {
[13:20:03.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.571]                         if (muffled) 
[13:20:03.571]                           invokeRestart("muffleMessage")
[13:20:03.571]                       }
[13:20:03.571]                       else if (inherits(cond, "warning")) {
[13:20:03.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.571]                         if (muffled) 
[13:20:03.571]                           invokeRestart("muffleWarning")
[13:20:03.571]                       }
[13:20:03.571]                       else if (inherits(cond, "condition")) {
[13:20:03.571]                         if (!is.null(pattern)) {
[13:20:03.571]                           computeRestarts <- base::computeRestarts
[13:20:03.571]                           grepl <- base::grepl
[13:20:03.571]                           restarts <- computeRestarts(cond)
[13:20:03.571]                           for (restart in restarts) {
[13:20:03.571]                             name <- restart$name
[13:20:03.571]                             if (is.null(name)) 
[13:20:03.571]                               next
[13:20:03.571]                             if (!grepl(pattern, name)) 
[13:20:03.571]                               next
[13:20:03.571]                             invokeRestart(restart)
[13:20:03.571]                             muffled <- TRUE
[13:20:03.571]                             break
[13:20:03.571]                           }
[13:20:03.571]                         }
[13:20:03.571]                       }
[13:20:03.571]                       invisible(muffled)
[13:20:03.571]                     }
[13:20:03.571]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.571]                   }
[13:20:03.571]                 }
[13:20:03.571]                 else {
[13:20:03.571]                   if (TRUE) {
[13:20:03.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.571]                     {
[13:20:03.571]                       inherits <- base::inherits
[13:20:03.571]                       invokeRestart <- base::invokeRestart
[13:20:03.571]                       is.null <- base::is.null
[13:20:03.571]                       muffled <- FALSE
[13:20:03.571]                       if (inherits(cond, "message")) {
[13:20:03.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.571]                         if (muffled) 
[13:20:03.571]                           invokeRestart("muffleMessage")
[13:20:03.571]                       }
[13:20:03.571]                       else if (inherits(cond, "warning")) {
[13:20:03.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.571]                         if (muffled) 
[13:20:03.571]                           invokeRestart("muffleWarning")
[13:20:03.571]                       }
[13:20:03.571]                       else if (inherits(cond, "condition")) {
[13:20:03.571]                         if (!is.null(pattern)) {
[13:20:03.571]                           computeRestarts <- base::computeRestarts
[13:20:03.571]                           grepl <- base::grepl
[13:20:03.571]                           restarts <- computeRestarts(cond)
[13:20:03.571]                           for (restart in restarts) {
[13:20:03.571]                             name <- restart$name
[13:20:03.571]                             if (is.null(name)) 
[13:20:03.571]                               next
[13:20:03.571]                             if (!grepl(pattern, name)) 
[13:20:03.571]                               next
[13:20:03.571]                             invokeRestart(restart)
[13:20:03.571]                             muffled <- TRUE
[13:20:03.571]                             break
[13:20:03.571]                           }
[13:20:03.571]                         }
[13:20:03.571]                       }
[13:20:03.571]                       invisible(muffled)
[13:20:03.571]                     }
[13:20:03.571]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.571]                   }
[13:20:03.571]                 }
[13:20:03.571]             }
[13:20:03.571]         }))
[13:20:03.571]     }, error = function(ex) {
[13:20:03.571]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.571]                 ...future.rng), started = ...future.startTime, 
[13:20:03.571]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.571]             version = "1.8"), class = "FutureResult")
[13:20:03.571]     }, finally = {
[13:20:03.571]         if (!identical(...future.workdir, getwd())) 
[13:20:03.571]             setwd(...future.workdir)
[13:20:03.571]         {
[13:20:03.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.571]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.571]             }
[13:20:03.571]             base::options(...future.oldOptions)
[13:20:03.571]             if (.Platform$OS.type == "windows") {
[13:20:03.571]                 old_names <- names(...future.oldEnvVars)
[13:20:03.571]                 envs <- base::Sys.getenv()
[13:20:03.571]                 names <- names(envs)
[13:20:03.571]                 common <- intersect(names, old_names)
[13:20:03.571]                 added <- setdiff(names, old_names)
[13:20:03.571]                 removed <- setdiff(old_names, names)
[13:20:03.571]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.571]                   envs[common]]
[13:20:03.571]                 NAMES <- toupper(changed)
[13:20:03.571]                 args <- list()
[13:20:03.571]                 for (kk in seq_along(NAMES)) {
[13:20:03.571]                   name <- changed[[kk]]
[13:20:03.571]                   NAME <- NAMES[[kk]]
[13:20:03.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.571]                     next
[13:20:03.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.571]                 }
[13:20:03.571]                 NAMES <- toupper(added)
[13:20:03.571]                 for (kk in seq_along(NAMES)) {
[13:20:03.571]                   name <- added[[kk]]
[13:20:03.571]                   NAME <- NAMES[[kk]]
[13:20:03.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.571]                     next
[13:20:03.571]                   args[[name]] <- ""
[13:20:03.571]                 }
[13:20:03.571]                 NAMES <- toupper(removed)
[13:20:03.571]                 for (kk in seq_along(NAMES)) {
[13:20:03.571]                   name <- removed[[kk]]
[13:20:03.571]                   NAME <- NAMES[[kk]]
[13:20:03.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.571]                     next
[13:20:03.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.571]                 }
[13:20:03.571]                 if (length(args) > 0) 
[13:20:03.571]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.571]             }
[13:20:03.571]             else {
[13:20:03.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.571]             }
[13:20:03.571]             {
[13:20:03.571]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.571]                   0L) {
[13:20:03.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.571]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.571]                   base::options(opts)
[13:20:03.571]                 }
[13:20:03.571]                 {
[13:20:03.571]                   {
[13:20:03.571]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.571]                     NULL
[13:20:03.571]                   }
[13:20:03.571]                   options(future.plan = NULL)
[13:20:03.571]                   if (is.na(NA_character_)) 
[13:20:03.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.571]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.571]                     envir = parent.frame()) 
[13:20:03.571]                   {
[13:20:03.571]                     default_workers <- missing(workers)
[13:20:03.571]                     if (is.function(workers)) 
[13:20:03.571]                       workers <- workers()
[13:20:03.571]                     workers <- structure(as.integer(workers), 
[13:20:03.571]                       class = class(workers))
[13:20:03.571]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.571]                       1L)
[13:20:03.571]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.571]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.571]                       if (default_workers) 
[13:20:03.571]                         supportsMulticore(warn = TRUE)
[13:20:03.571]                       return(sequential(..., envir = envir))
[13:20:03.571]                     }
[13:20:03.571]                     oopts <- options(mc.cores = workers)
[13:20:03.571]                     on.exit(options(oopts))
[13:20:03.571]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.571]                       envir = envir)
[13:20:03.571]                     if (!future$lazy) 
[13:20:03.571]                       future <- run(future)
[13:20:03.571]                     invisible(future)
[13:20:03.571]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.571]                 }
[13:20:03.571]             }
[13:20:03.571]         }
[13:20:03.571]     })
[13:20:03.571]     if (TRUE) {
[13:20:03.571]         base::sink(type = "output", split = FALSE)
[13:20:03.571]         if (TRUE) {
[13:20:03.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.571]         }
[13:20:03.571]         else {
[13:20:03.571]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.571]         }
[13:20:03.571]         base::close(...future.stdout)
[13:20:03.571]         ...future.stdout <- NULL
[13:20:03.571]     }
[13:20:03.571]     ...future.result$conditions <- ...future.conditions
[13:20:03.571]     ...future.result$finished <- base::Sys.time()
[13:20:03.571]     ...future.result
[13:20:03.571] }
[13:20:03.574] assign_globals() ...
[13:20:03.574] List of 5
[13:20:03.574]  $ ...future.FUN            :function (object, ...)  
[13:20:03.574]  $ future.call.arguments    : list()
[13:20:03.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.574]  $ ...future.elements_ii    :List of 1
[13:20:03.574]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.574]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:03.574]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.574]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.574]  $ ...future.seeds_ii       : NULL
[13:20:03.574]  $ ...future.globals.maxSize: NULL
[13:20:03.574]  - attr(*, "where")=List of 5
[13:20:03.574]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.574]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.574]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.574]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.574]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.574]  - attr(*, "resolved")= logi FALSE
[13:20:03.574]  - attr(*, "total_size")= num 1240
[13:20:03.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.574]  - attr(*, "already-done")= logi TRUE
[13:20:03.580] - copied ‘...future.FUN’ to environment
[13:20:03.580] - copied ‘future.call.arguments’ to environment
[13:20:03.580] - copied ‘...future.elements_ii’ to environment
[13:20:03.580] - copied ‘...future.seeds_ii’ to environment
[13:20:03.580] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.580] assign_globals() ... done
[13:20:03.580] requestCore(): workers = 2
[13:20:03.582] MulticoreFuture started
[13:20:03.583] - Launch lazy future ... done
[13:20:03.583] run() for ‘MulticoreFuture’ ... done
[13:20:03.583] Created future:
[13:20:03.584] plan(): Setting new future strategy stack:
[13:20:03.584] List of future strategies:
[13:20:03.584] 1. sequential:
[13:20:03.584]    - args: function (..., envir = parent.frame())
[13:20:03.584]    - tweaked: FALSE
[13:20:03.584]    - call: NULL
[13:20:03.585] plan(): nbrOfWorkers() = 1
[13:20:03.588] plan(): Setting new future strategy stack:
[13:20:03.588] List of future strategies:
[13:20:03.588] 1. multicore:
[13:20:03.588]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.588]    - tweaked: FALSE
[13:20:03.588]    - call: plan(strategy)
[13:20:03.593] plan(): nbrOfWorkers() = 2
[13:20:03.583] MulticoreFuture:
[13:20:03.583] Label: ‘future_by-1’
[13:20:03.583] Expression:
[13:20:03.583] {
[13:20:03.583]     do.call(function(...) {
[13:20:03.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.583]             on.exit(options(oopts), add = TRUE)
[13:20:03.583]         }
[13:20:03.583]         {
[13:20:03.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.583]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.583]             })
[13:20:03.583]         }
[13:20:03.583]     }, args = future.call.arguments)
[13:20:03.583] }
[13:20:03.583] Lazy evaluation: FALSE
[13:20:03.583] Asynchronous evaluation: TRUE
[13:20:03.583] Local evaluation: TRUE
[13:20:03.583] Environment: 0x55aced1cbb98
[13:20:03.583] Capture standard output: TRUE
[13:20:03.583] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.583] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.583] Packages: <none>
[13:20:03.583] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.583] Resolved: TRUE
[13:20:03.583] Value: <not collected>
[13:20:03.583] Conditions captured: <none>
[13:20:03.583] Early signaling: FALSE
[13:20:03.583] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.583] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.594] Chunk #1 of 2 ... DONE
[13:20:03.594] Chunk #2 of 2 ...
[13:20:03.595]  - Finding globals in 'X' for chunk #2 ...
[13:20:03.595] getGlobalsAndPackages() ...
[13:20:03.595] Searching for globals...
[13:20:03.596] 
[13:20:03.596] Searching for globals ... DONE
[13:20:03.596] - globals: [0] <none>
[13:20:03.596] getGlobalsAndPackages() ... DONE
[13:20:03.596]    + additional globals found: [n=0] 
[13:20:03.596]    + additional namespaces needed: [n=0] 
[13:20:03.596]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:03.597]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.597]  - seeds: <none>
[13:20:03.597]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.597] getGlobalsAndPackages() ...
[13:20:03.597] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.597] Resolving globals: FALSE
[13:20:03.597] Tweak future expression to call with '...' arguments ...
[13:20:03.598] {
[13:20:03.598]     do.call(function(...) {
[13:20:03.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.598]             on.exit(options(oopts), add = TRUE)
[13:20:03.598]         }
[13:20:03.598]         {
[13:20:03.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.598]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.598]             })
[13:20:03.598]         }
[13:20:03.598]     }, args = future.call.arguments)
[13:20:03.598] }
[13:20:03.598] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.599] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.599] 
[13:20:03.599] getGlobalsAndPackages() ... DONE
[13:20:03.600] run() for ‘Future’ ...
[13:20:03.600] - state: ‘created’
[13:20:03.600] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.605] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.606]   - Field: ‘label’
[13:20:03.606]   - Field: ‘local’
[13:20:03.606]   - Field: ‘owner’
[13:20:03.606]   - Field: ‘envir’
[13:20:03.606]   - Field: ‘workers’
[13:20:03.606]   - Field: ‘packages’
[13:20:03.607]   - Field: ‘gc’
[13:20:03.607]   - Field: ‘job’
[13:20:03.607]   - Field: ‘conditions’
[13:20:03.607]   - Field: ‘expr’
[13:20:03.608]   - Field: ‘uuid’
[13:20:03.608]   - Field: ‘seed’
[13:20:03.608]   - Field: ‘version’
[13:20:03.608]   - Field: ‘result’
[13:20:03.609]   - Field: ‘asynchronous’
[13:20:03.609]   - Field: ‘calls’
[13:20:03.609]   - Field: ‘globals’
[13:20:03.609]   - Field: ‘stdout’
[13:20:03.609]   - Field: ‘earlySignal’
[13:20:03.609]   - Field: ‘lazy’
[13:20:03.610]   - Field: ‘state’
[13:20:03.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.610] - Launch lazy future ...
[13:20:03.610] Packages needed by the future expression (n = 0): <none>
[13:20:03.611] Packages needed by future strategies (n = 0): <none>
[13:20:03.612] {
[13:20:03.612]     {
[13:20:03.612]         {
[13:20:03.612]             ...future.startTime <- base::Sys.time()
[13:20:03.612]             {
[13:20:03.612]                 {
[13:20:03.612]                   {
[13:20:03.612]                     {
[13:20:03.612]                       base::local({
[13:20:03.612]                         has_future <- base::requireNamespace("future", 
[13:20:03.612]                           quietly = TRUE)
[13:20:03.612]                         if (has_future) {
[13:20:03.612]                           ns <- base::getNamespace("future")
[13:20:03.612]                           version <- ns[[".package"]][["version"]]
[13:20:03.612]                           if (is.null(version)) 
[13:20:03.612]                             version <- utils::packageVersion("future")
[13:20:03.612]                         }
[13:20:03.612]                         else {
[13:20:03.612]                           version <- NULL
[13:20:03.612]                         }
[13:20:03.612]                         if (!has_future || version < "1.8.0") {
[13:20:03.612]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.612]                             "", base::R.version$version.string), 
[13:20:03.612]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.612]                               "release", "version")], collapse = " "), 
[13:20:03.612]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.612]                             info)
[13:20:03.612]                           info <- base::paste(info, collapse = "; ")
[13:20:03.612]                           if (!has_future) {
[13:20:03.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.612]                               info)
[13:20:03.612]                           }
[13:20:03.612]                           else {
[13:20:03.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.612]                               info, version)
[13:20:03.612]                           }
[13:20:03.612]                           base::stop(msg)
[13:20:03.612]                         }
[13:20:03.612]                       })
[13:20:03.612]                     }
[13:20:03.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.612]                     base::options(mc.cores = 1L)
[13:20:03.612]                   }
[13:20:03.612]                   options(future.plan = NULL)
[13:20:03.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.612]                 }
[13:20:03.612]                 ...future.workdir <- getwd()
[13:20:03.612]             }
[13:20:03.612]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.612]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.612]         }
[13:20:03.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.612]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.612]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.612]             base::names(...future.oldOptions))
[13:20:03.612]     }
[13:20:03.612]     if (FALSE) {
[13:20:03.612]     }
[13:20:03.612]     else {
[13:20:03.612]         if (TRUE) {
[13:20:03.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.612]                 open = "w")
[13:20:03.612]         }
[13:20:03.612]         else {
[13:20:03.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.612]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.612]         }
[13:20:03.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.612]             base::sink(type = "output", split = FALSE)
[13:20:03.612]             base::close(...future.stdout)
[13:20:03.612]         }, add = TRUE)
[13:20:03.612]     }
[13:20:03.612]     ...future.frame <- base::sys.nframe()
[13:20:03.612]     ...future.conditions <- base::list()
[13:20:03.612]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.612]     if (FALSE) {
[13:20:03.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.612]     }
[13:20:03.612]     ...future.result <- base::tryCatch({
[13:20:03.612]         base::withCallingHandlers({
[13:20:03.612]             ...future.value <- base::withVisible(base::local({
[13:20:03.612]                 withCallingHandlers({
[13:20:03.612]                   {
[13:20:03.612]                     do.call(function(...) {
[13:20:03.612]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.612]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.612]                         ...future.globals.maxSize)) {
[13:20:03.612]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.612]                         on.exit(options(oopts), add = TRUE)
[13:20:03.612]                       }
[13:20:03.612]                       {
[13:20:03.612]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.612]                           FUN = function(jj) {
[13:20:03.612]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.612]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.612]                           })
[13:20:03.612]                       }
[13:20:03.612]                     }, args = future.call.arguments)
[13:20:03.612]                   }
[13:20:03.612]                 }, immediateCondition = function(cond) {
[13:20:03.612]                   save_rds <- function (object, pathname, ...) 
[13:20:03.612]                   {
[13:20:03.612]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.612]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.612]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.612]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.612]                         fi_tmp[["mtime"]])
[13:20:03.612]                     }
[13:20:03.612]                     tryCatch({
[13:20:03.612]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.612]                     }, error = function(ex) {
[13:20:03.612]                       msg <- conditionMessage(ex)
[13:20:03.612]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.612]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.612]                         fi_tmp[["mtime"]], msg)
[13:20:03.612]                       ex$message <- msg
[13:20:03.612]                       stop(ex)
[13:20:03.612]                     })
[13:20:03.612]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.612]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.612]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.612]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.612]                       fi <- file.info(pathname)
[13:20:03.612]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.612]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.612]                         fi[["size"]], fi[["mtime"]])
[13:20:03.612]                       stop(msg)
[13:20:03.612]                     }
[13:20:03.612]                     invisible(pathname)
[13:20:03.612]                   }
[13:20:03.612]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.612]                     rootPath = tempdir()) 
[13:20:03.612]                   {
[13:20:03.612]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.612]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.612]                       tmpdir = path, fileext = ".rds")
[13:20:03.612]                     save_rds(obj, file)
[13:20:03.612]                   }
[13:20:03.612]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.612]                   {
[13:20:03.612]                     inherits <- base::inherits
[13:20:03.612]                     invokeRestart <- base::invokeRestart
[13:20:03.612]                     is.null <- base::is.null
[13:20:03.612]                     muffled <- FALSE
[13:20:03.612]                     if (inherits(cond, "message")) {
[13:20:03.612]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.612]                       if (muffled) 
[13:20:03.612]                         invokeRestart("muffleMessage")
[13:20:03.612]                     }
[13:20:03.612]                     else if (inherits(cond, "warning")) {
[13:20:03.612]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.612]                       if (muffled) 
[13:20:03.612]                         invokeRestart("muffleWarning")
[13:20:03.612]                     }
[13:20:03.612]                     else if (inherits(cond, "condition")) {
[13:20:03.612]                       if (!is.null(pattern)) {
[13:20:03.612]                         computeRestarts <- base::computeRestarts
[13:20:03.612]                         grepl <- base::grepl
[13:20:03.612]                         restarts <- computeRestarts(cond)
[13:20:03.612]                         for (restart in restarts) {
[13:20:03.612]                           name <- restart$name
[13:20:03.612]                           if (is.null(name)) 
[13:20:03.612]                             next
[13:20:03.612]                           if (!grepl(pattern, name)) 
[13:20:03.612]                             next
[13:20:03.612]                           invokeRestart(restart)
[13:20:03.612]                           muffled <- TRUE
[13:20:03.612]                           break
[13:20:03.612]                         }
[13:20:03.612]                       }
[13:20:03.612]                     }
[13:20:03.612]                     invisible(muffled)
[13:20:03.612]                   }
[13:20:03.612]                   muffleCondition(cond)
[13:20:03.612]                 })
[13:20:03.612]             }))
[13:20:03.612]             future::FutureResult(value = ...future.value$value, 
[13:20:03.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.612]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.612]                     ...future.globalenv.names))
[13:20:03.612]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.612]         }, condition = base::local({
[13:20:03.612]             c <- base::c
[13:20:03.612]             inherits <- base::inherits
[13:20:03.612]             invokeRestart <- base::invokeRestart
[13:20:03.612]             length <- base::length
[13:20:03.612]             list <- base::list
[13:20:03.612]             seq.int <- base::seq.int
[13:20:03.612]             signalCondition <- base::signalCondition
[13:20:03.612]             sys.calls <- base::sys.calls
[13:20:03.612]             `[[` <- base::`[[`
[13:20:03.612]             `+` <- base::`+`
[13:20:03.612]             `<<-` <- base::`<<-`
[13:20:03.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.612]                   3L)]
[13:20:03.612]             }
[13:20:03.612]             function(cond) {
[13:20:03.612]                 is_error <- inherits(cond, "error")
[13:20:03.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.612]                   NULL)
[13:20:03.612]                 if (is_error) {
[13:20:03.612]                   sessionInformation <- function() {
[13:20:03.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.612]                       search = base::search(), system = base::Sys.info())
[13:20:03.612]                   }
[13:20:03.612]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.612]                     cond$call), session = sessionInformation(), 
[13:20:03.612]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.612]                   signalCondition(cond)
[13:20:03.612]                 }
[13:20:03.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.612]                 "immediateCondition"))) {
[13:20:03.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.612]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.612]                   if (TRUE && !signal) {
[13:20:03.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.612]                     {
[13:20:03.612]                       inherits <- base::inherits
[13:20:03.612]                       invokeRestart <- base::invokeRestart
[13:20:03.612]                       is.null <- base::is.null
[13:20:03.612]                       muffled <- FALSE
[13:20:03.612]                       if (inherits(cond, "message")) {
[13:20:03.612]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.612]                         if (muffled) 
[13:20:03.612]                           invokeRestart("muffleMessage")
[13:20:03.612]                       }
[13:20:03.612]                       else if (inherits(cond, "warning")) {
[13:20:03.612]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.612]                         if (muffled) 
[13:20:03.612]                           invokeRestart("muffleWarning")
[13:20:03.612]                       }
[13:20:03.612]                       else if (inherits(cond, "condition")) {
[13:20:03.612]                         if (!is.null(pattern)) {
[13:20:03.612]                           computeRestarts <- base::computeRestarts
[13:20:03.612]                           grepl <- base::grepl
[13:20:03.612]                           restarts <- computeRestarts(cond)
[13:20:03.612]                           for (restart in restarts) {
[13:20:03.612]                             name <- restart$name
[13:20:03.612]                             if (is.null(name)) 
[13:20:03.612]                               next
[13:20:03.612]                             if (!grepl(pattern, name)) 
[13:20:03.612]                               next
[13:20:03.612]                             invokeRestart(restart)
[13:20:03.612]                             muffled <- TRUE
[13:20:03.612]                             break
[13:20:03.612]                           }
[13:20:03.612]                         }
[13:20:03.612]                       }
[13:20:03.612]                       invisible(muffled)
[13:20:03.612]                     }
[13:20:03.612]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.612]                   }
[13:20:03.612]                 }
[13:20:03.612]                 else {
[13:20:03.612]                   if (TRUE) {
[13:20:03.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.612]                     {
[13:20:03.612]                       inherits <- base::inherits
[13:20:03.612]                       invokeRestart <- base::invokeRestart
[13:20:03.612]                       is.null <- base::is.null
[13:20:03.612]                       muffled <- FALSE
[13:20:03.612]                       if (inherits(cond, "message")) {
[13:20:03.612]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.612]                         if (muffled) 
[13:20:03.612]                           invokeRestart("muffleMessage")
[13:20:03.612]                       }
[13:20:03.612]                       else if (inherits(cond, "warning")) {
[13:20:03.612]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.612]                         if (muffled) 
[13:20:03.612]                           invokeRestart("muffleWarning")
[13:20:03.612]                       }
[13:20:03.612]                       else if (inherits(cond, "condition")) {
[13:20:03.612]                         if (!is.null(pattern)) {
[13:20:03.612]                           computeRestarts <- base::computeRestarts
[13:20:03.612]                           grepl <- base::grepl
[13:20:03.612]                           restarts <- computeRestarts(cond)
[13:20:03.612]                           for (restart in restarts) {
[13:20:03.612]                             name <- restart$name
[13:20:03.612]                             if (is.null(name)) 
[13:20:03.612]                               next
[13:20:03.612]                             if (!grepl(pattern, name)) 
[13:20:03.612]                               next
[13:20:03.612]                             invokeRestart(restart)
[13:20:03.612]                             muffled <- TRUE
[13:20:03.612]                             break
[13:20:03.612]                           }
[13:20:03.612]                         }
[13:20:03.612]                       }
[13:20:03.612]                       invisible(muffled)
[13:20:03.612]                     }
[13:20:03.612]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.612]                   }
[13:20:03.612]                 }
[13:20:03.612]             }
[13:20:03.612]         }))
[13:20:03.612]     }, error = function(ex) {
[13:20:03.612]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.612]                 ...future.rng), started = ...future.startTime, 
[13:20:03.612]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.612]             version = "1.8"), class = "FutureResult")
[13:20:03.612]     }, finally = {
[13:20:03.612]         if (!identical(...future.workdir, getwd())) 
[13:20:03.612]             setwd(...future.workdir)
[13:20:03.612]         {
[13:20:03.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.612]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.612]             }
[13:20:03.612]             base::options(...future.oldOptions)
[13:20:03.612]             if (.Platform$OS.type == "windows") {
[13:20:03.612]                 old_names <- names(...future.oldEnvVars)
[13:20:03.612]                 envs <- base::Sys.getenv()
[13:20:03.612]                 names <- names(envs)
[13:20:03.612]                 common <- intersect(names, old_names)
[13:20:03.612]                 added <- setdiff(names, old_names)
[13:20:03.612]                 removed <- setdiff(old_names, names)
[13:20:03.612]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.612]                   envs[common]]
[13:20:03.612]                 NAMES <- toupper(changed)
[13:20:03.612]                 args <- list()
[13:20:03.612]                 for (kk in seq_along(NAMES)) {
[13:20:03.612]                   name <- changed[[kk]]
[13:20:03.612]                   NAME <- NAMES[[kk]]
[13:20:03.612]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.612]                     next
[13:20:03.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.612]                 }
[13:20:03.612]                 NAMES <- toupper(added)
[13:20:03.612]                 for (kk in seq_along(NAMES)) {
[13:20:03.612]                   name <- added[[kk]]
[13:20:03.612]                   NAME <- NAMES[[kk]]
[13:20:03.612]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.612]                     next
[13:20:03.612]                   args[[name]] <- ""
[13:20:03.612]                 }
[13:20:03.612]                 NAMES <- toupper(removed)
[13:20:03.612]                 for (kk in seq_along(NAMES)) {
[13:20:03.612]                   name <- removed[[kk]]
[13:20:03.612]                   NAME <- NAMES[[kk]]
[13:20:03.612]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.612]                     next
[13:20:03.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.612]                 }
[13:20:03.612]                 if (length(args) > 0) 
[13:20:03.612]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.612]             }
[13:20:03.612]             else {
[13:20:03.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.612]             }
[13:20:03.612]             {
[13:20:03.612]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.612]                   0L) {
[13:20:03.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.612]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.612]                   base::options(opts)
[13:20:03.612]                 }
[13:20:03.612]                 {
[13:20:03.612]                   {
[13:20:03.612]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.612]                     NULL
[13:20:03.612]                   }
[13:20:03.612]                   options(future.plan = NULL)
[13:20:03.612]                   if (is.na(NA_character_)) 
[13:20:03.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.612]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.612]                     envir = parent.frame()) 
[13:20:03.612]                   {
[13:20:03.612]                     default_workers <- missing(workers)
[13:20:03.612]                     if (is.function(workers)) 
[13:20:03.612]                       workers <- workers()
[13:20:03.612]                     workers <- structure(as.integer(workers), 
[13:20:03.612]                       class = class(workers))
[13:20:03.612]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.612]                       1L)
[13:20:03.612]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.612]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.612]                       if (default_workers) 
[13:20:03.612]                         supportsMulticore(warn = TRUE)
[13:20:03.612]                       return(sequential(..., envir = envir))
[13:20:03.612]                     }
[13:20:03.612]                     oopts <- options(mc.cores = workers)
[13:20:03.612]                     on.exit(options(oopts))
[13:20:03.612]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.612]                       envir = envir)
[13:20:03.612]                     if (!future$lazy) 
[13:20:03.612]                       future <- run(future)
[13:20:03.612]                     invisible(future)
[13:20:03.612]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.612]                 }
[13:20:03.612]             }
[13:20:03.612]         }
[13:20:03.612]     })
[13:20:03.612]     if (TRUE) {
[13:20:03.612]         base::sink(type = "output", split = FALSE)
[13:20:03.612]         if (TRUE) {
[13:20:03.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.612]         }
[13:20:03.612]         else {
[13:20:03.612]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.612]         }
[13:20:03.612]         base::close(...future.stdout)
[13:20:03.612]         ...future.stdout <- NULL
[13:20:03.612]     }
[13:20:03.612]     ...future.result$conditions <- ...future.conditions
[13:20:03.612]     ...future.result$finished <- base::Sys.time()
[13:20:03.612]     ...future.result
[13:20:03.612] }
[13:20:03.615] assign_globals() ...
[13:20:03.615] List of 5
[13:20:03.615]  $ ...future.FUN            :function (object, ...)  
[13:20:03.615]  $ future.call.arguments    : list()
[13:20:03.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.615]  $ ...future.elements_ii    :List of 2
[13:20:03.615]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.615]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:03.615]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.615]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:03.615]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.615]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:03.615]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.615]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:03.615]  $ ...future.seeds_ii       : NULL
[13:20:03.615]  $ ...future.globals.maxSize: NULL
[13:20:03.615]  - attr(*, "where")=List of 5
[13:20:03.615]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.615]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.615]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.615]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.615]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.615]  - attr(*, "resolved")= logi FALSE
[13:20:03.615]  - attr(*, "total_size")= num 1240
[13:20:03.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.615]  - attr(*, "already-done")= logi TRUE
[13:20:03.626] - copied ‘...future.FUN’ to environment
[13:20:03.626] - copied ‘future.call.arguments’ to environment
[13:20:03.626] - copied ‘...future.elements_ii’ to environment
[13:20:03.627] - copied ‘...future.seeds_ii’ to environment
[13:20:03.627] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.627] assign_globals() ... done
[13:20:03.627] requestCore(): workers = 2
[13:20:03.629] MulticoreFuture started
[13:20:03.630] - Launch lazy future ... done
[13:20:03.630] run() for ‘MulticoreFuture’ ... done
[13:20:03.630] Created future:
[13:20:03.631] plan(): Setting new future strategy stack:
[13:20:03.631] List of future strategies:
[13:20:03.631] 1. sequential:
[13:20:03.631]    - args: function (..., envir = parent.frame())
[13:20:03.631]    - tweaked: FALSE
[13:20:03.631]    - call: NULL
[13:20:03.632] plan(): nbrOfWorkers() = 1
[13:20:03.635] plan(): Setting new future strategy stack:
[13:20:03.636] List of future strategies:
[13:20:03.636] 1. multicore:
[13:20:03.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.636]    - tweaked: FALSE
[13:20:03.636]    - call: plan(strategy)
[13:20:03.641] plan(): nbrOfWorkers() = 2
[13:20:03.630] MulticoreFuture:
[13:20:03.630] Label: ‘future_by-2’
[13:20:03.630] Expression:
[13:20:03.630] {
[13:20:03.630]     do.call(function(...) {
[13:20:03.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.630]             on.exit(options(oopts), add = TRUE)
[13:20:03.630]         }
[13:20:03.630]         {
[13:20:03.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.630]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.630]             })
[13:20:03.630]         }
[13:20:03.630]     }, args = future.call.arguments)
[13:20:03.630] }
[13:20:03.630] Lazy evaluation: FALSE
[13:20:03.630] Asynchronous evaluation: TRUE
[13:20:03.630] Local evaluation: TRUE
[13:20:03.630] Environment: 0x55aced1cbb98
[13:20:03.630] Capture standard output: TRUE
[13:20:03.630] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.630] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.630] Packages: <none>
[13:20:03.630] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.630] Resolved: TRUE
[13:20:03.630] Value: <not collected>
[13:20:03.630] Conditions captured: <none>
[13:20:03.630] Early signaling: FALSE
[13:20:03.630] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.630] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.642] Chunk #2 of 2 ... DONE
[13:20:03.642] Launching 2 futures (chunks) ... DONE
[13:20:03.642] Resolving 2 futures (chunks) ...
[13:20:03.642] resolve() on list ...
[13:20:03.642]  recursive: 0
[13:20:03.643]  length: 2
[13:20:03.643] 
[13:20:03.643] Future #1
[13:20:03.643] result() for MulticoreFuture ...
[13:20:03.644] result() for MulticoreFuture ...
[13:20:03.644] result() for MulticoreFuture ... done
[13:20:03.645] result() for MulticoreFuture ... done
[13:20:03.645] result() for MulticoreFuture ...
[13:20:03.645] result() for MulticoreFuture ... done
[13:20:03.645] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:03.645] - nx: 2
[13:20:03.645] - relay: TRUE
[13:20:03.645] - stdout: TRUE
[13:20:03.646] - signal: TRUE
[13:20:03.646] - resignal: FALSE
[13:20:03.646] - force: TRUE
[13:20:03.646] - relayed: [n=2] FALSE, FALSE
[13:20:03.646] - queued futures: [n=2] FALSE, FALSE
[13:20:03.646]  - until=1
[13:20:03.646]  - relaying element #1
[13:20:03.646] result() for MulticoreFuture ...
[13:20:03.647] result() for MulticoreFuture ... done
[13:20:03.647] result() for MulticoreFuture ...
[13:20:03.647] result() for MulticoreFuture ... done
[13:20:03.647] result() for MulticoreFuture ...
[13:20:03.647] result() for MulticoreFuture ... done
[13:20:03.647] result() for MulticoreFuture ...
[13:20:03.648] result() for MulticoreFuture ... done
[13:20:03.648] - relayed: [n=2] TRUE, FALSE
[13:20:03.648] - queued futures: [n=2] TRUE, FALSE
[13:20:03.648] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:03.648]  length: 1 (resolved future 1)
[13:20:03.648] Future #2
[13:20:03.649] result() for MulticoreFuture ...
[13:20:03.649] result() for MulticoreFuture ...
[13:20:03.649] result() for MulticoreFuture ... done
[13:20:03.649] result() for MulticoreFuture ... done
[13:20:03.650] result() for MulticoreFuture ...
[13:20:03.650] result() for MulticoreFuture ... done
[13:20:03.650] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:03.650] - nx: 2
[13:20:03.650] - relay: TRUE
[13:20:03.650] - stdout: TRUE
[13:20:03.650] - signal: TRUE
[13:20:03.650] - resignal: FALSE
[13:20:03.651] - force: TRUE
[13:20:03.651] - relayed: [n=2] TRUE, FALSE
[13:20:03.651] - queued futures: [n=2] TRUE, FALSE
[13:20:03.651]  - until=2
[13:20:03.651]  - relaying element #2
[13:20:03.651] result() for MulticoreFuture ...
[13:20:03.651] result() for MulticoreFuture ... done
[13:20:03.651] result() for MulticoreFuture ...
[13:20:03.652] result() for MulticoreFuture ... done
[13:20:03.652] result() for MulticoreFuture ...
[13:20:03.652] result() for MulticoreFuture ... done
[13:20:03.652] result() for MulticoreFuture ...
[13:20:03.652] result() for MulticoreFuture ... done
[13:20:03.652] - relayed: [n=2] TRUE, TRUE
[13:20:03.652] - queued futures: [n=2] TRUE, TRUE
[13:20:03.653] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:03.653]  length: 0 (resolved future 2)
[13:20:03.653] Relaying remaining futures
[13:20:03.653] signalConditionsASAP(NULL, pos=0) ...
[13:20:03.653] - nx: 2
[13:20:03.653] - relay: TRUE
[13:20:03.653] - stdout: TRUE
[13:20:03.653] - signal: TRUE
[13:20:03.653] - resignal: FALSE
[13:20:03.653] - force: TRUE
[13:20:03.654] - relayed: [n=2] TRUE, TRUE
[13:20:03.654] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:03.654] - relayed: [n=2] TRUE, TRUE
[13:20:03.654] - queued futures: [n=2] TRUE, TRUE
[13:20:03.654] signalConditionsASAP(NULL, pos=0) ... done
[13:20:03.654] resolve() on list ... DONE
[13:20:03.654] result() for MulticoreFuture ...
[13:20:03.654] result() for MulticoreFuture ... done
[13:20:03.655] result() for MulticoreFuture ...
[13:20:03.655] result() for MulticoreFuture ... done
[13:20:03.655] result() for MulticoreFuture ...
[13:20:03.655] result() for MulticoreFuture ... done
[13:20:03.655] result() for MulticoreFuture ...
[13:20:03.655] result() for MulticoreFuture ... done
[13:20:03.655]  - Number of value chunks collected: 2
[13:20:03.655] Resolving 2 futures (chunks) ... DONE
[13:20:03.656] Reducing values from 2 chunks ...
[13:20:03.656]  - Number of values collected after concatenation: 3
[13:20:03.656]  - Number of values expected: 3
[13:20:03.656] Reducing values from 2 chunks ... DONE
[13:20:03.656] future_lapply() ... DONE
[13:20:03.656] future_by_internal() ... DONE
[13:20:03.658] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:20:03.658] future_lapply() ...
[13:20:03.663] Number of chunks: 2
[13:20:03.663] getGlobalsAndPackagesXApply() ...
[13:20:03.664]  - future.globals: TRUE
[13:20:03.664] getGlobalsAndPackages() ...
[13:20:03.664] Searching for globals...
[13:20:03.665] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:03.665] Searching for globals ... DONE
[13:20:03.666] Resolving globals: FALSE
[13:20:03.666] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:03.667] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:03.667] - globals: [1] ‘FUN’
[13:20:03.667] 
[13:20:03.667] getGlobalsAndPackages() ... DONE
[13:20:03.667]  - globals found/used: [n=1] ‘FUN’
[13:20:03.667]  - needed namespaces: [n=0] 
[13:20:03.667] Finding globals ... DONE
[13:20:03.667]  - use_args: TRUE
[13:20:03.668]  - Getting '...' globals ...
[13:20:03.668] resolve() on list ...
[13:20:03.668]  recursive: 0
[13:20:03.668]  length: 1
[13:20:03.668]  elements: ‘...’
[13:20:03.668]  length: 0 (resolved future 1)
[13:20:03.669] resolve() on list ... DONE
[13:20:03.669]    - '...' content: [n=0] 
[13:20:03.669] List of 1
[13:20:03.669]  $ ...: list()
[13:20:03.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.669]  - attr(*, "where")=List of 1
[13:20:03.669]   ..$ ...:<environment: 0x55aceff27820> 
[13:20:03.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.669]  - attr(*, "resolved")= logi TRUE
[13:20:03.669]  - attr(*, "total_size")= num NA
[13:20:03.672]  - Getting '...' globals ... DONE
[13:20:03.673] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:03.673] List of 2
[13:20:03.673]  $ ...future.FUN:function (object, ...)  
[13:20:03.673]  $ ...          : list()
[13:20:03.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.673]  - attr(*, "where")=List of 2
[13:20:03.673]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:03.673]   ..$ ...          :<environment: 0x55aceff27820> 
[13:20:03.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.673]  - attr(*, "resolved")= logi FALSE
[13:20:03.673]  - attr(*, "total_size")= num 1240
[13:20:03.676] Packages to be attached in all futures: [n=0] 
[13:20:03.676] getGlobalsAndPackagesXApply() ... DONE
[13:20:03.677] Number of futures (= number of chunks): 2
[13:20:03.677] Launching 2 futures (chunks) ...
[13:20:03.677] Chunk #1 of 2 ...
[13:20:03.677]  - Finding globals in 'X' for chunk #1 ...
[13:20:03.677] getGlobalsAndPackages() ...
[13:20:03.677] Searching for globals...
[13:20:03.678] 
[13:20:03.678] Searching for globals ... DONE
[13:20:03.678] - globals: [0] <none>
[13:20:03.678] getGlobalsAndPackages() ... DONE
[13:20:03.678]    + additional globals found: [n=0] 
[13:20:03.678]    + additional namespaces needed: [n=0] 
[13:20:03.678]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:03.678]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.679]  - seeds: <none>
[13:20:03.679]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.679] getGlobalsAndPackages() ...
[13:20:03.679] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.679] Resolving globals: FALSE
[13:20:03.679] Tweak future expression to call with '...' arguments ...
[13:20:03.679] {
[13:20:03.679]     do.call(function(...) {
[13:20:03.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.679]             on.exit(options(oopts), add = TRUE)
[13:20:03.679]         }
[13:20:03.679]         {
[13:20:03.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.679]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.679]             })
[13:20:03.679]         }
[13:20:03.679]     }, args = future.call.arguments)
[13:20:03.679] }
[13:20:03.680] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.680] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.680] 
[13:20:03.680] getGlobalsAndPackages() ... DONE
[13:20:03.681] run() for ‘Future’ ...
[13:20:03.681] - state: ‘created’
[13:20:03.681] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.685] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.686]   - Field: ‘label’
[13:20:03.686]   - Field: ‘local’
[13:20:03.686]   - Field: ‘owner’
[13:20:03.686]   - Field: ‘envir’
[13:20:03.686]   - Field: ‘workers’
[13:20:03.686]   - Field: ‘packages’
[13:20:03.686]   - Field: ‘gc’
[13:20:03.686]   - Field: ‘job’
[13:20:03.687]   - Field: ‘conditions’
[13:20:03.687]   - Field: ‘expr’
[13:20:03.687]   - Field: ‘uuid’
[13:20:03.687]   - Field: ‘seed’
[13:20:03.687]   - Field: ‘version’
[13:20:03.687]   - Field: ‘result’
[13:20:03.687]   - Field: ‘asynchronous’
[13:20:03.687]   - Field: ‘calls’
[13:20:03.687]   - Field: ‘globals’
[13:20:03.688]   - Field: ‘stdout’
[13:20:03.688]   - Field: ‘earlySignal’
[13:20:03.688]   - Field: ‘lazy’
[13:20:03.688]   - Field: ‘state’
[13:20:03.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.688] - Launch lazy future ...
[13:20:03.689] Packages needed by the future expression (n = 0): <none>
[13:20:03.689] Packages needed by future strategies (n = 0): <none>
[13:20:03.689] {
[13:20:03.689]     {
[13:20:03.689]         {
[13:20:03.689]             ...future.startTime <- base::Sys.time()
[13:20:03.689]             {
[13:20:03.689]                 {
[13:20:03.689]                   {
[13:20:03.689]                     {
[13:20:03.689]                       base::local({
[13:20:03.689]                         has_future <- base::requireNamespace("future", 
[13:20:03.689]                           quietly = TRUE)
[13:20:03.689]                         if (has_future) {
[13:20:03.689]                           ns <- base::getNamespace("future")
[13:20:03.689]                           version <- ns[[".package"]][["version"]]
[13:20:03.689]                           if (is.null(version)) 
[13:20:03.689]                             version <- utils::packageVersion("future")
[13:20:03.689]                         }
[13:20:03.689]                         else {
[13:20:03.689]                           version <- NULL
[13:20:03.689]                         }
[13:20:03.689]                         if (!has_future || version < "1.8.0") {
[13:20:03.689]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.689]                             "", base::R.version$version.string), 
[13:20:03.689]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.689]                               "release", "version")], collapse = " "), 
[13:20:03.689]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.689]                             info)
[13:20:03.689]                           info <- base::paste(info, collapse = "; ")
[13:20:03.689]                           if (!has_future) {
[13:20:03.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.689]                               info)
[13:20:03.689]                           }
[13:20:03.689]                           else {
[13:20:03.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.689]                               info, version)
[13:20:03.689]                           }
[13:20:03.689]                           base::stop(msg)
[13:20:03.689]                         }
[13:20:03.689]                       })
[13:20:03.689]                     }
[13:20:03.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.689]                     base::options(mc.cores = 1L)
[13:20:03.689]                   }
[13:20:03.689]                   options(future.plan = NULL)
[13:20:03.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.689]                 }
[13:20:03.689]                 ...future.workdir <- getwd()
[13:20:03.689]             }
[13:20:03.689]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.689]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.689]         }
[13:20:03.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.689]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.689]             base::names(...future.oldOptions))
[13:20:03.689]     }
[13:20:03.689]     if (FALSE) {
[13:20:03.689]     }
[13:20:03.689]     else {
[13:20:03.689]         if (TRUE) {
[13:20:03.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.689]                 open = "w")
[13:20:03.689]         }
[13:20:03.689]         else {
[13:20:03.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.689]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.689]         }
[13:20:03.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.689]             base::sink(type = "output", split = FALSE)
[13:20:03.689]             base::close(...future.stdout)
[13:20:03.689]         }, add = TRUE)
[13:20:03.689]     }
[13:20:03.689]     ...future.frame <- base::sys.nframe()
[13:20:03.689]     ...future.conditions <- base::list()
[13:20:03.689]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.689]     if (FALSE) {
[13:20:03.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.689]     }
[13:20:03.689]     ...future.result <- base::tryCatch({
[13:20:03.689]         base::withCallingHandlers({
[13:20:03.689]             ...future.value <- base::withVisible(base::local({
[13:20:03.689]                 withCallingHandlers({
[13:20:03.689]                   {
[13:20:03.689]                     do.call(function(...) {
[13:20:03.689]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.689]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.689]                         ...future.globals.maxSize)) {
[13:20:03.689]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.689]                         on.exit(options(oopts), add = TRUE)
[13:20:03.689]                       }
[13:20:03.689]                       {
[13:20:03.689]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.689]                           FUN = function(jj) {
[13:20:03.689]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.689]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.689]                           })
[13:20:03.689]                       }
[13:20:03.689]                     }, args = future.call.arguments)
[13:20:03.689]                   }
[13:20:03.689]                 }, immediateCondition = function(cond) {
[13:20:03.689]                   save_rds <- function (object, pathname, ...) 
[13:20:03.689]                   {
[13:20:03.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.689]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.689]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.689]                         fi_tmp[["mtime"]])
[13:20:03.689]                     }
[13:20:03.689]                     tryCatch({
[13:20:03.689]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.689]                     }, error = function(ex) {
[13:20:03.689]                       msg <- conditionMessage(ex)
[13:20:03.689]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.689]                         fi_tmp[["mtime"]], msg)
[13:20:03.689]                       ex$message <- msg
[13:20:03.689]                       stop(ex)
[13:20:03.689]                     })
[13:20:03.689]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.689]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.689]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.689]                       fi <- file.info(pathname)
[13:20:03.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.689]                         fi[["size"]], fi[["mtime"]])
[13:20:03.689]                       stop(msg)
[13:20:03.689]                     }
[13:20:03.689]                     invisible(pathname)
[13:20:03.689]                   }
[13:20:03.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.689]                     rootPath = tempdir()) 
[13:20:03.689]                   {
[13:20:03.689]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.689]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.689]                       tmpdir = path, fileext = ".rds")
[13:20:03.689]                     save_rds(obj, file)
[13:20:03.689]                   }
[13:20:03.689]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.689]                   {
[13:20:03.689]                     inherits <- base::inherits
[13:20:03.689]                     invokeRestart <- base::invokeRestart
[13:20:03.689]                     is.null <- base::is.null
[13:20:03.689]                     muffled <- FALSE
[13:20:03.689]                     if (inherits(cond, "message")) {
[13:20:03.689]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.689]                       if (muffled) 
[13:20:03.689]                         invokeRestart("muffleMessage")
[13:20:03.689]                     }
[13:20:03.689]                     else if (inherits(cond, "warning")) {
[13:20:03.689]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.689]                       if (muffled) 
[13:20:03.689]                         invokeRestart("muffleWarning")
[13:20:03.689]                     }
[13:20:03.689]                     else if (inherits(cond, "condition")) {
[13:20:03.689]                       if (!is.null(pattern)) {
[13:20:03.689]                         computeRestarts <- base::computeRestarts
[13:20:03.689]                         grepl <- base::grepl
[13:20:03.689]                         restarts <- computeRestarts(cond)
[13:20:03.689]                         for (restart in restarts) {
[13:20:03.689]                           name <- restart$name
[13:20:03.689]                           if (is.null(name)) 
[13:20:03.689]                             next
[13:20:03.689]                           if (!grepl(pattern, name)) 
[13:20:03.689]                             next
[13:20:03.689]                           invokeRestart(restart)
[13:20:03.689]                           muffled <- TRUE
[13:20:03.689]                           break
[13:20:03.689]                         }
[13:20:03.689]                       }
[13:20:03.689]                     }
[13:20:03.689]                     invisible(muffled)
[13:20:03.689]                   }
[13:20:03.689]                   muffleCondition(cond)
[13:20:03.689]                 })
[13:20:03.689]             }))
[13:20:03.689]             future::FutureResult(value = ...future.value$value, 
[13:20:03.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.689]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.689]                     ...future.globalenv.names))
[13:20:03.689]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.689]         }, condition = base::local({
[13:20:03.689]             c <- base::c
[13:20:03.689]             inherits <- base::inherits
[13:20:03.689]             invokeRestart <- base::invokeRestart
[13:20:03.689]             length <- base::length
[13:20:03.689]             list <- base::list
[13:20:03.689]             seq.int <- base::seq.int
[13:20:03.689]             signalCondition <- base::signalCondition
[13:20:03.689]             sys.calls <- base::sys.calls
[13:20:03.689]             `[[` <- base::`[[`
[13:20:03.689]             `+` <- base::`+`
[13:20:03.689]             `<<-` <- base::`<<-`
[13:20:03.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.689]                   3L)]
[13:20:03.689]             }
[13:20:03.689]             function(cond) {
[13:20:03.689]                 is_error <- inherits(cond, "error")
[13:20:03.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.689]                   NULL)
[13:20:03.689]                 if (is_error) {
[13:20:03.689]                   sessionInformation <- function() {
[13:20:03.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.689]                       search = base::search(), system = base::Sys.info())
[13:20:03.689]                   }
[13:20:03.689]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.689]                     cond$call), session = sessionInformation(), 
[13:20:03.689]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.689]                   signalCondition(cond)
[13:20:03.689]                 }
[13:20:03.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.689]                 "immediateCondition"))) {
[13:20:03.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.689]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.689]                   if (TRUE && !signal) {
[13:20:03.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.689]                     {
[13:20:03.689]                       inherits <- base::inherits
[13:20:03.689]                       invokeRestart <- base::invokeRestart
[13:20:03.689]                       is.null <- base::is.null
[13:20:03.689]                       muffled <- FALSE
[13:20:03.689]                       if (inherits(cond, "message")) {
[13:20:03.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.689]                         if (muffled) 
[13:20:03.689]                           invokeRestart("muffleMessage")
[13:20:03.689]                       }
[13:20:03.689]                       else if (inherits(cond, "warning")) {
[13:20:03.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.689]                         if (muffled) 
[13:20:03.689]                           invokeRestart("muffleWarning")
[13:20:03.689]                       }
[13:20:03.689]                       else if (inherits(cond, "condition")) {
[13:20:03.689]                         if (!is.null(pattern)) {
[13:20:03.689]                           computeRestarts <- base::computeRestarts
[13:20:03.689]                           grepl <- base::grepl
[13:20:03.689]                           restarts <- computeRestarts(cond)
[13:20:03.689]                           for (restart in restarts) {
[13:20:03.689]                             name <- restart$name
[13:20:03.689]                             if (is.null(name)) 
[13:20:03.689]                               next
[13:20:03.689]                             if (!grepl(pattern, name)) 
[13:20:03.689]                               next
[13:20:03.689]                             invokeRestart(restart)
[13:20:03.689]                             muffled <- TRUE
[13:20:03.689]                             break
[13:20:03.689]                           }
[13:20:03.689]                         }
[13:20:03.689]                       }
[13:20:03.689]                       invisible(muffled)
[13:20:03.689]                     }
[13:20:03.689]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.689]                   }
[13:20:03.689]                 }
[13:20:03.689]                 else {
[13:20:03.689]                   if (TRUE) {
[13:20:03.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.689]                     {
[13:20:03.689]                       inherits <- base::inherits
[13:20:03.689]                       invokeRestart <- base::invokeRestart
[13:20:03.689]                       is.null <- base::is.null
[13:20:03.689]                       muffled <- FALSE
[13:20:03.689]                       if (inherits(cond, "message")) {
[13:20:03.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.689]                         if (muffled) 
[13:20:03.689]                           invokeRestart("muffleMessage")
[13:20:03.689]                       }
[13:20:03.689]                       else if (inherits(cond, "warning")) {
[13:20:03.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.689]                         if (muffled) 
[13:20:03.689]                           invokeRestart("muffleWarning")
[13:20:03.689]                       }
[13:20:03.689]                       else if (inherits(cond, "condition")) {
[13:20:03.689]                         if (!is.null(pattern)) {
[13:20:03.689]                           computeRestarts <- base::computeRestarts
[13:20:03.689]                           grepl <- base::grepl
[13:20:03.689]                           restarts <- computeRestarts(cond)
[13:20:03.689]                           for (restart in restarts) {
[13:20:03.689]                             name <- restart$name
[13:20:03.689]                             if (is.null(name)) 
[13:20:03.689]                               next
[13:20:03.689]                             if (!grepl(pattern, name)) 
[13:20:03.689]                               next
[13:20:03.689]                             invokeRestart(restart)
[13:20:03.689]                             muffled <- TRUE
[13:20:03.689]                             break
[13:20:03.689]                           }
[13:20:03.689]                         }
[13:20:03.689]                       }
[13:20:03.689]                       invisible(muffled)
[13:20:03.689]                     }
[13:20:03.689]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.689]                   }
[13:20:03.689]                 }
[13:20:03.689]             }
[13:20:03.689]         }))
[13:20:03.689]     }, error = function(ex) {
[13:20:03.689]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.689]                 ...future.rng), started = ...future.startTime, 
[13:20:03.689]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.689]             version = "1.8"), class = "FutureResult")
[13:20:03.689]     }, finally = {
[13:20:03.689]         if (!identical(...future.workdir, getwd())) 
[13:20:03.689]             setwd(...future.workdir)
[13:20:03.689]         {
[13:20:03.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.689]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.689]             }
[13:20:03.689]             base::options(...future.oldOptions)
[13:20:03.689]             if (.Platform$OS.type == "windows") {
[13:20:03.689]                 old_names <- names(...future.oldEnvVars)
[13:20:03.689]                 envs <- base::Sys.getenv()
[13:20:03.689]                 names <- names(envs)
[13:20:03.689]                 common <- intersect(names, old_names)
[13:20:03.689]                 added <- setdiff(names, old_names)
[13:20:03.689]                 removed <- setdiff(old_names, names)
[13:20:03.689]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.689]                   envs[common]]
[13:20:03.689]                 NAMES <- toupper(changed)
[13:20:03.689]                 args <- list()
[13:20:03.689]                 for (kk in seq_along(NAMES)) {
[13:20:03.689]                   name <- changed[[kk]]
[13:20:03.689]                   NAME <- NAMES[[kk]]
[13:20:03.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.689]                     next
[13:20:03.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.689]                 }
[13:20:03.689]                 NAMES <- toupper(added)
[13:20:03.689]                 for (kk in seq_along(NAMES)) {
[13:20:03.689]                   name <- added[[kk]]
[13:20:03.689]                   NAME <- NAMES[[kk]]
[13:20:03.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.689]                     next
[13:20:03.689]                   args[[name]] <- ""
[13:20:03.689]                 }
[13:20:03.689]                 NAMES <- toupper(removed)
[13:20:03.689]                 for (kk in seq_along(NAMES)) {
[13:20:03.689]                   name <- removed[[kk]]
[13:20:03.689]                   NAME <- NAMES[[kk]]
[13:20:03.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.689]                     next
[13:20:03.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.689]                 }
[13:20:03.689]                 if (length(args) > 0) 
[13:20:03.689]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.689]             }
[13:20:03.689]             else {
[13:20:03.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.689]             }
[13:20:03.689]             {
[13:20:03.689]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.689]                   0L) {
[13:20:03.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.689]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.689]                   base::options(opts)
[13:20:03.689]                 }
[13:20:03.689]                 {
[13:20:03.689]                   {
[13:20:03.689]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.689]                     NULL
[13:20:03.689]                   }
[13:20:03.689]                   options(future.plan = NULL)
[13:20:03.689]                   if (is.na(NA_character_)) 
[13:20:03.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.689]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.689]                     envir = parent.frame()) 
[13:20:03.689]                   {
[13:20:03.689]                     default_workers <- missing(workers)
[13:20:03.689]                     if (is.function(workers)) 
[13:20:03.689]                       workers <- workers()
[13:20:03.689]                     workers <- structure(as.integer(workers), 
[13:20:03.689]                       class = class(workers))
[13:20:03.689]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.689]                       1L)
[13:20:03.689]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.689]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.689]                       if (default_workers) 
[13:20:03.689]                         supportsMulticore(warn = TRUE)
[13:20:03.689]                       return(sequential(..., envir = envir))
[13:20:03.689]                     }
[13:20:03.689]                     oopts <- options(mc.cores = workers)
[13:20:03.689]                     on.exit(options(oopts))
[13:20:03.689]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.689]                       envir = envir)
[13:20:03.689]                     if (!future$lazy) 
[13:20:03.689]                       future <- run(future)
[13:20:03.689]                     invisible(future)
[13:20:03.689]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.689]                 }
[13:20:03.689]             }
[13:20:03.689]         }
[13:20:03.689]     })
[13:20:03.689]     if (TRUE) {
[13:20:03.689]         base::sink(type = "output", split = FALSE)
[13:20:03.689]         if (TRUE) {
[13:20:03.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.689]         }
[13:20:03.689]         else {
[13:20:03.689]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.689]         }
[13:20:03.689]         base::close(...future.stdout)
[13:20:03.689]         ...future.stdout <- NULL
[13:20:03.689]     }
[13:20:03.689]     ...future.result$conditions <- ...future.conditions
[13:20:03.689]     ...future.result$finished <- base::Sys.time()
[13:20:03.689]     ...future.result
[13:20:03.689] }
[13:20:03.692] assign_globals() ...
[13:20:03.692] List of 5
[13:20:03.692]  $ ...future.FUN            :function (object, ...)  
[13:20:03.692]  $ future.call.arguments    : list()
[13:20:03.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.692]  $ ...future.elements_ii    :List of 1
[13:20:03.692]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.692]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:20:03.692]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.692]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:03.692]  $ ...future.seeds_ii       : NULL
[13:20:03.692]  $ ...future.globals.maxSize: NULL
[13:20:03.692]  - attr(*, "where")=List of 5
[13:20:03.692]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.692]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.692]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.692]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.692]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.692]  - attr(*, "resolved")= logi FALSE
[13:20:03.692]  - attr(*, "total_size")= num 1240
[13:20:03.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.692]  - attr(*, "already-done")= logi TRUE
[13:20:03.700] - copied ‘...future.FUN’ to environment
[13:20:03.700] - copied ‘future.call.arguments’ to environment
[13:20:03.700] - copied ‘...future.elements_ii’ to environment
[13:20:03.700] - copied ‘...future.seeds_ii’ to environment
[13:20:03.700] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.701] assign_globals() ... done
[13:20:03.701] requestCore(): workers = 2
[13:20:03.703] MulticoreFuture started
[13:20:03.704] - Launch lazy future ... done
[13:20:03.704] run() for ‘MulticoreFuture’ ... done
[13:20:03.704] Created future:
[13:20:03.705] plan(): Setting new future strategy stack:
[13:20:03.705] List of future strategies:
[13:20:03.705] 1. sequential:
[13:20:03.705]    - args: function (..., envir = parent.frame())
[13:20:03.705]    - tweaked: FALSE
[13:20:03.705]    - call: NULL
[13:20:03.706] plan(): nbrOfWorkers() = 1
[13:20:03.709] plan(): Setting new future strategy stack:
[13:20:03.709] List of future strategies:
[13:20:03.709] 1. multicore:
[13:20:03.709]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.709]    - tweaked: FALSE
[13:20:03.709]    - call: plan(strategy)
[13:20:03.714] plan(): nbrOfWorkers() = 2
[13:20:03.704] MulticoreFuture:
[13:20:03.704] Label: ‘future_by-1’
[13:20:03.704] Expression:
[13:20:03.704] {
[13:20:03.704]     do.call(function(...) {
[13:20:03.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.704]             on.exit(options(oopts), add = TRUE)
[13:20:03.704]         }
[13:20:03.704]         {
[13:20:03.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.704]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.704]             })
[13:20:03.704]         }
[13:20:03.704]     }, args = future.call.arguments)
[13:20:03.704] }
[13:20:03.704] Lazy evaluation: FALSE
[13:20:03.704] Asynchronous evaluation: TRUE
[13:20:03.704] Local evaluation: TRUE
[13:20:03.704] Environment: 0x55acefef4888
[13:20:03.704] Capture standard output: TRUE
[13:20:03.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.704] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.704] Packages: <none>
[13:20:03.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.704] Resolved: TRUE
[13:20:03.704] Value: <not collected>
[13:20:03.704] Conditions captured: <none>
[13:20:03.704] Early signaling: FALSE
[13:20:03.704] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.704] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.716] Chunk #1 of 2 ... DONE
[13:20:03.716] Chunk #2 of 2 ...
[13:20:03.716]  - Finding globals in 'X' for chunk #2 ...
[13:20:03.716] getGlobalsAndPackages() ...
[13:20:03.716] Searching for globals...
[13:20:03.717] 
[13:20:03.717] Searching for globals ... DONE
[13:20:03.717] - globals: [0] <none>
[13:20:03.717] getGlobalsAndPackages() ... DONE
[13:20:03.718]    + additional globals found: [n=0] 
[13:20:03.718]    + additional namespaces needed: [n=0] 
[13:20:03.718]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:03.718]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:03.718]  - seeds: <none>
[13:20:03.718]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.718] getGlobalsAndPackages() ...
[13:20:03.718] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.719] Resolving globals: FALSE
[13:20:03.719] Tweak future expression to call with '...' arguments ...
[13:20:03.719] {
[13:20:03.719]     do.call(function(...) {
[13:20:03.719]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.719]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.719]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.719]             on.exit(options(oopts), add = TRUE)
[13:20:03.719]         }
[13:20:03.719]         {
[13:20:03.719]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.719]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.719]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.719]             })
[13:20:03.719]         }
[13:20:03.719]     }, args = future.call.arguments)
[13:20:03.719] }
[13:20:03.719] Tweak future expression to call with '...' arguments ... DONE
[13:20:03.720] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:03.720] 
[13:20:03.720] getGlobalsAndPackages() ... DONE
[13:20:03.721] run() for ‘Future’ ...
[13:20:03.721] - state: ‘created’
[13:20:03.721] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:03.725] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.731] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:03.731]   - Field: ‘label’
[13:20:03.731]   - Field: ‘local’
[13:20:03.732]   - Field: ‘owner’
[13:20:03.732]   - Field: ‘envir’
[13:20:03.732]   - Field: ‘workers’
[13:20:03.732]   - Field: ‘packages’
[13:20:03.732]   - Field: ‘gc’
[13:20:03.732]   - Field: ‘job’
[13:20:03.732]   - Field: ‘conditions’
[13:20:03.733]   - Field: ‘expr’
[13:20:03.733]   - Field: ‘uuid’
[13:20:03.733]   - Field: ‘seed’
[13:20:03.733]   - Field: ‘version’
[13:20:03.733]   - Field: ‘result’
[13:20:03.733]   - Field: ‘asynchronous’
[13:20:03.733]   - Field: ‘calls’
[13:20:03.733]   - Field: ‘globals’
[13:20:03.733]   - Field: ‘stdout’
[13:20:03.734]   - Field: ‘earlySignal’
[13:20:03.734]   - Field: ‘lazy’
[13:20:03.734]   - Field: ‘state’
[13:20:03.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:03.734] - Launch lazy future ...
[13:20:03.735] Packages needed by the future expression (n = 0): <none>
[13:20:03.735] Packages needed by future strategies (n = 0): <none>
[13:20:03.735] {
[13:20:03.735]     {
[13:20:03.735]         {
[13:20:03.735]             ...future.startTime <- base::Sys.time()
[13:20:03.735]             {
[13:20:03.735]                 {
[13:20:03.735]                   {
[13:20:03.735]                     {
[13:20:03.735]                       base::local({
[13:20:03.735]                         has_future <- base::requireNamespace("future", 
[13:20:03.735]                           quietly = TRUE)
[13:20:03.735]                         if (has_future) {
[13:20:03.735]                           ns <- base::getNamespace("future")
[13:20:03.735]                           version <- ns[[".package"]][["version"]]
[13:20:03.735]                           if (is.null(version)) 
[13:20:03.735]                             version <- utils::packageVersion("future")
[13:20:03.735]                         }
[13:20:03.735]                         else {
[13:20:03.735]                           version <- NULL
[13:20:03.735]                         }
[13:20:03.735]                         if (!has_future || version < "1.8.0") {
[13:20:03.735]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:03.735]                             "", base::R.version$version.string), 
[13:20:03.735]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:03.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:03.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:03.735]                               "release", "version")], collapse = " "), 
[13:20:03.735]                             hostname = base::Sys.info()[["nodename"]])
[13:20:03.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:03.735]                             info)
[13:20:03.735]                           info <- base::paste(info, collapse = "; ")
[13:20:03.735]                           if (!has_future) {
[13:20:03.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:03.735]                               info)
[13:20:03.735]                           }
[13:20:03.735]                           else {
[13:20:03.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:03.735]                               info, version)
[13:20:03.735]                           }
[13:20:03.735]                           base::stop(msg)
[13:20:03.735]                         }
[13:20:03.735]                       })
[13:20:03.735]                     }
[13:20:03.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:03.735]                     base::options(mc.cores = 1L)
[13:20:03.735]                   }
[13:20:03.735]                   options(future.plan = NULL)
[13:20:03.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:03.735]                 }
[13:20:03.735]                 ...future.workdir <- getwd()
[13:20:03.735]             }
[13:20:03.735]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:03.735]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:03.735]         }
[13:20:03.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:03.735]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:03.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:03.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:03.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:03.735]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:03.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:03.735]             base::names(...future.oldOptions))
[13:20:03.735]     }
[13:20:03.735]     if (FALSE) {
[13:20:03.735]     }
[13:20:03.735]     else {
[13:20:03.735]         if (TRUE) {
[13:20:03.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:03.735]                 open = "w")
[13:20:03.735]         }
[13:20:03.735]         else {
[13:20:03.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:03.735]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:03.735]         }
[13:20:03.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:03.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:03.735]             base::sink(type = "output", split = FALSE)
[13:20:03.735]             base::close(...future.stdout)
[13:20:03.735]         }, add = TRUE)
[13:20:03.735]     }
[13:20:03.735]     ...future.frame <- base::sys.nframe()
[13:20:03.735]     ...future.conditions <- base::list()
[13:20:03.735]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:03.735]     if (FALSE) {
[13:20:03.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:03.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:03.735]     }
[13:20:03.735]     ...future.result <- base::tryCatch({
[13:20:03.735]         base::withCallingHandlers({
[13:20:03.735]             ...future.value <- base::withVisible(base::local({
[13:20:03.735]                 withCallingHandlers({
[13:20:03.735]                   {
[13:20:03.735]                     do.call(function(...) {
[13:20:03.735]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.735]                       if (!identical(...future.globals.maxSize.org, 
[13:20:03.735]                         ...future.globals.maxSize)) {
[13:20:03.735]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.735]                         on.exit(options(oopts), add = TRUE)
[13:20:03.735]                       }
[13:20:03.735]                       {
[13:20:03.735]                         lapply(seq_along(...future.elements_ii), 
[13:20:03.735]                           FUN = function(jj) {
[13:20:03.735]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.735]                             ...future.FUN(...future.X_jj, ...)
[13:20:03.735]                           })
[13:20:03.735]                       }
[13:20:03.735]                     }, args = future.call.arguments)
[13:20:03.735]                   }
[13:20:03.735]                 }, immediateCondition = function(cond) {
[13:20:03.735]                   save_rds <- function (object, pathname, ...) 
[13:20:03.735]                   {
[13:20:03.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:03.735]                     if (file_test("-f", pathname_tmp)) {
[13:20:03.735]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:03.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.735]                         fi_tmp[["mtime"]])
[13:20:03.735]                     }
[13:20:03.735]                     tryCatch({
[13:20:03.735]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:03.735]                     }, error = function(ex) {
[13:20:03.735]                       msg <- conditionMessage(ex)
[13:20:03.735]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:03.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.735]                         fi_tmp[["mtime"]], msg)
[13:20:03.735]                       ex$message <- msg
[13:20:03.735]                       stop(ex)
[13:20:03.735]                     })
[13:20:03.735]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:03.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:03.735]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:03.735]                       fi_tmp <- file.info(pathname_tmp)
[13:20:03.735]                       fi <- file.info(pathname)
[13:20:03.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:03.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:03.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:03.735]                         fi[["size"]], fi[["mtime"]])
[13:20:03.735]                       stop(msg)
[13:20:03.735]                     }
[13:20:03.735]                     invisible(pathname)
[13:20:03.735]                   }
[13:20:03.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:03.735]                     rootPath = tempdir()) 
[13:20:03.735]                   {
[13:20:03.735]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:03.735]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:03.735]                       tmpdir = path, fileext = ".rds")
[13:20:03.735]                     save_rds(obj, file)
[13:20:03.735]                   }
[13:20:03.735]                   saveImmediateCondition(cond, path = "/tmp/RtmpL8mNih/.future/immediateConditions")
[13:20:03.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.735]                   {
[13:20:03.735]                     inherits <- base::inherits
[13:20:03.735]                     invokeRestart <- base::invokeRestart
[13:20:03.735]                     is.null <- base::is.null
[13:20:03.735]                     muffled <- FALSE
[13:20:03.735]                     if (inherits(cond, "message")) {
[13:20:03.735]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:03.735]                       if (muffled) 
[13:20:03.735]                         invokeRestart("muffleMessage")
[13:20:03.735]                     }
[13:20:03.735]                     else if (inherits(cond, "warning")) {
[13:20:03.735]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:03.735]                       if (muffled) 
[13:20:03.735]                         invokeRestart("muffleWarning")
[13:20:03.735]                     }
[13:20:03.735]                     else if (inherits(cond, "condition")) {
[13:20:03.735]                       if (!is.null(pattern)) {
[13:20:03.735]                         computeRestarts <- base::computeRestarts
[13:20:03.735]                         grepl <- base::grepl
[13:20:03.735]                         restarts <- computeRestarts(cond)
[13:20:03.735]                         for (restart in restarts) {
[13:20:03.735]                           name <- restart$name
[13:20:03.735]                           if (is.null(name)) 
[13:20:03.735]                             next
[13:20:03.735]                           if (!grepl(pattern, name)) 
[13:20:03.735]                             next
[13:20:03.735]                           invokeRestart(restart)
[13:20:03.735]                           muffled <- TRUE
[13:20:03.735]                           break
[13:20:03.735]                         }
[13:20:03.735]                       }
[13:20:03.735]                     }
[13:20:03.735]                     invisible(muffled)
[13:20:03.735]                   }
[13:20:03.735]                   muffleCondition(cond)
[13:20:03.735]                 })
[13:20:03.735]             }))
[13:20:03.735]             future::FutureResult(value = ...future.value$value, 
[13:20:03.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.735]                   ...future.rng), globalenv = if (FALSE) 
[13:20:03.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:03.735]                     ...future.globalenv.names))
[13:20:03.735]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:03.735]         }, condition = base::local({
[13:20:03.735]             c <- base::c
[13:20:03.735]             inherits <- base::inherits
[13:20:03.735]             invokeRestart <- base::invokeRestart
[13:20:03.735]             length <- base::length
[13:20:03.735]             list <- base::list
[13:20:03.735]             seq.int <- base::seq.int
[13:20:03.735]             signalCondition <- base::signalCondition
[13:20:03.735]             sys.calls <- base::sys.calls
[13:20:03.735]             `[[` <- base::`[[`
[13:20:03.735]             `+` <- base::`+`
[13:20:03.735]             `<<-` <- base::`<<-`
[13:20:03.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:03.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:03.735]                   3L)]
[13:20:03.735]             }
[13:20:03.735]             function(cond) {
[13:20:03.735]                 is_error <- inherits(cond, "error")
[13:20:03.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:03.735]                   NULL)
[13:20:03.735]                 if (is_error) {
[13:20:03.735]                   sessionInformation <- function() {
[13:20:03.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:03.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:03.735]                       search = base::search(), system = base::Sys.info())
[13:20:03.735]                   }
[13:20:03.735]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:03.735]                     cond$call), session = sessionInformation(), 
[13:20:03.735]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:03.735]                   signalCondition(cond)
[13:20:03.735]                 }
[13:20:03.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:03.735]                 "immediateCondition"))) {
[13:20:03.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:03.735]                   ...future.conditions[[length(...future.conditions) + 
[13:20:03.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:03.735]                   if (TRUE && !signal) {
[13:20:03.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.735]                     {
[13:20:03.735]                       inherits <- base::inherits
[13:20:03.735]                       invokeRestart <- base::invokeRestart
[13:20:03.735]                       is.null <- base::is.null
[13:20:03.735]                       muffled <- FALSE
[13:20:03.735]                       if (inherits(cond, "message")) {
[13:20:03.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.735]                         if (muffled) 
[13:20:03.735]                           invokeRestart("muffleMessage")
[13:20:03.735]                       }
[13:20:03.735]                       else if (inherits(cond, "warning")) {
[13:20:03.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.735]                         if (muffled) 
[13:20:03.735]                           invokeRestart("muffleWarning")
[13:20:03.735]                       }
[13:20:03.735]                       else if (inherits(cond, "condition")) {
[13:20:03.735]                         if (!is.null(pattern)) {
[13:20:03.735]                           computeRestarts <- base::computeRestarts
[13:20:03.735]                           grepl <- base::grepl
[13:20:03.735]                           restarts <- computeRestarts(cond)
[13:20:03.735]                           for (restart in restarts) {
[13:20:03.735]                             name <- restart$name
[13:20:03.735]                             if (is.null(name)) 
[13:20:03.735]                               next
[13:20:03.735]                             if (!grepl(pattern, name)) 
[13:20:03.735]                               next
[13:20:03.735]                             invokeRestart(restart)
[13:20:03.735]                             muffled <- TRUE
[13:20:03.735]                             break
[13:20:03.735]                           }
[13:20:03.735]                         }
[13:20:03.735]                       }
[13:20:03.735]                       invisible(muffled)
[13:20:03.735]                     }
[13:20:03.735]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.735]                   }
[13:20:03.735]                 }
[13:20:03.735]                 else {
[13:20:03.735]                   if (TRUE) {
[13:20:03.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:03.735]                     {
[13:20:03.735]                       inherits <- base::inherits
[13:20:03.735]                       invokeRestart <- base::invokeRestart
[13:20:03.735]                       is.null <- base::is.null
[13:20:03.735]                       muffled <- FALSE
[13:20:03.735]                       if (inherits(cond, "message")) {
[13:20:03.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:03.735]                         if (muffled) 
[13:20:03.735]                           invokeRestart("muffleMessage")
[13:20:03.735]                       }
[13:20:03.735]                       else if (inherits(cond, "warning")) {
[13:20:03.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:03.735]                         if (muffled) 
[13:20:03.735]                           invokeRestart("muffleWarning")
[13:20:03.735]                       }
[13:20:03.735]                       else if (inherits(cond, "condition")) {
[13:20:03.735]                         if (!is.null(pattern)) {
[13:20:03.735]                           computeRestarts <- base::computeRestarts
[13:20:03.735]                           grepl <- base::grepl
[13:20:03.735]                           restarts <- computeRestarts(cond)
[13:20:03.735]                           for (restart in restarts) {
[13:20:03.735]                             name <- restart$name
[13:20:03.735]                             if (is.null(name)) 
[13:20:03.735]                               next
[13:20:03.735]                             if (!grepl(pattern, name)) 
[13:20:03.735]                               next
[13:20:03.735]                             invokeRestart(restart)
[13:20:03.735]                             muffled <- TRUE
[13:20:03.735]                             break
[13:20:03.735]                           }
[13:20:03.735]                         }
[13:20:03.735]                       }
[13:20:03.735]                       invisible(muffled)
[13:20:03.735]                     }
[13:20:03.735]                     muffleCondition(cond, pattern = "^muffle")
[13:20:03.735]                   }
[13:20:03.735]                 }
[13:20:03.735]             }
[13:20:03.735]         }))
[13:20:03.735]     }, error = function(ex) {
[13:20:03.735]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:03.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:03.735]                 ...future.rng), started = ...future.startTime, 
[13:20:03.735]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:03.735]             version = "1.8"), class = "FutureResult")
[13:20:03.735]     }, finally = {
[13:20:03.735]         if (!identical(...future.workdir, getwd())) 
[13:20:03.735]             setwd(...future.workdir)
[13:20:03.735]         {
[13:20:03.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:03.735]                 ...future.oldOptions$nwarnings <- NULL
[13:20:03.735]             }
[13:20:03.735]             base::options(...future.oldOptions)
[13:20:03.735]             if (.Platform$OS.type == "windows") {
[13:20:03.735]                 old_names <- names(...future.oldEnvVars)
[13:20:03.735]                 envs <- base::Sys.getenv()
[13:20:03.735]                 names <- names(envs)
[13:20:03.735]                 common <- intersect(names, old_names)
[13:20:03.735]                 added <- setdiff(names, old_names)
[13:20:03.735]                 removed <- setdiff(old_names, names)
[13:20:03.735]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:03.735]                   envs[common]]
[13:20:03.735]                 NAMES <- toupper(changed)
[13:20:03.735]                 args <- list()
[13:20:03.735]                 for (kk in seq_along(NAMES)) {
[13:20:03.735]                   name <- changed[[kk]]
[13:20:03.735]                   NAME <- NAMES[[kk]]
[13:20:03.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.735]                     next
[13:20:03.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.735]                 }
[13:20:03.735]                 NAMES <- toupper(added)
[13:20:03.735]                 for (kk in seq_along(NAMES)) {
[13:20:03.735]                   name <- added[[kk]]
[13:20:03.735]                   NAME <- NAMES[[kk]]
[13:20:03.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.735]                     next
[13:20:03.735]                   args[[name]] <- ""
[13:20:03.735]                 }
[13:20:03.735]                 NAMES <- toupper(removed)
[13:20:03.735]                 for (kk in seq_along(NAMES)) {
[13:20:03.735]                   name <- removed[[kk]]
[13:20:03.735]                   NAME <- NAMES[[kk]]
[13:20:03.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:03.735]                     next
[13:20:03.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:03.735]                 }
[13:20:03.735]                 if (length(args) > 0) 
[13:20:03.735]                   base::do.call(base::Sys.setenv, args = args)
[13:20:03.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:03.735]             }
[13:20:03.735]             else {
[13:20:03.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:03.735]             }
[13:20:03.735]             {
[13:20:03.735]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:03.735]                   0L) {
[13:20:03.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:03.735]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:03.735]                   base::options(opts)
[13:20:03.735]                 }
[13:20:03.735]                 {
[13:20:03.735]                   {
[13:20:03.735]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:03.735]                     NULL
[13:20:03.735]                   }
[13:20:03.735]                   options(future.plan = NULL)
[13:20:03.735]                   if (is.na(NA_character_)) 
[13:20:03.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:03.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:03.735]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:03.735]                     envir = parent.frame()) 
[13:20:03.735]                   {
[13:20:03.735]                     default_workers <- missing(workers)
[13:20:03.735]                     if (is.function(workers)) 
[13:20:03.735]                       workers <- workers()
[13:20:03.735]                     workers <- structure(as.integer(workers), 
[13:20:03.735]                       class = class(workers))
[13:20:03.735]                     stop_if_not(is.finite(workers), workers >= 
[13:20:03.735]                       1L)
[13:20:03.735]                     if ((workers == 1L && !inherits(workers, 
[13:20:03.735]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:03.735]                       if (default_workers) 
[13:20:03.735]                         supportsMulticore(warn = TRUE)
[13:20:03.735]                       return(sequential(..., envir = envir))
[13:20:03.735]                     }
[13:20:03.735]                     oopts <- options(mc.cores = workers)
[13:20:03.735]                     on.exit(options(oopts))
[13:20:03.735]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:03.735]                       envir = envir)
[13:20:03.735]                     if (!future$lazy) 
[13:20:03.735]                       future <- run(future)
[13:20:03.735]                     invisible(future)
[13:20:03.735]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:03.735]                 }
[13:20:03.735]             }
[13:20:03.735]         }
[13:20:03.735]     })
[13:20:03.735]     if (TRUE) {
[13:20:03.735]         base::sink(type = "output", split = FALSE)
[13:20:03.735]         if (TRUE) {
[13:20:03.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:03.735]         }
[13:20:03.735]         else {
[13:20:03.735]             ...future.result["stdout"] <- base::list(NULL)
[13:20:03.735]         }
[13:20:03.735]         base::close(...future.stdout)
[13:20:03.735]         ...future.stdout <- NULL
[13:20:03.735]     }
[13:20:03.735]     ...future.result$conditions <- ...future.conditions
[13:20:03.735]     ...future.result$finished <- base::Sys.time()
[13:20:03.735]     ...future.result
[13:20:03.735] }
[13:20:03.738] assign_globals() ...
[13:20:03.738] List of 5
[13:20:03.738]  $ ...future.FUN            :function (object, ...)  
[13:20:03.738]  $ future.call.arguments    : list()
[13:20:03.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:03.738]  $ ...future.elements_ii    :List of 2
[13:20:03.738]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.738]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:20:03.738]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.738]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:20:03.738]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:20:03.738]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:20:03.738]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:20:03.738]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:20:03.738]  $ ...future.seeds_ii       : NULL
[13:20:03.738]  $ ...future.globals.maxSize: NULL
[13:20:03.738]  - attr(*, "where")=List of 5
[13:20:03.738]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:20:03.738]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:20:03.738]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:20:03.738]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:20:03.738]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:20:03.738]  - attr(*, "resolved")= logi FALSE
[13:20:03.738]  - attr(*, "total_size")= num 1240
[13:20:03.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:03.738]  - attr(*, "already-done")= logi TRUE
[13:20:03.749] - copied ‘...future.FUN’ to environment
[13:20:03.749] - copied ‘future.call.arguments’ to environment
[13:20:03.749] - copied ‘...future.elements_ii’ to environment
[13:20:03.749] - copied ‘...future.seeds_ii’ to environment
[13:20:03.749] - copied ‘...future.globals.maxSize’ to environment
[13:20:03.749] assign_globals() ... done
[13:20:03.749] requestCore(): workers = 2
[13:20:03.752] MulticoreFuture started
[13:20:03.752] - Launch lazy future ... done
[13:20:03.753] run() for ‘MulticoreFuture’ ... done
[13:20:03.753] Created future:
[13:20:03.753] plan(): Setting new future strategy stack:
[13:20:03.754] List of future strategies:
[13:20:03.754] 1. sequential:
[13:20:03.754]    - args: function (..., envir = parent.frame())
[13:20:03.754]    - tweaked: FALSE
[13:20:03.754]    - call: NULL
[13:20:03.754] plan(): nbrOfWorkers() = 1
[13:20:03.759] plan(): Setting new future strategy stack:
[13:20:03.759] List of future strategies:
[13:20:03.759] 1. multicore:
[13:20:03.759]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:03.759]    - tweaked: FALSE
[13:20:03.759]    - call: plan(strategy)
[13:20:03.764] plan(): nbrOfWorkers() = 2
[13:20:03.753] MulticoreFuture:
[13:20:03.753] Label: ‘future_by-2’
[13:20:03.753] Expression:
[13:20:03.753] {
[13:20:03.753]     do.call(function(...) {
[13:20:03.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:03.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:03.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:03.753]             on.exit(options(oopts), add = TRUE)
[13:20:03.753]         }
[13:20:03.753]         {
[13:20:03.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:03.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:03.753]                 ...future.FUN(...future.X_jj, ...)
[13:20:03.753]             })
[13:20:03.753]         }
[13:20:03.753]     }, args = future.call.arguments)
[13:20:03.753] }
[13:20:03.753] Lazy evaluation: FALSE
[13:20:03.753] Asynchronous evaluation: TRUE
[13:20:03.753] Local evaluation: TRUE
[13:20:03.753] Environment: 0x55acefef4888
[13:20:03.753] Capture standard output: TRUE
[13:20:03.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:03.753] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:03.753] Packages: <none>
[13:20:03.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:03.753] Resolved: TRUE
[13:20:03.753] Value: <not collected>
[13:20:03.753] Conditions captured: <none>
[13:20:03.753] Early signaling: FALSE
[13:20:03.753] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:03.753] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:03.765] Chunk #2 of 2 ... DONE
[13:20:03.765] Launching 2 futures (chunks) ... DONE
[13:20:03.765] Resolving 2 futures (chunks) ...
[13:20:03.765] resolve() on list ...
[13:20:03.766]  recursive: 0
[13:20:03.766]  length: 2
[13:20:03.766] 
[13:20:03.766] Future #1
[13:20:03.766] result() for MulticoreFuture ...
[13:20:03.767] result() for MulticoreFuture ...
[13:20:03.767] result() for MulticoreFuture ... done
[13:20:03.768] result() for MulticoreFuture ... done
[13:20:03.768] result() for MulticoreFuture ...
[13:20:03.768] result() for MulticoreFuture ... done
[13:20:03.768] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:20:03.768] - nx: 2
[13:20:03.768] - relay: TRUE
[13:20:03.768] - stdout: TRUE
[13:20:03.769] - signal: TRUE
[13:20:03.769] - resignal: FALSE
[13:20:03.769] - force: TRUE
[13:20:03.769] - relayed: [n=2] FALSE, FALSE
[13:20:03.769] - queued futures: [n=2] FALSE, FALSE
[13:20:03.769]  - until=1
[13:20:03.769]  - relaying element #1
[13:20:03.770] result() for MulticoreFuture ...
[13:20:03.770] result() for MulticoreFuture ... done
[13:20:03.770] result() for MulticoreFuture ...
[13:20:03.770] result() for MulticoreFuture ... done
[13:20:03.770] result() for MulticoreFuture ...
[13:20:03.771] result() for MulticoreFuture ... done
[13:20:03.771] result() for MulticoreFuture ...
[13:20:03.771] result() for MulticoreFuture ... done
[13:20:03.771] - relayed: [n=2] TRUE, FALSE
[13:20:03.771] - queued futures: [n=2] TRUE, FALSE
[13:20:03.771] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:20:03.772]  length: 1 (resolved future 1)
[13:20:03.772] Future #2
[13:20:03.772] result() for MulticoreFuture ...
[13:20:03.773] result() for MulticoreFuture ...
[13:20:03.773] result() for MulticoreFuture ... done
[13:20:03.773] result() for MulticoreFuture ... done
[13:20:03.774] result() for MulticoreFuture ...
[13:20:03.774] result() for MulticoreFuture ... done
[13:20:03.774] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:20:03.774] - nx: 2
[13:20:03.774] - relay: TRUE
[13:20:03.774] - stdout: TRUE
[13:20:03.774] - signal: TRUE
[13:20:03.774] - resignal: FALSE
[13:20:03.775] - force: TRUE
[13:20:03.775] - relayed: [n=2] TRUE, FALSE
[13:20:03.775] - queued futures: [n=2] TRUE, FALSE
[13:20:03.775]  - until=2
[13:20:03.775]  - relaying element #2
[13:20:03.775] result() for MulticoreFuture ...
[13:20:03.775] result() for MulticoreFuture ... done
[13:20:03.776] result() for MulticoreFuture ...
[13:20:03.776] result() for MulticoreFuture ... done
[13:20:03.776] result() for MulticoreFuture ...
[13:20:03.776] result() for MulticoreFuture ... done
[13:20:03.776] result() for MulticoreFuture ...
[13:20:03.776] result() for MulticoreFuture ... done
[13:20:03.777] - relayed: [n=2] TRUE, TRUE
[13:20:03.777] - queued futures: [n=2] TRUE, TRUE
[13:20:03.777] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:20:03.777]  length: 0 (resolved future 2)
[13:20:03.777] Relaying remaining futures
[13:20:03.777] signalConditionsASAP(NULL, pos=0) ...
[13:20:03.777] - nx: 2
[13:20:03.777] - relay: TRUE
[13:20:03.778] - stdout: TRUE
[13:20:03.778] - signal: TRUE
[13:20:03.778] - resignal: FALSE
[13:20:03.778] - force: TRUE
[13:20:03.778] - relayed: [n=2] TRUE, TRUE
[13:20:03.778] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:03.778] - relayed: [n=2] TRUE, TRUE
[13:20:03.778] - queued futures: [n=2] TRUE, TRUE
[13:20:03.779] signalConditionsASAP(NULL, pos=0) ... done
[13:20:03.779] resolve() on list ... DONE
[13:20:03.779] result() for MulticoreFuture ...
[13:20:03.779] result() for MulticoreFuture ... done
[13:20:03.779] result() for MulticoreFuture ...
[13:20:03.779] result() for MulticoreFuture ... done
[13:20:03.779] result() for MulticoreFuture ...
[13:20:03.779] result() for MulticoreFuture ... done
[13:20:03.780] result() for MulticoreFuture ...
[13:20:03.780] result() for MulticoreFuture ... done
[13:20:03.780]  - Number of value chunks collected: 2
[13:20:03.780] Resolving 2 futures (chunks) ... DONE
[13:20:03.780] Reducing values from 2 chunks ...
[13:20:03.780]  - Number of values collected after concatenation: 3
[13:20:03.780]  - Number of values expected: 3
[13:20:03.780] Reducing values from 2 chunks ... DONE
[13:20:03.781] future_lapply() ... DONE
[13:20:03.781] future_by_internal() ... DONE
[13:20:03.782] future_by_internal() ...
- plan('multisession') ...
[13:20:03.783] plan(): Setting new future strategy stack:
[13:20:03.783] List of future strategies:
[13:20:03.783] 1. multisession:
[13:20:03.783]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:03.783]    - tweaked: FALSE
[13:20:03.783]    - call: plan(strategy)
[13:20:03.783] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:03.783] multisession:
[13:20:03.783] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:03.783] - tweaked: FALSE
[13:20:03.783] - call: plan(strategy)
[13:20:03.790] getGlobalsAndPackages() ...
[13:20:03.790] Not searching for globals
[13:20:03.790] - globals: [0] <none>
[13:20:03.790] getGlobalsAndPackages() ... DONE
[13:20:03.791] [local output] makeClusterPSOCK() ...
[13:20:03.843] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:03.845] [local output] Base port: 11800
[13:20:03.845] [local output] Getting setup options for 2 cluster nodes ...
[13:20:03.845] [local output]  - Node 1 of 2 ...
[13:20:03.845] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:03.846] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpL8mNih/worker.rank=1.parallelly.parent=69708.1104c7cac920a.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpL8mNih/worker.rank=1.parallelly.parent=69708.1104c7cac920a.pid")'’
[13:20:04.037] - Possible to infer worker's PID: TRUE
[13:20:04.038] [local output] Rscript port: 11800

[13:20:04.038] [local output]  - Node 2 of 2 ...
[13:20:04.039] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:04.039] [local output] Rscript port: 11800

[13:20:04.039] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:04.040] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:04.040] [local output] Setting up PSOCK nodes in parallel
[13:20:04.040] List of 36
[13:20:04.040]  $ worker          : chr "localhost"
[13:20:04.040]   ..- attr(*, "localhost")= logi TRUE
[13:20:04.040]  $ master          : chr "localhost"
[13:20:04.040]  $ port            : int 11800
[13:20:04.040]  $ connectTimeout  : num 120
[13:20:04.040]  $ timeout         : num 2592000
[13:20:04.040]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:04.040]  $ homogeneous     : logi TRUE
[13:20:04.040]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:04.040]  $ rscript_envs    : NULL
[13:20:04.040]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:04.040]  $ rscript_startup : NULL
[13:20:04.040]  $ rscript_sh      : chr "sh"
[13:20:04.040]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:04.040]  $ methods         : logi TRUE
[13:20:04.040]  $ socketOptions   : chr "no-delay"
[13:20:04.040]  $ useXDR          : logi FALSE
[13:20:04.040]  $ outfile         : chr "/dev/null"
[13:20:04.040]  $ renice          : int NA
[13:20:04.040]  $ rshcmd          : NULL
[13:20:04.040]  $ user            : chr(0) 
[13:20:04.040]  $ revtunnel       : logi FALSE
[13:20:04.040]  $ rshlogfile      : NULL
[13:20:04.040]  $ rshopts         : chr(0) 
[13:20:04.040]  $ rank            : int 1
[13:20:04.040]  $ manual          : logi FALSE
[13:20:04.040]  $ dryrun          : logi FALSE
[13:20:04.040]  $ quiet           : logi FALSE
[13:20:04.040]  $ setup_strategy  : chr "parallel"
[13:20:04.040]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:04.040]  $ pidfile         : chr "/tmp/RtmpL8mNih/worker.rank=1.parallelly.parent=69708.1104c7cac920a.pid"
[13:20:04.040]  $ rshcmd_label    : NULL
[13:20:04.040]  $ rsh_call        : NULL
[13:20:04.040]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:04.040]  $ localMachine    : logi TRUE
[13:20:04.040]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:04.040]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:04.040]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:04.040]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:04.040]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:04.040]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:04.040]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:04.040]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:04.040]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:04.040]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:04.040]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:04.040]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:04.040]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:04.040]  $ arguments       :List of 28
[13:20:04.040]   ..$ worker          : chr "localhost"
[13:20:04.040]   ..$ master          : NULL
[13:20:04.040]   ..$ port            : int 11800
[13:20:04.040]   ..$ connectTimeout  : num 120
[13:20:04.040]   ..$ timeout         : num 2592000
[13:20:04.040]   ..$ rscript         : NULL
[13:20:04.040]   ..$ homogeneous     : NULL
[13:20:04.040]   ..$ rscript_args    : NULL
[13:20:04.040]   ..$ rscript_envs    : NULL
[13:20:04.040]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:04.040]   ..$ rscript_startup : NULL
[13:20:04.040]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:04.040]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:04.040]   ..$ methods         : logi TRUE
[13:20:04.040]   ..$ socketOptions   : chr "no-delay"
[13:20:04.040]   ..$ useXDR          : logi FALSE
[13:20:04.040]   ..$ outfile         : chr "/dev/null"
[13:20:04.040]   ..$ renice          : int NA
[13:20:04.040]   ..$ rshcmd          : NULL
[13:20:04.040]   ..$ user            : NULL
[13:20:04.040]   ..$ revtunnel       : logi NA
[13:20:04.040]   ..$ rshlogfile      : NULL
[13:20:04.040]   ..$ rshopts         : NULL
[13:20:04.040]   ..$ rank            : int 1
[13:20:04.040]   ..$ manual          : logi FALSE
[13:20:04.040]   ..$ dryrun          : logi FALSE
[13:20:04.040]   ..$ quiet           : logi FALSE
[13:20:04.040]   ..$ setup_strategy  : chr "parallel"
[13:20:04.040]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:04.057] [local output] System call to launch all workers:
[13:20:04.057] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpL8mNih/worker.rank=1.parallelly.parent=69708.1104c7cac920a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11800 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:04.057] [local output] Starting PSOCK main server
[13:20:04.063] [local output] Workers launched
[13:20:04.063] [local output] Waiting for workers to connect back
[13:20:04.063]  - [local output] 0 workers out of 2 ready
[13:20:04.316]  - [local output] 0 workers out of 2 ready
[13:20:04.317]  - [local output] 1 workers out of 2 ready
[13:20:04.322]  - [local output] 1 workers out of 2 ready
[13:20:04.323]  - [local output] 2 workers out of 2 ready
[13:20:04.323] [local output] Launching of workers completed
[13:20:04.323] [local output] Collecting session information from workers
[13:20:04.324] [local output]  - Worker #1 of 2
[13:20:04.325] [local output]  - Worker #2 of 2
[13:20:04.325] [local output] makeClusterPSOCK() ... done
[13:20:04.336] Packages needed by the future expression (n = 0): <none>
[13:20:04.336] Packages needed by future strategies (n = 0): <none>
[13:20:04.336] {
[13:20:04.336]     {
[13:20:04.336]         {
[13:20:04.336]             ...future.startTime <- base::Sys.time()
[13:20:04.336]             {
[13:20:04.336]                 {
[13:20:04.336]                   {
[13:20:04.336]                     {
[13:20:04.336]                       base::local({
[13:20:04.336]                         has_future <- base::requireNamespace("future", 
[13:20:04.336]                           quietly = TRUE)
[13:20:04.336]                         if (has_future) {
[13:20:04.336]                           ns <- base::getNamespace("future")
[13:20:04.336]                           version <- ns[[".package"]][["version"]]
[13:20:04.336]                           if (is.null(version)) 
[13:20:04.336]                             version <- utils::packageVersion("future")
[13:20:04.336]                         }
[13:20:04.336]                         else {
[13:20:04.336]                           version <- NULL
[13:20:04.336]                         }
[13:20:04.336]                         if (!has_future || version < "1.8.0") {
[13:20:04.336]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.336]                             "", base::R.version$version.string), 
[13:20:04.336]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:04.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:04.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.336]                               "release", "version")], collapse = " "), 
[13:20:04.336]                             hostname = base::Sys.info()[["nodename"]])
[13:20:04.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.336]                             info)
[13:20:04.336]                           info <- base::paste(info, collapse = "; ")
[13:20:04.336]                           if (!has_future) {
[13:20:04.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.336]                               info)
[13:20:04.336]                           }
[13:20:04.336]                           else {
[13:20:04.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.336]                               info, version)
[13:20:04.336]                           }
[13:20:04.336]                           base::stop(msg)
[13:20:04.336]                         }
[13:20:04.336]                       })
[13:20:04.336]                     }
[13:20:04.336]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.336]                     base::options(mc.cores = 1L)
[13:20:04.336]                   }
[13:20:04.336]                   options(future.plan = NULL)
[13:20:04.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.336]                 }
[13:20:04.336]                 ...future.workdir <- getwd()
[13:20:04.336]             }
[13:20:04.336]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.336]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.336]         }
[13:20:04.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:20:04.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.336]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.336]             base::names(...future.oldOptions))
[13:20:04.336]     }
[13:20:04.336]     if (FALSE) {
[13:20:04.336]     }
[13:20:04.336]     else {
[13:20:04.336]         if (TRUE) {
[13:20:04.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.336]                 open = "w")
[13:20:04.336]         }
[13:20:04.336]         else {
[13:20:04.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.336]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.336]         }
[13:20:04.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.336]             base::sink(type = "output", split = FALSE)
[13:20:04.336]             base::close(...future.stdout)
[13:20:04.336]         }, add = TRUE)
[13:20:04.336]     }
[13:20:04.336]     ...future.frame <- base::sys.nframe()
[13:20:04.336]     ...future.conditions <- base::list()
[13:20:04.336]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.336]     if (FALSE) {
[13:20:04.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.336]     }
[13:20:04.336]     ...future.result <- base::tryCatch({
[13:20:04.336]         base::withCallingHandlers({
[13:20:04.336]             ...future.value <- base::withVisible(base::local({
[13:20:04.336]                 ...future.makeSendCondition <- base::local({
[13:20:04.336]                   sendCondition <- NULL
[13:20:04.336]                   function(frame = 1L) {
[13:20:04.336]                     if (is.function(sendCondition)) 
[13:20:04.336]                       return(sendCondition)
[13:20:04.336]                     ns <- getNamespace("parallel")
[13:20:04.336]                     if (exists("sendData", mode = "function", 
[13:20:04.336]                       envir = ns)) {
[13:20:04.336]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.336]                         envir = ns)
[13:20:04.336]                       envir <- sys.frame(frame)
[13:20:04.336]                       master <- NULL
[13:20:04.336]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.336]                         !identical(envir, emptyenv())) {
[13:20:04.336]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.336]                           inherits = FALSE)) {
[13:20:04.336]                           master <- get("master", mode = "list", 
[13:20:04.336]                             envir = envir, inherits = FALSE)
[13:20:04.336]                           if (inherits(master, c("SOCKnode", 
[13:20:04.336]                             "SOCK0node"))) {
[13:20:04.336]                             sendCondition <<- function(cond) {
[13:20:04.336]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.336]                                 success = TRUE)
[13:20:04.336]                               parallel_sendData(master, data)
[13:20:04.336]                             }
[13:20:04.336]                             return(sendCondition)
[13:20:04.336]                           }
[13:20:04.336]                         }
[13:20:04.336]                         frame <- frame + 1L
[13:20:04.336]                         envir <- sys.frame(frame)
[13:20:04.336]                       }
[13:20:04.336]                     }
[13:20:04.336]                     sendCondition <<- function(cond) NULL
[13:20:04.336]                   }
[13:20:04.336]                 })
[13:20:04.336]                 withCallingHandlers({
[13:20:04.336]                   NA
[13:20:04.336]                 }, immediateCondition = function(cond) {
[13:20:04.336]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.336]                   sendCondition(cond)
[13:20:04.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.336]                   {
[13:20:04.336]                     inherits <- base::inherits
[13:20:04.336]                     invokeRestart <- base::invokeRestart
[13:20:04.336]                     is.null <- base::is.null
[13:20:04.336]                     muffled <- FALSE
[13:20:04.336]                     if (inherits(cond, "message")) {
[13:20:04.336]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.336]                       if (muffled) 
[13:20:04.336]                         invokeRestart("muffleMessage")
[13:20:04.336]                     }
[13:20:04.336]                     else if (inherits(cond, "warning")) {
[13:20:04.336]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.336]                       if (muffled) 
[13:20:04.336]                         invokeRestart("muffleWarning")
[13:20:04.336]                     }
[13:20:04.336]                     else if (inherits(cond, "condition")) {
[13:20:04.336]                       if (!is.null(pattern)) {
[13:20:04.336]                         computeRestarts <- base::computeRestarts
[13:20:04.336]                         grepl <- base::grepl
[13:20:04.336]                         restarts <- computeRestarts(cond)
[13:20:04.336]                         for (restart in restarts) {
[13:20:04.336]                           name <- restart$name
[13:20:04.336]                           if (is.null(name)) 
[13:20:04.336]                             next
[13:20:04.336]                           if (!grepl(pattern, name)) 
[13:20:04.336]                             next
[13:20:04.336]                           invokeRestart(restart)
[13:20:04.336]                           muffled <- TRUE
[13:20:04.336]                           break
[13:20:04.336]                         }
[13:20:04.336]                       }
[13:20:04.336]                     }
[13:20:04.336]                     invisible(muffled)
[13:20:04.336]                   }
[13:20:04.336]                   muffleCondition(cond)
[13:20:04.336]                 })
[13:20:04.336]             }))
[13:20:04.336]             future::FutureResult(value = ...future.value$value, 
[13:20:04.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.336]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.336]                     ...future.globalenv.names))
[13:20:04.336]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.336]         }, condition = base::local({
[13:20:04.336]             c <- base::c
[13:20:04.336]             inherits <- base::inherits
[13:20:04.336]             invokeRestart <- base::invokeRestart
[13:20:04.336]             length <- base::length
[13:20:04.336]             list <- base::list
[13:20:04.336]             seq.int <- base::seq.int
[13:20:04.336]             signalCondition <- base::signalCondition
[13:20:04.336]             sys.calls <- base::sys.calls
[13:20:04.336]             `[[` <- base::`[[`
[13:20:04.336]             `+` <- base::`+`
[13:20:04.336]             `<<-` <- base::`<<-`
[13:20:04.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.336]                   3L)]
[13:20:04.336]             }
[13:20:04.336]             function(cond) {
[13:20:04.336]                 is_error <- inherits(cond, "error")
[13:20:04.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.336]                   NULL)
[13:20:04.336]                 if (is_error) {
[13:20:04.336]                   sessionInformation <- function() {
[13:20:04.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.336]                       search = base::search(), system = base::Sys.info())
[13:20:04.336]                   }
[13:20:04.336]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.336]                     cond$call), session = sessionInformation(), 
[13:20:04.336]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.336]                   signalCondition(cond)
[13:20:04.336]                 }
[13:20:04.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.336]                 "immediateCondition"))) {
[13:20:04.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.336]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.336]                   if (TRUE && !signal) {
[13:20:04.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.336]                     {
[13:20:04.336]                       inherits <- base::inherits
[13:20:04.336]                       invokeRestart <- base::invokeRestart
[13:20:04.336]                       is.null <- base::is.null
[13:20:04.336]                       muffled <- FALSE
[13:20:04.336]                       if (inherits(cond, "message")) {
[13:20:04.336]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.336]                         if (muffled) 
[13:20:04.336]                           invokeRestart("muffleMessage")
[13:20:04.336]                       }
[13:20:04.336]                       else if (inherits(cond, "warning")) {
[13:20:04.336]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.336]                         if (muffled) 
[13:20:04.336]                           invokeRestart("muffleWarning")
[13:20:04.336]                       }
[13:20:04.336]                       else if (inherits(cond, "condition")) {
[13:20:04.336]                         if (!is.null(pattern)) {
[13:20:04.336]                           computeRestarts <- base::computeRestarts
[13:20:04.336]                           grepl <- base::grepl
[13:20:04.336]                           restarts <- computeRestarts(cond)
[13:20:04.336]                           for (restart in restarts) {
[13:20:04.336]                             name <- restart$name
[13:20:04.336]                             if (is.null(name)) 
[13:20:04.336]                               next
[13:20:04.336]                             if (!grepl(pattern, name)) 
[13:20:04.336]                               next
[13:20:04.336]                             invokeRestart(restart)
[13:20:04.336]                             muffled <- TRUE
[13:20:04.336]                             break
[13:20:04.336]                           }
[13:20:04.336]                         }
[13:20:04.336]                       }
[13:20:04.336]                       invisible(muffled)
[13:20:04.336]                     }
[13:20:04.336]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.336]                   }
[13:20:04.336]                 }
[13:20:04.336]                 else {
[13:20:04.336]                   if (TRUE) {
[13:20:04.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.336]                     {
[13:20:04.336]                       inherits <- base::inherits
[13:20:04.336]                       invokeRestart <- base::invokeRestart
[13:20:04.336]                       is.null <- base::is.null
[13:20:04.336]                       muffled <- FALSE
[13:20:04.336]                       if (inherits(cond, "message")) {
[13:20:04.336]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.336]                         if (muffled) 
[13:20:04.336]                           invokeRestart("muffleMessage")
[13:20:04.336]                       }
[13:20:04.336]                       else if (inherits(cond, "warning")) {
[13:20:04.336]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.336]                         if (muffled) 
[13:20:04.336]                           invokeRestart("muffleWarning")
[13:20:04.336]                       }
[13:20:04.336]                       else if (inherits(cond, "condition")) {
[13:20:04.336]                         if (!is.null(pattern)) {
[13:20:04.336]                           computeRestarts <- base::computeRestarts
[13:20:04.336]                           grepl <- base::grepl
[13:20:04.336]                           restarts <- computeRestarts(cond)
[13:20:04.336]                           for (restart in restarts) {
[13:20:04.336]                             name <- restart$name
[13:20:04.336]                             if (is.null(name)) 
[13:20:04.336]                               next
[13:20:04.336]                             if (!grepl(pattern, name)) 
[13:20:04.336]                               next
[13:20:04.336]                             invokeRestart(restart)
[13:20:04.336]                             muffled <- TRUE
[13:20:04.336]                             break
[13:20:04.336]                           }
[13:20:04.336]                         }
[13:20:04.336]                       }
[13:20:04.336]                       invisible(muffled)
[13:20:04.336]                     }
[13:20:04.336]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.336]                   }
[13:20:04.336]                 }
[13:20:04.336]             }
[13:20:04.336]         }))
[13:20:04.336]     }, error = function(ex) {
[13:20:04.336]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.336]                 ...future.rng), started = ...future.startTime, 
[13:20:04.336]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.336]             version = "1.8"), class = "FutureResult")
[13:20:04.336]     }, finally = {
[13:20:04.336]         if (!identical(...future.workdir, getwd())) 
[13:20:04.336]             setwd(...future.workdir)
[13:20:04.336]         {
[13:20:04.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.336]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.336]             }
[13:20:04.336]             base::options(...future.oldOptions)
[13:20:04.336]             if (.Platform$OS.type == "windows") {
[13:20:04.336]                 old_names <- names(...future.oldEnvVars)
[13:20:04.336]                 envs <- base::Sys.getenv()
[13:20:04.336]                 names <- names(envs)
[13:20:04.336]                 common <- intersect(names, old_names)
[13:20:04.336]                 added <- setdiff(names, old_names)
[13:20:04.336]                 removed <- setdiff(old_names, names)
[13:20:04.336]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.336]                   envs[common]]
[13:20:04.336]                 NAMES <- toupper(changed)
[13:20:04.336]                 args <- list()
[13:20:04.336]                 for (kk in seq_along(NAMES)) {
[13:20:04.336]                   name <- changed[[kk]]
[13:20:04.336]                   NAME <- NAMES[[kk]]
[13:20:04.336]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.336]                     next
[13:20:04.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.336]                 }
[13:20:04.336]                 NAMES <- toupper(added)
[13:20:04.336]                 for (kk in seq_along(NAMES)) {
[13:20:04.336]                   name <- added[[kk]]
[13:20:04.336]                   NAME <- NAMES[[kk]]
[13:20:04.336]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.336]                     next
[13:20:04.336]                   args[[name]] <- ""
[13:20:04.336]                 }
[13:20:04.336]                 NAMES <- toupper(removed)
[13:20:04.336]                 for (kk in seq_along(NAMES)) {
[13:20:04.336]                   name <- removed[[kk]]
[13:20:04.336]                   NAME <- NAMES[[kk]]
[13:20:04.336]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.336]                     next
[13:20:04.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.336]                 }
[13:20:04.336]                 if (length(args) > 0) 
[13:20:04.336]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.336]             }
[13:20:04.336]             else {
[13:20:04.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.336]             }
[13:20:04.336]             {
[13:20:04.336]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.336]                   0L) {
[13:20:04.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.336]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.336]                   base::options(opts)
[13:20:04.336]                 }
[13:20:04.336]                 {
[13:20:04.336]                   {
[13:20:04.336]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.336]                     NULL
[13:20:04.336]                   }
[13:20:04.336]                   options(future.plan = NULL)
[13:20:04.336]                   if (is.na(NA_character_)) 
[13:20:04.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.336]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.336]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.336]                     envir = parent.frame()) 
[13:20:04.336]                   {
[13:20:04.336]                     if (is.function(workers)) 
[13:20:04.336]                       workers <- workers()
[13:20:04.336]                     workers <- structure(as.integer(workers), 
[13:20:04.336]                       class = class(workers))
[13:20:04.336]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.336]                       workers >= 1)
[13:20:04.336]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.336]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.336]                     }
[13:20:04.336]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.336]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.336]                       envir = envir)
[13:20:04.336]                     if (!future$lazy) 
[13:20:04.336]                       future <- run(future)
[13:20:04.336]                     invisible(future)
[13:20:04.336]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.336]                 }
[13:20:04.336]             }
[13:20:04.336]         }
[13:20:04.336]     })
[13:20:04.336]     if (TRUE) {
[13:20:04.336]         base::sink(type = "output", split = FALSE)
[13:20:04.336]         if (TRUE) {
[13:20:04.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.336]         }
[13:20:04.336]         else {
[13:20:04.336]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.336]         }
[13:20:04.336]         base::close(...future.stdout)
[13:20:04.336]         ...future.stdout <- NULL
[13:20:04.336]     }
[13:20:04.336]     ...future.result$conditions <- ...future.conditions
[13:20:04.336]     ...future.result$finished <- base::Sys.time()
[13:20:04.336]     ...future.result
[13:20:04.336] }
[13:20:04.395] MultisessionFuture started
[13:20:04.395] result() for ClusterFuture ...
[13:20:04.396] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.396] - Validating connection of MultisessionFuture
[13:20:04.443] - received message: FutureResult
[13:20:04.443] - Received FutureResult
[13:20:04.443] - Erased future from FutureRegistry
[13:20:04.444] result() for ClusterFuture ...
[13:20:04.444] - result already collected: FutureResult
[13:20:04.444] result() for ClusterFuture ... done
[13:20:04.444] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.444] result() for ClusterFuture ... done
[13:20:04.444] result() for ClusterFuture ...
[13:20:04.444] - result already collected: FutureResult
[13:20:04.444] result() for ClusterFuture ... done
[13:20:04.444] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:04.448] plan(): nbrOfWorkers() = 2
[13:20:04.448] future_by_internal() ...
[13:20:04.448] future_lapply() ...
[13:20:04.452] Number of chunks: 2
[13:20:04.452] getGlobalsAndPackagesXApply() ...
[13:20:04.452]  - future.globals: TRUE
[13:20:04.452] getGlobalsAndPackages() ...
[13:20:04.452] Searching for globals...
[13:20:04.453] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:04.454] Searching for globals ... DONE
[13:20:04.454] Resolving globals: FALSE
[13:20:04.454] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:04.454] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:04.455] - globals: [1] ‘FUN’
[13:20:04.455] 
[13:20:04.455] getGlobalsAndPackages() ... DONE
[13:20:04.455]  - globals found/used: [n=1] ‘FUN’
[13:20:04.455]  - needed namespaces: [n=0] 
[13:20:04.455] Finding globals ... DONE
[13:20:04.455]  - use_args: TRUE
[13:20:04.455]  - Getting '...' globals ...
[13:20:04.455] resolve() on list ...
[13:20:04.456]  recursive: 0
[13:20:04.456]  length: 1
[13:20:04.456]  elements: ‘...’
[13:20:04.456]  length: 0 (resolved future 1)
[13:20:04.456] resolve() on list ... DONE
[13:20:04.456]    - '...' content: [n=0] 
[13:20:04.456] List of 1
[13:20:04.456]  $ ...: list()
[13:20:04.456]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.456]  - attr(*, "where")=List of 1
[13:20:04.456]   ..$ ...:<environment: 0x55acefeaa4b0> 
[13:20:04.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.456]  - attr(*, "resolved")= logi TRUE
[13:20:04.456]  - attr(*, "total_size")= num NA
[13:20:04.459]  - Getting '...' globals ... DONE
[13:20:04.459] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:04.459] List of 2
[13:20:04.459]  $ ...future.FUN:function (object, ...)  
[13:20:04.459]  $ ...          : list()
[13:20:04.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.459]  - attr(*, "where")=List of 2
[13:20:04.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:04.459]   ..$ ...          :<environment: 0x55acefeaa4b0> 
[13:20:04.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.459]  - attr(*, "resolved")= logi FALSE
[13:20:04.459]  - attr(*, "total_size")= num 1240
[13:20:04.462] Packages to be attached in all futures: [n=0] 
[13:20:04.462] getGlobalsAndPackagesXApply() ... DONE
[13:20:04.462] Number of futures (= number of chunks): 2
[13:20:04.462] Launching 2 futures (chunks) ...
[13:20:04.462] Chunk #1 of 2 ...
[13:20:04.462]  - Finding globals in 'X' for chunk #1 ...
[13:20:04.462] getGlobalsAndPackages() ...
[13:20:04.462] Searching for globals...
[13:20:04.463] 
[13:20:04.463] Searching for globals ... DONE
[13:20:04.463] - globals: [0] <none>
[13:20:04.463] getGlobalsAndPackages() ... DONE
[13:20:04.463]    + additional globals found: [n=0] 
[13:20:04.463]    + additional namespaces needed: [n=0] 
[13:20:04.463]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:04.463]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:04.463]  - seeds: <none>
[13:20:04.463]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.464] getGlobalsAndPackages() ...
[13:20:04.464] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.464] Resolving globals: FALSE
[13:20:04.464] Tweak future expression to call with '...' arguments ...
[13:20:04.464] {
[13:20:04.464]     do.call(function(...) {
[13:20:04.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.464]             on.exit(options(oopts), add = TRUE)
[13:20:04.464]         }
[13:20:04.464]         {
[13:20:04.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.464]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.464]             })
[13:20:04.464]         }
[13:20:04.464]     }, args = future.call.arguments)
[13:20:04.464] }
[13:20:04.464] Tweak future expression to call with '...' arguments ... DONE
[13:20:04.465] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.465] 
[13:20:04.465] getGlobalsAndPackages() ... DONE
[13:20:04.465] run() for ‘Future’ ...
[13:20:04.465] - state: ‘created’
[13:20:04.465] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:04.479] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:04.480]   - Field: ‘node’
[13:20:04.480]   - Field: ‘label’
[13:20:04.480]   - Field: ‘local’
[13:20:04.480]   - Field: ‘owner’
[13:20:04.480]   - Field: ‘envir’
[13:20:04.480]   - Field: ‘workers’
[13:20:04.480]   - Field: ‘packages’
[13:20:04.480]   - Field: ‘gc’
[13:20:04.480]   - Field: ‘conditions’
[13:20:04.481]   - Field: ‘persistent’
[13:20:04.481]   - Field: ‘expr’
[13:20:04.481]   - Field: ‘uuid’
[13:20:04.481]   - Field: ‘seed’
[13:20:04.481]   - Field: ‘version’
[13:20:04.481]   - Field: ‘result’
[13:20:04.481]   - Field: ‘asynchronous’
[13:20:04.481]   - Field: ‘calls’
[13:20:04.481]   - Field: ‘globals’
[13:20:04.481]   - Field: ‘stdout’
[13:20:04.481]   - Field: ‘earlySignal’
[13:20:04.481]   - Field: ‘lazy’
[13:20:04.482]   - Field: ‘state’
[13:20:04.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:04.482] - Launch lazy future ...
[13:20:04.482] Packages needed by the future expression (n = 0): <none>
[13:20:04.482] Packages needed by future strategies (n = 0): <none>
[13:20:04.483] {
[13:20:04.483]     {
[13:20:04.483]         {
[13:20:04.483]             ...future.startTime <- base::Sys.time()
[13:20:04.483]             {
[13:20:04.483]                 {
[13:20:04.483]                   {
[13:20:04.483]                     {
[13:20:04.483]                       base::local({
[13:20:04.483]                         has_future <- base::requireNamespace("future", 
[13:20:04.483]                           quietly = TRUE)
[13:20:04.483]                         if (has_future) {
[13:20:04.483]                           ns <- base::getNamespace("future")
[13:20:04.483]                           version <- ns[[".package"]][["version"]]
[13:20:04.483]                           if (is.null(version)) 
[13:20:04.483]                             version <- utils::packageVersion("future")
[13:20:04.483]                         }
[13:20:04.483]                         else {
[13:20:04.483]                           version <- NULL
[13:20:04.483]                         }
[13:20:04.483]                         if (!has_future || version < "1.8.0") {
[13:20:04.483]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.483]                             "", base::R.version$version.string), 
[13:20:04.483]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:04.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:04.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.483]                               "release", "version")], collapse = " "), 
[13:20:04.483]                             hostname = base::Sys.info()[["nodename"]])
[13:20:04.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.483]                             info)
[13:20:04.483]                           info <- base::paste(info, collapse = "; ")
[13:20:04.483]                           if (!has_future) {
[13:20:04.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.483]                               info)
[13:20:04.483]                           }
[13:20:04.483]                           else {
[13:20:04.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.483]                               info, version)
[13:20:04.483]                           }
[13:20:04.483]                           base::stop(msg)
[13:20:04.483]                         }
[13:20:04.483]                       })
[13:20:04.483]                     }
[13:20:04.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.483]                     base::options(mc.cores = 1L)
[13:20:04.483]                   }
[13:20:04.483]                   options(future.plan = NULL)
[13:20:04.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.483]                 }
[13:20:04.483]                 ...future.workdir <- getwd()
[13:20:04.483]             }
[13:20:04.483]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.483]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.483]         }
[13:20:04.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.483]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:04.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.483]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.483]             base::names(...future.oldOptions))
[13:20:04.483]     }
[13:20:04.483]     if (FALSE) {
[13:20:04.483]     }
[13:20:04.483]     else {
[13:20:04.483]         if (TRUE) {
[13:20:04.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.483]                 open = "w")
[13:20:04.483]         }
[13:20:04.483]         else {
[13:20:04.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.483]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.483]         }
[13:20:04.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.483]             base::sink(type = "output", split = FALSE)
[13:20:04.483]             base::close(...future.stdout)
[13:20:04.483]         }, add = TRUE)
[13:20:04.483]     }
[13:20:04.483]     ...future.frame <- base::sys.nframe()
[13:20:04.483]     ...future.conditions <- base::list()
[13:20:04.483]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.483]     if (FALSE) {
[13:20:04.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.483]     }
[13:20:04.483]     ...future.result <- base::tryCatch({
[13:20:04.483]         base::withCallingHandlers({
[13:20:04.483]             ...future.value <- base::withVisible(base::local({
[13:20:04.483]                 ...future.makeSendCondition <- base::local({
[13:20:04.483]                   sendCondition <- NULL
[13:20:04.483]                   function(frame = 1L) {
[13:20:04.483]                     if (is.function(sendCondition)) 
[13:20:04.483]                       return(sendCondition)
[13:20:04.483]                     ns <- getNamespace("parallel")
[13:20:04.483]                     if (exists("sendData", mode = "function", 
[13:20:04.483]                       envir = ns)) {
[13:20:04.483]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.483]                         envir = ns)
[13:20:04.483]                       envir <- sys.frame(frame)
[13:20:04.483]                       master <- NULL
[13:20:04.483]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.483]                         !identical(envir, emptyenv())) {
[13:20:04.483]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.483]                           inherits = FALSE)) {
[13:20:04.483]                           master <- get("master", mode = "list", 
[13:20:04.483]                             envir = envir, inherits = FALSE)
[13:20:04.483]                           if (inherits(master, c("SOCKnode", 
[13:20:04.483]                             "SOCK0node"))) {
[13:20:04.483]                             sendCondition <<- function(cond) {
[13:20:04.483]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.483]                                 success = TRUE)
[13:20:04.483]                               parallel_sendData(master, data)
[13:20:04.483]                             }
[13:20:04.483]                             return(sendCondition)
[13:20:04.483]                           }
[13:20:04.483]                         }
[13:20:04.483]                         frame <- frame + 1L
[13:20:04.483]                         envir <- sys.frame(frame)
[13:20:04.483]                       }
[13:20:04.483]                     }
[13:20:04.483]                     sendCondition <<- function(cond) NULL
[13:20:04.483]                   }
[13:20:04.483]                 })
[13:20:04.483]                 withCallingHandlers({
[13:20:04.483]                   {
[13:20:04.483]                     do.call(function(...) {
[13:20:04.483]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.483]                       if (!identical(...future.globals.maxSize.org, 
[13:20:04.483]                         ...future.globals.maxSize)) {
[13:20:04.483]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.483]                         on.exit(options(oopts), add = TRUE)
[13:20:04.483]                       }
[13:20:04.483]                       {
[13:20:04.483]                         lapply(seq_along(...future.elements_ii), 
[13:20:04.483]                           FUN = function(jj) {
[13:20:04.483]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.483]                             ...future.FUN(...future.X_jj, ...)
[13:20:04.483]                           })
[13:20:04.483]                       }
[13:20:04.483]                     }, args = future.call.arguments)
[13:20:04.483]                   }
[13:20:04.483]                 }, immediateCondition = function(cond) {
[13:20:04.483]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.483]                   sendCondition(cond)
[13:20:04.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.483]                   {
[13:20:04.483]                     inherits <- base::inherits
[13:20:04.483]                     invokeRestart <- base::invokeRestart
[13:20:04.483]                     is.null <- base::is.null
[13:20:04.483]                     muffled <- FALSE
[13:20:04.483]                     if (inherits(cond, "message")) {
[13:20:04.483]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.483]                       if (muffled) 
[13:20:04.483]                         invokeRestart("muffleMessage")
[13:20:04.483]                     }
[13:20:04.483]                     else if (inherits(cond, "warning")) {
[13:20:04.483]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.483]                       if (muffled) 
[13:20:04.483]                         invokeRestart("muffleWarning")
[13:20:04.483]                     }
[13:20:04.483]                     else if (inherits(cond, "condition")) {
[13:20:04.483]                       if (!is.null(pattern)) {
[13:20:04.483]                         computeRestarts <- base::computeRestarts
[13:20:04.483]                         grepl <- base::grepl
[13:20:04.483]                         restarts <- computeRestarts(cond)
[13:20:04.483]                         for (restart in restarts) {
[13:20:04.483]                           name <- restart$name
[13:20:04.483]                           if (is.null(name)) 
[13:20:04.483]                             next
[13:20:04.483]                           if (!grepl(pattern, name)) 
[13:20:04.483]                             next
[13:20:04.483]                           invokeRestart(restart)
[13:20:04.483]                           muffled <- TRUE
[13:20:04.483]                           break
[13:20:04.483]                         }
[13:20:04.483]                       }
[13:20:04.483]                     }
[13:20:04.483]                     invisible(muffled)
[13:20:04.483]                   }
[13:20:04.483]                   muffleCondition(cond)
[13:20:04.483]                 })
[13:20:04.483]             }))
[13:20:04.483]             future::FutureResult(value = ...future.value$value, 
[13:20:04.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.483]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.483]                     ...future.globalenv.names))
[13:20:04.483]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.483]         }, condition = base::local({
[13:20:04.483]             c <- base::c
[13:20:04.483]             inherits <- base::inherits
[13:20:04.483]             invokeRestart <- base::invokeRestart
[13:20:04.483]             length <- base::length
[13:20:04.483]             list <- base::list
[13:20:04.483]             seq.int <- base::seq.int
[13:20:04.483]             signalCondition <- base::signalCondition
[13:20:04.483]             sys.calls <- base::sys.calls
[13:20:04.483]             `[[` <- base::`[[`
[13:20:04.483]             `+` <- base::`+`
[13:20:04.483]             `<<-` <- base::`<<-`
[13:20:04.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.483]                   3L)]
[13:20:04.483]             }
[13:20:04.483]             function(cond) {
[13:20:04.483]                 is_error <- inherits(cond, "error")
[13:20:04.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.483]                   NULL)
[13:20:04.483]                 if (is_error) {
[13:20:04.483]                   sessionInformation <- function() {
[13:20:04.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.483]                       search = base::search(), system = base::Sys.info())
[13:20:04.483]                   }
[13:20:04.483]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.483]                     cond$call), session = sessionInformation(), 
[13:20:04.483]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.483]                   signalCondition(cond)
[13:20:04.483]                 }
[13:20:04.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.483]                 "immediateCondition"))) {
[13:20:04.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.483]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.483]                   if (TRUE && !signal) {
[13:20:04.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.483]                     {
[13:20:04.483]                       inherits <- base::inherits
[13:20:04.483]                       invokeRestart <- base::invokeRestart
[13:20:04.483]                       is.null <- base::is.null
[13:20:04.483]                       muffled <- FALSE
[13:20:04.483]                       if (inherits(cond, "message")) {
[13:20:04.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.483]                         if (muffled) 
[13:20:04.483]                           invokeRestart("muffleMessage")
[13:20:04.483]                       }
[13:20:04.483]                       else if (inherits(cond, "warning")) {
[13:20:04.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.483]                         if (muffled) 
[13:20:04.483]                           invokeRestart("muffleWarning")
[13:20:04.483]                       }
[13:20:04.483]                       else if (inherits(cond, "condition")) {
[13:20:04.483]                         if (!is.null(pattern)) {
[13:20:04.483]                           computeRestarts <- base::computeRestarts
[13:20:04.483]                           grepl <- base::grepl
[13:20:04.483]                           restarts <- computeRestarts(cond)
[13:20:04.483]                           for (restart in restarts) {
[13:20:04.483]                             name <- restart$name
[13:20:04.483]                             if (is.null(name)) 
[13:20:04.483]                               next
[13:20:04.483]                             if (!grepl(pattern, name)) 
[13:20:04.483]                               next
[13:20:04.483]                             invokeRestart(restart)
[13:20:04.483]                             muffled <- TRUE
[13:20:04.483]                             break
[13:20:04.483]                           }
[13:20:04.483]                         }
[13:20:04.483]                       }
[13:20:04.483]                       invisible(muffled)
[13:20:04.483]                     }
[13:20:04.483]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.483]                   }
[13:20:04.483]                 }
[13:20:04.483]                 else {
[13:20:04.483]                   if (TRUE) {
[13:20:04.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.483]                     {
[13:20:04.483]                       inherits <- base::inherits
[13:20:04.483]                       invokeRestart <- base::invokeRestart
[13:20:04.483]                       is.null <- base::is.null
[13:20:04.483]                       muffled <- FALSE
[13:20:04.483]                       if (inherits(cond, "message")) {
[13:20:04.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.483]                         if (muffled) 
[13:20:04.483]                           invokeRestart("muffleMessage")
[13:20:04.483]                       }
[13:20:04.483]                       else if (inherits(cond, "warning")) {
[13:20:04.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.483]                         if (muffled) 
[13:20:04.483]                           invokeRestart("muffleWarning")
[13:20:04.483]                       }
[13:20:04.483]                       else if (inherits(cond, "condition")) {
[13:20:04.483]                         if (!is.null(pattern)) {
[13:20:04.483]                           computeRestarts <- base::computeRestarts
[13:20:04.483]                           grepl <- base::grepl
[13:20:04.483]                           restarts <- computeRestarts(cond)
[13:20:04.483]                           for (restart in restarts) {
[13:20:04.483]                             name <- restart$name
[13:20:04.483]                             if (is.null(name)) 
[13:20:04.483]                               next
[13:20:04.483]                             if (!grepl(pattern, name)) 
[13:20:04.483]                               next
[13:20:04.483]                             invokeRestart(restart)
[13:20:04.483]                             muffled <- TRUE
[13:20:04.483]                             break
[13:20:04.483]                           }
[13:20:04.483]                         }
[13:20:04.483]                       }
[13:20:04.483]                       invisible(muffled)
[13:20:04.483]                     }
[13:20:04.483]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.483]                   }
[13:20:04.483]                 }
[13:20:04.483]             }
[13:20:04.483]         }))
[13:20:04.483]     }, error = function(ex) {
[13:20:04.483]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.483]                 ...future.rng), started = ...future.startTime, 
[13:20:04.483]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.483]             version = "1.8"), class = "FutureResult")
[13:20:04.483]     }, finally = {
[13:20:04.483]         if (!identical(...future.workdir, getwd())) 
[13:20:04.483]             setwd(...future.workdir)
[13:20:04.483]         {
[13:20:04.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.483]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.483]             }
[13:20:04.483]             base::options(...future.oldOptions)
[13:20:04.483]             if (.Platform$OS.type == "windows") {
[13:20:04.483]                 old_names <- names(...future.oldEnvVars)
[13:20:04.483]                 envs <- base::Sys.getenv()
[13:20:04.483]                 names <- names(envs)
[13:20:04.483]                 common <- intersect(names, old_names)
[13:20:04.483]                 added <- setdiff(names, old_names)
[13:20:04.483]                 removed <- setdiff(old_names, names)
[13:20:04.483]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.483]                   envs[common]]
[13:20:04.483]                 NAMES <- toupper(changed)
[13:20:04.483]                 args <- list()
[13:20:04.483]                 for (kk in seq_along(NAMES)) {
[13:20:04.483]                   name <- changed[[kk]]
[13:20:04.483]                   NAME <- NAMES[[kk]]
[13:20:04.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.483]                     next
[13:20:04.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.483]                 }
[13:20:04.483]                 NAMES <- toupper(added)
[13:20:04.483]                 for (kk in seq_along(NAMES)) {
[13:20:04.483]                   name <- added[[kk]]
[13:20:04.483]                   NAME <- NAMES[[kk]]
[13:20:04.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.483]                     next
[13:20:04.483]                   args[[name]] <- ""
[13:20:04.483]                 }
[13:20:04.483]                 NAMES <- toupper(removed)
[13:20:04.483]                 for (kk in seq_along(NAMES)) {
[13:20:04.483]                   name <- removed[[kk]]
[13:20:04.483]                   NAME <- NAMES[[kk]]
[13:20:04.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.483]                     next
[13:20:04.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.483]                 }
[13:20:04.483]                 if (length(args) > 0) 
[13:20:04.483]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.483]             }
[13:20:04.483]             else {
[13:20:04.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.483]             }
[13:20:04.483]             {
[13:20:04.483]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.483]                   0L) {
[13:20:04.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.483]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.483]                   base::options(opts)
[13:20:04.483]                 }
[13:20:04.483]                 {
[13:20:04.483]                   {
[13:20:04.483]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.483]                     NULL
[13:20:04.483]                   }
[13:20:04.483]                   options(future.plan = NULL)
[13:20:04.483]                   if (is.na(NA_character_)) 
[13:20:04.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.483]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.483]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.483]                     envir = parent.frame()) 
[13:20:04.483]                   {
[13:20:04.483]                     if (is.function(workers)) 
[13:20:04.483]                       workers <- workers()
[13:20:04.483]                     workers <- structure(as.integer(workers), 
[13:20:04.483]                       class = class(workers))
[13:20:04.483]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.483]                       workers >= 1)
[13:20:04.483]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.483]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.483]                     }
[13:20:04.483]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.483]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.483]                       envir = envir)
[13:20:04.483]                     if (!future$lazy) 
[13:20:04.483]                       future <- run(future)
[13:20:04.483]                     invisible(future)
[13:20:04.483]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.483]                 }
[13:20:04.483]             }
[13:20:04.483]         }
[13:20:04.483]     })
[13:20:04.483]     if (TRUE) {
[13:20:04.483]         base::sink(type = "output", split = FALSE)
[13:20:04.483]         if (TRUE) {
[13:20:04.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.483]         }
[13:20:04.483]         else {
[13:20:04.483]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.483]         }
[13:20:04.483]         base::close(...future.stdout)
[13:20:04.483]         ...future.stdout <- NULL
[13:20:04.483]     }
[13:20:04.483]     ...future.result$conditions <- ...future.conditions
[13:20:04.483]     ...future.result$finished <- base::Sys.time()
[13:20:04.483]     ...future.result
[13:20:04.483] }
[13:20:04.486] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:20:04.486] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:20:04.486] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:20:04.486] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:04.487] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.487] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[13:20:04.487] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[13:20:04.487] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:04.488] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.488] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:04.488] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.488] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:20:04.489] MultisessionFuture started
[13:20:04.489] - Launch lazy future ... done
[13:20:04.489] run() for ‘MultisessionFuture’ ... done
[13:20:04.489] Created future:
[13:20:04.489] MultisessionFuture:
[13:20:04.489] Label: ‘future_by-1’
[13:20:04.489] Expression:
[13:20:04.489] {
[13:20:04.489]     do.call(function(...) {
[13:20:04.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.489]             on.exit(options(oopts), add = TRUE)
[13:20:04.489]         }
[13:20:04.489]         {
[13:20:04.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.489]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.489]             })
[13:20:04.489]         }
[13:20:04.489]     }, args = future.call.arguments)
[13:20:04.489] }
[13:20:04.489] Lazy evaluation: FALSE
[13:20:04.489] Asynchronous evaluation: TRUE
[13:20:04.489] Local evaluation: TRUE
[13:20:04.489] Environment: R_GlobalEnv
[13:20:04.489] Capture standard output: TRUE
[13:20:04.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:04.489] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:04.489] Packages: <none>
[13:20:04.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:04.489] Resolved: FALSE
[13:20:04.489] Value: <not collected>
[13:20:04.489] Conditions captured: <none>
[13:20:04.489] Early signaling: FALSE
[13:20:04.489] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:04.489] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.501] Chunk #1 of 2 ... DONE
[13:20:04.501] Chunk #2 of 2 ...
[13:20:04.502]  - Finding globals in 'X' for chunk #2 ...
[13:20:04.502] getGlobalsAndPackages() ...
[13:20:04.502] Searching for globals...
[13:20:04.502] 
[13:20:04.502] Searching for globals ... DONE
[13:20:04.502] - globals: [0] <none>
[13:20:04.502] getGlobalsAndPackages() ... DONE
[13:20:04.503]    + additional globals found: [n=0] 
[13:20:04.503]    + additional namespaces needed: [n=0] 
[13:20:04.503]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:04.503]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:04.503]  - seeds: <none>
[13:20:04.503]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.503] getGlobalsAndPackages() ...
[13:20:04.503] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.503] Resolving globals: FALSE
[13:20:04.503] Tweak future expression to call with '...' arguments ...
[13:20:04.504] {
[13:20:04.504]     do.call(function(...) {
[13:20:04.504]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.504]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.504]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.504]             on.exit(options(oopts), add = TRUE)
[13:20:04.504]         }
[13:20:04.504]         {
[13:20:04.504]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.504]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.504]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.504]             })
[13:20:04.504]         }
[13:20:04.504]     }, args = future.call.arguments)
[13:20:04.504] }
[13:20:04.504] Tweak future expression to call with '...' arguments ... DONE
[13:20:04.504] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.504] 
[13:20:04.504] getGlobalsAndPackages() ... DONE
[13:20:04.505] run() for ‘Future’ ...
[13:20:04.505] - state: ‘created’
[13:20:04.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:04.519] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:04.519]   - Field: ‘node’
[13:20:04.519]   - Field: ‘label’
[13:20:04.520]   - Field: ‘local’
[13:20:04.520]   - Field: ‘owner’
[13:20:04.520]   - Field: ‘envir’
[13:20:04.520]   - Field: ‘workers’
[13:20:04.520]   - Field: ‘packages’
[13:20:04.520]   - Field: ‘gc’
[13:20:04.520]   - Field: ‘conditions’
[13:20:04.520]   - Field: ‘persistent’
[13:20:04.520]   - Field: ‘expr’
[13:20:04.520]   - Field: ‘uuid’
[13:20:04.521]   - Field: ‘seed’
[13:20:04.521]   - Field: ‘version’
[13:20:04.521]   - Field: ‘result’
[13:20:04.521]   - Field: ‘asynchronous’
[13:20:04.521]   - Field: ‘calls’
[13:20:04.521]   - Field: ‘globals’
[13:20:04.521]   - Field: ‘stdout’
[13:20:04.521]   - Field: ‘earlySignal’
[13:20:04.521]   - Field: ‘lazy’
[13:20:04.521]   - Field: ‘state’
[13:20:04.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:04.522] - Launch lazy future ...
[13:20:04.522] Packages needed by the future expression (n = 0): <none>
[13:20:04.522] Packages needed by future strategies (n = 0): <none>
[13:20:04.522] {
[13:20:04.522]     {
[13:20:04.522]         {
[13:20:04.522]             ...future.startTime <- base::Sys.time()
[13:20:04.522]             {
[13:20:04.522]                 {
[13:20:04.522]                   {
[13:20:04.522]                     {
[13:20:04.522]                       base::local({
[13:20:04.522]                         has_future <- base::requireNamespace("future", 
[13:20:04.522]                           quietly = TRUE)
[13:20:04.522]                         if (has_future) {
[13:20:04.522]                           ns <- base::getNamespace("future")
[13:20:04.522]                           version <- ns[[".package"]][["version"]]
[13:20:04.522]                           if (is.null(version)) 
[13:20:04.522]                             version <- utils::packageVersion("future")
[13:20:04.522]                         }
[13:20:04.522]                         else {
[13:20:04.522]                           version <- NULL
[13:20:04.522]                         }
[13:20:04.522]                         if (!has_future || version < "1.8.0") {
[13:20:04.522]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.522]                             "", base::R.version$version.string), 
[13:20:04.522]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:04.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:04.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.522]                               "release", "version")], collapse = " "), 
[13:20:04.522]                             hostname = base::Sys.info()[["nodename"]])
[13:20:04.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.522]                             info)
[13:20:04.522]                           info <- base::paste(info, collapse = "; ")
[13:20:04.522]                           if (!has_future) {
[13:20:04.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.522]                               info)
[13:20:04.522]                           }
[13:20:04.522]                           else {
[13:20:04.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.522]                               info, version)
[13:20:04.522]                           }
[13:20:04.522]                           base::stop(msg)
[13:20:04.522]                         }
[13:20:04.522]                       })
[13:20:04.522]                     }
[13:20:04.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.522]                     base::options(mc.cores = 1L)
[13:20:04.522]                   }
[13:20:04.522]                   options(future.plan = NULL)
[13:20:04.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.522]                 }
[13:20:04.522]                 ...future.workdir <- getwd()
[13:20:04.522]             }
[13:20:04.522]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.522]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.522]         }
[13:20:04.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.522]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:04.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.522]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.522]             base::names(...future.oldOptions))
[13:20:04.522]     }
[13:20:04.522]     if (FALSE) {
[13:20:04.522]     }
[13:20:04.522]     else {
[13:20:04.522]         if (TRUE) {
[13:20:04.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.522]                 open = "w")
[13:20:04.522]         }
[13:20:04.522]         else {
[13:20:04.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.522]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.522]         }
[13:20:04.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.522]             base::sink(type = "output", split = FALSE)
[13:20:04.522]             base::close(...future.stdout)
[13:20:04.522]         }, add = TRUE)
[13:20:04.522]     }
[13:20:04.522]     ...future.frame <- base::sys.nframe()
[13:20:04.522]     ...future.conditions <- base::list()
[13:20:04.522]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.522]     if (FALSE) {
[13:20:04.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.522]     }
[13:20:04.522]     ...future.result <- base::tryCatch({
[13:20:04.522]         base::withCallingHandlers({
[13:20:04.522]             ...future.value <- base::withVisible(base::local({
[13:20:04.522]                 ...future.makeSendCondition <- base::local({
[13:20:04.522]                   sendCondition <- NULL
[13:20:04.522]                   function(frame = 1L) {
[13:20:04.522]                     if (is.function(sendCondition)) 
[13:20:04.522]                       return(sendCondition)
[13:20:04.522]                     ns <- getNamespace("parallel")
[13:20:04.522]                     if (exists("sendData", mode = "function", 
[13:20:04.522]                       envir = ns)) {
[13:20:04.522]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.522]                         envir = ns)
[13:20:04.522]                       envir <- sys.frame(frame)
[13:20:04.522]                       master <- NULL
[13:20:04.522]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.522]                         !identical(envir, emptyenv())) {
[13:20:04.522]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.522]                           inherits = FALSE)) {
[13:20:04.522]                           master <- get("master", mode = "list", 
[13:20:04.522]                             envir = envir, inherits = FALSE)
[13:20:04.522]                           if (inherits(master, c("SOCKnode", 
[13:20:04.522]                             "SOCK0node"))) {
[13:20:04.522]                             sendCondition <<- function(cond) {
[13:20:04.522]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.522]                                 success = TRUE)
[13:20:04.522]                               parallel_sendData(master, data)
[13:20:04.522]                             }
[13:20:04.522]                             return(sendCondition)
[13:20:04.522]                           }
[13:20:04.522]                         }
[13:20:04.522]                         frame <- frame + 1L
[13:20:04.522]                         envir <- sys.frame(frame)
[13:20:04.522]                       }
[13:20:04.522]                     }
[13:20:04.522]                     sendCondition <<- function(cond) NULL
[13:20:04.522]                   }
[13:20:04.522]                 })
[13:20:04.522]                 withCallingHandlers({
[13:20:04.522]                   {
[13:20:04.522]                     do.call(function(...) {
[13:20:04.522]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.522]                       if (!identical(...future.globals.maxSize.org, 
[13:20:04.522]                         ...future.globals.maxSize)) {
[13:20:04.522]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.522]                         on.exit(options(oopts), add = TRUE)
[13:20:04.522]                       }
[13:20:04.522]                       {
[13:20:04.522]                         lapply(seq_along(...future.elements_ii), 
[13:20:04.522]                           FUN = function(jj) {
[13:20:04.522]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.522]                             ...future.FUN(...future.X_jj, ...)
[13:20:04.522]                           })
[13:20:04.522]                       }
[13:20:04.522]                     }, args = future.call.arguments)
[13:20:04.522]                   }
[13:20:04.522]                 }, immediateCondition = function(cond) {
[13:20:04.522]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.522]                   sendCondition(cond)
[13:20:04.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.522]                   {
[13:20:04.522]                     inherits <- base::inherits
[13:20:04.522]                     invokeRestart <- base::invokeRestart
[13:20:04.522]                     is.null <- base::is.null
[13:20:04.522]                     muffled <- FALSE
[13:20:04.522]                     if (inherits(cond, "message")) {
[13:20:04.522]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.522]                       if (muffled) 
[13:20:04.522]                         invokeRestart("muffleMessage")
[13:20:04.522]                     }
[13:20:04.522]                     else if (inherits(cond, "warning")) {
[13:20:04.522]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.522]                       if (muffled) 
[13:20:04.522]                         invokeRestart("muffleWarning")
[13:20:04.522]                     }
[13:20:04.522]                     else if (inherits(cond, "condition")) {
[13:20:04.522]                       if (!is.null(pattern)) {
[13:20:04.522]                         computeRestarts <- base::computeRestarts
[13:20:04.522]                         grepl <- base::grepl
[13:20:04.522]                         restarts <- computeRestarts(cond)
[13:20:04.522]                         for (restart in restarts) {
[13:20:04.522]                           name <- restart$name
[13:20:04.522]                           if (is.null(name)) 
[13:20:04.522]                             next
[13:20:04.522]                           if (!grepl(pattern, name)) 
[13:20:04.522]                             next
[13:20:04.522]                           invokeRestart(restart)
[13:20:04.522]                           muffled <- TRUE
[13:20:04.522]                           break
[13:20:04.522]                         }
[13:20:04.522]                       }
[13:20:04.522]                     }
[13:20:04.522]                     invisible(muffled)
[13:20:04.522]                   }
[13:20:04.522]                   muffleCondition(cond)
[13:20:04.522]                 })
[13:20:04.522]             }))
[13:20:04.522]             future::FutureResult(value = ...future.value$value, 
[13:20:04.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.522]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.522]                     ...future.globalenv.names))
[13:20:04.522]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.522]         }, condition = base::local({
[13:20:04.522]             c <- base::c
[13:20:04.522]             inherits <- base::inherits
[13:20:04.522]             invokeRestart <- base::invokeRestart
[13:20:04.522]             length <- base::length
[13:20:04.522]             list <- base::list
[13:20:04.522]             seq.int <- base::seq.int
[13:20:04.522]             signalCondition <- base::signalCondition
[13:20:04.522]             sys.calls <- base::sys.calls
[13:20:04.522]             `[[` <- base::`[[`
[13:20:04.522]             `+` <- base::`+`
[13:20:04.522]             `<<-` <- base::`<<-`
[13:20:04.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.522]                   3L)]
[13:20:04.522]             }
[13:20:04.522]             function(cond) {
[13:20:04.522]                 is_error <- inherits(cond, "error")
[13:20:04.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.522]                   NULL)
[13:20:04.522]                 if (is_error) {
[13:20:04.522]                   sessionInformation <- function() {
[13:20:04.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.522]                       search = base::search(), system = base::Sys.info())
[13:20:04.522]                   }
[13:20:04.522]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.522]                     cond$call), session = sessionInformation(), 
[13:20:04.522]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.522]                   signalCondition(cond)
[13:20:04.522]                 }
[13:20:04.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.522]                 "immediateCondition"))) {
[13:20:04.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.522]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.522]                   if (TRUE && !signal) {
[13:20:04.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.522]                     {
[13:20:04.522]                       inherits <- base::inherits
[13:20:04.522]                       invokeRestart <- base::invokeRestart
[13:20:04.522]                       is.null <- base::is.null
[13:20:04.522]                       muffled <- FALSE
[13:20:04.522]                       if (inherits(cond, "message")) {
[13:20:04.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.522]                         if (muffled) 
[13:20:04.522]                           invokeRestart("muffleMessage")
[13:20:04.522]                       }
[13:20:04.522]                       else if (inherits(cond, "warning")) {
[13:20:04.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.522]                         if (muffled) 
[13:20:04.522]                           invokeRestart("muffleWarning")
[13:20:04.522]                       }
[13:20:04.522]                       else if (inherits(cond, "condition")) {
[13:20:04.522]                         if (!is.null(pattern)) {
[13:20:04.522]                           computeRestarts <- base::computeRestarts
[13:20:04.522]                           grepl <- base::grepl
[13:20:04.522]                           restarts <- computeRestarts(cond)
[13:20:04.522]                           for (restart in restarts) {
[13:20:04.522]                             name <- restart$name
[13:20:04.522]                             if (is.null(name)) 
[13:20:04.522]                               next
[13:20:04.522]                             if (!grepl(pattern, name)) 
[13:20:04.522]                               next
[13:20:04.522]                             invokeRestart(restart)
[13:20:04.522]                             muffled <- TRUE
[13:20:04.522]                             break
[13:20:04.522]                           }
[13:20:04.522]                         }
[13:20:04.522]                       }
[13:20:04.522]                       invisible(muffled)
[13:20:04.522]                     }
[13:20:04.522]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.522]                   }
[13:20:04.522]                 }
[13:20:04.522]                 else {
[13:20:04.522]                   if (TRUE) {
[13:20:04.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.522]                     {
[13:20:04.522]                       inherits <- base::inherits
[13:20:04.522]                       invokeRestart <- base::invokeRestart
[13:20:04.522]                       is.null <- base::is.null
[13:20:04.522]                       muffled <- FALSE
[13:20:04.522]                       if (inherits(cond, "message")) {
[13:20:04.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.522]                         if (muffled) 
[13:20:04.522]                           invokeRestart("muffleMessage")
[13:20:04.522]                       }
[13:20:04.522]                       else if (inherits(cond, "warning")) {
[13:20:04.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.522]                         if (muffled) 
[13:20:04.522]                           invokeRestart("muffleWarning")
[13:20:04.522]                       }
[13:20:04.522]                       else if (inherits(cond, "condition")) {
[13:20:04.522]                         if (!is.null(pattern)) {
[13:20:04.522]                           computeRestarts <- base::computeRestarts
[13:20:04.522]                           grepl <- base::grepl
[13:20:04.522]                           restarts <- computeRestarts(cond)
[13:20:04.522]                           for (restart in restarts) {
[13:20:04.522]                             name <- restart$name
[13:20:04.522]                             if (is.null(name)) 
[13:20:04.522]                               next
[13:20:04.522]                             if (!grepl(pattern, name)) 
[13:20:04.522]                               next
[13:20:04.522]                             invokeRestart(restart)
[13:20:04.522]                             muffled <- TRUE
[13:20:04.522]                             break
[13:20:04.522]                           }
[13:20:04.522]                         }
[13:20:04.522]                       }
[13:20:04.522]                       invisible(muffled)
[13:20:04.522]                     }
[13:20:04.522]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.522]                   }
[13:20:04.522]                 }
[13:20:04.522]             }
[13:20:04.522]         }))
[13:20:04.522]     }, error = function(ex) {
[13:20:04.522]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.522]                 ...future.rng), started = ...future.startTime, 
[13:20:04.522]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.522]             version = "1.8"), class = "FutureResult")
[13:20:04.522]     }, finally = {
[13:20:04.522]         if (!identical(...future.workdir, getwd())) 
[13:20:04.522]             setwd(...future.workdir)
[13:20:04.522]         {
[13:20:04.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.522]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.522]             }
[13:20:04.522]             base::options(...future.oldOptions)
[13:20:04.522]             if (.Platform$OS.type == "windows") {
[13:20:04.522]                 old_names <- names(...future.oldEnvVars)
[13:20:04.522]                 envs <- base::Sys.getenv()
[13:20:04.522]                 names <- names(envs)
[13:20:04.522]                 common <- intersect(names, old_names)
[13:20:04.522]                 added <- setdiff(names, old_names)
[13:20:04.522]                 removed <- setdiff(old_names, names)
[13:20:04.522]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.522]                   envs[common]]
[13:20:04.522]                 NAMES <- toupper(changed)
[13:20:04.522]                 args <- list()
[13:20:04.522]                 for (kk in seq_along(NAMES)) {
[13:20:04.522]                   name <- changed[[kk]]
[13:20:04.522]                   NAME <- NAMES[[kk]]
[13:20:04.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.522]                     next
[13:20:04.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.522]                 }
[13:20:04.522]                 NAMES <- toupper(added)
[13:20:04.522]                 for (kk in seq_along(NAMES)) {
[13:20:04.522]                   name <- added[[kk]]
[13:20:04.522]                   NAME <- NAMES[[kk]]
[13:20:04.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.522]                     next
[13:20:04.522]                   args[[name]] <- ""
[13:20:04.522]                 }
[13:20:04.522]                 NAMES <- toupper(removed)
[13:20:04.522]                 for (kk in seq_along(NAMES)) {
[13:20:04.522]                   name <- removed[[kk]]
[13:20:04.522]                   NAME <- NAMES[[kk]]
[13:20:04.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.522]                     next
[13:20:04.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.522]                 }
[13:20:04.522]                 if (length(args) > 0) 
[13:20:04.522]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.522]             }
[13:20:04.522]             else {
[13:20:04.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.522]             }
[13:20:04.522]             {
[13:20:04.522]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.522]                   0L) {
[13:20:04.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.522]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.522]                   base::options(opts)
[13:20:04.522]                 }
[13:20:04.522]                 {
[13:20:04.522]                   {
[13:20:04.522]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.522]                     NULL
[13:20:04.522]                   }
[13:20:04.522]                   options(future.plan = NULL)
[13:20:04.522]                   if (is.na(NA_character_)) 
[13:20:04.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.522]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.522]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.522]                     envir = parent.frame()) 
[13:20:04.522]                   {
[13:20:04.522]                     if (is.function(workers)) 
[13:20:04.522]                       workers <- workers()
[13:20:04.522]                     workers <- structure(as.integer(workers), 
[13:20:04.522]                       class = class(workers))
[13:20:04.522]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.522]                       workers >= 1)
[13:20:04.522]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.522]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.522]                     }
[13:20:04.522]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.522]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.522]                       envir = envir)
[13:20:04.522]                     if (!future$lazy) 
[13:20:04.522]                       future <- run(future)
[13:20:04.522]                     invisible(future)
[13:20:04.522]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.522]                 }
[13:20:04.522]             }
[13:20:04.522]         }
[13:20:04.522]     })
[13:20:04.522]     if (TRUE) {
[13:20:04.522]         base::sink(type = "output", split = FALSE)
[13:20:04.522]         if (TRUE) {
[13:20:04.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.522]         }
[13:20:04.522]         else {
[13:20:04.522]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.522]         }
[13:20:04.522]         base::close(...future.stdout)
[13:20:04.522]         ...future.stdout <- NULL
[13:20:04.522]     }
[13:20:04.522]     ...future.result$conditions <- ...future.conditions
[13:20:04.522]     ...future.result$finished <- base::Sys.time()
[13:20:04.522]     ...future.result
[13:20:04.522] }
[13:20:04.578] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:20:04.578] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:20:04.579] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:20:04.579] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:04.579] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.580] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[13:20:04.580] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[13:20:04.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:04.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.581] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:04.581] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.581] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:20:04.582] MultisessionFuture started
[13:20:04.582] - Launch lazy future ... done
[13:20:04.582] run() for ‘MultisessionFuture’ ... done
[13:20:04.582] Created future:
[13:20:04.582] MultisessionFuture:
[13:20:04.582] Label: ‘future_by-2’
[13:20:04.582] Expression:
[13:20:04.582] {
[13:20:04.582]     do.call(function(...) {
[13:20:04.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.582]             on.exit(options(oopts), add = TRUE)
[13:20:04.582]         }
[13:20:04.582]         {
[13:20:04.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.582]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.582]             })
[13:20:04.582]         }
[13:20:04.582]     }, args = future.call.arguments)
[13:20:04.582] }
[13:20:04.582] Lazy evaluation: FALSE
[13:20:04.582] Asynchronous evaluation: TRUE
[13:20:04.582] Local evaluation: TRUE
[13:20:04.582] Environment: R_GlobalEnv
[13:20:04.582] Capture standard output: TRUE
[13:20:04.582] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:04.582] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:04.582] Packages: <none>
[13:20:04.582] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:04.582] Resolved: FALSE
[13:20:04.582] Value: <not collected>
[13:20:04.582] Conditions captured: <none>
[13:20:04.582] Early signaling: FALSE
[13:20:04.582] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:04.582] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.594] Chunk #2 of 2 ... DONE
[13:20:04.594] Launching 2 futures (chunks) ... DONE
[13:20:04.595] Resolving 2 futures (chunks) ...
[13:20:04.595] resolve() on list ...
[13:20:04.595]  recursive: 0
[13:20:04.595]  length: 2
[13:20:04.595] 
[13:20:04.596] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.596] - Validating connection of MultisessionFuture
[13:20:04.596] - received message: FutureResult
[13:20:04.596] - Received FutureResult
[13:20:04.596] - Erased future from FutureRegistry
[13:20:04.596] result() for ClusterFuture ...
[13:20:04.596] - result already collected: FutureResult
[13:20:04.596] result() for ClusterFuture ... done
[13:20:04.597] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.597] Future #1
[13:20:04.597] result() for ClusterFuture ...
[13:20:04.597] - result already collected: FutureResult
[13:20:04.597] result() for ClusterFuture ... done
[13:20:04.597] result() for ClusterFuture ...
[13:20:04.597] - result already collected: FutureResult
[13:20:04.597] result() for ClusterFuture ... done
[13:20:04.597] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:04.597] - nx: 2
[13:20:04.598] - relay: TRUE
[13:20:04.598] - stdout: TRUE
[13:20:04.598] - signal: TRUE
[13:20:04.598] - resignal: FALSE
[13:20:04.600] - force: TRUE
[13:20:04.600] - relayed: [n=2] FALSE, FALSE
[13:20:04.600] - queued futures: [n=2] FALSE, FALSE
[13:20:04.600]  - until=1
[13:20:04.601]  - relaying element #1
[13:20:04.601] result() for ClusterFuture ...
[13:20:04.601] - result already collected: FutureResult
[13:20:04.601] result() for ClusterFuture ... done
[13:20:04.601] result() for ClusterFuture ...
[13:20:04.601] - result already collected: FutureResult
[13:20:04.601] result() for ClusterFuture ... done
[13:20:04.601] result() for ClusterFuture ...
[13:20:04.601] - result already collected: FutureResult
[13:20:04.601] result() for ClusterFuture ... done
[13:20:04.601] result() for ClusterFuture ...
[13:20:04.602] - result already collected: FutureResult
[13:20:04.602] result() for ClusterFuture ... done
[13:20:04.602] - relayed: [n=2] TRUE, FALSE
[13:20:04.602] - queued futures: [n=2] TRUE, FALSE
[13:20:04.602] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:04.602]  length: 1 (resolved future 1)
[13:20:04.674] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.675] - Validating connection of MultisessionFuture
[13:20:04.675] - received message: FutureResult
[13:20:04.675] - Received FutureResult
[13:20:04.675] - Erased future from FutureRegistry
[13:20:04.675] result() for ClusterFuture ...
[13:20:04.675] - result already collected: FutureResult
[13:20:04.675] result() for ClusterFuture ... done
[13:20:04.676] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.676] Future #2
[13:20:04.676] result() for ClusterFuture ...
[13:20:04.676] - result already collected: FutureResult
[13:20:04.676] result() for ClusterFuture ... done
[13:20:04.676] result() for ClusterFuture ...
[13:20:04.676] - result already collected: FutureResult
[13:20:04.676] result() for ClusterFuture ... done
[13:20:04.676] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:04.676] - nx: 2
[13:20:04.676] - relay: TRUE
[13:20:04.677] - stdout: TRUE
[13:20:04.677] - signal: TRUE
[13:20:04.677] - resignal: FALSE
[13:20:04.677] - force: TRUE
[13:20:04.677] - relayed: [n=2] TRUE, FALSE
[13:20:04.677] - queued futures: [n=2] TRUE, FALSE
[13:20:04.677]  - until=2
[13:20:04.677]  - relaying element #2
[13:20:04.677] result() for ClusterFuture ...
[13:20:04.677] - result already collected: FutureResult
[13:20:04.677] result() for ClusterFuture ... done
[13:20:04.678] result() for ClusterFuture ...
[13:20:04.678] - result already collected: FutureResult
[13:20:04.678] result() for ClusterFuture ... done
[13:20:04.678] result() for ClusterFuture ...
[13:20:04.678] - result already collected: FutureResult
[13:20:04.678] result() for ClusterFuture ... done
[13:20:04.678] result() for ClusterFuture ...
[13:20:04.678] - result already collected: FutureResult
[13:20:04.678] result() for ClusterFuture ... done
[13:20:04.678] - relayed: [n=2] TRUE, TRUE
[13:20:04.678] - queued futures: [n=2] TRUE, TRUE
[13:20:04.678] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:04.679]  length: 0 (resolved future 2)
[13:20:04.679] Relaying remaining futures
[13:20:04.679] signalConditionsASAP(NULL, pos=0) ...
[13:20:04.679] - nx: 2
[13:20:04.679] - relay: TRUE
[13:20:04.679] - stdout: TRUE
[13:20:04.679] - signal: TRUE
[13:20:04.679] - resignal: FALSE
[13:20:04.679] - force: TRUE
[13:20:04.679] - relayed: [n=2] TRUE, TRUE
[13:20:04.679] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:04.680] - relayed: [n=2] TRUE, TRUE
[13:20:04.680] - queued futures: [n=2] TRUE, TRUE
[13:20:04.680] signalConditionsASAP(NULL, pos=0) ... done
[13:20:04.680] resolve() on list ... DONE
[13:20:04.680] result() for ClusterFuture ...
[13:20:04.680] - result already collected: FutureResult
[13:20:04.680] result() for ClusterFuture ... done
[13:20:04.680] result() for ClusterFuture ...
[13:20:04.680] - result already collected: FutureResult
[13:20:04.680] result() for ClusterFuture ... done
[13:20:04.680] result() for ClusterFuture ...
[13:20:04.681] - result already collected: FutureResult
[13:20:04.681] result() for ClusterFuture ... done
[13:20:04.681] result() for ClusterFuture ...
[13:20:04.681] - result already collected: FutureResult
[13:20:04.681] result() for ClusterFuture ... done
[13:20:04.681]  - Number of value chunks collected: 2
[13:20:04.681] Resolving 2 futures (chunks) ... DONE
[13:20:04.681] Reducing values from 2 chunks ...
[13:20:04.681]  - Number of values collected after concatenation: 3
[13:20:04.681]  - Number of values expected: 3
[13:20:04.681] Reducing values from 2 chunks ... DONE
[13:20:04.681] future_lapply() ... DONE
[13:20:04.682] future_by_internal() ... DONE
[13:20:04.682] future_by_internal() ...
[13:20:04.682] future_lapply() ...
[13:20:04.687] Number of chunks: 2
[13:20:04.687] getGlobalsAndPackagesXApply() ...
[13:20:04.687]  - future.globals: TRUE
[13:20:04.687] getGlobalsAndPackages() ...
[13:20:04.687] Searching for globals...
[13:20:04.688] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:04.689] Searching for globals ... DONE
[13:20:04.689] Resolving globals: FALSE
[13:20:04.689] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:04.689] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:04.690] - globals: [1] ‘FUN’
[13:20:04.690] 
[13:20:04.690] getGlobalsAndPackages() ... DONE
[13:20:04.690]  - globals found/used: [n=1] ‘FUN’
[13:20:04.690]  - needed namespaces: [n=0] 
[13:20:04.690] Finding globals ... DONE
[13:20:04.690]  - use_args: TRUE
[13:20:04.690]  - Getting '...' globals ...
[13:20:04.691] resolve() on list ...
[13:20:04.691]  recursive: 0
[13:20:04.691]  length: 1
[13:20:04.691]  elements: ‘...’
[13:20:04.691]  length: 0 (resolved future 1)
[13:20:04.691] resolve() on list ... DONE
[13:20:04.691]    - '...' content: [n=1] ‘digits’
[13:20:04.691] List of 1
[13:20:04.691]  $ ...:List of 1
[13:20:04.691]   ..$ digits: int 2
[13:20:04.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.691]  - attr(*, "where")=List of 1
[13:20:04.691]   ..$ ...:<environment: 0x55acf0966b58> 
[13:20:04.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.691]  - attr(*, "resolved")= logi TRUE
[13:20:04.691]  - attr(*, "total_size")= num NA
[13:20:04.694]  - Getting '...' globals ... DONE
[13:20:04.694] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:04.695] List of 2
[13:20:04.695]  $ ...future.FUN:function (object, ...)  
[13:20:04.695]  $ ...          :List of 1
[13:20:04.695]   ..$ digits: int 2
[13:20:04.695]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.695]  - attr(*, "where")=List of 2
[13:20:04.695]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:04.695]   ..$ ...          :<environment: 0x55acf0966b58> 
[13:20:04.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.695]  - attr(*, "resolved")= logi FALSE
[13:20:04.695]  - attr(*, "total_size")= num 1296
[13:20:04.698] Packages to be attached in all futures: [n=0] 
[13:20:04.698] getGlobalsAndPackagesXApply() ... DONE
[13:20:04.698] Number of futures (= number of chunks): 2
[13:20:04.698] Launching 2 futures (chunks) ...
[13:20:04.698] Chunk #1 of 2 ...
[13:20:04.698]  - Finding globals in 'X' for chunk #1 ...
[13:20:04.698] getGlobalsAndPackages() ...
[13:20:04.698] Searching for globals...
[13:20:04.699] 
[13:20:04.699] Searching for globals ... DONE
[13:20:04.699] - globals: [0] <none>
[13:20:04.699] getGlobalsAndPackages() ... DONE
[13:20:04.699]    + additional globals found: [n=0] 
[13:20:04.699]    + additional namespaces needed: [n=0] 
[13:20:04.699]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:04.699]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:04.699]  - seeds: <none>
[13:20:04.699]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.700] getGlobalsAndPackages() ...
[13:20:04.700] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.700] Resolving globals: FALSE
[13:20:04.700] Tweak future expression to call with '...' arguments ...
[13:20:04.700] {
[13:20:04.700]     do.call(function(...) {
[13:20:04.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.700]             on.exit(options(oopts), add = TRUE)
[13:20:04.700]         }
[13:20:04.700]         {
[13:20:04.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.700]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.700]             })
[13:20:04.700]         }
[13:20:04.700]     }, args = future.call.arguments)
[13:20:04.700] }
[13:20:04.700] Tweak future expression to call with '...' arguments ... DONE
[13:20:04.701] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.701] 
[13:20:04.701] getGlobalsAndPackages() ... DONE
[13:20:04.701] run() for ‘Future’ ...
[13:20:04.701] - state: ‘created’
[13:20:04.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:04.716] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:04.716]   - Field: ‘node’
[13:20:04.716]   - Field: ‘label’
[13:20:04.716]   - Field: ‘local’
[13:20:04.716]   - Field: ‘owner’
[13:20:04.716]   - Field: ‘envir’
[13:20:04.716]   - Field: ‘workers’
[13:20:04.716]   - Field: ‘packages’
[13:20:04.717]   - Field: ‘gc’
[13:20:04.717]   - Field: ‘conditions’
[13:20:04.717]   - Field: ‘persistent’
[13:20:04.717]   - Field: ‘expr’
[13:20:04.717]   - Field: ‘uuid’
[13:20:04.717]   - Field: ‘seed’
[13:20:04.717]   - Field: ‘version’
[13:20:04.717]   - Field: ‘result’
[13:20:04.717]   - Field: ‘asynchronous’
[13:20:04.717]   - Field: ‘calls’
[13:20:04.717]   - Field: ‘globals’
[13:20:04.718]   - Field: ‘stdout’
[13:20:04.718]   - Field: ‘earlySignal’
[13:20:04.718]   - Field: ‘lazy’
[13:20:04.718]   - Field: ‘state’
[13:20:04.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:04.718] - Launch lazy future ...
[13:20:04.718] Packages needed by the future expression (n = 0): <none>
[13:20:04.718] Packages needed by future strategies (n = 0): <none>
[13:20:04.719] {
[13:20:04.719]     {
[13:20:04.719]         {
[13:20:04.719]             ...future.startTime <- base::Sys.time()
[13:20:04.719]             {
[13:20:04.719]                 {
[13:20:04.719]                   {
[13:20:04.719]                     {
[13:20:04.719]                       base::local({
[13:20:04.719]                         has_future <- base::requireNamespace("future", 
[13:20:04.719]                           quietly = TRUE)
[13:20:04.719]                         if (has_future) {
[13:20:04.719]                           ns <- base::getNamespace("future")
[13:20:04.719]                           version <- ns[[".package"]][["version"]]
[13:20:04.719]                           if (is.null(version)) 
[13:20:04.719]                             version <- utils::packageVersion("future")
[13:20:04.719]                         }
[13:20:04.719]                         else {
[13:20:04.719]                           version <- NULL
[13:20:04.719]                         }
[13:20:04.719]                         if (!has_future || version < "1.8.0") {
[13:20:04.719]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.719]                             "", base::R.version$version.string), 
[13:20:04.719]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:04.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:04.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.719]                               "release", "version")], collapse = " "), 
[13:20:04.719]                             hostname = base::Sys.info()[["nodename"]])
[13:20:04.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.719]                             info)
[13:20:04.719]                           info <- base::paste(info, collapse = "; ")
[13:20:04.719]                           if (!has_future) {
[13:20:04.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.719]                               info)
[13:20:04.719]                           }
[13:20:04.719]                           else {
[13:20:04.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.719]                               info, version)
[13:20:04.719]                           }
[13:20:04.719]                           base::stop(msg)
[13:20:04.719]                         }
[13:20:04.719]                       })
[13:20:04.719]                     }
[13:20:04.719]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.719]                     base::options(mc.cores = 1L)
[13:20:04.719]                   }
[13:20:04.719]                   options(future.plan = NULL)
[13:20:04.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.719]                 }
[13:20:04.719]                 ...future.workdir <- getwd()
[13:20:04.719]             }
[13:20:04.719]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.719]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.719]         }
[13:20:04.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.719]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:04.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.719]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.719]             base::names(...future.oldOptions))
[13:20:04.719]     }
[13:20:04.719]     if (FALSE) {
[13:20:04.719]     }
[13:20:04.719]     else {
[13:20:04.719]         if (TRUE) {
[13:20:04.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.719]                 open = "w")
[13:20:04.719]         }
[13:20:04.719]         else {
[13:20:04.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.719]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.719]         }
[13:20:04.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.719]             base::sink(type = "output", split = FALSE)
[13:20:04.719]             base::close(...future.stdout)
[13:20:04.719]         }, add = TRUE)
[13:20:04.719]     }
[13:20:04.719]     ...future.frame <- base::sys.nframe()
[13:20:04.719]     ...future.conditions <- base::list()
[13:20:04.719]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.719]     if (FALSE) {
[13:20:04.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.719]     }
[13:20:04.719]     ...future.result <- base::tryCatch({
[13:20:04.719]         base::withCallingHandlers({
[13:20:04.719]             ...future.value <- base::withVisible(base::local({
[13:20:04.719]                 ...future.makeSendCondition <- base::local({
[13:20:04.719]                   sendCondition <- NULL
[13:20:04.719]                   function(frame = 1L) {
[13:20:04.719]                     if (is.function(sendCondition)) 
[13:20:04.719]                       return(sendCondition)
[13:20:04.719]                     ns <- getNamespace("parallel")
[13:20:04.719]                     if (exists("sendData", mode = "function", 
[13:20:04.719]                       envir = ns)) {
[13:20:04.719]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.719]                         envir = ns)
[13:20:04.719]                       envir <- sys.frame(frame)
[13:20:04.719]                       master <- NULL
[13:20:04.719]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.719]                         !identical(envir, emptyenv())) {
[13:20:04.719]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.719]                           inherits = FALSE)) {
[13:20:04.719]                           master <- get("master", mode = "list", 
[13:20:04.719]                             envir = envir, inherits = FALSE)
[13:20:04.719]                           if (inherits(master, c("SOCKnode", 
[13:20:04.719]                             "SOCK0node"))) {
[13:20:04.719]                             sendCondition <<- function(cond) {
[13:20:04.719]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.719]                                 success = TRUE)
[13:20:04.719]                               parallel_sendData(master, data)
[13:20:04.719]                             }
[13:20:04.719]                             return(sendCondition)
[13:20:04.719]                           }
[13:20:04.719]                         }
[13:20:04.719]                         frame <- frame + 1L
[13:20:04.719]                         envir <- sys.frame(frame)
[13:20:04.719]                       }
[13:20:04.719]                     }
[13:20:04.719]                     sendCondition <<- function(cond) NULL
[13:20:04.719]                   }
[13:20:04.719]                 })
[13:20:04.719]                 withCallingHandlers({
[13:20:04.719]                   {
[13:20:04.719]                     do.call(function(...) {
[13:20:04.719]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.719]                       if (!identical(...future.globals.maxSize.org, 
[13:20:04.719]                         ...future.globals.maxSize)) {
[13:20:04.719]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.719]                         on.exit(options(oopts), add = TRUE)
[13:20:04.719]                       }
[13:20:04.719]                       {
[13:20:04.719]                         lapply(seq_along(...future.elements_ii), 
[13:20:04.719]                           FUN = function(jj) {
[13:20:04.719]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.719]                             ...future.FUN(...future.X_jj, ...)
[13:20:04.719]                           })
[13:20:04.719]                       }
[13:20:04.719]                     }, args = future.call.arguments)
[13:20:04.719]                   }
[13:20:04.719]                 }, immediateCondition = function(cond) {
[13:20:04.719]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.719]                   sendCondition(cond)
[13:20:04.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.719]                   {
[13:20:04.719]                     inherits <- base::inherits
[13:20:04.719]                     invokeRestart <- base::invokeRestart
[13:20:04.719]                     is.null <- base::is.null
[13:20:04.719]                     muffled <- FALSE
[13:20:04.719]                     if (inherits(cond, "message")) {
[13:20:04.719]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.719]                       if (muffled) 
[13:20:04.719]                         invokeRestart("muffleMessage")
[13:20:04.719]                     }
[13:20:04.719]                     else if (inherits(cond, "warning")) {
[13:20:04.719]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.719]                       if (muffled) 
[13:20:04.719]                         invokeRestart("muffleWarning")
[13:20:04.719]                     }
[13:20:04.719]                     else if (inherits(cond, "condition")) {
[13:20:04.719]                       if (!is.null(pattern)) {
[13:20:04.719]                         computeRestarts <- base::computeRestarts
[13:20:04.719]                         grepl <- base::grepl
[13:20:04.719]                         restarts <- computeRestarts(cond)
[13:20:04.719]                         for (restart in restarts) {
[13:20:04.719]                           name <- restart$name
[13:20:04.719]                           if (is.null(name)) 
[13:20:04.719]                             next
[13:20:04.719]                           if (!grepl(pattern, name)) 
[13:20:04.719]                             next
[13:20:04.719]                           invokeRestart(restart)
[13:20:04.719]                           muffled <- TRUE
[13:20:04.719]                           break
[13:20:04.719]                         }
[13:20:04.719]                       }
[13:20:04.719]                     }
[13:20:04.719]                     invisible(muffled)
[13:20:04.719]                   }
[13:20:04.719]                   muffleCondition(cond)
[13:20:04.719]                 })
[13:20:04.719]             }))
[13:20:04.719]             future::FutureResult(value = ...future.value$value, 
[13:20:04.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.719]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.719]                     ...future.globalenv.names))
[13:20:04.719]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.719]         }, condition = base::local({
[13:20:04.719]             c <- base::c
[13:20:04.719]             inherits <- base::inherits
[13:20:04.719]             invokeRestart <- base::invokeRestart
[13:20:04.719]             length <- base::length
[13:20:04.719]             list <- base::list
[13:20:04.719]             seq.int <- base::seq.int
[13:20:04.719]             signalCondition <- base::signalCondition
[13:20:04.719]             sys.calls <- base::sys.calls
[13:20:04.719]             `[[` <- base::`[[`
[13:20:04.719]             `+` <- base::`+`
[13:20:04.719]             `<<-` <- base::`<<-`
[13:20:04.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.719]                   3L)]
[13:20:04.719]             }
[13:20:04.719]             function(cond) {
[13:20:04.719]                 is_error <- inherits(cond, "error")
[13:20:04.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.719]                   NULL)
[13:20:04.719]                 if (is_error) {
[13:20:04.719]                   sessionInformation <- function() {
[13:20:04.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.719]                       search = base::search(), system = base::Sys.info())
[13:20:04.719]                   }
[13:20:04.719]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.719]                     cond$call), session = sessionInformation(), 
[13:20:04.719]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.719]                   signalCondition(cond)
[13:20:04.719]                 }
[13:20:04.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.719]                 "immediateCondition"))) {
[13:20:04.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.719]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.719]                   if (TRUE && !signal) {
[13:20:04.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.719]                     {
[13:20:04.719]                       inherits <- base::inherits
[13:20:04.719]                       invokeRestart <- base::invokeRestart
[13:20:04.719]                       is.null <- base::is.null
[13:20:04.719]                       muffled <- FALSE
[13:20:04.719]                       if (inherits(cond, "message")) {
[13:20:04.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.719]                         if (muffled) 
[13:20:04.719]                           invokeRestart("muffleMessage")
[13:20:04.719]                       }
[13:20:04.719]                       else if (inherits(cond, "warning")) {
[13:20:04.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.719]                         if (muffled) 
[13:20:04.719]                           invokeRestart("muffleWarning")
[13:20:04.719]                       }
[13:20:04.719]                       else if (inherits(cond, "condition")) {
[13:20:04.719]                         if (!is.null(pattern)) {
[13:20:04.719]                           computeRestarts <- base::computeRestarts
[13:20:04.719]                           grepl <- base::grepl
[13:20:04.719]                           restarts <- computeRestarts(cond)
[13:20:04.719]                           for (restart in restarts) {
[13:20:04.719]                             name <- restart$name
[13:20:04.719]                             if (is.null(name)) 
[13:20:04.719]                               next
[13:20:04.719]                             if (!grepl(pattern, name)) 
[13:20:04.719]                               next
[13:20:04.719]                             invokeRestart(restart)
[13:20:04.719]                             muffled <- TRUE
[13:20:04.719]                             break
[13:20:04.719]                           }
[13:20:04.719]                         }
[13:20:04.719]                       }
[13:20:04.719]                       invisible(muffled)
[13:20:04.719]                     }
[13:20:04.719]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.719]                   }
[13:20:04.719]                 }
[13:20:04.719]                 else {
[13:20:04.719]                   if (TRUE) {
[13:20:04.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.719]                     {
[13:20:04.719]                       inherits <- base::inherits
[13:20:04.719]                       invokeRestart <- base::invokeRestart
[13:20:04.719]                       is.null <- base::is.null
[13:20:04.719]                       muffled <- FALSE
[13:20:04.719]                       if (inherits(cond, "message")) {
[13:20:04.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.719]                         if (muffled) 
[13:20:04.719]                           invokeRestart("muffleMessage")
[13:20:04.719]                       }
[13:20:04.719]                       else if (inherits(cond, "warning")) {
[13:20:04.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.719]                         if (muffled) 
[13:20:04.719]                           invokeRestart("muffleWarning")
[13:20:04.719]                       }
[13:20:04.719]                       else if (inherits(cond, "condition")) {
[13:20:04.719]                         if (!is.null(pattern)) {
[13:20:04.719]                           computeRestarts <- base::computeRestarts
[13:20:04.719]                           grepl <- base::grepl
[13:20:04.719]                           restarts <- computeRestarts(cond)
[13:20:04.719]                           for (restart in restarts) {
[13:20:04.719]                             name <- restart$name
[13:20:04.719]                             if (is.null(name)) 
[13:20:04.719]                               next
[13:20:04.719]                             if (!grepl(pattern, name)) 
[13:20:04.719]                               next
[13:20:04.719]                             invokeRestart(restart)
[13:20:04.719]                             muffled <- TRUE
[13:20:04.719]                             break
[13:20:04.719]                           }
[13:20:04.719]                         }
[13:20:04.719]                       }
[13:20:04.719]                       invisible(muffled)
[13:20:04.719]                     }
[13:20:04.719]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.719]                   }
[13:20:04.719]                 }
[13:20:04.719]             }
[13:20:04.719]         }))
[13:20:04.719]     }, error = function(ex) {
[13:20:04.719]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.719]                 ...future.rng), started = ...future.startTime, 
[13:20:04.719]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.719]             version = "1.8"), class = "FutureResult")
[13:20:04.719]     }, finally = {
[13:20:04.719]         if (!identical(...future.workdir, getwd())) 
[13:20:04.719]             setwd(...future.workdir)
[13:20:04.719]         {
[13:20:04.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.719]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.719]             }
[13:20:04.719]             base::options(...future.oldOptions)
[13:20:04.719]             if (.Platform$OS.type == "windows") {
[13:20:04.719]                 old_names <- names(...future.oldEnvVars)
[13:20:04.719]                 envs <- base::Sys.getenv()
[13:20:04.719]                 names <- names(envs)
[13:20:04.719]                 common <- intersect(names, old_names)
[13:20:04.719]                 added <- setdiff(names, old_names)
[13:20:04.719]                 removed <- setdiff(old_names, names)
[13:20:04.719]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.719]                   envs[common]]
[13:20:04.719]                 NAMES <- toupper(changed)
[13:20:04.719]                 args <- list()
[13:20:04.719]                 for (kk in seq_along(NAMES)) {
[13:20:04.719]                   name <- changed[[kk]]
[13:20:04.719]                   NAME <- NAMES[[kk]]
[13:20:04.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.719]                     next
[13:20:04.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.719]                 }
[13:20:04.719]                 NAMES <- toupper(added)
[13:20:04.719]                 for (kk in seq_along(NAMES)) {
[13:20:04.719]                   name <- added[[kk]]
[13:20:04.719]                   NAME <- NAMES[[kk]]
[13:20:04.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.719]                     next
[13:20:04.719]                   args[[name]] <- ""
[13:20:04.719]                 }
[13:20:04.719]                 NAMES <- toupper(removed)
[13:20:04.719]                 for (kk in seq_along(NAMES)) {
[13:20:04.719]                   name <- removed[[kk]]
[13:20:04.719]                   NAME <- NAMES[[kk]]
[13:20:04.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.719]                     next
[13:20:04.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.719]                 }
[13:20:04.719]                 if (length(args) > 0) 
[13:20:04.719]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.719]             }
[13:20:04.719]             else {
[13:20:04.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.719]             }
[13:20:04.719]             {
[13:20:04.719]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.719]                   0L) {
[13:20:04.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.719]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.719]                   base::options(opts)
[13:20:04.719]                 }
[13:20:04.719]                 {
[13:20:04.719]                   {
[13:20:04.719]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.719]                     NULL
[13:20:04.719]                   }
[13:20:04.719]                   options(future.plan = NULL)
[13:20:04.719]                   if (is.na(NA_character_)) 
[13:20:04.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.719]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.719]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.719]                     envir = parent.frame()) 
[13:20:04.719]                   {
[13:20:04.719]                     if (is.function(workers)) 
[13:20:04.719]                       workers <- workers()
[13:20:04.719]                     workers <- structure(as.integer(workers), 
[13:20:04.719]                       class = class(workers))
[13:20:04.719]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.719]                       workers >= 1)
[13:20:04.719]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.719]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.719]                     }
[13:20:04.719]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.719]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.719]                       envir = envir)
[13:20:04.719]                     if (!future$lazy) 
[13:20:04.719]                       future <- run(future)
[13:20:04.719]                     invisible(future)
[13:20:04.719]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.719]                 }
[13:20:04.719]             }
[13:20:04.719]         }
[13:20:04.719]     })
[13:20:04.719]     if (TRUE) {
[13:20:04.719]         base::sink(type = "output", split = FALSE)
[13:20:04.719]         if (TRUE) {
[13:20:04.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.719]         }
[13:20:04.719]         else {
[13:20:04.719]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.719]         }
[13:20:04.719]         base::close(...future.stdout)
[13:20:04.719]         ...future.stdout <- NULL
[13:20:04.719]     }
[13:20:04.719]     ...future.result$conditions <- ...future.conditions
[13:20:04.719]     ...future.result$finished <- base::Sys.time()
[13:20:04.719]     ...future.result
[13:20:04.719] }
[13:20:04.722] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[13:20:04.722] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:20:04.722] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:20:04.723] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:20:04.723] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:20:04.723] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[13:20:04.724] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[13:20:04.724] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:04.724] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.724] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:04.725] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.725] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[13:20:04.725] MultisessionFuture started
[13:20:04.725] - Launch lazy future ... done
[13:20:04.726] run() for ‘MultisessionFuture’ ... done
[13:20:04.726] Created future:
[13:20:04.726] MultisessionFuture:
[13:20:04.726] Label: ‘future_by-1’
[13:20:04.726] Expression:
[13:20:04.726] {
[13:20:04.726]     do.call(function(...) {
[13:20:04.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.726]             on.exit(options(oopts), add = TRUE)
[13:20:04.726]         }
[13:20:04.726]         {
[13:20:04.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.726]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.726]             })
[13:20:04.726]         }
[13:20:04.726]     }, args = future.call.arguments)
[13:20:04.726] }
[13:20:04.726] Lazy evaluation: FALSE
[13:20:04.726] Asynchronous evaluation: TRUE
[13:20:04.726] Local evaluation: TRUE
[13:20:04.726] Environment: R_GlobalEnv
[13:20:04.726] Capture standard output: TRUE
[13:20:04.726] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:04.726] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:04.726] Packages: <none>
[13:20:04.726] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:04.726] Resolved: FALSE
[13:20:04.726] Value: <not collected>
[13:20:04.726] Conditions captured: <none>
[13:20:04.726] Early signaling: FALSE
[13:20:04.726] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:04.726] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.738] Chunk #1 of 2 ... DONE
[13:20:04.738] Chunk #2 of 2 ...
[13:20:04.738]  - Finding globals in 'X' for chunk #2 ...
[13:20:04.738] getGlobalsAndPackages() ...
[13:20:04.738] Searching for globals...
[13:20:04.739] 
[13:20:04.739] Searching for globals ... DONE
[13:20:04.739] - globals: [0] <none>
[13:20:04.739] getGlobalsAndPackages() ... DONE
[13:20:04.739]    + additional globals found: [n=0] 
[13:20:04.739]    + additional namespaces needed: [n=0] 
[13:20:04.739]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:04.739]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:04.739]  - seeds: <none>
[13:20:04.739]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.739] getGlobalsAndPackages() ...
[13:20:04.740] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.740] Resolving globals: FALSE
[13:20:04.740] Tweak future expression to call with '...' arguments ...
[13:20:04.740] {
[13:20:04.740]     do.call(function(...) {
[13:20:04.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.740]             on.exit(options(oopts), add = TRUE)
[13:20:04.740]         }
[13:20:04.740]         {
[13:20:04.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.740]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.740]             })
[13:20:04.740]         }
[13:20:04.740]     }, args = future.call.arguments)
[13:20:04.740] }
[13:20:04.740] Tweak future expression to call with '...' arguments ... DONE
[13:20:04.741] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.741] 
[13:20:04.741] getGlobalsAndPackages() ... DONE
[13:20:04.741] run() for ‘Future’ ...
[13:20:04.741] - state: ‘created’
[13:20:04.741] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:04.755] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:04.755]   - Field: ‘node’
[13:20:04.756]   - Field: ‘label’
[13:20:04.756]   - Field: ‘local’
[13:20:04.756]   - Field: ‘owner’
[13:20:04.756]   - Field: ‘envir’
[13:20:04.756]   - Field: ‘workers’
[13:20:04.756]   - Field: ‘packages’
[13:20:04.756]   - Field: ‘gc’
[13:20:04.756]   - Field: ‘conditions’
[13:20:04.756]   - Field: ‘persistent’
[13:20:04.756]   - Field: ‘expr’
[13:20:04.756]   - Field: ‘uuid’
[13:20:04.757]   - Field: ‘seed’
[13:20:04.757]   - Field: ‘version’
[13:20:04.757]   - Field: ‘result’
[13:20:04.757]   - Field: ‘asynchronous’
[13:20:04.757]   - Field: ‘calls’
[13:20:04.757]   - Field: ‘globals’
[13:20:04.757]   - Field: ‘stdout’
[13:20:04.757]   - Field: ‘earlySignal’
[13:20:04.757]   - Field: ‘lazy’
[13:20:04.757]   - Field: ‘state’
[13:20:04.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:04.758] - Launch lazy future ...
[13:20:04.758] Packages needed by the future expression (n = 0): <none>
[13:20:04.758] Packages needed by future strategies (n = 0): <none>
[13:20:04.758] {
[13:20:04.758]     {
[13:20:04.758]         {
[13:20:04.758]             ...future.startTime <- base::Sys.time()
[13:20:04.758]             {
[13:20:04.758]                 {
[13:20:04.758]                   {
[13:20:04.758]                     {
[13:20:04.758]                       base::local({
[13:20:04.758]                         has_future <- base::requireNamespace("future", 
[13:20:04.758]                           quietly = TRUE)
[13:20:04.758]                         if (has_future) {
[13:20:04.758]                           ns <- base::getNamespace("future")
[13:20:04.758]                           version <- ns[[".package"]][["version"]]
[13:20:04.758]                           if (is.null(version)) 
[13:20:04.758]                             version <- utils::packageVersion("future")
[13:20:04.758]                         }
[13:20:04.758]                         else {
[13:20:04.758]                           version <- NULL
[13:20:04.758]                         }
[13:20:04.758]                         if (!has_future || version < "1.8.0") {
[13:20:04.758]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.758]                             "", base::R.version$version.string), 
[13:20:04.758]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:04.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:04.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.758]                               "release", "version")], collapse = " "), 
[13:20:04.758]                             hostname = base::Sys.info()[["nodename"]])
[13:20:04.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.758]                             info)
[13:20:04.758]                           info <- base::paste(info, collapse = "; ")
[13:20:04.758]                           if (!has_future) {
[13:20:04.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.758]                               info)
[13:20:04.758]                           }
[13:20:04.758]                           else {
[13:20:04.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.758]                               info, version)
[13:20:04.758]                           }
[13:20:04.758]                           base::stop(msg)
[13:20:04.758]                         }
[13:20:04.758]                       })
[13:20:04.758]                     }
[13:20:04.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.758]                     base::options(mc.cores = 1L)
[13:20:04.758]                   }
[13:20:04.758]                   options(future.plan = NULL)
[13:20:04.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.758]                 }
[13:20:04.758]                 ...future.workdir <- getwd()
[13:20:04.758]             }
[13:20:04.758]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.758]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.758]         }
[13:20:04.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.758]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:04.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.758]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.758]             base::names(...future.oldOptions))
[13:20:04.758]     }
[13:20:04.758]     if (FALSE) {
[13:20:04.758]     }
[13:20:04.758]     else {
[13:20:04.758]         if (TRUE) {
[13:20:04.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.758]                 open = "w")
[13:20:04.758]         }
[13:20:04.758]         else {
[13:20:04.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.758]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.758]         }
[13:20:04.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.758]             base::sink(type = "output", split = FALSE)
[13:20:04.758]             base::close(...future.stdout)
[13:20:04.758]         }, add = TRUE)
[13:20:04.758]     }
[13:20:04.758]     ...future.frame <- base::sys.nframe()
[13:20:04.758]     ...future.conditions <- base::list()
[13:20:04.758]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.758]     if (FALSE) {
[13:20:04.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.758]     }
[13:20:04.758]     ...future.result <- base::tryCatch({
[13:20:04.758]         base::withCallingHandlers({
[13:20:04.758]             ...future.value <- base::withVisible(base::local({
[13:20:04.758]                 ...future.makeSendCondition <- base::local({
[13:20:04.758]                   sendCondition <- NULL
[13:20:04.758]                   function(frame = 1L) {
[13:20:04.758]                     if (is.function(sendCondition)) 
[13:20:04.758]                       return(sendCondition)
[13:20:04.758]                     ns <- getNamespace("parallel")
[13:20:04.758]                     if (exists("sendData", mode = "function", 
[13:20:04.758]                       envir = ns)) {
[13:20:04.758]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.758]                         envir = ns)
[13:20:04.758]                       envir <- sys.frame(frame)
[13:20:04.758]                       master <- NULL
[13:20:04.758]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.758]                         !identical(envir, emptyenv())) {
[13:20:04.758]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.758]                           inherits = FALSE)) {
[13:20:04.758]                           master <- get("master", mode = "list", 
[13:20:04.758]                             envir = envir, inherits = FALSE)
[13:20:04.758]                           if (inherits(master, c("SOCKnode", 
[13:20:04.758]                             "SOCK0node"))) {
[13:20:04.758]                             sendCondition <<- function(cond) {
[13:20:04.758]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.758]                                 success = TRUE)
[13:20:04.758]                               parallel_sendData(master, data)
[13:20:04.758]                             }
[13:20:04.758]                             return(sendCondition)
[13:20:04.758]                           }
[13:20:04.758]                         }
[13:20:04.758]                         frame <- frame + 1L
[13:20:04.758]                         envir <- sys.frame(frame)
[13:20:04.758]                       }
[13:20:04.758]                     }
[13:20:04.758]                     sendCondition <<- function(cond) NULL
[13:20:04.758]                   }
[13:20:04.758]                 })
[13:20:04.758]                 withCallingHandlers({
[13:20:04.758]                   {
[13:20:04.758]                     do.call(function(...) {
[13:20:04.758]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.758]                       if (!identical(...future.globals.maxSize.org, 
[13:20:04.758]                         ...future.globals.maxSize)) {
[13:20:04.758]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.758]                         on.exit(options(oopts), add = TRUE)
[13:20:04.758]                       }
[13:20:04.758]                       {
[13:20:04.758]                         lapply(seq_along(...future.elements_ii), 
[13:20:04.758]                           FUN = function(jj) {
[13:20:04.758]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.758]                             ...future.FUN(...future.X_jj, ...)
[13:20:04.758]                           })
[13:20:04.758]                       }
[13:20:04.758]                     }, args = future.call.arguments)
[13:20:04.758]                   }
[13:20:04.758]                 }, immediateCondition = function(cond) {
[13:20:04.758]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.758]                   sendCondition(cond)
[13:20:04.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.758]                   {
[13:20:04.758]                     inherits <- base::inherits
[13:20:04.758]                     invokeRestart <- base::invokeRestart
[13:20:04.758]                     is.null <- base::is.null
[13:20:04.758]                     muffled <- FALSE
[13:20:04.758]                     if (inherits(cond, "message")) {
[13:20:04.758]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.758]                       if (muffled) 
[13:20:04.758]                         invokeRestart("muffleMessage")
[13:20:04.758]                     }
[13:20:04.758]                     else if (inherits(cond, "warning")) {
[13:20:04.758]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.758]                       if (muffled) 
[13:20:04.758]                         invokeRestart("muffleWarning")
[13:20:04.758]                     }
[13:20:04.758]                     else if (inherits(cond, "condition")) {
[13:20:04.758]                       if (!is.null(pattern)) {
[13:20:04.758]                         computeRestarts <- base::computeRestarts
[13:20:04.758]                         grepl <- base::grepl
[13:20:04.758]                         restarts <- computeRestarts(cond)
[13:20:04.758]                         for (restart in restarts) {
[13:20:04.758]                           name <- restart$name
[13:20:04.758]                           if (is.null(name)) 
[13:20:04.758]                             next
[13:20:04.758]                           if (!grepl(pattern, name)) 
[13:20:04.758]                             next
[13:20:04.758]                           invokeRestart(restart)
[13:20:04.758]                           muffled <- TRUE
[13:20:04.758]                           break
[13:20:04.758]                         }
[13:20:04.758]                       }
[13:20:04.758]                     }
[13:20:04.758]                     invisible(muffled)
[13:20:04.758]                   }
[13:20:04.758]                   muffleCondition(cond)
[13:20:04.758]                 })
[13:20:04.758]             }))
[13:20:04.758]             future::FutureResult(value = ...future.value$value, 
[13:20:04.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.758]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.758]                     ...future.globalenv.names))
[13:20:04.758]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.758]         }, condition = base::local({
[13:20:04.758]             c <- base::c
[13:20:04.758]             inherits <- base::inherits
[13:20:04.758]             invokeRestart <- base::invokeRestart
[13:20:04.758]             length <- base::length
[13:20:04.758]             list <- base::list
[13:20:04.758]             seq.int <- base::seq.int
[13:20:04.758]             signalCondition <- base::signalCondition
[13:20:04.758]             sys.calls <- base::sys.calls
[13:20:04.758]             `[[` <- base::`[[`
[13:20:04.758]             `+` <- base::`+`
[13:20:04.758]             `<<-` <- base::`<<-`
[13:20:04.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.758]                   3L)]
[13:20:04.758]             }
[13:20:04.758]             function(cond) {
[13:20:04.758]                 is_error <- inherits(cond, "error")
[13:20:04.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.758]                   NULL)
[13:20:04.758]                 if (is_error) {
[13:20:04.758]                   sessionInformation <- function() {
[13:20:04.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.758]                       search = base::search(), system = base::Sys.info())
[13:20:04.758]                   }
[13:20:04.758]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.758]                     cond$call), session = sessionInformation(), 
[13:20:04.758]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.758]                   signalCondition(cond)
[13:20:04.758]                 }
[13:20:04.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.758]                 "immediateCondition"))) {
[13:20:04.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.758]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.758]                   if (TRUE && !signal) {
[13:20:04.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.758]                     {
[13:20:04.758]                       inherits <- base::inherits
[13:20:04.758]                       invokeRestart <- base::invokeRestart
[13:20:04.758]                       is.null <- base::is.null
[13:20:04.758]                       muffled <- FALSE
[13:20:04.758]                       if (inherits(cond, "message")) {
[13:20:04.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.758]                         if (muffled) 
[13:20:04.758]                           invokeRestart("muffleMessage")
[13:20:04.758]                       }
[13:20:04.758]                       else if (inherits(cond, "warning")) {
[13:20:04.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.758]                         if (muffled) 
[13:20:04.758]                           invokeRestart("muffleWarning")
[13:20:04.758]                       }
[13:20:04.758]                       else if (inherits(cond, "condition")) {
[13:20:04.758]                         if (!is.null(pattern)) {
[13:20:04.758]                           computeRestarts <- base::computeRestarts
[13:20:04.758]                           grepl <- base::grepl
[13:20:04.758]                           restarts <- computeRestarts(cond)
[13:20:04.758]                           for (restart in restarts) {
[13:20:04.758]                             name <- restart$name
[13:20:04.758]                             if (is.null(name)) 
[13:20:04.758]                               next
[13:20:04.758]                             if (!grepl(pattern, name)) 
[13:20:04.758]                               next
[13:20:04.758]                             invokeRestart(restart)
[13:20:04.758]                             muffled <- TRUE
[13:20:04.758]                             break
[13:20:04.758]                           }
[13:20:04.758]                         }
[13:20:04.758]                       }
[13:20:04.758]                       invisible(muffled)
[13:20:04.758]                     }
[13:20:04.758]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.758]                   }
[13:20:04.758]                 }
[13:20:04.758]                 else {
[13:20:04.758]                   if (TRUE) {
[13:20:04.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.758]                     {
[13:20:04.758]                       inherits <- base::inherits
[13:20:04.758]                       invokeRestart <- base::invokeRestart
[13:20:04.758]                       is.null <- base::is.null
[13:20:04.758]                       muffled <- FALSE
[13:20:04.758]                       if (inherits(cond, "message")) {
[13:20:04.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.758]                         if (muffled) 
[13:20:04.758]                           invokeRestart("muffleMessage")
[13:20:04.758]                       }
[13:20:04.758]                       else if (inherits(cond, "warning")) {
[13:20:04.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.758]                         if (muffled) 
[13:20:04.758]                           invokeRestart("muffleWarning")
[13:20:04.758]                       }
[13:20:04.758]                       else if (inherits(cond, "condition")) {
[13:20:04.758]                         if (!is.null(pattern)) {
[13:20:04.758]                           computeRestarts <- base::computeRestarts
[13:20:04.758]                           grepl <- base::grepl
[13:20:04.758]                           restarts <- computeRestarts(cond)
[13:20:04.758]                           for (restart in restarts) {
[13:20:04.758]                             name <- restart$name
[13:20:04.758]                             if (is.null(name)) 
[13:20:04.758]                               next
[13:20:04.758]                             if (!grepl(pattern, name)) 
[13:20:04.758]                               next
[13:20:04.758]                             invokeRestart(restart)
[13:20:04.758]                             muffled <- TRUE
[13:20:04.758]                             break
[13:20:04.758]                           }
[13:20:04.758]                         }
[13:20:04.758]                       }
[13:20:04.758]                       invisible(muffled)
[13:20:04.758]                     }
[13:20:04.758]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.758]                   }
[13:20:04.758]                 }
[13:20:04.758]             }
[13:20:04.758]         }))
[13:20:04.758]     }, error = function(ex) {
[13:20:04.758]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.758]                 ...future.rng), started = ...future.startTime, 
[13:20:04.758]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.758]             version = "1.8"), class = "FutureResult")
[13:20:04.758]     }, finally = {
[13:20:04.758]         if (!identical(...future.workdir, getwd())) 
[13:20:04.758]             setwd(...future.workdir)
[13:20:04.758]         {
[13:20:04.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.758]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.758]             }
[13:20:04.758]             base::options(...future.oldOptions)
[13:20:04.758]             if (.Platform$OS.type == "windows") {
[13:20:04.758]                 old_names <- names(...future.oldEnvVars)
[13:20:04.758]                 envs <- base::Sys.getenv()
[13:20:04.758]                 names <- names(envs)
[13:20:04.758]                 common <- intersect(names, old_names)
[13:20:04.758]                 added <- setdiff(names, old_names)
[13:20:04.758]                 removed <- setdiff(old_names, names)
[13:20:04.758]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.758]                   envs[common]]
[13:20:04.758]                 NAMES <- toupper(changed)
[13:20:04.758]                 args <- list()
[13:20:04.758]                 for (kk in seq_along(NAMES)) {
[13:20:04.758]                   name <- changed[[kk]]
[13:20:04.758]                   NAME <- NAMES[[kk]]
[13:20:04.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.758]                     next
[13:20:04.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.758]                 }
[13:20:04.758]                 NAMES <- toupper(added)
[13:20:04.758]                 for (kk in seq_along(NAMES)) {
[13:20:04.758]                   name <- added[[kk]]
[13:20:04.758]                   NAME <- NAMES[[kk]]
[13:20:04.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.758]                     next
[13:20:04.758]                   args[[name]] <- ""
[13:20:04.758]                 }
[13:20:04.758]                 NAMES <- toupper(removed)
[13:20:04.758]                 for (kk in seq_along(NAMES)) {
[13:20:04.758]                   name <- removed[[kk]]
[13:20:04.758]                   NAME <- NAMES[[kk]]
[13:20:04.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.758]                     next
[13:20:04.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.758]                 }
[13:20:04.758]                 if (length(args) > 0) 
[13:20:04.758]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.758]             }
[13:20:04.758]             else {
[13:20:04.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.758]             }
[13:20:04.758]             {
[13:20:04.758]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.758]                   0L) {
[13:20:04.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.758]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.758]                   base::options(opts)
[13:20:04.758]                 }
[13:20:04.758]                 {
[13:20:04.758]                   {
[13:20:04.758]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.758]                     NULL
[13:20:04.758]                   }
[13:20:04.758]                   options(future.plan = NULL)
[13:20:04.758]                   if (is.na(NA_character_)) 
[13:20:04.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.758]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.758]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.758]                     envir = parent.frame()) 
[13:20:04.758]                   {
[13:20:04.758]                     if (is.function(workers)) 
[13:20:04.758]                       workers <- workers()
[13:20:04.758]                     workers <- structure(as.integer(workers), 
[13:20:04.758]                       class = class(workers))
[13:20:04.758]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.758]                       workers >= 1)
[13:20:04.758]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.758]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.758]                     }
[13:20:04.758]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.758]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.758]                       envir = envir)
[13:20:04.758]                     if (!future$lazy) 
[13:20:04.758]                       future <- run(future)
[13:20:04.758]                     invisible(future)
[13:20:04.758]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.758]                 }
[13:20:04.758]             }
[13:20:04.758]         }
[13:20:04.758]     })
[13:20:04.758]     if (TRUE) {
[13:20:04.758]         base::sink(type = "output", split = FALSE)
[13:20:04.758]         if (TRUE) {
[13:20:04.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.758]         }
[13:20:04.758]         else {
[13:20:04.758]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.758]         }
[13:20:04.758]         base::close(...future.stdout)
[13:20:04.758]         ...future.stdout <- NULL
[13:20:04.758]     }
[13:20:04.758]     ...future.result$conditions <- ...future.conditions
[13:20:04.758]     ...future.result$finished <- base::Sys.time()
[13:20:04.758]     ...future.result
[13:20:04.758] }
[13:20:04.761] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[13:20:04.762] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:20:04.762] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:20:04.762] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[13:20:04.762] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[13:20:04.763] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[13:20:04.763] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[13:20:04.763] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:04.763] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.763] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:04.764] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.764] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[13:20:04.764] MultisessionFuture started
[13:20:04.765] - Launch lazy future ... done
[13:20:04.765] run() for ‘MultisessionFuture’ ... done
[13:20:04.765] Created future:
[13:20:04.765] MultisessionFuture:
[13:20:04.765] Label: ‘future_by-2’
[13:20:04.765] Expression:
[13:20:04.765] {
[13:20:04.765]     do.call(function(...) {
[13:20:04.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.765]             on.exit(options(oopts), add = TRUE)
[13:20:04.765]         }
[13:20:04.765]         {
[13:20:04.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.765]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.765]             })
[13:20:04.765]         }
[13:20:04.765]     }, args = future.call.arguments)
[13:20:04.765] }
[13:20:04.765] Lazy evaluation: FALSE
[13:20:04.765] Asynchronous evaluation: TRUE
[13:20:04.765] Local evaluation: TRUE
[13:20:04.765] Environment: R_GlobalEnv
[13:20:04.765] Capture standard output: TRUE
[13:20:04.765] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:04.765] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:04.765] Packages: <none>
[13:20:04.765] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:04.765] Resolved: FALSE
[13:20:04.765] Value: <not collected>
[13:20:04.765] Conditions captured: <none>
[13:20:04.765] Early signaling: FALSE
[13:20:04.765] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:04.765] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.777] Chunk #2 of 2 ... DONE
[13:20:04.777] Launching 2 futures (chunks) ... DONE
[13:20:04.777] Resolving 2 futures (chunks) ...
[13:20:04.777] resolve() on list ...
[13:20:04.777]  recursive: 0
[13:20:04.777]  length: 2
[13:20:04.777] 
[13:20:04.778] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.778] - Validating connection of MultisessionFuture
[13:20:04.778] - received message: FutureResult
[13:20:04.778] - Received FutureResult
[13:20:04.778] - Erased future from FutureRegistry
[13:20:04.778] result() for ClusterFuture ...
[13:20:04.779] - result already collected: FutureResult
[13:20:04.779] result() for ClusterFuture ... done
[13:20:04.779] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.779] Future #1
[13:20:04.779] result() for ClusterFuture ...
[13:20:04.779] - result already collected: FutureResult
[13:20:04.779] result() for ClusterFuture ... done
[13:20:04.779] result() for ClusterFuture ...
[13:20:04.779] - result already collected: FutureResult
[13:20:04.779] result() for ClusterFuture ... done
[13:20:04.779] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:04.779] - nx: 2
[13:20:04.780] - relay: TRUE
[13:20:04.780] - stdout: TRUE
[13:20:04.780] - signal: TRUE
[13:20:04.780] - resignal: FALSE
[13:20:04.780] - force: TRUE
[13:20:04.780] - relayed: [n=2] FALSE, FALSE
[13:20:04.780] - queued futures: [n=2] FALSE, FALSE
[13:20:04.780]  - until=1
[13:20:04.780]  - relaying element #1
[13:20:04.780] result() for ClusterFuture ...
[13:20:04.780] - result already collected: FutureResult
[13:20:04.781] result() for ClusterFuture ... done
[13:20:04.781] result() for ClusterFuture ...
[13:20:04.781] - result already collected: FutureResult
[13:20:04.781] result() for ClusterFuture ... done
[13:20:04.781] result() for ClusterFuture ...
[13:20:04.781] - result already collected: FutureResult
[13:20:04.781] result() for ClusterFuture ... done
[13:20:04.781] result() for ClusterFuture ...
[13:20:04.781] - result already collected: FutureResult
[13:20:04.781] result() for ClusterFuture ... done
[13:20:04.781] - relayed: [n=2] TRUE, FALSE
[13:20:04.782] - queued futures: [n=2] TRUE, FALSE
[13:20:04.782] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:04.782]  length: 1 (resolved future 1)
[13:20:04.824] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.824] - Validating connection of MultisessionFuture
[13:20:04.824] - received message: FutureResult
[13:20:04.824] - Received FutureResult
[13:20:04.825] - Erased future from FutureRegistry
[13:20:04.825] result() for ClusterFuture ...
[13:20:04.825] - result already collected: FutureResult
[13:20:04.825] result() for ClusterFuture ... done
[13:20:04.825] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.825] Future #2
[13:20:04.825] result() for ClusterFuture ...
[13:20:04.825] - result already collected: FutureResult
[13:20:04.825] result() for ClusterFuture ... done
[13:20:04.825] result() for ClusterFuture ...
[13:20:04.825] - result already collected: FutureResult
[13:20:04.826] result() for ClusterFuture ... done
[13:20:04.826] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:04.826] - nx: 2
[13:20:04.826] - relay: TRUE
[13:20:04.826] - stdout: TRUE
[13:20:04.826] - signal: TRUE
[13:20:04.826] - resignal: FALSE
[13:20:04.826] - force: TRUE
[13:20:04.826] - relayed: [n=2] TRUE, FALSE
[13:20:04.826] - queued futures: [n=2] TRUE, FALSE
[13:20:04.826]  - until=2
[13:20:04.826]  - relaying element #2
[13:20:04.827] result() for ClusterFuture ...
[13:20:04.827] - result already collected: FutureResult
[13:20:04.827] result() for ClusterFuture ... done
[13:20:04.827] result() for ClusterFuture ...
[13:20:04.827] - result already collected: FutureResult
[13:20:04.827] result() for ClusterFuture ... done
[13:20:04.827] result() for ClusterFuture ...
[13:20:04.827] - result already collected: FutureResult
[13:20:04.827] result() for ClusterFuture ... done
[13:20:04.827] result() for ClusterFuture ...
[13:20:04.827] - result already collected: FutureResult
[13:20:04.828] result() for ClusterFuture ... done
[13:20:04.828] - relayed: [n=2] TRUE, TRUE
[13:20:04.828] - queued futures: [n=2] TRUE, TRUE
[13:20:04.828] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:04.828]  length: 0 (resolved future 2)
[13:20:04.828] Relaying remaining futures
[13:20:04.828] signalConditionsASAP(NULL, pos=0) ...
[13:20:04.828] - nx: 2
[13:20:04.828] - relay: TRUE
[13:20:04.828] - stdout: TRUE
[13:20:04.828] - signal: TRUE
[13:20:04.829] - resignal: FALSE
[13:20:04.829] - force: TRUE
[13:20:04.829] - relayed: [n=2] TRUE, TRUE
[13:20:04.829] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:04.829] - relayed: [n=2] TRUE, TRUE
[13:20:04.829] - queued futures: [n=2] TRUE, TRUE
[13:20:04.829] signalConditionsASAP(NULL, pos=0) ... done
[13:20:04.829] resolve() on list ... DONE
[13:20:04.829] result() for ClusterFuture ...
[13:20:04.829] - result already collected: FutureResult
[13:20:04.829] result() for ClusterFuture ... done
[13:20:04.830] result() for ClusterFuture ...
[13:20:04.830] - result already collected: FutureResult
[13:20:04.830] result() for ClusterFuture ... done
[13:20:04.830] result() for ClusterFuture ...
[13:20:04.830] - result already collected: FutureResult
[13:20:04.830] result() for ClusterFuture ... done
[13:20:04.830] result() for ClusterFuture ...
[13:20:04.830] - result already collected: FutureResult
[13:20:04.830] result() for ClusterFuture ... done
[13:20:04.830]  - Number of value chunks collected: 2
[13:20:04.831] Resolving 2 futures (chunks) ... DONE
[13:20:04.831] Reducing values from 2 chunks ...
[13:20:04.831]  - Number of values collected after concatenation: 6
[13:20:04.831]  - Number of values expected: 6
[13:20:04.831] Reducing values from 2 chunks ... DONE
[13:20:04.831] future_lapply() ... DONE
[13:20:04.831] future_by_internal() ... DONE
[13:20:04.832] future_by_internal() ...
[13:20:04.833] future_lapply() ...
[13:20:04.837] Number of chunks: 2
[13:20:04.838] getGlobalsAndPackagesXApply() ...
[13:20:04.838]  - future.globals: TRUE
[13:20:04.838] getGlobalsAndPackages() ...
[13:20:04.838] Searching for globals...
[13:20:04.840] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:04.840] Searching for globals ... DONE
[13:20:04.840] Resolving globals: FALSE
[13:20:04.840] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:20:04.841] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:20:04.841] - globals: [1] ‘FUN’
[13:20:04.841] - packages: [1] ‘stats’
[13:20:04.841] getGlobalsAndPackages() ... DONE
[13:20:04.841]  - globals found/used: [n=1] ‘FUN’
[13:20:04.841]  - needed namespaces: [n=1] ‘stats’
[13:20:04.841] Finding globals ... DONE
[13:20:04.842]  - use_args: TRUE
[13:20:04.842]  - Getting '...' globals ...
[13:20:04.842] resolve() on list ...
[13:20:04.842]  recursive: 0
[13:20:04.842]  length: 1
[13:20:04.842]  elements: ‘...’
[13:20:04.842]  length: 0 (resolved future 1)
[13:20:04.842] resolve() on list ... DONE
[13:20:04.843]    - '...' content: [n=1] ‘singular.ok’
[13:20:04.843] List of 1
[13:20:04.843]  $ ...:List of 1
[13:20:04.843]   ..$ singular.ok: logi FALSE
[13:20:04.843]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.843]  - attr(*, "where")=List of 1
[13:20:04.843]   ..$ ...:<environment: 0x55acee9dd5d0> 
[13:20:04.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.843]  - attr(*, "resolved")= logi TRUE
[13:20:04.843]  - attr(*, "total_size")= num NA
[13:20:04.848]  - Getting '...' globals ... DONE
[13:20:04.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:04.848] List of 2
[13:20:04.848]  $ ...future.FUN:function (x, ...)  
[13:20:04.848]  $ ...          :List of 1
[13:20:04.848]   ..$ singular.ok: logi FALSE
[13:20:04.848]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.848]  - attr(*, "where")=List of 2
[13:20:04.848]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:04.848]   ..$ ...          :<environment: 0x55acee9dd5d0> 
[13:20:04.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.848]  - attr(*, "resolved")= logi FALSE
[13:20:04.848]  - attr(*, "total_size")= num 5384
[13:20:04.851] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:04.851] getGlobalsAndPackagesXApply() ... DONE
[13:20:04.851] Number of futures (= number of chunks): 2
[13:20:04.851] Launching 2 futures (chunks) ...
[13:20:04.851] Chunk #1 of 2 ...
[13:20:04.852]  - Finding globals in 'X' for chunk #1 ...
[13:20:04.852] getGlobalsAndPackages() ...
[13:20:04.852] Searching for globals...
[13:20:04.852] 
[13:20:04.852] Searching for globals ... DONE
[13:20:04.852] - globals: [0] <none>
[13:20:04.852] getGlobalsAndPackages() ... DONE
[13:20:04.852]    + additional globals found: [n=0] 
[13:20:04.853]    + additional namespaces needed: [n=0] 
[13:20:04.853]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:04.853]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:04.853]  - seeds: <none>
[13:20:04.853]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.853] getGlobalsAndPackages() ...
[13:20:04.853] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.853] Resolving globals: FALSE
[13:20:04.853] Tweak future expression to call with '...' arguments ...
[13:20:04.853] {
[13:20:04.853]     do.call(function(...) {
[13:20:04.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.853]             on.exit(options(oopts), add = TRUE)
[13:20:04.853]         }
[13:20:04.853]         {
[13:20:04.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.853]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.853]             })
[13:20:04.853]         }
[13:20:04.853]     }, args = future.call.arguments)
[13:20:04.853] }
[13:20:04.854] Tweak future expression to call with '...' arguments ... DONE
[13:20:04.854] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.854] 
[13:20:04.854] getGlobalsAndPackages() ... DONE
[13:20:04.854] run() for ‘Future’ ...
[13:20:04.855] - state: ‘created’
[13:20:04.855] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:04.869] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.869] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:04.869]   - Field: ‘node’
[13:20:04.869]   - Field: ‘label’
[13:20:04.869]   - Field: ‘local’
[13:20:04.869]   - Field: ‘owner’
[13:20:04.869]   - Field: ‘envir’
[13:20:04.869]   - Field: ‘workers’
[13:20:04.869]   - Field: ‘packages’
[13:20:04.869]   - Field: ‘gc’
[13:20:04.870]   - Field: ‘conditions’
[13:20:04.870]   - Field: ‘persistent’
[13:20:04.870]   - Field: ‘expr’
[13:20:04.870]   - Field: ‘uuid’
[13:20:04.870]   - Field: ‘seed’
[13:20:04.870]   - Field: ‘version’
[13:20:04.870]   - Field: ‘result’
[13:20:04.870]   - Field: ‘asynchronous’
[13:20:04.870]   - Field: ‘calls’
[13:20:04.870]   - Field: ‘globals’
[13:20:04.870]   - Field: ‘stdout’
[13:20:04.871]   - Field: ‘earlySignal’
[13:20:04.871]   - Field: ‘lazy’
[13:20:04.871]   - Field: ‘state’
[13:20:04.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:04.871] - Launch lazy future ...
[13:20:04.871] Packages needed by the future expression (n = 1): ‘stats’
[13:20:04.871] Packages needed by future strategies (n = 0): <none>
[13:20:04.872] {
[13:20:04.872]     {
[13:20:04.872]         {
[13:20:04.872]             ...future.startTime <- base::Sys.time()
[13:20:04.872]             {
[13:20:04.872]                 {
[13:20:04.872]                   {
[13:20:04.872]                     {
[13:20:04.872]                       {
[13:20:04.872]                         base::local({
[13:20:04.872]                           has_future <- base::requireNamespace("future", 
[13:20:04.872]                             quietly = TRUE)
[13:20:04.872]                           if (has_future) {
[13:20:04.872]                             ns <- base::getNamespace("future")
[13:20:04.872]                             version <- ns[[".package"]][["version"]]
[13:20:04.872]                             if (is.null(version)) 
[13:20:04.872]                               version <- utils::packageVersion("future")
[13:20:04.872]                           }
[13:20:04.872]                           else {
[13:20:04.872]                             version <- NULL
[13:20:04.872]                           }
[13:20:04.872]                           if (!has_future || version < "1.8.0") {
[13:20:04.872]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.872]                               "", base::R.version$version.string), 
[13:20:04.872]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:04.872]                                 base::R.version$platform, 8 * 
[13:20:04.872]                                   base::.Machine$sizeof.pointer), 
[13:20:04.872]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.872]                                 "release", "version")], collapse = " "), 
[13:20:04.872]                               hostname = base::Sys.info()[["nodename"]])
[13:20:04.872]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.872]                               info)
[13:20:04.872]                             info <- base::paste(info, collapse = "; ")
[13:20:04.872]                             if (!has_future) {
[13:20:04.872]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.872]                                 info)
[13:20:04.872]                             }
[13:20:04.872]                             else {
[13:20:04.872]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.872]                                 info, version)
[13:20:04.872]                             }
[13:20:04.872]                             base::stop(msg)
[13:20:04.872]                           }
[13:20:04.872]                         })
[13:20:04.872]                       }
[13:20:04.872]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.872]                       base::options(mc.cores = 1L)
[13:20:04.872]                     }
[13:20:04.872]                     base::local({
[13:20:04.872]                       for (pkg in "stats") {
[13:20:04.872]                         base::loadNamespace(pkg)
[13:20:04.872]                         base::library(pkg, character.only = TRUE)
[13:20:04.872]                       }
[13:20:04.872]                     })
[13:20:04.872]                   }
[13:20:04.872]                   options(future.plan = NULL)
[13:20:04.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.872]                 }
[13:20:04.872]                 ...future.workdir <- getwd()
[13:20:04.872]             }
[13:20:04.872]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.872]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.872]         }
[13:20:04.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.872]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:04.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.872]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.872]             base::names(...future.oldOptions))
[13:20:04.872]     }
[13:20:04.872]     if (FALSE) {
[13:20:04.872]     }
[13:20:04.872]     else {
[13:20:04.872]         if (TRUE) {
[13:20:04.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.872]                 open = "w")
[13:20:04.872]         }
[13:20:04.872]         else {
[13:20:04.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.872]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.872]         }
[13:20:04.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.872]             base::sink(type = "output", split = FALSE)
[13:20:04.872]             base::close(...future.stdout)
[13:20:04.872]         }, add = TRUE)
[13:20:04.872]     }
[13:20:04.872]     ...future.frame <- base::sys.nframe()
[13:20:04.872]     ...future.conditions <- base::list()
[13:20:04.872]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.872]     if (FALSE) {
[13:20:04.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.872]     }
[13:20:04.872]     ...future.result <- base::tryCatch({
[13:20:04.872]         base::withCallingHandlers({
[13:20:04.872]             ...future.value <- base::withVisible(base::local({
[13:20:04.872]                 ...future.makeSendCondition <- base::local({
[13:20:04.872]                   sendCondition <- NULL
[13:20:04.872]                   function(frame = 1L) {
[13:20:04.872]                     if (is.function(sendCondition)) 
[13:20:04.872]                       return(sendCondition)
[13:20:04.872]                     ns <- getNamespace("parallel")
[13:20:04.872]                     if (exists("sendData", mode = "function", 
[13:20:04.872]                       envir = ns)) {
[13:20:04.872]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.872]                         envir = ns)
[13:20:04.872]                       envir <- sys.frame(frame)
[13:20:04.872]                       master <- NULL
[13:20:04.872]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.872]                         !identical(envir, emptyenv())) {
[13:20:04.872]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.872]                           inherits = FALSE)) {
[13:20:04.872]                           master <- get("master", mode = "list", 
[13:20:04.872]                             envir = envir, inherits = FALSE)
[13:20:04.872]                           if (inherits(master, c("SOCKnode", 
[13:20:04.872]                             "SOCK0node"))) {
[13:20:04.872]                             sendCondition <<- function(cond) {
[13:20:04.872]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.872]                                 success = TRUE)
[13:20:04.872]                               parallel_sendData(master, data)
[13:20:04.872]                             }
[13:20:04.872]                             return(sendCondition)
[13:20:04.872]                           }
[13:20:04.872]                         }
[13:20:04.872]                         frame <- frame + 1L
[13:20:04.872]                         envir <- sys.frame(frame)
[13:20:04.872]                       }
[13:20:04.872]                     }
[13:20:04.872]                     sendCondition <<- function(cond) NULL
[13:20:04.872]                   }
[13:20:04.872]                 })
[13:20:04.872]                 withCallingHandlers({
[13:20:04.872]                   {
[13:20:04.872]                     do.call(function(...) {
[13:20:04.872]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.872]                       if (!identical(...future.globals.maxSize.org, 
[13:20:04.872]                         ...future.globals.maxSize)) {
[13:20:04.872]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.872]                         on.exit(options(oopts), add = TRUE)
[13:20:04.872]                       }
[13:20:04.872]                       {
[13:20:04.872]                         lapply(seq_along(...future.elements_ii), 
[13:20:04.872]                           FUN = function(jj) {
[13:20:04.872]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.872]                             ...future.FUN(...future.X_jj, ...)
[13:20:04.872]                           })
[13:20:04.872]                       }
[13:20:04.872]                     }, args = future.call.arguments)
[13:20:04.872]                   }
[13:20:04.872]                 }, immediateCondition = function(cond) {
[13:20:04.872]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.872]                   sendCondition(cond)
[13:20:04.872]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.872]                   {
[13:20:04.872]                     inherits <- base::inherits
[13:20:04.872]                     invokeRestart <- base::invokeRestart
[13:20:04.872]                     is.null <- base::is.null
[13:20:04.872]                     muffled <- FALSE
[13:20:04.872]                     if (inherits(cond, "message")) {
[13:20:04.872]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.872]                       if (muffled) 
[13:20:04.872]                         invokeRestart("muffleMessage")
[13:20:04.872]                     }
[13:20:04.872]                     else if (inherits(cond, "warning")) {
[13:20:04.872]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.872]                       if (muffled) 
[13:20:04.872]                         invokeRestart("muffleWarning")
[13:20:04.872]                     }
[13:20:04.872]                     else if (inherits(cond, "condition")) {
[13:20:04.872]                       if (!is.null(pattern)) {
[13:20:04.872]                         computeRestarts <- base::computeRestarts
[13:20:04.872]                         grepl <- base::grepl
[13:20:04.872]                         restarts <- computeRestarts(cond)
[13:20:04.872]                         for (restart in restarts) {
[13:20:04.872]                           name <- restart$name
[13:20:04.872]                           if (is.null(name)) 
[13:20:04.872]                             next
[13:20:04.872]                           if (!grepl(pattern, name)) 
[13:20:04.872]                             next
[13:20:04.872]                           invokeRestart(restart)
[13:20:04.872]                           muffled <- TRUE
[13:20:04.872]                           break
[13:20:04.872]                         }
[13:20:04.872]                       }
[13:20:04.872]                     }
[13:20:04.872]                     invisible(muffled)
[13:20:04.872]                   }
[13:20:04.872]                   muffleCondition(cond)
[13:20:04.872]                 })
[13:20:04.872]             }))
[13:20:04.872]             future::FutureResult(value = ...future.value$value, 
[13:20:04.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.872]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.872]                     ...future.globalenv.names))
[13:20:04.872]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.872]         }, condition = base::local({
[13:20:04.872]             c <- base::c
[13:20:04.872]             inherits <- base::inherits
[13:20:04.872]             invokeRestart <- base::invokeRestart
[13:20:04.872]             length <- base::length
[13:20:04.872]             list <- base::list
[13:20:04.872]             seq.int <- base::seq.int
[13:20:04.872]             signalCondition <- base::signalCondition
[13:20:04.872]             sys.calls <- base::sys.calls
[13:20:04.872]             `[[` <- base::`[[`
[13:20:04.872]             `+` <- base::`+`
[13:20:04.872]             `<<-` <- base::`<<-`
[13:20:04.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.872]                   3L)]
[13:20:04.872]             }
[13:20:04.872]             function(cond) {
[13:20:04.872]                 is_error <- inherits(cond, "error")
[13:20:04.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.872]                   NULL)
[13:20:04.872]                 if (is_error) {
[13:20:04.872]                   sessionInformation <- function() {
[13:20:04.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.872]                       search = base::search(), system = base::Sys.info())
[13:20:04.872]                   }
[13:20:04.872]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.872]                     cond$call), session = sessionInformation(), 
[13:20:04.872]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.872]                   signalCondition(cond)
[13:20:04.872]                 }
[13:20:04.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.872]                 "immediateCondition"))) {
[13:20:04.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.872]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.872]                   if (TRUE && !signal) {
[13:20:04.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.872]                     {
[13:20:04.872]                       inherits <- base::inherits
[13:20:04.872]                       invokeRestart <- base::invokeRestart
[13:20:04.872]                       is.null <- base::is.null
[13:20:04.872]                       muffled <- FALSE
[13:20:04.872]                       if (inherits(cond, "message")) {
[13:20:04.872]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.872]                         if (muffled) 
[13:20:04.872]                           invokeRestart("muffleMessage")
[13:20:04.872]                       }
[13:20:04.872]                       else if (inherits(cond, "warning")) {
[13:20:04.872]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.872]                         if (muffled) 
[13:20:04.872]                           invokeRestart("muffleWarning")
[13:20:04.872]                       }
[13:20:04.872]                       else if (inherits(cond, "condition")) {
[13:20:04.872]                         if (!is.null(pattern)) {
[13:20:04.872]                           computeRestarts <- base::computeRestarts
[13:20:04.872]                           grepl <- base::grepl
[13:20:04.872]                           restarts <- computeRestarts(cond)
[13:20:04.872]                           for (restart in restarts) {
[13:20:04.872]                             name <- restart$name
[13:20:04.872]                             if (is.null(name)) 
[13:20:04.872]                               next
[13:20:04.872]                             if (!grepl(pattern, name)) 
[13:20:04.872]                               next
[13:20:04.872]                             invokeRestart(restart)
[13:20:04.872]                             muffled <- TRUE
[13:20:04.872]                             break
[13:20:04.872]                           }
[13:20:04.872]                         }
[13:20:04.872]                       }
[13:20:04.872]                       invisible(muffled)
[13:20:04.872]                     }
[13:20:04.872]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.872]                   }
[13:20:04.872]                 }
[13:20:04.872]                 else {
[13:20:04.872]                   if (TRUE) {
[13:20:04.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.872]                     {
[13:20:04.872]                       inherits <- base::inherits
[13:20:04.872]                       invokeRestart <- base::invokeRestart
[13:20:04.872]                       is.null <- base::is.null
[13:20:04.872]                       muffled <- FALSE
[13:20:04.872]                       if (inherits(cond, "message")) {
[13:20:04.872]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.872]                         if (muffled) 
[13:20:04.872]                           invokeRestart("muffleMessage")
[13:20:04.872]                       }
[13:20:04.872]                       else if (inherits(cond, "warning")) {
[13:20:04.872]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.872]                         if (muffled) 
[13:20:04.872]                           invokeRestart("muffleWarning")
[13:20:04.872]                       }
[13:20:04.872]                       else if (inherits(cond, "condition")) {
[13:20:04.872]                         if (!is.null(pattern)) {
[13:20:04.872]                           computeRestarts <- base::computeRestarts
[13:20:04.872]                           grepl <- base::grepl
[13:20:04.872]                           restarts <- computeRestarts(cond)
[13:20:04.872]                           for (restart in restarts) {
[13:20:04.872]                             name <- restart$name
[13:20:04.872]                             if (is.null(name)) 
[13:20:04.872]                               next
[13:20:04.872]                             if (!grepl(pattern, name)) 
[13:20:04.872]                               next
[13:20:04.872]                             invokeRestart(restart)
[13:20:04.872]                             muffled <- TRUE
[13:20:04.872]                             break
[13:20:04.872]                           }
[13:20:04.872]                         }
[13:20:04.872]                       }
[13:20:04.872]                       invisible(muffled)
[13:20:04.872]                     }
[13:20:04.872]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.872]                   }
[13:20:04.872]                 }
[13:20:04.872]             }
[13:20:04.872]         }))
[13:20:04.872]     }, error = function(ex) {
[13:20:04.872]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.872]                 ...future.rng), started = ...future.startTime, 
[13:20:04.872]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.872]             version = "1.8"), class = "FutureResult")
[13:20:04.872]     }, finally = {
[13:20:04.872]         if (!identical(...future.workdir, getwd())) 
[13:20:04.872]             setwd(...future.workdir)
[13:20:04.872]         {
[13:20:04.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.872]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.872]             }
[13:20:04.872]             base::options(...future.oldOptions)
[13:20:04.872]             if (.Platform$OS.type == "windows") {
[13:20:04.872]                 old_names <- names(...future.oldEnvVars)
[13:20:04.872]                 envs <- base::Sys.getenv()
[13:20:04.872]                 names <- names(envs)
[13:20:04.872]                 common <- intersect(names, old_names)
[13:20:04.872]                 added <- setdiff(names, old_names)
[13:20:04.872]                 removed <- setdiff(old_names, names)
[13:20:04.872]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.872]                   envs[common]]
[13:20:04.872]                 NAMES <- toupper(changed)
[13:20:04.872]                 args <- list()
[13:20:04.872]                 for (kk in seq_along(NAMES)) {
[13:20:04.872]                   name <- changed[[kk]]
[13:20:04.872]                   NAME <- NAMES[[kk]]
[13:20:04.872]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.872]                     next
[13:20:04.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.872]                 }
[13:20:04.872]                 NAMES <- toupper(added)
[13:20:04.872]                 for (kk in seq_along(NAMES)) {
[13:20:04.872]                   name <- added[[kk]]
[13:20:04.872]                   NAME <- NAMES[[kk]]
[13:20:04.872]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.872]                     next
[13:20:04.872]                   args[[name]] <- ""
[13:20:04.872]                 }
[13:20:04.872]                 NAMES <- toupper(removed)
[13:20:04.872]                 for (kk in seq_along(NAMES)) {
[13:20:04.872]                   name <- removed[[kk]]
[13:20:04.872]                   NAME <- NAMES[[kk]]
[13:20:04.872]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.872]                     next
[13:20:04.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.872]                 }
[13:20:04.872]                 if (length(args) > 0) 
[13:20:04.872]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.872]             }
[13:20:04.872]             else {
[13:20:04.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.872]             }
[13:20:04.872]             {
[13:20:04.872]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.872]                   0L) {
[13:20:04.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.872]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.872]                   base::options(opts)
[13:20:04.872]                 }
[13:20:04.872]                 {
[13:20:04.872]                   {
[13:20:04.872]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.872]                     NULL
[13:20:04.872]                   }
[13:20:04.872]                   options(future.plan = NULL)
[13:20:04.872]                   if (is.na(NA_character_)) 
[13:20:04.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.872]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.872]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.872]                     envir = parent.frame()) 
[13:20:04.872]                   {
[13:20:04.872]                     if (is.function(workers)) 
[13:20:04.872]                       workers <- workers()
[13:20:04.872]                     workers <- structure(as.integer(workers), 
[13:20:04.872]                       class = class(workers))
[13:20:04.872]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.872]                       workers >= 1)
[13:20:04.872]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.872]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.872]                     }
[13:20:04.872]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.872]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.872]                       envir = envir)
[13:20:04.872]                     if (!future$lazy) 
[13:20:04.872]                       future <- run(future)
[13:20:04.872]                     invisible(future)
[13:20:04.872]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.872]                 }
[13:20:04.872]             }
[13:20:04.872]         }
[13:20:04.872]     })
[13:20:04.872]     if (TRUE) {
[13:20:04.872]         base::sink(type = "output", split = FALSE)
[13:20:04.872]         if (TRUE) {
[13:20:04.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.872]         }
[13:20:04.872]         else {
[13:20:04.872]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.872]         }
[13:20:04.872]         base::close(...future.stdout)
[13:20:04.872]         ...future.stdout <- NULL
[13:20:04.872]     }
[13:20:04.872]     ...future.result$conditions <- ...future.conditions
[13:20:04.872]     ...future.result$finished <- base::Sys.time()
[13:20:04.872]     ...future.result
[13:20:04.872] }
[13:20:04.875] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[13:20:04.875] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[13:20:04.875] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[13:20:04.876] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:20:04.876] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:20:04.876] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:20:04.876] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:20:04.877] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:04.877] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.877] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:04.877] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:04.877] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[13:20:04.878] MultisessionFuture started
[13:20:04.878] - Launch lazy future ... done
[13:20:04.878] run() for ‘MultisessionFuture’ ... done
[13:20:04.878] Created future:
[13:20:04.878] MultisessionFuture:
[13:20:04.878] Label: ‘future_by-1’
[13:20:04.878] Expression:
[13:20:04.878] {
[13:20:04.878]     do.call(function(...) {
[13:20:04.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.878]             on.exit(options(oopts), add = TRUE)
[13:20:04.878]         }
[13:20:04.878]         {
[13:20:04.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.878]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.878]             })
[13:20:04.878]         }
[13:20:04.878]     }, args = future.call.arguments)
[13:20:04.878] }
[13:20:04.878] Lazy evaluation: FALSE
[13:20:04.878] Asynchronous evaluation: TRUE
[13:20:04.878] Local evaluation: TRUE
[13:20:04.878] Environment: R_GlobalEnv
[13:20:04.878] Capture standard output: TRUE
[13:20:04.878] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:04.878] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:04.878] Packages: 1 packages (‘stats’)
[13:20:04.878] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:04.878] Resolved: FALSE
[13:20:04.878] Value: <not collected>
[13:20:04.878] Conditions captured: <none>
[13:20:04.878] Early signaling: FALSE
[13:20:04.878] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:04.878] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.890] Chunk #1 of 2 ... DONE
[13:20:04.890] Chunk #2 of 2 ...
[13:20:04.890]  - Finding globals in 'X' for chunk #2 ...
[13:20:04.890] getGlobalsAndPackages() ...
[13:20:04.890] Searching for globals...
[13:20:04.891] 
[13:20:04.891] Searching for globals ... DONE
[13:20:04.891] - globals: [0] <none>
[13:20:04.891] getGlobalsAndPackages() ... DONE
[13:20:04.891]    + additional globals found: [n=0] 
[13:20:04.891]    + additional namespaces needed: [n=0] 
[13:20:04.891]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:04.892]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:04.892]  - seeds: <none>
[13:20:04.892]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.892] getGlobalsAndPackages() ...
[13:20:04.892] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.892] Resolving globals: FALSE
[13:20:04.892] Tweak future expression to call with '...' arguments ...
[13:20:04.892] {
[13:20:04.892]     do.call(function(...) {
[13:20:04.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.892]             on.exit(options(oopts), add = TRUE)
[13:20:04.892]         }
[13:20:04.892]         {
[13:20:04.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.892]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.892]             })
[13:20:04.892]         }
[13:20:04.892]     }, args = future.call.arguments)
[13:20:04.892] }
[13:20:04.893] Tweak future expression to call with '...' arguments ... DONE
[13:20:04.893] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:04.893] 
[13:20:04.893] getGlobalsAndPackages() ... DONE
[13:20:04.893] run() for ‘Future’ ...
[13:20:04.894] - state: ‘created’
[13:20:04.894] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:04.908] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:04.908]   - Field: ‘node’
[13:20:04.908]   - Field: ‘label’
[13:20:04.908]   - Field: ‘local’
[13:20:04.908]   - Field: ‘owner’
[13:20:04.908]   - Field: ‘envir’
[13:20:04.908]   - Field: ‘workers’
[13:20:04.908]   - Field: ‘packages’
[13:20:04.909]   - Field: ‘gc’
[13:20:04.909]   - Field: ‘conditions’
[13:20:04.909]   - Field: ‘persistent’
[13:20:04.909]   - Field: ‘expr’
[13:20:04.909]   - Field: ‘uuid’
[13:20:04.909]   - Field: ‘seed’
[13:20:04.909]   - Field: ‘version’
[13:20:04.909]   - Field: ‘result’
[13:20:04.909]   - Field: ‘asynchronous’
[13:20:04.909]   - Field: ‘calls’
[13:20:04.909]   - Field: ‘globals’
[13:20:04.910]   - Field: ‘stdout’
[13:20:04.910]   - Field: ‘earlySignal’
[13:20:04.910]   - Field: ‘lazy’
[13:20:04.910]   - Field: ‘state’
[13:20:04.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:04.910] - Launch lazy future ...
[13:20:04.910] Packages needed by the future expression (n = 1): ‘stats’
[13:20:04.910] Packages needed by future strategies (n = 0): <none>
[13:20:04.911] {
[13:20:04.911]     {
[13:20:04.911]         {
[13:20:04.911]             ...future.startTime <- base::Sys.time()
[13:20:04.911]             {
[13:20:04.911]                 {
[13:20:04.911]                   {
[13:20:04.911]                     {
[13:20:04.911]                       {
[13:20:04.911]                         base::local({
[13:20:04.911]                           has_future <- base::requireNamespace("future", 
[13:20:04.911]                             quietly = TRUE)
[13:20:04.911]                           if (has_future) {
[13:20:04.911]                             ns <- base::getNamespace("future")
[13:20:04.911]                             version <- ns[[".package"]][["version"]]
[13:20:04.911]                             if (is.null(version)) 
[13:20:04.911]                               version <- utils::packageVersion("future")
[13:20:04.911]                           }
[13:20:04.911]                           else {
[13:20:04.911]                             version <- NULL
[13:20:04.911]                           }
[13:20:04.911]                           if (!has_future || version < "1.8.0") {
[13:20:04.911]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:04.911]                               "", base::R.version$version.string), 
[13:20:04.911]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:04.911]                                 base::R.version$platform, 8 * 
[13:20:04.911]                                   base::.Machine$sizeof.pointer), 
[13:20:04.911]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:04.911]                                 "release", "version")], collapse = " "), 
[13:20:04.911]                               hostname = base::Sys.info()[["nodename"]])
[13:20:04.911]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:04.911]                               info)
[13:20:04.911]                             info <- base::paste(info, collapse = "; ")
[13:20:04.911]                             if (!has_future) {
[13:20:04.911]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:04.911]                                 info)
[13:20:04.911]                             }
[13:20:04.911]                             else {
[13:20:04.911]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:04.911]                                 info, version)
[13:20:04.911]                             }
[13:20:04.911]                             base::stop(msg)
[13:20:04.911]                           }
[13:20:04.911]                         })
[13:20:04.911]                       }
[13:20:04.911]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:04.911]                       base::options(mc.cores = 1L)
[13:20:04.911]                     }
[13:20:04.911]                     base::local({
[13:20:04.911]                       for (pkg in "stats") {
[13:20:04.911]                         base::loadNamespace(pkg)
[13:20:04.911]                         base::library(pkg, character.only = TRUE)
[13:20:04.911]                       }
[13:20:04.911]                     })
[13:20:04.911]                   }
[13:20:04.911]                   options(future.plan = NULL)
[13:20:04.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:04.911]                 }
[13:20:04.911]                 ...future.workdir <- getwd()
[13:20:04.911]             }
[13:20:04.911]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:04.911]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:04.911]         }
[13:20:04.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:04.911]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:04.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:04.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:04.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:04.911]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:04.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:04.911]             base::names(...future.oldOptions))
[13:20:04.911]     }
[13:20:04.911]     if (FALSE) {
[13:20:04.911]     }
[13:20:04.911]     else {
[13:20:04.911]         if (TRUE) {
[13:20:04.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:04.911]                 open = "w")
[13:20:04.911]         }
[13:20:04.911]         else {
[13:20:04.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:04.911]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:04.911]         }
[13:20:04.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:04.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:04.911]             base::sink(type = "output", split = FALSE)
[13:20:04.911]             base::close(...future.stdout)
[13:20:04.911]         }, add = TRUE)
[13:20:04.911]     }
[13:20:04.911]     ...future.frame <- base::sys.nframe()
[13:20:04.911]     ...future.conditions <- base::list()
[13:20:04.911]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:04.911]     if (FALSE) {
[13:20:04.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:04.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:04.911]     }
[13:20:04.911]     ...future.result <- base::tryCatch({
[13:20:04.911]         base::withCallingHandlers({
[13:20:04.911]             ...future.value <- base::withVisible(base::local({
[13:20:04.911]                 ...future.makeSendCondition <- base::local({
[13:20:04.911]                   sendCondition <- NULL
[13:20:04.911]                   function(frame = 1L) {
[13:20:04.911]                     if (is.function(sendCondition)) 
[13:20:04.911]                       return(sendCondition)
[13:20:04.911]                     ns <- getNamespace("parallel")
[13:20:04.911]                     if (exists("sendData", mode = "function", 
[13:20:04.911]                       envir = ns)) {
[13:20:04.911]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:04.911]                         envir = ns)
[13:20:04.911]                       envir <- sys.frame(frame)
[13:20:04.911]                       master <- NULL
[13:20:04.911]                       while (!identical(envir, .GlobalEnv) && 
[13:20:04.911]                         !identical(envir, emptyenv())) {
[13:20:04.911]                         if (exists("master", mode = "list", envir = envir, 
[13:20:04.911]                           inherits = FALSE)) {
[13:20:04.911]                           master <- get("master", mode = "list", 
[13:20:04.911]                             envir = envir, inherits = FALSE)
[13:20:04.911]                           if (inherits(master, c("SOCKnode", 
[13:20:04.911]                             "SOCK0node"))) {
[13:20:04.911]                             sendCondition <<- function(cond) {
[13:20:04.911]                               data <- list(type = "VALUE", value = cond, 
[13:20:04.911]                                 success = TRUE)
[13:20:04.911]                               parallel_sendData(master, data)
[13:20:04.911]                             }
[13:20:04.911]                             return(sendCondition)
[13:20:04.911]                           }
[13:20:04.911]                         }
[13:20:04.911]                         frame <- frame + 1L
[13:20:04.911]                         envir <- sys.frame(frame)
[13:20:04.911]                       }
[13:20:04.911]                     }
[13:20:04.911]                     sendCondition <<- function(cond) NULL
[13:20:04.911]                   }
[13:20:04.911]                 })
[13:20:04.911]                 withCallingHandlers({
[13:20:04.911]                   {
[13:20:04.911]                     do.call(function(...) {
[13:20:04.911]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.911]                       if (!identical(...future.globals.maxSize.org, 
[13:20:04.911]                         ...future.globals.maxSize)) {
[13:20:04.911]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.911]                         on.exit(options(oopts), add = TRUE)
[13:20:04.911]                       }
[13:20:04.911]                       {
[13:20:04.911]                         lapply(seq_along(...future.elements_ii), 
[13:20:04.911]                           FUN = function(jj) {
[13:20:04.911]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.911]                             ...future.FUN(...future.X_jj, ...)
[13:20:04.911]                           })
[13:20:04.911]                       }
[13:20:04.911]                     }, args = future.call.arguments)
[13:20:04.911]                   }
[13:20:04.911]                 }, immediateCondition = function(cond) {
[13:20:04.911]                   sendCondition <- ...future.makeSendCondition()
[13:20:04.911]                   sendCondition(cond)
[13:20:04.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.911]                   {
[13:20:04.911]                     inherits <- base::inherits
[13:20:04.911]                     invokeRestart <- base::invokeRestart
[13:20:04.911]                     is.null <- base::is.null
[13:20:04.911]                     muffled <- FALSE
[13:20:04.911]                     if (inherits(cond, "message")) {
[13:20:04.911]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:04.911]                       if (muffled) 
[13:20:04.911]                         invokeRestart("muffleMessage")
[13:20:04.911]                     }
[13:20:04.911]                     else if (inherits(cond, "warning")) {
[13:20:04.911]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:04.911]                       if (muffled) 
[13:20:04.911]                         invokeRestart("muffleWarning")
[13:20:04.911]                     }
[13:20:04.911]                     else if (inherits(cond, "condition")) {
[13:20:04.911]                       if (!is.null(pattern)) {
[13:20:04.911]                         computeRestarts <- base::computeRestarts
[13:20:04.911]                         grepl <- base::grepl
[13:20:04.911]                         restarts <- computeRestarts(cond)
[13:20:04.911]                         for (restart in restarts) {
[13:20:04.911]                           name <- restart$name
[13:20:04.911]                           if (is.null(name)) 
[13:20:04.911]                             next
[13:20:04.911]                           if (!grepl(pattern, name)) 
[13:20:04.911]                             next
[13:20:04.911]                           invokeRestart(restart)
[13:20:04.911]                           muffled <- TRUE
[13:20:04.911]                           break
[13:20:04.911]                         }
[13:20:04.911]                       }
[13:20:04.911]                     }
[13:20:04.911]                     invisible(muffled)
[13:20:04.911]                   }
[13:20:04.911]                   muffleCondition(cond)
[13:20:04.911]                 })
[13:20:04.911]             }))
[13:20:04.911]             future::FutureResult(value = ...future.value$value, 
[13:20:04.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.911]                   ...future.rng), globalenv = if (FALSE) 
[13:20:04.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:04.911]                     ...future.globalenv.names))
[13:20:04.911]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:04.911]         }, condition = base::local({
[13:20:04.911]             c <- base::c
[13:20:04.911]             inherits <- base::inherits
[13:20:04.911]             invokeRestart <- base::invokeRestart
[13:20:04.911]             length <- base::length
[13:20:04.911]             list <- base::list
[13:20:04.911]             seq.int <- base::seq.int
[13:20:04.911]             signalCondition <- base::signalCondition
[13:20:04.911]             sys.calls <- base::sys.calls
[13:20:04.911]             `[[` <- base::`[[`
[13:20:04.911]             `+` <- base::`+`
[13:20:04.911]             `<<-` <- base::`<<-`
[13:20:04.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:04.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:04.911]                   3L)]
[13:20:04.911]             }
[13:20:04.911]             function(cond) {
[13:20:04.911]                 is_error <- inherits(cond, "error")
[13:20:04.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:04.911]                   NULL)
[13:20:04.911]                 if (is_error) {
[13:20:04.911]                   sessionInformation <- function() {
[13:20:04.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:04.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:04.911]                       search = base::search(), system = base::Sys.info())
[13:20:04.911]                   }
[13:20:04.911]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:04.911]                     cond$call), session = sessionInformation(), 
[13:20:04.911]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:04.911]                   signalCondition(cond)
[13:20:04.911]                 }
[13:20:04.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:04.911]                 "immediateCondition"))) {
[13:20:04.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:04.911]                   ...future.conditions[[length(...future.conditions) + 
[13:20:04.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:04.911]                   if (TRUE && !signal) {
[13:20:04.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.911]                     {
[13:20:04.911]                       inherits <- base::inherits
[13:20:04.911]                       invokeRestart <- base::invokeRestart
[13:20:04.911]                       is.null <- base::is.null
[13:20:04.911]                       muffled <- FALSE
[13:20:04.911]                       if (inherits(cond, "message")) {
[13:20:04.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.911]                         if (muffled) 
[13:20:04.911]                           invokeRestart("muffleMessage")
[13:20:04.911]                       }
[13:20:04.911]                       else if (inherits(cond, "warning")) {
[13:20:04.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.911]                         if (muffled) 
[13:20:04.911]                           invokeRestart("muffleWarning")
[13:20:04.911]                       }
[13:20:04.911]                       else if (inherits(cond, "condition")) {
[13:20:04.911]                         if (!is.null(pattern)) {
[13:20:04.911]                           computeRestarts <- base::computeRestarts
[13:20:04.911]                           grepl <- base::grepl
[13:20:04.911]                           restarts <- computeRestarts(cond)
[13:20:04.911]                           for (restart in restarts) {
[13:20:04.911]                             name <- restart$name
[13:20:04.911]                             if (is.null(name)) 
[13:20:04.911]                               next
[13:20:04.911]                             if (!grepl(pattern, name)) 
[13:20:04.911]                               next
[13:20:04.911]                             invokeRestart(restart)
[13:20:04.911]                             muffled <- TRUE
[13:20:04.911]                             break
[13:20:04.911]                           }
[13:20:04.911]                         }
[13:20:04.911]                       }
[13:20:04.911]                       invisible(muffled)
[13:20:04.911]                     }
[13:20:04.911]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.911]                   }
[13:20:04.911]                 }
[13:20:04.911]                 else {
[13:20:04.911]                   if (TRUE) {
[13:20:04.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:04.911]                     {
[13:20:04.911]                       inherits <- base::inherits
[13:20:04.911]                       invokeRestart <- base::invokeRestart
[13:20:04.911]                       is.null <- base::is.null
[13:20:04.911]                       muffled <- FALSE
[13:20:04.911]                       if (inherits(cond, "message")) {
[13:20:04.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:04.911]                         if (muffled) 
[13:20:04.911]                           invokeRestart("muffleMessage")
[13:20:04.911]                       }
[13:20:04.911]                       else if (inherits(cond, "warning")) {
[13:20:04.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:04.911]                         if (muffled) 
[13:20:04.911]                           invokeRestart("muffleWarning")
[13:20:04.911]                       }
[13:20:04.911]                       else if (inherits(cond, "condition")) {
[13:20:04.911]                         if (!is.null(pattern)) {
[13:20:04.911]                           computeRestarts <- base::computeRestarts
[13:20:04.911]                           grepl <- base::grepl
[13:20:04.911]                           restarts <- computeRestarts(cond)
[13:20:04.911]                           for (restart in restarts) {
[13:20:04.911]                             name <- restart$name
[13:20:04.911]                             if (is.null(name)) 
[13:20:04.911]                               next
[13:20:04.911]                             if (!grepl(pattern, name)) 
[13:20:04.911]                               next
[13:20:04.911]                             invokeRestart(restart)
[13:20:04.911]                             muffled <- TRUE
[13:20:04.911]                             break
[13:20:04.911]                           }
[13:20:04.911]                         }
[13:20:04.911]                       }
[13:20:04.911]                       invisible(muffled)
[13:20:04.911]                     }
[13:20:04.911]                     muffleCondition(cond, pattern = "^muffle")
[13:20:04.911]                   }
[13:20:04.911]                 }
[13:20:04.911]             }
[13:20:04.911]         }))
[13:20:04.911]     }, error = function(ex) {
[13:20:04.911]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:04.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:04.911]                 ...future.rng), started = ...future.startTime, 
[13:20:04.911]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:04.911]             version = "1.8"), class = "FutureResult")
[13:20:04.911]     }, finally = {
[13:20:04.911]         if (!identical(...future.workdir, getwd())) 
[13:20:04.911]             setwd(...future.workdir)
[13:20:04.911]         {
[13:20:04.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:04.911]                 ...future.oldOptions$nwarnings <- NULL
[13:20:04.911]             }
[13:20:04.911]             base::options(...future.oldOptions)
[13:20:04.911]             if (.Platform$OS.type == "windows") {
[13:20:04.911]                 old_names <- names(...future.oldEnvVars)
[13:20:04.911]                 envs <- base::Sys.getenv()
[13:20:04.911]                 names <- names(envs)
[13:20:04.911]                 common <- intersect(names, old_names)
[13:20:04.911]                 added <- setdiff(names, old_names)
[13:20:04.911]                 removed <- setdiff(old_names, names)
[13:20:04.911]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:04.911]                   envs[common]]
[13:20:04.911]                 NAMES <- toupper(changed)
[13:20:04.911]                 args <- list()
[13:20:04.911]                 for (kk in seq_along(NAMES)) {
[13:20:04.911]                   name <- changed[[kk]]
[13:20:04.911]                   NAME <- NAMES[[kk]]
[13:20:04.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.911]                     next
[13:20:04.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.911]                 }
[13:20:04.911]                 NAMES <- toupper(added)
[13:20:04.911]                 for (kk in seq_along(NAMES)) {
[13:20:04.911]                   name <- added[[kk]]
[13:20:04.911]                   NAME <- NAMES[[kk]]
[13:20:04.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.911]                     next
[13:20:04.911]                   args[[name]] <- ""
[13:20:04.911]                 }
[13:20:04.911]                 NAMES <- toupper(removed)
[13:20:04.911]                 for (kk in seq_along(NAMES)) {
[13:20:04.911]                   name <- removed[[kk]]
[13:20:04.911]                   NAME <- NAMES[[kk]]
[13:20:04.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:04.911]                     next
[13:20:04.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:04.911]                 }
[13:20:04.911]                 if (length(args) > 0) 
[13:20:04.911]                   base::do.call(base::Sys.setenv, args = args)
[13:20:04.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:04.911]             }
[13:20:04.911]             else {
[13:20:04.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:04.911]             }
[13:20:04.911]             {
[13:20:04.911]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:04.911]                   0L) {
[13:20:04.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:04.911]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:04.911]                   base::options(opts)
[13:20:04.911]                 }
[13:20:04.911]                 {
[13:20:04.911]                   {
[13:20:04.911]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:04.911]                     NULL
[13:20:04.911]                   }
[13:20:04.911]                   options(future.plan = NULL)
[13:20:04.911]                   if (is.na(NA_character_)) 
[13:20:04.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:04.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:04.911]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:04.911]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:04.911]                     envir = parent.frame()) 
[13:20:04.911]                   {
[13:20:04.911]                     if (is.function(workers)) 
[13:20:04.911]                       workers <- workers()
[13:20:04.911]                     workers <- structure(as.integer(workers), 
[13:20:04.911]                       class = class(workers))
[13:20:04.911]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:04.911]                       workers >= 1)
[13:20:04.911]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:04.911]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:04.911]                     }
[13:20:04.911]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:04.911]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:04.911]                       envir = envir)
[13:20:04.911]                     if (!future$lazy) 
[13:20:04.911]                       future <- run(future)
[13:20:04.911]                     invisible(future)
[13:20:04.911]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:04.911]                 }
[13:20:04.911]             }
[13:20:04.911]         }
[13:20:04.911]     })
[13:20:04.911]     if (TRUE) {
[13:20:04.911]         base::sink(type = "output", split = FALSE)
[13:20:04.911]         if (TRUE) {
[13:20:04.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:04.911]         }
[13:20:04.911]         else {
[13:20:04.911]             ...future.result["stdout"] <- base::list(NULL)
[13:20:04.911]         }
[13:20:04.911]         base::close(...future.stdout)
[13:20:04.911]         ...future.stdout <- NULL
[13:20:04.911]     }
[13:20:04.911]     ...future.result$conditions <- ...future.conditions
[13:20:04.911]     ...future.result$finished <- base::Sys.time()
[13:20:04.911]     ...future.result
[13:20:04.911] }
[13:20:04.914] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[13:20:04.914] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[13:20:04.914] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[13:20:04.915] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[13:20:04.915] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[13:20:04.915] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:20:04.916] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:20:04.916] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:04.916] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.916] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:04.916] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:04.917] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[13:20:04.917] MultisessionFuture started
[13:20:04.917] - Launch lazy future ... done
[13:20:04.917] run() for ‘MultisessionFuture’ ... done
[13:20:04.917] Created future:
[13:20:04.917] MultisessionFuture:
[13:20:04.917] Label: ‘future_by-2’
[13:20:04.917] Expression:
[13:20:04.917] {
[13:20:04.917]     do.call(function(...) {
[13:20:04.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:04.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:04.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:04.917]             on.exit(options(oopts), add = TRUE)
[13:20:04.917]         }
[13:20:04.917]         {
[13:20:04.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:04.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:04.917]                 ...future.FUN(...future.X_jj, ...)
[13:20:04.917]             })
[13:20:04.917]         }
[13:20:04.917]     }, args = future.call.arguments)
[13:20:04.917] }
[13:20:04.917] Lazy evaluation: FALSE
[13:20:04.917] Asynchronous evaluation: TRUE
[13:20:04.917] Local evaluation: TRUE
[13:20:04.917] Environment: R_GlobalEnv
[13:20:04.917] Capture standard output: TRUE
[13:20:04.917] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:04.917] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:04.917] Packages: 1 packages (‘stats’)
[13:20:04.917] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:04.917] Resolved: FALSE
[13:20:04.917] Value: <not collected>
[13:20:04.917] Conditions captured: <none>
[13:20:04.917] Early signaling: FALSE
[13:20:04.917] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:04.917] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:04.929] Chunk #2 of 2 ... DONE
[13:20:04.929] Launching 2 futures (chunks) ... DONE
[13:20:04.929] Resolving 2 futures (chunks) ...
[13:20:04.929] resolve() on list ...
[13:20:04.929]  recursive: 0
[13:20:04.930]  length: 2
[13:20:04.930] 
[13:20:04.930] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.930] - Validating connection of MultisessionFuture
[13:20:04.931] - received message: FutureResult
[13:20:04.931] - Received FutureResult
[13:20:04.931] - Erased future from FutureRegistry
[13:20:04.931] result() for ClusterFuture ...
[13:20:04.931] - result already collected: FutureResult
[13:20:04.931] result() for ClusterFuture ... done
[13:20:04.931] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.931] Future #1
[13:20:04.931] result() for ClusterFuture ...
[13:20:04.931] - result already collected: FutureResult
[13:20:04.931] result() for ClusterFuture ... done
[13:20:04.932] result() for ClusterFuture ...
[13:20:04.932] - result already collected: FutureResult
[13:20:04.932] result() for ClusterFuture ... done
[13:20:04.932] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:04.932] - nx: 2
[13:20:04.932] - relay: TRUE
[13:20:04.932] - stdout: TRUE
[13:20:04.932] - signal: TRUE
[13:20:04.932] - resignal: FALSE
[13:20:04.932] - force: TRUE
[13:20:04.932] - relayed: [n=2] FALSE, FALSE
[13:20:04.933] - queued futures: [n=2] FALSE, FALSE
[13:20:04.933]  - until=1
[13:20:04.933]  - relaying element #1
[13:20:04.933] result() for ClusterFuture ...
[13:20:04.933] - result already collected: FutureResult
[13:20:04.933] result() for ClusterFuture ... done
[13:20:04.933] result() for ClusterFuture ...
[13:20:04.933] - result already collected: FutureResult
[13:20:04.933] result() for ClusterFuture ... done
[13:20:04.933] result() for ClusterFuture ...
[13:20:04.933] - result already collected: FutureResult
[13:20:04.934] result() for ClusterFuture ... done
[13:20:04.934] result() for ClusterFuture ...
[13:20:04.934] - result already collected: FutureResult
[13:20:04.934] result() for ClusterFuture ... done
[13:20:04.934] - relayed: [n=2] TRUE, FALSE
[13:20:04.934] - queued futures: [n=2] TRUE, FALSE
[13:20:04.934] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:04.934]  length: 1 (resolved future 1)
[13:20:04.976] receiveMessageFromWorker() for ClusterFuture ...
[13:20:04.976] - Validating connection of MultisessionFuture
[13:20:04.977] - received message: FutureResult
[13:20:04.977] - Received FutureResult
[13:20:04.977] - Erased future from FutureRegistry
[13:20:04.977] result() for ClusterFuture ...
[13:20:04.977] - result already collected: FutureResult
[13:20:04.977] result() for ClusterFuture ... done
[13:20:04.977] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:04.977] Future #2
[13:20:04.977] result() for ClusterFuture ...
[13:20:04.977] - result already collected: FutureResult
[13:20:04.978] result() for ClusterFuture ... done
[13:20:04.978] result() for ClusterFuture ...
[13:20:04.978] - result already collected: FutureResult
[13:20:04.978] result() for ClusterFuture ... done
[13:20:04.978] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:04.978] - nx: 2
[13:20:04.978] - relay: TRUE
[13:20:04.978] - stdout: TRUE
[13:20:04.978] - signal: TRUE
[13:20:04.978] - resignal: FALSE
[13:20:04.978] - force: TRUE
[13:20:04.979] - relayed: [n=2] TRUE, FALSE
[13:20:04.979] - queued futures: [n=2] TRUE, FALSE
[13:20:04.979]  - until=2
[13:20:04.979]  - relaying element #2
[13:20:04.979] result() for ClusterFuture ...
[13:20:04.979] - result already collected: FutureResult
[13:20:04.979] result() for ClusterFuture ... done
[13:20:04.979] result() for ClusterFuture ...
[13:20:04.979] - result already collected: FutureResult
[13:20:04.979] result() for ClusterFuture ... done
[13:20:04.979] result() for ClusterFuture ...
[13:20:04.979] - result already collected: FutureResult
[13:20:04.980] result() for ClusterFuture ... done
[13:20:04.980] result() for ClusterFuture ...
[13:20:04.980] - result already collected: FutureResult
[13:20:04.980] result() for ClusterFuture ... done
[13:20:04.980] - relayed: [n=2] TRUE, TRUE
[13:20:04.980] - queued futures: [n=2] TRUE, TRUE
[13:20:04.980] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:04.980]  length: 0 (resolved future 2)
[13:20:04.980] Relaying remaining futures
[13:20:04.981] signalConditionsASAP(NULL, pos=0) ...
[13:20:04.981] - nx: 2
[13:20:04.981] - relay: TRUE
[13:20:04.981] - stdout: TRUE
[13:20:04.981] - signal: TRUE
[13:20:04.981] - resignal: FALSE
[13:20:04.981] - force: TRUE
[13:20:04.981] - relayed: [n=2] TRUE, TRUE
[13:20:04.981] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:04.981] - relayed: [n=2] TRUE, TRUE
[13:20:04.981] - queued futures: [n=2] TRUE, TRUE
[13:20:04.981] signalConditionsASAP(NULL, pos=0) ... done
[13:20:04.982] resolve() on list ... DONE
[13:20:04.982] result() for ClusterFuture ...
[13:20:04.982] - result already collected: FutureResult
[13:20:04.982] result() for ClusterFuture ... done
[13:20:04.982] result() for ClusterFuture ...
[13:20:04.982] - result already collected: FutureResult
[13:20:04.982] result() for ClusterFuture ... done
[13:20:04.982] result() for ClusterFuture ...
[13:20:04.982] - result already collected: FutureResult
[13:20:04.982] result() for ClusterFuture ... done
[13:20:04.982] result() for ClusterFuture ...
[13:20:04.982] - result already collected: FutureResult
[13:20:04.983] result() for ClusterFuture ... done
[13:20:04.983]  - Number of value chunks collected: 2
[13:20:04.983] Resolving 2 futures (chunks) ... DONE
[13:20:04.983] Reducing values from 2 chunks ...
[13:20:04.983]  - Number of values collected after concatenation: 3
[13:20:04.983]  - Number of values expected: 3
[13:20:04.983] Reducing values from 2 chunks ... DONE
[13:20:04.983] future_lapply() ... DONE
[13:20:04.983] future_by_internal() ... DONE
[13:20:04.987] future_by_internal() ...
[13:20:04.988] future_lapply() ...
[13:20:04.992] Number of chunks: 2
[13:20:04.992] getGlobalsAndPackagesXApply() ...
[13:20:04.992]  - future.globals: TRUE
[13:20:04.992] getGlobalsAndPackages() ...
[13:20:04.992] Searching for globals...
[13:20:04.994] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:20:04.994] Searching for globals ... DONE
[13:20:04.994] Resolving globals: FALSE
[13:20:04.995] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:20:04.995] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:20:04.995] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:04.996] - packages: [1] ‘stats’
[13:20:04.996] getGlobalsAndPackages() ... DONE
[13:20:04.996]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:20:04.996]  - needed namespaces: [n=1] ‘stats’
[13:20:04.996] Finding globals ... DONE
[13:20:04.996]  - use_args: TRUE
[13:20:04.996]  - Getting '...' globals ...
[13:20:04.996] resolve() on list ...
[13:20:04.997]  recursive: 0
[13:20:04.997]  length: 1
[13:20:04.997]  elements: ‘...’
[13:20:04.997]  length: 0 (resolved future 1)
[13:20:04.997] resolve() on list ... DONE
[13:20:04.997]    - '...' content: [n=0] 
[13:20:04.997] List of 1
[13:20:04.997]  $ ...: list()
[13:20:04.997]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:04.997]  - attr(*, "where")=List of 1
[13:20:04.997]   ..$ ...:<environment: 0x55acef74c380> 
[13:20:04.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:04.997]  - attr(*, "resolved")= logi TRUE
[13:20:04.997]  - attr(*, "total_size")= num NA
[13:20:05.000]  - Getting '...' globals ... DONE
[13:20:05.000] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:20:05.000] List of 4
[13:20:05.000]  $ ...future.FUN:function (x)  
[13:20:05.000]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:20:05.000]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:20:05.000]  $ ...          : list()
[13:20:05.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.000]  - attr(*, "where")=List of 4
[13:20:05.000]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.000]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:20:05.000]   ..$ wool         :<environment: R_EmptyEnv> 
[13:20:05.000]   ..$ ...          :<environment: 0x55acef74c380> 
[13:20:05.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.000]  - attr(*, "resolved")= logi FALSE
[13:20:05.000]  - attr(*, "total_size")= num 2320
[13:20:05.004] Packages to be attached in all futures: [n=1] ‘stats’
[13:20:05.004] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.004] Number of futures (= number of chunks): 2
[13:20:05.004] Launching 2 futures (chunks) ...
[13:20:05.004] Chunk #1 of 2 ...
[13:20:05.004]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.005] getGlobalsAndPackages() ...
[13:20:05.005] Searching for globals...
[13:20:05.005] 
[13:20:05.005] Searching for globals ... DONE
[13:20:05.005] - globals: [0] <none>
[13:20:05.005] getGlobalsAndPackages() ... DONE
[13:20:05.005]    + additional globals found: [n=0] 
[13:20:05.005]    + additional namespaces needed: [n=0] 
[13:20:05.006]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.006]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.006]  - seeds: <none>
[13:20:05.006]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.006] getGlobalsAndPackages() ...
[13:20:05.006] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.006] Resolving globals: FALSE
[13:20:05.006] Tweak future expression to call with '...' arguments ...
[13:20:05.006] {
[13:20:05.006]     do.call(function(...) {
[13:20:05.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.006]             on.exit(options(oopts), add = TRUE)
[13:20:05.006]         }
[13:20:05.006]         {
[13:20:05.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.006]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.006]             })
[13:20:05.006]         }
[13:20:05.006]     }, args = future.call.arguments)
[13:20:05.006] }
[13:20:05.007] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.007] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.007] 
[13:20:05.007] getGlobalsAndPackages() ... DONE
[13:20:05.008] run() for ‘Future’ ...
[13:20:05.008] - state: ‘created’
[13:20:05.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:05.024]   - Field: ‘node’
[13:20:05.024]   - Field: ‘label’
[13:20:05.024]   - Field: ‘local’
[13:20:05.025]   - Field: ‘owner’
[13:20:05.025]   - Field: ‘envir’
[13:20:05.025]   - Field: ‘workers’
[13:20:05.025]   - Field: ‘packages’
[13:20:05.025]   - Field: ‘gc’
[13:20:05.025]   - Field: ‘conditions’
[13:20:05.025]   - Field: ‘persistent’
[13:20:05.025]   - Field: ‘expr’
[13:20:05.025]   - Field: ‘uuid’
[13:20:05.025]   - Field: ‘seed’
[13:20:05.025]   - Field: ‘version’
[13:20:05.028]   - Field: ‘result’
[13:20:05.028]   - Field: ‘asynchronous’
[13:20:05.028]   - Field: ‘calls’
[13:20:05.028]   - Field: ‘globals’
[13:20:05.028]   - Field: ‘stdout’
[13:20:05.028]   - Field: ‘earlySignal’
[13:20:05.028]   - Field: ‘lazy’
[13:20:05.028]   - Field: ‘state’
[13:20:05.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:05.029] - Launch lazy future ...
[13:20:05.029] Packages needed by the future expression (n = 1): ‘stats’
[13:20:05.029] Packages needed by future strategies (n = 0): <none>
[13:20:05.030] {
[13:20:05.030]     {
[13:20:05.030]         {
[13:20:05.030]             ...future.startTime <- base::Sys.time()
[13:20:05.030]             {
[13:20:05.030]                 {
[13:20:05.030]                   {
[13:20:05.030]                     {
[13:20:05.030]                       {
[13:20:05.030]                         base::local({
[13:20:05.030]                           has_future <- base::requireNamespace("future", 
[13:20:05.030]                             quietly = TRUE)
[13:20:05.030]                           if (has_future) {
[13:20:05.030]                             ns <- base::getNamespace("future")
[13:20:05.030]                             version <- ns[[".package"]][["version"]]
[13:20:05.030]                             if (is.null(version)) 
[13:20:05.030]                               version <- utils::packageVersion("future")
[13:20:05.030]                           }
[13:20:05.030]                           else {
[13:20:05.030]                             version <- NULL
[13:20:05.030]                           }
[13:20:05.030]                           if (!has_future || version < "1.8.0") {
[13:20:05.030]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.030]                               "", base::R.version$version.string), 
[13:20:05.030]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:05.030]                                 base::R.version$platform, 8 * 
[13:20:05.030]                                   base::.Machine$sizeof.pointer), 
[13:20:05.030]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.030]                                 "release", "version")], collapse = " "), 
[13:20:05.030]                               hostname = base::Sys.info()[["nodename"]])
[13:20:05.030]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.030]                               info)
[13:20:05.030]                             info <- base::paste(info, collapse = "; ")
[13:20:05.030]                             if (!has_future) {
[13:20:05.030]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.030]                                 info)
[13:20:05.030]                             }
[13:20:05.030]                             else {
[13:20:05.030]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.030]                                 info, version)
[13:20:05.030]                             }
[13:20:05.030]                             base::stop(msg)
[13:20:05.030]                           }
[13:20:05.030]                         })
[13:20:05.030]                       }
[13:20:05.030]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.030]                       base::options(mc.cores = 1L)
[13:20:05.030]                     }
[13:20:05.030]                     base::local({
[13:20:05.030]                       for (pkg in "stats") {
[13:20:05.030]                         base::loadNamespace(pkg)
[13:20:05.030]                         base::library(pkg, character.only = TRUE)
[13:20:05.030]                       }
[13:20:05.030]                     })
[13:20:05.030]                   }
[13:20:05.030]                   options(future.plan = NULL)
[13:20:05.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.030]                 }
[13:20:05.030]                 ...future.workdir <- getwd()
[13:20:05.030]             }
[13:20:05.030]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.030]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.030]         }
[13:20:05.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.030]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.030]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.030]             base::names(...future.oldOptions))
[13:20:05.030]     }
[13:20:05.030]     if (FALSE) {
[13:20:05.030]     }
[13:20:05.030]     else {
[13:20:05.030]         if (TRUE) {
[13:20:05.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.030]                 open = "w")
[13:20:05.030]         }
[13:20:05.030]         else {
[13:20:05.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.030]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.030]         }
[13:20:05.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.030]             base::sink(type = "output", split = FALSE)
[13:20:05.030]             base::close(...future.stdout)
[13:20:05.030]         }, add = TRUE)
[13:20:05.030]     }
[13:20:05.030]     ...future.frame <- base::sys.nframe()
[13:20:05.030]     ...future.conditions <- base::list()
[13:20:05.030]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.030]     if (FALSE) {
[13:20:05.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.030]     }
[13:20:05.030]     ...future.result <- base::tryCatch({
[13:20:05.030]         base::withCallingHandlers({
[13:20:05.030]             ...future.value <- base::withVisible(base::local({
[13:20:05.030]                 ...future.makeSendCondition <- base::local({
[13:20:05.030]                   sendCondition <- NULL
[13:20:05.030]                   function(frame = 1L) {
[13:20:05.030]                     if (is.function(sendCondition)) 
[13:20:05.030]                       return(sendCondition)
[13:20:05.030]                     ns <- getNamespace("parallel")
[13:20:05.030]                     if (exists("sendData", mode = "function", 
[13:20:05.030]                       envir = ns)) {
[13:20:05.030]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:05.030]                         envir = ns)
[13:20:05.030]                       envir <- sys.frame(frame)
[13:20:05.030]                       master <- NULL
[13:20:05.030]                       while (!identical(envir, .GlobalEnv) && 
[13:20:05.030]                         !identical(envir, emptyenv())) {
[13:20:05.030]                         if (exists("master", mode = "list", envir = envir, 
[13:20:05.030]                           inherits = FALSE)) {
[13:20:05.030]                           master <- get("master", mode = "list", 
[13:20:05.030]                             envir = envir, inherits = FALSE)
[13:20:05.030]                           if (inherits(master, c("SOCKnode", 
[13:20:05.030]                             "SOCK0node"))) {
[13:20:05.030]                             sendCondition <<- function(cond) {
[13:20:05.030]                               data <- list(type = "VALUE", value = cond, 
[13:20:05.030]                                 success = TRUE)
[13:20:05.030]                               parallel_sendData(master, data)
[13:20:05.030]                             }
[13:20:05.030]                             return(sendCondition)
[13:20:05.030]                           }
[13:20:05.030]                         }
[13:20:05.030]                         frame <- frame + 1L
[13:20:05.030]                         envir <- sys.frame(frame)
[13:20:05.030]                       }
[13:20:05.030]                     }
[13:20:05.030]                     sendCondition <<- function(cond) NULL
[13:20:05.030]                   }
[13:20:05.030]                 })
[13:20:05.030]                 withCallingHandlers({
[13:20:05.030]                   {
[13:20:05.030]                     do.call(function(...) {
[13:20:05.030]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.030]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.030]                         ...future.globals.maxSize)) {
[13:20:05.030]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.030]                         on.exit(options(oopts), add = TRUE)
[13:20:05.030]                       }
[13:20:05.030]                       {
[13:20:05.030]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.030]                           FUN = function(jj) {
[13:20:05.030]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.030]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.030]                           })
[13:20:05.030]                       }
[13:20:05.030]                     }, args = future.call.arguments)
[13:20:05.030]                   }
[13:20:05.030]                 }, immediateCondition = function(cond) {
[13:20:05.030]                   sendCondition <- ...future.makeSendCondition()
[13:20:05.030]                   sendCondition(cond)
[13:20:05.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.030]                   {
[13:20:05.030]                     inherits <- base::inherits
[13:20:05.030]                     invokeRestart <- base::invokeRestart
[13:20:05.030]                     is.null <- base::is.null
[13:20:05.030]                     muffled <- FALSE
[13:20:05.030]                     if (inherits(cond, "message")) {
[13:20:05.030]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.030]                       if (muffled) 
[13:20:05.030]                         invokeRestart("muffleMessage")
[13:20:05.030]                     }
[13:20:05.030]                     else if (inherits(cond, "warning")) {
[13:20:05.030]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.030]                       if (muffled) 
[13:20:05.030]                         invokeRestart("muffleWarning")
[13:20:05.030]                     }
[13:20:05.030]                     else if (inherits(cond, "condition")) {
[13:20:05.030]                       if (!is.null(pattern)) {
[13:20:05.030]                         computeRestarts <- base::computeRestarts
[13:20:05.030]                         grepl <- base::grepl
[13:20:05.030]                         restarts <- computeRestarts(cond)
[13:20:05.030]                         for (restart in restarts) {
[13:20:05.030]                           name <- restart$name
[13:20:05.030]                           if (is.null(name)) 
[13:20:05.030]                             next
[13:20:05.030]                           if (!grepl(pattern, name)) 
[13:20:05.030]                             next
[13:20:05.030]                           invokeRestart(restart)
[13:20:05.030]                           muffled <- TRUE
[13:20:05.030]                           break
[13:20:05.030]                         }
[13:20:05.030]                       }
[13:20:05.030]                     }
[13:20:05.030]                     invisible(muffled)
[13:20:05.030]                   }
[13:20:05.030]                   muffleCondition(cond)
[13:20:05.030]                 })
[13:20:05.030]             }))
[13:20:05.030]             future::FutureResult(value = ...future.value$value, 
[13:20:05.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.030]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.030]                     ...future.globalenv.names))
[13:20:05.030]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.030]         }, condition = base::local({
[13:20:05.030]             c <- base::c
[13:20:05.030]             inherits <- base::inherits
[13:20:05.030]             invokeRestart <- base::invokeRestart
[13:20:05.030]             length <- base::length
[13:20:05.030]             list <- base::list
[13:20:05.030]             seq.int <- base::seq.int
[13:20:05.030]             signalCondition <- base::signalCondition
[13:20:05.030]             sys.calls <- base::sys.calls
[13:20:05.030]             `[[` <- base::`[[`
[13:20:05.030]             `+` <- base::`+`
[13:20:05.030]             `<<-` <- base::`<<-`
[13:20:05.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.030]                   3L)]
[13:20:05.030]             }
[13:20:05.030]             function(cond) {
[13:20:05.030]                 is_error <- inherits(cond, "error")
[13:20:05.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.030]                   NULL)
[13:20:05.030]                 if (is_error) {
[13:20:05.030]                   sessionInformation <- function() {
[13:20:05.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.030]                       search = base::search(), system = base::Sys.info())
[13:20:05.030]                   }
[13:20:05.030]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.030]                     cond$call), session = sessionInformation(), 
[13:20:05.030]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.030]                   signalCondition(cond)
[13:20:05.030]                 }
[13:20:05.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.030]                 "immediateCondition"))) {
[13:20:05.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.030]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.030]                   if (TRUE && !signal) {
[13:20:05.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.030]                     {
[13:20:05.030]                       inherits <- base::inherits
[13:20:05.030]                       invokeRestart <- base::invokeRestart
[13:20:05.030]                       is.null <- base::is.null
[13:20:05.030]                       muffled <- FALSE
[13:20:05.030]                       if (inherits(cond, "message")) {
[13:20:05.030]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.030]                         if (muffled) 
[13:20:05.030]                           invokeRestart("muffleMessage")
[13:20:05.030]                       }
[13:20:05.030]                       else if (inherits(cond, "warning")) {
[13:20:05.030]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.030]                         if (muffled) 
[13:20:05.030]                           invokeRestart("muffleWarning")
[13:20:05.030]                       }
[13:20:05.030]                       else if (inherits(cond, "condition")) {
[13:20:05.030]                         if (!is.null(pattern)) {
[13:20:05.030]                           computeRestarts <- base::computeRestarts
[13:20:05.030]                           grepl <- base::grepl
[13:20:05.030]                           restarts <- computeRestarts(cond)
[13:20:05.030]                           for (restart in restarts) {
[13:20:05.030]                             name <- restart$name
[13:20:05.030]                             if (is.null(name)) 
[13:20:05.030]                               next
[13:20:05.030]                             if (!grepl(pattern, name)) 
[13:20:05.030]                               next
[13:20:05.030]                             invokeRestart(restart)
[13:20:05.030]                             muffled <- TRUE
[13:20:05.030]                             break
[13:20:05.030]                           }
[13:20:05.030]                         }
[13:20:05.030]                       }
[13:20:05.030]                       invisible(muffled)
[13:20:05.030]                     }
[13:20:05.030]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.030]                   }
[13:20:05.030]                 }
[13:20:05.030]                 else {
[13:20:05.030]                   if (TRUE) {
[13:20:05.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.030]                     {
[13:20:05.030]                       inherits <- base::inherits
[13:20:05.030]                       invokeRestart <- base::invokeRestart
[13:20:05.030]                       is.null <- base::is.null
[13:20:05.030]                       muffled <- FALSE
[13:20:05.030]                       if (inherits(cond, "message")) {
[13:20:05.030]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.030]                         if (muffled) 
[13:20:05.030]                           invokeRestart("muffleMessage")
[13:20:05.030]                       }
[13:20:05.030]                       else if (inherits(cond, "warning")) {
[13:20:05.030]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.030]                         if (muffled) 
[13:20:05.030]                           invokeRestart("muffleWarning")
[13:20:05.030]                       }
[13:20:05.030]                       else if (inherits(cond, "condition")) {
[13:20:05.030]                         if (!is.null(pattern)) {
[13:20:05.030]                           computeRestarts <- base::computeRestarts
[13:20:05.030]                           grepl <- base::grepl
[13:20:05.030]                           restarts <- computeRestarts(cond)
[13:20:05.030]                           for (restart in restarts) {
[13:20:05.030]                             name <- restart$name
[13:20:05.030]                             if (is.null(name)) 
[13:20:05.030]                               next
[13:20:05.030]                             if (!grepl(pattern, name)) 
[13:20:05.030]                               next
[13:20:05.030]                             invokeRestart(restart)
[13:20:05.030]                             muffled <- TRUE
[13:20:05.030]                             break
[13:20:05.030]                           }
[13:20:05.030]                         }
[13:20:05.030]                       }
[13:20:05.030]                       invisible(muffled)
[13:20:05.030]                     }
[13:20:05.030]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.030]                   }
[13:20:05.030]                 }
[13:20:05.030]             }
[13:20:05.030]         }))
[13:20:05.030]     }, error = function(ex) {
[13:20:05.030]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.030]                 ...future.rng), started = ...future.startTime, 
[13:20:05.030]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.030]             version = "1.8"), class = "FutureResult")
[13:20:05.030]     }, finally = {
[13:20:05.030]         if (!identical(...future.workdir, getwd())) 
[13:20:05.030]             setwd(...future.workdir)
[13:20:05.030]         {
[13:20:05.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.030]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.030]             }
[13:20:05.030]             base::options(...future.oldOptions)
[13:20:05.030]             if (.Platform$OS.type == "windows") {
[13:20:05.030]                 old_names <- names(...future.oldEnvVars)
[13:20:05.030]                 envs <- base::Sys.getenv()
[13:20:05.030]                 names <- names(envs)
[13:20:05.030]                 common <- intersect(names, old_names)
[13:20:05.030]                 added <- setdiff(names, old_names)
[13:20:05.030]                 removed <- setdiff(old_names, names)
[13:20:05.030]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.030]                   envs[common]]
[13:20:05.030]                 NAMES <- toupper(changed)
[13:20:05.030]                 args <- list()
[13:20:05.030]                 for (kk in seq_along(NAMES)) {
[13:20:05.030]                   name <- changed[[kk]]
[13:20:05.030]                   NAME <- NAMES[[kk]]
[13:20:05.030]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.030]                     next
[13:20:05.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.030]                 }
[13:20:05.030]                 NAMES <- toupper(added)
[13:20:05.030]                 for (kk in seq_along(NAMES)) {
[13:20:05.030]                   name <- added[[kk]]
[13:20:05.030]                   NAME <- NAMES[[kk]]
[13:20:05.030]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.030]                     next
[13:20:05.030]                   args[[name]] <- ""
[13:20:05.030]                 }
[13:20:05.030]                 NAMES <- toupper(removed)
[13:20:05.030]                 for (kk in seq_along(NAMES)) {
[13:20:05.030]                   name <- removed[[kk]]
[13:20:05.030]                   NAME <- NAMES[[kk]]
[13:20:05.030]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.030]                     next
[13:20:05.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.030]                 }
[13:20:05.030]                 if (length(args) > 0) 
[13:20:05.030]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.030]             }
[13:20:05.030]             else {
[13:20:05.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.030]             }
[13:20:05.030]             {
[13:20:05.030]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.030]                   0L) {
[13:20:05.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.030]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.030]                   base::options(opts)
[13:20:05.030]                 }
[13:20:05.030]                 {
[13:20:05.030]                   {
[13:20:05.030]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.030]                     NULL
[13:20:05.030]                   }
[13:20:05.030]                   options(future.plan = NULL)
[13:20:05.030]                   if (is.na(NA_character_)) 
[13:20:05.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.030]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:05.030]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:05.030]                     envir = parent.frame()) 
[13:20:05.030]                   {
[13:20:05.030]                     if (is.function(workers)) 
[13:20:05.030]                       workers <- workers()
[13:20:05.030]                     workers <- structure(as.integer(workers), 
[13:20:05.030]                       class = class(workers))
[13:20:05.030]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:05.030]                       workers >= 1)
[13:20:05.030]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:05.030]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:05.030]                     }
[13:20:05.030]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:05.030]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:05.030]                       envir = envir)
[13:20:05.030]                     if (!future$lazy) 
[13:20:05.030]                       future <- run(future)
[13:20:05.030]                     invisible(future)
[13:20:05.030]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.030]                 }
[13:20:05.030]             }
[13:20:05.030]         }
[13:20:05.030]     })
[13:20:05.030]     if (TRUE) {
[13:20:05.030]         base::sink(type = "output", split = FALSE)
[13:20:05.030]         if (TRUE) {
[13:20:05.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.030]         }
[13:20:05.030]         else {
[13:20:05.030]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.030]         }
[13:20:05.030]         base::close(...future.stdout)
[13:20:05.030]         ...future.stdout <- NULL
[13:20:05.030]     }
[13:20:05.030]     ...future.result$conditions <- ...future.conditions
[13:20:05.030]     ...future.result$finished <- base::Sys.time()
[13:20:05.030]     ...future.result
[13:20:05.030] }
[13:20:05.033] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[13:20:05.033] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[13:20:05.033] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[13:20:05.033] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[13:20:05.033] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[13:20:05.034] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[13:20:05.034] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[13:20:05.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:05.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.035] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:20:05.035] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:20:05.035] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:05.035] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.035] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:05.036] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.036] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[13:20:05.036] MultisessionFuture started
[13:20:05.036] - Launch lazy future ... done
[13:20:05.037] run() for ‘MultisessionFuture’ ... done
[13:20:05.037] Created future:
[13:20:05.037] MultisessionFuture:
[13:20:05.037] Label: ‘future_by-1’
[13:20:05.037] Expression:
[13:20:05.037] {
[13:20:05.037]     do.call(function(...) {
[13:20:05.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.037]             on.exit(options(oopts), add = TRUE)
[13:20:05.037]         }
[13:20:05.037]         {
[13:20:05.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.037]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.037]             })
[13:20:05.037]         }
[13:20:05.037]     }, args = future.call.arguments)
[13:20:05.037] }
[13:20:05.037] Lazy evaluation: FALSE
[13:20:05.037] Asynchronous evaluation: TRUE
[13:20:05.037] Local evaluation: TRUE
[13:20:05.037] Environment: 0x55acef7d6c38
[13:20:05.037] Capture standard output: TRUE
[13:20:05.037] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.037] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[13:20:05.037] Packages: 1 packages (‘stats’)
[13:20:05.037] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.037] Resolved: FALSE
[13:20:05.037] Value: <not collected>
[13:20:05.037] Conditions captured: <none>
[13:20:05.037] Early signaling: FALSE
[13:20:05.037] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:05.037] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.049] Chunk #1 of 2 ... DONE
[13:20:05.049] Chunk #2 of 2 ...
[13:20:05.049]  - Finding globals in 'X' for chunk #2 ...
[13:20:05.049] getGlobalsAndPackages() ...
[13:20:05.049] Searching for globals...
[13:20:05.049] 
[13:20:05.050] Searching for globals ... DONE
[13:20:05.050] - globals: [0] <none>
[13:20:05.050] getGlobalsAndPackages() ... DONE
[13:20:05.050]    + additional globals found: [n=0] 
[13:20:05.050]    + additional namespaces needed: [n=0] 
[13:20:05.050]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:05.050]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.050]  - seeds: <none>
[13:20:05.050]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.050] getGlobalsAndPackages() ...
[13:20:05.051] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.051] Resolving globals: FALSE
[13:20:05.051] Tweak future expression to call with '...' arguments ...
[13:20:05.051] {
[13:20:05.051]     do.call(function(...) {
[13:20:05.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.051]             on.exit(options(oopts), add = TRUE)
[13:20:05.051]         }
[13:20:05.051]         {
[13:20:05.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.051]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.051]             })
[13:20:05.051]         }
[13:20:05.051]     }, args = future.call.arguments)
[13:20:05.051] }
[13:20:05.051] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.052] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.052] 
[13:20:05.052] getGlobalsAndPackages() ... DONE
[13:20:05.052] run() for ‘Future’ ...
[13:20:05.052] - state: ‘created’
[13:20:05.052] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:05.066]   - Field: ‘node’
[13:20:05.066]   - Field: ‘label’
[13:20:05.066]   - Field: ‘local’
[13:20:05.067]   - Field: ‘owner’
[13:20:05.067]   - Field: ‘envir’
[13:20:05.067]   - Field: ‘workers’
[13:20:05.067]   - Field: ‘packages’
[13:20:05.067]   - Field: ‘gc’
[13:20:05.067]   - Field: ‘conditions’
[13:20:05.067]   - Field: ‘persistent’
[13:20:05.067]   - Field: ‘expr’
[13:20:05.067]   - Field: ‘uuid’
[13:20:05.067]   - Field: ‘seed’
[13:20:05.067]   - Field: ‘version’
[13:20:05.068]   - Field: ‘result’
[13:20:05.068]   - Field: ‘asynchronous’
[13:20:05.068]   - Field: ‘calls’
[13:20:05.068]   - Field: ‘globals’
[13:20:05.068]   - Field: ‘stdout’
[13:20:05.068]   - Field: ‘earlySignal’
[13:20:05.068]   - Field: ‘lazy’
[13:20:05.068]   - Field: ‘state’
[13:20:05.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:05.068] - Launch lazy future ...
[13:20:05.069] Packages needed by the future expression (n = 1): ‘stats’
[13:20:05.069] Packages needed by future strategies (n = 0): <none>
[13:20:05.069] {
[13:20:05.069]     {
[13:20:05.069]         {
[13:20:05.069]             ...future.startTime <- base::Sys.time()
[13:20:05.069]             {
[13:20:05.069]                 {
[13:20:05.069]                   {
[13:20:05.069]                     {
[13:20:05.069]                       {
[13:20:05.069]                         base::local({
[13:20:05.069]                           has_future <- base::requireNamespace("future", 
[13:20:05.069]                             quietly = TRUE)
[13:20:05.069]                           if (has_future) {
[13:20:05.069]                             ns <- base::getNamespace("future")
[13:20:05.069]                             version <- ns[[".package"]][["version"]]
[13:20:05.069]                             if (is.null(version)) 
[13:20:05.069]                               version <- utils::packageVersion("future")
[13:20:05.069]                           }
[13:20:05.069]                           else {
[13:20:05.069]                             version <- NULL
[13:20:05.069]                           }
[13:20:05.069]                           if (!has_future || version < "1.8.0") {
[13:20:05.069]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.069]                               "", base::R.version$version.string), 
[13:20:05.069]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:05.069]                                 base::R.version$platform, 8 * 
[13:20:05.069]                                   base::.Machine$sizeof.pointer), 
[13:20:05.069]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.069]                                 "release", "version")], collapse = " "), 
[13:20:05.069]                               hostname = base::Sys.info()[["nodename"]])
[13:20:05.069]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.069]                               info)
[13:20:05.069]                             info <- base::paste(info, collapse = "; ")
[13:20:05.069]                             if (!has_future) {
[13:20:05.069]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.069]                                 info)
[13:20:05.069]                             }
[13:20:05.069]                             else {
[13:20:05.069]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.069]                                 info, version)
[13:20:05.069]                             }
[13:20:05.069]                             base::stop(msg)
[13:20:05.069]                           }
[13:20:05.069]                         })
[13:20:05.069]                       }
[13:20:05.069]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.069]                       base::options(mc.cores = 1L)
[13:20:05.069]                     }
[13:20:05.069]                     base::local({
[13:20:05.069]                       for (pkg in "stats") {
[13:20:05.069]                         base::loadNamespace(pkg)
[13:20:05.069]                         base::library(pkg, character.only = TRUE)
[13:20:05.069]                       }
[13:20:05.069]                     })
[13:20:05.069]                   }
[13:20:05.069]                   options(future.plan = NULL)
[13:20:05.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.069]                 }
[13:20:05.069]                 ...future.workdir <- getwd()
[13:20:05.069]             }
[13:20:05.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.069]         }
[13:20:05.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.069]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.069]             base::names(...future.oldOptions))
[13:20:05.069]     }
[13:20:05.069]     if (FALSE) {
[13:20:05.069]     }
[13:20:05.069]     else {
[13:20:05.069]         if (TRUE) {
[13:20:05.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.069]                 open = "w")
[13:20:05.069]         }
[13:20:05.069]         else {
[13:20:05.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.069]         }
[13:20:05.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.069]             base::sink(type = "output", split = FALSE)
[13:20:05.069]             base::close(...future.stdout)
[13:20:05.069]         }, add = TRUE)
[13:20:05.069]     }
[13:20:05.069]     ...future.frame <- base::sys.nframe()
[13:20:05.069]     ...future.conditions <- base::list()
[13:20:05.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.069]     if (FALSE) {
[13:20:05.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.069]     }
[13:20:05.069]     ...future.result <- base::tryCatch({
[13:20:05.069]         base::withCallingHandlers({
[13:20:05.069]             ...future.value <- base::withVisible(base::local({
[13:20:05.069]                 ...future.makeSendCondition <- base::local({
[13:20:05.069]                   sendCondition <- NULL
[13:20:05.069]                   function(frame = 1L) {
[13:20:05.069]                     if (is.function(sendCondition)) 
[13:20:05.069]                       return(sendCondition)
[13:20:05.069]                     ns <- getNamespace("parallel")
[13:20:05.069]                     if (exists("sendData", mode = "function", 
[13:20:05.069]                       envir = ns)) {
[13:20:05.069]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:05.069]                         envir = ns)
[13:20:05.069]                       envir <- sys.frame(frame)
[13:20:05.069]                       master <- NULL
[13:20:05.069]                       while (!identical(envir, .GlobalEnv) && 
[13:20:05.069]                         !identical(envir, emptyenv())) {
[13:20:05.069]                         if (exists("master", mode = "list", envir = envir, 
[13:20:05.069]                           inherits = FALSE)) {
[13:20:05.069]                           master <- get("master", mode = "list", 
[13:20:05.069]                             envir = envir, inherits = FALSE)
[13:20:05.069]                           if (inherits(master, c("SOCKnode", 
[13:20:05.069]                             "SOCK0node"))) {
[13:20:05.069]                             sendCondition <<- function(cond) {
[13:20:05.069]                               data <- list(type = "VALUE", value = cond, 
[13:20:05.069]                                 success = TRUE)
[13:20:05.069]                               parallel_sendData(master, data)
[13:20:05.069]                             }
[13:20:05.069]                             return(sendCondition)
[13:20:05.069]                           }
[13:20:05.069]                         }
[13:20:05.069]                         frame <- frame + 1L
[13:20:05.069]                         envir <- sys.frame(frame)
[13:20:05.069]                       }
[13:20:05.069]                     }
[13:20:05.069]                     sendCondition <<- function(cond) NULL
[13:20:05.069]                   }
[13:20:05.069]                 })
[13:20:05.069]                 withCallingHandlers({
[13:20:05.069]                   {
[13:20:05.069]                     do.call(function(...) {
[13:20:05.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.069]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.069]                         ...future.globals.maxSize)) {
[13:20:05.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.069]                         on.exit(options(oopts), add = TRUE)
[13:20:05.069]                       }
[13:20:05.069]                       {
[13:20:05.069]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.069]                           FUN = function(jj) {
[13:20:05.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.069]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.069]                           })
[13:20:05.069]                       }
[13:20:05.069]                     }, args = future.call.arguments)
[13:20:05.069]                   }
[13:20:05.069]                 }, immediateCondition = function(cond) {
[13:20:05.069]                   sendCondition <- ...future.makeSendCondition()
[13:20:05.069]                   sendCondition(cond)
[13:20:05.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.069]                   {
[13:20:05.069]                     inherits <- base::inherits
[13:20:05.069]                     invokeRestart <- base::invokeRestart
[13:20:05.069]                     is.null <- base::is.null
[13:20:05.069]                     muffled <- FALSE
[13:20:05.069]                     if (inherits(cond, "message")) {
[13:20:05.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.069]                       if (muffled) 
[13:20:05.069]                         invokeRestart("muffleMessage")
[13:20:05.069]                     }
[13:20:05.069]                     else if (inherits(cond, "warning")) {
[13:20:05.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.069]                       if (muffled) 
[13:20:05.069]                         invokeRestart("muffleWarning")
[13:20:05.069]                     }
[13:20:05.069]                     else if (inherits(cond, "condition")) {
[13:20:05.069]                       if (!is.null(pattern)) {
[13:20:05.069]                         computeRestarts <- base::computeRestarts
[13:20:05.069]                         grepl <- base::grepl
[13:20:05.069]                         restarts <- computeRestarts(cond)
[13:20:05.069]                         for (restart in restarts) {
[13:20:05.069]                           name <- restart$name
[13:20:05.069]                           if (is.null(name)) 
[13:20:05.069]                             next
[13:20:05.069]                           if (!grepl(pattern, name)) 
[13:20:05.069]                             next
[13:20:05.069]                           invokeRestart(restart)
[13:20:05.069]                           muffled <- TRUE
[13:20:05.069]                           break
[13:20:05.069]                         }
[13:20:05.069]                       }
[13:20:05.069]                     }
[13:20:05.069]                     invisible(muffled)
[13:20:05.069]                   }
[13:20:05.069]                   muffleCondition(cond)
[13:20:05.069]                 })
[13:20:05.069]             }))
[13:20:05.069]             future::FutureResult(value = ...future.value$value, 
[13:20:05.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.069]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.069]                     ...future.globalenv.names))
[13:20:05.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.069]         }, condition = base::local({
[13:20:05.069]             c <- base::c
[13:20:05.069]             inherits <- base::inherits
[13:20:05.069]             invokeRestart <- base::invokeRestart
[13:20:05.069]             length <- base::length
[13:20:05.069]             list <- base::list
[13:20:05.069]             seq.int <- base::seq.int
[13:20:05.069]             signalCondition <- base::signalCondition
[13:20:05.069]             sys.calls <- base::sys.calls
[13:20:05.069]             `[[` <- base::`[[`
[13:20:05.069]             `+` <- base::`+`
[13:20:05.069]             `<<-` <- base::`<<-`
[13:20:05.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.069]                   3L)]
[13:20:05.069]             }
[13:20:05.069]             function(cond) {
[13:20:05.069]                 is_error <- inherits(cond, "error")
[13:20:05.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.069]                   NULL)
[13:20:05.069]                 if (is_error) {
[13:20:05.069]                   sessionInformation <- function() {
[13:20:05.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.069]                       search = base::search(), system = base::Sys.info())
[13:20:05.069]                   }
[13:20:05.069]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.069]                     cond$call), session = sessionInformation(), 
[13:20:05.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.069]                   signalCondition(cond)
[13:20:05.069]                 }
[13:20:05.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.069]                 "immediateCondition"))) {
[13:20:05.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.069]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.069]                   if (TRUE && !signal) {
[13:20:05.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.069]                     {
[13:20:05.069]                       inherits <- base::inherits
[13:20:05.069]                       invokeRestart <- base::invokeRestart
[13:20:05.069]                       is.null <- base::is.null
[13:20:05.069]                       muffled <- FALSE
[13:20:05.069]                       if (inherits(cond, "message")) {
[13:20:05.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.069]                         if (muffled) 
[13:20:05.069]                           invokeRestart("muffleMessage")
[13:20:05.069]                       }
[13:20:05.069]                       else if (inherits(cond, "warning")) {
[13:20:05.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.069]                         if (muffled) 
[13:20:05.069]                           invokeRestart("muffleWarning")
[13:20:05.069]                       }
[13:20:05.069]                       else if (inherits(cond, "condition")) {
[13:20:05.069]                         if (!is.null(pattern)) {
[13:20:05.069]                           computeRestarts <- base::computeRestarts
[13:20:05.069]                           grepl <- base::grepl
[13:20:05.069]                           restarts <- computeRestarts(cond)
[13:20:05.069]                           for (restart in restarts) {
[13:20:05.069]                             name <- restart$name
[13:20:05.069]                             if (is.null(name)) 
[13:20:05.069]                               next
[13:20:05.069]                             if (!grepl(pattern, name)) 
[13:20:05.069]                               next
[13:20:05.069]                             invokeRestart(restart)
[13:20:05.069]                             muffled <- TRUE
[13:20:05.069]                             break
[13:20:05.069]                           }
[13:20:05.069]                         }
[13:20:05.069]                       }
[13:20:05.069]                       invisible(muffled)
[13:20:05.069]                     }
[13:20:05.069]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.069]                   }
[13:20:05.069]                 }
[13:20:05.069]                 else {
[13:20:05.069]                   if (TRUE) {
[13:20:05.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.069]                     {
[13:20:05.069]                       inherits <- base::inherits
[13:20:05.069]                       invokeRestart <- base::invokeRestart
[13:20:05.069]                       is.null <- base::is.null
[13:20:05.069]                       muffled <- FALSE
[13:20:05.069]                       if (inherits(cond, "message")) {
[13:20:05.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.069]                         if (muffled) 
[13:20:05.069]                           invokeRestart("muffleMessage")
[13:20:05.069]                       }
[13:20:05.069]                       else if (inherits(cond, "warning")) {
[13:20:05.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.069]                         if (muffled) 
[13:20:05.069]                           invokeRestart("muffleWarning")
[13:20:05.069]                       }
[13:20:05.069]                       else if (inherits(cond, "condition")) {
[13:20:05.069]                         if (!is.null(pattern)) {
[13:20:05.069]                           computeRestarts <- base::computeRestarts
[13:20:05.069]                           grepl <- base::grepl
[13:20:05.069]                           restarts <- computeRestarts(cond)
[13:20:05.069]                           for (restart in restarts) {
[13:20:05.069]                             name <- restart$name
[13:20:05.069]                             if (is.null(name)) 
[13:20:05.069]                               next
[13:20:05.069]                             if (!grepl(pattern, name)) 
[13:20:05.069]                               next
[13:20:05.069]                             invokeRestart(restart)
[13:20:05.069]                             muffled <- TRUE
[13:20:05.069]                             break
[13:20:05.069]                           }
[13:20:05.069]                         }
[13:20:05.069]                       }
[13:20:05.069]                       invisible(muffled)
[13:20:05.069]                     }
[13:20:05.069]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.069]                   }
[13:20:05.069]                 }
[13:20:05.069]             }
[13:20:05.069]         }))
[13:20:05.069]     }, error = function(ex) {
[13:20:05.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.069]                 ...future.rng), started = ...future.startTime, 
[13:20:05.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.069]             version = "1.8"), class = "FutureResult")
[13:20:05.069]     }, finally = {
[13:20:05.069]         if (!identical(...future.workdir, getwd())) 
[13:20:05.069]             setwd(...future.workdir)
[13:20:05.069]         {
[13:20:05.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.069]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.069]             }
[13:20:05.069]             base::options(...future.oldOptions)
[13:20:05.069]             if (.Platform$OS.type == "windows") {
[13:20:05.069]                 old_names <- names(...future.oldEnvVars)
[13:20:05.069]                 envs <- base::Sys.getenv()
[13:20:05.069]                 names <- names(envs)
[13:20:05.069]                 common <- intersect(names, old_names)
[13:20:05.069]                 added <- setdiff(names, old_names)
[13:20:05.069]                 removed <- setdiff(old_names, names)
[13:20:05.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.069]                   envs[common]]
[13:20:05.069]                 NAMES <- toupper(changed)
[13:20:05.069]                 args <- list()
[13:20:05.069]                 for (kk in seq_along(NAMES)) {
[13:20:05.069]                   name <- changed[[kk]]
[13:20:05.069]                   NAME <- NAMES[[kk]]
[13:20:05.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.069]                     next
[13:20:05.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.069]                 }
[13:20:05.069]                 NAMES <- toupper(added)
[13:20:05.069]                 for (kk in seq_along(NAMES)) {
[13:20:05.069]                   name <- added[[kk]]
[13:20:05.069]                   NAME <- NAMES[[kk]]
[13:20:05.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.069]                     next
[13:20:05.069]                   args[[name]] <- ""
[13:20:05.069]                 }
[13:20:05.069]                 NAMES <- toupper(removed)
[13:20:05.069]                 for (kk in seq_along(NAMES)) {
[13:20:05.069]                   name <- removed[[kk]]
[13:20:05.069]                   NAME <- NAMES[[kk]]
[13:20:05.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.069]                     next
[13:20:05.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.069]                 }
[13:20:05.069]                 if (length(args) > 0) 
[13:20:05.069]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.069]             }
[13:20:05.069]             else {
[13:20:05.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.069]             }
[13:20:05.069]             {
[13:20:05.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.069]                   0L) {
[13:20:05.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.069]                   base::options(opts)
[13:20:05.069]                 }
[13:20:05.069]                 {
[13:20:05.069]                   {
[13:20:05.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.069]                     NULL
[13:20:05.069]                   }
[13:20:05.069]                   options(future.plan = NULL)
[13:20:05.069]                   if (is.na(NA_character_)) 
[13:20:05.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.069]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:05.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:05.069]                     envir = parent.frame()) 
[13:20:05.069]                   {
[13:20:05.069]                     if (is.function(workers)) 
[13:20:05.069]                       workers <- workers()
[13:20:05.069]                     workers <- structure(as.integer(workers), 
[13:20:05.069]                       class = class(workers))
[13:20:05.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:05.069]                       workers >= 1)
[13:20:05.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:05.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:05.069]                     }
[13:20:05.069]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:05.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:05.069]                       envir = envir)
[13:20:05.069]                     if (!future$lazy) 
[13:20:05.069]                       future <- run(future)
[13:20:05.069]                     invisible(future)
[13:20:05.069]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.069]                 }
[13:20:05.069]             }
[13:20:05.069]         }
[13:20:05.069]     })
[13:20:05.069]     if (TRUE) {
[13:20:05.069]         base::sink(type = "output", split = FALSE)
[13:20:05.069]         if (TRUE) {
[13:20:05.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.069]         }
[13:20:05.069]         else {
[13:20:05.069]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.069]         }
[13:20:05.069]         base::close(...future.stdout)
[13:20:05.069]         ...future.stdout <- NULL
[13:20:05.069]     }
[13:20:05.069]     ...future.result$conditions <- ...future.conditions
[13:20:05.069]     ...future.result$finished <- base::Sys.time()
[13:20:05.069]     ...future.result
[13:20:05.069] }
[13:20:05.072] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[13:20:05.073] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[13:20:05.073] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[13:20:05.073] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[13:20:05.073] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[13:20:05.073] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[13:20:05.074] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[13:20:05.074] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:05.074] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.075] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:20:05.075] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:20:05.075] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:05.075] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.075] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:05.076] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.076] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[13:20:05.076] MultisessionFuture started
[13:20:05.076] - Launch lazy future ... done
[13:20:05.077] run() for ‘MultisessionFuture’ ... done
[13:20:05.077] Created future:
[13:20:05.077] MultisessionFuture:
[13:20:05.077] Label: ‘future_by-2’
[13:20:05.077] Expression:
[13:20:05.077] {
[13:20:05.077]     do.call(function(...) {
[13:20:05.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.077]             on.exit(options(oopts), add = TRUE)
[13:20:05.077]         }
[13:20:05.077]         {
[13:20:05.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.077]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.077]             })
[13:20:05.077]         }
[13:20:05.077]     }, args = future.call.arguments)
[13:20:05.077] }
[13:20:05.077] Lazy evaluation: FALSE
[13:20:05.077] Asynchronous evaluation: TRUE
[13:20:05.077] Local evaluation: TRUE
[13:20:05.077] Environment: 0x55acef7d6c38
[13:20:05.077] Capture standard output: TRUE
[13:20:05.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.077] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[13:20:05.077] Packages: 1 packages (‘stats’)
[13:20:05.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.077] Resolved: FALSE
[13:20:05.077] Value: <not collected>
[13:20:05.077] Conditions captured: <none>
[13:20:05.077] Early signaling: FALSE
[13:20:05.077] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:05.077] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.089] Chunk #2 of 2 ... DONE
[13:20:05.089] Launching 2 futures (chunks) ... DONE
[13:20:05.089] Resolving 2 futures (chunks) ...
[13:20:05.089] resolve() on list ...
[13:20:05.089]  recursive: 0
[13:20:05.089]  length: 2
[13:20:05.089] 
[13:20:05.090] receiveMessageFromWorker() for ClusterFuture ...
[13:20:05.090] - Validating connection of MultisessionFuture
[13:20:05.090] - received message: FutureResult
[13:20:05.090] - Received FutureResult
[13:20:05.090] - Erased future from FutureRegistry
[13:20:05.090] result() for ClusterFuture ...
[13:20:05.091] - result already collected: FutureResult
[13:20:05.091] result() for ClusterFuture ... done
[13:20:05.091] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:05.091] Future #1
[13:20:05.091] result() for ClusterFuture ...
[13:20:05.091] - result already collected: FutureResult
[13:20:05.091] result() for ClusterFuture ... done
[13:20:05.091] result() for ClusterFuture ...
[13:20:05.091] - result already collected: FutureResult
[13:20:05.091] result() for ClusterFuture ... done
[13:20:05.091] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:05.092] - nx: 2
[13:20:05.092] - relay: TRUE
[13:20:05.092] - stdout: TRUE
[13:20:05.092] - signal: TRUE
[13:20:05.092] - resignal: FALSE
[13:20:05.092] - force: TRUE
[13:20:05.092] - relayed: [n=2] FALSE, FALSE
[13:20:05.092] - queued futures: [n=2] FALSE, FALSE
[13:20:05.092]  - until=1
[13:20:05.092]  - relaying element #1
[13:20:05.092] result() for ClusterFuture ...
[13:20:05.092] - result already collected: FutureResult
[13:20:05.093] result() for ClusterFuture ... done
[13:20:05.093] result() for ClusterFuture ...
[13:20:05.093] - result already collected: FutureResult
[13:20:05.093] result() for ClusterFuture ... done
[13:20:05.093] result() for ClusterFuture ...
[13:20:05.093] - result already collected: FutureResult
[13:20:05.093] result() for ClusterFuture ... done
[13:20:05.093] result() for ClusterFuture ...
[13:20:05.093] - result already collected: FutureResult
[13:20:05.093] result() for ClusterFuture ... done
[13:20:05.093] - relayed: [n=2] TRUE, FALSE
[13:20:05.094] - queued futures: [n=2] TRUE, FALSE
[13:20:05.094] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:05.094]  length: 1 (resolved future 1)
[13:20:05.136] receiveMessageFromWorker() for ClusterFuture ...
[13:20:05.136] - Validating connection of MultisessionFuture
[13:20:05.136] - received message: FutureResult
[13:20:05.136] - Received FutureResult
[13:20:05.137] - Erased future from FutureRegistry
[13:20:05.137] result() for ClusterFuture ...
[13:20:05.137] - result already collected: FutureResult
[13:20:05.137] result() for ClusterFuture ... done
[13:20:05.137] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:05.137] Future #2
[13:20:05.137] result() for ClusterFuture ...
[13:20:05.137] - result already collected: FutureResult
[13:20:05.137] result() for ClusterFuture ... done
[13:20:05.137] result() for ClusterFuture ...
[13:20:05.138] - result already collected: FutureResult
[13:20:05.138] result() for ClusterFuture ... done
[13:20:05.138] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:05.138] - nx: 2
[13:20:05.138] - relay: TRUE
[13:20:05.138] - stdout: TRUE
[13:20:05.138] - signal: TRUE
[13:20:05.138] - resignal: FALSE
[13:20:05.138] - force: TRUE
[13:20:05.138] - relayed: [n=2] TRUE, FALSE
[13:20:05.138] - queued futures: [n=2] TRUE, FALSE
[13:20:05.138]  - until=2
[13:20:05.139]  - relaying element #2
[13:20:05.139] result() for ClusterFuture ...
[13:20:05.139] - result already collected: FutureResult
[13:20:05.139] result() for ClusterFuture ... done
[13:20:05.139] result() for ClusterFuture ...
[13:20:05.139] - result already collected: FutureResult
[13:20:05.139] result() for ClusterFuture ... done
[13:20:05.139] result() for ClusterFuture ...
[13:20:05.139] - result already collected: FutureResult
[13:20:05.139] result() for ClusterFuture ... done
[13:20:05.139] result() for ClusterFuture ...
[13:20:05.140] - result already collected: FutureResult
[13:20:05.140] result() for ClusterFuture ... done
[13:20:05.140] - relayed: [n=2] TRUE, TRUE
[13:20:05.140] - queued futures: [n=2] TRUE, TRUE
[13:20:05.140] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:05.140]  length: 0 (resolved future 2)
[13:20:05.140] Relaying remaining futures
[13:20:05.140] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.140] - nx: 2
[13:20:05.140] - relay: TRUE
[13:20:05.140] - stdout: TRUE
[13:20:05.140] - signal: TRUE
[13:20:05.141] - resignal: FALSE
[13:20:05.141] - force: TRUE
[13:20:05.141] - relayed: [n=2] TRUE, TRUE
[13:20:05.141] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:05.141] - relayed: [n=2] TRUE, TRUE
[13:20:05.141] - queued futures: [n=2] TRUE, TRUE
[13:20:05.141] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.141] resolve() on list ... DONE
[13:20:05.141] result() for ClusterFuture ...
[13:20:05.141] - result already collected: FutureResult
[13:20:05.141] result() for ClusterFuture ... done
[13:20:05.142] result() for ClusterFuture ...
[13:20:05.142] - result already collected: FutureResult
[13:20:05.142] result() for ClusterFuture ... done
[13:20:05.142] result() for ClusterFuture ...
[13:20:05.142] - result already collected: FutureResult
[13:20:05.142] result() for ClusterFuture ... done
[13:20:05.142] result() for ClusterFuture ...
[13:20:05.142] - result already collected: FutureResult
[13:20:05.142] result() for ClusterFuture ... done
[13:20:05.142]  - Number of value chunks collected: 2
[13:20:05.142] Resolving 2 futures (chunks) ... DONE
[13:20:05.143] Reducing values from 2 chunks ...
[13:20:05.143]  - Number of values collected after concatenation: 3
[13:20:05.143]  - Number of values expected: 3
[13:20:05.143] Reducing values from 2 chunks ... DONE
[13:20:05.143] future_lapply() ... DONE
[13:20:05.143] future_by_internal() ... DONE
[13:20:05.143] future_by_internal() ...
[13:20:05.144] future_lapply() ...
[13:20:05.148] Number of chunks: 2
[13:20:05.148] getGlobalsAndPackagesXApply() ...
[13:20:05.148]  - future.globals: TRUE
[13:20:05.148] getGlobalsAndPackages() ...
[13:20:05.148] Searching for globals...
[13:20:05.149] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.149] Searching for globals ... DONE
[13:20:05.150] Resolving globals: FALSE
[13:20:05.150] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:05.150] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:05.150] - globals: [1] ‘FUN’
[13:20:05.150] 
[13:20:05.151] getGlobalsAndPackages() ... DONE
[13:20:05.151]  - globals found/used: [n=1] ‘FUN’
[13:20:05.151]  - needed namespaces: [n=0] 
[13:20:05.151] Finding globals ... DONE
[13:20:05.151]  - use_args: TRUE
[13:20:05.151]  - Getting '...' globals ...
[13:20:05.151] resolve() on list ...
[13:20:05.151]  recursive: 0
[13:20:05.151]  length: 1
[13:20:05.152]  elements: ‘...’
[13:20:05.152]  length: 0 (resolved future 1)
[13:20:05.152] resolve() on list ... DONE
[13:20:05.152]    - '...' content: [n=0] 
[13:20:05.152] List of 1
[13:20:05.152]  $ ...: list()
[13:20:05.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.152]  - attr(*, "where")=List of 1
[13:20:05.152]   ..$ ...:<environment: 0x55acefe17ce8> 
[13:20:05.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.152]  - attr(*, "resolved")= logi TRUE
[13:20:05.152]  - attr(*, "total_size")= num NA
[13:20:05.154]  - Getting '...' globals ... DONE
[13:20:05.155] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.155] List of 2
[13:20:05.155]  $ ...future.FUN:function (object, ...)  
[13:20:05.155]  $ ...          : list()
[13:20:05.155]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.155]  - attr(*, "where")=List of 2
[13:20:05.155]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.155]   ..$ ...          :<environment: 0x55acefe17ce8> 
[13:20:05.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.155]  - attr(*, "resolved")= logi FALSE
[13:20:05.155]  - attr(*, "total_size")= num 1240
[13:20:05.157] Packages to be attached in all futures: [n=0] 
[13:20:05.157] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.158] Number of futures (= number of chunks): 2
[13:20:05.158] Launching 2 futures (chunks) ...
[13:20:05.158] Chunk #1 of 2 ...
[13:20:05.158]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.158] getGlobalsAndPackages() ...
[13:20:05.158] Searching for globals...
[13:20:05.158] 
[13:20:05.159] Searching for globals ... DONE
[13:20:05.159] - globals: [0] <none>
[13:20:05.159] getGlobalsAndPackages() ... DONE
[13:20:05.159]    + additional globals found: [n=0] 
[13:20:05.159]    + additional namespaces needed: [n=0] 
[13:20:05.159]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.159]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.159]  - seeds: <none>
[13:20:05.159]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.159] getGlobalsAndPackages() ...
[13:20:05.159] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.160] Resolving globals: FALSE
[13:20:05.160] Tweak future expression to call with '...' arguments ...
[13:20:05.160] {
[13:20:05.160]     do.call(function(...) {
[13:20:05.160]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.160]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.160]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.160]             on.exit(options(oopts), add = TRUE)
[13:20:05.160]         }
[13:20:05.160]         {
[13:20:05.160]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.160]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.160]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.160]             })
[13:20:05.160]         }
[13:20:05.160]     }, args = future.call.arguments)
[13:20:05.160] }
[13:20:05.160] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.160] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.161] 
[13:20:05.161] getGlobalsAndPackages() ... DONE
[13:20:05.161] run() for ‘Future’ ...
[13:20:05.161] - state: ‘created’
[13:20:05.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:05.175]   - Field: ‘node’
[13:20:05.175]   - Field: ‘label’
[13:20:05.176]   - Field: ‘local’
[13:20:05.176]   - Field: ‘owner’
[13:20:05.176]   - Field: ‘envir’
[13:20:05.176]   - Field: ‘workers’
[13:20:05.176]   - Field: ‘packages’
[13:20:05.176]   - Field: ‘gc’
[13:20:05.176]   - Field: ‘conditions’
[13:20:05.176]   - Field: ‘persistent’
[13:20:05.176]   - Field: ‘expr’
[13:20:05.176]   - Field: ‘uuid’
[13:20:05.176]   - Field: ‘seed’
[13:20:05.177]   - Field: ‘version’
[13:20:05.177]   - Field: ‘result’
[13:20:05.177]   - Field: ‘asynchronous’
[13:20:05.177]   - Field: ‘calls’
[13:20:05.177]   - Field: ‘globals’
[13:20:05.177]   - Field: ‘stdout’
[13:20:05.177]   - Field: ‘earlySignal’
[13:20:05.177]   - Field: ‘lazy’
[13:20:05.177]   - Field: ‘state’
[13:20:05.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:05.177] - Launch lazy future ...
[13:20:05.178] Packages needed by the future expression (n = 0): <none>
[13:20:05.178] Packages needed by future strategies (n = 0): <none>
[13:20:05.178] {
[13:20:05.178]     {
[13:20:05.178]         {
[13:20:05.178]             ...future.startTime <- base::Sys.time()
[13:20:05.178]             {
[13:20:05.178]                 {
[13:20:05.178]                   {
[13:20:05.178]                     {
[13:20:05.178]                       base::local({
[13:20:05.178]                         has_future <- base::requireNamespace("future", 
[13:20:05.178]                           quietly = TRUE)
[13:20:05.178]                         if (has_future) {
[13:20:05.178]                           ns <- base::getNamespace("future")
[13:20:05.178]                           version <- ns[[".package"]][["version"]]
[13:20:05.178]                           if (is.null(version)) 
[13:20:05.178]                             version <- utils::packageVersion("future")
[13:20:05.178]                         }
[13:20:05.178]                         else {
[13:20:05.178]                           version <- NULL
[13:20:05.178]                         }
[13:20:05.178]                         if (!has_future || version < "1.8.0") {
[13:20:05.178]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.178]                             "", base::R.version$version.string), 
[13:20:05.178]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.178]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.178]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.178]                               "release", "version")], collapse = " "), 
[13:20:05.178]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.178]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.178]                             info)
[13:20:05.178]                           info <- base::paste(info, collapse = "; ")
[13:20:05.178]                           if (!has_future) {
[13:20:05.178]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.178]                               info)
[13:20:05.178]                           }
[13:20:05.178]                           else {
[13:20:05.178]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.178]                               info, version)
[13:20:05.178]                           }
[13:20:05.178]                           base::stop(msg)
[13:20:05.178]                         }
[13:20:05.178]                       })
[13:20:05.178]                     }
[13:20:05.178]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.178]                     base::options(mc.cores = 1L)
[13:20:05.178]                   }
[13:20:05.178]                   options(future.plan = NULL)
[13:20:05.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.178]                 }
[13:20:05.178]                 ...future.workdir <- getwd()
[13:20:05.178]             }
[13:20:05.178]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.178]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.178]         }
[13:20:05.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.178]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.178]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.178]             base::names(...future.oldOptions))
[13:20:05.178]     }
[13:20:05.178]     if (FALSE) {
[13:20:05.178]     }
[13:20:05.178]     else {
[13:20:05.178]         if (TRUE) {
[13:20:05.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.178]                 open = "w")
[13:20:05.178]         }
[13:20:05.178]         else {
[13:20:05.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.178]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.178]         }
[13:20:05.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.178]             base::sink(type = "output", split = FALSE)
[13:20:05.178]             base::close(...future.stdout)
[13:20:05.178]         }, add = TRUE)
[13:20:05.178]     }
[13:20:05.178]     ...future.frame <- base::sys.nframe()
[13:20:05.178]     ...future.conditions <- base::list()
[13:20:05.178]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.178]     if (FALSE) {
[13:20:05.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.178]     }
[13:20:05.178]     ...future.result <- base::tryCatch({
[13:20:05.178]         base::withCallingHandlers({
[13:20:05.178]             ...future.value <- base::withVisible(base::local({
[13:20:05.178]                 ...future.makeSendCondition <- base::local({
[13:20:05.178]                   sendCondition <- NULL
[13:20:05.178]                   function(frame = 1L) {
[13:20:05.178]                     if (is.function(sendCondition)) 
[13:20:05.178]                       return(sendCondition)
[13:20:05.178]                     ns <- getNamespace("parallel")
[13:20:05.178]                     if (exists("sendData", mode = "function", 
[13:20:05.178]                       envir = ns)) {
[13:20:05.178]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:05.178]                         envir = ns)
[13:20:05.178]                       envir <- sys.frame(frame)
[13:20:05.178]                       master <- NULL
[13:20:05.178]                       while (!identical(envir, .GlobalEnv) && 
[13:20:05.178]                         !identical(envir, emptyenv())) {
[13:20:05.178]                         if (exists("master", mode = "list", envir = envir, 
[13:20:05.178]                           inherits = FALSE)) {
[13:20:05.178]                           master <- get("master", mode = "list", 
[13:20:05.178]                             envir = envir, inherits = FALSE)
[13:20:05.178]                           if (inherits(master, c("SOCKnode", 
[13:20:05.178]                             "SOCK0node"))) {
[13:20:05.178]                             sendCondition <<- function(cond) {
[13:20:05.178]                               data <- list(type = "VALUE", value = cond, 
[13:20:05.178]                                 success = TRUE)
[13:20:05.178]                               parallel_sendData(master, data)
[13:20:05.178]                             }
[13:20:05.178]                             return(sendCondition)
[13:20:05.178]                           }
[13:20:05.178]                         }
[13:20:05.178]                         frame <- frame + 1L
[13:20:05.178]                         envir <- sys.frame(frame)
[13:20:05.178]                       }
[13:20:05.178]                     }
[13:20:05.178]                     sendCondition <<- function(cond) NULL
[13:20:05.178]                   }
[13:20:05.178]                 })
[13:20:05.178]                 withCallingHandlers({
[13:20:05.178]                   {
[13:20:05.178]                     do.call(function(...) {
[13:20:05.178]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.178]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.178]                         ...future.globals.maxSize)) {
[13:20:05.178]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.178]                         on.exit(options(oopts), add = TRUE)
[13:20:05.178]                       }
[13:20:05.178]                       {
[13:20:05.178]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.178]                           FUN = function(jj) {
[13:20:05.178]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.178]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.178]                           })
[13:20:05.178]                       }
[13:20:05.178]                     }, args = future.call.arguments)
[13:20:05.178]                   }
[13:20:05.178]                 }, immediateCondition = function(cond) {
[13:20:05.178]                   sendCondition <- ...future.makeSendCondition()
[13:20:05.178]                   sendCondition(cond)
[13:20:05.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.178]                   {
[13:20:05.178]                     inherits <- base::inherits
[13:20:05.178]                     invokeRestart <- base::invokeRestart
[13:20:05.178]                     is.null <- base::is.null
[13:20:05.178]                     muffled <- FALSE
[13:20:05.178]                     if (inherits(cond, "message")) {
[13:20:05.178]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.178]                       if (muffled) 
[13:20:05.178]                         invokeRestart("muffleMessage")
[13:20:05.178]                     }
[13:20:05.178]                     else if (inherits(cond, "warning")) {
[13:20:05.178]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.178]                       if (muffled) 
[13:20:05.178]                         invokeRestart("muffleWarning")
[13:20:05.178]                     }
[13:20:05.178]                     else if (inherits(cond, "condition")) {
[13:20:05.178]                       if (!is.null(pattern)) {
[13:20:05.178]                         computeRestarts <- base::computeRestarts
[13:20:05.178]                         grepl <- base::grepl
[13:20:05.178]                         restarts <- computeRestarts(cond)
[13:20:05.178]                         for (restart in restarts) {
[13:20:05.178]                           name <- restart$name
[13:20:05.178]                           if (is.null(name)) 
[13:20:05.178]                             next
[13:20:05.178]                           if (!grepl(pattern, name)) 
[13:20:05.178]                             next
[13:20:05.178]                           invokeRestart(restart)
[13:20:05.178]                           muffled <- TRUE
[13:20:05.178]                           break
[13:20:05.178]                         }
[13:20:05.178]                       }
[13:20:05.178]                     }
[13:20:05.178]                     invisible(muffled)
[13:20:05.178]                   }
[13:20:05.178]                   muffleCondition(cond)
[13:20:05.178]                 })
[13:20:05.178]             }))
[13:20:05.178]             future::FutureResult(value = ...future.value$value, 
[13:20:05.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.178]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.178]                     ...future.globalenv.names))
[13:20:05.178]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.178]         }, condition = base::local({
[13:20:05.178]             c <- base::c
[13:20:05.178]             inherits <- base::inherits
[13:20:05.178]             invokeRestart <- base::invokeRestart
[13:20:05.178]             length <- base::length
[13:20:05.178]             list <- base::list
[13:20:05.178]             seq.int <- base::seq.int
[13:20:05.178]             signalCondition <- base::signalCondition
[13:20:05.178]             sys.calls <- base::sys.calls
[13:20:05.178]             `[[` <- base::`[[`
[13:20:05.178]             `+` <- base::`+`
[13:20:05.178]             `<<-` <- base::`<<-`
[13:20:05.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.178]                   3L)]
[13:20:05.178]             }
[13:20:05.178]             function(cond) {
[13:20:05.178]                 is_error <- inherits(cond, "error")
[13:20:05.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.178]                   NULL)
[13:20:05.178]                 if (is_error) {
[13:20:05.178]                   sessionInformation <- function() {
[13:20:05.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.178]                       search = base::search(), system = base::Sys.info())
[13:20:05.178]                   }
[13:20:05.178]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.178]                     cond$call), session = sessionInformation(), 
[13:20:05.178]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.178]                   signalCondition(cond)
[13:20:05.178]                 }
[13:20:05.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.178]                 "immediateCondition"))) {
[13:20:05.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.178]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.178]                   if (TRUE && !signal) {
[13:20:05.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.178]                     {
[13:20:05.178]                       inherits <- base::inherits
[13:20:05.178]                       invokeRestart <- base::invokeRestart
[13:20:05.178]                       is.null <- base::is.null
[13:20:05.178]                       muffled <- FALSE
[13:20:05.178]                       if (inherits(cond, "message")) {
[13:20:05.178]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.178]                         if (muffled) 
[13:20:05.178]                           invokeRestart("muffleMessage")
[13:20:05.178]                       }
[13:20:05.178]                       else if (inherits(cond, "warning")) {
[13:20:05.178]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.178]                         if (muffled) 
[13:20:05.178]                           invokeRestart("muffleWarning")
[13:20:05.178]                       }
[13:20:05.178]                       else if (inherits(cond, "condition")) {
[13:20:05.178]                         if (!is.null(pattern)) {
[13:20:05.178]                           computeRestarts <- base::computeRestarts
[13:20:05.178]                           grepl <- base::grepl
[13:20:05.178]                           restarts <- computeRestarts(cond)
[13:20:05.178]                           for (restart in restarts) {
[13:20:05.178]                             name <- restart$name
[13:20:05.178]                             if (is.null(name)) 
[13:20:05.178]                               next
[13:20:05.178]                             if (!grepl(pattern, name)) 
[13:20:05.178]                               next
[13:20:05.178]                             invokeRestart(restart)
[13:20:05.178]                             muffled <- TRUE
[13:20:05.178]                             break
[13:20:05.178]                           }
[13:20:05.178]                         }
[13:20:05.178]                       }
[13:20:05.178]                       invisible(muffled)
[13:20:05.178]                     }
[13:20:05.178]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.178]                   }
[13:20:05.178]                 }
[13:20:05.178]                 else {
[13:20:05.178]                   if (TRUE) {
[13:20:05.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.178]                     {
[13:20:05.178]                       inherits <- base::inherits
[13:20:05.178]                       invokeRestart <- base::invokeRestart
[13:20:05.178]                       is.null <- base::is.null
[13:20:05.178]                       muffled <- FALSE
[13:20:05.178]                       if (inherits(cond, "message")) {
[13:20:05.178]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.178]                         if (muffled) 
[13:20:05.178]                           invokeRestart("muffleMessage")
[13:20:05.178]                       }
[13:20:05.178]                       else if (inherits(cond, "warning")) {
[13:20:05.178]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.178]                         if (muffled) 
[13:20:05.178]                           invokeRestart("muffleWarning")
[13:20:05.178]                       }
[13:20:05.178]                       else if (inherits(cond, "condition")) {
[13:20:05.178]                         if (!is.null(pattern)) {
[13:20:05.178]                           computeRestarts <- base::computeRestarts
[13:20:05.178]                           grepl <- base::grepl
[13:20:05.178]                           restarts <- computeRestarts(cond)
[13:20:05.178]                           for (restart in restarts) {
[13:20:05.178]                             name <- restart$name
[13:20:05.178]                             if (is.null(name)) 
[13:20:05.178]                               next
[13:20:05.178]                             if (!grepl(pattern, name)) 
[13:20:05.178]                               next
[13:20:05.178]                             invokeRestart(restart)
[13:20:05.178]                             muffled <- TRUE
[13:20:05.178]                             break
[13:20:05.178]                           }
[13:20:05.178]                         }
[13:20:05.178]                       }
[13:20:05.178]                       invisible(muffled)
[13:20:05.178]                     }
[13:20:05.178]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.178]                   }
[13:20:05.178]                 }
[13:20:05.178]             }
[13:20:05.178]         }))
[13:20:05.178]     }, error = function(ex) {
[13:20:05.178]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.178]                 ...future.rng), started = ...future.startTime, 
[13:20:05.178]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.178]             version = "1.8"), class = "FutureResult")
[13:20:05.178]     }, finally = {
[13:20:05.178]         if (!identical(...future.workdir, getwd())) 
[13:20:05.178]             setwd(...future.workdir)
[13:20:05.178]         {
[13:20:05.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.178]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.178]             }
[13:20:05.178]             base::options(...future.oldOptions)
[13:20:05.178]             if (.Platform$OS.type == "windows") {
[13:20:05.178]                 old_names <- names(...future.oldEnvVars)
[13:20:05.178]                 envs <- base::Sys.getenv()
[13:20:05.178]                 names <- names(envs)
[13:20:05.178]                 common <- intersect(names, old_names)
[13:20:05.178]                 added <- setdiff(names, old_names)
[13:20:05.178]                 removed <- setdiff(old_names, names)
[13:20:05.178]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.178]                   envs[common]]
[13:20:05.178]                 NAMES <- toupper(changed)
[13:20:05.178]                 args <- list()
[13:20:05.178]                 for (kk in seq_along(NAMES)) {
[13:20:05.178]                   name <- changed[[kk]]
[13:20:05.178]                   NAME <- NAMES[[kk]]
[13:20:05.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.178]                     next
[13:20:05.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.178]                 }
[13:20:05.178]                 NAMES <- toupper(added)
[13:20:05.178]                 for (kk in seq_along(NAMES)) {
[13:20:05.178]                   name <- added[[kk]]
[13:20:05.178]                   NAME <- NAMES[[kk]]
[13:20:05.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.178]                     next
[13:20:05.178]                   args[[name]] <- ""
[13:20:05.178]                 }
[13:20:05.178]                 NAMES <- toupper(removed)
[13:20:05.178]                 for (kk in seq_along(NAMES)) {
[13:20:05.178]                   name <- removed[[kk]]
[13:20:05.178]                   NAME <- NAMES[[kk]]
[13:20:05.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.178]                     next
[13:20:05.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.178]                 }
[13:20:05.178]                 if (length(args) > 0) 
[13:20:05.178]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.178]             }
[13:20:05.178]             else {
[13:20:05.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.178]             }
[13:20:05.178]             {
[13:20:05.178]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.178]                   0L) {
[13:20:05.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.178]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.178]                   base::options(opts)
[13:20:05.178]                 }
[13:20:05.178]                 {
[13:20:05.178]                   {
[13:20:05.178]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.178]                     NULL
[13:20:05.178]                   }
[13:20:05.178]                   options(future.plan = NULL)
[13:20:05.178]                   if (is.na(NA_character_)) 
[13:20:05.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.178]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:05.178]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:05.178]                     envir = parent.frame()) 
[13:20:05.178]                   {
[13:20:05.178]                     if (is.function(workers)) 
[13:20:05.178]                       workers <- workers()
[13:20:05.178]                     workers <- structure(as.integer(workers), 
[13:20:05.178]                       class = class(workers))
[13:20:05.178]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:05.178]                       workers >= 1)
[13:20:05.178]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:05.178]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:05.178]                     }
[13:20:05.178]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:05.178]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:05.178]                       envir = envir)
[13:20:05.178]                     if (!future$lazy) 
[13:20:05.178]                       future <- run(future)
[13:20:05.178]                     invisible(future)
[13:20:05.178]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.178]                 }
[13:20:05.178]             }
[13:20:05.178]         }
[13:20:05.178]     })
[13:20:05.178]     if (TRUE) {
[13:20:05.178]         base::sink(type = "output", split = FALSE)
[13:20:05.178]         if (TRUE) {
[13:20:05.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.178]         }
[13:20:05.178]         else {
[13:20:05.178]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.178]         }
[13:20:05.178]         base::close(...future.stdout)
[13:20:05.178]         ...future.stdout <- NULL
[13:20:05.178]     }
[13:20:05.178]     ...future.result$conditions <- ...future.conditions
[13:20:05.178]     ...future.result$finished <- base::Sys.time()
[13:20:05.178]     ...future.result
[13:20:05.178] }
[13:20:05.181] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:20:05.181] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:20:05.182] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:20:05.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:05.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.182] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:20:05.183] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:20:05.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:05.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:05.184] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.184] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:20:05.184] MultisessionFuture started
[13:20:05.184] - Launch lazy future ... done
[13:20:05.185] run() for ‘MultisessionFuture’ ... done
[13:20:05.185] Created future:
[13:20:05.185] MultisessionFuture:
[13:20:05.185] Label: ‘future_by-1’
[13:20:05.185] Expression:
[13:20:05.185] {
[13:20:05.185]     do.call(function(...) {
[13:20:05.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.185]             on.exit(options(oopts), add = TRUE)
[13:20:05.185]         }
[13:20:05.185]         {
[13:20:05.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.185]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.185]             })
[13:20:05.185]         }
[13:20:05.185]     }, args = future.call.arguments)
[13:20:05.185] }
[13:20:05.185] Lazy evaluation: FALSE
[13:20:05.185] Asynchronous evaluation: TRUE
[13:20:05.185] Local evaluation: TRUE
[13:20:05.185] Environment: 0x55acefe444d8
[13:20:05.185] Capture standard output: TRUE
[13:20:05.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.185] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.185] Packages: <none>
[13:20:05.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.185] Resolved: FALSE
[13:20:05.185] Value: <not collected>
[13:20:05.185] Conditions captured: <none>
[13:20:05.185] Early signaling: FALSE
[13:20:05.185] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:05.185] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.196] Chunk #1 of 2 ... DONE
[13:20:05.197] Chunk #2 of 2 ...
[13:20:05.197]  - Finding globals in 'X' for chunk #2 ...
[13:20:05.197] getGlobalsAndPackages() ...
[13:20:05.197] Searching for globals...
[13:20:05.197] 
[13:20:05.197] Searching for globals ... DONE
[13:20:05.198] - globals: [0] <none>
[13:20:05.198] getGlobalsAndPackages() ... DONE
[13:20:05.198]    + additional globals found: [n=0] 
[13:20:05.198]    + additional namespaces needed: [n=0] 
[13:20:05.198]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:05.198]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.198]  - seeds: <none>
[13:20:05.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.198] getGlobalsAndPackages() ...
[13:20:05.198] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.199] Resolving globals: FALSE
[13:20:05.199] Tweak future expression to call with '...' arguments ...
[13:20:05.199] {
[13:20:05.199]     do.call(function(...) {
[13:20:05.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.199]             on.exit(options(oopts), add = TRUE)
[13:20:05.199]         }
[13:20:05.199]         {
[13:20:05.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.199]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.199]             })
[13:20:05.199]         }
[13:20:05.199]     }, args = future.call.arguments)
[13:20:05.199] }
[13:20:05.199] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.199] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.199] 
[13:20:05.200] getGlobalsAndPackages() ... DONE
[13:20:05.200] run() for ‘Future’ ...
[13:20:05.200] - state: ‘created’
[13:20:05.200] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.215] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:05.215]   - Field: ‘node’
[13:20:05.215]   - Field: ‘label’
[13:20:05.215]   - Field: ‘local’
[13:20:05.215]   - Field: ‘owner’
[13:20:05.215]   - Field: ‘envir’
[13:20:05.216]   - Field: ‘workers’
[13:20:05.216]   - Field: ‘packages’
[13:20:05.216]   - Field: ‘gc’
[13:20:05.216]   - Field: ‘conditions’
[13:20:05.216]   - Field: ‘persistent’
[13:20:05.216]   - Field: ‘expr’
[13:20:05.216]   - Field: ‘uuid’
[13:20:05.216]   - Field: ‘seed’
[13:20:05.216]   - Field: ‘version’
[13:20:05.216]   - Field: ‘result’
[13:20:05.216]   - Field: ‘asynchronous’
[13:20:05.217]   - Field: ‘calls’
[13:20:05.217]   - Field: ‘globals’
[13:20:05.217]   - Field: ‘stdout’
[13:20:05.217]   - Field: ‘earlySignal’
[13:20:05.217]   - Field: ‘lazy’
[13:20:05.217]   - Field: ‘state’
[13:20:05.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:05.217] - Launch lazy future ...
[13:20:05.218] Packages needed by the future expression (n = 0): <none>
[13:20:05.218] Packages needed by future strategies (n = 0): <none>
[13:20:05.218] {
[13:20:05.218]     {
[13:20:05.218]         {
[13:20:05.218]             ...future.startTime <- base::Sys.time()
[13:20:05.218]             {
[13:20:05.218]                 {
[13:20:05.218]                   {
[13:20:05.218]                     {
[13:20:05.218]                       base::local({
[13:20:05.218]                         has_future <- base::requireNamespace("future", 
[13:20:05.218]                           quietly = TRUE)
[13:20:05.218]                         if (has_future) {
[13:20:05.218]                           ns <- base::getNamespace("future")
[13:20:05.218]                           version <- ns[[".package"]][["version"]]
[13:20:05.218]                           if (is.null(version)) 
[13:20:05.218]                             version <- utils::packageVersion("future")
[13:20:05.218]                         }
[13:20:05.218]                         else {
[13:20:05.218]                           version <- NULL
[13:20:05.218]                         }
[13:20:05.218]                         if (!has_future || version < "1.8.0") {
[13:20:05.218]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.218]                             "", base::R.version$version.string), 
[13:20:05.218]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.218]                               "release", "version")], collapse = " "), 
[13:20:05.218]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.218]                             info)
[13:20:05.218]                           info <- base::paste(info, collapse = "; ")
[13:20:05.218]                           if (!has_future) {
[13:20:05.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.218]                               info)
[13:20:05.218]                           }
[13:20:05.218]                           else {
[13:20:05.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.218]                               info, version)
[13:20:05.218]                           }
[13:20:05.218]                           base::stop(msg)
[13:20:05.218]                         }
[13:20:05.218]                       })
[13:20:05.218]                     }
[13:20:05.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.218]                     base::options(mc.cores = 1L)
[13:20:05.218]                   }
[13:20:05.218]                   options(future.plan = NULL)
[13:20:05.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.218]                 }
[13:20:05.218]                 ...future.workdir <- getwd()
[13:20:05.218]             }
[13:20:05.218]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.218]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.218]         }
[13:20:05.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.218]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.218]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.218]             base::names(...future.oldOptions))
[13:20:05.218]     }
[13:20:05.218]     if (FALSE) {
[13:20:05.218]     }
[13:20:05.218]     else {
[13:20:05.218]         if (TRUE) {
[13:20:05.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.218]                 open = "w")
[13:20:05.218]         }
[13:20:05.218]         else {
[13:20:05.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.218]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.218]         }
[13:20:05.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.218]             base::sink(type = "output", split = FALSE)
[13:20:05.218]             base::close(...future.stdout)
[13:20:05.218]         }, add = TRUE)
[13:20:05.218]     }
[13:20:05.218]     ...future.frame <- base::sys.nframe()
[13:20:05.218]     ...future.conditions <- base::list()
[13:20:05.218]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.218]     if (FALSE) {
[13:20:05.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.218]     }
[13:20:05.218]     ...future.result <- base::tryCatch({
[13:20:05.218]         base::withCallingHandlers({
[13:20:05.218]             ...future.value <- base::withVisible(base::local({
[13:20:05.218]                 ...future.makeSendCondition <- base::local({
[13:20:05.218]                   sendCondition <- NULL
[13:20:05.218]                   function(frame = 1L) {
[13:20:05.218]                     if (is.function(sendCondition)) 
[13:20:05.218]                       return(sendCondition)
[13:20:05.218]                     ns <- getNamespace("parallel")
[13:20:05.218]                     if (exists("sendData", mode = "function", 
[13:20:05.218]                       envir = ns)) {
[13:20:05.218]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:05.218]                         envir = ns)
[13:20:05.218]                       envir <- sys.frame(frame)
[13:20:05.218]                       master <- NULL
[13:20:05.218]                       while (!identical(envir, .GlobalEnv) && 
[13:20:05.218]                         !identical(envir, emptyenv())) {
[13:20:05.218]                         if (exists("master", mode = "list", envir = envir, 
[13:20:05.218]                           inherits = FALSE)) {
[13:20:05.218]                           master <- get("master", mode = "list", 
[13:20:05.218]                             envir = envir, inherits = FALSE)
[13:20:05.218]                           if (inherits(master, c("SOCKnode", 
[13:20:05.218]                             "SOCK0node"))) {
[13:20:05.218]                             sendCondition <<- function(cond) {
[13:20:05.218]                               data <- list(type = "VALUE", value = cond, 
[13:20:05.218]                                 success = TRUE)
[13:20:05.218]                               parallel_sendData(master, data)
[13:20:05.218]                             }
[13:20:05.218]                             return(sendCondition)
[13:20:05.218]                           }
[13:20:05.218]                         }
[13:20:05.218]                         frame <- frame + 1L
[13:20:05.218]                         envir <- sys.frame(frame)
[13:20:05.218]                       }
[13:20:05.218]                     }
[13:20:05.218]                     sendCondition <<- function(cond) NULL
[13:20:05.218]                   }
[13:20:05.218]                 })
[13:20:05.218]                 withCallingHandlers({
[13:20:05.218]                   {
[13:20:05.218]                     do.call(function(...) {
[13:20:05.218]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.218]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.218]                         ...future.globals.maxSize)) {
[13:20:05.218]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.218]                         on.exit(options(oopts), add = TRUE)
[13:20:05.218]                       }
[13:20:05.218]                       {
[13:20:05.218]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.218]                           FUN = function(jj) {
[13:20:05.218]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.218]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.218]                           })
[13:20:05.218]                       }
[13:20:05.218]                     }, args = future.call.arguments)
[13:20:05.218]                   }
[13:20:05.218]                 }, immediateCondition = function(cond) {
[13:20:05.218]                   sendCondition <- ...future.makeSendCondition()
[13:20:05.218]                   sendCondition(cond)
[13:20:05.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.218]                   {
[13:20:05.218]                     inherits <- base::inherits
[13:20:05.218]                     invokeRestart <- base::invokeRestart
[13:20:05.218]                     is.null <- base::is.null
[13:20:05.218]                     muffled <- FALSE
[13:20:05.218]                     if (inherits(cond, "message")) {
[13:20:05.218]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.218]                       if (muffled) 
[13:20:05.218]                         invokeRestart("muffleMessage")
[13:20:05.218]                     }
[13:20:05.218]                     else if (inherits(cond, "warning")) {
[13:20:05.218]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.218]                       if (muffled) 
[13:20:05.218]                         invokeRestart("muffleWarning")
[13:20:05.218]                     }
[13:20:05.218]                     else if (inherits(cond, "condition")) {
[13:20:05.218]                       if (!is.null(pattern)) {
[13:20:05.218]                         computeRestarts <- base::computeRestarts
[13:20:05.218]                         grepl <- base::grepl
[13:20:05.218]                         restarts <- computeRestarts(cond)
[13:20:05.218]                         for (restart in restarts) {
[13:20:05.218]                           name <- restart$name
[13:20:05.218]                           if (is.null(name)) 
[13:20:05.218]                             next
[13:20:05.218]                           if (!grepl(pattern, name)) 
[13:20:05.218]                             next
[13:20:05.218]                           invokeRestart(restart)
[13:20:05.218]                           muffled <- TRUE
[13:20:05.218]                           break
[13:20:05.218]                         }
[13:20:05.218]                       }
[13:20:05.218]                     }
[13:20:05.218]                     invisible(muffled)
[13:20:05.218]                   }
[13:20:05.218]                   muffleCondition(cond)
[13:20:05.218]                 })
[13:20:05.218]             }))
[13:20:05.218]             future::FutureResult(value = ...future.value$value, 
[13:20:05.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.218]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.218]                     ...future.globalenv.names))
[13:20:05.218]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.218]         }, condition = base::local({
[13:20:05.218]             c <- base::c
[13:20:05.218]             inherits <- base::inherits
[13:20:05.218]             invokeRestart <- base::invokeRestart
[13:20:05.218]             length <- base::length
[13:20:05.218]             list <- base::list
[13:20:05.218]             seq.int <- base::seq.int
[13:20:05.218]             signalCondition <- base::signalCondition
[13:20:05.218]             sys.calls <- base::sys.calls
[13:20:05.218]             `[[` <- base::`[[`
[13:20:05.218]             `+` <- base::`+`
[13:20:05.218]             `<<-` <- base::`<<-`
[13:20:05.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.218]                   3L)]
[13:20:05.218]             }
[13:20:05.218]             function(cond) {
[13:20:05.218]                 is_error <- inherits(cond, "error")
[13:20:05.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.218]                   NULL)
[13:20:05.218]                 if (is_error) {
[13:20:05.218]                   sessionInformation <- function() {
[13:20:05.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.218]                       search = base::search(), system = base::Sys.info())
[13:20:05.218]                   }
[13:20:05.218]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.218]                     cond$call), session = sessionInformation(), 
[13:20:05.218]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.218]                   signalCondition(cond)
[13:20:05.218]                 }
[13:20:05.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.218]                 "immediateCondition"))) {
[13:20:05.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.218]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.218]                   if (TRUE && !signal) {
[13:20:05.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.218]                     {
[13:20:05.218]                       inherits <- base::inherits
[13:20:05.218]                       invokeRestart <- base::invokeRestart
[13:20:05.218]                       is.null <- base::is.null
[13:20:05.218]                       muffled <- FALSE
[13:20:05.218]                       if (inherits(cond, "message")) {
[13:20:05.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.218]                         if (muffled) 
[13:20:05.218]                           invokeRestart("muffleMessage")
[13:20:05.218]                       }
[13:20:05.218]                       else if (inherits(cond, "warning")) {
[13:20:05.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.218]                         if (muffled) 
[13:20:05.218]                           invokeRestart("muffleWarning")
[13:20:05.218]                       }
[13:20:05.218]                       else if (inherits(cond, "condition")) {
[13:20:05.218]                         if (!is.null(pattern)) {
[13:20:05.218]                           computeRestarts <- base::computeRestarts
[13:20:05.218]                           grepl <- base::grepl
[13:20:05.218]                           restarts <- computeRestarts(cond)
[13:20:05.218]                           for (restart in restarts) {
[13:20:05.218]                             name <- restart$name
[13:20:05.218]                             if (is.null(name)) 
[13:20:05.218]                               next
[13:20:05.218]                             if (!grepl(pattern, name)) 
[13:20:05.218]                               next
[13:20:05.218]                             invokeRestart(restart)
[13:20:05.218]                             muffled <- TRUE
[13:20:05.218]                             break
[13:20:05.218]                           }
[13:20:05.218]                         }
[13:20:05.218]                       }
[13:20:05.218]                       invisible(muffled)
[13:20:05.218]                     }
[13:20:05.218]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.218]                   }
[13:20:05.218]                 }
[13:20:05.218]                 else {
[13:20:05.218]                   if (TRUE) {
[13:20:05.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.218]                     {
[13:20:05.218]                       inherits <- base::inherits
[13:20:05.218]                       invokeRestart <- base::invokeRestart
[13:20:05.218]                       is.null <- base::is.null
[13:20:05.218]                       muffled <- FALSE
[13:20:05.218]                       if (inherits(cond, "message")) {
[13:20:05.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.218]                         if (muffled) 
[13:20:05.218]                           invokeRestart("muffleMessage")
[13:20:05.218]                       }
[13:20:05.218]                       else if (inherits(cond, "warning")) {
[13:20:05.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.218]                         if (muffled) 
[13:20:05.218]                           invokeRestart("muffleWarning")
[13:20:05.218]                       }
[13:20:05.218]                       else if (inherits(cond, "condition")) {
[13:20:05.218]                         if (!is.null(pattern)) {
[13:20:05.218]                           computeRestarts <- base::computeRestarts
[13:20:05.218]                           grepl <- base::grepl
[13:20:05.218]                           restarts <- computeRestarts(cond)
[13:20:05.218]                           for (restart in restarts) {
[13:20:05.218]                             name <- restart$name
[13:20:05.218]                             if (is.null(name)) 
[13:20:05.218]                               next
[13:20:05.218]                             if (!grepl(pattern, name)) 
[13:20:05.218]                               next
[13:20:05.218]                             invokeRestart(restart)
[13:20:05.218]                             muffled <- TRUE
[13:20:05.218]                             break
[13:20:05.218]                           }
[13:20:05.218]                         }
[13:20:05.218]                       }
[13:20:05.218]                       invisible(muffled)
[13:20:05.218]                     }
[13:20:05.218]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.218]                   }
[13:20:05.218]                 }
[13:20:05.218]             }
[13:20:05.218]         }))
[13:20:05.218]     }, error = function(ex) {
[13:20:05.218]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.218]                 ...future.rng), started = ...future.startTime, 
[13:20:05.218]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.218]             version = "1.8"), class = "FutureResult")
[13:20:05.218]     }, finally = {
[13:20:05.218]         if (!identical(...future.workdir, getwd())) 
[13:20:05.218]             setwd(...future.workdir)
[13:20:05.218]         {
[13:20:05.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.218]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.218]             }
[13:20:05.218]             base::options(...future.oldOptions)
[13:20:05.218]             if (.Platform$OS.type == "windows") {
[13:20:05.218]                 old_names <- names(...future.oldEnvVars)
[13:20:05.218]                 envs <- base::Sys.getenv()
[13:20:05.218]                 names <- names(envs)
[13:20:05.218]                 common <- intersect(names, old_names)
[13:20:05.218]                 added <- setdiff(names, old_names)
[13:20:05.218]                 removed <- setdiff(old_names, names)
[13:20:05.218]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.218]                   envs[common]]
[13:20:05.218]                 NAMES <- toupper(changed)
[13:20:05.218]                 args <- list()
[13:20:05.218]                 for (kk in seq_along(NAMES)) {
[13:20:05.218]                   name <- changed[[kk]]
[13:20:05.218]                   NAME <- NAMES[[kk]]
[13:20:05.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.218]                     next
[13:20:05.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.218]                 }
[13:20:05.218]                 NAMES <- toupper(added)
[13:20:05.218]                 for (kk in seq_along(NAMES)) {
[13:20:05.218]                   name <- added[[kk]]
[13:20:05.218]                   NAME <- NAMES[[kk]]
[13:20:05.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.218]                     next
[13:20:05.218]                   args[[name]] <- ""
[13:20:05.218]                 }
[13:20:05.218]                 NAMES <- toupper(removed)
[13:20:05.218]                 for (kk in seq_along(NAMES)) {
[13:20:05.218]                   name <- removed[[kk]]
[13:20:05.218]                   NAME <- NAMES[[kk]]
[13:20:05.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.218]                     next
[13:20:05.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.218]                 }
[13:20:05.218]                 if (length(args) > 0) 
[13:20:05.218]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.218]             }
[13:20:05.218]             else {
[13:20:05.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.218]             }
[13:20:05.218]             {
[13:20:05.218]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.218]                   0L) {
[13:20:05.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.218]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.218]                   base::options(opts)
[13:20:05.218]                 }
[13:20:05.218]                 {
[13:20:05.218]                   {
[13:20:05.218]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.218]                     NULL
[13:20:05.218]                   }
[13:20:05.218]                   options(future.plan = NULL)
[13:20:05.218]                   if (is.na(NA_character_)) 
[13:20:05.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.218]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:05.218]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:05.218]                     envir = parent.frame()) 
[13:20:05.218]                   {
[13:20:05.218]                     if (is.function(workers)) 
[13:20:05.218]                       workers <- workers()
[13:20:05.218]                     workers <- structure(as.integer(workers), 
[13:20:05.218]                       class = class(workers))
[13:20:05.218]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:05.218]                       workers >= 1)
[13:20:05.218]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:05.218]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:05.218]                     }
[13:20:05.218]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:05.218]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:05.218]                       envir = envir)
[13:20:05.218]                     if (!future$lazy) 
[13:20:05.218]                       future <- run(future)
[13:20:05.218]                     invisible(future)
[13:20:05.218]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.218]                 }
[13:20:05.218]             }
[13:20:05.218]         }
[13:20:05.218]     })
[13:20:05.218]     if (TRUE) {
[13:20:05.218]         base::sink(type = "output", split = FALSE)
[13:20:05.218]         if (TRUE) {
[13:20:05.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.218]         }
[13:20:05.218]         else {
[13:20:05.218]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.218]         }
[13:20:05.218]         base::close(...future.stdout)
[13:20:05.218]         ...future.stdout <- NULL
[13:20:05.218]     }
[13:20:05.218]     ...future.result$conditions <- ...future.conditions
[13:20:05.218]     ...future.result$finished <- base::Sys.time()
[13:20:05.218]     ...future.result
[13:20:05.218] }
[13:20:05.221] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:20:05.221] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:20:05.222] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:20:05.222] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:05.222] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.223] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:20:05.223] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:20:05.223] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:05.223] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.224] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:05.224] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.224] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:20:05.225] MultisessionFuture started
[13:20:05.225] - Launch lazy future ... done
[13:20:05.225] run() for ‘MultisessionFuture’ ... done
[13:20:05.225] Created future:
[13:20:05.225] MultisessionFuture:
[13:20:05.225] Label: ‘future_by-2’
[13:20:05.225] Expression:
[13:20:05.225] {
[13:20:05.225]     do.call(function(...) {
[13:20:05.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.225]             on.exit(options(oopts), add = TRUE)
[13:20:05.225]         }
[13:20:05.225]         {
[13:20:05.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.225]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.225]             })
[13:20:05.225]         }
[13:20:05.225]     }, args = future.call.arguments)
[13:20:05.225] }
[13:20:05.225] Lazy evaluation: FALSE
[13:20:05.225] Asynchronous evaluation: TRUE
[13:20:05.225] Local evaluation: TRUE
[13:20:05.225] Environment: 0x55acefe444d8
[13:20:05.225] Capture standard output: TRUE
[13:20:05.225] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.225] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.225] Packages: <none>
[13:20:05.225] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.225] Resolved: FALSE
[13:20:05.225] Value: <not collected>
[13:20:05.225] Conditions captured: <none>
[13:20:05.225] Early signaling: FALSE
[13:20:05.225] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:05.225] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.239] Chunk #2 of 2 ... DONE
[13:20:05.240] Launching 2 futures (chunks) ... DONE
[13:20:05.240] Resolving 2 futures (chunks) ...
[13:20:05.240] resolve() on list ...
[13:20:05.240]  recursive: 0
[13:20:05.240]  length: 2
[13:20:05.240] 
[13:20:05.241] receiveMessageFromWorker() for ClusterFuture ...
[13:20:05.241] - Validating connection of MultisessionFuture
[13:20:05.241] - received message: FutureResult
[13:20:05.241] - Received FutureResult
[13:20:05.241] - Erased future from FutureRegistry
[13:20:05.241] result() for ClusterFuture ...
[13:20:05.241] - result already collected: FutureResult
[13:20:05.242] result() for ClusterFuture ... done
[13:20:05.242] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:05.242] Future #1
[13:20:05.242] result() for ClusterFuture ...
[13:20:05.242] - result already collected: FutureResult
[13:20:05.242] result() for ClusterFuture ... done
[13:20:05.242] result() for ClusterFuture ...
[13:20:05.242] - result already collected: FutureResult
[13:20:05.242] result() for ClusterFuture ... done
[13:20:05.242] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:05.242] - nx: 2
[13:20:05.243] - relay: TRUE
[13:20:05.243] - stdout: TRUE
[13:20:05.243] - signal: TRUE
[13:20:05.243] - resignal: FALSE
[13:20:05.243] - force: TRUE
[13:20:05.243] - relayed: [n=2] FALSE, FALSE
[13:20:05.243] - queued futures: [n=2] FALSE, FALSE
[13:20:05.243]  - until=1
[13:20:05.243]  - relaying element #1
[13:20:05.243] result() for ClusterFuture ...
[13:20:05.243] - result already collected: FutureResult
[13:20:05.243] result() for ClusterFuture ... done
[13:20:05.244] result() for ClusterFuture ...
[13:20:05.244] - result already collected: FutureResult
[13:20:05.244] result() for ClusterFuture ... done
[13:20:05.244] result() for ClusterFuture ...
[13:20:05.244] - result already collected: FutureResult
[13:20:05.244] result() for ClusterFuture ... done
[13:20:05.244] result() for ClusterFuture ...
[13:20:05.244] - result already collected: FutureResult
[13:20:05.244] result() for ClusterFuture ... done
[13:20:05.244] - relayed: [n=2] TRUE, FALSE
[13:20:05.244] - queued futures: [n=2] TRUE, FALSE
[13:20:05.245] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:05.245]  length: 1 (resolved future 1)
[13:20:05.274] receiveMessageFromWorker() for ClusterFuture ...
[13:20:05.274] - Validating connection of MultisessionFuture
[13:20:05.274] - received message: FutureResult
[13:20:05.274] - Received FutureResult
[13:20:05.275] - Erased future from FutureRegistry
[13:20:05.275] result() for ClusterFuture ...
[13:20:05.275] - result already collected: FutureResult
[13:20:05.275] result() for ClusterFuture ... done
[13:20:05.275] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:05.275] Future #2
[13:20:05.275] result() for ClusterFuture ...
[13:20:05.275] - result already collected: FutureResult
[13:20:05.275] result() for ClusterFuture ... done
[13:20:05.275] result() for ClusterFuture ...
[13:20:05.275] - result already collected: FutureResult
[13:20:05.276] result() for ClusterFuture ... done
[13:20:05.276] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:05.276] - nx: 2
[13:20:05.276] - relay: TRUE
[13:20:05.276] - stdout: TRUE
[13:20:05.276] - signal: TRUE
[13:20:05.276] - resignal: FALSE
[13:20:05.276] - force: TRUE
[13:20:05.276] - relayed: [n=2] TRUE, FALSE
[13:20:05.276] - queued futures: [n=2] TRUE, FALSE
[13:20:05.276]  - until=2
[13:20:05.277]  - relaying element #2
[13:20:05.277] result() for ClusterFuture ...
[13:20:05.277] - result already collected: FutureResult
[13:20:05.277] result() for ClusterFuture ... done
[13:20:05.277] result() for ClusterFuture ...
[13:20:05.277] - result already collected: FutureResult
[13:20:05.277] result() for ClusterFuture ... done
[13:20:05.277] result() for ClusterFuture ...
[13:20:05.277] - result already collected: FutureResult
[13:20:05.277] result() for ClusterFuture ... done
[13:20:05.277] result() for ClusterFuture ...
[13:20:05.278] - result already collected: FutureResult
[13:20:05.278] result() for ClusterFuture ... done
[13:20:05.278] - relayed: [n=2] TRUE, TRUE
[13:20:05.278] - queued futures: [n=2] TRUE, TRUE
[13:20:05.278] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:05.278]  length: 0 (resolved future 2)
[13:20:05.278] Relaying remaining futures
[13:20:05.278] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.278] - nx: 2
[13:20:05.278] - relay: TRUE
[13:20:05.278] - stdout: TRUE
[13:20:05.278] - signal: TRUE
[13:20:05.279] - resignal: FALSE
[13:20:05.279] - force: TRUE
[13:20:05.279] - relayed: [n=2] TRUE, TRUE
[13:20:05.279] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:05.279] - relayed: [n=2] TRUE, TRUE
[13:20:05.279] - queued futures: [n=2] TRUE, TRUE
[13:20:05.279] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.279] resolve() on list ... DONE
[13:20:05.279] result() for ClusterFuture ...
[13:20:05.279] - result already collected: FutureResult
[13:20:05.279] result() for ClusterFuture ... done
[13:20:05.279] result() for ClusterFuture ...
[13:20:05.280] - result already collected: FutureResult
[13:20:05.280] result() for ClusterFuture ... done
[13:20:05.280] result() for ClusterFuture ...
[13:20:05.280] - result already collected: FutureResult
[13:20:05.280] result() for ClusterFuture ... done
[13:20:05.280] result() for ClusterFuture ...
[13:20:05.280] - result already collected: FutureResult
[13:20:05.280] result() for ClusterFuture ... done
[13:20:05.280]  - Number of value chunks collected: 2
[13:20:05.280] Resolving 2 futures (chunks) ... DONE
[13:20:05.281] Reducing values from 2 chunks ...
[13:20:05.281]  - Number of values collected after concatenation: 3
[13:20:05.281]  - Number of values expected: 3
[13:20:05.281] Reducing values from 2 chunks ... DONE
[13:20:05.281] future_lapply() ... DONE
[13:20:05.281] future_by_internal() ... DONE
[13:20:05.282] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:20:05.282] future_lapply() ...
[13:20:05.286] Number of chunks: 2
[13:20:05.286] getGlobalsAndPackagesXApply() ...
[13:20:05.286]  - future.globals: TRUE
[13:20:05.287] getGlobalsAndPackages() ...
[13:20:05.287] Searching for globals...
[13:20:05.288] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:20:05.288] Searching for globals ... DONE
[13:20:05.288] Resolving globals: FALSE
[13:20:05.288] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:20:05.289] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:20:05.289] - globals: [1] ‘FUN’
[13:20:05.289] 
[13:20:05.289] getGlobalsAndPackages() ... DONE
[13:20:05.289]  - globals found/used: [n=1] ‘FUN’
[13:20:05.289]  - needed namespaces: [n=0] 
[13:20:05.289] Finding globals ... DONE
[13:20:05.289]  - use_args: TRUE
[13:20:05.289]  - Getting '...' globals ...
[13:20:05.290] resolve() on list ...
[13:20:05.290]  recursive: 0
[13:20:05.290]  length: 1
[13:20:05.290]  elements: ‘...’
[13:20:05.290]  length: 0 (resolved future 1)
[13:20:05.290] resolve() on list ... DONE
[13:20:05.290]    - '...' content: [n=0] 
[13:20:05.290] List of 1
[13:20:05.290]  $ ...: list()
[13:20:05.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.290]  - attr(*, "where")=List of 1
[13:20:05.290]   ..$ ...:<environment: 0x55acf06ce288> 
[13:20:05.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.290]  - attr(*, "resolved")= logi TRUE
[13:20:05.290]  - attr(*, "total_size")= num NA
[13:20:05.293]  - Getting '...' globals ... DONE
[13:20:05.293] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:20:05.293] List of 2
[13:20:05.293]  $ ...future.FUN:function (object, ...)  
[13:20:05.293]  $ ...          : list()
[13:20:05.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:20:05.293]  - attr(*, "where")=List of 2
[13:20:05.293]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:20:05.293]   ..$ ...          :<environment: 0x55acf06ce288> 
[13:20:05.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:05.293]  - attr(*, "resolved")= logi FALSE
[13:20:05.293]  - attr(*, "total_size")= num 1240
[13:20:05.296] Packages to be attached in all futures: [n=0] 
[13:20:05.296] getGlobalsAndPackagesXApply() ... DONE
[13:20:05.296] Number of futures (= number of chunks): 2
[13:20:05.296] Launching 2 futures (chunks) ...
[13:20:05.296] Chunk #1 of 2 ...
[13:20:05.296]  - Finding globals in 'X' for chunk #1 ...
[13:20:05.296] getGlobalsAndPackages() ...
[13:20:05.296] Searching for globals...
[13:20:05.297] 
[13:20:05.297] Searching for globals ... DONE
[13:20:05.297] - globals: [0] <none>
[13:20:05.297] getGlobalsAndPackages() ... DONE
[13:20:05.297]    + additional globals found: [n=0] 
[13:20:05.297]    + additional namespaces needed: [n=0] 
[13:20:05.297]  - Finding globals in 'X' for chunk #1 ... DONE
[13:20:05.297]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.297]  - seeds: <none>
[13:20:05.298]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.298] getGlobalsAndPackages() ...
[13:20:05.298] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.298] Resolving globals: FALSE
[13:20:05.298] Tweak future expression to call with '...' arguments ...
[13:20:05.298] {
[13:20:05.298]     do.call(function(...) {
[13:20:05.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.298]             on.exit(options(oopts), add = TRUE)
[13:20:05.298]         }
[13:20:05.298]         {
[13:20:05.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.298]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.298]             })
[13:20:05.298]         }
[13:20:05.298]     }, args = future.call.arguments)
[13:20:05.298] }
[13:20:05.298] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.299] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.299] 
[13:20:05.299] getGlobalsAndPackages() ... DONE
[13:20:05.299] run() for ‘Future’ ...
[13:20:05.299] - state: ‘created’
[13:20:05.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:05.314]   - Field: ‘node’
[13:20:05.314]   - Field: ‘label’
[13:20:05.314]   - Field: ‘local’
[13:20:05.314]   - Field: ‘owner’
[13:20:05.314]   - Field: ‘envir’
[13:20:05.314]   - Field: ‘workers’
[13:20:05.314]   - Field: ‘packages’
[13:20:05.314]   - Field: ‘gc’
[13:20:05.314]   - Field: ‘conditions’
[13:20:05.314]   - Field: ‘persistent’
[13:20:05.314]   - Field: ‘expr’
[13:20:05.315]   - Field: ‘uuid’
[13:20:05.315]   - Field: ‘seed’
[13:20:05.315]   - Field: ‘version’
[13:20:05.315]   - Field: ‘result’
[13:20:05.315]   - Field: ‘asynchronous’
[13:20:05.315]   - Field: ‘calls’
[13:20:05.315]   - Field: ‘globals’
[13:20:05.315]   - Field: ‘stdout’
[13:20:05.315]   - Field: ‘earlySignal’
[13:20:05.315]   - Field: ‘lazy’
[13:20:05.316]   - Field: ‘state’
[13:20:05.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:05.316] - Launch lazy future ...
[13:20:05.316] Packages needed by the future expression (n = 0): <none>
[13:20:05.316] Packages needed by future strategies (n = 0): <none>
[13:20:05.317] {
[13:20:05.317]     {
[13:20:05.317]         {
[13:20:05.317]             ...future.startTime <- base::Sys.time()
[13:20:05.317]             {
[13:20:05.317]                 {
[13:20:05.317]                   {
[13:20:05.317]                     {
[13:20:05.317]                       base::local({
[13:20:05.317]                         has_future <- base::requireNamespace("future", 
[13:20:05.317]                           quietly = TRUE)
[13:20:05.317]                         if (has_future) {
[13:20:05.317]                           ns <- base::getNamespace("future")
[13:20:05.317]                           version <- ns[[".package"]][["version"]]
[13:20:05.317]                           if (is.null(version)) 
[13:20:05.317]                             version <- utils::packageVersion("future")
[13:20:05.317]                         }
[13:20:05.317]                         else {
[13:20:05.317]                           version <- NULL
[13:20:05.317]                         }
[13:20:05.317]                         if (!has_future || version < "1.8.0") {
[13:20:05.317]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.317]                             "", base::R.version$version.string), 
[13:20:05.317]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.317]                               "release", "version")], collapse = " "), 
[13:20:05.317]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.317]                             info)
[13:20:05.317]                           info <- base::paste(info, collapse = "; ")
[13:20:05.317]                           if (!has_future) {
[13:20:05.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.317]                               info)
[13:20:05.317]                           }
[13:20:05.317]                           else {
[13:20:05.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.317]                               info, version)
[13:20:05.317]                           }
[13:20:05.317]                           base::stop(msg)
[13:20:05.317]                         }
[13:20:05.317]                       })
[13:20:05.317]                     }
[13:20:05.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.317]                     base::options(mc.cores = 1L)
[13:20:05.317]                   }
[13:20:05.317]                   options(future.plan = NULL)
[13:20:05.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.317]                 }
[13:20:05.317]                 ...future.workdir <- getwd()
[13:20:05.317]             }
[13:20:05.317]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.317]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.317]         }
[13:20:05.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.317]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.317]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.317]             base::names(...future.oldOptions))
[13:20:05.317]     }
[13:20:05.317]     if (FALSE) {
[13:20:05.317]     }
[13:20:05.317]     else {
[13:20:05.317]         if (TRUE) {
[13:20:05.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.317]                 open = "w")
[13:20:05.317]         }
[13:20:05.317]         else {
[13:20:05.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.317]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.317]         }
[13:20:05.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.317]             base::sink(type = "output", split = FALSE)
[13:20:05.317]             base::close(...future.stdout)
[13:20:05.317]         }, add = TRUE)
[13:20:05.317]     }
[13:20:05.317]     ...future.frame <- base::sys.nframe()
[13:20:05.317]     ...future.conditions <- base::list()
[13:20:05.317]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.317]     if (FALSE) {
[13:20:05.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.317]     }
[13:20:05.317]     ...future.result <- base::tryCatch({
[13:20:05.317]         base::withCallingHandlers({
[13:20:05.317]             ...future.value <- base::withVisible(base::local({
[13:20:05.317]                 ...future.makeSendCondition <- base::local({
[13:20:05.317]                   sendCondition <- NULL
[13:20:05.317]                   function(frame = 1L) {
[13:20:05.317]                     if (is.function(sendCondition)) 
[13:20:05.317]                       return(sendCondition)
[13:20:05.317]                     ns <- getNamespace("parallel")
[13:20:05.317]                     if (exists("sendData", mode = "function", 
[13:20:05.317]                       envir = ns)) {
[13:20:05.317]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:05.317]                         envir = ns)
[13:20:05.317]                       envir <- sys.frame(frame)
[13:20:05.317]                       master <- NULL
[13:20:05.317]                       while (!identical(envir, .GlobalEnv) && 
[13:20:05.317]                         !identical(envir, emptyenv())) {
[13:20:05.317]                         if (exists("master", mode = "list", envir = envir, 
[13:20:05.317]                           inherits = FALSE)) {
[13:20:05.317]                           master <- get("master", mode = "list", 
[13:20:05.317]                             envir = envir, inherits = FALSE)
[13:20:05.317]                           if (inherits(master, c("SOCKnode", 
[13:20:05.317]                             "SOCK0node"))) {
[13:20:05.317]                             sendCondition <<- function(cond) {
[13:20:05.317]                               data <- list(type = "VALUE", value = cond, 
[13:20:05.317]                                 success = TRUE)
[13:20:05.317]                               parallel_sendData(master, data)
[13:20:05.317]                             }
[13:20:05.317]                             return(sendCondition)
[13:20:05.317]                           }
[13:20:05.317]                         }
[13:20:05.317]                         frame <- frame + 1L
[13:20:05.317]                         envir <- sys.frame(frame)
[13:20:05.317]                       }
[13:20:05.317]                     }
[13:20:05.317]                     sendCondition <<- function(cond) NULL
[13:20:05.317]                   }
[13:20:05.317]                 })
[13:20:05.317]                 withCallingHandlers({
[13:20:05.317]                   {
[13:20:05.317]                     do.call(function(...) {
[13:20:05.317]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.317]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.317]                         ...future.globals.maxSize)) {
[13:20:05.317]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.317]                         on.exit(options(oopts), add = TRUE)
[13:20:05.317]                       }
[13:20:05.317]                       {
[13:20:05.317]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.317]                           FUN = function(jj) {
[13:20:05.317]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.317]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.317]                           })
[13:20:05.317]                       }
[13:20:05.317]                     }, args = future.call.arguments)
[13:20:05.317]                   }
[13:20:05.317]                 }, immediateCondition = function(cond) {
[13:20:05.317]                   sendCondition <- ...future.makeSendCondition()
[13:20:05.317]                   sendCondition(cond)
[13:20:05.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.317]                   {
[13:20:05.317]                     inherits <- base::inherits
[13:20:05.317]                     invokeRestart <- base::invokeRestart
[13:20:05.317]                     is.null <- base::is.null
[13:20:05.317]                     muffled <- FALSE
[13:20:05.317]                     if (inherits(cond, "message")) {
[13:20:05.317]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.317]                       if (muffled) 
[13:20:05.317]                         invokeRestart("muffleMessage")
[13:20:05.317]                     }
[13:20:05.317]                     else if (inherits(cond, "warning")) {
[13:20:05.317]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.317]                       if (muffled) 
[13:20:05.317]                         invokeRestart("muffleWarning")
[13:20:05.317]                     }
[13:20:05.317]                     else if (inherits(cond, "condition")) {
[13:20:05.317]                       if (!is.null(pattern)) {
[13:20:05.317]                         computeRestarts <- base::computeRestarts
[13:20:05.317]                         grepl <- base::grepl
[13:20:05.317]                         restarts <- computeRestarts(cond)
[13:20:05.317]                         for (restart in restarts) {
[13:20:05.317]                           name <- restart$name
[13:20:05.317]                           if (is.null(name)) 
[13:20:05.317]                             next
[13:20:05.317]                           if (!grepl(pattern, name)) 
[13:20:05.317]                             next
[13:20:05.317]                           invokeRestart(restart)
[13:20:05.317]                           muffled <- TRUE
[13:20:05.317]                           break
[13:20:05.317]                         }
[13:20:05.317]                       }
[13:20:05.317]                     }
[13:20:05.317]                     invisible(muffled)
[13:20:05.317]                   }
[13:20:05.317]                   muffleCondition(cond)
[13:20:05.317]                 })
[13:20:05.317]             }))
[13:20:05.317]             future::FutureResult(value = ...future.value$value, 
[13:20:05.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.317]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.317]                     ...future.globalenv.names))
[13:20:05.317]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.317]         }, condition = base::local({
[13:20:05.317]             c <- base::c
[13:20:05.317]             inherits <- base::inherits
[13:20:05.317]             invokeRestart <- base::invokeRestart
[13:20:05.317]             length <- base::length
[13:20:05.317]             list <- base::list
[13:20:05.317]             seq.int <- base::seq.int
[13:20:05.317]             signalCondition <- base::signalCondition
[13:20:05.317]             sys.calls <- base::sys.calls
[13:20:05.317]             `[[` <- base::`[[`
[13:20:05.317]             `+` <- base::`+`
[13:20:05.317]             `<<-` <- base::`<<-`
[13:20:05.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.317]                   3L)]
[13:20:05.317]             }
[13:20:05.317]             function(cond) {
[13:20:05.317]                 is_error <- inherits(cond, "error")
[13:20:05.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.317]                   NULL)
[13:20:05.317]                 if (is_error) {
[13:20:05.317]                   sessionInformation <- function() {
[13:20:05.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.317]                       search = base::search(), system = base::Sys.info())
[13:20:05.317]                   }
[13:20:05.317]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.317]                     cond$call), session = sessionInformation(), 
[13:20:05.317]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.317]                   signalCondition(cond)
[13:20:05.317]                 }
[13:20:05.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.317]                 "immediateCondition"))) {
[13:20:05.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.317]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.317]                   if (TRUE && !signal) {
[13:20:05.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.317]                     {
[13:20:05.317]                       inherits <- base::inherits
[13:20:05.317]                       invokeRestart <- base::invokeRestart
[13:20:05.317]                       is.null <- base::is.null
[13:20:05.317]                       muffled <- FALSE
[13:20:05.317]                       if (inherits(cond, "message")) {
[13:20:05.317]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.317]                         if (muffled) 
[13:20:05.317]                           invokeRestart("muffleMessage")
[13:20:05.317]                       }
[13:20:05.317]                       else if (inherits(cond, "warning")) {
[13:20:05.317]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.317]                         if (muffled) 
[13:20:05.317]                           invokeRestart("muffleWarning")
[13:20:05.317]                       }
[13:20:05.317]                       else if (inherits(cond, "condition")) {
[13:20:05.317]                         if (!is.null(pattern)) {
[13:20:05.317]                           computeRestarts <- base::computeRestarts
[13:20:05.317]                           grepl <- base::grepl
[13:20:05.317]                           restarts <- computeRestarts(cond)
[13:20:05.317]                           for (restart in restarts) {
[13:20:05.317]                             name <- restart$name
[13:20:05.317]                             if (is.null(name)) 
[13:20:05.317]                               next
[13:20:05.317]                             if (!grepl(pattern, name)) 
[13:20:05.317]                               next
[13:20:05.317]                             invokeRestart(restart)
[13:20:05.317]                             muffled <- TRUE
[13:20:05.317]                             break
[13:20:05.317]                           }
[13:20:05.317]                         }
[13:20:05.317]                       }
[13:20:05.317]                       invisible(muffled)
[13:20:05.317]                     }
[13:20:05.317]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.317]                   }
[13:20:05.317]                 }
[13:20:05.317]                 else {
[13:20:05.317]                   if (TRUE) {
[13:20:05.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.317]                     {
[13:20:05.317]                       inherits <- base::inherits
[13:20:05.317]                       invokeRestart <- base::invokeRestart
[13:20:05.317]                       is.null <- base::is.null
[13:20:05.317]                       muffled <- FALSE
[13:20:05.317]                       if (inherits(cond, "message")) {
[13:20:05.317]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.317]                         if (muffled) 
[13:20:05.317]                           invokeRestart("muffleMessage")
[13:20:05.317]                       }
[13:20:05.317]                       else if (inherits(cond, "warning")) {
[13:20:05.317]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.317]                         if (muffled) 
[13:20:05.317]                           invokeRestart("muffleWarning")
[13:20:05.317]                       }
[13:20:05.317]                       else if (inherits(cond, "condition")) {
[13:20:05.317]                         if (!is.null(pattern)) {
[13:20:05.317]                           computeRestarts <- base::computeRestarts
[13:20:05.317]                           grepl <- base::grepl
[13:20:05.317]                           restarts <- computeRestarts(cond)
[13:20:05.317]                           for (restart in restarts) {
[13:20:05.317]                             name <- restart$name
[13:20:05.317]                             if (is.null(name)) 
[13:20:05.317]                               next
[13:20:05.317]                             if (!grepl(pattern, name)) 
[13:20:05.317]                               next
[13:20:05.317]                             invokeRestart(restart)
[13:20:05.317]                             muffled <- TRUE
[13:20:05.317]                             break
[13:20:05.317]                           }
[13:20:05.317]                         }
[13:20:05.317]                       }
[13:20:05.317]                       invisible(muffled)
[13:20:05.317]                     }
[13:20:05.317]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.317]                   }
[13:20:05.317]                 }
[13:20:05.317]             }
[13:20:05.317]         }))
[13:20:05.317]     }, error = function(ex) {
[13:20:05.317]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.317]                 ...future.rng), started = ...future.startTime, 
[13:20:05.317]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.317]             version = "1.8"), class = "FutureResult")
[13:20:05.317]     }, finally = {
[13:20:05.317]         if (!identical(...future.workdir, getwd())) 
[13:20:05.317]             setwd(...future.workdir)
[13:20:05.317]         {
[13:20:05.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.317]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.317]             }
[13:20:05.317]             base::options(...future.oldOptions)
[13:20:05.317]             if (.Platform$OS.type == "windows") {
[13:20:05.317]                 old_names <- names(...future.oldEnvVars)
[13:20:05.317]                 envs <- base::Sys.getenv()
[13:20:05.317]                 names <- names(envs)
[13:20:05.317]                 common <- intersect(names, old_names)
[13:20:05.317]                 added <- setdiff(names, old_names)
[13:20:05.317]                 removed <- setdiff(old_names, names)
[13:20:05.317]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.317]                   envs[common]]
[13:20:05.317]                 NAMES <- toupper(changed)
[13:20:05.317]                 args <- list()
[13:20:05.317]                 for (kk in seq_along(NAMES)) {
[13:20:05.317]                   name <- changed[[kk]]
[13:20:05.317]                   NAME <- NAMES[[kk]]
[13:20:05.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.317]                     next
[13:20:05.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.317]                 }
[13:20:05.317]                 NAMES <- toupper(added)
[13:20:05.317]                 for (kk in seq_along(NAMES)) {
[13:20:05.317]                   name <- added[[kk]]
[13:20:05.317]                   NAME <- NAMES[[kk]]
[13:20:05.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.317]                     next
[13:20:05.317]                   args[[name]] <- ""
[13:20:05.317]                 }
[13:20:05.317]                 NAMES <- toupper(removed)
[13:20:05.317]                 for (kk in seq_along(NAMES)) {
[13:20:05.317]                   name <- removed[[kk]]
[13:20:05.317]                   NAME <- NAMES[[kk]]
[13:20:05.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.317]                     next
[13:20:05.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.317]                 }
[13:20:05.317]                 if (length(args) > 0) 
[13:20:05.317]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.317]             }
[13:20:05.317]             else {
[13:20:05.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.317]             }
[13:20:05.317]             {
[13:20:05.317]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.317]                   0L) {
[13:20:05.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.317]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.317]                   base::options(opts)
[13:20:05.317]                 }
[13:20:05.317]                 {
[13:20:05.317]                   {
[13:20:05.317]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.317]                     NULL
[13:20:05.317]                   }
[13:20:05.317]                   options(future.plan = NULL)
[13:20:05.317]                   if (is.na(NA_character_)) 
[13:20:05.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.317]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:05.317]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:05.317]                     envir = parent.frame()) 
[13:20:05.317]                   {
[13:20:05.317]                     if (is.function(workers)) 
[13:20:05.317]                       workers <- workers()
[13:20:05.317]                     workers <- structure(as.integer(workers), 
[13:20:05.317]                       class = class(workers))
[13:20:05.317]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:05.317]                       workers >= 1)
[13:20:05.317]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:05.317]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:05.317]                     }
[13:20:05.317]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:05.317]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:05.317]                       envir = envir)
[13:20:05.317]                     if (!future$lazy) 
[13:20:05.317]                       future <- run(future)
[13:20:05.317]                     invisible(future)
[13:20:05.317]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.317]                 }
[13:20:05.317]             }
[13:20:05.317]         }
[13:20:05.317]     })
[13:20:05.317]     if (TRUE) {
[13:20:05.317]         base::sink(type = "output", split = FALSE)
[13:20:05.317]         if (TRUE) {
[13:20:05.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.317]         }
[13:20:05.317]         else {
[13:20:05.317]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.317]         }
[13:20:05.317]         base::close(...future.stdout)
[13:20:05.317]         ...future.stdout <- NULL
[13:20:05.317]     }
[13:20:05.317]     ...future.result$conditions <- ...future.conditions
[13:20:05.317]     ...future.result$finished <- base::Sys.time()
[13:20:05.317]     ...future.result
[13:20:05.317] }
[13:20:05.320] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:20:05.320] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:20:05.320] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:20:05.320] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:20:05.321] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.321] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:20:05.321] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:20:05.321] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:20:05.322] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.322] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:20:05.322] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:20:05.322] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:20:05.323] MultisessionFuture started
[13:20:05.323] - Launch lazy future ... done
[13:20:05.323] run() for ‘MultisessionFuture’ ... done
[13:20:05.323] Created future:
[13:20:05.323] MultisessionFuture:
[13:20:05.323] Label: ‘future_by-1’
[13:20:05.323] Expression:
[13:20:05.323] {
[13:20:05.323]     do.call(function(...) {
[13:20:05.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.323]             on.exit(options(oopts), add = TRUE)
[13:20:05.323]         }
[13:20:05.323]         {
[13:20:05.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.323]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.323]             })
[13:20:05.323]         }
[13:20:05.323]     }, args = future.call.arguments)
[13:20:05.323] }
[13:20:05.323] Lazy evaluation: FALSE
[13:20:05.323] Asynchronous evaluation: TRUE
[13:20:05.323] Local evaluation: TRUE
[13:20:05.323] Environment: 0x55acf07011f8
[13:20:05.323] Capture standard output: TRUE
[13:20:05.323] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.323] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.323] Packages: <none>
[13:20:05.323] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.323] Resolved: FALSE
[13:20:05.323] Value: <not collected>
[13:20:05.323] Conditions captured: <none>
[13:20:05.323] Early signaling: FALSE
[13:20:05.323] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:05.323] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.335] Chunk #1 of 2 ... DONE
[13:20:05.335] Chunk #2 of 2 ...
[13:20:05.335]  - Finding globals in 'X' for chunk #2 ...
[13:20:05.335] getGlobalsAndPackages() ...
[13:20:05.335] Searching for globals...
[13:20:05.336] 
[13:20:05.336] Searching for globals ... DONE
[13:20:05.336] - globals: [0] <none>
[13:20:05.336] getGlobalsAndPackages() ... DONE
[13:20:05.336]    + additional globals found: [n=0] 
[13:20:05.336]    + additional namespaces needed: [n=0] 
[13:20:05.336]  - Finding globals in 'X' for chunk #2 ... DONE
[13:20:05.337]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:20:05.337]  - seeds: <none>
[13:20:05.337]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.337] getGlobalsAndPackages() ...
[13:20:05.337] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.337] Resolving globals: FALSE
[13:20:05.337] Tweak future expression to call with '...' arguments ...
[13:20:05.337] {
[13:20:05.337]     do.call(function(...) {
[13:20:05.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.337]             on.exit(options(oopts), add = TRUE)
[13:20:05.337]         }
[13:20:05.337]         {
[13:20:05.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.337]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.337]             })
[13:20:05.337]         }
[13:20:05.337]     }, args = future.call.arguments)
[13:20:05.337] }
[13:20:05.338] Tweak future expression to call with '...' arguments ... DONE
[13:20:05.338] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:20:05.338] 
[13:20:05.338] getGlobalsAndPackages() ... DONE
[13:20:05.338] run() for ‘Future’ ...
[13:20:05.339] - state: ‘created’
[13:20:05.339] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:05.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:05.353]   - Field: ‘node’
[13:20:05.353]   - Field: ‘label’
[13:20:05.353]   - Field: ‘local’
[13:20:05.354]   - Field: ‘owner’
[13:20:05.354]   - Field: ‘envir’
[13:20:05.354]   - Field: ‘workers’
[13:20:05.354]   - Field: ‘packages’
[13:20:05.354]   - Field: ‘gc’
[13:20:05.354]   - Field: ‘conditions’
[13:20:05.354]   - Field: ‘persistent’
[13:20:05.354]   - Field: ‘expr’
[13:20:05.354]   - Field: ‘uuid’
[13:20:05.354]   - Field: ‘seed’
[13:20:05.354]   - Field: ‘version’
[13:20:05.355]   - Field: ‘result’
[13:20:05.355]   - Field: ‘asynchronous’
[13:20:05.355]   - Field: ‘calls’
[13:20:05.355]   - Field: ‘globals’
[13:20:05.355]   - Field: ‘stdout’
[13:20:05.355]   - Field: ‘earlySignal’
[13:20:05.355]   - Field: ‘lazy’
[13:20:05.355]   - Field: ‘state’
[13:20:05.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:05.355] - Launch lazy future ...
[13:20:05.356] Packages needed by the future expression (n = 0): <none>
[13:20:05.356] Packages needed by future strategies (n = 0): <none>
[13:20:05.356] {
[13:20:05.356]     {
[13:20:05.356]         {
[13:20:05.356]             ...future.startTime <- base::Sys.time()
[13:20:05.356]             {
[13:20:05.356]                 {
[13:20:05.356]                   {
[13:20:05.356]                     {
[13:20:05.356]                       base::local({
[13:20:05.356]                         has_future <- base::requireNamespace("future", 
[13:20:05.356]                           quietly = TRUE)
[13:20:05.356]                         if (has_future) {
[13:20:05.356]                           ns <- base::getNamespace("future")
[13:20:05.356]                           version <- ns[[".package"]][["version"]]
[13:20:05.356]                           if (is.null(version)) 
[13:20:05.356]                             version <- utils::packageVersion("future")
[13:20:05.356]                         }
[13:20:05.356]                         else {
[13:20:05.356]                           version <- NULL
[13:20:05.356]                         }
[13:20:05.356]                         if (!has_future || version < "1.8.0") {
[13:20:05.356]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:05.356]                             "", base::R.version$version.string), 
[13:20:05.356]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:05.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:05.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:05.356]                               "release", "version")], collapse = " "), 
[13:20:05.356]                             hostname = base::Sys.info()[["nodename"]])
[13:20:05.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:05.356]                             info)
[13:20:05.356]                           info <- base::paste(info, collapse = "; ")
[13:20:05.356]                           if (!has_future) {
[13:20:05.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:05.356]                               info)
[13:20:05.356]                           }
[13:20:05.356]                           else {
[13:20:05.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:05.356]                               info, version)
[13:20:05.356]                           }
[13:20:05.356]                           base::stop(msg)
[13:20:05.356]                         }
[13:20:05.356]                       })
[13:20:05.356]                     }
[13:20:05.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:05.356]                     base::options(mc.cores = 1L)
[13:20:05.356]                   }
[13:20:05.356]                   options(future.plan = NULL)
[13:20:05.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:05.356]                 }
[13:20:05.356]                 ...future.workdir <- getwd()
[13:20:05.356]             }
[13:20:05.356]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:05.356]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:05.356]         }
[13:20:05.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:20:05.356]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:20:05.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:20:05.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:20:05.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:05.356]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:05.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:05.356]             base::names(...future.oldOptions))
[13:20:05.356]     }
[13:20:05.356]     if (FALSE) {
[13:20:05.356]     }
[13:20:05.356]     else {
[13:20:05.356]         if (TRUE) {
[13:20:05.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:05.356]                 open = "w")
[13:20:05.356]         }
[13:20:05.356]         else {
[13:20:05.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:05.356]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:05.356]         }
[13:20:05.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:05.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:05.356]             base::sink(type = "output", split = FALSE)
[13:20:05.356]             base::close(...future.stdout)
[13:20:05.356]         }, add = TRUE)
[13:20:05.356]     }
[13:20:05.356]     ...future.frame <- base::sys.nframe()
[13:20:05.356]     ...future.conditions <- base::list()
[13:20:05.356]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:05.356]     if (FALSE) {
[13:20:05.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:05.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:05.356]     }
[13:20:05.356]     ...future.result <- base::tryCatch({
[13:20:05.356]         base::withCallingHandlers({
[13:20:05.356]             ...future.value <- base::withVisible(base::local({
[13:20:05.356]                 ...future.makeSendCondition <- base::local({
[13:20:05.356]                   sendCondition <- NULL
[13:20:05.356]                   function(frame = 1L) {
[13:20:05.356]                     if (is.function(sendCondition)) 
[13:20:05.356]                       return(sendCondition)
[13:20:05.356]                     ns <- getNamespace("parallel")
[13:20:05.356]                     if (exists("sendData", mode = "function", 
[13:20:05.356]                       envir = ns)) {
[13:20:05.356]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:05.356]                         envir = ns)
[13:20:05.356]                       envir <- sys.frame(frame)
[13:20:05.356]                       master <- NULL
[13:20:05.356]                       while (!identical(envir, .GlobalEnv) && 
[13:20:05.356]                         !identical(envir, emptyenv())) {
[13:20:05.356]                         if (exists("master", mode = "list", envir = envir, 
[13:20:05.356]                           inherits = FALSE)) {
[13:20:05.356]                           master <- get("master", mode = "list", 
[13:20:05.356]                             envir = envir, inherits = FALSE)
[13:20:05.356]                           if (inherits(master, c("SOCKnode", 
[13:20:05.356]                             "SOCK0node"))) {
[13:20:05.356]                             sendCondition <<- function(cond) {
[13:20:05.356]                               data <- list(type = "VALUE", value = cond, 
[13:20:05.356]                                 success = TRUE)
[13:20:05.356]                               parallel_sendData(master, data)
[13:20:05.356]                             }
[13:20:05.356]                             return(sendCondition)
[13:20:05.356]                           }
[13:20:05.356]                         }
[13:20:05.356]                         frame <- frame + 1L
[13:20:05.356]                         envir <- sys.frame(frame)
[13:20:05.356]                       }
[13:20:05.356]                     }
[13:20:05.356]                     sendCondition <<- function(cond) NULL
[13:20:05.356]                   }
[13:20:05.356]                 })
[13:20:05.356]                 withCallingHandlers({
[13:20:05.356]                   {
[13:20:05.356]                     do.call(function(...) {
[13:20:05.356]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.356]                       if (!identical(...future.globals.maxSize.org, 
[13:20:05.356]                         ...future.globals.maxSize)) {
[13:20:05.356]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.356]                         on.exit(options(oopts), add = TRUE)
[13:20:05.356]                       }
[13:20:05.356]                       {
[13:20:05.356]                         lapply(seq_along(...future.elements_ii), 
[13:20:05.356]                           FUN = function(jj) {
[13:20:05.356]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.356]                             ...future.FUN(...future.X_jj, ...)
[13:20:05.356]                           })
[13:20:05.356]                       }
[13:20:05.356]                     }, args = future.call.arguments)
[13:20:05.356]                   }
[13:20:05.356]                 }, immediateCondition = function(cond) {
[13:20:05.356]                   sendCondition <- ...future.makeSendCondition()
[13:20:05.356]                   sendCondition(cond)
[13:20:05.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.356]                   {
[13:20:05.356]                     inherits <- base::inherits
[13:20:05.356]                     invokeRestart <- base::invokeRestart
[13:20:05.356]                     is.null <- base::is.null
[13:20:05.356]                     muffled <- FALSE
[13:20:05.356]                     if (inherits(cond, "message")) {
[13:20:05.356]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:05.356]                       if (muffled) 
[13:20:05.356]                         invokeRestart("muffleMessage")
[13:20:05.356]                     }
[13:20:05.356]                     else if (inherits(cond, "warning")) {
[13:20:05.356]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:05.356]                       if (muffled) 
[13:20:05.356]                         invokeRestart("muffleWarning")
[13:20:05.356]                     }
[13:20:05.356]                     else if (inherits(cond, "condition")) {
[13:20:05.356]                       if (!is.null(pattern)) {
[13:20:05.356]                         computeRestarts <- base::computeRestarts
[13:20:05.356]                         grepl <- base::grepl
[13:20:05.356]                         restarts <- computeRestarts(cond)
[13:20:05.356]                         for (restart in restarts) {
[13:20:05.356]                           name <- restart$name
[13:20:05.356]                           if (is.null(name)) 
[13:20:05.356]                             next
[13:20:05.356]                           if (!grepl(pattern, name)) 
[13:20:05.356]                             next
[13:20:05.356]                           invokeRestart(restart)
[13:20:05.356]                           muffled <- TRUE
[13:20:05.356]                           break
[13:20:05.356]                         }
[13:20:05.356]                       }
[13:20:05.356]                     }
[13:20:05.356]                     invisible(muffled)
[13:20:05.356]                   }
[13:20:05.356]                   muffleCondition(cond)
[13:20:05.356]                 })
[13:20:05.356]             }))
[13:20:05.356]             future::FutureResult(value = ...future.value$value, 
[13:20:05.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.356]                   ...future.rng), globalenv = if (FALSE) 
[13:20:05.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:05.356]                     ...future.globalenv.names))
[13:20:05.356]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:05.356]         }, condition = base::local({
[13:20:05.356]             c <- base::c
[13:20:05.356]             inherits <- base::inherits
[13:20:05.356]             invokeRestart <- base::invokeRestart
[13:20:05.356]             length <- base::length
[13:20:05.356]             list <- base::list
[13:20:05.356]             seq.int <- base::seq.int
[13:20:05.356]             signalCondition <- base::signalCondition
[13:20:05.356]             sys.calls <- base::sys.calls
[13:20:05.356]             `[[` <- base::`[[`
[13:20:05.356]             `+` <- base::`+`
[13:20:05.356]             `<<-` <- base::`<<-`
[13:20:05.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:05.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:05.356]                   3L)]
[13:20:05.356]             }
[13:20:05.356]             function(cond) {
[13:20:05.356]                 is_error <- inherits(cond, "error")
[13:20:05.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:05.356]                   NULL)
[13:20:05.356]                 if (is_error) {
[13:20:05.356]                   sessionInformation <- function() {
[13:20:05.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:05.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:05.356]                       search = base::search(), system = base::Sys.info())
[13:20:05.356]                   }
[13:20:05.356]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:05.356]                     cond$call), session = sessionInformation(), 
[13:20:05.356]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:05.356]                   signalCondition(cond)
[13:20:05.356]                 }
[13:20:05.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:05.356]                 "immediateCondition"))) {
[13:20:05.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:05.356]                   ...future.conditions[[length(...future.conditions) + 
[13:20:05.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:05.356]                   if (TRUE && !signal) {
[13:20:05.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.356]                     {
[13:20:05.356]                       inherits <- base::inherits
[13:20:05.356]                       invokeRestart <- base::invokeRestart
[13:20:05.356]                       is.null <- base::is.null
[13:20:05.356]                       muffled <- FALSE
[13:20:05.356]                       if (inherits(cond, "message")) {
[13:20:05.356]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.356]                         if (muffled) 
[13:20:05.356]                           invokeRestart("muffleMessage")
[13:20:05.356]                       }
[13:20:05.356]                       else if (inherits(cond, "warning")) {
[13:20:05.356]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.356]                         if (muffled) 
[13:20:05.356]                           invokeRestart("muffleWarning")
[13:20:05.356]                       }
[13:20:05.356]                       else if (inherits(cond, "condition")) {
[13:20:05.356]                         if (!is.null(pattern)) {
[13:20:05.356]                           computeRestarts <- base::computeRestarts
[13:20:05.356]                           grepl <- base::grepl
[13:20:05.356]                           restarts <- computeRestarts(cond)
[13:20:05.356]                           for (restart in restarts) {
[13:20:05.356]                             name <- restart$name
[13:20:05.356]                             if (is.null(name)) 
[13:20:05.356]                               next
[13:20:05.356]                             if (!grepl(pattern, name)) 
[13:20:05.356]                               next
[13:20:05.356]                             invokeRestart(restart)
[13:20:05.356]                             muffled <- TRUE
[13:20:05.356]                             break
[13:20:05.356]                           }
[13:20:05.356]                         }
[13:20:05.356]                       }
[13:20:05.356]                       invisible(muffled)
[13:20:05.356]                     }
[13:20:05.356]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.356]                   }
[13:20:05.356]                 }
[13:20:05.356]                 else {
[13:20:05.356]                   if (TRUE) {
[13:20:05.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:05.356]                     {
[13:20:05.356]                       inherits <- base::inherits
[13:20:05.356]                       invokeRestart <- base::invokeRestart
[13:20:05.356]                       is.null <- base::is.null
[13:20:05.356]                       muffled <- FALSE
[13:20:05.356]                       if (inherits(cond, "message")) {
[13:20:05.356]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:05.356]                         if (muffled) 
[13:20:05.356]                           invokeRestart("muffleMessage")
[13:20:05.356]                       }
[13:20:05.356]                       else if (inherits(cond, "warning")) {
[13:20:05.356]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:05.356]                         if (muffled) 
[13:20:05.356]                           invokeRestart("muffleWarning")
[13:20:05.356]                       }
[13:20:05.356]                       else if (inherits(cond, "condition")) {
[13:20:05.356]                         if (!is.null(pattern)) {
[13:20:05.356]                           computeRestarts <- base::computeRestarts
[13:20:05.356]                           grepl <- base::grepl
[13:20:05.356]                           restarts <- computeRestarts(cond)
[13:20:05.356]                           for (restart in restarts) {
[13:20:05.356]                             name <- restart$name
[13:20:05.356]                             if (is.null(name)) 
[13:20:05.356]                               next
[13:20:05.356]                             if (!grepl(pattern, name)) 
[13:20:05.356]                               next
[13:20:05.356]                             invokeRestart(restart)
[13:20:05.356]                             muffled <- TRUE
[13:20:05.356]                             break
[13:20:05.356]                           }
[13:20:05.356]                         }
[13:20:05.356]                       }
[13:20:05.356]                       invisible(muffled)
[13:20:05.356]                     }
[13:20:05.356]                     muffleCondition(cond, pattern = "^muffle")
[13:20:05.356]                   }
[13:20:05.356]                 }
[13:20:05.356]             }
[13:20:05.356]         }))
[13:20:05.356]     }, error = function(ex) {
[13:20:05.356]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:05.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:05.356]                 ...future.rng), started = ...future.startTime, 
[13:20:05.356]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:05.356]             version = "1.8"), class = "FutureResult")
[13:20:05.356]     }, finally = {
[13:20:05.356]         if (!identical(...future.workdir, getwd())) 
[13:20:05.356]             setwd(...future.workdir)
[13:20:05.356]         {
[13:20:05.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:05.356]                 ...future.oldOptions$nwarnings <- NULL
[13:20:05.356]             }
[13:20:05.356]             base::options(...future.oldOptions)
[13:20:05.356]             if (.Platform$OS.type == "windows") {
[13:20:05.356]                 old_names <- names(...future.oldEnvVars)
[13:20:05.356]                 envs <- base::Sys.getenv()
[13:20:05.356]                 names <- names(envs)
[13:20:05.356]                 common <- intersect(names, old_names)
[13:20:05.356]                 added <- setdiff(names, old_names)
[13:20:05.356]                 removed <- setdiff(old_names, names)
[13:20:05.356]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:05.356]                   envs[common]]
[13:20:05.356]                 NAMES <- toupper(changed)
[13:20:05.356]                 args <- list()
[13:20:05.356]                 for (kk in seq_along(NAMES)) {
[13:20:05.356]                   name <- changed[[kk]]
[13:20:05.356]                   NAME <- NAMES[[kk]]
[13:20:05.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.356]                     next
[13:20:05.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.356]                 }
[13:20:05.356]                 NAMES <- toupper(added)
[13:20:05.356]                 for (kk in seq_along(NAMES)) {
[13:20:05.356]                   name <- added[[kk]]
[13:20:05.356]                   NAME <- NAMES[[kk]]
[13:20:05.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.356]                     next
[13:20:05.356]                   args[[name]] <- ""
[13:20:05.356]                 }
[13:20:05.356]                 NAMES <- toupper(removed)
[13:20:05.356]                 for (kk in seq_along(NAMES)) {
[13:20:05.356]                   name <- removed[[kk]]
[13:20:05.356]                   NAME <- NAMES[[kk]]
[13:20:05.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:05.356]                     next
[13:20:05.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:05.356]                 }
[13:20:05.356]                 if (length(args) > 0) 
[13:20:05.356]                   base::do.call(base::Sys.setenv, args = args)
[13:20:05.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:05.356]             }
[13:20:05.356]             else {
[13:20:05.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:05.356]             }
[13:20:05.356]             {
[13:20:05.356]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:05.356]                   0L) {
[13:20:05.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:05.356]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:05.356]                   base::options(opts)
[13:20:05.356]                 }
[13:20:05.356]                 {
[13:20:05.356]                   {
[13:20:05.356]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:05.356]                     NULL
[13:20:05.356]                   }
[13:20:05.356]                   options(future.plan = NULL)
[13:20:05.356]                   if (is.na(NA_character_)) 
[13:20:05.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:05.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:05.356]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:05.356]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:05.356]                     envir = parent.frame()) 
[13:20:05.356]                   {
[13:20:05.356]                     if (is.function(workers)) 
[13:20:05.356]                       workers <- workers()
[13:20:05.356]                     workers <- structure(as.integer(workers), 
[13:20:05.356]                       class = class(workers))
[13:20:05.356]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:05.356]                       workers >= 1)
[13:20:05.356]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:05.356]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:05.356]                     }
[13:20:05.356]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:05.356]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:05.356]                       envir = envir)
[13:20:05.356]                     if (!future$lazy) 
[13:20:05.356]                       future <- run(future)
[13:20:05.356]                     invisible(future)
[13:20:05.356]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:05.356]                 }
[13:20:05.356]             }
[13:20:05.356]         }
[13:20:05.356]     })
[13:20:05.356]     if (TRUE) {
[13:20:05.356]         base::sink(type = "output", split = FALSE)
[13:20:05.356]         if (TRUE) {
[13:20:05.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:05.356]         }
[13:20:05.356]         else {
[13:20:05.356]             ...future.result["stdout"] <- base::list(NULL)
[13:20:05.356]         }
[13:20:05.356]         base::close(...future.stdout)
[13:20:05.356]         ...future.stdout <- NULL
[13:20:05.356]     }
[13:20:05.356]     ...future.result$conditions <- ...future.conditions
[13:20:05.356]     ...future.result$finished <- base::Sys.time()
[13:20:05.356]     ...future.result
[13:20:05.356] }
[13:20:05.359] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:20:05.359] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:20:05.360] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:20:05.360] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:20:05.360] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.361] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:20:05.361] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:20:05.361] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:20:05.361] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.361] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:20:05.362] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:20:05.362] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:20:05.362] MultisessionFuture started
[13:20:05.362] - Launch lazy future ... done
[13:20:05.363] run() for ‘MultisessionFuture’ ... done
[13:20:05.363] Created future:
[13:20:05.363] MultisessionFuture:
[13:20:05.363] Label: ‘future_by-2’
[13:20:05.363] Expression:
[13:20:05.363] {
[13:20:05.363]     do.call(function(...) {
[13:20:05.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:20:05.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:20:05.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:20:05.363]             on.exit(options(oopts), add = TRUE)
[13:20:05.363]         }
[13:20:05.363]         {
[13:20:05.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:20:05.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:20:05.363]                 ...future.FUN(...future.X_jj, ...)
[13:20:05.363]             })
[13:20:05.363]         }
[13:20:05.363]     }, args = future.call.arguments)
[13:20:05.363] }
[13:20:05.363] Lazy evaluation: FALSE
[13:20:05.363] Asynchronous evaluation: TRUE
[13:20:05.363] Local evaluation: TRUE
[13:20:05.363] Environment: 0x55acf07011f8
[13:20:05.363] Capture standard output: TRUE
[13:20:05.363] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:20:05.363] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:20:05.363] Packages: <none>
[13:20:05.363] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:20:05.363] Resolved: FALSE
[13:20:05.363] Value: <not collected>
[13:20:05.363] Conditions captured: <none>
[13:20:05.363] Early signaling: FALSE
[13:20:05.363] Owner process: db250dd6-9c3e-1a29-680a-17fb9eb1797d
[13:20:05.363] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:05.375] Chunk #2 of 2 ... DONE
[13:20:05.375] Launching 2 futures (chunks) ... DONE
[13:20:05.375] Resolving 2 futures (chunks) ...
[13:20:05.375] resolve() on list ...
[13:20:05.375]  recursive: 0
[13:20:05.375]  length: 2
[13:20:05.375] 
[13:20:05.376] receiveMessageFromWorker() for ClusterFuture ...
[13:20:05.376] - Validating connection of MultisessionFuture
[13:20:05.376] - received message: FutureResult
[13:20:05.376] - Received FutureResult
[13:20:05.376] - Erased future from FutureRegistry
[13:20:05.377] result() for ClusterFuture ...
[13:20:05.377] - result already collected: FutureResult
[13:20:05.377] result() for ClusterFuture ... done
[13:20:05.377] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:05.377] Future #1
[13:20:05.377] result() for ClusterFuture ...
[13:20:05.377] - result already collected: FutureResult
[13:20:05.377] result() for ClusterFuture ... done
[13:20:05.377] result() for ClusterFuture ...
[13:20:05.377] - result already collected: FutureResult
[13:20:05.377] result() for ClusterFuture ... done
[13:20:05.378] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:20:05.378] - nx: 2
[13:20:05.378] - relay: TRUE
[13:20:05.378] - stdout: TRUE
[13:20:05.378] - signal: TRUE
[13:20:05.378] - resignal: FALSE
[13:20:05.378] - force: TRUE
[13:20:05.378] - relayed: [n=2] FALSE, FALSE
[13:20:05.378] - queued futures: [n=2] FALSE, FALSE
[13:20:05.378]  - until=1
[13:20:05.378]  - relaying element #1
[13:20:05.378] result() for ClusterFuture ...
[13:20:05.379] - result already collected: FutureResult
[13:20:05.379] result() for ClusterFuture ... done
[13:20:05.379] result() for ClusterFuture ...
[13:20:05.379] - result already collected: FutureResult
[13:20:05.379] result() for ClusterFuture ... done
[13:20:05.379] result() for ClusterFuture ...
[13:20:05.379] - result already collected: FutureResult
[13:20:05.379] result() for ClusterFuture ... done
[13:20:05.379] result() for ClusterFuture ...
[13:20:05.379] - result already collected: FutureResult
[13:20:05.379] result() for ClusterFuture ... done
[13:20:05.379] - relayed: [n=2] TRUE, FALSE
[13:20:05.380] - queued futures: [n=2] TRUE, FALSE
[13:20:05.380] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:20:05.380]  length: 1 (resolved future 1)
[13:20:05.410] receiveMessageFromWorker() for ClusterFuture ...
[13:20:05.411] - Validating connection of MultisessionFuture
[13:20:05.411] - received message: FutureResult
[13:20:05.411] - Received FutureResult
[13:20:05.411] - Erased future from FutureRegistry
[13:20:05.411] result() for ClusterFuture ...
[13:20:05.411] - result already collected: FutureResult
[13:20:05.411] result() for ClusterFuture ... done
[13:20:05.411] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:05.412] Future #2
[13:20:05.412] result() for ClusterFuture ...
[13:20:05.412] - result already collected: FutureResult
[13:20:05.412] result() for ClusterFuture ... done
[13:20:05.412] result() for ClusterFuture ...
[13:20:05.412] - result already collected: FutureResult
[13:20:05.412] result() for ClusterFuture ... done
[13:20:05.412] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:20:05.412] - nx: 2
[13:20:05.412] - relay: TRUE
[13:20:05.413] - stdout: TRUE
[13:20:05.413] - signal: TRUE
[13:20:05.413] - resignal: FALSE
[13:20:05.413] - force: TRUE
[13:20:05.413] - relayed: [n=2] TRUE, FALSE
[13:20:05.413] - queued futures: [n=2] TRUE, FALSE
[13:20:05.413]  - until=2
[13:20:05.413]  - relaying element #2
[13:20:05.413] result() for ClusterFuture ...
[13:20:05.413] - result already collected: FutureResult
[13:20:05.413] result() for ClusterFuture ... done
[13:20:05.413] result() for ClusterFuture ...
[13:20:05.414] - result already collected: FutureResult
[13:20:05.414] result() for ClusterFuture ... done
[13:20:05.414] result() for ClusterFuture ...
[13:20:05.414] - result already collected: FutureResult
[13:20:05.414] result() for ClusterFuture ... done
[13:20:05.414] result() for ClusterFuture ...
[13:20:05.414] - result already collected: FutureResult
[13:20:05.414] result() for ClusterFuture ... done
[13:20:05.414] - relayed: [n=2] TRUE, TRUE
[13:20:05.414] - queued futures: [n=2] TRUE, TRUE
[13:20:05.414] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:20:05.415]  length: 0 (resolved future 2)
[13:20:05.415] Relaying remaining futures
[13:20:05.415] signalConditionsASAP(NULL, pos=0) ...
[13:20:05.415] - nx: 2
[13:20:05.415] - relay: TRUE
[13:20:05.415] - stdout: TRUE
[13:20:05.415] - signal: TRUE
[13:20:05.415] - resignal: FALSE
[13:20:05.415] - force: TRUE
[13:20:05.415] - relayed: [n=2] TRUE, TRUE
[13:20:05.415] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:20:05.416] - relayed: [n=2] TRUE, TRUE
[13:20:05.416] - queued futures: [n=2] TRUE, TRUE
[13:20:05.416] signalConditionsASAP(NULL, pos=0) ... done
[13:20:05.416] resolve() on list ... DONE
[13:20:05.416] result() for ClusterFuture ...
[13:20:05.416] - result already collected: FutureResult
[13:20:05.416] result() for ClusterFuture ... done
[13:20:05.416] result() for ClusterFuture ...
[13:20:05.416] - result already collected: FutureResult
[13:20:05.416] result() for ClusterFuture ... done
[13:20:05.417] result() for ClusterFuture ...
[13:20:05.417] - result already collected: FutureResult
[13:20:05.417] result() for ClusterFuture ... done
[13:20:05.417] result() for ClusterFuture ...
[13:20:05.417] - result already collected: FutureResult
[13:20:05.417] result() for ClusterFuture ... done
[13:20:05.417]  - Number of value chunks collected: 2
[13:20:05.417] Resolving 2 futures (chunks) ... DONE
[13:20:05.417] Reducing values from 2 chunks ...
[13:20:05.417]  - Number of values collected after concatenation: 3
[13:20:05.417]  - Number of values expected: 3
[13:20:05.418] Reducing values from 2 chunks ... DONE
[13:20:05.418] future_lapply() ... DONE
[13:20:05.418] future_by_internal() ... DONE
[13:20:05.419] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[13:20:05.420] plan(): Setting new future strategy stack:
[13:20:05.420] List of future strategies:
[13:20:05.420] 1. FutureStrategy:
[13:20:05.420]    - args: function (..., envir = parent.frame())
[13:20:05.420]    - tweaked: FALSE
[13:20:05.420]    - call: future::plan(oplan)
[13:20:05.420] plan(): nbrOfWorkers() = 1
> 
