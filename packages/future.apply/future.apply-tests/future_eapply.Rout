
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:43:55.671] plan(): Setting new future strategy stack:
[17:43:55.671] List of future strategies:
[17:43:55.671] 1. sequential:
[17:43:55.671]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.671]    - tweaked: FALSE
[17:43:55.671]    - call: future::plan("sequential")
[17:43:55.685] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:43:55.706] plan(): Setting new future strategy stack:
[17:43:55.706] List of future strategies:
[17:43:55.706] 1. sequential:
[17:43:55.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.706]    - tweaked: FALSE
[17:43:55.706]    - call: plan(strategy)
[17:43:55.719] plan(): nbrOfWorkers() = 1
[17:43:55.720] future_lapply() ...
[17:43:55.724] Number of chunks: 1
[17:43:55.724] getGlobalsAndPackagesXApply() ...
[17:43:55.724]  - future.globals: TRUE
[17:43:55.725] getGlobalsAndPackages() ...
[17:43:55.725] Searching for globals...
[17:43:55.727] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.727] Searching for globals ... DONE
[17:43:55.727] Resolving globals: FALSE
[17:43:55.728] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:55.728] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:55.728] - globals: [1] ‘FUN’
[17:43:55.729] 
[17:43:55.729] getGlobalsAndPackages() ... DONE
[17:43:55.729]  - globals found/used: [n=1] ‘FUN’
[17:43:55.729]  - needed namespaces: [n=0] 
[17:43:55.729] Finding globals ... DONE
[17:43:55.729]  - use_args: TRUE
[17:43:55.729]  - Getting '...' globals ...
[17:43:55.730] resolve() on list ...
[17:43:55.730]  recursive: 0
[17:43:55.730]  length: 1
[17:43:55.730]  elements: ‘...’
[17:43:55.730]  length: 0 (resolved future 1)
[17:43:55.731] resolve() on list ... DONE
[17:43:55.731]    - '...' content: [n=0] 
[17:43:55.731] List of 1
[17:43:55.731]  $ ...: list()
[17:43:55.731]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.731]  - attr(*, "where")=List of 1
[17:43:55.731]   ..$ ...:<environment: 0x55813c14bd78> 
[17:43:55.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.731]  - attr(*, "resolved")= logi TRUE
[17:43:55.731]  - attr(*, "total_size")= num NA
[17:43:55.735]  - Getting '...' globals ... DONE
[17:43:55.736] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.736] List of 2
[17:43:55.736]  $ ...future.FUN:function (x, ...)  
[17:43:55.736]  $ ...          : list()
[17:43:55.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.736]  - attr(*, "where")=List of 2
[17:43:55.736]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.736]   ..$ ...          :<environment: 0x55813c14bd78> 
[17:43:55.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.736]  - attr(*, "resolved")= logi FALSE
[17:43:55.736]  - attr(*, "total_size")= num 1240
[17:43:55.738] Packages to be attached in all futures: [n=0] 
[17:43:55.738] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.739] Number of futures (= number of chunks): 1
[17:43:55.739] Launching 1 futures (chunks) ...
[17:43:55.739] Chunk #1 of 1 ...
[17:43:55.739]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.739] getGlobalsAndPackages() ...
[17:43:55.739] Searching for globals...
[17:43:55.739] 
[17:43:55.740] Searching for globals ... DONE
[17:43:55.740] - globals: [0] <none>
[17:43:55.740] getGlobalsAndPackages() ... DONE
[17:43:55.740]    + additional globals found: [n=0] 
[17:43:55.740]    + additional namespaces needed: [n=0] 
[17:43:55.740]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.740]  - seeds: <none>
[17:43:55.740]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.740] getGlobalsAndPackages() ...
[17:43:55.740] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.741] Resolving globals: FALSE
[17:43:55.741] Tweak future expression to call with '...' arguments ...
[17:43:55.741] {
[17:43:55.741]     do.call(function(...) {
[17:43:55.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.741]             on.exit(options(oopts), add = TRUE)
[17:43:55.741]         }
[17:43:55.741]         {
[17:43:55.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.741]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.741]             })
[17:43:55.741]         }
[17:43:55.741]     }, args = future.call.arguments)
[17:43:55.741] }
[17:43:55.741] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.741] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.741] 
[17:43:55.742] getGlobalsAndPackages() ... DONE
[17:43:55.742] run() for ‘Future’ ...
[17:43:55.742] - state: ‘created’
[17:43:55.743] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:55.743] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:55.743]   - Field: ‘label’
[17:43:55.743]   - Field: ‘local’
[17:43:55.743]   - Field: ‘owner’
[17:43:55.743]   - Field: ‘envir’
[17:43:55.743]   - Field: ‘packages’
[17:43:55.744]   - Field: ‘gc’
[17:43:55.744]   - Field: ‘conditions’
[17:43:55.744]   - Field: ‘expr’
[17:43:55.744]   - Field: ‘uuid’
[17:43:55.744]   - Field: ‘seed’
[17:43:55.744]   - Field: ‘version’
[17:43:55.744]   - Field: ‘result’
[17:43:55.744]   - Field: ‘asynchronous’
[17:43:55.744]   - Field: ‘calls’
[17:43:55.744]   - Field: ‘globals’
[17:43:55.744]   - Field: ‘stdout’
[17:43:55.745]   - Field: ‘earlySignal’
[17:43:55.745]   - Field: ‘lazy’
[17:43:55.745]   - Field: ‘state’
[17:43:55.745] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:55.745] - Launch lazy future ...
[17:43:55.746] Packages needed by the future expression (n = 0): <none>
[17:43:55.746] Packages needed by future strategies (n = 0): <none>
[17:43:55.746] {
[17:43:55.746]     {
[17:43:55.746]         {
[17:43:55.746]             ...future.startTime <- base::Sys.time()
[17:43:55.746]             {
[17:43:55.746]                 {
[17:43:55.746]                   {
[17:43:55.746]                     base::local({
[17:43:55.746]                       has_future <- base::requireNamespace("future", 
[17:43:55.746]                         quietly = TRUE)
[17:43:55.746]                       if (has_future) {
[17:43:55.746]                         ns <- base::getNamespace("future")
[17:43:55.746]                         version <- ns[[".package"]][["version"]]
[17:43:55.746]                         if (is.null(version)) 
[17:43:55.746]                           version <- utils::packageVersion("future")
[17:43:55.746]                       }
[17:43:55.746]                       else {
[17:43:55.746]                         version <- NULL
[17:43:55.746]                       }
[17:43:55.746]                       if (!has_future || version < "1.8.0") {
[17:43:55.746]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.746]                           "", base::R.version$version.string), 
[17:43:55.746]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:55.746]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.746]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.746]                             "release", "version")], collapse = " "), 
[17:43:55.746]                           hostname = base::Sys.info()[["nodename"]])
[17:43:55.746]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.746]                           info)
[17:43:55.746]                         info <- base::paste(info, collapse = "; ")
[17:43:55.746]                         if (!has_future) {
[17:43:55.746]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.746]                             info)
[17:43:55.746]                         }
[17:43:55.746]                         else {
[17:43:55.746]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.746]                             info, version)
[17:43:55.746]                         }
[17:43:55.746]                         base::stop(msg)
[17:43:55.746]                       }
[17:43:55.746]                     })
[17:43:55.746]                   }
[17:43:55.746]                   ...future.strategy.old <- future::plan("list")
[17:43:55.746]                   options(future.plan = NULL)
[17:43:55.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.746]                 }
[17:43:55.746]                 ...future.workdir <- getwd()
[17:43:55.746]             }
[17:43:55.746]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.746]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.746]         }
[17:43:55.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.746]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.746]             base::names(...future.oldOptions))
[17:43:55.746]     }
[17:43:55.746]     if (FALSE) {
[17:43:55.746]     }
[17:43:55.746]     else {
[17:43:55.746]         if (TRUE) {
[17:43:55.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.746]                 open = "w")
[17:43:55.746]         }
[17:43:55.746]         else {
[17:43:55.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.746]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.746]         }
[17:43:55.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.746]             base::sink(type = "output", split = FALSE)
[17:43:55.746]             base::close(...future.stdout)
[17:43:55.746]         }, add = TRUE)
[17:43:55.746]     }
[17:43:55.746]     ...future.frame <- base::sys.nframe()
[17:43:55.746]     ...future.conditions <- base::list()
[17:43:55.746]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.746]     if (FALSE) {
[17:43:55.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.746]     }
[17:43:55.746]     ...future.result <- base::tryCatch({
[17:43:55.746]         base::withCallingHandlers({
[17:43:55.746]             ...future.value <- base::withVisible(base::local({
[17:43:55.746]                 do.call(function(...) {
[17:43:55.746]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.746]                   if (!identical(...future.globals.maxSize.org, 
[17:43:55.746]                     ...future.globals.maxSize)) {
[17:43:55.746]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.746]                     on.exit(options(oopts), add = TRUE)
[17:43:55.746]                   }
[17:43:55.746]                   {
[17:43:55.746]                     lapply(seq_along(...future.elements_ii), 
[17:43:55.746]                       FUN = function(jj) {
[17:43:55.746]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.746]                         ...future.FUN(...future.X_jj, ...)
[17:43:55.746]                       })
[17:43:55.746]                   }
[17:43:55.746]                 }, args = future.call.arguments)
[17:43:55.746]             }))
[17:43:55.746]             future::FutureResult(value = ...future.value$value, 
[17:43:55.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.746]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.746]                     ...future.globalenv.names))
[17:43:55.746]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.746]         }, condition = base::local({
[17:43:55.746]             c <- base::c
[17:43:55.746]             inherits <- base::inherits
[17:43:55.746]             invokeRestart <- base::invokeRestart
[17:43:55.746]             length <- base::length
[17:43:55.746]             list <- base::list
[17:43:55.746]             seq.int <- base::seq.int
[17:43:55.746]             signalCondition <- base::signalCondition
[17:43:55.746]             sys.calls <- base::sys.calls
[17:43:55.746]             `[[` <- base::`[[`
[17:43:55.746]             `+` <- base::`+`
[17:43:55.746]             `<<-` <- base::`<<-`
[17:43:55.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.746]                   3L)]
[17:43:55.746]             }
[17:43:55.746]             function(cond) {
[17:43:55.746]                 is_error <- inherits(cond, "error")
[17:43:55.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.746]                   NULL)
[17:43:55.746]                 if (is_error) {
[17:43:55.746]                   sessionInformation <- function() {
[17:43:55.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.746]                       search = base::search(), system = base::Sys.info())
[17:43:55.746]                   }
[17:43:55.746]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.746]                     cond$call), session = sessionInformation(), 
[17:43:55.746]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.746]                   signalCondition(cond)
[17:43:55.746]                 }
[17:43:55.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.746]                 "immediateCondition"))) {
[17:43:55.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.746]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.746]                   if (TRUE && !signal) {
[17:43:55.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.746]                     {
[17:43:55.746]                       inherits <- base::inherits
[17:43:55.746]                       invokeRestart <- base::invokeRestart
[17:43:55.746]                       is.null <- base::is.null
[17:43:55.746]                       muffled <- FALSE
[17:43:55.746]                       if (inherits(cond, "message")) {
[17:43:55.746]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.746]                         if (muffled) 
[17:43:55.746]                           invokeRestart("muffleMessage")
[17:43:55.746]                       }
[17:43:55.746]                       else if (inherits(cond, "warning")) {
[17:43:55.746]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.746]                         if (muffled) 
[17:43:55.746]                           invokeRestart("muffleWarning")
[17:43:55.746]                       }
[17:43:55.746]                       else if (inherits(cond, "condition")) {
[17:43:55.746]                         if (!is.null(pattern)) {
[17:43:55.746]                           computeRestarts <- base::computeRestarts
[17:43:55.746]                           grepl <- base::grepl
[17:43:55.746]                           restarts <- computeRestarts(cond)
[17:43:55.746]                           for (restart in restarts) {
[17:43:55.746]                             name <- restart$name
[17:43:55.746]                             if (is.null(name)) 
[17:43:55.746]                               next
[17:43:55.746]                             if (!grepl(pattern, name)) 
[17:43:55.746]                               next
[17:43:55.746]                             invokeRestart(restart)
[17:43:55.746]                             muffled <- TRUE
[17:43:55.746]                             break
[17:43:55.746]                           }
[17:43:55.746]                         }
[17:43:55.746]                       }
[17:43:55.746]                       invisible(muffled)
[17:43:55.746]                     }
[17:43:55.746]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.746]                   }
[17:43:55.746]                 }
[17:43:55.746]                 else {
[17:43:55.746]                   if (TRUE) {
[17:43:55.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.746]                     {
[17:43:55.746]                       inherits <- base::inherits
[17:43:55.746]                       invokeRestart <- base::invokeRestart
[17:43:55.746]                       is.null <- base::is.null
[17:43:55.746]                       muffled <- FALSE
[17:43:55.746]                       if (inherits(cond, "message")) {
[17:43:55.746]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.746]                         if (muffled) 
[17:43:55.746]                           invokeRestart("muffleMessage")
[17:43:55.746]                       }
[17:43:55.746]                       else if (inherits(cond, "warning")) {
[17:43:55.746]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.746]                         if (muffled) 
[17:43:55.746]                           invokeRestart("muffleWarning")
[17:43:55.746]                       }
[17:43:55.746]                       else if (inherits(cond, "condition")) {
[17:43:55.746]                         if (!is.null(pattern)) {
[17:43:55.746]                           computeRestarts <- base::computeRestarts
[17:43:55.746]                           grepl <- base::grepl
[17:43:55.746]                           restarts <- computeRestarts(cond)
[17:43:55.746]                           for (restart in restarts) {
[17:43:55.746]                             name <- restart$name
[17:43:55.746]                             if (is.null(name)) 
[17:43:55.746]                               next
[17:43:55.746]                             if (!grepl(pattern, name)) 
[17:43:55.746]                               next
[17:43:55.746]                             invokeRestart(restart)
[17:43:55.746]                             muffled <- TRUE
[17:43:55.746]                             break
[17:43:55.746]                           }
[17:43:55.746]                         }
[17:43:55.746]                       }
[17:43:55.746]                       invisible(muffled)
[17:43:55.746]                     }
[17:43:55.746]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.746]                   }
[17:43:55.746]                 }
[17:43:55.746]             }
[17:43:55.746]         }))
[17:43:55.746]     }, error = function(ex) {
[17:43:55.746]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.746]                 ...future.rng), started = ...future.startTime, 
[17:43:55.746]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.746]             version = "1.8"), class = "FutureResult")
[17:43:55.746]     }, finally = {
[17:43:55.746]         if (!identical(...future.workdir, getwd())) 
[17:43:55.746]             setwd(...future.workdir)
[17:43:55.746]         {
[17:43:55.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.746]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.746]             }
[17:43:55.746]             base::options(...future.oldOptions)
[17:43:55.746]             if (.Platform$OS.type == "windows") {
[17:43:55.746]                 old_names <- names(...future.oldEnvVars)
[17:43:55.746]                 envs <- base::Sys.getenv()
[17:43:55.746]                 names <- names(envs)
[17:43:55.746]                 common <- intersect(names, old_names)
[17:43:55.746]                 added <- setdiff(names, old_names)
[17:43:55.746]                 removed <- setdiff(old_names, names)
[17:43:55.746]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.746]                   envs[common]]
[17:43:55.746]                 NAMES <- toupper(changed)
[17:43:55.746]                 args <- list()
[17:43:55.746]                 for (kk in seq_along(NAMES)) {
[17:43:55.746]                   name <- changed[[kk]]
[17:43:55.746]                   NAME <- NAMES[[kk]]
[17:43:55.746]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.746]                     next
[17:43:55.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.746]                 }
[17:43:55.746]                 NAMES <- toupper(added)
[17:43:55.746]                 for (kk in seq_along(NAMES)) {
[17:43:55.746]                   name <- added[[kk]]
[17:43:55.746]                   NAME <- NAMES[[kk]]
[17:43:55.746]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.746]                     next
[17:43:55.746]                   args[[name]] <- ""
[17:43:55.746]                 }
[17:43:55.746]                 NAMES <- toupper(removed)
[17:43:55.746]                 for (kk in seq_along(NAMES)) {
[17:43:55.746]                   name <- removed[[kk]]
[17:43:55.746]                   NAME <- NAMES[[kk]]
[17:43:55.746]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.746]                     next
[17:43:55.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.746]                 }
[17:43:55.746]                 if (length(args) > 0) 
[17:43:55.746]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.746]             }
[17:43:55.746]             else {
[17:43:55.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.746]             }
[17:43:55.746]             {
[17:43:55.746]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.746]                   0L) {
[17:43:55.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.746]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.746]                   base::options(opts)
[17:43:55.746]                 }
[17:43:55.746]                 {
[17:43:55.746]                   {
[17:43:55.746]                     NULL
[17:43:55.746]                     RNGkind("Mersenne-Twister")
[17:43:55.746]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:55.746]                       inherits = FALSE)
[17:43:55.746]                   }
[17:43:55.746]                   options(future.plan = NULL)
[17:43:55.746]                   if (is.na(NA_character_)) 
[17:43:55.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.746]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.746]                     .init = FALSE)
[17:43:55.746]                 }
[17:43:55.746]             }
[17:43:55.746]         }
[17:43:55.746]     })
[17:43:55.746]     if (TRUE) {
[17:43:55.746]         base::sink(type = "output", split = FALSE)
[17:43:55.746]         if (TRUE) {
[17:43:55.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.746]         }
[17:43:55.746]         else {
[17:43:55.746]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.746]         }
[17:43:55.746]         base::close(...future.stdout)
[17:43:55.746]         ...future.stdout <- NULL
[17:43:55.746]     }
[17:43:55.746]     ...future.result$conditions <- ...future.conditions
[17:43:55.746]     ...future.result$finished <- base::Sys.time()
[17:43:55.746]     ...future.result
[17:43:55.746] }
[17:43:55.748] assign_globals() ...
[17:43:55.748] List of 5
[17:43:55.748]  $ ...future.FUN            :function (x, ...)  
[17:43:55.748]  $ future.call.arguments    : list()
[17:43:55.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.748]  $ ...future.elements_ii    :List of 3
[17:43:55.748]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:43:55.748]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:55.748]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:55.748]  $ ...future.seeds_ii       : NULL
[17:43:55.748]  $ ...future.globals.maxSize: NULL
[17:43:55.748]  - attr(*, "where")=List of 5
[17:43:55.748]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:55.748]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:55.748]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:55.748]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:55.748]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:55.748]  - attr(*, "resolved")= logi FALSE
[17:43:55.748]  - attr(*, "total_size")= num 1240
[17:43:55.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.748]  - attr(*, "already-done")= logi TRUE
[17:43:55.756] - copied ‘...future.FUN’ to environment
[17:43:55.756] - copied ‘future.call.arguments’ to environment
[17:43:55.756] - copied ‘...future.elements_ii’ to environment
[17:43:55.756] - copied ‘...future.seeds_ii’ to environment
[17:43:55.756] - copied ‘...future.globals.maxSize’ to environment
[17:43:55.757] assign_globals() ... done
[17:43:55.757] plan(): Setting new future strategy stack:
[17:43:55.757] List of future strategies:
[17:43:55.757] 1. sequential:
[17:43:55.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.757]    - tweaked: FALSE
[17:43:55.757]    - call: NULL
[17:43:55.757] plan(): nbrOfWorkers() = 1
[17:43:55.758] plan(): Setting new future strategy stack:
[17:43:55.759] List of future strategies:
[17:43:55.759] 1. sequential:
[17:43:55.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.759]    - tweaked: FALSE
[17:43:55.759]    - call: plan(strategy)
[17:43:55.759] plan(): nbrOfWorkers() = 1
[17:43:55.759] SequentialFuture started (and completed)
[17:43:55.760] - Launch lazy future ... done
[17:43:55.760] run() for ‘SequentialFuture’ ... done
[17:43:55.760] Created future:
[17:43:55.760] SequentialFuture:
[17:43:55.760] Label: ‘future_eapply-1’
[17:43:55.760] Expression:
[17:43:55.760] {
[17:43:55.760]     do.call(function(...) {
[17:43:55.760]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.760]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.760]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.760]             on.exit(options(oopts), add = TRUE)
[17:43:55.760]         }
[17:43:55.760]         {
[17:43:55.760]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.760]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.760]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.760]             })
[17:43:55.760]         }
[17:43:55.760]     }, args = future.call.arguments)
[17:43:55.760] }
[17:43:55.760] Lazy evaluation: FALSE
[17:43:55.760] Asynchronous evaluation: FALSE
[17:43:55.760] Local evaluation: TRUE
[17:43:55.760] Environment: R_GlobalEnv
[17:43:55.760] Capture standard output: TRUE
[17:43:55.760] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.760] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.760] Packages: <none>
[17:43:55.760] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.760] Resolved: TRUE
[17:43:55.760] Value: 168 bytes of class ‘list’
[17:43:55.760] Early signaling: FALSE
[17:43:55.760] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:55.760] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.761] Chunk #1 of 1 ... DONE
[17:43:55.761] Launching 1 futures (chunks) ... DONE
[17:43:55.761] Resolving 1 futures (chunks) ...
[17:43:55.762] resolve() on list ...
[17:43:55.762]  recursive: 0
[17:43:55.762]  length: 1
[17:43:55.762] 
[17:43:55.762] resolved() for ‘SequentialFuture’ ...
[17:43:55.762] - state: ‘finished’
[17:43:55.762] - run: TRUE
[17:43:55.762] - result: ‘FutureResult’
[17:43:55.762] resolved() for ‘SequentialFuture’ ... done
[17:43:55.763] Future #1
[17:43:55.763] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:55.763] - nx: 1
[17:43:55.763] - relay: TRUE
[17:43:55.763] - stdout: TRUE
[17:43:55.763] - signal: TRUE
[17:43:55.763] - resignal: FALSE
[17:43:55.763] - force: TRUE
[17:43:55.763] - relayed: [n=1] FALSE
[17:43:55.764] - queued futures: [n=1] FALSE
[17:43:55.764]  - until=1
[17:43:55.764]  - relaying element #1
[17:43:55.764] - relayed: [n=1] TRUE
[17:43:55.764] - queued futures: [n=1] TRUE
[17:43:55.764] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:55.764]  length: 0 (resolved future 1)
[17:43:55.764] Relaying remaining futures
[17:43:55.764] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.765] - nx: 1
[17:43:55.765] - relay: TRUE
[17:43:55.765] - stdout: TRUE
[17:43:55.765] - signal: TRUE
[17:43:55.765] - resignal: FALSE
[17:43:55.765] - force: TRUE
[17:43:55.765] - relayed: [n=1] TRUE
[17:43:55.765] - queued futures: [n=1] TRUE
 - flush all
[17:43:55.765] - relayed: [n=1] TRUE
[17:43:55.765] - queued futures: [n=1] TRUE
[17:43:55.765] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.766] resolve() on list ... DONE
[17:43:55.766]  - Number of value chunks collected: 1
[17:43:55.766] Resolving 1 futures (chunks) ... DONE
[17:43:55.766] Reducing values from 1 chunks ...
[17:43:55.766]  - Number of values collected after concatenation: 3
[17:43:55.766]  - Number of values expected: 3
[17:43:55.766] Reducing values from 1 chunks ... DONE
[17:43:55.766] future_lapply() ... DONE
[17:43:55.768] future_lapply() ...
[17:43:55.769] Number of chunks: 1
[17:43:55.769] getGlobalsAndPackagesXApply() ...
[17:43:55.769]  - future.globals: TRUE
[17:43:55.769] getGlobalsAndPackages() ...
[17:43:55.769] Searching for globals...
[17:43:55.770] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.770] Searching for globals ... DONE
[17:43:55.770] Resolving globals: FALSE
[17:43:55.770] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:55.771] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:55.771] - globals: [1] ‘FUN’
[17:43:55.771] - packages: [1] ‘stats’
[17:43:55.771] getGlobalsAndPackages() ... DONE
[17:43:55.771]  - globals found/used: [n=1] ‘FUN’
[17:43:55.771]  - needed namespaces: [n=1] ‘stats’
[17:43:55.771] Finding globals ... DONE
[17:43:55.771]  - use_args: TRUE
[17:43:55.772]  - Getting '...' globals ...
[17:43:55.772] resolve() on list ...
[17:43:55.772]  recursive: 0
[17:43:55.772]  length: 1
[17:43:55.772]  elements: ‘...’
[17:43:55.772]  length: 0 (resolved future 1)
[17:43:55.772] resolve() on list ... DONE
[17:43:55.772]    - '...' content: [n=1] ‘probs’
[17:43:55.773] List of 1
[17:43:55.773]  $ ...:List of 1
[17:43:55.773]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:55.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.773]  - attr(*, "where")=List of 1
[17:43:55.773]   ..$ ...:<environment: 0x55813dfa78c0> 
[17:43:55.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.773]  - attr(*, "resolved")= logi TRUE
[17:43:55.773]  - attr(*, "total_size")= num NA
[17:43:55.775]  - Getting '...' globals ... DONE
[17:43:55.775] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.776] List of 2
[17:43:55.776]  $ ...future.FUN:function (x, ...)  
[17:43:55.776]  $ ...          :List of 1
[17:43:55.776]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:55.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.776]  - attr(*, "where")=List of 2
[17:43:55.776]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.776]   ..$ ...          :<environment: 0x55813dfa78c0> 
[17:43:55.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.776]  - attr(*, "resolved")= logi FALSE
[17:43:55.776]  - attr(*, "total_size")= num 1328
[17:43:55.778] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:55.778] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.779] Number of futures (= number of chunks): 1
[17:43:55.779] Launching 1 futures (chunks) ...
[17:43:55.779] Chunk #1 of 1 ...
[17:43:55.779]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.779] getGlobalsAndPackages() ...
[17:43:55.779] Searching for globals...
[17:43:55.779] 
[17:43:55.779] Searching for globals ... DONE
[17:43:55.780] - globals: [0] <none>
[17:43:55.780] getGlobalsAndPackages() ... DONE
[17:43:55.780]    + additional globals found: [n=0] 
[17:43:55.781]    + additional namespaces needed: [n=0] 
[17:43:55.781]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.781]  - seeds: <none>
[17:43:55.781]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.782] getGlobalsAndPackages() ...
[17:43:55.782] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.782] Resolving globals: FALSE
[17:43:55.782] Tweak future expression to call with '...' arguments ...
[17:43:55.782] {
[17:43:55.782]     do.call(function(...) {
[17:43:55.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.782]             on.exit(options(oopts), add = TRUE)
[17:43:55.782]         }
[17:43:55.782]         {
[17:43:55.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.782]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.782]             })
[17:43:55.782]         }
[17:43:55.782]     }, args = future.call.arguments)
[17:43:55.782] }
[17:43:55.782] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.783] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.783] - packages: [1] ‘stats’
[17:43:55.783] getGlobalsAndPackages() ... DONE
[17:43:55.783] run() for ‘Future’ ...
[17:43:55.783] - state: ‘created’
[17:43:55.783] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:55.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:55.784]   - Field: ‘label’
[17:43:55.784]   - Field: ‘local’
[17:43:55.784]   - Field: ‘owner’
[17:43:55.784]   - Field: ‘envir’
[17:43:55.784]   - Field: ‘packages’
[17:43:55.784]   - Field: ‘gc’
[17:43:55.784]   - Field: ‘conditions’
[17:43:55.784]   - Field: ‘expr’
[17:43:55.784]   - Field: ‘uuid’
[17:43:55.785]   - Field: ‘seed’
[17:43:55.785]   - Field: ‘version’
[17:43:55.785]   - Field: ‘result’
[17:43:55.785]   - Field: ‘asynchronous’
[17:43:55.785]   - Field: ‘calls’
[17:43:55.785]   - Field: ‘globals’
[17:43:55.785]   - Field: ‘stdout’
[17:43:55.785]   - Field: ‘earlySignal’
[17:43:55.785]   - Field: ‘lazy’
[17:43:55.785]   - Field: ‘state’
[17:43:55.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:55.786] - Launch lazy future ...
[17:43:55.786] Packages needed by the future expression (n = 1): ‘stats’
[17:43:55.786] Packages needed by future strategies (n = 0): <none>
[17:43:55.786] {
[17:43:55.786]     {
[17:43:55.786]         {
[17:43:55.786]             ...future.startTime <- base::Sys.time()
[17:43:55.786]             {
[17:43:55.786]                 {
[17:43:55.786]                   {
[17:43:55.786]                     {
[17:43:55.786]                       base::local({
[17:43:55.786]                         has_future <- base::requireNamespace("future", 
[17:43:55.786]                           quietly = TRUE)
[17:43:55.786]                         if (has_future) {
[17:43:55.786]                           ns <- base::getNamespace("future")
[17:43:55.786]                           version <- ns[[".package"]][["version"]]
[17:43:55.786]                           if (is.null(version)) 
[17:43:55.786]                             version <- utils::packageVersion("future")
[17:43:55.786]                         }
[17:43:55.786]                         else {
[17:43:55.786]                           version <- NULL
[17:43:55.786]                         }
[17:43:55.786]                         if (!has_future || version < "1.8.0") {
[17:43:55.786]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.786]                             "", base::R.version$version.string), 
[17:43:55.786]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.786]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.786]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.786]                               "release", "version")], collapse = " "), 
[17:43:55.786]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.786]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.786]                             info)
[17:43:55.786]                           info <- base::paste(info, collapse = "; ")
[17:43:55.786]                           if (!has_future) {
[17:43:55.786]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.786]                               info)
[17:43:55.786]                           }
[17:43:55.786]                           else {
[17:43:55.786]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.786]                               info, version)
[17:43:55.786]                           }
[17:43:55.786]                           base::stop(msg)
[17:43:55.786]                         }
[17:43:55.786]                       })
[17:43:55.786]                     }
[17:43:55.786]                     base::local({
[17:43:55.786]                       for (pkg in "stats") {
[17:43:55.786]                         base::loadNamespace(pkg)
[17:43:55.786]                         base::library(pkg, character.only = TRUE)
[17:43:55.786]                       }
[17:43:55.786]                     })
[17:43:55.786]                   }
[17:43:55.786]                   ...future.strategy.old <- future::plan("list")
[17:43:55.786]                   options(future.plan = NULL)
[17:43:55.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.786]                 }
[17:43:55.786]                 ...future.workdir <- getwd()
[17:43:55.786]             }
[17:43:55.786]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.786]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.786]         }
[17:43:55.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.786]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.786]             base::names(...future.oldOptions))
[17:43:55.786]     }
[17:43:55.786]     if (FALSE) {
[17:43:55.786]     }
[17:43:55.786]     else {
[17:43:55.786]         if (TRUE) {
[17:43:55.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.786]                 open = "w")
[17:43:55.786]         }
[17:43:55.786]         else {
[17:43:55.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.786]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.786]         }
[17:43:55.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.786]             base::sink(type = "output", split = FALSE)
[17:43:55.786]             base::close(...future.stdout)
[17:43:55.786]         }, add = TRUE)
[17:43:55.786]     }
[17:43:55.786]     ...future.frame <- base::sys.nframe()
[17:43:55.786]     ...future.conditions <- base::list()
[17:43:55.786]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.786]     if (FALSE) {
[17:43:55.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.786]     }
[17:43:55.786]     ...future.result <- base::tryCatch({
[17:43:55.786]         base::withCallingHandlers({
[17:43:55.786]             ...future.value <- base::withVisible(base::local({
[17:43:55.786]                 do.call(function(...) {
[17:43:55.786]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.786]                   if (!identical(...future.globals.maxSize.org, 
[17:43:55.786]                     ...future.globals.maxSize)) {
[17:43:55.786]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.786]                     on.exit(options(oopts), add = TRUE)
[17:43:55.786]                   }
[17:43:55.786]                   {
[17:43:55.786]                     lapply(seq_along(...future.elements_ii), 
[17:43:55.786]                       FUN = function(jj) {
[17:43:55.786]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.786]                         ...future.FUN(...future.X_jj, ...)
[17:43:55.786]                       })
[17:43:55.786]                   }
[17:43:55.786]                 }, args = future.call.arguments)
[17:43:55.786]             }))
[17:43:55.786]             future::FutureResult(value = ...future.value$value, 
[17:43:55.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.786]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.786]                     ...future.globalenv.names))
[17:43:55.786]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.786]         }, condition = base::local({
[17:43:55.786]             c <- base::c
[17:43:55.786]             inherits <- base::inherits
[17:43:55.786]             invokeRestart <- base::invokeRestart
[17:43:55.786]             length <- base::length
[17:43:55.786]             list <- base::list
[17:43:55.786]             seq.int <- base::seq.int
[17:43:55.786]             signalCondition <- base::signalCondition
[17:43:55.786]             sys.calls <- base::sys.calls
[17:43:55.786]             `[[` <- base::`[[`
[17:43:55.786]             `+` <- base::`+`
[17:43:55.786]             `<<-` <- base::`<<-`
[17:43:55.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.786]                   3L)]
[17:43:55.786]             }
[17:43:55.786]             function(cond) {
[17:43:55.786]                 is_error <- inherits(cond, "error")
[17:43:55.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.786]                   NULL)
[17:43:55.786]                 if (is_error) {
[17:43:55.786]                   sessionInformation <- function() {
[17:43:55.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.786]                       search = base::search(), system = base::Sys.info())
[17:43:55.786]                   }
[17:43:55.786]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.786]                     cond$call), session = sessionInformation(), 
[17:43:55.786]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.786]                   signalCondition(cond)
[17:43:55.786]                 }
[17:43:55.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.786]                 "immediateCondition"))) {
[17:43:55.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.786]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.786]                   if (TRUE && !signal) {
[17:43:55.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.786]                     {
[17:43:55.786]                       inherits <- base::inherits
[17:43:55.786]                       invokeRestart <- base::invokeRestart
[17:43:55.786]                       is.null <- base::is.null
[17:43:55.786]                       muffled <- FALSE
[17:43:55.786]                       if (inherits(cond, "message")) {
[17:43:55.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.786]                         if (muffled) 
[17:43:55.786]                           invokeRestart("muffleMessage")
[17:43:55.786]                       }
[17:43:55.786]                       else if (inherits(cond, "warning")) {
[17:43:55.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.786]                         if (muffled) 
[17:43:55.786]                           invokeRestart("muffleWarning")
[17:43:55.786]                       }
[17:43:55.786]                       else if (inherits(cond, "condition")) {
[17:43:55.786]                         if (!is.null(pattern)) {
[17:43:55.786]                           computeRestarts <- base::computeRestarts
[17:43:55.786]                           grepl <- base::grepl
[17:43:55.786]                           restarts <- computeRestarts(cond)
[17:43:55.786]                           for (restart in restarts) {
[17:43:55.786]                             name <- restart$name
[17:43:55.786]                             if (is.null(name)) 
[17:43:55.786]                               next
[17:43:55.786]                             if (!grepl(pattern, name)) 
[17:43:55.786]                               next
[17:43:55.786]                             invokeRestart(restart)
[17:43:55.786]                             muffled <- TRUE
[17:43:55.786]                             break
[17:43:55.786]                           }
[17:43:55.786]                         }
[17:43:55.786]                       }
[17:43:55.786]                       invisible(muffled)
[17:43:55.786]                     }
[17:43:55.786]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.786]                   }
[17:43:55.786]                 }
[17:43:55.786]                 else {
[17:43:55.786]                   if (TRUE) {
[17:43:55.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.786]                     {
[17:43:55.786]                       inherits <- base::inherits
[17:43:55.786]                       invokeRestart <- base::invokeRestart
[17:43:55.786]                       is.null <- base::is.null
[17:43:55.786]                       muffled <- FALSE
[17:43:55.786]                       if (inherits(cond, "message")) {
[17:43:55.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.786]                         if (muffled) 
[17:43:55.786]                           invokeRestart("muffleMessage")
[17:43:55.786]                       }
[17:43:55.786]                       else if (inherits(cond, "warning")) {
[17:43:55.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.786]                         if (muffled) 
[17:43:55.786]                           invokeRestart("muffleWarning")
[17:43:55.786]                       }
[17:43:55.786]                       else if (inherits(cond, "condition")) {
[17:43:55.786]                         if (!is.null(pattern)) {
[17:43:55.786]                           computeRestarts <- base::computeRestarts
[17:43:55.786]                           grepl <- base::grepl
[17:43:55.786]                           restarts <- computeRestarts(cond)
[17:43:55.786]                           for (restart in restarts) {
[17:43:55.786]                             name <- restart$name
[17:43:55.786]                             if (is.null(name)) 
[17:43:55.786]                               next
[17:43:55.786]                             if (!grepl(pattern, name)) 
[17:43:55.786]                               next
[17:43:55.786]                             invokeRestart(restart)
[17:43:55.786]                             muffled <- TRUE
[17:43:55.786]                             break
[17:43:55.786]                           }
[17:43:55.786]                         }
[17:43:55.786]                       }
[17:43:55.786]                       invisible(muffled)
[17:43:55.786]                     }
[17:43:55.786]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.786]                   }
[17:43:55.786]                 }
[17:43:55.786]             }
[17:43:55.786]         }))
[17:43:55.786]     }, error = function(ex) {
[17:43:55.786]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.786]                 ...future.rng), started = ...future.startTime, 
[17:43:55.786]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.786]             version = "1.8"), class = "FutureResult")
[17:43:55.786]     }, finally = {
[17:43:55.786]         if (!identical(...future.workdir, getwd())) 
[17:43:55.786]             setwd(...future.workdir)
[17:43:55.786]         {
[17:43:55.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.786]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.786]             }
[17:43:55.786]             base::options(...future.oldOptions)
[17:43:55.786]             if (.Platform$OS.type == "windows") {
[17:43:55.786]                 old_names <- names(...future.oldEnvVars)
[17:43:55.786]                 envs <- base::Sys.getenv()
[17:43:55.786]                 names <- names(envs)
[17:43:55.786]                 common <- intersect(names, old_names)
[17:43:55.786]                 added <- setdiff(names, old_names)
[17:43:55.786]                 removed <- setdiff(old_names, names)
[17:43:55.786]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.786]                   envs[common]]
[17:43:55.786]                 NAMES <- toupper(changed)
[17:43:55.786]                 args <- list()
[17:43:55.786]                 for (kk in seq_along(NAMES)) {
[17:43:55.786]                   name <- changed[[kk]]
[17:43:55.786]                   NAME <- NAMES[[kk]]
[17:43:55.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.786]                     next
[17:43:55.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.786]                 }
[17:43:55.786]                 NAMES <- toupper(added)
[17:43:55.786]                 for (kk in seq_along(NAMES)) {
[17:43:55.786]                   name <- added[[kk]]
[17:43:55.786]                   NAME <- NAMES[[kk]]
[17:43:55.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.786]                     next
[17:43:55.786]                   args[[name]] <- ""
[17:43:55.786]                 }
[17:43:55.786]                 NAMES <- toupper(removed)
[17:43:55.786]                 for (kk in seq_along(NAMES)) {
[17:43:55.786]                   name <- removed[[kk]]
[17:43:55.786]                   NAME <- NAMES[[kk]]
[17:43:55.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.786]                     next
[17:43:55.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.786]                 }
[17:43:55.786]                 if (length(args) > 0) 
[17:43:55.786]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.786]             }
[17:43:55.786]             else {
[17:43:55.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.786]             }
[17:43:55.786]             {
[17:43:55.786]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.786]                   0L) {
[17:43:55.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.786]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.786]                   base::options(opts)
[17:43:55.786]                 }
[17:43:55.786]                 {
[17:43:55.786]                   {
[17:43:55.786]                     NULL
[17:43:55.786]                     RNGkind("Mersenne-Twister")
[17:43:55.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:55.786]                       inherits = FALSE)
[17:43:55.786]                   }
[17:43:55.786]                   options(future.plan = NULL)
[17:43:55.786]                   if (is.na(NA_character_)) 
[17:43:55.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.786]                     .init = FALSE)
[17:43:55.786]                 }
[17:43:55.786]             }
[17:43:55.786]         }
[17:43:55.786]     })
[17:43:55.786]     if (TRUE) {
[17:43:55.786]         base::sink(type = "output", split = FALSE)
[17:43:55.786]         if (TRUE) {
[17:43:55.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.786]         }
[17:43:55.786]         else {
[17:43:55.786]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.786]         }
[17:43:55.786]         base::close(...future.stdout)
[17:43:55.786]         ...future.stdout <- NULL
[17:43:55.786]     }
[17:43:55.786]     ...future.result$conditions <- ...future.conditions
[17:43:55.786]     ...future.result$finished <- base::Sys.time()
[17:43:55.786]     ...future.result
[17:43:55.786] }
[17:43:55.788] assign_globals() ...
[17:43:55.788] List of 5
[17:43:55.788]  $ ...future.FUN            :function (x, ...)  
[17:43:55.788]  $ future.call.arguments    :List of 1
[17:43:55.788]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:55.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.788]  $ ...future.elements_ii    :List of 3
[17:43:55.788]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:43:55.788]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:55.788]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:55.788]  $ ...future.seeds_ii       : NULL
[17:43:55.788]  $ ...future.globals.maxSize: NULL
[17:43:55.788]  - attr(*, "where")=List of 5
[17:43:55.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:55.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:55.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:55.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:55.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:55.788]  - attr(*, "resolved")= logi FALSE
[17:43:55.788]  - attr(*, "total_size")= num 1328
[17:43:55.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.788]  - attr(*, "already-done")= logi TRUE
[17:43:55.793] - copied ‘...future.FUN’ to environment
[17:43:55.793] - copied ‘future.call.arguments’ to environment
[17:43:55.793] - copied ‘...future.elements_ii’ to environment
[17:43:55.794] - copied ‘...future.seeds_ii’ to environment
[17:43:55.794] - copied ‘...future.globals.maxSize’ to environment
[17:43:55.794] assign_globals() ... done
[17:43:55.794] plan(): Setting new future strategy stack:
[17:43:55.794] List of future strategies:
[17:43:55.794] 1. sequential:
[17:43:55.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.794]    - tweaked: FALSE
[17:43:55.794]    - call: NULL
[17:43:55.795] plan(): nbrOfWorkers() = 1
[17:43:55.796] plan(): Setting new future strategy stack:
[17:43:55.796] List of future strategies:
[17:43:55.796] 1. sequential:
[17:43:55.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.796]    - tweaked: FALSE
[17:43:55.796]    - call: plan(strategy)
[17:43:55.796] plan(): nbrOfWorkers() = 1
[17:43:55.796] SequentialFuture started (and completed)
[17:43:55.796] - Launch lazy future ... done
[17:43:55.797] run() for ‘SequentialFuture’ ... done
[17:43:55.797] Created future:
[17:43:55.797] SequentialFuture:
[17:43:55.797] Label: ‘future_eapply-1’
[17:43:55.797] Expression:
[17:43:55.797] {
[17:43:55.797]     do.call(function(...) {
[17:43:55.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.797]             on.exit(options(oopts), add = TRUE)
[17:43:55.797]         }
[17:43:55.797]         {
[17:43:55.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.797]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.797]             })
[17:43:55.797]         }
[17:43:55.797]     }, args = future.call.arguments)
[17:43:55.797] }
[17:43:55.797] Lazy evaluation: FALSE
[17:43:55.797] Asynchronous evaluation: FALSE
[17:43:55.797] Local evaluation: TRUE
[17:43:55.797] Environment: R_GlobalEnv
[17:43:55.797] Capture standard output: TRUE
[17:43:55.797] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.797] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.797] Packages: 1 packages (‘stats’)
[17:43:55.797] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.797] Resolved: TRUE
[17:43:55.797] Value: 1.29 KiB of class ‘list’
[17:43:55.797] Early signaling: FALSE
[17:43:55.797] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:55.797] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.798] Chunk #1 of 1 ... DONE
[17:43:55.798] Launching 1 futures (chunks) ... DONE
[17:43:55.798] Resolving 1 futures (chunks) ...
[17:43:55.798] resolve() on list ...
[17:43:55.798]  recursive: 0
[17:43:55.798]  length: 1
[17:43:55.798] 
[17:43:55.798] resolved() for ‘SequentialFuture’ ...
[17:43:55.798] - state: ‘finished’
[17:43:55.798] - run: TRUE
[17:43:55.798] - result: ‘FutureResult’
[17:43:55.799] resolved() for ‘SequentialFuture’ ... done
[17:43:55.799] Future #1
[17:43:55.799] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:55.799] - nx: 1
[17:43:55.799] - relay: TRUE
[17:43:55.799] - stdout: TRUE
[17:43:55.799] - signal: TRUE
[17:43:55.799] - resignal: FALSE
[17:43:55.799] - force: TRUE
[17:43:55.799] - relayed: [n=1] FALSE
[17:43:55.799] - queued futures: [n=1] FALSE
[17:43:55.800]  - until=1
[17:43:55.800]  - relaying element #1
[17:43:55.800] - relayed: [n=1] TRUE
[17:43:55.800] - queued futures: [n=1] TRUE
[17:43:55.800] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:55.800]  length: 0 (resolved future 1)
[17:43:55.800] Relaying remaining futures
[17:43:55.800] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.800] - nx: 1
[17:43:55.800] - relay: TRUE
[17:43:55.800] - stdout: TRUE
[17:43:55.801] - signal: TRUE
[17:43:55.801] - resignal: FALSE
[17:43:55.801] - force: TRUE
[17:43:55.801] - relayed: [n=1] TRUE
[17:43:55.801] - queued futures: [n=1] TRUE
 - flush all
[17:43:55.801] - relayed: [n=1] TRUE
[17:43:55.801] - queued futures: [n=1] TRUE
[17:43:55.801] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.801] resolve() on list ... DONE
[17:43:55.801]  - Number of value chunks collected: 1
[17:43:55.801] Resolving 1 futures (chunks) ... DONE
[17:43:55.802] Reducing values from 1 chunks ...
[17:43:55.802]  - Number of values collected after concatenation: 3
[17:43:55.802]  - Number of values expected: 3
[17:43:55.802] Reducing values from 1 chunks ... DONE
[17:43:55.802] future_lapply() ... DONE
[17:43:55.803] future_lapply() ...
[17:43:55.804] Number of chunks: 1
[17:43:55.804] getGlobalsAndPackagesXApply() ...
[17:43:55.804]  - future.globals: TRUE
[17:43:55.804] getGlobalsAndPackages() ...
[17:43:55.804] Searching for globals...
[17:43:55.805] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.805] Searching for globals ... DONE
[17:43:55.805] Resolving globals: FALSE
[17:43:55.806] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:55.807] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:55.807] - globals: [1] ‘FUN’
[17:43:55.807] - packages: [1] ‘stats’
[17:43:55.807] getGlobalsAndPackages() ... DONE
[17:43:55.807]  - globals found/used: [n=1] ‘FUN’
[17:43:55.807]  - needed namespaces: [n=1] ‘stats’
[17:43:55.807] Finding globals ... DONE
[17:43:55.808]  - use_args: TRUE
[17:43:55.808]  - Getting '...' globals ...
[17:43:55.808] resolve() on list ...
[17:43:55.808]  recursive: 0
[17:43:55.808]  length: 1
[17:43:55.808]  elements: ‘...’
[17:43:55.808]  length: 0 (resolved future 1)
[17:43:55.808] resolve() on list ... DONE
[17:43:55.809]    - '...' content: [n=0] 
[17:43:55.809] List of 1
[17:43:55.809]  $ ...: list()
[17:43:55.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.809]  - attr(*, "where")=List of 1
[17:43:55.809]   ..$ ...:<environment: 0x55813e60dee0> 
[17:43:55.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.809]  - attr(*, "resolved")= logi TRUE
[17:43:55.809]  - attr(*, "total_size")= num NA
[17:43:55.811]  - Getting '...' globals ... DONE
[17:43:55.811] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.811] List of 2
[17:43:55.811]  $ ...future.FUN:function (x, ...)  
[17:43:55.811]  $ ...          : list()
[17:43:55.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.811]  - attr(*, "where")=List of 2
[17:43:55.811]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.811]   ..$ ...          :<environment: 0x55813e60dee0> 
[17:43:55.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.811]  - attr(*, "resolved")= logi FALSE
[17:43:55.811]  - attr(*, "total_size")= num 1248
[17:43:55.814] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:55.814] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.814] Number of futures (= number of chunks): 1
[17:43:55.814] Launching 1 futures (chunks) ...
[17:43:55.814] Chunk #1 of 1 ...
[17:43:55.814]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.814] getGlobalsAndPackages() ...
[17:43:55.814] Searching for globals...
[17:43:55.815] 
[17:43:55.815] Searching for globals ... DONE
[17:43:55.815] - globals: [0] <none>
[17:43:55.815] getGlobalsAndPackages() ... DONE
[17:43:55.815]    + additional globals found: [n=0] 
[17:43:55.815]    + additional namespaces needed: [n=0] 
[17:43:55.815]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.815]  - seeds: <none>
[17:43:55.815]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.815] getGlobalsAndPackages() ...
[17:43:55.816] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.816] Resolving globals: FALSE
[17:43:55.816] Tweak future expression to call with '...' arguments ...
[17:43:55.816] {
[17:43:55.816]     do.call(function(...) {
[17:43:55.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.816]             on.exit(options(oopts), add = TRUE)
[17:43:55.816]         }
[17:43:55.816]         {
[17:43:55.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.816]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.816]             })
[17:43:55.816]         }
[17:43:55.816]     }, args = future.call.arguments)
[17:43:55.816] }
[17:43:55.816] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.816] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.817] - packages: [1] ‘stats’
[17:43:55.817] getGlobalsAndPackages() ... DONE
[17:43:55.817] run() for ‘Future’ ...
[17:43:55.817] - state: ‘created’
[17:43:55.817] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:55.817] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:55.818]   - Field: ‘label’
[17:43:55.818]   - Field: ‘local’
[17:43:55.818]   - Field: ‘owner’
[17:43:55.818]   - Field: ‘envir’
[17:43:55.818]   - Field: ‘packages’
[17:43:55.818]   - Field: ‘gc’
[17:43:55.818]   - Field: ‘conditions’
[17:43:55.818]   - Field: ‘expr’
[17:43:55.818]   - Field: ‘uuid’
[17:43:55.818]   - Field: ‘seed’
[17:43:55.818]   - Field: ‘version’
[17:43:55.818]   - Field: ‘result’
[17:43:55.819]   - Field: ‘asynchronous’
[17:43:55.819]   - Field: ‘calls’
[17:43:55.819]   - Field: ‘globals’
[17:43:55.819]   - Field: ‘stdout’
[17:43:55.819]   - Field: ‘earlySignal’
[17:43:55.819]   - Field: ‘lazy’
[17:43:55.819]   - Field: ‘state’
[17:43:55.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:55.819] - Launch lazy future ...
[17:43:55.819] Packages needed by the future expression (n = 1): ‘stats’
[17:43:55.820] Packages needed by future strategies (n = 0): <none>
[17:43:55.820] {
[17:43:55.820]     {
[17:43:55.820]         {
[17:43:55.820]             ...future.startTime <- base::Sys.time()
[17:43:55.820]             {
[17:43:55.820]                 {
[17:43:55.820]                   {
[17:43:55.820]                     {
[17:43:55.820]                       base::local({
[17:43:55.820]                         has_future <- base::requireNamespace("future", 
[17:43:55.820]                           quietly = TRUE)
[17:43:55.820]                         if (has_future) {
[17:43:55.820]                           ns <- base::getNamespace("future")
[17:43:55.820]                           version <- ns[[".package"]][["version"]]
[17:43:55.820]                           if (is.null(version)) 
[17:43:55.820]                             version <- utils::packageVersion("future")
[17:43:55.820]                         }
[17:43:55.820]                         else {
[17:43:55.820]                           version <- NULL
[17:43:55.820]                         }
[17:43:55.820]                         if (!has_future || version < "1.8.0") {
[17:43:55.820]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.820]                             "", base::R.version$version.string), 
[17:43:55.820]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.820]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.820]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.820]                               "release", "version")], collapse = " "), 
[17:43:55.820]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.820]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.820]                             info)
[17:43:55.820]                           info <- base::paste(info, collapse = "; ")
[17:43:55.820]                           if (!has_future) {
[17:43:55.820]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.820]                               info)
[17:43:55.820]                           }
[17:43:55.820]                           else {
[17:43:55.820]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.820]                               info, version)
[17:43:55.820]                           }
[17:43:55.820]                           base::stop(msg)
[17:43:55.820]                         }
[17:43:55.820]                       })
[17:43:55.820]                     }
[17:43:55.820]                     base::local({
[17:43:55.820]                       for (pkg in "stats") {
[17:43:55.820]                         base::loadNamespace(pkg)
[17:43:55.820]                         base::library(pkg, character.only = TRUE)
[17:43:55.820]                       }
[17:43:55.820]                     })
[17:43:55.820]                   }
[17:43:55.820]                   ...future.strategy.old <- future::plan("list")
[17:43:55.820]                   options(future.plan = NULL)
[17:43:55.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.820]                 }
[17:43:55.820]                 ...future.workdir <- getwd()
[17:43:55.820]             }
[17:43:55.820]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.820]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.820]         }
[17:43:55.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.820]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.820]             base::names(...future.oldOptions))
[17:43:55.820]     }
[17:43:55.820]     if (FALSE) {
[17:43:55.820]     }
[17:43:55.820]     else {
[17:43:55.820]         if (TRUE) {
[17:43:55.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.820]                 open = "w")
[17:43:55.820]         }
[17:43:55.820]         else {
[17:43:55.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.820]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.820]         }
[17:43:55.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.820]             base::sink(type = "output", split = FALSE)
[17:43:55.820]             base::close(...future.stdout)
[17:43:55.820]         }, add = TRUE)
[17:43:55.820]     }
[17:43:55.820]     ...future.frame <- base::sys.nframe()
[17:43:55.820]     ...future.conditions <- base::list()
[17:43:55.820]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.820]     if (FALSE) {
[17:43:55.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.820]     }
[17:43:55.820]     ...future.result <- base::tryCatch({
[17:43:55.820]         base::withCallingHandlers({
[17:43:55.820]             ...future.value <- base::withVisible(base::local({
[17:43:55.820]                 do.call(function(...) {
[17:43:55.820]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.820]                   if (!identical(...future.globals.maxSize.org, 
[17:43:55.820]                     ...future.globals.maxSize)) {
[17:43:55.820]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.820]                     on.exit(options(oopts), add = TRUE)
[17:43:55.820]                   }
[17:43:55.820]                   {
[17:43:55.820]                     lapply(seq_along(...future.elements_ii), 
[17:43:55.820]                       FUN = function(jj) {
[17:43:55.820]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.820]                         ...future.FUN(...future.X_jj, ...)
[17:43:55.820]                       })
[17:43:55.820]                   }
[17:43:55.820]                 }, args = future.call.arguments)
[17:43:55.820]             }))
[17:43:55.820]             future::FutureResult(value = ...future.value$value, 
[17:43:55.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.820]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.820]                     ...future.globalenv.names))
[17:43:55.820]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.820]         }, condition = base::local({
[17:43:55.820]             c <- base::c
[17:43:55.820]             inherits <- base::inherits
[17:43:55.820]             invokeRestart <- base::invokeRestart
[17:43:55.820]             length <- base::length
[17:43:55.820]             list <- base::list
[17:43:55.820]             seq.int <- base::seq.int
[17:43:55.820]             signalCondition <- base::signalCondition
[17:43:55.820]             sys.calls <- base::sys.calls
[17:43:55.820]             `[[` <- base::`[[`
[17:43:55.820]             `+` <- base::`+`
[17:43:55.820]             `<<-` <- base::`<<-`
[17:43:55.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.820]                   3L)]
[17:43:55.820]             }
[17:43:55.820]             function(cond) {
[17:43:55.820]                 is_error <- inherits(cond, "error")
[17:43:55.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.820]                   NULL)
[17:43:55.820]                 if (is_error) {
[17:43:55.820]                   sessionInformation <- function() {
[17:43:55.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.820]                       search = base::search(), system = base::Sys.info())
[17:43:55.820]                   }
[17:43:55.820]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.820]                     cond$call), session = sessionInformation(), 
[17:43:55.820]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.820]                   signalCondition(cond)
[17:43:55.820]                 }
[17:43:55.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.820]                 "immediateCondition"))) {
[17:43:55.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.820]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.820]                   if (TRUE && !signal) {
[17:43:55.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.820]                     {
[17:43:55.820]                       inherits <- base::inherits
[17:43:55.820]                       invokeRestart <- base::invokeRestart
[17:43:55.820]                       is.null <- base::is.null
[17:43:55.820]                       muffled <- FALSE
[17:43:55.820]                       if (inherits(cond, "message")) {
[17:43:55.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.820]                         if (muffled) 
[17:43:55.820]                           invokeRestart("muffleMessage")
[17:43:55.820]                       }
[17:43:55.820]                       else if (inherits(cond, "warning")) {
[17:43:55.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.820]                         if (muffled) 
[17:43:55.820]                           invokeRestart("muffleWarning")
[17:43:55.820]                       }
[17:43:55.820]                       else if (inherits(cond, "condition")) {
[17:43:55.820]                         if (!is.null(pattern)) {
[17:43:55.820]                           computeRestarts <- base::computeRestarts
[17:43:55.820]                           grepl <- base::grepl
[17:43:55.820]                           restarts <- computeRestarts(cond)
[17:43:55.820]                           for (restart in restarts) {
[17:43:55.820]                             name <- restart$name
[17:43:55.820]                             if (is.null(name)) 
[17:43:55.820]                               next
[17:43:55.820]                             if (!grepl(pattern, name)) 
[17:43:55.820]                               next
[17:43:55.820]                             invokeRestart(restart)
[17:43:55.820]                             muffled <- TRUE
[17:43:55.820]                             break
[17:43:55.820]                           }
[17:43:55.820]                         }
[17:43:55.820]                       }
[17:43:55.820]                       invisible(muffled)
[17:43:55.820]                     }
[17:43:55.820]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.820]                   }
[17:43:55.820]                 }
[17:43:55.820]                 else {
[17:43:55.820]                   if (TRUE) {
[17:43:55.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.820]                     {
[17:43:55.820]                       inherits <- base::inherits
[17:43:55.820]                       invokeRestart <- base::invokeRestart
[17:43:55.820]                       is.null <- base::is.null
[17:43:55.820]                       muffled <- FALSE
[17:43:55.820]                       if (inherits(cond, "message")) {
[17:43:55.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.820]                         if (muffled) 
[17:43:55.820]                           invokeRestart("muffleMessage")
[17:43:55.820]                       }
[17:43:55.820]                       else if (inherits(cond, "warning")) {
[17:43:55.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.820]                         if (muffled) 
[17:43:55.820]                           invokeRestart("muffleWarning")
[17:43:55.820]                       }
[17:43:55.820]                       else if (inherits(cond, "condition")) {
[17:43:55.820]                         if (!is.null(pattern)) {
[17:43:55.820]                           computeRestarts <- base::computeRestarts
[17:43:55.820]                           grepl <- base::grepl
[17:43:55.820]                           restarts <- computeRestarts(cond)
[17:43:55.820]                           for (restart in restarts) {
[17:43:55.820]                             name <- restart$name
[17:43:55.820]                             if (is.null(name)) 
[17:43:55.820]                               next
[17:43:55.820]                             if (!grepl(pattern, name)) 
[17:43:55.820]                               next
[17:43:55.820]                             invokeRestart(restart)
[17:43:55.820]                             muffled <- TRUE
[17:43:55.820]                             break
[17:43:55.820]                           }
[17:43:55.820]                         }
[17:43:55.820]                       }
[17:43:55.820]                       invisible(muffled)
[17:43:55.820]                     }
[17:43:55.820]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.820]                   }
[17:43:55.820]                 }
[17:43:55.820]             }
[17:43:55.820]         }))
[17:43:55.820]     }, error = function(ex) {
[17:43:55.820]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.820]                 ...future.rng), started = ...future.startTime, 
[17:43:55.820]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.820]             version = "1.8"), class = "FutureResult")
[17:43:55.820]     }, finally = {
[17:43:55.820]         if (!identical(...future.workdir, getwd())) 
[17:43:55.820]             setwd(...future.workdir)
[17:43:55.820]         {
[17:43:55.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.820]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.820]             }
[17:43:55.820]             base::options(...future.oldOptions)
[17:43:55.820]             if (.Platform$OS.type == "windows") {
[17:43:55.820]                 old_names <- names(...future.oldEnvVars)
[17:43:55.820]                 envs <- base::Sys.getenv()
[17:43:55.820]                 names <- names(envs)
[17:43:55.820]                 common <- intersect(names, old_names)
[17:43:55.820]                 added <- setdiff(names, old_names)
[17:43:55.820]                 removed <- setdiff(old_names, names)
[17:43:55.820]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.820]                   envs[common]]
[17:43:55.820]                 NAMES <- toupper(changed)
[17:43:55.820]                 args <- list()
[17:43:55.820]                 for (kk in seq_along(NAMES)) {
[17:43:55.820]                   name <- changed[[kk]]
[17:43:55.820]                   NAME <- NAMES[[kk]]
[17:43:55.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.820]                     next
[17:43:55.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.820]                 }
[17:43:55.820]                 NAMES <- toupper(added)
[17:43:55.820]                 for (kk in seq_along(NAMES)) {
[17:43:55.820]                   name <- added[[kk]]
[17:43:55.820]                   NAME <- NAMES[[kk]]
[17:43:55.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.820]                     next
[17:43:55.820]                   args[[name]] <- ""
[17:43:55.820]                 }
[17:43:55.820]                 NAMES <- toupper(removed)
[17:43:55.820]                 for (kk in seq_along(NAMES)) {
[17:43:55.820]                   name <- removed[[kk]]
[17:43:55.820]                   NAME <- NAMES[[kk]]
[17:43:55.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.820]                     next
[17:43:55.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.820]                 }
[17:43:55.820]                 if (length(args) > 0) 
[17:43:55.820]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.820]             }
[17:43:55.820]             else {
[17:43:55.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.820]             }
[17:43:55.820]             {
[17:43:55.820]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.820]                   0L) {
[17:43:55.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.820]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.820]                   base::options(opts)
[17:43:55.820]                 }
[17:43:55.820]                 {
[17:43:55.820]                   {
[17:43:55.820]                     NULL
[17:43:55.820]                     RNGkind("Mersenne-Twister")
[17:43:55.820]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:55.820]                       inherits = FALSE)
[17:43:55.820]                   }
[17:43:55.820]                   options(future.plan = NULL)
[17:43:55.820]                   if (is.na(NA_character_)) 
[17:43:55.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.820]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.820]                     .init = FALSE)
[17:43:55.820]                 }
[17:43:55.820]             }
[17:43:55.820]         }
[17:43:55.820]     })
[17:43:55.820]     if (TRUE) {
[17:43:55.820]         base::sink(type = "output", split = FALSE)
[17:43:55.820]         if (TRUE) {
[17:43:55.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.820]         }
[17:43:55.820]         else {
[17:43:55.820]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.820]         }
[17:43:55.820]         base::close(...future.stdout)
[17:43:55.820]         ...future.stdout <- NULL
[17:43:55.820]     }
[17:43:55.820]     ...future.result$conditions <- ...future.conditions
[17:43:55.820]     ...future.result$finished <- base::Sys.time()
[17:43:55.820]     ...future.result
[17:43:55.820] }
[17:43:55.822] assign_globals() ...
[17:43:55.822] List of 5
[17:43:55.822]  $ ...future.FUN            :function (x, ...)  
[17:43:55.822]  $ future.call.arguments    : list()
[17:43:55.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.822]  $ ...future.elements_ii    :List of 3
[17:43:55.822]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:43:55.822]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:55.822]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:55.822]  $ ...future.seeds_ii       : NULL
[17:43:55.822]  $ ...future.globals.maxSize: NULL
[17:43:55.822]  - attr(*, "where")=List of 5
[17:43:55.822]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:55.822]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:55.822]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:55.822]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:55.822]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:55.822]  - attr(*, "resolved")= logi FALSE
[17:43:55.822]  - attr(*, "total_size")= num 1248
[17:43:55.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.822]  - attr(*, "already-done")= logi TRUE
[17:43:55.827] - copied ‘...future.FUN’ to environment
[17:43:55.827] - copied ‘future.call.arguments’ to environment
[17:43:55.827] - copied ‘...future.elements_ii’ to environment
[17:43:55.827] - copied ‘...future.seeds_ii’ to environment
[17:43:55.827] - copied ‘...future.globals.maxSize’ to environment
[17:43:55.827] assign_globals() ... done
[17:43:55.827] plan(): Setting new future strategy stack:
[17:43:55.828] List of future strategies:
[17:43:55.828] 1. sequential:
[17:43:55.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.828]    - tweaked: FALSE
[17:43:55.828]    - call: NULL
[17:43:55.828] plan(): nbrOfWorkers() = 1
[17:43:55.829] plan(): Setting new future strategy stack:
[17:43:55.829] List of future strategies:
[17:43:55.829] 1. sequential:
[17:43:55.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.829]    - tweaked: FALSE
[17:43:55.829]    - call: plan(strategy)
[17:43:55.830] plan(): nbrOfWorkers() = 1
[17:43:55.831] SequentialFuture started (and completed)
[17:43:55.831] - Launch lazy future ... done
[17:43:55.831] run() for ‘SequentialFuture’ ... done
[17:43:55.831] Created future:
[17:43:55.831] SequentialFuture:
[17:43:55.831] Label: ‘future_eapply-1’
[17:43:55.831] Expression:
[17:43:55.831] {
[17:43:55.831]     do.call(function(...) {
[17:43:55.831]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.831]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.831]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.831]             on.exit(options(oopts), add = TRUE)
[17:43:55.831]         }
[17:43:55.831]         {
[17:43:55.831]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.831]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.831]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.831]             })
[17:43:55.831]         }
[17:43:55.831]     }, args = future.call.arguments)
[17:43:55.831] }
[17:43:55.831] Lazy evaluation: FALSE
[17:43:55.831] Asynchronous evaluation: FALSE
[17:43:55.831] Local evaluation: TRUE
[17:43:55.831] Environment: R_GlobalEnv
[17:43:55.831] Capture standard output: TRUE
[17:43:55.831] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.831] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.831] Packages: 1 packages (‘stats’)
[17:43:55.831] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.831] Resolved: TRUE
[17:43:55.831] Value: 1.71 KiB of class ‘list’
[17:43:55.831] Early signaling: FALSE
[17:43:55.831] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:55.831] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.832] Chunk #1 of 1 ... DONE
[17:43:55.832] Launching 1 futures (chunks) ... DONE
[17:43:55.832] Resolving 1 futures (chunks) ...
[17:43:55.833] resolve() on list ...
[17:43:55.833]  recursive: 0
[17:43:55.833]  length: 1
[17:43:55.833] 
[17:43:55.833] resolved() for ‘SequentialFuture’ ...
[17:43:55.833] - state: ‘finished’
[17:43:55.833] - run: TRUE
[17:43:55.833] - result: ‘FutureResult’
[17:43:55.833] resolved() for ‘SequentialFuture’ ... done
[17:43:55.833] Future #1
[17:43:55.833] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:55.834] - nx: 1
[17:43:55.834] - relay: TRUE
[17:43:55.834] - stdout: TRUE
[17:43:55.834] - signal: TRUE
[17:43:55.834] - resignal: FALSE
[17:43:55.834] - force: TRUE
[17:43:55.834] - relayed: [n=1] FALSE
[17:43:55.834] - queued futures: [n=1] FALSE
[17:43:55.834]  - until=1
[17:43:55.834]  - relaying element #1
[17:43:55.834] - relayed: [n=1] TRUE
[17:43:55.835] - queued futures: [n=1] TRUE
[17:43:55.835] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:55.835]  length: 0 (resolved future 1)
[17:43:55.835] Relaying remaining futures
[17:43:55.835] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.835] - nx: 1
[17:43:55.835] - relay: TRUE
[17:43:55.835] - stdout: TRUE
[17:43:55.835] - signal: TRUE
[17:43:55.835] - resignal: FALSE
[17:43:55.835] - force: TRUE
[17:43:55.835] - relayed: [n=1] TRUE
[17:43:55.836] - queued futures: [n=1] TRUE
 - flush all
[17:43:55.836] - relayed: [n=1] TRUE
[17:43:55.836] - queued futures: [n=1] TRUE
[17:43:55.836] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.836] resolve() on list ... DONE
[17:43:55.836]  - Number of value chunks collected: 1
[17:43:55.836] Resolving 1 futures (chunks) ... DONE
[17:43:55.836] Reducing values from 1 chunks ...
[17:43:55.836]  - Number of values collected after concatenation: 3
[17:43:55.836]  - Number of values expected: 3
[17:43:55.837] Reducing values from 1 chunks ... DONE
[17:43:55.837] future_lapply() ... DONE
[17:43:55.837] future_lapply() ...
[17:43:55.837] Number of chunks: 1
[17:43:55.837] getGlobalsAndPackagesXApply() ...
[17:43:55.837]  - future.globals: TRUE
[17:43:55.838] getGlobalsAndPackages() ...
[17:43:55.838] Searching for globals...
[17:43:55.839] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.839] Searching for globals ... DONE
[17:43:55.839] Resolving globals: FALSE
[17:43:55.839] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:55.839] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:55.840] - globals: [1] ‘FUN’
[17:43:55.840] - packages: [1] ‘stats’
[17:43:55.840] getGlobalsAndPackages() ... DONE
[17:43:55.840]  - globals found/used: [n=1] ‘FUN’
[17:43:55.840]  - needed namespaces: [n=1] ‘stats’
[17:43:55.840] Finding globals ... DONE
[17:43:55.840]  - use_args: TRUE
[17:43:55.840]  - Getting '...' globals ...
[17:43:55.840] resolve() on list ...
[17:43:55.841]  recursive: 0
[17:43:55.841]  length: 1
[17:43:55.841]  elements: ‘...’
[17:43:55.841]  length: 0 (resolved future 1)
[17:43:55.841] resolve() on list ... DONE
[17:43:55.841]    - '...' content: [n=0] 
[17:43:55.841] List of 1
[17:43:55.841]  $ ...: list()
[17:43:55.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.841]  - attr(*, "where")=List of 1
[17:43:55.841]   ..$ ...:<environment: 0x55813d33da58> 
[17:43:55.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.841]  - attr(*, "resolved")= logi TRUE
[17:43:55.841]  - attr(*, "total_size")= num NA
[17:43:55.843]  - Getting '...' globals ... DONE
[17:43:55.844] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.844] List of 2
[17:43:55.844]  $ ...future.FUN:function (x, ...)  
[17:43:55.844]  $ ...          : list()
[17:43:55.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.844]  - attr(*, "where")=List of 2
[17:43:55.844]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.844]   ..$ ...          :<environment: 0x55813d33da58> 
[17:43:55.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.844]  - attr(*, "resolved")= logi FALSE
[17:43:55.844]  - attr(*, "total_size")= num 1248
[17:43:55.846] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:55.846] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.846] Number of futures (= number of chunks): 1
[17:43:55.846] Launching 1 futures (chunks) ...
[17:43:55.846] Chunk #1 of 1 ...
[17:43:55.847]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.847] getGlobalsAndPackages() ...
[17:43:55.847] Searching for globals...
[17:43:55.847] 
[17:43:55.847] Searching for globals ... DONE
[17:43:55.847] - globals: [0] <none>
[17:43:55.847] getGlobalsAndPackages() ... DONE
[17:43:55.847]    + additional globals found: [n=0] 
[17:43:55.847]    + additional namespaces needed: [n=0] 
[17:43:55.848]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.848]  - seeds: <none>
[17:43:55.848]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.848] getGlobalsAndPackages() ...
[17:43:55.848] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.848] Resolving globals: FALSE
[17:43:55.848] Tweak future expression to call with '...' arguments ...
[17:43:55.848] {
[17:43:55.848]     do.call(function(...) {
[17:43:55.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.848]             on.exit(options(oopts), add = TRUE)
[17:43:55.848]         }
[17:43:55.848]         {
[17:43:55.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.848]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.848]             })
[17:43:55.848]         }
[17:43:55.848]     }, args = future.call.arguments)
[17:43:55.848] }
[17:43:55.848] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.849] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.849] - packages: [1] ‘stats’
[17:43:55.849] getGlobalsAndPackages() ... DONE
[17:43:55.849] run() for ‘Future’ ...
[17:43:55.849] - state: ‘created’
[17:43:55.849] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:55.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:55.850]   - Field: ‘label’
[17:43:55.850]   - Field: ‘local’
[17:43:55.850]   - Field: ‘owner’
[17:43:55.850]   - Field: ‘envir’
[17:43:55.850]   - Field: ‘packages’
[17:43:55.850]   - Field: ‘gc’
[17:43:55.850]   - Field: ‘conditions’
[17:43:55.851]   - Field: ‘expr’
[17:43:55.851]   - Field: ‘uuid’
[17:43:55.851]   - Field: ‘seed’
[17:43:55.851]   - Field: ‘version’
[17:43:55.851]   - Field: ‘result’
[17:43:55.851]   - Field: ‘asynchronous’
[17:43:55.851]   - Field: ‘calls’
[17:43:55.851]   - Field: ‘globals’
[17:43:55.851]   - Field: ‘stdout’
[17:43:55.851]   - Field: ‘earlySignal’
[17:43:55.851]   - Field: ‘lazy’
[17:43:55.851]   - Field: ‘state’
[17:43:55.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:55.852] - Launch lazy future ...
[17:43:55.852] Packages needed by the future expression (n = 1): ‘stats’
[17:43:55.852] Packages needed by future strategies (n = 0): <none>
[17:43:55.852] {
[17:43:55.852]     {
[17:43:55.852]         {
[17:43:55.852]             ...future.startTime <- base::Sys.time()
[17:43:55.852]             {
[17:43:55.852]                 {
[17:43:55.852]                   {
[17:43:55.852]                     {
[17:43:55.852]                       base::local({
[17:43:55.852]                         has_future <- base::requireNamespace("future", 
[17:43:55.852]                           quietly = TRUE)
[17:43:55.852]                         if (has_future) {
[17:43:55.852]                           ns <- base::getNamespace("future")
[17:43:55.852]                           version <- ns[[".package"]][["version"]]
[17:43:55.852]                           if (is.null(version)) 
[17:43:55.852]                             version <- utils::packageVersion("future")
[17:43:55.852]                         }
[17:43:55.852]                         else {
[17:43:55.852]                           version <- NULL
[17:43:55.852]                         }
[17:43:55.852]                         if (!has_future || version < "1.8.0") {
[17:43:55.852]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.852]                             "", base::R.version$version.string), 
[17:43:55.852]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.852]                               "release", "version")], collapse = " "), 
[17:43:55.852]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.852]                             info)
[17:43:55.852]                           info <- base::paste(info, collapse = "; ")
[17:43:55.852]                           if (!has_future) {
[17:43:55.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.852]                               info)
[17:43:55.852]                           }
[17:43:55.852]                           else {
[17:43:55.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.852]                               info, version)
[17:43:55.852]                           }
[17:43:55.852]                           base::stop(msg)
[17:43:55.852]                         }
[17:43:55.852]                       })
[17:43:55.852]                     }
[17:43:55.852]                     base::local({
[17:43:55.852]                       for (pkg in "stats") {
[17:43:55.852]                         base::loadNamespace(pkg)
[17:43:55.852]                         base::library(pkg, character.only = TRUE)
[17:43:55.852]                       }
[17:43:55.852]                     })
[17:43:55.852]                   }
[17:43:55.852]                   ...future.strategy.old <- future::plan("list")
[17:43:55.852]                   options(future.plan = NULL)
[17:43:55.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.852]                 }
[17:43:55.852]                 ...future.workdir <- getwd()
[17:43:55.852]             }
[17:43:55.852]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.852]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.852]         }
[17:43:55.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.852]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.852]             base::names(...future.oldOptions))
[17:43:55.852]     }
[17:43:55.852]     if (FALSE) {
[17:43:55.852]     }
[17:43:55.852]     else {
[17:43:55.852]         if (TRUE) {
[17:43:55.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.852]                 open = "w")
[17:43:55.852]         }
[17:43:55.852]         else {
[17:43:55.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.852]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.852]         }
[17:43:55.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.852]             base::sink(type = "output", split = FALSE)
[17:43:55.852]             base::close(...future.stdout)
[17:43:55.852]         }, add = TRUE)
[17:43:55.852]     }
[17:43:55.852]     ...future.frame <- base::sys.nframe()
[17:43:55.852]     ...future.conditions <- base::list()
[17:43:55.852]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.852]     if (FALSE) {
[17:43:55.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.852]     }
[17:43:55.852]     ...future.result <- base::tryCatch({
[17:43:55.852]         base::withCallingHandlers({
[17:43:55.852]             ...future.value <- base::withVisible(base::local({
[17:43:55.852]                 do.call(function(...) {
[17:43:55.852]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.852]                   if (!identical(...future.globals.maxSize.org, 
[17:43:55.852]                     ...future.globals.maxSize)) {
[17:43:55.852]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.852]                     on.exit(options(oopts), add = TRUE)
[17:43:55.852]                   }
[17:43:55.852]                   {
[17:43:55.852]                     lapply(seq_along(...future.elements_ii), 
[17:43:55.852]                       FUN = function(jj) {
[17:43:55.852]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.852]                         ...future.FUN(...future.X_jj, ...)
[17:43:55.852]                       })
[17:43:55.852]                   }
[17:43:55.852]                 }, args = future.call.arguments)
[17:43:55.852]             }))
[17:43:55.852]             future::FutureResult(value = ...future.value$value, 
[17:43:55.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.852]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.852]                     ...future.globalenv.names))
[17:43:55.852]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.852]         }, condition = base::local({
[17:43:55.852]             c <- base::c
[17:43:55.852]             inherits <- base::inherits
[17:43:55.852]             invokeRestart <- base::invokeRestart
[17:43:55.852]             length <- base::length
[17:43:55.852]             list <- base::list
[17:43:55.852]             seq.int <- base::seq.int
[17:43:55.852]             signalCondition <- base::signalCondition
[17:43:55.852]             sys.calls <- base::sys.calls
[17:43:55.852]             `[[` <- base::`[[`
[17:43:55.852]             `+` <- base::`+`
[17:43:55.852]             `<<-` <- base::`<<-`
[17:43:55.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.852]                   3L)]
[17:43:55.852]             }
[17:43:55.852]             function(cond) {
[17:43:55.852]                 is_error <- inherits(cond, "error")
[17:43:55.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.852]                   NULL)
[17:43:55.852]                 if (is_error) {
[17:43:55.852]                   sessionInformation <- function() {
[17:43:55.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.852]                       search = base::search(), system = base::Sys.info())
[17:43:55.852]                   }
[17:43:55.852]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.852]                     cond$call), session = sessionInformation(), 
[17:43:55.852]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.852]                   signalCondition(cond)
[17:43:55.852]                 }
[17:43:55.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.852]                 "immediateCondition"))) {
[17:43:55.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.852]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.852]                   if (TRUE && !signal) {
[17:43:55.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.852]                     {
[17:43:55.852]                       inherits <- base::inherits
[17:43:55.852]                       invokeRestart <- base::invokeRestart
[17:43:55.852]                       is.null <- base::is.null
[17:43:55.852]                       muffled <- FALSE
[17:43:55.852]                       if (inherits(cond, "message")) {
[17:43:55.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.852]                         if (muffled) 
[17:43:55.852]                           invokeRestart("muffleMessage")
[17:43:55.852]                       }
[17:43:55.852]                       else if (inherits(cond, "warning")) {
[17:43:55.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.852]                         if (muffled) 
[17:43:55.852]                           invokeRestart("muffleWarning")
[17:43:55.852]                       }
[17:43:55.852]                       else if (inherits(cond, "condition")) {
[17:43:55.852]                         if (!is.null(pattern)) {
[17:43:55.852]                           computeRestarts <- base::computeRestarts
[17:43:55.852]                           grepl <- base::grepl
[17:43:55.852]                           restarts <- computeRestarts(cond)
[17:43:55.852]                           for (restart in restarts) {
[17:43:55.852]                             name <- restart$name
[17:43:55.852]                             if (is.null(name)) 
[17:43:55.852]                               next
[17:43:55.852]                             if (!grepl(pattern, name)) 
[17:43:55.852]                               next
[17:43:55.852]                             invokeRestart(restart)
[17:43:55.852]                             muffled <- TRUE
[17:43:55.852]                             break
[17:43:55.852]                           }
[17:43:55.852]                         }
[17:43:55.852]                       }
[17:43:55.852]                       invisible(muffled)
[17:43:55.852]                     }
[17:43:55.852]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.852]                   }
[17:43:55.852]                 }
[17:43:55.852]                 else {
[17:43:55.852]                   if (TRUE) {
[17:43:55.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.852]                     {
[17:43:55.852]                       inherits <- base::inherits
[17:43:55.852]                       invokeRestart <- base::invokeRestart
[17:43:55.852]                       is.null <- base::is.null
[17:43:55.852]                       muffled <- FALSE
[17:43:55.852]                       if (inherits(cond, "message")) {
[17:43:55.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.852]                         if (muffled) 
[17:43:55.852]                           invokeRestart("muffleMessage")
[17:43:55.852]                       }
[17:43:55.852]                       else if (inherits(cond, "warning")) {
[17:43:55.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.852]                         if (muffled) 
[17:43:55.852]                           invokeRestart("muffleWarning")
[17:43:55.852]                       }
[17:43:55.852]                       else if (inherits(cond, "condition")) {
[17:43:55.852]                         if (!is.null(pattern)) {
[17:43:55.852]                           computeRestarts <- base::computeRestarts
[17:43:55.852]                           grepl <- base::grepl
[17:43:55.852]                           restarts <- computeRestarts(cond)
[17:43:55.852]                           for (restart in restarts) {
[17:43:55.852]                             name <- restart$name
[17:43:55.852]                             if (is.null(name)) 
[17:43:55.852]                               next
[17:43:55.852]                             if (!grepl(pattern, name)) 
[17:43:55.852]                               next
[17:43:55.852]                             invokeRestart(restart)
[17:43:55.852]                             muffled <- TRUE
[17:43:55.852]                             break
[17:43:55.852]                           }
[17:43:55.852]                         }
[17:43:55.852]                       }
[17:43:55.852]                       invisible(muffled)
[17:43:55.852]                     }
[17:43:55.852]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.852]                   }
[17:43:55.852]                 }
[17:43:55.852]             }
[17:43:55.852]         }))
[17:43:55.852]     }, error = function(ex) {
[17:43:55.852]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.852]                 ...future.rng), started = ...future.startTime, 
[17:43:55.852]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.852]             version = "1.8"), class = "FutureResult")
[17:43:55.852]     }, finally = {
[17:43:55.852]         if (!identical(...future.workdir, getwd())) 
[17:43:55.852]             setwd(...future.workdir)
[17:43:55.852]         {
[17:43:55.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.852]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.852]             }
[17:43:55.852]             base::options(...future.oldOptions)
[17:43:55.852]             if (.Platform$OS.type == "windows") {
[17:43:55.852]                 old_names <- names(...future.oldEnvVars)
[17:43:55.852]                 envs <- base::Sys.getenv()
[17:43:55.852]                 names <- names(envs)
[17:43:55.852]                 common <- intersect(names, old_names)
[17:43:55.852]                 added <- setdiff(names, old_names)
[17:43:55.852]                 removed <- setdiff(old_names, names)
[17:43:55.852]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.852]                   envs[common]]
[17:43:55.852]                 NAMES <- toupper(changed)
[17:43:55.852]                 args <- list()
[17:43:55.852]                 for (kk in seq_along(NAMES)) {
[17:43:55.852]                   name <- changed[[kk]]
[17:43:55.852]                   NAME <- NAMES[[kk]]
[17:43:55.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.852]                     next
[17:43:55.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.852]                 }
[17:43:55.852]                 NAMES <- toupper(added)
[17:43:55.852]                 for (kk in seq_along(NAMES)) {
[17:43:55.852]                   name <- added[[kk]]
[17:43:55.852]                   NAME <- NAMES[[kk]]
[17:43:55.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.852]                     next
[17:43:55.852]                   args[[name]] <- ""
[17:43:55.852]                 }
[17:43:55.852]                 NAMES <- toupper(removed)
[17:43:55.852]                 for (kk in seq_along(NAMES)) {
[17:43:55.852]                   name <- removed[[kk]]
[17:43:55.852]                   NAME <- NAMES[[kk]]
[17:43:55.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.852]                     next
[17:43:55.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.852]                 }
[17:43:55.852]                 if (length(args) > 0) 
[17:43:55.852]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.852]             }
[17:43:55.852]             else {
[17:43:55.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.852]             }
[17:43:55.852]             {
[17:43:55.852]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.852]                   0L) {
[17:43:55.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.852]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.852]                   base::options(opts)
[17:43:55.852]                 }
[17:43:55.852]                 {
[17:43:55.852]                   {
[17:43:55.852]                     NULL
[17:43:55.852]                     RNGkind("Mersenne-Twister")
[17:43:55.852]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:55.852]                       inherits = FALSE)
[17:43:55.852]                   }
[17:43:55.852]                   options(future.plan = NULL)
[17:43:55.852]                   if (is.na(NA_character_)) 
[17:43:55.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.852]                     .init = FALSE)
[17:43:55.852]                 }
[17:43:55.852]             }
[17:43:55.852]         }
[17:43:55.852]     })
[17:43:55.852]     if (TRUE) {
[17:43:55.852]         base::sink(type = "output", split = FALSE)
[17:43:55.852]         if (TRUE) {
[17:43:55.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.852]         }
[17:43:55.852]         else {
[17:43:55.852]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.852]         }
[17:43:55.852]         base::close(...future.stdout)
[17:43:55.852]         ...future.stdout <- NULL
[17:43:55.852]     }
[17:43:55.852]     ...future.result$conditions <- ...future.conditions
[17:43:55.852]     ...future.result$finished <- base::Sys.time()
[17:43:55.852]     ...future.result
[17:43:55.852] }
[17:43:55.855] assign_globals() ...
[17:43:55.855] List of 5
[17:43:55.855]  $ ...future.FUN            :function (x, ...)  
[17:43:55.855]  $ future.call.arguments    : list()
[17:43:55.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.855]  $ ...future.elements_ii    :List of 3
[17:43:55.855]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:43:55.855]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:55.855]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:55.855]  $ ...future.seeds_ii       : NULL
[17:43:55.855]  $ ...future.globals.maxSize: NULL
[17:43:55.855]  - attr(*, "where")=List of 5
[17:43:55.855]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:55.855]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:55.855]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:55.855]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:55.855]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:55.855]  - attr(*, "resolved")= logi FALSE
[17:43:55.855]  - attr(*, "total_size")= num 1248
[17:43:55.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.855]  - attr(*, "already-done")= logi TRUE
[17:43:55.860] - copied ‘...future.FUN’ to environment
[17:43:55.860] - copied ‘future.call.arguments’ to environment
[17:43:55.860] - copied ‘...future.elements_ii’ to environment
[17:43:55.861] - copied ‘...future.seeds_ii’ to environment
[17:43:55.861] - copied ‘...future.globals.maxSize’ to environment
[17:43:55.861] assign_globals() ... done
[17:43:55.861] plan(): Setting new future strategy stack:
[17:43:55.861] List of future strategies:
[17:43:55.861] 1. sequential:
[17:43:55.861]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.861]    - tweaked: FALSE
[17:43:55.861]    - call: NULL
[17:43:55.862] plan(): nbrOfWorkers() = 1
[17:43:55.863] plan(): Setting new future strategy stack:
[17:43:55.863] List of future strategies:
[17:43:55.863] 1. sequential:
[17:43:55.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.863]    - tweaked: FALSE
[17:43:55.863]    - call: plan(strategy)
[17:43:55.863] plan(): nbrOfWorkers() = 1
[17:43:55.863] SequentialFuture started (and completed)
[17:43:55.864] - Launch lazy future ... done
[17:43:55.864] run() for ‘SequentialFuture’ ... done
[17:43:55.864] Created future:
[17:43:55.864] SequentialFuture:
[17:43:55.864] Label: ‘future_eapply-1’
[17:43:55.864] Expression:
[17:43:55.864] {
[17:43:55.864]     do.call(function(...) {
[17:43:55.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.864]             on.exit(options(oopts), add = TRUE)
[17:43:55.864]         }
[17:43:55.864]         {
[17:43:55.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.864]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.864]             })
[17:43:55.864]         }
[17:43:55.864]     }, args = future.call.arguments)
[17:43:55.864] }
[17:43:55.864] Lazy evaluation: FALSE
[17:43:55.864] Asynchronous evaluation: FALSE
[17:43:55.864] Local evaluation: TRUE
[17:43:55.864] Environment: R_GlobalEnv
[17:43:55.864] Capture standard output: TRUE
[17:43:55.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.864] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.864] Packages: 1 packages (‘stats’)
[17:43:55.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.864] Resolved: TRUE
[17:43:55.864] Value: 1.71 KiB of class ‘list’
[17:43:55.864] Early signaling: FALSE
[17:43:55.864] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:55.864] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:55.865] Chunk #1 of 1 ... DONE
[17:43:55.865] Launching 1 futures (chunks) ... DONE
[17:43:55.865] Resolving 1 futures (chunks) ...
[17:43:55.865] resolve() on list ...
[17:43:55.865]  recursive: 0
[17:43:55.865]  length: 1
[17:43:55.865] 
[17:43:55.865] resolved() for ‘SequentialFuture’ ...
[17:43:55.865] - state: ‘finished’
[17:43:55.866] - run: TRUE
[17:43:55.866] - result: ‘FutureResult’
[17:43:55.866] resolved() for ‘SequentialFuture’ ... done
[17:43:55.866] Future #1
[17:43:55.866] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:55.866] - nx: 1
[17:43:55.866] - relay: TRUE
[17:43:55.866] - stdout: TRUE
[17:43:55.866] - signal: TRUE
[17:43:55.866] - resignal: FALSE
[17:43:55.866] - force: TRUE
[17:43:55.866] - relayed: [n=1] FALSE
[17:43:55.867] - queued futures: [n=1] FALSE
[17:43:55.867]  - until=1
[17:43:55.867]  - relaying element #1
[17:43:55.867] - relayed: [n=1] TRUE
[17:43:55.867] - queued futures: [n=1] TRUE
[17:43:55.867] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:55.867]  length: 0 (resolved future 1)
[17:43:55.867] Relaying remaining futures
[17:43:55.867] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.867] - nx: 1
[17:43:55.868] - relay: TRUE
[17:43:55.868] - stdout: TRUE
[17:43:55.868] - signal: TRUE
[17:43:55.868] - resignal: FALSE
[17:43:55.868] - force: TRUE
[17:43:55.868] - relayed: [n=1] TRUE
[17:43:55.868] - queued futures: [n=1] TRUE
 - flush all
[17:43:55.868] - relayed: [n=1] TRUE
[17:43:55.868] - queued futures: [n=1] TRUE
[17:43:55.868] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.868] resolve() on list ... DONE
[17:43:55.869]  - Number of value chunks collected: 1
[17:43:55.869] Resolving 1 futures (chunks) ... DONE
[17:43:55.869] Reducing values from 1 chunks ...
[17:43:55.869]  - Number of values collected after concatenation: 3
[17:43:55.869]  - Number of values expected: 3
[17:43:55.869] Reducing values from 1 chunks ... DONE
[17:43:55.869] future_lapply() ... DONE
[17:43:55.869] plan(): Setting new future strategy stack:
[17:43:55.869] List of future strategies:
[17:43:55.869] 1. sequential:
[17:43:55.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.869]    - tweaked: FALSE
[17:43:55.869]    - call: plan(sequential)
[17:43:55.870] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:43:55.870] plan(): Setting new future strategy stack:
[17:43:55.870] List of future strategies:
[17:43:55.870] 1. multicore:
[17:43:55.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:55.870]    - tweaked: FALSE
[17:43:55.870]    - call: plan(strategy)
[17:43:55.874] plan(): nbrOfWorkers() = 2
[17:43:55.874] future_lapply() ...
[17:43:55.878] Number of chunks: 2
[17:43:55.878] getGlobalsAndPackagesXApply() ...
[17:43:55.878]  - future.globals: TRUE
[17:43:55.878] getGlobalsAndPackages() ...
[17:43:55.878] Searching for globals...
[17:43:55.879] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.880] Searching for globals ... DONE
[17:43:55.880] Resolving globals: FALSE
[17:43:55.880] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:55.880] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:55.880] - globals: [1] ‘FUN’
[17:43:55.881] 
[17:43:55.881] getGlobalsAndPackages() ... DONE
[17:43:55.881]  - globals found/used: [n=1] ‘FUN’
[17:43:55.881]  - needed namespaces: [n=0] 
[17:43:55.881] Finding globals ... DONE
[17:43:55.881]  - use_args: TRUE
[17:43:55.881]  - Getting '...' globals ...
[17:43:55.881] resolve() on list ...
[17:43:55.881]  recursive: 0
[17:43:55.882]  length: 1
[17:43:55.882]  elements: ‘...’
[17:43:55.882]  length: 0 (resolved future 1)
[17:43:55.882] resolve() on list ... DONE
[17:43:55.882]    - '...' content: [n=0] 
[17:43:55.883] List of 1
[17:43:55.883]  $ ...: list()
[17:43:55.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.883]  - attr(*, "where")=List of 1
[17:43:55.883]   ..$ ...:<environment: 0x55813e37deb8> 
[17:43:55.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.883]  - attr(*, "resolved")= logi TRUE
[17:43:55.883]  - attr(*, "total_size")= num NA
[17:43:55.886]  - Getting '...' globals ... DONE
[17:43:55.886] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.886] List of 2
[17:43:55.886]  $ ...future.FUN:function (x, ...)  
[17:43:55.886]  $ ...          : list()
[17:43:55.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.886]  - attr(*, "where")=List of 2
[17:43:55.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.886]   ..$ ...          :<environment: 0x55813e37deb8> 
[17:43:55.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.886]  - attr(*, "resolved")= logi FALSE
[17:43:55.886]  - attr(*, "total_size")= num 1240
[17:43:55.889] Packages to be attached in all futures: [n=0] 
[17:43:55.889] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.889] Number of futures (= number of chunks): 2
[17:43:55.889] Launching 2 futures (chunks) ...
[17:43:55.889] Chunk #1 of 2 ...
[17:43:55.889]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.889] getGlobalsAndPackages() ...
[17:43:55.889] Searching for globals...
[17:43:55.890] 
[17:43:55.890] Searching for globals ... DONE
[17:43:55.890] - globals: [0] <none>
[17:43:55.890] getGlobalsAndPackages() ... DONE
[17:43:55.890]    + additional globals found: [n=0] 
[17:43:55.890]    + additional namespaces needed: [n=0] 
[17:43:55.890]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.890]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.890]  - seeds: <none>
[17:43:55.890]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.890] getGlobalsAndPackages() ...
[17:43:55.891] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.891] Resolving globals: FALSE
[17:43:55.891] Tweak future expression to call with '...' arguments ...
[17:43:55.891] {
[17:43:55.891]     do.call(function(...) {
[17:43:55.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.891]             on.exit(options(oopts), add = TRUE)
[17:43:55.891]         }
[17:43:55.891]         {
[17:43:55.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.891]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.891]             })
[17:43:55.891]         }
[17:43:55.891]     }, args = future.call.arguments)
[17:43:55.891] }
[17:43:55.891] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.891] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.892] 
[17:43:55.892] getGlobalsAndPackages() ... DONE
[17:43:55.892] run() for ‘Future’ ...
[17:43:55.892] - state: ‘created’
[17:43:55.892] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.895] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:55.896]   - Field: ‘label’
[17:43:55.896]   - Field: ‘local’
[17:43:55.896]   - Field: ‘owner’
[17:43:55.896]   - Field: ‘envir’
[17:43:55.896]   - Field: ‘workers’
[17:43:55.896]   - Field: ‘packages’
[17:43:55.896]   - Field: ‘gc’
[17:43:55.896]   - Field: ‘job’
[17:43:55.896]   - Field: ‘conditions’
[17:43:55.897]   - Field: ‘expr’
[17:43:55.897]   - Field: ‘uuid’
[17:43:55.897]   - Field: ‘seed’
[17:43:55.897]   - Field: ‘version’
[17:43:55.897]   - Field: ‘result’
[17:43:55.897]   - Field: ‘asynchronous’
[17:43:55.897]   - Field: ‘calls’
[17:43:55.897]   - Field: ‘globals’
[17:43:55.897]   - Field: ‘stdout’
[17:43:55.897]   - Field: ‘earlySignal’
[17:43:55.897]   - Field: ‘lazy’
[17:43:55.897]   - Field: ‘state’
[17:43:55.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:55.898] - Launch lazy future ...
[17:43:55.899] Packages needed by the future expression (n = 0): <none>
[17:43:55.899] Packages needed by future strategies (n = 0): <none>
[17:43:55.899] {
[17:43:55.899]     {
[17:43:55.899]         {
[17:43:55.899]             ...future.startTime <- base::Sys.time()
[17:43:55.899]             {
[17:43:55.899]                 {
[17:43:55.899]                   {
[17:43:55.899]                     {
[17:43:55.899]                       base::local({
[17:43:55.899]                         has_future <- base::requireNamespace("future", 
[17:43:55.899]                           quietly = TRUE)
[17:43:55.899]                         if (has_future) {
[17:43:55.899]                           ns <- base::getNamespace("future")
[17:43:55.899]                           version <- ns[[".package"]][["version"]]
[17:43:55.899]                           if (is.null(version)) 
[17:43:55.899]                             version <- utils::packageVersion("future")
[17:43:55.899]                         }
[17:43:55.899]                         else {
[17:43:55.899]                           version <- NULL
[17:43:55.899]                         }
[17:43:55.899]                         if (!has_future || version < "1.8.0") {
[17:43:55.899]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.899]                             "", base::R.version$version.string), 
[17:43:55.899]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.899]                               "release", "version")], collapse = " "), 
[17:43:55.899]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.899]                             info)
[17:43:55.899]                           info <- base::paste(info, collapse = "; ")
[17:43:55.899]                           if (!has_future) {
[17:43:55.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.899]                               info)
[17:43:55.899]                           }
[17:43:55.899]                           else {
[17:43:55.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.899]                               info, version)
[17:43:55.899]                           }
[17:43:55.899]                           base::stop(msg)
[17:43:55.899]                         }
[17:43:55.899]                       })
[17:43:55.899]                     }
[17:43:55.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.899]                     base::options(mc.cores = 1L)
[17:43:55.899]                   }
[17:43:55.899]                   ...future.strategy.old <- future::plan("list")
[17:43:55.899]                   options(future.plan = NULL)
[17:43:55.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.899]                 }
[17:43:55.899]                 ...future.workdir <- getwd()
[17:43:55.899]             }
[17:43:55.899]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.899]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.899]         }
[17:43:55.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.899]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.899]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.899]             base::names(...future.oldOptions))
[17:43:55.899]     }
[17:43:55.899]     if (FALSE) {
[17:43:55.899]     }
[17:43:55.899]     else {
[17:43:55.899]         if (TRUE) {
[17:43:55.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.899]                 open = "w")
[17:43:55.899]         }
[17:43:55.899]         else {
[17:43:55.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.899]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.899]         }
[17:43:55.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.899]             base::sink(type = "output", split = FALSE)
[17:43:55.899]             base::close(...future.stdout)
[17:43:55.899]         }, add = TRUE)
[17:43:55.899]     }
[17:43:55.899]     ...future.frame <- base::sys.nframe()
[17:43:55.899]     ...future.conditions <- base::list()
[17:43:55.899]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.899]     if (FALSE) {
[17:43:55.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.899]     }
[17:43:55.899]     ...future.result <- base::tryCatch({
[17:43:55.899]         base::withCallingHandlers({
[17:43:55.899]             ...future.value <- base::withVisible(base::local({
[17:43:55.899]                 withCallingHandlers({
[17:43:55.899]                   {
[17:43:55.899]                     do.call(function(...) {
[17:43:55.899]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.899]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.899]                         ...future.globals.maxSize)) {
[17:43:55.899]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.899]                         on.exit(options(oopts), add = TRUE)
[17:43:55.899]                       }
[17:43:55.899]                       {
[17:43:55.899]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.899]                           FUN = function(jj) {
[17:43:55.899]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.899]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.899]                           })
[17:43:55.899]                       }
[17:43:55.899]                     }, args = future.call.arguments)
[17:43:55.899]                   }
[17:43:55.899]                 }, immediateCondition = function(cond) {
[17:43:55.899]                   save_rds <- function (object, pathname, ...) 
[17:43:55.899]                   {
[17:43:55.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:55.899]                     if (file_test("-f", pathname_tmp)) {
[17:43:55.899]                       fi_tmp <- file.info(pathname_tmp)
[17:43:55.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:55.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:55.899]                         fi_tmp[["mtime"]])
[17:43:55.899]                     }
[17:43:55.899]                     tryCatch({
[17:43:55.899]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:55.899]                     }, error = function(ex) {
[17:43:55.899]                       msg <- conditionMessage(ex)
[17:43:55.899]                       fi_tmp <- file.info(pathname_tmp)
[17:43:55.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:55.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:55.899]                         fi_tmp[["mtime"]], msg)
[17:43:55.899]                       ex$message <- msg
[17:43:55.899]                       stop(ex)
[17:43:55.899]                     })
[17:43:55.899]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:55.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:55.899]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:55.899]                       fi_tmp <- file.info(pathname_tmp)
[17:43:55.899]                       fi <- file.info(pathname)
[17:43:55.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:55.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:55.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:55.899]                         fi[["size"]], fi[["mtime"]])
[17:43:55.899]                       stop(msg)
[17:43:55.899]                     }
[17:43:55.899]                     invisible(pathname)
[17:43:55.899]                   }
[17:43:55.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:55.899]                     rootPath = tempdir()) 
[17:43:55.899]                   {
[17:43:55.899]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:55.899]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:55.899]                       tmpdir = path, fileext = ".rds")
[17:43:55.899]                     save_rds(obj, file)
[17:43:55.899]                   }
[17:43:55.899]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:55.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.899]                   {
[17:43:55.899]                     inherits <- base::inherits
[17:43:55.899]                     invokeRestart <- base::invokeRestart
[17:43:55.899]                     is.null <- base::is.null
[17:43:55.899]                     muffled <- FALSE
[17:43:55.899]                     if (inherits(cond, "message")) {
[17:43:55.899]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.899]                       if (muffled) 
[17:43:55.899]                         invokeRestart("muffleMessage")
[17:43:55.899]                     }
[17:43:55.899]                     else if (inherits(cond, "warning")) {
[17:43:55.899]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.899]                       if (muffled) 
[17:43:55.899]                         invokeRestart("muffleWarning")
[17:43:55.899]                     }
[17:43:55.899]                     else if (inherits(cond, "condition")) {
[17:43:55.899]                       if (!is.null(pattern)) {
[17:43:55.899]                         computeRestarts <- base::computeRestarts
[17:43:55.899]                         grepl <- base::grepl
[17:43:55.899]                         restarts <- computeRestarts(cond)
[17:43:55.899]                         for (restart in restarts) {
[17:43:55.899]                           name <- restart$name
[17:43:55.899]                           if (is.null(name)) 
[17:43:55.899]                             next
[17:43:55.899]                           if (!grepl(pattern, name)) 
[17:43:55.899]                             next
[17:43:55.899]                           invokeRestart(restart)
[17:43:55.899]                           muffled <- TRUE
[17:43:55.899]                           break
[17:43:55.899]                         }
[17:43:55.899]                       }
[17:43:55.899]                     }
[17:43:55.899]                     invisible(muffled)
[17:43:55.899]                   }
[17:43:55.899]                   muffleCondition(cond)
[17:43:55.899]                 })
[17:43:55.899]             }))
[17:43:55.899]             future::FutureResult(value = ...future.value$value, 
[17:43:55.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.899]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.899]                     ...future.globalenv.names))
[17:43:55.899]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.899]         }, condition = base::local({
[17:43:55.899]             c <- base::c
[17:43:55.899]             inherits <- base::inherits
[17:43:55.899]             invokeRestart <- base::invokeRestart
[17:43:55.899]             length <- base::length
[17:43:55.899]             list <- base::list
[17:43:55.899]             seq.int <- base::seq.int
[17:43:55.899]             signalCondition <- base::signalCondition
[17:43:55.899]             sys.calls <- base::sys.calls
[17:43:55.899]             `[[` <- base::`[[`
[17:43:55.899]             `+` <- base::`+`
[17:43:55.899]             `<<-` <- base::`<<-`
[17:43:55.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.899]                   3L)]
[17:43:55.899]             }
[17:43:55.899]             function(cond) {
[17:43:55.899]                 is_error <- inherits(cond, "error")
[17:43:55.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.899]                   NULL)
[17:43:55.899]                 if (is_error) {
[17:43:55.899]                   sessionInformation <- function() {
[17:43:55.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.899]                       search = base::search(), system = base::Sys.info())
[17:43:55.899]                   }
[17:43:55.899]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.899]                     cond$call), session = sessionInformation(), 
[17:43:55.899]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.899]                   signalCondition(cond)
[17:43:55.899]                 }
[17:43:55.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.899]                 "immediateCondition"))) {
[17:43:55.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.899]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.899]                   if (TRUE && !signal) {
[17:43:55.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.899]                     {
[17:43:55.899]                       inherits <- base::inherits
[17:43:55.899]                       invokeRestart <- base::invokeRestart
[17:43:55.899]                       is.null <- base::is.null
[17:43:55.899]                       muffled <- FALSE
[17:43:55.899]                       if (inherits(cond, "message")) {
[17:43:55.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.899]                         if (muffled) 
[17:43:55.899]                           invokeRestart("muffleMessage")
[17:43:55.899]                       }
[17:43:55.899]                       else if (inherits(cond, "warning")) {
[17:43:55.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.899]                         if (muffled) 
[17:43:55.899]                           invokeRestart("muffleWarning")
[17:43:55.899]                       }
[17:43:55.899]                       else if (inherits(cond, "condition")) {
[17:43:55.899]                         if (!is.null(pattern)) {
[17:43:55.899]                           computeRestarts <- base::computeRestarts
[17:43:55.899]                           grepl <- base::grepl
[17:43:55.899]                           restarts <- computeRestarts(cond)
[17:43:55.899]                           for (restart in restarts) {
[17:43:55.899]                             name <- restart$name
[17:43:55.899]                             if (is.null(name)) 
[17:43:55.899]                               next
[17:43:55.899]                             if (!grepl(pattern, name)) 
[17:43:55.899]                               next
[17:43:55.899]                             invokeRestart(restart)
[17:43:55.899]                             muffled <- TRUE
[17:43:55.899]                             break
[17:43:55.899]                           }
[17:43:55.899]                         }
[17:43:55.899]                       }
[17:43:55.899]                       invisible(muffled)
[17:43:55.899]                     }
[17:43:55.899]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.899]                   }
[17:43:55.899]                 }
[17:43:55.899]                 else {
[17:43:55.899]                   if (TRUE) {
[17:43:55.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.899]                     {
[17:43:55.899]                       inherits <- base::inherits
[17:43:55.899]                       invokeRestart <- base::invokeRestart
[17:43:55.899]                       is.null <- base::is.null
[17:43:55.899]                       muffled <- FALSE
[17:43:55.899]                       if (inherits(cond, "message")) {
[17:43:55.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.899]                         if (muffled) 
[17:43:55.899]                           invokeRestart("muffleMessage")
[17:43:55.899]                       }
[17:43:55.899]                       else if (inherits(cond, "warning")) {
[17:43:55.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.899]                         if (muffled) 
[17:43:55.899]                           invokeRestart("muffleWarning")
[17:43:55.899]                       }
[17:43:55.899]                       else if (inherits(cond, "condition")) {
[17:43:55.899]                         if (!is.null(pattern)) {
[17:43:55.899]                           computeRestarts <- base::computeRestarts
[17:43:55.899]                           grepl <- base::grepl
[17:43:55.899]                           restarts <- computeRestarts(cond)
[17:43:55.899]                           for (restart in restarts) {
[17:43:55.899]                             name <- restart$name
[17:43:55.899]                             if (is.null(name)) 
[17:43:55.899]                               next
[17:43:55.899]                             if (!grepl(pattern, name)) 
[17:43:55.899]                               next
[17:43:55.899]                             invokeRestart(restart)
[17:43:55.899]                             muffled <- TRUE
[17:43:55.899]                             break
[17:43:55.899]                           }
[17:43:55.899]                         }
[17:43:55.899]                       }
[17:43:55.899]                       invisible(muffled)
[17:43:55.899]                     }
[17:43:55.899]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.899]                   }
[17:43:55.899]                 }
[17:43:55.899]             }
[17:43:55.899]         }))
[17:43:55.899]     }, error = function(ex) {
[17:43:55.899]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.899]                 ...future.rng), started = ...future.startTime, 
[17:43:55.899]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.899]             version = "1.8"), class = "FutureResult")
[17:43:55.899]     }, finally = {
[17:43:55.899]         if (!identical(...future.workdir, getwd())) 
[17:43:55.899]             setwd(...future.workdir)
[17:43:55.899]         {
[17:43:55.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.899]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.899]             }
[17:43:55.899]             base::options(...future.oldOptions)
[17:43:55.899]             if (.Platform$OS.type == "windows") {
[17:43:55.899]                 old_names <- names(...future.oldEnvVars)
[17:43:55.899]                 envs <- base::Sys.getenv()
[17:43:55.899]                 names <- names(envs)
[17:43:55.899]                 common <- intersect(names, old_names)
[17:43:55.899]                 added <- setdiff(names, old_names)
[17:43:55.899]                 removed <- setdiff(old_names, names)
[17:43:55.899]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.899]                   envs[common]]
[17:43:55.899]                 NAMES <- toupper(changed)
[17:43:55.899]                 args <- list()
[17:43:55.899]                 for (kk in seq_along(NAMES)) {
[17:43:55.899]                   name <- changed[[kk]]
[17:43:55.899]                   NAME <- NAMES[[kk]]
[17:43:55.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.899]                     next
[17:43:55.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.899]                 }
[17:43:55.899]                 NAMES <- toupper(added)
[17:43:55.899]                 for (kk in seq_along(NAMES)) {
[17:43:55.899]                   name <- added[[kk]]
[17:43:55.899]                   NAME <- NAMES[[kk]]
[17:43:55.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.899]                     next
[17:43:55.899]                   args[[name]] <- ""
[17:43:55.899]                 }
[17:43:55.899]                 NAMES <- toupper(removed)
[17:43:55.899]                 for (kk in seq_along(NAMES)) {
[17:43:55.899]                   name <- removed[[kk]]
[17:43:55.899]                   NAME <- NAMES[[kk]]
[17:43:55.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.899]                     next
[17:43:55.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.899]                 }
[17:43:55.899]                 if (length(args) > 0) 
[17:43:55.899]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.899]             }
[17:43:55.899]             else {
[17:43:55.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.899]             }
[17:43:55.899]             {
[17:43:55.899]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.899]                   0L) {
[17:43:55.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.899]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.899]                   base::options(opts)
[17:43:55.899]                 }
[17:43:55.899]                 {
[17:43:55.899]                   {
[17:43:55.899]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.899]                     NULL
[17:43:55.899]                   }
[17:43:55.899]                   options(future.plan = NULL)
[17:43:55.899]                   if (is.na(NA_character_)) 
[17:43:55.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.899]                     .init = FALSE)
[17:43:55.899]                 }
[17:43:55.899]             }
[17:43:55.899]         }
[17:43:55.899]     })
[17:43:55.899]     if (TRUE) {
[17:43:55.899]         base::sink(type = "output", split = FALSE)
[17:43:55.899]         if (TRUE) {
[17:43:55.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.899]         }
[17:43:55.899]         else {
[17:43:55.899]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.899]         }
[17:43:55.899]         base::close(...future.stdout)
[17:43:55.899]         ...future.stdout <- NULL
[17:43:55.899]     }
[17:43:55.899]     ...future.result$conditions <- ...future.conditions
[17:43:55.899]     ...future.result$finished <- base::Sys.time()
[17:43:55.899]     ...future.result
[17:43:55.899] }
[17:43:55.901] assign_globals() ...
[17:43:55.901] List of 5
[17:43:55.901]  $ ...future.FUN            :function (x, ...)  
[17:43:55.901]  $ future.call.arguments    : list()
[17:43:55.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.901]  $ ...future.elements_ii    :List of 1
[17:43:55.901]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:43:55.901]  $ ...future.seeds_ii       : NULL
[17:43:55.901]  $ ...future.globals.maxSize: NULL
[17:43:55.901]  - attr(*, "where")=List of 5
[17:43:55.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:55.901]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:55.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:55.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:55.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:55.901]  - attr(*, "resolved")= logi FALSE
[17:43:55.901]  - attr(*, "total_size")= num 1240
[17:43:55.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.901]  - attr(*, "already-done")= logi TRUE
[17:43:55.906] - copied ‘...future.FUN’ to environment
[17:43:55.906] - copied ‘future.call.arguments’ to environment
[17:43:55.906] - copied ‘...future.elements_ii’ to environment
[17:43:55.906] - copied ‘...future.seeds_ii’ to environment
[17:43:55.906] - copied ‘...future.globals.maxSize’ to environment
[17:43:55.906] assign_globals() ... done
[17:43:55.906] requestCore(): workers = 2
[17:43:55.909] MulticoreFuture started
[17:43:55.910] - Launch lazy future ... done
[17:43:55.910] plan(): Setting new future strategy stack:
[17:43:55.910] run() for ‘MulticoreFuture’ ... done
[17:43:55.910] Created future:
[17:43:55.910] List of future strategies:
[17:43:55.910] 1. sequential:
[17:43:55.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.910]    - tweaked: FALSE
[17:43:55.910]    - call: NULL
[17:43:55.911] plan(): nbrOfWorkers() = 1
[17:43:55.913] plan(): Setting new future strategy stack:
[17:43:55.913] List of future strategies:
[17:43:55.913] 1. multicore:
[17:43:55.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:55.913]    - tweaked: FALSE
[17:43:55.913]    - call: plan(strategy)
[17:43:55.922] plan(): nbrOfWorkers() = 2
[17:43:55.910] MulticoreFuture:
[17:43:55.910] Label: ‘future_eapply-1’
[17:43:55.910] Expression:
[17:43:55.910] {
[17:43:55.910]     do.call(function(...) {
[17:43:55.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.910]             on.exit(options(oopts), add = TRUE)
[17:43:55.910]         }
[17:43:55.910]         {
[17:43:55.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.910]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.910]             })
[17:43:55.910]         }
[17:43:55.910]     }, args = future.call.arguments)
[17:43:55.910] }
[17:43:55.910] Lazy evaluation: FALSE
[17:43:55.910] Asynchronous evaluation: TRUE
[17:43:55.910] Local evaluation: TRUE
[17:43:55.910] Environment: R_GlobalEnv
[17:43:55.910] Capture standard output: TRUE
[17:43:55.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.910] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.910] Packages: <none>
[17:43:55.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.910] Resolved: TRUE
[17:43:55.910] Value: <not collected>
[17:43:55.910] Conditions captured: <none>
[17:43:55.910] Early signaling: FALSE
[17:43:55.910] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:55.910] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.923] Chunk #1 of 2 ... DONE
[17:43:55.923] Chunk #2 of 2 ...
[17:43:55.923]  - Finding globals in 'X' for chunk #2 ...
[17:43:55.923] getGlobalsAndPackages() ...
[17:43:55.923] Searching for globals...
[17:43:55.924] 
[17:43:55.924] Searching for globals ... DONE
[17:43:55.926] - globals: [0] <none>
[17:43:55.927] getGlobalsAndPackages() ... DONE
[17:43:55.927]    + additional globals found: [n=0] 
[17:43:55.927]    + additional namespaces needed: [n=0] 
[17:43:55.927]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:55.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.927]  - seeds: <none>
[17:43:55.927]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.928] getGlobalsAndPackages() ...
[17:43:55.928] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.928] Resolving globals: FALSE
[17:43:55.928] Tweak future expression to call with '...' arguments ...
[17:43:55.928] {
[17:43:55.928]     do.call(function(...) {
[17:43:55.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.928]             on.exit(options(oopts), add = TRUE)
[17:43:55.928]         }
[17:43:55.928]         {
[17:43:55.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.928]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.928]             })
[17:43:55.928]         }
[17:43:55.928]     }, args = future.call.arguments)
[17:43:55.928] }
[17:43:55.929] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.930] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.930] 
[17:43:55.930] getGlobalsAndPackages() ... DONE
[17:43:55.931] run() for ‘Future’ ...
[17:43:55.931] - state: ‘created’
[17:43:55.931] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.936] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:55.936]   - Field: ‘label’
[17:43:55.936]   - Field: ‘local’
[17:43:55.937]   - Field: ‘owner’
[17:43:55.937]   - Field: ‘envir’
[17:43:55.937]   - Field: ‘workers’
[17:43:55.937]   - Field: ‘packages’
[17:43:55.937]   - Field: ‘gc’
[17:43:55.937]   - Field: ‘job’
[17:43:55.937]   - Field: ‘conditions’
[17:43:55.938]   - Field: ‘expr’
[17:43:55.938]   - Field: ‘uuid’
[17:43:55.938]   - Field: ‘seed’
[17:43:55.938]   - Field: ‘version’
[17:43:55.938]   - Field: ‘result’
[17:43:55.938]   - Field: ‘asynchronous’
[17:43:55.939]   - Field: ‘calls’
[17:43:55.939]   - Field: ‘globals’
[17:43:55.939]   - Field: ‘stdout’
[17:43:55.939]   - Field: ‘earlySignal’
[17:43:55.939]   - Field: ‘lazy’
[17:43:55.939]   - Field: ‘state’
[17:43:55.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:55.940] - Launch lazy future ...
[17:43:55.940] Packages needed by the future expression (n = 0): <none>
[17:43:55.940] Packages needed by future strategies (n = 0): <none>
[17:43:55.941] {
[17:43:55.941]     {
[17:43:55.941]         {
[17:43:55.941]             ...future.startTime <- base::Sys.time()
[17:43:55.941]             {
[17:43:55.941]                 {
[17:43:55.941]                   {
[17:43:55.941]                     {
[17:43:55.941]                       base::local({
[17:43:55.941]                         has_future <- base::requireNamespace("future", 
[17:43:55.941]                           quietly = TRUE)
[17:43:55.941]                         if (has_future) {
[17:43:55.941]                           ns <- base::getNamespace("future")
[17:43:55.941]                           version <- ns[[".package"]][["version"]]
[17:43:55.941]                           if (is.null(version)) 
[17:43:55.941]                             version <- utils::packageVersion("future")
[17:43:55.941]                         }
[17:43:55.941]                         else {
[17:43:55.941]                           version <- NULL
[17:43:55.941]                         }
[17:43:55.941]                         if (!has_future || version < "1.8.0") {
[17:43:55.941]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.941]                             "", base::R.version$version.string), 
[17:43:55.941]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.941]                               "release", "version")], collapse = " "), 
[17:43:55.941]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.941]                             info)
[17:43:55.941]                           info <- base::paste(info, collapse = "; ")
[17:43:55.941]                           if (!has_future) {
[17:43:55.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.941]                               info)
[17:43:55.941]                           }
[17:43:55.941]                           else {
[17:43:55.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.941]                               info, version)
[17:43:55.941]                           }
[17:43:55.941]                           base::stop(msg)
[17:43:55.941]                         }
[17:43:55.941]                       })
[17:43:55.941]                     }
[17:43:55.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.941]                     base::options(mc.cores = 1L)
[17:43:55.941]                   }
[17:43:55.941]                   ...future.strategy.old <- future::plan("list")
[17:43:55.941]                   options(future.plan = NULL)
[17:43:55.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.941]                 }
[17:43:55.941]                 ...future.workdir <- getwd()
[17:43:55.941]             }
[17:43:55.941]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.941]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.941]         }
[17:43:55.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.941]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.941]             base::names(...future.oldOptions))
[17:43:55.941]     }
[17:43:55.941]     if (FALSE) {
[17:43:55.941]     }
[17:43:55.941]     else {
[17:43:55.941]         if (TRUE) {
[17:43:55.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.941]                 open = "w")
[17:43:55.941]         }
[17:43:55.941]         else {
[17:43:55.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.941]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.941]         }
[17:43:55.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.941]             base::sink(type = "output", split = FALSE)
[17:43:55.941]             base::close(...future.stdout)
[17:43:55.941]         }, add = TRUE)
[17:43:55.941]     }
[17:43:55.941]     ...future.frame <- base::sys.nframe()
[17:43:55.941]     ...future.conditions <- base::list()
[17:43:55.941]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.941]     if (FALSE) {
[17:43:55.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.941]     }
[17:43:55.941]     ...future.result <- base::tryCatch({
[17:43:55.941]         base::withCallingHandlers({
[17:43:55.941]             ...future.value <- base::withVisible(base::local({
[17:43:55.941]                 withCallingHandlers({
[17:43:55.941]                   {
[17:43:55.941]                     do.call(function(...) {
[17:43:55.941]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.941]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.941]                         ...future.globals.maxSize)) {
[17:43:55.941]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.941]                         on.exit(options(oopts), add = TRUE)
[17:43:55.941]                       }
[17:43:55.941]                       {
[17:43:55.941]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.941]                           FUN = function(jj) {
[17:43:55.941]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.941]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.941]                           })
[17:43:55.941]                       }
[17:43:55.941]                     }, args = future.call.arguments)
[17:43:55.941]                   }
[17:43:55.941]                 }, immediateCondition = function(cond) {
[17:43:55.941]                   save_rds <- function (object, pathname, ...) 
[17:43:55.941]                   {
[17:43:55.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:55.941]                     if (file_test("-f", pathname_tmp)) {
[17:43:55.941]                       fi_tmp <- file.info(pathname_tmp)
[17:43:55.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:55.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:55.941]                         fi_tmp[["mtime"]])
[17:43:55.941]                     }
[17:43:55.941]                     tryCatch({
[17:43:55.941]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:55.941]                     }, error = function(ex) {
[17:43:55.941]                       msg <- conditionMessage(ex)
[17:43:55.941]                       fi_tmp <- file.info(pathname_tmp)
[17:43:55.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:55.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:55.941]                         fi_tmp[["mtime"]], msg)
[17:43:55.941]                       ex$message <- msg
[17:43:55.941]                       stop(ex)
[17:43:55.941]                     })
[17:43:55.941]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:55.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:55.941]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:55.941]                       fi_tmp <- file.info(pathname_tmp)
[17:43:55.941]                       fi <- file.info(pathname)
[17:43:55.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:55.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:55.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:55.941]                         fi[["size"]], fi[["mtime"]])
[17:43:55.941]                       stop(msg)
[17:43:55.941]                     }
[17:43:55.941]                     invisible(pathname)
[17:43:55.941]                   }
[17:43:55.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:55.941]                     rootPath = tempdir()) 
[17:43:55.941]                   {
[17:43:55.941]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:55.941]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:55.941]                       tmpdir = path, fileext = ".rds")
[17:43:55.941]                     save_rds(obj, file)
[17:43:55.941]                   }
[17:43:55.941]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:55.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.941]                   {
[17:43:55.941]                     inherits <- base::inherits
[17:43:55.941]                     invokeRestart <- base::invokeRestart
[17:43:55.941]                     is.null <- base::is.null
[17:43:55.941]                     muffled <- FALSE
[17:43:55.941]                     if (inherits(cond, "message")) {
[17:43:55.941]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.941]                       if (muffled) 
[17:43:55.941]                         invokeRestart("muffleMessage")
[17:43:55.941]                     }
[17:43:55.941]                     else if (inherits(cond, "warning")) {
[17:43:55.941]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.941]                       if (muffled) 
[17:43:55.941]                         invokeRestart("muffleWarning")
[17:43:55.941]                     }
[17:43:55.941]                     else if (inherits(cond, "condition")) {
[17:43:55.941]                       if (!is.null(pattern)) {
[17:43:55.941]                         computeRestarts <- base::computeRestarts
[17:43:55.941]                         grepl <- base::grepl
[17:43:55.941]                         restarts <- computeRestarts(cond)
[17:43:55.941]                         for (restart in restarts) {
[17:43:55.941]                           name <- restart$name
[17:43:55.941]                           if (is.null(name)) 
[17:43:55.941]                             next
[17:43:55.941]                           if (!grepl(pattern, name)) 
[17:43:55.941]                             next
[17:43:55.941]                           invokeRestart(restart)
[17:43:55.941]                           muffled <- TRUE
[17:43:55.941]                           break
[17:43:55.941]                         }
[17:43:55.941]                       }
[17:43:55.941]                     }
[17:43:55.941]                     invisible(muffled)
[17:43:55.941]                   }
[17:43:55.941]                   muffleCondition(cond)
[17:43:55.941]                 })
[17:43:55.941]             }))
[17:43:55.941]             future::FutureResult(value = ...future.value$value, 
[17:43:55.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.941]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.941]                     ...future.globalenv.names))
[17:43:55.941]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.941]         }, condition = base::local({
[17:43:55.941]             c <- base::c
[17:43:55.941]             inherits <- base::inherits
[17:43:55.941]             invokeRestart <- base::invokeRestart
[17:43:55.941]             length <- base::length
[17:43:55.941]             list <- base::list
[17:43:55.941]             seq.int <- base::seq.int
[17:43:55.941]             signalCondition <- base::signalCondition
[17:43:55.941]             sys.calls <- base::sys.calls
[17:43:55.941]             `[[` <- base::`[[`
[17:43:55.941]             `+` <- base::`+`
[17:43:55.941]             `<<-` <- base::`<<-`
[17:43:55.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.941]                   3L)]
[17:43:55.941]             }
[17:43:55.941]             function(cond) {
[17:43:55.941]                 is_error <- inherits(cond, "error")
[17:43:55.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.941]                   NULL)
[17:43:55.941]                 if (is_error) {
[17:43:55.941]                   sessionInformation <- function() {
[17:43:55.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.941]                       search = base::search(), system = base::Sys.info())
[17:43:55.941]                   }
[17:43:55.941]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.941]                     cond$call), session = sessionInformation(), 
[17:43:55.941]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.941]                   signalCondition(cond)
[17:43:55.941]                 }
[17:43:55.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.941]                 "immediateCondition"))) {
[17:43:55.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.941]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.941]                   if (TRUE && !signal) {
[17:43:55.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.941]                     {
[17:43:55.941]                       inherits <- base::inherits
[17:43:55.941]                       invokeRestart <- base::invokeRestart
[17:43:55.941]                       is.null <- base::is.null
[17:43:55.941]                       muffled <- FALSE
[17:43:55.941]                       if (inherits(cond, "message")) {
[17:43:55.941]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.941]                         if (muffled) 
[17:43:55.941]                           invokeRestart("muffleMessage")
[17:43:55.941]                       }
[17:43:55.941]                       else if (inherits(cond, "warning")) {
[17:43:55.941]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.941]                         if (muffled) 
[17:43:55.941]                           invokeRestart("muffleWarning")
[17:43:55.941]                       }
[17:43:55.941]                       else if (inherits(cond, "condition")) {
[17:43:55.941]                         if (!is.null(pattern)) {
[17:43:55.941]                           computeRestarts <- base::computeRestarts
[17:43:55.941]                           grepl <- base::grepl
[17:43:55.941]                           restarts <- computeRestarts(cond)
[17:43:55.941]                           for (restart in restarts) {
[17:43:55.941]                             name <- restart$name
[17:43:55.941]                             if (is.null(name)) 
[17:43:55.941]                               next
[17:43:55.941]                             if (!grepl(pattern, name)) 
[17:43:55.941]                               next
[17:43:55.941]                             invokeRestart(restart)
[17:43:55.941]                             muffled <- TRUE
[17:43:55.941]                             break
[17:43:55.941]                           }
[17:43:55.941]                         }
[17:43:55.941]                       }
[17:43:55.941]                       invisible(muffled)
[17:43:55.941]                     }
[17:43:55.941]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.941]                   }
[17:43:55.941]                 }
[17:43:55.941]                 else {
[17:43:55.941]                   if (TRUE) {
[17:43:55.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.941]                     {
[17:43:55.941]                       inherits <- base::inherits
[17:43:55.941]                       invokeRestart <- base::invokeRestart
[17:43:55.941]                       is.null <- base::is.null
[17:43:55.941]                       muffled <- FALSE
[17:43:55.941]                       if (inherits(cond, "message")) {
[17:43:55.941]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.941]                         if (muffled) 
[17:43:55.941]                           invokeRestart("muffleMessage")
[17:43:55.941]                       }
[17:43:55.941]                       else if (inherits(cond, "warning")) {
[17:43:55.941]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.941]                         if (muffled) 
[17:43:55.941]                           invokeRestart("muffleWarning")
[17:43:55.941]                       }
[17:43:55.941]                       else if (inherits(cond, "condition")) {
[17:43:55.941]                         if (!is.null(pattern)) {
[17:43:55.941]                           computeRestarts <- base::computeRestarts
[17:43:55.941]                           grepl <- base::grepl
[17:43:55.941]                           restarts <- computeRestarts(cond)
[17:43:55.941]                           for (restart in restarts) {
[17:43:55.941]                             name <- restart$name
[17:43:55.941]                             if (is.null(name)) 
[17:43:55.941]                               next
[17:43:55.941]                             if (!grepl(pattern, name)) 
[17:43:55.941]                               next
[17:43:55.941]                             invokeRestart(restart)
[17:43:55.941]                             muffled <- TRUE
[17:43:55.941]                             break
[17:43:55.941]                           }
[17:43:55.941]                         }
[17:43:55.941]                       }
[17:43:55.941]                       invisible(muffled)
[17:43:55.941]                     }
[17:43:55.941]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.941]                   }
[17:43:55.941]                 }
[17:43:55.941]             }
[17:43:55.941]         }))
[17:43:55.941]     }, error = function(ex) {
[17:43:55.941]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.941]                 ...future.rng), started = ...future.startTime, 
[17:43:55.941]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.941]             version = "1.8"), class = "FutureResult")
[17:43:55.941]     }, finally = {
[17:43:55.941]         if (!identical(...future.workdir, getwd())) 
[17:43:55.941]             setwd(...future.workdir)
[17:43:55.941]         {
[17:43:55.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.941]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.941]             }
[17:43:55.941]             base::options(...future.oldOptions)
[17:43:55.941]             if (.Platform$OS.type == "windows") {
[17:43:55.941]                 old_names <- names(...future.oldEnvVars)
[17:43:55.941]                 envs <- base::Sys.getenv()
[17:43:55.941]                 names <- names(envs)
[17:43:55.941]                 common <- intersect(names, old_names)
[17:43:55.941]                 added <- setdiff(names, old_names)
[17:43:55.941]                 removed <- setdiff(old_names, names)
[17:43:55.941]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.941]                   envs[common]]
[17:43:55.941]                 NAMES <- toupper(changed)
[17:43:55.941]                 args <- list()
[17:43:55.941]                 for (kk in seq_along(NAMES)) {
[17:43:55.941]                   name <- changed[[kk]]
[17:43:55.941]                   NAME <- NAMES[[kk]]
[17:43:55.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.941]                     next
[17:43:55.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.941]                 }
[17:43:55.941]                 NAMES <- toupper(added)
[17:43:55.941]                 for (kk in seq_along(NAMES)) {
[17:43:55.941]                   name <- added[[kk]]
[17:43:55.941]                   NAME <- NAMES[[kk]]
[17:43:55.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.941]                     next
[17:43:55.941]                   args[[name]] <- ""
[17:43:55.941]                 }
[17:43:55.941]                 NAMES <- toupper(removed)
[17:43:55.941]                 for (kk in seq_along(NAMES)) {
[17:43:55.941]                   name <- removed[[kk]]
[17:43:55.941]                   NAME <- NAMES[[kk]]
[17:43:55.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.941]                     next
[17:43:55.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.941]                 }
[17:43:55.941]                 if (length(args) > 0) 
[17:43:55.941]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.941]             }
[17:43:55.941]             else {
[17:43:55.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.941]             }
[17:43:55.941]             {
[17:43:55.941]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.941]                   0L) {
[17:43:55.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.941]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.941]                   base::options(opts)
[17:43:55.941]                 }
[17:43:55.941]                 {
[17:43:55.941]                   {
[17:43:55.941]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.941]                     NULL
[17:43:55.941]                   }
[17:43:55.941]                   options(future.plan = NULL)
[17:43:55.941]                   if (is.na(NA_character_)) 
[17:43:55.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.941]                     .init = FALSE)
[17:43:55.941]                 }
[17:43:55.941]             }
[17:43:55.941]         }
[17:43:55.941]     })
[17:43:55.941]     if (TRUE) {
[17:43:55.941]         base::sink(type = "output", split = FALSE)
[17:43:55.941]         if (TRUE) {
[17:43:55.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.941]         }
[17:43:55.941]         else {
[17:43:55.941]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.941]         }
[17:43:55.941]         base::close(...future.stdout)
[17:43:55.941]         ...future.stdout <- NULL
[17:43:55.941]     }
[17:43:55.941]     ...future.result$conditions <- ...future.conditions
[17:43:55.941]     ...future.result$finished <- base::Sys.time()
[17:43:55.941]     ...future.result
[17:43:55.941] }
[17:43:55.943] assign_globals() ...
[17:43:55.943] List of 5
[17:43:55.943]  $ ...future.FUN            :function (x, ...)  
[17:43:55.943]  $ future.call.arguments    : list()
[17:43:55.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.943]  $ ...future.elements_ii    :List of 2
[17:43:55.943]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:55.943]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:55.943]  $ ...future.seeds_ii       : NULL
[17:43:55.943]  $ ...future.globals.maxSize: NULL
[17:43:55.943]  - attr(*, "where")=List of 5
[17:43:55.943]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:55.943]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:55.943]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:55.943]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:55.943]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:55.943]  - attr(*, "resolved")= logi FALSE
[17:43:55.943]  - attr(*, "total_size")= num 1240
[17:43:55.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.943]  - attr(*, "already-done")= logi TRUE
[17:43:55.950] - copied ‘...future.FUN’ to environment
[17:43:55.951] - copied ‘future.call.arguments’ to environment
[17:43:55.951] - copied ‘...future.elements_ii’ to environment
[17:43:55.951] - copied ‘...future.seeds_ii’ to environment
[17:43:55.951] - copied ‘...future.globals.maxSize’ to environment
[17:43:55.951] assign_globals() ... done
[17:43:55.951] requestCore(): workers = 2
[17:43:55.957] MulticoreFuture started
[17:43:55.957] - Launch lazy future ... done
[17:43:55.957] run() for ‘MulticoreFuture’ ... done
[17:43:55.957] Created future:
[17:43:55.958] plan(): Setting new future strategy stack:
[17:43:55.958] List of future strategies:
[17:43:55.958] 1. sequential:
[17:43:55.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.958]    - tweaked: FALSE
[17:43:55.958]    - call: NULL
[17:43:55.959] plan(): nbrOfWorkers() = 1
[17:43:55.961] plan(): Setting new future strategy stack:
[17:43:55.961] List of future strategies:
[17:43:55.961] 1. multicore:
[17:43:55.961]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:55.961]    - tweaked: FALSE
[17:43:55.961]    - call: plan(strategy)
[17:43:55.966] plan(): nbrOfWorkers() = 2
[17:43:55.958] MulticoreFuture:
[17:43:55.958] Label: ‘future_eapply-2’
[17:43:55.958] Expression:
[17:43:55.958] {
[17:43:55.958]     do.call(function(...) {
[17:43:55.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.958]             on.exit(options(oopts), add = TRUE)
[17:43:55.958]         }
[17:43:55.958]         {
[17:43:55.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.958]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.958]             })
[17:43:55.958]         }
[17:43:55.958]     }, args = future.call.arguments)
[17:43:55.958] }
[17:43:55.958] Lazy evaluation: FALSE
[17:43:55.958] Asynchronous evaluation: TRUE
[17:43:55.958] Local evaluation: TRUE
[17:43:55.958] Environment: R_GlobalEnv
[17:43:55.958] Capture standard output: TRUE
[17:43:55.958] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.958] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.958] Packages: <none>
[17:43:55.958] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.958] Resolved: TRUE
[17:43:55.958] Value: <not collected>
[17:43:55.958] Conditions captured: <none>
[17:43:55.958] Early signaling: FALSE
[17:43:55.958] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:55.958] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.967] Chunk #2 of 2 ... DONE
[17:43:55.967] Launching 2 futures (chunks) ... DONE
[17:43:55.967] Resolving 2 futures (chunks) ...
[17:43:55.968] resolve() on list ...
[17:43:55.968]  recursive: 0
[17:43:55.968]  length: 2
[17:43:55.968] 
[17:43:55.968] Future #1
[17:43:55.969] result() for MulticoreFuture ...
[17:43:55.971] result() for MulticoreFuture ...
[17:43:55.971] result() for MulticoreFuture ... done
[17:43:55.971] result() for MulticoreFuture ... done
[17:43:55.971] result() for MulticoreFuture ...
[17:43:55.971] result() for MulticoreFuture ... done
[17:43:55.971] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:55.972] - nx: 2
[17:43:55.972] - relay: TRUE
[17:43:55.972] - stdout: TRUE
[17:43:55.972] - signal: TRUE
[17:43:55.972] - resignal: FALSE
[17:43:55.972] - force: TRUE
[17:43:55.972] - relayed: [n=2] FALSE, FALSE
[17:43:55.972] - queued futures: [n=2] FALSE, FALSE
[17:43:55.973]  - until=1
[17:43:55.973]  - relaying element #1
[17:43:55.973] result() for MulticoreFuture ...
[17:43:55.973] result() for MulticoreFuture ... done
[17:43:55.973] result() for MulticoreFuture ...
[17:43:55.973] result() for MulticoreFuture ... done
[17:43:55.974] result() for MulticoreFuture ...
[17:43:55.974] result() for MulticoreFuture ... done
[17:43:55.974] result() for MulticoreFuture ...
[17:43:55.974] result() for MulticoreFuture ... done
[17:43:55.974] - relayed: [n=2] TRUE, FALSE
[17:43:55.974] - queued futures: [n=2] TRUE, FALSE
[17:43:55.974] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:55.974]  length: 1 (resolved future 1)
[17:43:55.975] Future #2
[17:43:55.975] result() for MulticoreFuture ...
[17:43:55.976] result() for MulticoreFuture ...
[17:43:55.976] result() for MulticoreFuture ... done
[17:43:55.976] result() for MulticoreFuture ... done
[17:43:55.979] result() for MulticoreFuture ...
[17:43:55.979] result() for MulticoreFuture ... done
[17:43:55.979] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:55.979] - nx: 2
[17:43:55.979] - relay: TRUE
[17:43:55.979] - stdout: TRUE
[17:43:55.979] - signal: TRUE
[17:43:55.979] - resignal: FALSE
[17:43:55.979] - force: TRUE
[17:43:55.980] - relayed: [n=2] TRUE, FALSE
[17:43:55.980] - queued futures: [n=2] TRUE, FALSE
[17:43:55.980]  - until=2
[17:43:55.980]  - relaying element #2
[17:43:55.980] result() for MulticoreFuture ...
[17:43:55.980] result() for MulticoreFuture ... done
[17:43:55.980] result() for MulticoreFuture ...
[17:43:55.981] result() for MulticoreFuture ... done
[17:43:55.981] result() for MulticoreFuture ...
[17:43:55.981] result() for MulticoreFuture ... done
[17:43:55.981] result() for MulticoreFuture ...
[17:43:55.981] result() for MulticoreFuture ... done
[17:43:55.981] - relayed: [n=2] TRUE, TRUE
[17:43:55.981] - queued futures: [n=2] TRUE, TRUE
[17:43:55.981] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:55.982]  length: 0 (resolved future 2)
[17:43:55.982] Relaying remaining futures
[17:43:55.982] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.982] - nx: 2
[17:43:55.982] - relay: TRUE
[17:43:55.982] - stdout: TRUE
[17:43:55.982] - signal: TRUE
[17:43:55.982] - resignal: FALSE
[17:43:55.983] - force: TRUE
[17:43:55.983] - relayed: [n=2] TRUE, TRUE
[17:43:55.983] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:55.983] - relayed: [n=2] TRUE, TRUE
[17:43:55.983] - queued futures: [n=2] TRUE, TRUE
[17:43:55.983] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.983] resolve() on list ... DONE
[17:43:55.983] result() for MulticoreFuture ...
[17:43:55.984] result() for MulticoreFuture ... done
[17:43:55.984] result() for MulticoreFuture ...
[17:43:55.984] result() for MulticoreFuture ... done
[17:43:55.984] result() for MulticoreFuture ...
[17:43:55.984] result() for MulticoreFuture ... done
[17:43:55.984] result() for MulticoreFuture ...
[17:43:55.984] result() for MulticoreFuture ... done
[17:43:55.984]  - Number of value chunks collected: 2
[17:43:55.985] Resolving 2 futures (chunks) ... DONE
[17:43:55.985] Reducing values from 2 chunks ...
[17:43:55.985]  - Number of values collected after concatenation: 3
[17:43:55.985]  - Number of values expected: 3
[17:43:55.985] Reducing values from 2 chunks ... DONE
[17:43:55.985] future_lapply() ... DONE
[17:43:55.986] future_lapply() ...
[17:43:55.991] Number of chunks: 2
[17:43:55.991] getGlobalsAndPackagesXApply() ...
[17:43:55.991]  - future.globals: TRUE
[17:43:55.991] getGlobalsAndPackages() ...
[17:43:55.991] Searching for globals...
[17:43:55.993] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.993] Searching for globals ... DONE
[17:43:55.993] Resolving globals: FALSE
[17:43:55.993] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:55.994] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:55.994] - globals: [1] ‘FUN’
[17:43:55.994] - packages: [1] ‘stats’
[17:43:55.994] getGlobalsAndPackages() ... DONE
[17:43:55.994]  - globals found/used: [n=1] ‘FUN’
[17:43:55.995]  - needed namespaces: [n=1] ‘stats’
[17:43:55.995] Finding globals ... DONE
[17:43:55.995]  - use_args: TRUE
[17:43:55.995]  - Getting '...' globals ...
[17:43:55.995] resolve() on list ...
[17:43:55.995]  recursive: 0
[17:43:55.996]  length: 1
[17:43:55.996]  elements: ‘...’
[17:43:55.996]  length: 0 (resolved future 1)
[17:43:55.996] resolve() on list ... DONE
[17:43:55.996]    - '...' content: [n=1] ‘probs’
[17:43:55.996] List of 1
[17:43:55.996]  $ ...:List of 1
[17:43:55.996]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:55.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.996]  - attr(*, "where")=List of 1
[17:43:55.996]   ..$ ...:<environment: 0x55813ca06a38> 
[17:43:55.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.996]  - attr(*, "resolved")= logi TRUE
[17:43:55.996]  - attr(*, "total_size")= num NA
[17:43:56.000]  - Getting '...' globals ... DONE
[17:43:56.000] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:56.000] List of 2
[17:43:56.000]  $ ...future.FUN:function (x, ...)  
[17:43:56.000]  $ ...          :List of 1
[17:43:56.000]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:56.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.000]  - attr(*, "where")=List of 2
[17:43:56.000]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:56.000]   ..$ ...          :<environment: 0x55813ca06a38> 
[17:43:56.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.000]  - attr(*, "resolved")= logi FALSE
[17:43:56.000]  - attr(*, "total_size")= num 1328
[17:43:56.003] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:56.003] getGlobalsAndPackagesXApply() ... DONE
[17:43:56.004] Number of futures (= number of chunks): 2
[17:43:56.004] Launching 2 futures (chunks) ...
[17:43:56.004] Chunk #1 of 2 ...
[17:43:56.004]  - Finding globals in 'X' for chunk #1 ...
[17:43:56.004] getGlobalsAndPackages() ...
[17:43:56.004] Searching for globals...
[17:43:56.004] 
[17:43:56.005] Searching for globals ... DONE
[17:43:56.005] - globals: [0] <none>
[17:43:56.005] getGlobalsAndPackages() ... DONE
[17:43:56.005]    + additional globals found: [n=0] 
[17:43:56.005]    + additional namespaces needed: [n=0] 
[17:43:56.005]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:56.005]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.005]  - seeds: <none>
[17:43:56.005]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.005] getGlobalsAndPackages() ...
[17:43:56.005] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.006] Resolving globals: FALSE
[17:43:56.006] Tweak future expression to call with '...' arguments ...
[17:43:56.006] {
[17:43:56.006]     do.call(function(...) {
[17:43:56.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.006]             on.exit(options(oopts), add = TRUE)
[17:43:56.006]         }
[17:43:56.006]         {
[17:43:56.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.006]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.006]             })
[17:43:56.006]         }
[17:43:56.006]     }, args = future.call.arguments)
[17:43:56.006] }
[17:43:56.006] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.006] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.007] - packages: [1] ‘stats’
[17:43:56.007] getGlobalsAndPackages() ... DONE
[17:43:56.007] run() for ‘Future’ ...
[17:43:56.007] - state: ‘created’
[17:43:56.007] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.013] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.013] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:56.013]   - Field: ‘label’
[17:43:56.013]   - Field: ‘local’
[17:43:56.013]   - Field: ‘owner’
[17:43:56.013]   - Field: ‘envir’
[17:43:56.014]   - Field: ‘workers’
[17:43:56.014]   - Field: ‘packages’
[17:43:56.014]   - Field: ‘gc’
[17:43:56.014]   - Field: ‘job’
[17:43:56.014]   - Field: ‘conditions’
[17:43:56.014]   - Field: ‘expr’
[17:43:56.014]   - Field: ‘uuid’
[17:43:56.014]   - Field: ‘seed’
[17:43:56.014]   - Field: ‘version’
[17:43:56.014]   - Field: ‘result’
[17:43:56.014]   - Field: ‘asynchronous’
[17:43:56.015]   - Field: ‘calls’
[17:43:56.015]   - Field: ‘globals’
[17:43:56.015]   - Field: ‘stdout’
[17:43:56.015]   - Field: ‘earlySignal’
[17:43:56.015]   - Field: ‘lazy’
[17:43:56.015]   - Field: ‘state’
[17:43:56.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:56.015] - Launch lazy future ...
[17:43:56.016] Packages needed by the future expression (n = 1): ‘stats’
[17:43:56.016] Packages needed by future strategies (n = 0): <none>
[17:43:56.016] {
[17:43:56.016]     {
[17:43:56.016]         {
[17:43:56.016]             ...future.startTime <- base::Sys.time()
[17:43:56.016]             {
[17:43:56.016]                 {
[17:43:56.016]                   {
[17:43:56.016]                     {
[17:43:56.016]                       {
[17:43:56.016]                         base::local({
[17:43:56.016]                           has_future <- base::requireNamespace("future", 
[17:43:56.016]                             quietly = TRUE)
[17:43:56.016]                           if (has_future) {
[17:43:56.016]                             ns <- base::getNamespace("future")
[17:43:56.016]                             version <- ns[[".package"]][["version"]]
[17:43:56.016]                             if (is.null(version)) 
[17:43:56.016]                               version <- utils::packageVersion("future")
[17:43:56.016]                           }
[17:43:56.016]                           else {
[17:43:56.016]                             version <- NULL
[17:43:56.016]                           }
[17:43:56.016]                           if (!has_future || version < "1.8.0") {
[17:43:56.016]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.016]                               "", base::R.version$version.string), 
[17:43:56.016]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:56.016]                                 base::R.version$platform, 8 * 
[17:43:56.016]                                   base::.Machine$sizeof.pointer), 
[17:43:56.016]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.016]                                 "release", "version")], collapse = " "), 
[17:43:56.016]                               hostname = base::Sys.info()[["nodename"]])
[17:43:56.016]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.016]                               info)
[17:43:56.016]                             info <- base::paste(info, collapse = "; ")
[17:43:56.016]                             if (!has_future) {
[17:43:56.016]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.016]                                 info)
[17:43:56.016]                             }
[17:43:56.016]                             else {
[17:43:56.016]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.016]                                 info, version)
[17:43:56.016]                             }
[17:43:56.016]                             base::stop(msg)
[17:43:56.016]                           }
[17:43:56.016]                         })
[17:43:56.016]                       }
[17:43:56.016]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.016]                       base::options(mc.cores = 1L)
[17:43:56.016]                     }
[17:43:56.016]                     base::local({
[17:43:56.016]                       for (pkg in "stats") {
[17:43:56.016]                         base::loadNamespace(pkg)
[17:43:56.016]                         base::library(pkg, character.only = TRUE)
[17:43:56.016]                       }
[17:43:56.016]                     })
[17:43:56.016]                   }
[17:43:56.016]                   ...future.strategy.old <- future::plan("list")
[17:43:56.016]                   options(future.plan = NULL)
[17:43:56.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.016]                 }
[17:43:56.016]                 ...future.workdir <- getwd()
[17:43:56.016]             }
[17:43:56.016]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.016]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.016]         }
[17:43:56.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.016]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.016]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.016]             base::names(...future.oldOptions))
[17:43:56.016]     }
[17:43:56.016]     if (FALSE) {
[17:43:56.016]     }
[17:43:56.016]     else {
[17:43:56.016]         if (TRUE) {
[17:43:56.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.016]                 open = "w")
[17:43:56.016]         }
[17:43:56.016]         else {
[17:43:56.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.016]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.016]         }
[17:43:56.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.016]             base::sink(type = "output", split = FALSE)
[17:43:56.016]             base::close(...future.stdout)
[17:43:56.016]         }, add = TRUE)
[17:43:56.016]     }
[17:43:56.016]     ...future.frame <- base::sys.nframe()
[17:43:56.016]     ...future.conditions <- base::list()
[17:43:56.016]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.016]     if (FALSE) {
[17:43:56.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.016]     }
[17:43:56.016]     ...future.result <- base::tryCatch({
[17:43:56.016]         base::withCallingHandlers({
[17:43:56.016]             ...future.value <- base::withVisible(base::local({
[17:43:56.016]                 withCallingHandlers({
[17:43:56.016]                   {
[17:43:56.016]                     do.call(function(...) {
[17:43:56.016]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.016]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.016]                         ...future.globals.maxSize)) {
[17:43:56.016]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.016]                         on.exit(options(oopts), add = TRUE)
[17:43:56.016]                       }
[17:43:56.016]                       {
[17:43:56.016]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.016]                           FUN = function(jj) {
[17:43:56.016]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.016]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.016]                           })
[17:43:56.016]                       }
[17:43:56.016]                     }, args = future.call.arguments)
[17:43:56.016]                   }
[17:43:56.016]                 }, immediateCondition = function(cond) {
[17:43:56.016]                   save_rds <- function (object, pathname, ...) 
[17:43:56.016]                   {
[17:43:56.016]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:56.016]                     if (file_test("-f", pathname_tmp)) {
[17:43:56.016]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.016]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:56.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.016]                         fi_tmp[["mtime"]])
[17:43:56.016]                     }
[17:43:56.016]                     tryCatch({
[17:43:56.016]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:56.016]                     }, error = function(ex) {
[17:43:56.016]                       msg <- conditionMessage(ex)
[17:43:56.016]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.016]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:56.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.016]                         fi_tmp[["mtime"]], msg)
[17:43:56.016]                       ex$message <- msg
[17:43:56.016]                       stop(ex)
[17:43:56.016]                     })
[17:43:56.016]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:56.016]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:56.016]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:56.016]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.016]                       fi <- file.info(pathname)
[17:43:56.016]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:56.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.016]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:56.016]                         fi[["size"]], fi[["mtime"]])
[17:43:56.016]                       stop(msg)
[17:43:56.016]                     }
[17:43:56.016]                     invisible(pathname)
[17:43:56.016]                   }
[17:43:56.016]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:56.016]                     rootPath = tempdir()) 
[17:43:56.016]                   {
[17:43:56.016]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:56.016]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:56.016]                       tmpdir = path, fileext = ".rds")
[17:43:56.016]                     save_rds(obj, file)
[17:43:56.016]                   }
[17:43:56.016]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:56.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.016]                   {
[17:43:56.016]                     inherits <- base::inherits
[17:43:56.016]                     invokeRestart <- base::invokeRestart
[17:43:56.016]                     is.null <- base::is.null
[17:43:56.016]                     muffled <- FALSE
[17:43:56.016]                     if (inherits(cond, "message")) {
[17:43:56.016]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.016]                       if (muffled) 
[17:43:56.016]                         invokeRestart("muffleMessage")
[17:43:56.016]                     }
[17:43:56.016]                     else if (inherits(cond, "warning")) {
[17:43:56.016]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.016]                       if (muffled) 
[17:43:56.016]                         invokeRestart("muffleWarning")
[17:43:56.016]                     }
[17:43:56.016]                     else if (inherits(cond, "condition")) {
[17:43:56.016]                       if (!is.null(pattern)) {
[17:43:56.016]                         computeRestarts <- base::computeRestarts
[17:43:56.016]                         grepl <- base::grepl
[17:43:56.016]                         restarts <- computeRestarts(cond)
[17:43:56.016]                         for (restart in restarts) {
[17:43:56.016]                           name <- restart$name
[17:43:56.016]                           if (is.null(name)) 
[17:43:56.016]                             next
[17:43:56.016]                           if (!grepl(pattern, name)) 
[17:43:56.016]                             next
[17:43:56.016]                           invokeRestart(restart)
[17:43:56.016]                           muffled <- TRUE
[17:43:56.016]                           break
[17:43:56.016]                         }
[17:43:56.016]                       }
[17:43:56.016]                     }
[17:43:56.016]                     invisible(muffled)
[17:43:56.016]                   }
[17:43:56.016]                   muffleCondition(cond)
[17:43:56.016]                 })
[17:43:56.016]             }))
[17:43:56.016]             future::FutureResult(value = ...future.value$value, 
[17:43:56.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.016]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.016]                     ...future.globalenv.names))
[17:43:56.016]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.016]         }, condition = base::local({
[17:43:56.016]             c <- base::c
[17:43:56.016]             inherits <- base::inherits
[17:43:56.016]             invokeRestart <- base::invokeRestart
[17:43:56.016]             length <- base::length
[17:43:56.016]             list <- base::list
[17:43:56.016]             seq.int <- base::seq.int
[17:43:56.016]             signalCondition <- base::signalCondition
[17:43:56.016]             sys.calls <- base::sys.calls
[17:43:56.016]             `[[` <- base::`[[`
[17:43:56.016]             `+` <- base::`+`
[17:43:56.016]             `<<-` <- base::`<<-`
[17:43:56.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.016]                   3L)]
[17:43:56.016]             }
[17:43:56.016]             function(cond) {
[17:43:56.016]                 is_error <- inherits(cond, "error")
[17:43:56.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.016]                   NULL)
[17:43:56.016]                 if (is_error) {
[17:43:56.016]                   sessionInformation <- function() {
[17:43:56.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.016]                       search = base::search(), system = base::Sys.info())
[17:43:56.016]                   }
[17:43:56.016]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.016]                     cond$call), session = sessionInformation(), 
[17:43:56.016]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.016]                   signalCondition(cond)
[17:43:56.016]                 }
[17:43:56.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.016]                 "immediateCondition"))) {
[17:43:56.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.016]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.016]                   if (TRUE && !signal) {
[17:43:56.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.016]                     {
[17:43:56.016]                       inherits <- base::inherits
[17:43:56.016]                       invokeRestart <- base::invokeRestart
[17:43:56.016]                       is.null <- base::is.null
[17:43:56.016]                       muffled <- FALSE
[17:43:56.016]                       if (inherits(cond, "message")) {
[17:43:56.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.016]                         if (muffled) 
[17:43:56.016]                           invokeRestart("muffleMessage")
[17:43:56.016]                       }
[17:43:56.016]                       else if (inherits(cond, "warning")) {
[17:43:56.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.016]                         if (muffled) 
[17:43:56.016]                           invokeRestart("muffleWarning")
[17:43:56.016]                       }
[17:43:56.016]                       else if (inherits(cond, "condition")) {
[17:43:56.016]                         if (!is.null(pattern)) {
[17:43:56.016]                           computeRestarts <- base::computeRestarts
[17:43:56.016]                           grepl <- base::grepl
[17:43:56.016]                           restarts <- computeRestarts(cond)
[17:43:56.016]                           for (restart in restarts) {
[17:43:56.016]                             name <- restart$name
[17:43:56.016]                             if (is.null(name)) 
[17:43:56.016]                               next
[17:43:56.016]                             if (!grepl(pattern, name)) 
[17:43:56.016]                               next
[17:43:56.016]                             invokeRestart(restart)
[17:43:56.016]                             muffled <- TRUE
[17:43:56.016]                             break
[17:43:56.016]                           }
[17:43:56.016]                         }
[17:43:56.016]                       }
[17:43:56.016]                       invisible(muffled)
[17:43:56.016]                     }
[17:43:56.016]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.016]                   }
[17:43:56.016]                 }
[17:43:56.016]                 else {
[17:43:56.016]                   if (TRUE) {
[17:43:56.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.016]                     {
[17:43:56.016]                       inherits <- base::inherits
[17:43:56.016]                       invokeRestart <- base::invokeRestart
[17:43:56.016]                       is.null <- base::is.null
[17:43:56.016]                       muffled <- FALSE
[17:43:56.016]                       if (inherits(cond, "message")) {
[17:43:56.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.016]                         if (muffled) 
[17:43:56.016]                           invokeRestart("muffleMessage")
[17:43:56.016]                       }
[17:43:56.016]                       else if (inherits(cond, "warning")) {
[17:43:56.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.016]                         if (muffled) 
[17:43:56.016]                           invokeRestart("muffleWarning")
[17:43:56.016]                       }
[17:43:56.016]                       else if (inherits(cond, "condition")) {
[17:43:56.016]                         if (!is.null(pattern)) {
[17:43:56.016]                           computeRestarts <- base::computeRestarts
[17:43:56.016]                           grepl <- base::grepl
[17:43:56.016]                           restarts <- computeRestarts(cond)
[17:43:56.016]                           for (restart in restarts) {
[17:43:56.016]                             name <- restart$name
[17:43:56.016]                             if (is.null(name)) 
[17:43:56.016]                               next
[17:43:56.016]                             if (!grepl(pattern, name)) 
[17:43:56.016]                               next
[17:43:56.016]                             invokeRestart(restart)
[17:43:56.016]                             muffled <- TRUE
[17:43:56.016]                             break
[17:43:56.016]                           }
[17:43:56.016]                         }
[17:43:56.016]                       }
[17:43:56.016]                       invisible(muffled)
[17:43:56.016]                     }
[17:43:56.016]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.016]                   }
[17:43:56.016]                 }
[17:43:56.016]             }
[17:43:56.016]         }))
[17:43:56.016]     }, error = function(ex) {
[17:43:56.016]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.016]                 ...future.rng), started = ...future.startTime, 
[17:43:56.016]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.016]             version = "1.8"), class = "FutureResult")
[17:43:56.016]     }, finally = {
[17:43:56.016]         if (!identical(...future.workdir, getwd())) 
[17:43:56.016]             setwd(...future.workdir)
[17:43:56.016]         {
[17:43:56.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.016]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.016]             }
[17:43:56.016]             base::options(...future.oldOptions)
[17:43:56.016]             if (.Platform$OS.type == "windows") {
[17:43:56.016]                 old_names <- names(...future.oldEnvVars)
[17:43:56.016]                 envs <- base::Sys.getenv()
[17:43:56.016]                 names <- names(envs)
[17:43:56.016]                 common <- intersect(names, old_names)
[17:43:56.016]                 added <- setdiff(names, old_names)
[17:43:56.016]                 removed <- setdiff(old_names, names)
[17:43:56.016]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.016]                   envs[common]]
[17:43:56.016]                 NAMES <- toupper(changed)
[17:43:56.016]                 args <- list()
[17:43:56.016]                 for (kk in seq_along(NAMES)) {
[17:43:56.016]                   name <- changed[[kk]]
[17:43:56.016]                   NAME <- NAMES[[kk]]
[17:43:56.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.016]                     next
[17:43:56.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.016]                 }
[17:43:56.016]                 NAMES <- toupper(added)
[17:43:56.016]                 for (kk in seq_along(NAMES)) {
[17:43:56.016]                   name <- added[[kk]]
[17:43:56.016]                   NAME <- NAMES[[kk]]
[17:43:56.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.016]                     next
[17:43:56.016]                   args[[name]] <- ""
[17:43:56.016]                 }
[17:43:56.016]                 NAMES <- toupper(removed)
[17:43:56.016]                 for (kk in seq_along(NAMES)) {
[17:43:56.016]                   name <- removed[[kk]]
[17:43:56.016]                   NAME <- NAMES[[kk]]
[17:43:56.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.016]                     next
[17:43:56.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.016]                 }
[17:43:56.016]                 if (length(args) > 0) 
[17:43:56.016]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.016]             }
[17:43:56.016]             else {
[17:43:56.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.016]             }
[17:43:56.016]             {
[17:43:56.016]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.016]                   0L) {
[17:43:56.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.016]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.016]                   base::options(opts)
[17:43:56.016]                 }
[17:43:56.016]                 {
[17:43:56.016]                   {
[17:43:56.016]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.016]                     NULL
[17:43:56.016]                   }
[17:43:56.016]                   options(future.plan = NULL)
[17:43:56.016]                   if (is.na(NA_character_)) 
[17:43:56.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.016]                     .init = FALSE)
[17:43:56.016]                 }
[17:43:56.016]             }
[17:43:56.016]         }
[17:43:56.016]     })
[17:43:56.016]     if (TRUE) {
[17:43:56.016]         base::sink(type = "output", split = FALSE)
[17:43:56.016]         if (TRUE) {
[17:43:56.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.016]         }
[17:43:56.016]         else {
[17:43:56.016]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.016]         }
[17:43:56.016]         base::close(...future.stdout)
[17:43:56.016]         ...future.stdout <- NULL
[17:43:56.016]     }
[17:43:56.016]     ...future.result$conditions <- ...future.conditions
[17:43:56.016]     ...future.result$finished <- base::Sys.time()
[17:43:56.016]     ...future.result
[17:43:56.016] }
[17:43:56.018] assign_globals() ...
[17:43:56.019] List of 5
[17:43:56.019]  $ ...future.FUN            :function (x, ...)  
[17:43:56.019]  $ future.call.arguments    :List of 1
[17:43:56.019]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:56.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.019]  $ ...future.elements_ii    :List of 1
[17:43:56.019]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:43:56.019]  $ ...future.seeds_ii       : NULL
[17:43:56.019]  $ ...future.globals.maxSize: NULL
[17:43:56.019]  - attr(*, "where")=List of 5
[17:43:56.019]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:56.019]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:56.019]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:56.019]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:56.019]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:56.019]  - attr(*, "resolved")= logi FALSE
[17:43:56.019]  - attr(*, "total_size")= num 1328
[17:43:56.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.019]  - attr(*, "already-done")= logi TRUE
[17:43:56.023] - copied ‘...future.FUN’ to environment
[17:43:56.024] - copied ‘future.call.arguments’ to environment
[17:43:56.024] - copied ‘...future.elements_ii’ to environment
[17:43:56.024] - copied ‘...future.seeds_ii’ to environment
[17:43:56.024] - copied ‘...future.globals.maxSize’ to environment
[17:43:56.024] assign_globals() ... done
[17:43:56.024] requestCore(): workers = 2
[17:43:56.026] MulticoreFuture started
[17:43:56.027] - Launch lazy future ... done
[17:43:56.027] run() for ‘MulticoreFuture’ ... done
[17:43:56.027] Created future:
[17:43:56.028] plan(): Setting new future strategy stack:
[17:43:56.028] List of future strategies:
[17:43:56.028] 1. sequential:
[17:43:56.028]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.028]    - tweaked: FALSE
[17:43:56.028]    - call: NULL
[17:43:56.029] plan(): nbrOfWorkers() = 1
[17:43:56.031] plan(): Setting new future strategy stack:
[17:43:56.031] List of future strategies:
[17:43:56.031] 1. multicore:
[17:43:56.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:56.031]    - tweaked: FALSE
[17:43:56.031]    - call: plan(strategy)
[17:43:56.036] plan(): nbrOfWorkers() = 2
[17:43:56.027] MulticoreFuture:
[17:43:56.027] Label: ‘future_eapply-1’
[17:43:56.027] Expression:
[17:43:56.027] {
[17:43:56.027]     do.call(function(...) {
[17:43:56.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.027]             on.exit(options(oopts), add = TRUE)
[17:43:56.027]         }
[17:43:56.027]         {
[17:43:56.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.027]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.027]             })
[17:43:56.027]         }
[17:43:56.027]     }, args = future.call.arguments)
[17:43:56.027] }
[17:43:56.027] Lazy evaluation: FALSE
[17:43:56.027] Asynchronous evaluation: TRUE
[17:43:56.027] Local evaluation: TRUE
[17:43:56.027] Environment: R_GlobalEnv
[17:43:56.027] Capture standard output: TRUE
[17:43:56.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.027] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.027] Packages: 1 packages (‘stats’)
[17:43:56.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.027] Resolved: TRUE
[17:43:56.027] Value: <not collected>
[17:43:56.027] Conditions captured: <none>
[17:43:56.027] Early signaling: FALSE
[17:43:56.027] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.027] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.037] Chunk #1 of 2 ... DONE
[17:43:56.037] Chunk #2 of 2 ...
[17:43:56.038]  - Finding globals in 'X' for chunk #2 ...
[17:43:56.038] getGlobalsAndPackages() ...
[17:43:56.038] Searching for globals...
[17:43:56.038] 
[17:43:56.038] Searching for globals ... DONE
[17:43:56.038] - globals: [0] <none>
[17:43:56.039] getGlobalsAndPackages() ... DONE
[17:43:56.039]    + additional globals found: [n=0] 
[17:43:56.039]    + additional namespaces needed: [n=0] 
[17:43:56.039]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:56.039]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.039]  - seeds: <none>
[17:43:56.039]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.040] getGlobalsAndPackages() ...
[17:43:56.040] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.040] Resolving globals: FALSE
[17:43:56.040] Tweak future expression to call with '...' arguments ...
[17:43:56.040] {
[17:43:56.040]     do.call(function(...) {
[17:43:56.040]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.040]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.040]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.040]             on.exit(options(oopts), add = TRUE)
[17:43:56.040]         }
[17:43:56.040]         {
[17:43:56.040]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.040]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.040]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.040]             })
[17:43:56.040]         }
[17:43:56.040]     }, args = future.call.arguments)
[17:43:56.040] }
[17:43:56.041] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.041] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.041] - packages: [1] ‘stats’
[17:43:56.042] getGlobalsAndPackages() ... DONE
[17:43:56.042] run() for ‘Future’ ...
[17:43:56.042] - state: ‘created’
[17:43:56.042] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.047] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.047] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:56.047]   - Field: ‘label’
[17:43:56.047]   - Field: ‘local’
[17:43:56.047]   - Field: ‘owner’
[17:43:56.047]   - Field: ‘envir’
[17:43:56.048]   - Field: ‘workers’
[17:43:56.048]   - Field: ‘packages’
[17:43:56.048]   - Field: ‘gc’
[17:43:56.048]   - Field: ‘job’
[17:43:56.048]   - Field: ‘conditions’
[17:43:56.048]   - Field: ‘expr’
[17:43:56.048]   - Field: ‘uuid’
[17:43:56.049]   - Field: ‘seed’
[17:43:56.049]   - Field: ‘version’
[17:43:56.049]   - Field: ‘result’
[17:43:56.049]   - Field: ‘asynchronous’
[17:43:56.049]   - Field: ‘calls’
[17:43:56.049]   - Field: ‘globals’
[17:43:56.049]   - Field: ‘stdout’
[17:43:56.049]   - Field: ‘earlySignal’
[17:43:56.050]   - Field: ‘lazy’
[17:43:56.050]   - Field: ‘state’
[17:43:56.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:56.050] - Launch lazy future ...
[17:43:56.050] Packages needed by the future expression (n = 1): ‘stats’
[17:43:56.051] Packages needed by future strategies (n = 0): <none>
[17:43:56.051] {
[17:43:56.051]     {
[17:43:56.051]         {
[17:43:56.051]             ...future.startTime <- base::Sys.time()
[17:43:56.051]             {
[17:43:56.051]                 {
[17:43:56.051]                   {
[17:43:56.051]                     {
[17:43:56.051]                       {
[17:43:56.051]                         base::local({
[17:43:56.051]                           has_future <- base::requireNamespace("future", 
[17:43:56.051]                             quietly = TRUE)
[17:43:56.051]                           if (has_future) {
[17:43:56.051]                             ns <- base::getNamespace("future")
[17:43:56.051]                             version <- ns[[".package"]][["version"]]
[17:43:56.051]                             if (is.null(version)) 
[17:43:56.051]                               version <- utils::packageVersion("future")
[17:43:56.051]                           }
[17:43:56.051]                           else {
[17:43:56.051]                             version <- NULL
[17:43:56.051]                           }
[17:43:56.051]                           if (!has_future || version < "1.8.0") {
[17:43:56.051]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.051]                               "", base::R.version$version.string), 
[17:43:56.051]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:56.051]                                 base::R.version$platform, 8 * 
[17:43:56.051]                                   base::.Machine$sizeof.pointer), 
[17:43:56.051]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.051]                                 "release", "version")], collapse = " "), 
[17:43:56.051]                               hostname = base::Sys.info()[["nodename"]])
[17:43:56.051]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.051]                               info)
[17:43:56.051]                             info <- base::paste(info, collapse = "; ")
[17:43:56.051]                             if (!has_future) {
[17:43:56.051]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.051]                                 info)
[17:43:56.051]                             }
[17:43:56.051]                             else {
[17:43:56.051]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.051]                                 info, version)
[17:43:56.051]                             }
[17:43:56.051]                             base::stop(msg)
[17:43:56.051]                           }
[17:43:56.051]                         })
[17:43:56.051]                       }
[17:43:56.051]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.051]                       base::options(mc.cores = 1L)
[17:43:56.051]                     }
[17:43:56.051]                     base::local({
[17:43:56.051]                       for (pkg in "stats") {
[17:43:56.051]                         base::loadNamespace(pkg)
[17:43:56.051]                         base::library(pkg, character.only = TRUE)
[17:43:56.051]                       }
[17:43:56.051]                     })
[17:43:56.051]                   }
[17:43:56.051]                   ...future.strategy.old <- future::plan("list")
[17:43:56.051]                   options(future.plan = NULL)
[17:43:56.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.051]                 }
[17:43:56.051]                 ...future.workdir <- getwd()
[17:43:56.051]             }
[17:43:56.051]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.051]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.051]         }
[17:43:56.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.051]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.051]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.051]             base::names(...future.oldOptions))
[17:43:56.051]     }
[17:43:56.051]     if (FALSE) {
[17:43:56.051]     }
[17:43:56.051]     else {
[17:43:56.051]         if (TRUE) {
[17:43:56.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.051]                 open = "w")
[17:43:56.051]         }
[17:43:56.051]         else {
[17:43:56.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.051]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.051]         }
[17:43:56.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.051]             base::sink(type = "output", split = FALSE)
[17:43:56.051]             base::close(...future.stdout)
[17:43:56.051]         }, add = TRUE)
[17:43:56.051]     }
[17:43:56.051]     ...future.frame <- base::sys.nframe()
[17:43:56.051]     ...future.conditions <- base::list()
[17:43:56.051]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.051]     if (FALSE) {
[17:43:56.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.051]     }
[17:43:56.051]     ...future.result <- base::tryCatch({
[17:43:56.051]         base::withCallingHandlers({
[17:43:56.051]             ...future.value <- base::withVisible(base::local({
[17:43:56.051]                 withCallingHandlers({
[17:43:56.051]                   {
[17:43:56.051]                     do.call(function(...) {
[17:43:56.051]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.051]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.051]                         ...future.globals.maxSize)) {
[17:43:56.051]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.051]                         on.exit(options(oopts), add = TRUE)
[17:43:56.051]                       }
[17:43:56.051]                       {
[17:43:56.051]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.051]                           FUN = function(jj) {
[17:43:56.051]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.051]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.051]                           })
[17:43:56.051]                       }
[17:43:56.051]                     }, args = future.call.arguments)
[17:43:56.051]                   }
[17:43:56.051]                 }, immediateCondition = function(cond) {
[17:43:56.051]                   save_rds <- function (object, pathname, ...) 
[17:43:56.051]                   {
[17:43:56.051]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:56.051]                     if (file_test("-f", pathname_tmp)) {
[17:43:56.051]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.051]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:56.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.051]                         fi_tmp[["mtime"]])
[17:43:56.051]                     }
[17:43:56.051]                     tryCatch({
[17:43:56.051]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:56.051]                     }, error = function(ex) {
[17:43:56.051]                       msg <- conditionMessage(ex)
[17:43:56.051]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.051]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:56.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.051]                         fi_tmp[["mtime"]], msg)
[17:43:56.051]                       ex$message <- msg
[17:43:56.051]                       stop(ex)
[17:43:56.051]                     })
[17:43:56.051]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:56.051]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:56.051]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:56.051]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.051]                       fi <- file.info(pathname)
[17:43:56.051]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:56.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.051]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:56.051]                         fi[["size"]], fi[["mtime"]])
[17:43:56.051]                       stop(msg)
[17:43:56.051]                     }
[17:43:56.051]                     invisible(pathname)
[17:43:56.051]                   }
[17:43:56.051]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:56.051]                     rootPath = tempdir()) 
[17:43:56.051]                   {
[17:43:56.051]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:56.051]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:56.051]                       tmpdir = path, fileext = ".rds")
[17:43:56.051]                     save_rds(obj, file)
[17:43:56.051]                   }
[17:43:56.051]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:56.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.051]                   {
[17:43:56.051]                     inherits <- base::inherits
[17:43:56.051]                     invokeRestart <- base::invokeRestart
[17:43:56.051]                     is.null <- base::is.null
[17:43:56.051]                     muffled <- FALSE
[17:43:56.051]                     if (inherits(cond, "message")) {
[17:43:56.051]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.051]                       if (muffled) 
[17:43:56.051]                         invokeRestart("muffleMessage")
[17:43:56.051]                     }
[17:43:56.051]                     else if (inherits(cond, "warning")) {
[17:43:56.051]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.051]                       if (muffled) 
[17:43:56.051]                         invokeRestart("muffleWarning")
[17:43:56.051]                     }
[17:43:56.051]                     else if (inherits(cond, "condition")) {
[17:43:56.051]                       if (!is.null(pattern)) {
[17:43:56.051]                         computeRestarts <- base::computeRestarts
[17:43:56.051]                         grepl <- base::grepl
[17:43:56.051]                         restarts <- computeRestarts(cond)
[17:43:56.051]                         for (restart in restarts) {
[17:43:56.051]                           name <- restart$name
[17:43:56.051]                           if (is.null(name)) 
[17:43:56.051]                             next
[17:43:56.051]                           if (!grepl(pattern, name)) 
[17:43:56.051]                             next
[17:43:56.051]                           invokeRestart(restart)
[17:43:56.051]                           muffled <- TRUE
[17:43:56.051]                           break
[17:43:56.051]                         }
[17:43:56.051]                       }
[17:43:56.051]                     }
[17:43:56.051]                     invisible(muffled)
[17:43:56.051]                   }
[17:43:56.051]                   muffleCondition(cond)
[17:43:56.051]                 })
[17:43:56.051]             }))
[17:43:56.051]             future::FutureResult(value = ...future.value$value, 
[17:43:56.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.051]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.051]                     ...future.globalenv.names))
[17:43:56.051]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.051]         }, condition = base::local({
[17:43:56.051]             c <- base::c
[17:43:56.051]             inherits <- base::inherits
[17:43:56.051]             invokeRestart <- base::invokeRestart
[17:43:56.051]             length <- base::length
[17:43:56.051]             list <- base::list
[17:43:56.051]             seq.int <- base::seq.int
[17:43:56.051]             signalCondition <- base::signalCondition
[17:43:56.051]             sys.calls <- base::sys.calls
[17:43:56.051]             `[[` <- base::`[[`
[17:43:56.051]             `+` <- base::`+`
[17:43:56.051]             `<<-` <- base::`<<-`
[17:43:56.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.051]                   3L)]
[17:43:56.051]             }
[17:43:56.051]             function(cond) {
[17:43:56.051]                 is_error <- inherits(cond, "error")
[17:43:56.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.051]                   NULL)
[17:43:56.051]                 if (is_error) {
[17:43:56.051]                   sessionInformation <- function() {
[17:43:56.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.051]                       search = base::search(), system = base::Sys.info())
[17:43:56.051]                   }
[17:43:56.051]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.051]                     cond$call), session = sessionInformation(), 
[17:43:56.051]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.051]                   signalCondition(cond)
[17:43:56.051]                 }
[17:43:56.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.051]                 "immediateCondition"))) {
[17:43:56.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.051]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.051]                   if (TRUE && !signal) {
[17:43:56.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.051]                     {
[17:43:56.051]                       inherits <- base::inherits
[17:43:56.051]                       invokeRestart <- base::invokeRestart
[17:43:56.051]                       is.null <- base::is.null
[17:43:56.051]                       muffled <- FALSE
[17:43:56.051]                       if (inherits(cond, "message")) {
[17:43:56.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.051]                         if (muffled) 
[17:43:56.051]                           invokeRestart("muffleMessage")
[17:43:56.051]                       }
[17:43:56.051]                       else if (inherits(cond, "warning")) {
[17:43:56.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.051]                         if (muffled) 
[17:43:56.051]                           invokeRestart("muffleWarning")
[17:43:56.051]                       }
[17:43:56.051]                       else if (inherits(cond, "condition")) {
[17:43:56.051]                         if (!is.null(pattern)) {
[17:43:56.051]                           computeRestarts <- base::computeRestarts
[17:43:56.051]                           grepl <- base::grepl
[17:43:56.051]                           restarts <- computeRestarts(cond)
[17:43:56.051]                           for (restart in restarts) {
[17:43:56.051]                             name <- restart$name
[17:43:56.051]                             if (is.null(name)) 
[17:43:56.051]                               next
[17:43:56.051]                             if (!grepl(pattern, name)) 
[17:43:56.051]                               next
[17:43:56.051]                             invokeRestart(restart)
[17:43:56.051]                             muffled <- TRUE
[17:43:56.051]                             break
[17:43:56.051]                           }
[17:43:56.051]                         }
[17:43:56.051]                       }
[17:43:56.051]                       invisible(muffled)
[17:43:56.051]                     }
[17:43:56.051]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.051]                   }
[17:43:56.051]                 }
[17:43:56.051]                 else {
[17:43:56.051]                   if (TRUE) {
[17:43:56.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.051]                     {
[17:43:56.051]                       inherits <- base::inherits
[17:43:56.051]                       invokeRestart <- base::invokeRestart
[17:43:56.051]                       is.null <- base::is.null
[17:43:56.051]                       muffled <- FALSE
[17:43:56.051]                       if (inherits(cond, "message")) {
[17:43:56.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.051]                         if (muffled) 
[17:43:56.051]                           invokeRestart("muffleMessage")
[17:43:56.051]                       }
[17:43:56.051]                       else if (inherits(cond, "warning")) {
[17:43:56.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.051]                         if (muffled) 
[17:43:56.051]                           invokeRestart("muffleWarning")
[17:43:56.051]                       }
[17:43:56.051]                       else if (inherits(cond, "condition")) {
[17:43:56.051]                         if (!is.null(pattern)) {
[17:43:56.051]                           computeRestarts <- base::computeRestarts
[17:43:56.051]                           grepl <- base::grepl
[17:43:56.051]                           restarts <- computeRestarts(cond)
[17:43:56.051]                           for (restart in restarts) {
[17:43:56.051]                             name <- restart$name
[17:43:56.051]                             if (is.null(name)) 
[17:43:56.051]                               next
[17:43:56.051]                             if (!grepl(pattern, name)) 
[17:43:56.051]                               next
[17:43:56.051]                             invokeRestart(restart)
[17:43:56.051]                             muffled <- TRUE
[17:43:56.051]                             break
[17:43:56.051]                           }
[17:43:56.051]                         }
[17:43:56.051]                       }
[17:43:56.051]                       invisible(muffled)
[17:43:56.051]                     }
[17:43:56.051]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.051]                   }
[17:43:56.051]                 }
[17:43:56.051]             }
[17:43:56.051]         }))
[17:43:56.051]     }, error = function(ex) {
[17:43:56.051]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.051]                 ...future.rng), started = ...future.startTime, 
[17:43:56.051]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.051]             version = "1.8"), class = "FutureResult")
[17:43:56.051]     }, finally = {
[17:43:56.051]         if (!identical(...future.workdir, getwd())) 
[17:43:56.051]             setwd(...future.workdir)
[17:43:56.051]         {
[17:43:56.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.051]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.051]             }
[17:43:56.051]             base::options(...future.oldOptions)
[17:43:56.051]             if (.Platform$OS.type == "windows") {
[17:43:56.051]                 old_names <- names(...future.oldEnvVars)
[17:43:56.051]                 envs <- base::Sys.getenv()
[17:43:56.051]                 names <- names(envs)
[17:43:56.051]                 common <- intersect(names, old_names)
[17:43:56.051]                 added <- setdiff(names, old_names)
[17:43:56.051]                 removed <- setdiff(old_names, names)
[17:43:56.051]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.051]                   envs[common]]
[17:43:56.051]                 NAMES <- toupper(changed)
[17:43:56.051]                 args <- list()
[17:43:56.051]                 for (kk in seq_along(NAMES)) {
[17:43:56.051]                   name <- changed[[kk]]
[17:43:56.051]                   NAME <- NAMES[[kk]]
[17:43:56.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.051]                     next
[17:43:56.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.051]                 }
[17:43:56.051]                 NAMES <- toupper(added)
[17:43:56.051]                 for (kk in seq_along(NAMES)) {
[17:43:56.051]                   name <- added[[kk]]
[17:43:56.051]                   NAME <- NAMES[[kk]]
[17:43:56.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.051]                     next
[17:43:56.051]                   args[[name]] <- ""
[17:43:56.051]                 }
[17:43:56.051]                 NAMES <- toupper(removed)
[17:43:56.051]                 for (kk in seq_along(NAMES)) {
[17:43:56.051]                   name <- removed[[kk]]
[17:43:56.051]                   NAME <- NAMES[[kk]]
[17:43:56.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.051]                     next
[17:43:56.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.051]                 }
[17:43:56.051]                 if (length(args) > 0) 
[17:43:56.051]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.051]             }
[17:43:56.051]             else {
[17:43:56.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.051]             }
[17:43:56.051]             {
[17:43:56.051]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.051]                   0L) {
[17:43:56.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.051]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.051]                   base::options(opts)
[17:43:56.051]                 }
[17:43:56.051]                 {
[17:43:56.051]                   {
[17:43:56.051]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.051]                     NULL
[17:43:56.051]                   }
[17:43:56.051]                   options(future.plan = NULL)
[17:43:56.051]                   if (is.na(NA_character_)) 
[17:43:56.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.051]                     .init = FALSE)
[17:43:56.051]                 }
[17:43:56.051]             }
[17:43:56.051]         }
[17:43:56.051]     })
[17:43:56.051]     if (TRUE) {
[17:43:56.051]         base::sink(type = "output", split = FALSE)
[17:43:56.051]         if (TRUE) {
[17:43:56.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.051]         }
[17:43:56.051]         else {
[17:43:56.051]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.051]         }
[17:43:56.051]         base::close(...future.stdout)
[17:43:56.051]         ...future.stdout <- NULL
[17:43:56.051]     }
[17:43:56.051]     ...future.result$conditions <- ...future.conditions
[17:43:56.051]     ...future.result$finished <- base::Sys.time()
[17:43:56.051]     ...future.result
[17:43:56.051] }
[17:43:56.054] assign_globals() ...
[17:43:56.055] List of 5
[17:43:56.055]  $ ...future.FUN            :function (x, ...)  
[17:43:56.055]  $ future.call.arguments    :List of 1
[17:43:56.055]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:56.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.055]  $ ...future.elements_ii    :List of 2
[17:43:56.055]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:56.055]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:56.055]  $ ...future.seeds_ii       : NULL
[17:43:56.055]  $ ...future.globals.maxSize: NULL
[17:43:56.055]  - attr(*, "where")=List of 5
[17:43:56.055]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:56.055]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:56.055]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:56.055]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:56.055]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:56.055]  - attr(*, "resolved")= logi FALSE
[17:43:56.055]  - attr(*, "total_size")= num 1328
[17:43:56.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.055]  - attr(*, "already-done")= logi TRUE
[17:43:56.066] - copied ‘...future.FUN’ to environment
[17:43:56.067] - copied ‘future.call.arguments’ to environment
[17:43:56.067] - copied ‘...future.elements_ii’ to environment
[17:43:56.067] - copied ‘...future.seeds_ii’ to environment
[17:43:56.067] - copied ‘...future.globals.maxSize’ to environment
[17:43:56.067] assign_globals() ... done
[17:43:56.067] requestCore(): workers = 2
[17:43:56.070] MulticoreFuture started
[17:43:56.070] - Launch lazy future ... done
[17:43:56.070] run() for ‘MulticoreFuture’ ... done
[17:43:56.070] Created future:
[17:43:56.071] plan(): Setting new future strategy stack:
[17:43:56.071] List of future strategies:
[17:43:56.071] 1. sequential:
[17:43:56.071]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.071]    - tweaked: FALSE
[17:43:56.071]    - call: NULL
[17:43:56.072] plan(): nbrOfWorkers() = 1
[17:43:56.075] plan(): Setting new future strategy stack:
[17:43:56.075] List of future strategies:
[17:43:56.075] 1. multicore:
[17:43:56.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:56.075]    - tweaked: FALSE
[17:43:56.075]    - call: plan(strategy)
[17:43:56.080] plan(): nbrOfWorkers() = 2
[17:43:56.071] MulticoreFuture:
[17:43:56.071] Label: ‘future_eapply-2’
[17:43:56.071] Expression:
[17:43:56.071] {
[17:43:56.071]     do.call(function(...) {
[17:43:56.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.071]             on.exit(options(oopts), add = TRUE)
[17:43:56.071]         }
[17:43:56.071]         {
[17:43:56.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.071]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.071]             })
[17:43:56.071]         }
[17:43:56.071]     }, args = future.call.arguments)
[17:43:56.071] }
[17:43:56.071] Lazy evaluation: FALSE
[17:43:56.071] Asynchronous evaluation: TRUE
[17:43:56.071] Local evaluation: TRUE
[17:43:56.071] Environment: R_GlobalEnv
[17:43:56.071] Capture standard output: TRUE
[17:43:56.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.071] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.071] Packages: 1 packages (‘stats’)
[17:43:56.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.071] Resolved: TRUE
[17:43:56.071] Value: <not collected>
[17:43:56.071] Conditions captured: <none>
[17:43:56.071] Early signaling: FALSE
[17:43:56.071] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.071] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.081] Chunk #2 of 2 ... DONE
[17:43:56.081] Launching 2 futures (chunks) ... DONE
[17:43:56.081] Resolving 2 futures (chunks) ...
[17:43:56.081] resolve() on list ...
[17:43:56.081]  recursive: 0
[17:43:56.082]  length: 2
[17:43:56.082] 
[17:43:56.082] Future #1
[17:43:56.082] result() for MulticoreFuture ...
[17:43:56.083] result() for MulticoreFuture ...
[17:43:56.083] result() for MulticoreFuture ... done
[17:43:56.084] result() for MulticoreFuture ... done
[17:43:56.084] result() for MulticoreFuture ...
[17:43:56.084] result() for MulticoreFuture ... done
[17:43:56.084] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:56.084] - nx: 2
[17:43:56.084] - relay: TRUE
[17:43:56.084] - stdout: TRUE
[17:43:56.085] - signal: TRUE
[17:43:56.085] - resignal: FALSE
[17:43:56.085] - force: TRUE
[17:43:56.085] - relayed: [n=2] FALSE, FALSE
[17:43:56.085] - queued futures: [n=2] FALSE, FALSE
[17:43:56.085]  - until=1
[17:43:56.085]  - relaying element #1
[17:43:56.086] result() for MulticoreFuture ...
[17:43:56.086] result() for MulticoreFuture ... done
[17:43:56.086] result() for MulticoreFuture ...
[17:43:56.086] result() for MulticoreFuture ... done
[17:43:56.086] result() for MulticoreFuture ...
[17:43:56.086] result() for MulticoreFuture ... done
[17:43:56.086] result() for MulticoreFuture ...
[17:43:56.087] result() for MulticoreFuture ... done
[17:43:56.087] - relayed: [n=2] TRUE, FALSE
[17:43:56.087] - queued futures: [n=2] TRUE, FALSE
[17:43:56.087] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:56.087]  length: 1 (resolved future 1)
[17:43:56.088] Future #2
[17:43:56.088] result() for MulticoreFuture ...
[17:43:56.088] result() for MulticoreFuture ...
[17:43:56.089] result() for MulticoreFuture ... done
[17:43:56.089] result() for MulticoreFuture ... done
[17:43:56.089] result() for MulticoreFuture ...
[17:43:56.089] result() for MulticoreFuture ... done
[17:43:56.089] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:56.089] - nx: 2
[17:43:56.089] - relay: TRUE
[17:43:56.090] - stdout: TRUE
[17:43:56.090] - signal: TRUE
[17:43:56.090] - resignal: FALSE
[17:43:56.090] - force: TRUE
[17:43:56.090] - relayed: [n=2] TRUE, FALSE
[17:43:56.090] - queued futures: [n=2] TRUE, FALSE
[17:43:56.090]  - until=2
[17:43:56.090]  - relaying element #2
[17:43:56.090] result() for MulticoreFuture ...
[17:43:56.091] result() for MulticoreFuture ... done
[17:43:56.091] result() for MulticoreFuture ...
[17:43:56.091] result() for MulticoreFuture ... done
[17:43:56.091] result() for MulticoreFuture ...
[17:43:56.091] result() for MulticoreFuture ... done
[17:43:56.091] result() for MulticoreFuture ...
[17:43:56.091] result() for MulticoreFuture ... done
[17:43:56.091] - relayed: [n=2] TRUE, TRUE
[17:43:56.092] - queued futures: [n=2] TRUE, TRUE
[17:43:56.092] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:56.092]  length: 0 (resolved future 2)
[17:43:56.092] Relaying remaining futures
[17:43:56.092] signalConditionsASAP(NULL, pos=0) ...
[17:43:56.092] - nx: 2
[17:43:56.092] - relay: TRUE
[17:43:56.092] - stdout: TRUE
[17:43:56.092] - signal: TRUE
[17:43:56.092] - resignal: FALSE
[17:43:56.093] - force: TRUE
[17:43:56.093] - relayed: [n=2] TRUE, TRUE
[17:43:56.093] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:56.093] - relayed: [n=2] TRUE, TRUE
[17:43:56.093] - queued futures: [n=2] TRUE, TRUE
[17:43:56.093] signalConditionsASAP(NULL, pos=0) ... done
[17:43:56.093] resolve() on list ... DONE
[17:43:56.093] result() for MulticoreFuture ...
[17:43:56.093] result() for MulticoreFuture ... done
[17:43:56.094] result() for MulticoreFuture ...
[17:43:56.094] result() for MulticoreFuture ... done
[17:43:56.094] result() for MulticoreFuture ...
[17:43:56.094] result() for MulticoreFuture ... done
[17:43:56.094] result() for MulticoreFuture ...
[17:43:56.094] result() for MulticoreFuture ... done
[17:43:56.094]  - Number of value chunks collected: 2
[17:43:56.094] Resolving 2 futures (chunks) ... DONE
[17:43:56.094] Reducing values from 2 chunks ...
[17:43:56.095]  - Number of values collected after concatenation: 3
[17:43:56.095]  - Number of values expected: 3
[17:43:56.095] Reducing values from 2 chunks ... DONE
[17:43:56.095] future_lapply() ... DONE
[17:43:56.096] future_lapply() ...
[17:43:56.100] Number of chunks: 2
[17:43:56.101] getGlobalsAndPackagesXApply() ...
[17:43:56.101]  - future.globals: TRUE
[17:43:56.101] getGlobalsAndPackages() ...
[17:43:56.101] Searching for globals...
[17:43:56.102] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:56.102] Searching for globals ... DONE
[17:43:56.102] Resolving globals: FALSE
[17:43:56.103] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:56.103] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:56.103] - globals: [1] ‘FUN’
[17:43:56.104] - packages: [1] ‘stats’
[17:43:56.104] getGlobalsAndPackages() ... DONE
[17:43:56.104]  - globals found/used: [n=1] ‘FUN’
[17:43:56.104]  - needed namespaces: [n=1] ‘stats’
[17:43:56.104] Finding globals ... DONE
[17:43:56.104]  - use_args: TRUE
[17:43:56.106]  - Getting '...' globals ...
[17:43:56.107] resolve() on list ...
[17:43:56.107]  recursive: 0
[17:43:56.107]  length: 1
[17:43:56.107]  elements: ‘...’
[17:43:56.107]  length: 0 (resolved future 1)
[17:43:56.107] resolve() on list ... DONE
[17:43:56.107]    - '...' content: [n=0] 
[17:43:56.108] List of 1
[17:43:56.108]  $ ...: list()
[17:43:56.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.108]  - attr(*, "where")=List of 1
[17:43:56.108]   ..$ ...:<environment: 0x55813e32b4c8> 
[17:43:56.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.108]  - attr(*, "resolved")= logi TRUE
[17:43:56.108]  - attr(*, "total_size")= num NA
[17:43:56.111]  - Getting '...' globals ... DONE
[17:43:56.111] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:56.111] List of 2
[17:43:56.111]  $ ...future.FUN:function (x, ...)  
[17:43:56.111]  $ ...          : list()
[17:43:56.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.111]  - attr(*, "where")=List of 2
[17:43:56.111]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:56.111]   ..$ ...          :<environment: 0x55813e32b4c8> 
[17:43:56.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.111]  - attr(*, "resolved")= logi FALSE
[17:43:56.111]  - attr(*, "total_size")= num 1248
[17:43:56.114] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:56.114] getGlobalsAndPackagesXApply() ... DONE
[17:43:56.115] Number of futures (= number of chunks): 2
[17:43:56.115] Launching 2 futures (chunks) ...
[17:43:56.115] Chunk #1 of 2 ...
[17:43:56.115]  - Finding globals in 'X' for chunk #1 ...
[17:43:56.115] getGlobalsAndPackages() ...
[17:43:56.115] Searching for globals...
[17:43:56.116] 
[17:43:56.116] Searching for globals ... DONE
[17:43:56.116] - globals: [0] <none>
[17:43:56.116] getGlobalsAndPackages() ... DONE
[17:43:56.116]    + additional globals found: [n=0] 
[17:43:56.116]    + additional namespaces needed: [n=0] 
[17:43:56.116]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:56.116]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.116]  - seeds: <none>
[17:43:56.116]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.117] getGlobalsAndPackages() ...
[17:43:56.117] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.117] Resolving globals: FALSE
[17:43:56.117] Tweak future expression to call with '...' arguments ...
[17:43:56.117] {
[17:43:56.117]     do.call(function(...) {
[17:43:56.117]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.117]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.117]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.117]             on.exit(options(oopts), add = TRUE)
[17:43:56.117]         }
[17:43:56.117]         {
[17:43:56.117]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.117]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.117]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.117]             })
[17:43:56.117]         }
[17:43:56.117]     }, args = future.call.arguments)
[17:43:56.117] }
[17:43:56.117] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.118] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.118] - packages: [1] ‘stats’
[17:43:56.118] getGlobalsAndPackages() ... DONE
[17:43:56.118] run() for ‘Future’ ...
[17:43:56.118] - state: ‘created’
[17:43:56.118] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.122] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:56.123]   - Field: ‘label’
[17:43:56.123]   - Field: ‘local’
[17:43:56.123]   - Field: ‘owner’
[17:43:56.123]   - Field: ‘envir’
[17:43:56.123]   - Field: ‘workers’
[17:43:56.123]   - Field: ‘packages’
[17:43:56.123]   - Field: ‘gc’
[17:43:56.123]   - Field: ‘job’
[17:43:56.123]   - Field: ‘conditions’
[17:43:56.124]   - Field: ‘expr’
[17:43:56.124]   - Field: ‘uuid’
[17:43:56.124]   - Field: ‘seed’
[17:43:56.124]   - Field: ‘version’
[17:43:56.124]   - Field: ‘result’
[17:43:56.124]   - Field: ‘asynchronous’
[17:43:56.124]   - Field: ‘calls’
[17:43:56.124]   - Field: ‘globals’
[17:43:56.124]   - Field: ‘stdout’
[17:43:56.125]   - Field: ‘earlySignal’
[17:43:56.125]   - Field: ‘lazy’
[17:43:56.125]   - Field: ‘state’
[17:43:56.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:56.125] - Launch lazy future ...
[17:43:56.125] Packages needed by the future expression (n = 1): ‘stats’
[17:43:56.125] Packages needed by future strategies (n = 0): <none>
[17:43:56.126] {
[17:43:56.126]     {
[17:43:56.126]         {
[17:43:56.126]             ...future.startTime <- base::Sys.time()
[17:43:56.126]             {
[17:43:56.126]                 {
[17:43:56.126]                   {
[17:43:56.126]                     {
[17:43:56.126]                       {
[17:43:56.126]                         base::local({
[17:43:56.126]                           has_future <- base::requireNamespace("future", 
[17:43:56.126]                             quietly = TRUE)
[17:43:56.126]                           if (has_future) {
[17:43:56.126]                             ns <- base::getNamespace("future")
[17:43:56.126]                             version <- ns[[".package"]][["version"]]
[17:43:56.126]                             if (is.null(version)) 
[17:43:56.126]                               version <- utils::packageVersion("future")
[17:43:56.126]                           }
[17:43:56.126]                           else {
[17:43:56.126]                             version <- NULL
[17:43:56.126]                           }
[17:43:56.126]                           if (!has_future || version < "1.8.0") {
[17:43:56.126]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.126]                               "", base::R.version$version.string), 
[17:43:56.126]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:56.126]                                 base::R.version$platform, 8 * 
[17:43:56.126]                                   base::.Machine$sizeof.pointer), 
[17:43:56.126]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.126]                                 "release", "version")], collapse = " "), 
[17:43:56.126]                               hostname = base::Sys.info()[["nodename"]])
[17:43:56.126]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.126]                               info)
[17:43:56.126]                             info <- base::paste(info, collapse = "; ")
[17:43:56.126]                             if (!has_future) {
[17:43:56.126]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.126]                                 info)
[17:43:56.126]                             }
[17:43:56.126]                             else {
[17:43:56.126]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.126]                                 info, version)
[17:43:56.126]                             }
[17:43:56.126]                             base::stop(msg)
[17:43:56.126]                           }
[17:43:56.126]                         })
[17:43:56.126]                       }
[17:43:56.126]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.126]                       base::options(mc.cores = 1L)
[17:43:56.126]                     }
[17:43:56.126]                     base::local({
[17:43:56.126]                       for (pkg in "stats") {
[17:43:56.126]                         base::loadNamespace(pkg)
[17:43:56.126]                         base::library(pkg, character.only = TRUE)
[17:43:56.126]                       }
[17:43:56.126]                     })
[17:43:56.126]                   }
[17:43:56.126]                   ...future.strategy.old <- future::plan("list")
[17:43:56.126]                   options(future.plan = NULL)
[17:43:56.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.126]                 }
[17:43:56.126]                 ...future.workdir <- getwd()
[17:43:56.126]             }
[17:43:56.126]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.126]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.126]         }
[17:43:56.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.126]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.126]             base::names(...future.oldOptions))
[17:43:56.126]     }
[17:43:56.126]     if (FALSE) {
[17:43:56.126]     }
[17:43:56.126]     else {
[17:43:56.126]         if (TRUE) {
[17:43:56.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.126]                 open = "w")
[17:43:56.126]         }
[17:43:56.126]         else {
[17:43:56.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.126]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.126]         }
[17:43:56.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.126]             base::sink(type = "output", split = FALSE)
[17:43:56.126]             base::close(...future.stdout)
[17:43:56.126]         }, add = TRUE)
[17:43:56.126]     }
[17:43:56.126]     ...future.frame <- base::sys.nframe()
[17:43:56.126]     ...future.conditions <- base::list()
[17:43:56.126]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.126]     if (FALSE) {
[17:43:56.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.126]     }
[17:43:56.126]     ...future.result <- base::tryCatch({
[17:43:56.126]         base::withCallingHandlers({
[17:43:56.126]             ...future.value <- base::withVisible(base::local({
[17:43:56.126]                 withCallingHandlers({
[17:43:56.126]                   {
[17:43:56.126]                     do.call(function(...) {
[17:43:56.126]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.126]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.126]                         ...future.globals.maxSize)) {
[17:43:56.126]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.126]                         on.exit(options(oopts), add = TRUE)
[17:43:56.126]                       }
[17:43:56.126]                       {
[17:43:56.126]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.126]                           FUN = function(jj) {
[17:43:56.126]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.126]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.126]                           })
[17:43:56.126]                       }
[17:43:56.126]                     }, args = future.call.arguments)
[17:43:56.126]                   }
[17:43:56.126]                 }, immediateCondition = function(cond) {
[17:43:56.126]                   save_rds <- function (object, pathname, ...) 
[17:43:56.126]                   {
[17:43:56.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:56.126]                     if (file_test("-f", pathname_tmp)) {
[17:43:56.126]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:56.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.126]                         fi_tmp[["mtime"]])
[17:43:56.126]                     }
[17:43:56.126]                     tryCatch({
[17:43:56.126]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:56.126]                     }, error = function(ex) {
[17:43:56.126]                       msg <- conditionMessage(ex)
[17:43:56.126]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:56.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.126]                         fi_tmp[["mtime"]], msg)
[17:43:56.126]                       ex$message <- msg
[17:43:56.126]                       stop(ex)
[17:43:56.126]                     })
[17:43:56.126]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:56.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:56.126]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:56.126]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.126]                       fi <- file.info(pathname)
[17:43:56.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:56.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:56.126]                         fi[["size"]], fi[["mtime"]])
[17:43:56.126]                       stop(msg)
[17:43:56.126]                     }
[17:43:56.126]                     invisible(pathname)
[17:43:56.126]                   }
[17:43:56.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:56.126]                     rootPath = tempdir()) 
[17:43:56.126]                   {
[17:43:56.126]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:56.126]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:56.126]                       tmpdir = path, fileext = ".rds")
[17:43:56.126]                     save_rds(obj, file)
[17:43:56.126]                   }
[17:43:56.126]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:56.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.126]                   {
[17:43:56.126]                     inherits <- base::inherits
[17:43:56.126]                     invokeRestart <- base::invokeRestart
[17:43:56.126]                     is.null <- base::is.null
[17:43:56.126]                     muffled <- FALSE
[17:43:56.126]                     if (inherits(cond, "message")) {
[17:43:56.126]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.126]                       if (muffled) 
[17:43:56.126]                         invokeRestart("muffleMessage")
[17:43:56.126]                     }
[17:43:56.126]                     else if (inherits(cond, "warning")) {
[17:43:56.126]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.126]                       if (muffled) 
[17:43:56.126]                         invokeRestart("muffleWarning")
[17:43:56.126]                     }
[17:43:56.126]                     else if (inherits(cond, "condition")) {
[17:43:56.126]                       if (!is.null(pattern)) {
[17:43:56.126]                         computeRestarts <- base::computeRestarts
[17:43:56.126]                         grepl <- base::grepl
[17:43:56.126]                         restarts <- computeRestarts(cond)
[17:43:56.126]                         for (restart in restarts) {
[17:43:56.126]                           name <- restart$name
[17:43:56.126]                           if (is.null(name)) 
[17:43:56.126]                             next
[17:43:56.126]                           if (!grepl(pattern, name)) 
[17:43:56.126]                             next
[17:43:56.126]                           invokeRestart(restart)
[17:43:56.126]                           muffled <- TRUE
[17:43:56.126]                           break
[17:43:56.126]                         }
[17:43:56.126]                       }
[17:43:56.126]                     }
[17:43:56.126]                     invisible(muffled)
[17:43:56.126]                   }
[17:43:56.126]                   muffleCondition(cond)
[17:43:56.126]                 })
[17:43:56.126]             }))
[17:43:56.126]             future::FutureResult(value = ...future.value$value, 
[17:43:56.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.126]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.126]                     ...future.globalenv.names))
[17:43:56.126]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.126]         }, condition = base::local({
[17:43:56.126]             c <- base::c
[17:43:56.126]             inherits <- base::inherits
[17:43:56.126]             invokeRestart <- base::invokeRestart
[17:43:56.126]             length <- base::length
[17:43:56.126]             list <- base::list
[17:43:56.126]             seq.int <- base::seq.int
[17:43:56.126]             signalCondition <- base::signalCondition
[17:43:56.126]             sys.calls <- base::sys.calls
[17:43:56.126]             `[[` <- base::`[[`
[17:43:56.126]             `+` <- base::`+`
[17:43:56.126]             `<<-` <- base::`<<-`
[17:43:56.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.126]                   3L)]
[17:43:56.126]             }
[17:43:56.126]             function(cond) {
[17:43:56.126]                 is_error <- inherits(cond, "error")
[17:43:56.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.126]                   NULL)
[17:43:56.126]                 if (is_error) {
[17:43:56.126]                   sessionInformation <- function() {
[17:43:56.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.126]                       search = base::search(), system = base::Sys.info())
[17:43:56.126]                   }
[17:43:56.126]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.126]                     cond$call), session = sessionInformation(), 
[17:43:56.126]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.126]                   signalCondition(cond)
[17:43:56.126]                 }
[17:43:56.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.126]                 "immediateCondition"))) {
[17:43:56.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.126]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.126]                   if (TRUE && !signal) {
[17:43:56.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.126]                     {
[17:43:56.126]                       inherits <- base::inherits
[17:43:56.126]                       invokeRestart <- base::invokeRestart
[17:43:56.126]                       is.null <- base::is.null
[17:43:56.126]                       muffled <- FALSE
[17:43:56.126]                       if (inherits(cond, "message")) {
[17:43:56.126]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.126]                         if (muffled) 
[17:43:56.126]                           invokeRestart("muffleMessage")
[17:43:56.126]                       }
[17:43:56.126]                       else if (inherits(cond, "warning")) {
[17:43:56.126]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.126]                         if (muffled) 
[17:43:56.126]                           invokeRestart("muffleWarning")
[17:43:56.126]                       }
[17:43:56.126]                       else if (inherits(cond, "condition")) {
[17:43:56.126]                         if (!is.null(pattern)) {
[17:43:56.126]                           computeRestarts <- base::computeRestarts
[17:43:56.126]                           grepl <- base::grepl
[17:43:56.126]                           restarts <- computeRestarts(cond)
[17:43:56.126]                           for (restart in restarts) {
[17:43:56.126]                             name <- restart$name
[17:43:56.126]                             if (is.null(name)) 
[17:43:56.126]                               next
[17:43:56.126]                             if (!grepl(pattern, name)) 
[17:43:56.126]                               next
[17:43:56.126]                             invokeRestart(restart)
[17:43:56.126]                             muffled <- TRUE
[17:43:56.126]                             break
[17:43:56.126]                           }
[17:43:56.126]                         }
[17:43:56.126]                       }
[17:43:56.126]                       invisible(muffled)
[17:43:56.126]                     }
[17:43:56.126]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.126]                   }
[17:43:56.126]                 }
[17:43:56.126]                 else {
[17:43:56.126]                   if (TRUE) {
[17:43:56.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.126]                     {
[17:43:56.126]                       inherits <- base::inherits
[17:43:56.126]                       invokeRestart <- base::invokeRestart
[17:43:56.126]                       is.null <- base::is.null
[17:43:56.126]                       muffled <- FALSE
[17:43:56.126]                       if (inherits(cond, "message")) {
[17:43:56.126]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.126]                         if (muffled) 
[17:43:56.126]                           invokeRestart("muffleMessage")
[17:43:56.126]                       }
[17:43:56.126]                       else if (inherits(cond, "warning")) {
[17:43:56.126]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.126]                         if (muffled) 
[17:43:56.126]                           invokeRestart("muffleWarning")
[17:43:56.126]                       }
[17:43:56.126]                       else if (inherits(cond, "condition")) {
[17:43:56.126]                         if (!is.null(pattern)) {
[17:43:56.126]                           computeRestarts <- base::computeRestarts
[17:43:56.126]                           grepl <- base::grepl
[17:43:56.126]                           restarts <- computeRestarts(cond)
[17:43:56.126]                           for (restart in restarts) {
[17:43:56.126]                             name <- restart$name
[17:43:56.126]                             if (is.null(name)) 
[17:43:56.126]                               next
[17:43:56.126]                             if (!grepl(pattern, name)) 
[17:43:56.126]                               next
[17:43:56.126]                             invokeRestart(restart)
[17:43:56.126]                             muffled <- TRUE
[17:43:56.126]                             break
[17:43:56.126]                           }
[17:43:56.126]                         }
[17:43:56.126]                       }
[17:43:56.126]                       invisible(muffled)
[17:43:56.126]                     }
[17:43:56.126]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.126]                   }
[17:43:56.126]                 }
[17:43:56.126]             }
[17:43:56.126]         }))
[17:43:56.126]     }, error = function(ex) {
[17:43:56.126]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.126]                 ...future.rng), started = ...future.startTime, 
[17:43:56.126]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.126]             version = "1.8"), class = "FutureResult")
[17:43:56.126]     }, finally = {
[17:43:56.126]         if (!identical(...future.workdir, getwd())) 
[17:43:56.126]             setwd(...future.workdir)
[17:43:56.126]         {
[17:43:56.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.126]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.126]             }
[17:43:56.126]             base::options(...future.oldOptions)
[17:43:56.126]             if (.Platform$OS.type == "windows") {
[17:43:56.126]                 old_names <- names(...future.oldEnvVars)
[17:43:56.126]                 envs <- base::Sys.getenv()
[17:43:56.126]                 names <- names(envs)
[17:43:56.126]                 common <- intersect(names, old_names)
[17:43:56.126]                 added <- setdiff(names, old_names)
[17:43:56.126]                 removed <- setdiff(old_names, names)
[17:43:56.126]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.126]                   envs[common]]
[17:43:56.126]                 NAMES <- toupper(changed)
[17:43:56.126]                 args <- list()
[17:43:56.126]                 for (kk in seq_along(NAMES)) {
[17:43:56.126]                   name <- changed[[kk]]
[17:43:56.126]                   NAME <- NAMES[[kk]]
[17:43:56.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.126]                     next
[17:43:56.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.126]                 }
[17:43:56.126]                 NAMES <- toupper(added)
[17:43:56.126]                 for (kk in seq_along(NAMES)) {
[17:43:56.126]                   name <- added[[kk]]
[17:43:56.126]                   NAME <- NAMES[[kk]]
[17:43:56.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.126]                     next
[17:43:56.126]                   args[[name]] <- ""
[17:43:56.126]                 }
[17:43:56.126]                 NAMES <- toupper(removed)
[17:43:56.126]                 for (kk in seq_along(NAMES)) {
[17:43:56.126]                   name <- removed[[kk]]
[17:43:56.126]                   NAME <- NAMES[[kk]]
[17:43:56.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.126]                     next
[17:43:56.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.126]                 }
[17:43:56.126]                 if (length(args) > 0) 
[17:43:56.126]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.126]             }
[17:43:56.126]             else {
[17:43:56.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.126]             }
[17:43:56.126]             {
[17:43:56.126]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.126]                   0L) {
[17:43:56.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.126]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.126]                   base::options(opts)
[17:43:56.126]                 }
[17:43:56.126]                 {
[17:43:56.126]                   {
[17:43:56.126]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.126]                     NULL
[17:43:56.126]                   }
[17:43:56.126]                   options(future.plan = NULL)
[17:43:56.126]                   if (is.na(NA_character_)) 
[17:43:56.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.126]                     .init = FALSE)
[17:43:56.126]                 }
[17:43:56.126]             }
[17:43:56.126]         }
[17:43:56.126]     })
[17:43:56.126]     if (TRUE) {
[17:43:56.126]         base::sink(type = "output", split = FALSE)
[17:43:56.126]         if (TRUE) {
[17:43:56.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.126]         }
[17:43:56.126]         else {
[17:43:56.126]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.126]         }
[17:43:56.126]         base::close(...future.stdout)
[17:43:56.126]         ...future.stdout <- NULL
[17:43:56.126]     }
[17:43:56.126]     ...future.result$conditions <- ...future.conditions
[17:43:56.126]     ...future.result$finished <- base::Sys.time()
[17:43:56.126]     ...future.result
[17:43:56.126] }
[17:43:56.128] assign_globals() ...
[17:43:56.129] List of 5
[17:43:56.129]  $ ...future.FUN            :function (x, ...)  
[17:43:56.129]  $ future.call.arguments    : list()
[17:43:56.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.129]  $ ...future.elements_ii    :List of 1
[17:43:56.129]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:43:56.129]  $ ...future.seeds_ii       : NULL
[17:43:56.129]  $ ...future.globals.maxSize: NULL
[17:43:56.129]  - attr(*, "where")=List of 5
[17:43:56.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:56.129]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:56.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:56.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:56.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:56.129]  - attr(*, "resolved")= logi FALSE
[17:43:56.129]  - attr(*, "total_size")= num 1248
[17:43:56.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.129]  - attr(*, "already-done")= logi TRUE
[17:43:56.133] - copied ‘...future.FUN’ to environment
[17:43:56.133] - copied ‘future.call.arguments’ to environment
[17:43:56.133] - copied ‘...future.elements_ii’ to environment
[17:43:56.133] - copied ‘...future.seeds_ii’ to environment
[17:43:56.133] - copied ‘...future.globals.maxSize’ to environment
[17:43:56.134] assign_globals() ... done
[17:43:56.134] requestCore(): workers = 2
[17:43:56.136] MulticoreFuture started
[17:43:56.136] - Launch lazy future ... done
[17:43:56.136] run() for ‘MulticoreFuture’ ... done
[17:43:56.136] Created future:
[17:43:56.137] plan(): Setting new future strategy stack:
[17:43:56.140] List of future strategies:
[17:43:56.140] 1. sequential:
[17:43:56.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.140]    - tweaked: FALSE
[17:43:56.140]    - call: NULL
[17:43:56.141] plan(): nbrOfWorkers() = 1
[17:43:56.144] plan(): Setting new future strategy stack:
[17:43:56.144] List of future strategies:
[17:43:56.144] 1. multicore:
[17:43:56.144]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:56.144]    - tweaked: FALSE
[17:43:56.144]    - call: plan(strategy)
[17:43:56.149] plan(): nbrOfWorkers() = 2
[17:43:56.140] MulticoreFuture:
[17:43:56.140] Label: ‘future_eapply-1’
[17:43:56.140] Expression:
[17:43:56.140] {
[17:43:56.140]     do.call(function(...) {
[17:43:56.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.140]             on.exit(options(oopts), add = TRUE)
[17:43:56.140]         }
[17:43:56.140]         {
[17:43:56.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.140]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.140]             })
[17:43:56.140]         }
[17:43:56.140]     }, args = future.call.arguments)
[17:43:56.140] }
[17:43:56.140] Lazy evaluation: FALSE
[17:43:56.140] Asynchronous evaluation: TRUE
[17:43:56.140] Local evaluation: TRUE
[17:43:56.140] Environment: R_GlobalEnv
[17:43:56.140] Capture standard output: TRUE
[17:43:56.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.140] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.140] Packages: 1 packages (‘stats’)
[17:43:56.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.140] Resolved: TRUE
[17:43:56.140] Value: <not collected>
[17:43:56.140] Conditions captured: <none>
[17:43:56.140] Early signaling: FALSE
[17:43:56.140] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.140] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.150] Chunk #1 of 2 ... DONE
[17:43:56.150] Chunk #2 of 2 ...
[17:43:56.150]  - Finding globals in 'X' for chunk #2 ...
[17:43:56.151] getGlobalsAndPackages() ...
[17:43:56.151] Searching for globals...
[17:43:56.151] 
[17:43:56.151] Searching for globals ... DONE
[17:43:56.152] - globals: [0] <none>
[17:43:56.152] getGlobalsAndPackages() ... DONE
[17:43:56.152]    + additional globals found: [n=0] 
[17:43:56.152]    + additional namespaces needed: [n=0] 
[17:43:56.152]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:56.152]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.152]  - seeds: <none>
[17:43:56.153]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.153] getGlobalsAndPackages() ...
[17:43:56.153] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.153] Resolving globals: FALSE
[17:43:56.153] Tweak future expression to call with '...' arguments ...
[17:43:56.153] {
[17:43:56.153]     do.call(function(...) {
[17:43:56.153]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.153]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.153]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.153]             on.exit(options(oopts), add = TRUE)
[17:43:56.153]         }
[17:43:56.153]         {
[17:43:56.153]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.153]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.153]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.153]             })
[17:43:56.153]         }
[17:43:56.153]     }, args = future.call.arguments)
[17:43:56.153] }
[17:43:56.154] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.155] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.155] - packages: [1] ‘stats’
[17:43:56.155] getGlobalsAndPackages() ... DONE
[17:43:56.156] run() for ‘Future’ ...
[17:43:56.156] - state: ‘created’
[17:43:56.156] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.161] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:56.161]   - Field: ‘label’
[17:43:56.161]   - Field: ‘local’
[17:43:56.161]   - Field: ‘owner’
[17:43:56.161]   - Field: ‘envir’
[17:43:56.162]   - Field: ‘workers’
[17:43:56.162]   - Field: ‘packages’
[17:43:56.162]   - Field: ‘gc’
[17:43:56.162]   - Field: ‘job’
[17:43:56.162]   - Field: ‘conditions’
[17:43:56.162]   - Field: ‘expr’
[17:43:56.162]   - Field: ‘uuid’
[17:43:56.163]   - Field: ‘seed’
[17:43:56.163]   - Field: ‘version’
[17:43:56.163]   - Field: ‘result’
[17:43:56.163]   - Field: ‘asynchronous’
[17:43:56.163]   - Field: ‘calls’
[17:43:56.163]   - Field: ‘globals’
[17:43:56.163]   - Field: ‘stdout’
[17:43:56.164]   - Field: ‘earlySignal’
[17:43:56.164]   - Field: ‘lazy’
[17:43:56.164]   - Field: ‘state’
[17:43:56.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:56.164] - Launch lazy future ...
[17:43:56.165] Packages needed by the future expression (n = 1): ‘stats’
[17:43:56.165] Packages needed by future strategies (n = 0): <none>
[17:43:56.166] {
[17:43:56.166]     {
[17:43:56.166]         {
[17:43:56.166]             ...future.startTime <- base::Sys.time()
[17:43:56.166]             {
[17:43:56.166]                 {
[17:43:56.166]                   {
[17:43:56.166]                     {
[17:43:56.166]                       {
[17:43:56.166]                         base::local({
[17:43:56.166]                           has_future <- base::requireNamespace("future", 
[17:43:56.166]                             quietly = TRUE)
[17:43:56.166]                           if (has_future) {
[17:43:56.166]                             ns <- base::getNamespace("future")
[17:43:56.166]                             version <- ns[[".package"]][["version"]]
[17:43:56.166]                             if (is.null(version)) 
[17:43:56.166]                               version <- utils::packageVersion("future")
[17:43:56.166]                           }
[17:43:56.166]                           else {
[17:43:56.166]                             version <- NULL
[17:43:56.166]                           }
[17:43:56.166]                           if (!has_future || version < "1.8.0") {
[17:43:56.166]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.166]                               "", base::R.version$version.string), 
[17:43:56.166]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:56.166]                                 base::R.version$platform, 8 * 
[17:43:56.166]                                   base::.Machine$sizeof.pointer), 
[17:43:56.166]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.166]                                 "release", "version")], collapse = " "), 
[17:43:56.166]                               hostname = base::Sys.info()[["nodename"]])
[17:43:56.166]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.166]                               info)
[17:43:56.166]                             info <- base::paste(info, collapse = "; ")
[17:43:56.166]                             if (!has_future) {
[17:43:56.166]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.166]                                 info)
[17:43:56.166]                             }
[17:43:56.166]                             else {
[17:43:56.166]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.166]                                 info, version)
[17:43:56.166]                             }
[17:43:56.166]                             base::stop(msg)
[17:43:56.166]                           }
[17:43:56.166]                         })
[17:43:56.166]                       }
[17:43:56.166]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.166]                       base::options(mc.cores = 1L)
[17:43:56.166]                     }
[17:43:56.166]                     base::local({
[17:43:56.166]                       for (pkg in "stats") {
[17:43:56.166]                         base::loadNamespace(pkg)
[17:43:56.166]                         base::library(pkg, character.only = TRUE)
[17:43:56.166]                       }
[17:43:56.166]                     })
[17:43:56.166]                   }
[17:43:56.166]                   ...future.strategy.old <- future::plan("list")
[17:43:56.166]                   options(future.plan = NULL)
[17:43:56.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.166]                 }
[17:43:56.166]                 ...future.workdir <- getwd()
[17:43:56.166]             }
[17:43:56.166]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.166]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.166]         }
[17:43:56.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.166]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.166]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.166]             base::names(...future.oldOptions))
[17:43:56.166]     }
[17:43:56.166]     if (FALSE) {
[17:43:56.166]     }
[17:43:56.166]     else {
[17:43:56.166]         if (TRUE) {
[17:43:56.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.166]                 open = "w")
[17:43:56.166]         }
[17:43:56.166]         else {
[17:43:56.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.166]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.166]         }
[17:43:56.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.166]             base::sink(type = "output", split = FALSE)
[17:43:56.166]             base::close(...future.stdout)
[17:43:56.166]         }, add = TRUE)
[17:43:56.166]     }
[17:43:56.166]     ...future.frame <- base::sys.nframe()
[17:43:56.166]     ...future.conditions <- base::list()
[17:43:56.166]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.166]     if (FALSE) {
[17:43:56.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.166]     }
[17:43:56.166]     ...future.result <- base::tryCatch({
[17:43:56.166]         base::withCallingHandlers({
[17:43:56.166]             ...future.value <- base::withVisible(base::local({
[17:43:56.166]                 withCallingHandlers({
[17:43:56.166]                   {
[17:43:56.166]                     do.call(function(...) {
[17:43:56.166]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.166]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.166]                         ...future.globals.maxSize)) {
[17:43:56.166]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.166]                         on.exit(options(oopts), add = TRUE)
[17:43:56.166]                       }
[17:43:56.166]                       {
[17:43:56.166]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.166]                           FUN = function(jj) {
[17:43:56.166]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.166]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.166]                           })
[17:43:56.166]                       }
[17:43:56.166]                     }, args = future.call.arguments)
[17:43:56.166]                   }
[17:43:56.166]                 }, immediateCondition = function(cond) {
[17:43:56.166]                   save_rds <- function (object, pathname, ...) 
[17:43:56.166]                   {
[17:43:56.166]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:56.166]                     if (file_test("-f", pathname_tmp)) {
[17:43:56.166]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.166]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:56.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.166]                         fi_tmp[["mtime"]])
[17:43:56.166]                     }
[17:43:56.166]                     tryCatch({
[17:43:56.166]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:56.166]                     }, error = function(ex) {
[17:43:56.166]                       msg <- conditionMessage(ex)
[17:43:56.166]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.166]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:56.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.166]                         fi_tmp[["mtime"]], msg)
[17:43:56.166]                       ex$message <- msg
[17:43:56.166]                       stop(ex)
[17:43:56.166]                     })
[17:43:56.166]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:56.166]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:56.166]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:56.166]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.166]                       fi <- file.info(pathname)
[17:43:56.166]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:56.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.166]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:56.166]                         fi[["size"]], fi[["mtime"]])
[17:43:56.166]                       stop(msg)
[17:43:56.166]                     }
[17:43:56.166]                     invisible(pathname)
[17:43:56.166]                   }
[17:43:56.166]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:56.166]                     rootPath = tempdir()) 
[17:43:56.166]                   {
[17:43:56.166]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:56.166]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:56.166]                       tmpdir = path, fileext = ".rds")
[17:43:56.166]                     save_rds(obj, file)
[17:43:56.166]                   }
[17:43:56.166]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:56.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.166]                   {
[17:43:56.166]                     inherits <- base::inherits
[17:43:56.166]                     invokeRestart <- base::invokeRestart
[17:43:56.166]                     is.null <- base::is.null
[17:43:56.166]                     muffled <- FALSE
[17:43:56.166]                     if (inherits(cond, "message")) {
[17:43:56.166]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.166]                       if (muffled) 
[17:43:56.166]                         invokeRestart("muffleMessage")
[17:43:56.166]                     }
[17:43:56.166]                     else if (inherits(cond, "warning")) {
[17:43:56.166]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.166]                       if (muffled) 
[17:43:56.166]                         invokeRestart("muffleWarning")
[17:43:56.166]                     }
[17:43:56.166]                     else if (inherits(cond, "condition")) {
[17:43:56.166]                       if (!is.null(pattern)) {
[17:43:56.166]                         computeRestarts <- base::computeRestarts
[17:43:56.166]                         grepl <- base::grepl
[17:43:56.166]                         restarts <- computeRestarts(cond)
[17:43:56.166]                         for (restart in restarts) {
[17:43:56.166]                           name <- restart$name
[17:43:56.166]                           if (is.null(name)) 
[17:43:56.166]                             next
[17:43:56.166]                           if (!grepl(pattern, name)) 
[17:43:56.166]                             next
[17:43:56.166]                           invokeRestart(restart)
[17:43:56.166]                           muffled <- TRUE
[17:43:56.166]                           break
[17:43:56.166]                         }
[17:43:56.166]                       }
[17:43:56.166]                     }
[17:43:56.166]                     invisible(muffled)
[17:43:56.166]                   }
[17:43:56.166]                   muffleCondition(cond)
[17:43:56.166]                 })
[17:43:56.166]             }))
[17:43:56.166]             future::FutureResult(value = ...future.value$value, 
[17:43:56.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.166]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.166]                     ...future.globalenv.names))
[17:43:56.166]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.166]         }, condition = base::local({
[17:43:56.166]             c <- base::c
[17:43:56.166]             inherits <- base::inherits
[17:43:56.166]             invokeRestart <- base::invokeRestart
[17:43:56.166]             length <- base::length
[17:43:56.166]             list <- base::list
[17:43:56.166]             seq.int <- base::seq.int
[17:43:56.166]             signalCondition <- base::signalCondition
[17:43:56.166]             sys.calls <- base::sys.calls
[17:43:56.166]             `[[` <- base::`[[`
[17:43:56.166]             `+` <- base::`+`
[17:43:56.166]             `<<-` <- base::`<<-`
[17:43:56.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.166]                   3L)]
[17:43:56.166]             }
[17:43:56.166]             function(cond) {
[17:43:56.166]                 is_error <- inherits(cond, "error")
[17:43:56.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.166]                   NULL)
[17:43:56.166]                 if (is_error) {
[17:43:56.166]                   sessionInformation <- function() {
[17:43:56.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.166]                       search = base::search(), system = base::Sys.info())
[17:43:56.166]                   }
[17:43:56.166]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.166]                     cond$call), session = sessionInformation(), 
[17:43:56.166]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.166]                   signalCondition(cond)
[17:43:56.166]                 }
[17:43:56.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.166]                 "immediateCondition"))) {
[17:43:56.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.166]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.166]                   if (TRUE && !signal) {
[17:43:56.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.166]                     {
[17:43:56.166]                       inherits <- base::inherits
[17:43:56.166]                       invokeRestart <- base::invokeRestart
[17:43:56.166]                       is.null <- base::is.null
[17:43:56.166]                       muffled <- FALSE
[17:43:56.166]                       if (inherits(cond, "message")) {
[17:43:56.166]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.166]                         if (muffled) 
[17:43:56.166]                           invokeRestart("muffleMessage")
[17:43:56.166]                       }
[17:43:56.166]                       else if (inherits(cond, "warning")) {
[17:43:56.166]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.166]                         if (muffled) 
[17:43:56.166]                           invokeRestart("muffleWarning")
[17:43:56.166]                       }
[17:43:56.166]                       else if (inherits(cond, "condition")) {
[17:43:56.166]                         if (!is.null(pattern)) {
[17:43:56.166]                           computeRestarts <- base::computeRestarts
[17:43:56.166]                           grepl <- base::grepl
[17:43:56.166]                           restarts <- computeRestarts(cond)
[17:43:56.166]                           for (restart in restarts) {
[17:43:56.166]                             name <- restart$name
[17:43:56.166]                             if (is.null(name)) 
[17:43:56.166]                               next
[17:43:56.166]                             if (!grepl(pattern, name)) 
[17:43:56.166]                               next
[17:43:56.166]                             invokeRestart(restart)
[17:43:56.166]                             muffled <- TRUE
[17:43:56.166]                             break
[17:43:56.166]                           }
[17:43:56.166]                         }
[17:43:56.166]                       }
[17:43:56.166]                       invisible(muffled)
[17:43:56.166]                     }
[17:43:56.166]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.166]                   }
[17:43:56.166]                 }
[17:43:56.166]                 else {
[17:43:56.166]                   if (TRUE) {
[17:43:56.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.166]                     {
[17:43:56.166]                       inherits <- base::inherits
[17:43:56.166]                       invokeRestart <- base::invokeRestart
[17:43:56.166]                       is.null <- base::is.null
[17:43:56.166]                       muffled <- FALSE
[17:43:56.166]                       if (inherits(cond, "message")) {
[17:43:56.166]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.166]                         if (muffled) 
[17:43:56.166]                           invokeRestart("muffleMessage")
[17:43:56.166]                       }
[17:43:56.166]                       else if (inherits(cond, "warning")) {
[17:43:56.166]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.166]                         if (muffled) 
[17:43:56.166]                           invokeRestart("muffleWarning")
[17:43:56.166]                       }
[17:43:56.166]                       else if (inherits(cond, "condition")) {
[17:43:56.166]                         if (!is.null(pattern)) {
[17:43:56.166]                           computeRestarts <- base::computeRestarts
[17:43:56.166]                           grepl <- base::grepl
[17:43:56.166]                           restarts <- computeRestarts(cond)
[17:43:56.166]                           for (restart in restarts) {
[17:43:56.166]                             name <- restart$name
[17:43:56.166]                             if (is.null(name)) 
[17:43:56.166]                               next
[17:43:56.166]                             if (!grepl(pattern, name)) 
[17:43:56.166]                               next
[17:43:56.166]                             invokeRestart(restart)
[17:43:56.166]                             muffled <- TRUE
[17:43:56.166]                             break
[17:43:56.166]                           }
[17:43:56.166]                         }
[17:43:56.166]                       }
[17:43:56.166]                       invisible(muffled)
[17:43:56.166]                     }
[17:43:56.166]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.166]                   }
[17:43:56.166]                 }
[17:43:56.166]             }
[17:43:56.166]         }))
[17:43:56.166]     }, error = function(ex) {
[17:43:56.166]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.166]                 ...future.rng), started = ...future.startTime, 
[17:43:56.166]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.166]             version = "1.8"), class = "FutureResult")
[17:43:56.166]     }, finally = {
[17:43:56.166]         if (!identical(...future.workdir, getwd())) 
[17:43:56.166]             setwd(...future.workdir)
[17:43:56.166]         {
[17:43:56.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.166]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.166]             }
[17:43:56.166]             base::options(...future.oldOptions)
[17:43:56.166]             if (.Platform$OS.type == "windows") {
[17:43:56.166]                 old_names <- names(...future.oldEnvVars)
[17:43:56.166]                 envs <- base::Sys.getenv()
[17:43:56.166]                 names <- names(envs)
[17:43:56.166]                 common <- intersect(names, old_names)
[17:43:56.166]                 added <- setdiff(names, old_names)
[17:43:56.166]                 removed <- setdiff(old_names, names)
[17:43:56.166]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.166]                   envs[common]]
[17:43:56.166]                 NAMES <- toupper(changed)
[17:43:56.166]                 args <- list()
[17:43:56.166]                 for (kk in seq_along(NAMES)) {
[17:43:56.166]                   name <- changed[[kk]]
[17:43:56.166]                   NAME <- NAMES[[kk]]
[17:43:56.166]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.166]                     next
[17:43:56.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.166]                 }
[17:43:56.166]                 NAMES <- toupper(added)
[17:43:56.166]                 for (kk in seq_along(NAMES)) {
[17:43:56.166]                   name <- added[[kk]]
[17:43:56.166]                   NAME <- NAMES[[kk]]
[17:43:56.166]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.166]                     next
[17:43:56.166]                   args[[name]] <- ""
[17:43:56.166]                 }
[17:43:56.166]                 NAMES <- toupper(removed)
[17:43:56.166]                 for (kk in seq_along(NAMES)) {
[17:43:56.166]                   name <- removed[[kk]]
[17:43:56.166]                   NAME <- NAMES[[kk]]
[17:43:56.166]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.166]                     next
[17:43:56.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.166]                 }
[17:43:56.166]                 if (length(args) > 0) 
[17:43:56.166]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.166]             }
[17:43:56.166]             else {
[17:43:56.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.166]             }
[17:43:56.166]             {
[17:43:56.166]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.166]                   0L) {
[17:43:56.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.166]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.166]                   base::options(opts)
[17:43:56.166]                 }
[17:43:56.166]                 {
[17:43:56.166]                   {
[17:43:56.166]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.166]                     NULL
[17:43:56.166]                   }
[17:43:56.166]                   options(future.plan = NULL)
[17:43:56.166]                   if (is.na(NA_character_)) 
[17:43:56.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.166]                     .init = FALSE)
[17:43:56.166]                 }
[17:43:56.166]             }
[17:43:56.166]         }
[17:43:56.166]     })
[17:43:56.166]     if (TRUE) {
[17:43:56.166]         base::sink(type = "output", split = FALSE)
[17:43:56.166]         if (TRUE) {
[17:43:56.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.166]         }
[17:43:56.166]         else {
[17:43:56.166]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.166]         }
[17:43:56.166]         base::close(...future.stdout)
[17:43:56.166]         ...future.stdout <- NULL
[17:43:56.166]     }
[17:43:56.166]     ...future.result$conditions <- ...future.conditions
[17:43:56.166]     ...future.result$finished <- base::Sys.time()
[17:43:56.166]     ...future.result
[17:43:56.166] }
[17:43:56.168] assign_globals() ...
[17:43:56.168] List of 5
[17:43:56.168]  $ ...future.FUN            :function (x, ...)  
[17:43:56.168]  $ future.call.arguments    : list()
[17:43:56.168]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.168]  $ ...future.elements_ii    :List of 2
[17:43:56.168]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:56.168]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:56.168]  $ ...future.seeds_ii       : NULL
[17:43:56.168]  $ ...future.globals.maxSize: NULL
[17:43:56.168]  - attr(*, "where")=List of 5
[17:43:56.168]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:56.168]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:56.168]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:56.168]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:56.168]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:56.168]  - attr(*, "resolved")= logi FALSE
[17:43:56.168]  - attr(*, "total_size")= num 1248
[17:43:56.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.168]  - attr(*, "already-done")= logi TRUE
[17:43:56.175] - copied ‘...future.FUN’ to environment
[17:43:56.176] - copied ‘future.call.arguments’ to environment
[17:43:56.176] - copied ‘...future.elements_ii’ to environment
[17:43:56.176] - copied ‘...future.seeds_ii’ to environment
[17:43:56.176] - copied ‘...future.globals.maxSize’ to environment
[17:43:56.176] assign_globals() ... done
[17:43:56.176] requestCore(): workers = 2
[17:43:56.178] MulticoreFuture started
[17:43:56.179] - Launch lazy future ... done
[17:43:56.179] run() for ‘MulticoreFuture’ ... done
[17:43:56.179] Created future:
[17:43:56.180] plan(): Setting new future strategy stack:
[17:43:56.180] List of future strategies:
[17:43:56.180] 1. sequential:
[17:43:56.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.180]    - tweaked: FALSE
[17:43:56.180]    - call: NULL
[17:43:56.181] plan(): nbrOfWorkers() = 1
[17:43:56.184] plan(): Setting new future strategy stack:
[17:43:56.184] List of future strategies:
[17:43:56.184] 1. multicore:
[17:43:56.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:56.184]    - tweaked: FALSE
[17:43:56.184]    - call: plan(strategy)
[17:43:56.189] plan(): nbrOfWorkers() = 2
[17:43:56.179] MulticoreFuture:
[17:43:56.179] Label: ‘future_eapply-2’
[17:43:56.179] Expression:
[17:43:56.179] {
[17:43:56.179]     do.call(function(...) {
[17:43:56.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.179]             on.exit(options(oopts), add = TRUE)
[17:43:56.179]         }
[17:43:56.179]         {
[17:43:56.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.179]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.179]             })
[17:43:56.179]         }
[17:43:56.179]     }, args = future.call.arguments)
[17:43:56.179] }
[17:43:56.179] Lazy evaluation: FALSE
[17:43:56.179] Asynchronous evaluation: TRUE
[17:43:56.179] Local evaluation: TRUE
[17:43:56.179] Environment: R_GlobalEnv
[17:43:56.179] Capture standard output: TRUE
[17:43:56.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.179] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.179] Packages: 1 packages (‘stats’)
[17:43:56.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.179] Resolved: TRUE
[17:43:56.179] Value: <not collected>
[17:43:56.179] Conditions captured: <none>
[17:43:56.179] Early signaling: FALSE
[17:43:56.179] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.179] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.190] Chunk #2 of 2 ... DONE
[17:43:56.190] Launching 2 futures (chunks) ... DONE
[17:43:56.190] Resolving 2 futures (chunks) ...
[17:43:56.190] resolve() on list ...
[17:43:56.190]  recursive: 0
[17:43:56.191]  length: 2
[17:43:56.191] 
[17:43:56.191] Future #1
[17:43:56.191] result() for MulticoreFuture ...
[17:43:56.192] result() for MulticoreFuture ...
[17:43:56.192] result() for MulticoreFuture ... done
[17:43:56.192] result() for MulticoreFuture ... done
[17:43:56.193] result() for MulticoreFuture ...
[17:43:56.193] result() for MulticoreFuture ... done
[17:43:56.193] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:56.193] - nx: 2
[17:43:56.193] - relay: TRUE
[17:43:56.193] - stdout: TRUE
[17:43:56.193] - signal: TRUE
[17:43:56.194] - resignal: FALSE
[17:43:56.194] - force: TRUE
[17:43:56.194] - relayed: [n=2] FALSE, FALSE
[17:43:56.194] - queued futures: [n=2] FALSE, FALSE
[17:43:56.194]  - until=1
[17:43:56.194]  - relaying element #1
[17:43:56.194] result() for MulticoreFuture ...
[17:43:56.195] result() for MulticoreFuture ... done
[17:43:56.195] result() for MulticoreFuture ...
[17:43:56.195] result() for MulticoreFuture ... done
[17:43:56.195] result() for MulticoreFuture ...
[17:43:56.195] result() for MulticoreFuture ... done
[17:43:56.195] result() for MulticoreFuture ...
[17:43:56.196] result() for MulticoreFuture ... done
[17:43:56.196] - relayed: [n=2] TRUE, FALSE
[17:43:56.196] - queued futures: [n=2] TRUE, FALSE
[17:43:56.196] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:56.196]  length: 1 (resolved future 1)
[17:43:56.196] Future #2
[17:43:56.197] result() for MulticoreFuture ...
[17:43:56.197] result() for MulticoreFuture ...
[17:43:56.197] result() for MulticoreFuture ... done
[17:43:56.197] result() for MulticoreFuture ... done
[17:43:56.198] result() for MulticoreFuture ...
[17:43:56.198] result() for MulticoreFuture ... done
[17:43:56.200] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:56.201] - nx: 2
[17:43:56.201] - relay: TRUE
[17:43:56.201] - stdout: TRUE
[17:43:56.201] - signal: TRUE
[17:43:56.201] - resignal: FALSE
[17:43:56.201] - force: TRUE
[17:43:56.201] - relayed: [n=2] TRUE, FALSE
[17:43:56.201] - queued futures: [n=2] TRUE, FALSE
[17:43:56.201]  - until=2
[17:43:56.202]  - relaying element #2
[17:43:56.202] result() for MulticoreFuture ...
[17:43:56.202] result() for MulticoreFuture ... done
[17:43:56.202] result() for MulticoreFuture ...
[17:43:56.202] result() for MulticoreFuture ... done
[17:43:56.202] result() for MulticoreFuture ...
[17:43:56.202] result() for MulticoreFuture ... done
[17:43:56.203] result() for MulticoreFuture ...
[17:43:56.203] result() for MulticoreFuture ... done
[17:43:56.203] - relayed: [n=2] TRUE, TRUE
[17:43:56.203] - queued futures: [n=2] TRUE, TRUE
[17:43:56.203] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:56.203]  length: 0 (resolved future 2)
[17:43:56.203] Relaying remaining futures
[17:43:56.204] signalConditionsASAP(NULL, pos=0) ...
[17:43:56.204] - nx: 2
[17:43:56.204] - relay: TRUE
[17:43:56.204] - stdout: TRUE
[17:43:56.204] - signal: TRUE
[17:43:56.204] - resignal: FALSE
[17:43:56.204] - force: TRUE
[17:43:56.204] - relayed: [n=2] TRUE, TRUE
[17:43:56.204] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:56.205] - relayed: [n=2] TRUE, TRUE
[17:43:56.205] - queued futures: [n=2] TRUE, TRUE
[17:43:56.205] signalConditionsASAP(NULL, pos=0) ... done
[17:43:56.205] resolve() on list ... DONE
[17:43:56.205] result() for MulticoreFuture ...
[17:43:56.205] result() for MulticoreFuture ... done
[17:43:56.205] result() for MulticoreFuture ...
[17:43:56.205] result() for MulticoreFuture ... done
[17:43:56.206] result() for MulticoreFuture ...
[17:43:56.206] result() for MulticoreFuture ... done
[17:43:56.206] result() for MulticoreFuture ...
[17:43:56.206] result() for MulticoreFuture ... done
[17:43:56.206]  - Number of value chunks collected: 2
[17:43:56.206] Resolving 2 futures (chunks) ... DONE
[17:43:56.206] Reducing values from 2 chunks ...
[17:43:56.206]  - Number of values collected after concatenation: 3
[17:43:56.207]  - Number of values expected: 3
[17:43:56.207] Reducing values from 2 chunks ... DONE
[17:43:56.207] future_lapply() ... DONE
[17:43:56.207] future_lapply() ...
[17:43:56.212] Number of chunks: 2
[17:43:56.212] getGlobalsAndPackagesXApply() ...
[17:43:56.212]  - future.globals: TRUE
[17:43:56.212] getGlobalsAndPackages() ...
[17:43:56.212] Searching for globals...
[17:43:56.214] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:56.214] Searching for globals ... DONE
[17:43:56.214] Resolving globals: FALSE
[17:43:56.214] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:56.215] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:56.215] - globals: [1] ‘FUN’
[17:43:56.215] - packages: [1] ‘stats’
[17:43:56.215] getGlobalsAndPackages() ... DONE
[17:43:56.215]  - globals found/used: [n=1] ‘FUN’
[17:43:56.215]  - needed namespaces: [n=1] ‘stats’
[17:43:56.215] Finding globals ... DONE
[17:43:56.216]  - use_args: TRUE
[17:43:56.216]  - Getting '...' globals ...
[17:43:56.216] resolve() on list ...
[17:43:56.216]  recursive: 0
[17:43:56.216]  length: 1
[17:43:56.216]  elements: ‘...’
[17:43:56.216]  length: 0 (resolved future 1)
[17:43:56.217] resolve() on list ... DONE
[17:43:56.217]    - '...' content: [n=0] 
[17:43:56.217] List of 1
[17:43:56.217]  $ ...: list()
[17:43:56.217]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.217]  - attr(*, "where")=List of 1
[17:43:56.217]   ..$ ...:<environment: 0x55813bd6e068> 
[17:43:56.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.217]  - attr(*, "resolved")= logi TRUE
[17:43:56.217]  - attr(*, "total_size")= num NA
[17:43:56.220]  - Getting '...' globals ... DONE
[17:43:56.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:56.220] List of 2
[17:43:56.220]  $ ...future.FUN:function (x, ...)  
[17:43:56.220]  $ ...          : list()
[17:43:56.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.220]  - attr(*, "where")=List of 2
[17:43:56.220]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:56.220]   ..$ ...          :<environment: 0x55813bd6e068> 
[17:43:56.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.220]  - attr(*, "resolved")= logi FALSE
[17:43:56.220]  - attr(*, "total_size")= num 1248
[17:43:56.223] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:56.223] getGlobalsAndPackagesXApply() ... DONE
[17:43:56.223] Number of futures (= number of chunks): 2
[17:43:56.223] Launching 2 futures (chunks) ...
[17:43:56.223] Chunk #1 of 2 ...
[17:43:56.224]  - Finding globals in 'X' for chunk #1 ...
[17:43:56.224] getGlobalsAndPackages() ...
[17:43:56.224] Searching for globals...
[17:43:56.224] 
[17:43:56.224] Searching for globals ... DONE
[17:43:56.224] - globals: [0] <none>
[17:43:56.224] getGlobalsAndPackages() ... DONE
[17:43:56.224]    + additional globals found: [n=0] 
[17:43:56.224]    + additional namespaces needed: [n=0] 
[17:43:56.225]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:56.225]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.225]  - seeds: <none>
[17:43:56.225]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.225] getGlobalsAndPackages() ...
[17:43:56.225] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.225] Resolving globals: FALSE
[17:43:56.225] Tweak future expression to call with '...' arguments ...
[17:43:56.225] {
[17:43:56.225]     do.call(function(...) {
[17:43:56.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.225]             on.exit(options(oopts), add = TRUE)
[17:43:56.225]         }
[17:43:56.225]         {
[17:43:56.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.225]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.225]             })
[17:43:56.225]         }
[17:43:56.225]     }, args = future.call.arguments)
[17:43:56.225] }
[17:43:56.226] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.226] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.226] - packages: [1] ‘stats’
[17:43:56.226] getGlobalsAndPackages() ... DONE
[17:43:56.227] run() for ‘Future’ ...
[17:43:56.227] - state: ‘created’
[17:43:56.227] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.232] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:56.232]   - Field: ‘label’
[17:43:56.232]   - Field: ‘local’
[17:43:56.232]   - Field: ‘owner’
[17:43:56.232]   - Field: ‘envir’
[17:43:56.233]   - Field: ‘workers’
[17:43:56.233]   - Field: ‘packages’
[17:43:56.233]   - Field: ‘gc’
[17:43:56.233]   - Field: ‘job’
[17:43:56.233]   - Field: ‘conditions’
[17:43:56.233]   - Field: ‘expr’
[17:43:56.233]   - Field: ‘uuid’
[17:43:56.233]   - Field: ‘seed’
[17:43:56.233]   - Field: ‘version’
[17:43:56.233]   - Field: ‘result’
[17:43:56.233]   - Field: ‘asynchronous’
[17:43:56.234]   - Field: ‘calls’
[17:43:56.234]   - Field: ‘globals’
[17:43:56.234]   - Field: ‘stdout’
[17:43:56.234]   - Field: ‘earlySignal’
[17:43:56.234]   - Field: ‘lazy’
[17:43:56.234]   - Field: ‘state’
[17:43:56.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:56.234] - Launch lazy future ...
[17:43:56.234] Packages needed by the future expression (n = 1): ‘stats’
[17:43:56.235] Packages needed by future strategies (n = 0): <none>
[17:43:56.235] {
[17:43:56.235]     {
[17:43:56.235]         {
[17:43:56.235]             ...future.startTime <- base::Sys.time()
[17:43:56.235]             {
[17:43:56.235]                 {
[17:43:56.235]                   {
[17:43:56.235]                     {
[17:43:56.235]                       {
[17:43:56.235]                         base::local({
[17:43:56.235]                           has_future <- base::requireNamespace("future", 
[17:43:56.235]                             quietly = TRUE)
[17:43:56.235]                           if (has_future) {
[17:43:56.235]                             ns <- base::getNamespace("future")
[17:43:56.235]                             version <- ns[[".package"]][["version"]]
[17:43:56.235]                             if (is.null(version)) 
[17:43:56.235]                               version <- utils::packageVersion("future")
[17:43:56.235]                           }
[17:43:56.235]                           else {
[17:43:56.235]                             version <- NULL
[17:43:56.235]                           }
[17:43:56.235]                           if (!has_future || version < "1.8.0") {
[17:43:56.235]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.235]                               "", base::R.version$version.string), 
[17:43:56.235]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:56.235]                                 base::R.version$platform, 8 * 
[17:43:56.235]                                   base::.Machine$sizeof.pointer), 
[17:43:56.235]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.235]                                 "release", "version")], collapse = " "), 
[17:43:56.235]                               hostname = base::Sys.info()[["nodename"]])
[17:43:56.235]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.235]                               info)
[17:43:56.235]                             info <- base::paste(info, collapse = "; ")
[17:43:56.235]                             if (!has_future) {
[17:43:56.235]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.235]                                 info)
[17:43:56.235]                             }
[17:43:56.235]                             else {
[17:43:56.235]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.235]                                 info, version)
[17:43:56.235]                             }
[17:43:56.235]                             base::stop(msg)
[17:43:56.235]                           }
[17:43:56.235]                         })
[17:43:56.235]                       }
[17:43:56.235]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.235]                       base::options(mc.cores = 1L)
[17:43:56.235]                     }
[17:43:56.235]                     base::local({
[17:43:56.235]                       for (pkg in "stats") {
[17:43:56.235]                         base::loadNamespace(pkg)
[17:43:56.235]                         base::library(pkg, character.only = TRUE)
[17:43:56.235]                       }
[17:43:56.235]                     })
[17:43:56.235]                   }
[17:43:56.235]                   ...future.strategy.old <- future::plan("list")
[17:43:56.235]                   options(future.plan = NULL)
[17:43:56.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.235]                 }
[17:43:56.235]                 ...future.workdir <- getwd()
[17:43:56.235]             }
[17:43:56.235]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.235]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.235]         }
[17:43:56.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.235]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.235]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.235]             base::names(...future.oldOptions))
[17:43:56.235]     }
[17:43:56.235]     if (FALSE) {
[17:43:56.235]     }
[17:43:56.235]     else {
[17:43:56.235]         if (TRUE) {
[17:43:56.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.235]                 open = "w")
[17:43:56.235]         }
[17:43:56.235]         else {
[17:43:56.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.235]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.235]         }
[17:43:56.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.235]             base::sink(type = "output", split = FALSE)
[17:43:56.235]             base::close(...future.stdout)
[17:43:56.235]         }, add = TRUE)
[17:43:56.235]     }
[17:43:56.235]     ...future.frame <- base::sys.nframe()
[17:43:56.235]     ...future.conditions <- base::list()
[17:43:56.235]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.235]     if (FALSE) {
[17:43:56.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.235]     }
[17:43:56.235]     ...future.result <- base::tryCatch({
[17:43:56.235]         base::withCallingHandlers({
[17:43:56.235]             ...future.value <- base::withVisible(base::local({
[17:43:56.235]                 withCallingHandlers({
[17:43:56.235]                   {
[17:43:56.235]                     do.call(function(...) {
[17:43:56.235]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.235]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.235]                         ...future.globals.maxSize)) {
[17:43:56.235]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.235]                         on.exit(options(oopts), add = TRUE)
[17:43:56.235]                       }
[17:43:56.235]                       {
[17:43:56.235]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.235]                           FUN = function(jj) {
[17:43:56.235]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.235]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.235]                           })
[17:43:56.235]                       }
[17:43:56.235]                     }, args = future.call.arguments)
[17:43:56.235]                   }
[17:43:56.235]                 }, immediateCondition = function(cond) {
[17:43:56.235]                   save_rds <- function (object, pathname, ...) 
[17:43:56.235]                   {
[17:43:56.235]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:56.235]                     if (file_test("-f", pathname_tmp)) {
[17:43:56.235]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.235]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:56.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.235]                         fi_tmp[["mtime"]])
[17:43:56.235]                     }
[17:43:56.235]                     tryCatch({
[17:43:56.235]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:56.235]                     }, error = function(ex) {
[17:43:56.235]                       msg <- conditionMessage(ex)
[17:43:56.235]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.235]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:56.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.235]                         fi_tmp[["mtime"]], msg)
[17:43:56.235]                       ex$message <- msg
[17:43:56.235]                       stop(ex)
[17:43:56.235]                     })
[17:43:56.235]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:56.235]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:56.235]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:56.235]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.235]                       fi <- file.info(pathname)
[17:43:56.235]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:56.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.235]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:56.235]                         fi[["size"]], fi[["mtime"]])
[17:43:56.235]                       stop(msg)
[17:43:56.235]                     }
[17:43:56.235]                     invisible(pathname)
[17:43:56.235]                   }
[17:43:56.235]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:56.235]                     rootPath = tempdir()) 
[17:43:56.235]                   {
[17:43:56.235]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:56.235]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:56.235]                       tmpdir = path, fileext = ".rds")
[17:43:56.235]                     save_rds(obj, file)
[17:43:56.235]                   }
[17:43:56.235]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:56.235]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.235]                   {
[17:43:56.235]                     inherits <- base::inherits
[17:43:56.235]                     invokeRestart <- base::invokeRestart
[17:43:56.235]                     is.null <- base::is.null
[17:43:56.235]                     muffled <- FALSE
[17:43:56.235]                     if (inherits(cond, "message")) {
[17:43:56.235]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.235]                       if (muffled) 
[17:43:56.235]                         invokeRestart("muffleMessage")
[17:43:56.235]                     }
[17:43:56.235]                     else if (inherits(cond, "warning")) {
[17:43:56.235]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.235]                       if (muffled) 
[17:43:56.235]                         invokeRestart("muffleWarning")
[17:43:56.235]                     }
[17:43:56.235]                     else if (inherits(cond, "condition")) {
[17:43:56.235]                       if (!is.null(pattern)) {
[17:43:56.235]                         computeRestarts <- base::computeRestarts
[17:43:56.235]                         grepl <- base::grepl
[17:43:56.235]                         restarts <- computeRestarts(cond)
[17:43:56.235]                         for (restart in restarts) {
[17:43:56.235]                           name <- restart$name
[17:43:56.235]                           if (is.null(name)) 
[17:43:56.235]                             next
[17:43:56.235]                           if (!grepl(pattern, name)) 
[17:43:56.235]                             next
[17:43:56.235]                           invokeRestart(restart)
[17:43:56.235]                           muffled <- TRUE
[17:43:56.235]                           break
[17:43:56.235]                         }
[17:43:56.235]                       }
[17:43:56.235]                     }
[17:43:56.235]                     invisible(muffled)
[17:43:56.235]                   }
[17:43:56.235]                   muffleCondition(cond)
[17:43:56.235]                 })
[17:43:56.235]             }))
[17:43:56.235]             future::FutureResult(value = ...future.value$value, 
[17:43:56.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.235]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.235]                     ...future.globalenv.names))
[17:43:56.235]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.235]         }, condition = base::local({
[17:43:56.235]             c <- base::c
[17:43:56.235]             inherits <- base::inherits
[17:43:56.235]             invokeRestart <- base::invokeRestart
[17:43:56.235]             length <- base::length
[17:43:56.235]             list <- base::list
[17:43:56.235]             seq.int <- base::seq.int
[17:43:56.235]             signalCondition <- base::signalCondition
[17:43:56.235]             sys.calls <- base::sys.calls
[17:43:56.235]             `[[` <- base::`[[`
[17:43:56.235]             `+` <- base::`+`
[17:43:56.235]             `<<-` <- base::`<<-`
[17:43:56.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.235]                   3L)]
[17:43:56.235]             }
[17:43:56.235]             function(cond) {
[17:43:56.235]                 is_error <- inherits(cond, "error")
[17:43:56.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.235]                   NULL)
[17:43:56.235]                 if (is_error) {
[17:43:56.235]                   sessionInformation <- function() {
[17:43:56.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.235]                       search = base::search(), system = base::Sys.info())
[17:43:56.235]                   }
[17:43:56.235]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.235]                     cond$call), session = sessionInformation(), 
[17:43:56.235]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.235]                   signalCondition(cond)
[17:43:56.235]                 }
[17:43:56.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.235]                 "immediateCondition"))) {
[17:43:56.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.235]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.235]                   if (TRUE && !signal) {
[17:43:56.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.235]                     {
[17:43:56.235]                       inherits <- base::inherits
[17:43:56.235]                       invokeRestart <- base::invokeRestart
[17:43:56.235]                       is.null <- base::is.null
[17:43:56.235]                       muffled <- FALSE
[17:43:56.235]                       if (inherits(cond, "message")) {
[17:43:56.235]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.235]                         if (muffled) 
[17:43:56.235]                           invokeRestart("muffleMessage")
[17:43:56.235]                       }
[17:43:56.235]                       else if (inherits(cond, "warning")) {
[17:43:56.235]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.235]                         if (muffled) 
[17:43:56.235]                           invokeRestart("muffleWarning")
[17:43:56.235]                       }
[17:43:56.235]                       else if (inherits(cond, "condition")) {
[17:43:56.235]                         if (!is.null(pattern)) {
[17:43:56.235]                           computeRestarts <- base::computeRestarts
[17:43:56.235]                           grepl <- base::grepl
[17:43:56.235]                           restarts <- computeRestarts(cond)
[17:43:56.235]                           for (restart in restarts) {
[17:43:56.235]                             name <- restart$name
[17:43:56.235]                             if (is.null(name)) 
[17:43:56.235]                               next
[17:43:56.235]                             if (!grepl(pattern, name)) 
[17:43:56.235]                               next
[17:43:56.235]                             invokeRestart(restart)
[17:43:56.235]                             muffled <- TRUE
[17:43:56.235]                             break
[17:43:56.235]                           }
[17:43:56.235]                         }
[17:43:56.235]                       }
[17:43:56.235]                       invisible(muffled)
[17:43:56.235]                     }
[17:43:56.235]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.235]                   }
[17:43:56.235]                 }
[17:43:56.235]                 else {
[17:43:56.235]                   if (TRUE) {
[17:43:56.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.235]                     {
[17:43:56.235]                       inherits <- base::inherits
[17:43:56.235]                       invokeRestart <- base::invokeRestart
[17:43:56.235]                       is.null <- base::is.null
[17:43:56.235]                       muffled <- FALSE
[17:43:56.235]                       if (inherits(cond, "message")) {
[17:43:56.235]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.235]                         if (muffled) 
[17:43:56.235]                           invokeRestart("muffleMessage")
[17:43:56.235]                       }
[17:43:56.235]                       else if (inherits(cond, "warning")) {
[17:43:56.235]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.235]                         if (muffled) 
[17:43:56.235]                           invokeRestart("muffleWarning")
[17:43:56.235]                       }
[17:43:56.235]                       else if (inherits(cond, "condition")) {
[17:43:56.235]                         if (!is.null(pattern)) {
[17:43:56.235]                           computeRestarts <- base::computeRestarts
[17:43:56.235]                           grepl <- base::grepl
[17:43:56.235]                           restarts <- computeRestarts(cond)
[17:43:56.235]                           for (restart in restarts) {
[17:43:56.235]                             name <- restart$name
[17:43:56.235]                             if (is.null(name)) 
[17:43:56.235]                               next
[17:43:56.235]                             if (!grepl(pattern, name)) 
[17:43:56.235]                               next
[17:43:56.235]                             invokeRestart(restart)
[17:43:56.235]                             muffled <- TRUE
[17:43:56.235]                             break
[17:43:56.235]                           }
[17:43:56.235]                         }
[17:43:56.235]                       }
[17:43:56.235]                       invisible(muffled)
[17:43:56.235]                     }
[17:43:56.235]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.235]                   }
[17:43:56.235]                 }
[17:43:56.235]             }
[17:43:56.235]         }))
[17:43:56.235]     }, error = function(ex) {
[17:43:56.235]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.235]                 ...future.rng), started = ...future.startTime, 
[17:43:56.235]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.235]             version = "1.8"), class = "FutureResult")
[17:43:56.235]     }, finally = {
[17:43:56.235]         if (!identical(...future.workdir, getwd())) 
[17:43:56.235]             setwd(...future.workdir)
[17:43:56.235]         {
[17:43:56.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.235]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.235]             }
[17:43:56.235]             base::options(...future.oldOptions)
[17:43:56.235]             if (.Platform$OS.type == "windows") {
[17:43:56.235]                 old_names <- names(...future.oldEnvVars)
[17:43:56.235]                 envs <- base::Sys.getenv()
[17:43:56.235]                 names <- names(envs)
[17:43:56.235]                 common <- intersect(names, old_names)
[17:43:56.235]                 added <- setdiff(names, old_names)
[17:43:56.235]                 removed <- setdiff(old_names, names)
[17:43:56.235]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.235]                   envs[common]]
[17:43:56.235]                 NAMES <- toupper(changed)
[17:43:56.235]                 args <- list()
[17:43:56.235]                 for (kk in seq_along(NAMES)) {
[17:43:56.235]                   name <- changed[[kk]]
[17:43:56.235]                   NAME <- NAMES[[kk]]
[17:43:56.235]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.235]                     next
[17:43:56.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.235]                 }
[17:43:56.235]                 NAMES <- toupper(added)
[17:43:56.235]                 for (kk in seq_along(NAMES)) {
[17:43:56.235]                   name <- added[[kk]]
[17:43:56.235]                   NAME <- NAMES[[kk]]
[17:43:56.235]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.235]                     next
[17:43:56.235]                   args[[name]] <- ""
[17:43:56.235]                 }
[17:43:56.235]                 NAMES <- toupper(removed)
[17:43:56.235]                 for (kk in seq_along(NAMES)) {
[17:43:56.235]                   name <- removed[[kk]]
[17:43:56.235]                   NAME <- NAMES[[kk]]
[17:43:56.235]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.235]                     next
[17:43:56.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.235]                 }
[17:43:56.235]                 if (length(args) > 0) 
[17:43:56.235]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.235]             }
[17:43:56.235]             else {
[17:43:56.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.235]             }
[17:43:56.235]             {
[17:43:56.235]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.235]                   0L) {
[17:43:56.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.235]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.235]                   base::options(opts)
[17:43:56.235]                 }
[17:43:56.235]                 {
[17:43:56.235]                   {
[17:43:56.235]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.235]                     NULL
[17:43:56.235]                   }
[17:43:56.235]                   options(future.plan = NULL)
[17:43:56.235]                   if (is.na(NA_character_)) 
[17:43:56.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.235]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.235]                     .init = FALSE)
[17:43:56.235]                 }
[17:43:56.235]             }
[17:43:56.235]         }
[17:43:56.235]     })
[17:43:56.235]     if (TRUE) {
[17:43:56.235]         base::sink(type = "output", split = FALSE)
[17:43:56.235]         if (TRUE) {
[17:43:56.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.235]         }
[17:43:56.235]         else {
[17:43:56.235]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.235]         }
[17:43:56.235]         base::close(...future.stdout)
[17:43:56.235]         ...future.stdout <- NULL
[17:43:56.235]     }
[17:43:56.235]     ...future.result$conditions <- ...future.conditions
[17:43:56.235]     ...future.result$finished <- base::Sys.time()
[17:43:56.235]     ...future.result
[17:43:56.235] }
[17:43:56.237] assign_globals() ...
[17:43:56.237] List of 5
[17:43:56.237]  $ ...future.FUN            :function (x, ...)  
[17:43:56.237]  $ future.call.arguments    : list()
[17:43:56.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.237]  $ ...future.elements_ii    :List of 1
[17:43:56.237]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:43:56.237]  $ ...future.seeds_ii       : NULL
[17:43:56.237]  $ ...future.globals.maxSize: NULL
[17:43:56.237]  - attr(*, "where")=List of 5
[17:43:56.237]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:56.237]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:56.237]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:56.237]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:56.237]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:56.237]  - attr(*, "resolved")= logi FALSE
[17:43:56.237]  - attr(*, "total_size")= num 1248
[17:43:56.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.237]  - attr(*, "already-done")= logi TRUE
[17:43:56.242] - copied ‘...future.FUN’ to environment
[17:43:56.242] - copied ‘future.call.arguments’ to environment
[17:43:56.242] - copied ‘...future.elements_ii’ to environment
[17:43:56.242] - copied ‘...future.seeds_ii’ to environment
[17:43:56.242] - copied ‘...future.globals.maxSize’ to environment
[17:43:56.242] assign_globals() ... done
[17:43:56.243] requestCore(): workers = 2
[17:43:56.245] MulticoreFuture started
[17:43:56.245] - Launch lazy future ... done
[17:43:56.245] run() for ‘MulticoreFuture’ ... done
[17:43:56.245] Created future:
[17:43:56.246] plan(): Setting new future strategy stack:
[17:43:56.246] List of future strategies:
[17:43:56.246] 1. sequential:
[17:43:56.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.246]    - tweaked: FALSE
[17:43:56.246]    - call: NULL
[17:43:56.247] plan(): nbrOfWorkers() = 1
[17:43:56.249] plan(): Setting new future strategy stack:
[17:43:56.250] List of future strategies:
[17:43:56.250] 1. multicore:
[17:43:56.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:56.250]    - tweaked: FALSE
[17:43:56.250]    - call: plan(strategy)
[17:43:56.255] plan(): nbrOfWorkers() = 2
[17:43:56.246] MulticoreFuture:
[17:43:56.246] Label: ‘future_eapply-1’
[17:43:56.246] Expression:
[17:43:56.246] {
[17:43:56.246]     do.call(function(...) {
[17:43:56.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.246]             on.exit(options(oopts), add = TRUE)
[17:43:56.246]         }
[17:43:56.246]         {
[17:43:56.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.246]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.246]             })
[17:43:56.246]         }
[17:43:56.246]     }, args = future.call.arguments)
[17:43:56.246] }
[17:43:56.246] Lazy evaluation: FALSE
[17:43:56.246] Asynchronous evaluation: TRUE
[17:43:56.246] Local evaluation: TRUE
[17:43:56.246] Environment: R_GlobalEnv
[17:43:56.246] Capture standard output: TRUE
[17:43:56.246] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.246] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.246] Packages: 1 packages (‘stats’)
[17:43:56.246] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.246] Resolved: TRUE
[17:43:56.246] Value: <not collected>
[17:43:56.246] Conditions captured: <none>
[17:43:56.246] Early signaling: FALSE
[17:43:56.246] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.246] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.256] Chunk #1 of 2 ... DONE
[17:43:56.256] Chunk #2 of 2 ...
[17:43:56.256]  - Finding globals in 'X' for chunk #2 ...
[17:43:56.256] getGlobalsAndPackages() ...
[17:43:56.256] Searching for globals...
[17:43:56.257] 
[17:43:56.257] Searching for globals ... DONE
[17:43:56.257] - globals: [0] <none>
[17:43:56.257] getGlobalsAndPackages() ... DONE
[17:43:56.257]    + additional globals found: [n=0] 
[17:43:56.257]    + additional namespaces needed: [n=0] 
[17:43:56.257]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:56.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.258]  - seeds: <none>
[17:43:56.258]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.258] getGlobalsAndPackages() ...
[17:43:56.258] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.258] Resolving globals: FALSE
[17:43:56.258] Tweak future expression to call with '...' arguments ...
[17:43:56.259] {
[17:43:56.259]     do.call(function(...) {
[17:43:56.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.259]             on.exit(options(oopts), add = TRUE)
[17:43:56.259]         }
[17:43:56.259]         {
[17:43:56.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.259]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.259]             })
[17:43:56.259]         }
[17:43:56.259]     }, args = future.call.arguments)
[17:43:56.259] }
[17:43:56.259] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.260] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.260] - packages: [1] ‘stats’
[17:43:56.260] getGlobalsAndPackages() ... DONE
[17:43:56.260] run() for ‘Future’ ...
[17:43:56.261] - state: ‘created’
[17:43:56.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:56.266]   - Field: ‘label’
[17:43:56.266]   - Field: ‘local’
[17:43:56.266]   - Field: ‘owner’
[17:43:56.266]   - Field: ‘envir’
[17:43:56.266]   - Field: ‘workers’
[17:43:56.266]   - Field: ‘packages’
[17:43:56.266]   - Field: ‘gc’
[17:43:56.266]   - Field: ‘job’
[17:43:56.267]   - Field: ‘conditions’
[17:43:56.267]   - Field: ‘expr’
[17:43:56.267]   - Field: ‘uuid’
[17:43:56.267]   - Field: ‘seed’
[17:43:56.267]   - Field: ‘version’
[17:43:56.267]   - Field: ‘result’
[17:43:56.267]   - Field: ‘asynchronous’
[17:43:56.268]   - Field: ‘calls’
[17:43:56.268]   - Field: ‘globals’
[17:43:56.268]   - Field: ‘stdout’
[17:43:56.268]   - Field: ‘earlySignal’
[17:43:56.268]   - Field: ‘lazy’
[17:43:56.268]   - Field: ‘state’
[17:43:56.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:56.268] - Launch lazy future ...
[17:43:56.269] Packages needed by the future expression (n = 1): ‘stats’
[17:43:56.269] Packages needed by future strategies (n = 0): <none>
[17:43:56.270] {
[17:43:56.270]     {
[17:43:56.270]         {
[17:43:56.270]             ...future.startTime <- base::Sys.time()
[17:43:56.270]             {
[17:43:56.270]                 {
[17:43:56.270]                   {
[17:43:56.270]                     {
[17:43:56.270]                       {
[17:43:56.270]                         base::local({
[17:43:56.270]                           has_future <- base::requireNamespace("future", 
[17:43:56.270]                             quietly = TRUE)
[17:43:56.270]                           if (has_future) {
[17:43:56.270]                             ns <- base::getNamespace("future")
[17:43:56.270]                             version <- ns[[".package"]][["version"]]
[17:43:56.270]                             if (is.null(version)) 
[17:43:56.270]                               version <- utils::packageVersion("future")
[17:43:56.270]                           }
[17:43:56.270]                           else {
[17:43:56.270]                             version <- NULL
[17:43:56.270]                           }
[17:43:56.270]                           if (!has_future || version < "1.8.0") {
[17:43:56.270]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.270]                               "", base::R.version$version.string), 
[17:43:56.270]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:56.270]                                 base::R.version$platform, 8 * 
[17:43:56.270]                                   base::.Machine$sizeof.pointer), 
[17:43:56.270]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.270]                                 "release", "version")], collapse = " "), 
[17:43:56.270]                               hostname = base::Sys.info()[["nodename"]])
[17:43:56.270]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.270]                               info)
[17:43:56.270]                             info <- base::paste(info, collapse = "; ")
[17:43:56.270]                             if (!has_future) {
[17:43:56.270]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.270]                                 info)
[17:43:56.270]                             }
[17:43:56.270]                             else {
[17:43:56.270]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.270]                                 info, version)
[17:43:56.270]                             }
[17:43:56.270]                             base::stop(msg)
[17:43:56.270]                           }
[17:43:56.270]                         })
[17:43:56.270]                       }
[17:43:56.270]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.270]                       base::options(mc.cores = 1L)
[17:43:56.270]                     }
[17:43:56.270]                     base::local({
[17:43:56.270]                       for (pkg in "stats") {
[17:43:56.270]                         base::loadNamespace(pkg)
[17:43:56.270]                         base::library(pkg, character.only = TRUE)
[17:43:56.270]                       }
[17:43:56.270]                     })
[17:43:56.270]                   }
[17:43:56.270]                   ...future.strategy.old <- future::plan("list")
[17:43:56.270]                   options(future.plan = NULL)
[17:43:56.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.270]                 }
[17:43:56.270]                 ...future.workdir <- getwd()
[17:43:56.270]             }
[17:43:56.270]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.270]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.270]         }
[17:43:56.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.270]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.270]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.270]             base::names(...future.oldOptions))
[17:43:56.270]     }
[17:43:56.270]     if (FALSE) {
[17:43:56.270]     }
[17:43:56.270]     else {
[17:43:56.270]         if (TRUE) {
[17:43:56.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.270]                 open = "w")
[17:43:56.270]         }
[17:43:56.270]         else {
[17:43:56.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.270]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.270]         }
[17:43:56.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.270]             base::sink(type = "output", split = FALSE)
[17:43:56.270]             base::close(...future.stdout)
[17:43:56.270]         }, add = TRUE)
[17:43:56.270]     }
[17:43:56.270]     ...future.frame <- base::sys.nframe()
[17:43:56.270]     ...future.conditions <- base::list()
[17:43:56.270]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.270]     if (FALSE) {
[17:43:56.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.270]     }
[17:43:56.270]     ...future.result <- base::tryCatch({
[17:43:56.270]         base::withCallingHandlers({
[17:43:56.270]             ...future.value <- base::withVisible(base::local({
[17:43:56.270]                 withCallingHandlers({
[17:43:56.270]                   {
[17:43:56.270]                     do.call(function(...) {
[17:43:56.270]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.270]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.270]                         ...future.globals.maxSize)) {
[17:43:56.270]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.270]                         on.exit(options(oopts), add = TRUE)
[17:43:56.270]                       }
[17:43:56.270]                       {
[17:43:56.270]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.270]                           FUN = function(jj) {
[17:43:56.270]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.270]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.270]                           })
[17:43:56.270]                       }
[17:43:56.270]                     }, args = future.call.arguments)
[17:43:56.270]                   }
[17:43:56.270]                 }, immediateCondition = function(cond) {
[17:43:56.270]                   save_rds <- function (object, pathname, ...) 
[17:43:56.270]                   {
[17:43:56.270]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:56.270]                     if (file_test("-f", pathname_tmp)) {
[17:43:56.270]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.270]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:56.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.270]                         fi_tmp[["mtime"]])
[17:43:56.270]                     }
[17:43:56.270]                     tryCatch({
[17:43:56.270]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:56.270]                     }, error = function(ex) {
[17:43:56.270]                       msg <- conditionMessage(ex)
[17:43:56.270]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.270]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:56.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.270]                         fi_tmp[["mtime"]], msg)
[17:43:56.270]                       ex$message <- msg
[17:43:56.270]                       stop(ex)
[17:43:56.270]                     })
[17:43:56.270]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:56.270]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:56.270]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:56.270]                       fi_tmp <- file.info(pathname_tmp)
[17:43:56.270]                       fi <- file.info(pathname)
[17:43:56.270]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:56.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:56.270]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:56.270]                         fi[["size"]], fi[["mtime"]])
[17:43:56.270]                       stop(msg)
[17:43:56.270]                     }
[17:43:56.270]                     invisible(pathname)
[17:43:56.270]                   }
[17:43:56.270]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:56.270]                     rootPath = tempdir()) 
[17:43:56.270]                   {
[17:43:56.270]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:56.270]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:56.270]                       tmpdir = path, fileext = ".rds")
[17:43:56.270]                     save_rds(obj, file)
[17:43:56.270]                   }
[17:43:56.270]                   saveImmediateCondition(cond, path = "/tmp/RtmpzdXoYb/.future/immediateConditions")
[17:43:56.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.270]                   {
[17:43:56.270]                     inherits <- base::inherits
[17:43:56.270]                     invokeRestart <- base::invokeRestart
[17:43:56.270]                     is.null <- base::is.null
[17:43:56.270]                     muffled <- FALSE
[17:43:56.270]                     if (inherits(cond, "message")) {
[17:43:56.270]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.270]                       if (muffled) 
[17:43:56.270]                         invokeRestart("muffleMessage")
[17:43:56.270]                     }
[17:43:56.270]                     else if (inherits(cond, "warning")) {
[17:43:56.270]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.270]                       if (muffled) 
[17:43:56.270]                         invokeRestart("muffleWarning")
[17:43:56.270]                     }
[17:43:56.270]                     else if (inherits(cond, "condition")) {
[17:43:56.270]                       if (!is.null(pattern)) {
[17:43:56.270]                         computeRestarts <- base::computeRestarts
[17:43:56.270]                         grepl <- base::grepl
[17:43:56.270]                         restarts <- computeRestarts(cond)
[17:43:56.270]                         for (restart in restarts) {
[17:43:56.270]                           name <- restart$name
[17:43:56.270]                           if (is.null(name)) 
[17:43:56.270]                             next
[17:43:56.270]                           if (!grepl(pattern, name)) 
[17:43:56.270]                             next
[17:43:56.270]                           invokeRestart(restart)
[17:43:56.270]                           muffled <- TRUE
[17:43:56.270]                           break
[17:43:56.270]                         }
[17:43:56.270]                       }
[17:43:56.270]                     }
[17:43:56.270]                     invisible(muffled)
[17:43:56.270]                   }
[17:43:56.270]                   muffleCondition(cond)
[17:43:56.270]                 })
[17:43:56.270]             }))
[17:43:56.270]             future::FutureResult(value = ...future.value$value, 
[17:43:56.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.270]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.270]                     ...future.globalenv.names))
[17:43:56.270]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.270]         }, condition = base::local({
[17:43:56.270]             c <- base::c
[17:43:56.270]             inherits <- base::inherits
[17:43:56.270]             invokeRestart <- base::invokeRestart
[17:43:56.270]             length <- base::length
[17:43:56.270]             list <- base::list
[17:43:56.270]             seq.int <- base::seq.int
[17:43:56.270]             signalCondition <- base::signalCondition
[17:43:56.270]             sys.calls <- base::sys.calls
[17:43:56.270]             `[[` <- base::`[[`
[17:43:56.270]             `+` <- base::`+`
[17:43:56.270]             `<<-` <- base::`<<-`
[17:43:56.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.270]                   3L)]
[17:43:56.270]             }
[17:43:56.270]             function(cond) {
[17:43:56.270]                 is_error <- inherits(cond, "error")
[17:43:56.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.270]                   NULL)
[17:43:56.270]                 if (is_error) {
[17:43:56.270]                   sessionInformation <- function() {
[17:43:56.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.270]                       search = base::search(), system = base::Sys.info())
[17:43:56.270]                   }
[17:43:56.270]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.270]                     cond$call), session = sessionInformation(), 
[17:43:56.270]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.270]                   signalCondition(cond)
[17:43:56.270]                 }
[17:43:56.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.270]                 "immediateCondition"))) {
[17:43:56.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.270]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.270]                   if (TRUE && !signal) {
[17:43:56.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.270]                     {
[17:43:56.270]                       inherits <- base::inherits
[17:43:56.270]                       invokeRestart <- base::invokeRestart
[17:43:56.270]                       is.null <- base::is.null
[17:43:56.270]                       muffled <- FALSE
[17:43:56.270]                       if (inherits(cond, "message")) {
[17:43:56.270]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.270]                         if (muffled) 
[17:43:56.270]                           invokeRestart("muffleMessage")
[17:43:56.270]                       }
[17:43:56.270]                       else if (inherits(cond, "warning")) {
[17:43:56.270]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.270]                         if (muffled) 
[17:43:56.270]                           invokeRestart("muffleWarning")
[17:43:56.270]                       }
[17:43:56.270]                       else if (inherits(cond, "condition")) {
[17:43:56.270]                         if (!is.null(pattern)) {
[17:43:56.270]                           computeRestarts <- base::computeRestarts
[17:43:56.270]                           grepl <- base::grepl
[17:43:56.270]                           restarts <- computeRestarts(cond)
[17:43:56.270]                           for (restart in restarts) {
[17:43:56.270]                             name <- restart$name
[17:43:56.270]                             if (is.null(name)) 
[17:43:56.270]                               next
[17:43:56.270]                             if (!grepl(pattern, name)) 
[17:43:56.270]                               next
[17:43:56.270]                             invokeRestart(restart)
[17:43:56.270]                             muffled <- TRUE
[17:43:56.270]                             break
[17:43:56.270]                           }
[17:43:56.270]                         }
[17:43:56.270]                       }
[17:43:56.270]                       invisible(muffled)
[17:43:56.270]                     }
[17:43:56.270]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.270]                   }
[17:43:56.270]                 }
[17:43:56.270]                 else {
[17:43:56.270]                   if (TRUE) {
[17:43:56.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.270]                     {
[17:43:56.270]                       inherits <- base::inherits
[17:43:56.270]                       invokeRestart <- base::invokeRestart
[17:43:56.270]                       is.null <- base::is.null
[17:43:56.270]                       muffled <- FALSE
[17:43:56.270]                       if (inherits(cond, "message")) {
[17:43:56.270]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.270]                         if (muffled) 
[17:43:56.270]                           invokeRestart("muffleMessage")
[17:43:56.270]                       }
[17:43:56.270]                       else if (inherits(cond, "warning")) {
[17:43:56.270]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.270]                         if (muffled) 
[17:43:56.270]                           invokeRestart("muffleWarning")
[17:43:56.270]                       }
[17:43:56.270]                       else if (inherits(cond, "condition")) {
[17:43:56.270]                         if (!is.null(pattern)) {
[17:43:56.270]                           computeRestarts <- base::computeRestarts
[17:43:56.270]                           grepl <- base::grepl
[17:43:56.270]                           restarts <- computeRestarts(cond)
[17:43:56.270]                           for (restart in restarts) {
[17:43:56.270]                             name <- restart$name
[17:43:56.270]                             if (is.null(name)) 
[17:43:56.270]                               next
[17:43:56.270]                             if (!grepl(pattern, name)) 
[17:43:56.270]                               next
[17:43:56.270]                             invokeRestart(restart)
[17:43:56.270]                             muffled <- TRUE
[17:43:56.270]                             break
[17:43:56.270]                           }
[17:43:56.270]                         }
[17:43:56.270]                       }
[17:43:56.270]                       invisible(muffled)
[17:43:56.270]                     }
[17:43:56.270]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.270]                   }
[17:43:56.270]                 }
[17:43:56.270]             }
[17:43:56.270]         }))
[17:43:56.270]     }, error = function(ex) {
[17:43:56.270]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.270]                 ...future.rng), started = ...future.startTime, 
[17:43:56.270]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.270]             version = "1.8"), class = "FutureResult")
[17:43:56.270]     }, finally = {
[17:43:56.270]         if (!identical(...future.workdir, getwd())) 
[17:43:56.270]             setwd(...future.workdir)
[17:43:56.270]         {
[17:43:56.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.270]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.270]             }
[17:43:56.270]             base::options(...future.oldOptions)
[17:43:56.270]             if (.Platform$OS.type == "windows") {
[17:43:56.270]                 old_names <- names(...future.oldEnvVars)
[17:43:56.270]                 envs <- base::Sys.getenv()
[17:43:56.270]                 names <- names(envs)
[17:43:56.270]                 common <- intersect(names, old_names)
[17:43:56.270]                 added <- setdiff(names, old_names)
[17:43:56.270]                 removed <- setdiff(old_names, names)
[17:43:56.270]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.270]                   envs[common]]
[17:43:56.270]                 NAMES <- toupper(changed)
[17:43:56.270]                 args <- list()
[17:43:56.270]                 for (kk in seq_along(NAMES)) {
[17:43:56.270]                   name <- changed[[kk]]
[17:43:56.270]                   NAME <- NAMES[[kk]]
[17:43:56.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.270]                     next
[17:43:56.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.270]                 }
[17:43:56.270]                 NAMES <- toupper(added)
[17:43:56.270]                 for (kk in seq_along(NAMES)) {
[17:43:56.270]                   name <- added[[kk]]
[17:43:56.270]                   NAME <- NAMES[[kk]]
[17:43:56.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.270]                     next
[17:43:56.270]                   args[[name]] <- ""
[17:43:56.270]                 }
[17:43:56.270]                 NAMES <- toupper(removed)
[17:43:56.270]                 for (kk in seq_along(NAMES)) {
[17:43:56.270]                   name <- removed[[kk]]
[17:43:56.270]                   NAME <- NAMES[[kk]]
[17:43:56.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.270]                     next
[17:43:56.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.270]                 }
[17:43:56.270]                 if (length(args) > 0) 
[17:43:56.270]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.270]             }
[17:43:56.270]             else {
[17:43:56.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.270]             }
[17:43:56.270]             {
[17:43:56.270]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.270]                   0L) {
[17:43:56.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.270]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.270]                   base::options(opts)
[17:43:56.270]                 }
[17:43:56.270]                 {
[17:43:56.270]                   {
[17:43:56.270]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.270]                     NULL
[17:43:56.270]                   }
[17:43:56.270]                   options(future.plan = NULL)
[17:43:56.270]                   if (is.na(NA_character_)) 
[17:43:56.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.270]                     .init = FALSE)
[17:43:56.270]                 }
[17:43:56.270]             }
[17:43:56.270]         }
[17:43:56.270]     })
[17:43:56.270]     if (TRUE) {
[17:43:56.270]         base::sink(type = "output", split = FALSE)
[17:43:56.270]         if (TRUE) {
[17:43:56.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.270]         }
[17:43:56.270]         else {
[17:43:56.270]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.270]         }
[17:43:56.270]         base::close(...future.stdout)
[17:43:56.270]         ...future.stdout <- NULL
[17:43:56.270]     }
[17:43:56.270]     ...future.result$conditions <- ...future.conditions
[17:43:56.270]     ...future.result$finished <- base::Sys.time()
[17:43:56.270]     ...future.result
[17:43:56.270] }
[17:43:56.273] assign_globals() ...
[17:43:56.273] List of 5
[17:43:56.273]  $ ...future.FUN            :function (x, ...)  
[17:43:56.273]  $ future.call.arguments    : list()
[17:43:56.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.273]  $ ...future.elements_ii    :List of 2
[17:43:56.273]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:43:56.273]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:43:56.273]  $ ...future.seeds_ii       : NULL
[17:43:56.273]  $ ...future.globals.maxSize: NULL
[17:43:56.273]  - attr(*, "where")=List of 5
[17:43:56.273]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:56.273]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:56.273]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:56.273]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:56.273]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:56.273]  - attr(*, "resolved")= logi FALSE
[17:43:56.273]  - attr(*, "total_size")= num 1248
[17:43:56.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.273]  - attr(*, "already-done")= logi TRUE
[17:43:56.284] - copied ‘...future.FUN’ to environment
[17:43:56.284] - copied ‘future.call.arguments’ to environment
[17:43:56.284] - copied ‘...future.elements_ii’ to environment
[17:43:56.285] - copied ‘...future.seeds_ii’ to environment
[17:43:56.285] - copied ‘...future.globals.maxSize’ to environment
[17:43:56.285] assign_globals() ... done
[17:43:56.285] requestCore(): workers = 2
[17:43:56.287] MulticoreFuture started
[17:43:56.288] - Launch lazy future ... done
[17:43:56.288] run() for ‘MulticoreFuture’ ... done
[17:43:56.288] Created future:
[17:43:56.289] plan(): Setting new future strategy stack:
[17:43:56.289] List of future strategies:
[17:43:56.289] 1. sequential:
[17:43:56.289]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.289]    - tweaked: FALSE
[17:43:56.289]    - call: NULL
[17:43:56.290] plan(): nbrOfWorkers() = 1
[17:43:56.293] plan(): Setting new future strategy stack:
[17:43:56.293] List of future strategies:
[17:43:56.293] 1. multicore:
[17:43:56.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:56.293]    - tweaked: FALSE
[17:43:56.293]    - call: plan(strategy)
[17:43:56.298] plan(): nbrOfWorkers() = 2
[17:43:56.288] MulticoreFuture:
[17:43:56.288] Label: ‘future_eapply-2’
[17:43:56.288] Expression:
[17:43:56.288] {
[17:43:56.288]     do.call(function(...) {
[17:43:56.288]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.288]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.288]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.288]             on.exit(options(oopts), add = TRUE)
[17:43:56.288]         }
[17:43:56.288]         {
[17:43:56.288]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.288]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.288]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.288]             })
[17:43:56.288]         }
[17:43:56.288]     }, args = future.call.arguments)
[17:43:56.288] }
[17:43:56.288] Lazy evaluation: FALSE
[17:43:56.288] Asynchronous evaluation: TRUE
[17:43:56.288] Local evaluation: TRUE
[17:43:56.288] Environment: R_GlobalEnv
[17:43:56.288] Capture standard output: TRUE
[17:43:56.288] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.288] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.288] Packages: 1 packages (‘stats’)
[17:43:56.288] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.288] Resolved: TRUE
[17:43:56.288] Value: <not collected>
[17:43:56.288] Conditions captured: <none>
[17:43:56.288] Early signaling: FALSE
[17:43:56.288] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.288] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.299] Chunk #2 of 2 ... DONE
[17:43:56.299] Launching 2 futures (chunks) ... DONE
[17:43:56.300] Resolving 2 futures (chunks) ...
[17:43:56.300] resolve() on list ...
[17:43:56.300]  recursive: 0
[17:43:56.300]  length: 2
[17:43:56.300] 
[17:43:56.301] Future #1
[17:43:56.301] result() for MulticoreFuture ...
[17:43:56.302] result() for MulticoreFuture ...
[17:43:56.302] result() for MulticoreFuture ... done
[17:43:56.302] result() for MulticoreFuture ... done
[17:43:56.302] result() for MulticoreFuture ...
[17:43:56.302] result() for MulticoreFuture ... done
[17:43:56.303] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:56.303] - nx: 2
[17:43:56.303] - relay: TRUE
[17:43:56.303] - stdout: TRUE
[17:43:56.303] - signal: TRUE
[17:43:56.303] - resignal: FALSE
[17:43:56.303] - force: TRUE
[17:43:56.303] - relayed: [n=2] FALSE, FALSE
[17:43:56.304] - queued futures: [n=2] FALSE, FALSE
[17:43:56.304]  - until=1
[17:43:56.304]  - relaying element #1
[17:43:56.304] result() for MulticoreFuture ...
[17:43:56.304] result() for MulticoreFuture ... done
[17:43:56.304] result() for MulticoreFuture ...
[17:43:56.304] result() for MulticoreFuture ... done
[17:43:56.305] result() for MulticoreFuture ...
[17:43:56.305] result() for MulticoreFuture ... done
[17:43:56.305] result() for MulticoreFuture ...
[17:43:56.305] result() for MulticoreFuture ... done
[17:43:56.305] - relayed: [n=2] TRUE, FALSE
[17:43:56.305] - queued futures: [n=2] TRUE, FALSE
[17:43:56.306] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:56.306]  length: 1 (resolved future 1)
[17:43:56.306] Future #2
[17:43:56.306] result() for MulticoreFuture ...
[17:43:56.307] result() for MulticoreFuture ...
[17:43:56.307] result() for MulticoreFuture ... done
[17:43:56.307] result() for MulticoreFuture ... done
[17:43:56.307] result() for MulticoreFuture ...
[17:43:56.308] result() for MulticoreFuture ... done
[17:43:56.308] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:56.308] - nx: 2
[17:43:56.308] - relay: TRUE
[17:43:56.308] - stdout: TRUE
[17:43:56.308] - signal: TRUE
[17:43:56.308] - resignal: FALSE
[17:43:56.308] - force: TRUE
[17:43:56.309] - relayed: [n=2] TRUE, FALSE
[17:43:56.309] - queued futures: [n=2] TRUE, FALSE
[17:43:56.309]  - until=2
[17:43:56.309]  - relaying element #2
[17:43:56.309] result() for MulticoreFuture ...
[17:43:56.309] result() for MulticoreFuture ... done
[17:43:56.309] result() for MulticoreFuture ...
[17:43:56.309] result() for MulticoreFuture ... done
[17:43:56.310] result() for MulticoreFuture ...
[17:43:56.310] result() for MulticoreFuture ... done
[17:43:56.310] result() for MulticoreFuture ...
[17:43:56.310] result() for MulticoreFuture ... done
[17:43:56.310] - relayed: [n=2] TRUE, TRUE
[17:43:56.310] - queued futures: [n=2] TRUE, TRUE
[17:43:56.310] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:56.310]  length: 0 (resolved future 2)
[17:43:56.310] Relaying remaining futures
[17:43:56.311] signalConditionsASAP(NULL, pos=0) ...
[17:43:56.311] - nx: 2
[17:43:56.311] - relay: TRUE
[17:43:56.311] - stdout: TRUE
[17:43:56.311] - signal: TRUE
[17:43:56.311] - resignal: FALSE
[17:43:56.311] - force: TRUE
[17:43:56.311] - relayed: [n=2] TRUE, TRUE
[17:43:56.311] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:56.312] - relayed: [n=2] TRUE, TRUE
[17:43:56.312] - queued futures: [n=2] TRUE, TRUE
[17:43:56.312] signalConditionsASAP(NULL, pos=0) ... done
[17:43:56.312] resolve() on list ... DONE
[17:43:56.312] result() for MulticoreFuture ...
[17:43:56.312] result() for MulticoreFuture ... done
[17:43:56.312] result() for MulticoreFuture ...
[17:43:56.312] result() for MulticoreFuture ... done
[17:43:56.312] result() for MulticoreFuture ...
[17:43:56.313] result() for MulticoreFuture ... done
[17:43:56.313] result() for MulticoreFuture ...
[17:43:56.313] result() for MulticoreFuture ... done
[17:43:56.313]  - Number of value chunks collected: 2
[17:43:56.313] Resolving 2 futures (chunks) ... DONE
[17:43:56.313] Reducing values from 2 chunks ...
[17:43:56.313]  - Number of values collected after concatenation: 3
[17:43:56.313]  - Number of values expected: 3
[17:43:56.313] Reducing values from 2 chunks ... DONE
[17:43:56.314] future_lapply() ... DONE
[17:43:56.314] plan(): Setting new future strategy stack:
[17:43:56.314] List of future strategies:
[17:43:56.314] 1. sequential:
[17:43:56.314]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:56.314]    - tweaked: FALSE
[17:43:56.314]    - call: plan(sequential)
[17:43:56.315] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:43:56.315] plan(): Setting new future strategy stack:
[17:43:56.315] List of future strategies:
[17:43:56.315] 1. multisession:
[17:43:56.315]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:56.315]    - tweaked: FALSE
[17:43:56.315]    - call: plan(strategy)
[17:43:56.316] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:56.316] multisession:
[17:43:56.316] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:56.316] - tweaked: FALSE
[17:43:56.316] - call: plan(strategy)
[17:43:56.322] getGlobalsAndPackages() ...
[17:43:56.322] Not searching for globals
[17:43:56.322] - globals: [0] <none>
[17:43:56.323] getGlobalsAndPackages() ... DONE
[17:43:56.323] [local output] makeClusterPSOCK() ...
[17:43:56.370] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:56.371] [local output] Base port: 11700
[17:43:56.371] [local output] Getting setup options for 2 cluster nodes ...
[17:43:56.371] [local output]  - Node 1 of 2 ...
[17:43:56.372] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:56.372] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzdXoYb/worker.rank=1.parallelly.parent=29082.719a34c3bf84.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpzdXoYb/worker.rank=1.parallelly.parent=29082.719a34c3bf84.pid")'’
[17:43:56.559] - Possible to infer worker's PID: TRUE
[17:43:56.559] [local output] Rscript port: 11700

[17:43:56.560] [local output]  - Node 2 of 2 ...
[17:43:56.560] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:56.561] [local output] Rscript port: 11700

[17:43:56.561] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:56.561] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:56.562] [local output] Setting up PSOCK nodes in parallel
[17:43:56.562] List of 36
[17:43:56.562]  $ worker          : chr "localhost"
[17:43:56.562]   ..- attr(*, "localhost")= logi TRUE
[17:43:56.562]  $ master          : chr "localhost"
[17:43:56.562]  $ port            : int 11700
[17:43:56.562]  $ connectTimeout  : num 120
[17:43:56.562]  $ timeout         : num 2592000
[17:43:56.562]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:56.562]  $ homogeneous     : logi TRUE
[17:43:56.562]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:56.562]  $ rscript_envs    : NULL
[17:43:56.562]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:56.562]  $ rscript_startup : NULL
[17:43:56.562]  $ rscript_sh      : chr "sh"
[17:43:56.562]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:56.562]  $ methods         : logi TRUE
[17:43:56.562]  $ socketOptions   : chr "no-delay"
[17:43:56.562]  $ useXDR          : logi FALSE
[17:43:56.562]  $ outfile         : chr "/dev/null"
[17:43:56.562]  $ renice          : int NA
[17:43:56.562]  $ rshcmd          : NULL
[17:43:56.562]  $ user            : chr(0) 
[17:43:56.562]  $ revtunnel       : logi FALSE
[17:43:56.562]  $ rshlogfile      : NULL
[17:43:56.562]  $ rshopts         : chr(0) 
[17:43:56.562]  $ rank            : int 1
[17:43:56.562]  $ manual          : logi FALSE
[17:43:56.562]  $ dryrun          : logi FALSE
[17:43:56.562]  $ quiet           : logi FALSE
[17:43:56.562]  $ setup_strategy  : chr "parallel"
[17:43:56.562]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:56.562]  $ pidfile         : chr "/tmp/RtmpzdXoYb/worker.rank=1.parallelly.parent=29082.719a34c3bf84.pid"
[17:43:56.562]  $ rshcmd_label    : NULL
[17:43:56.562]  $ rsh_call        : NULL
[17:43:56.562]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:56.562]  $ localMachine    : logi TRUE
[17:43:56.562]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:56.562]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:56.562]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:56.562]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:56.562]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:56.562]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:56.562]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:56.562]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:56.562]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:56.562]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:56.562]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:56.562]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:56.562]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:56.562]  $ arguments       :List of 28
[17:43:56.562]   ..$ worker          : chr "localhost"
[17:43:56.562]   ..$ master          : NULL
[17:43:56.562]   ..$ port            : int 11700
[17:43:56.562]   ..$ connectTimeout  : num 120
[17:43:56.562]   ..$ timeout         : num 2592000
[17:43:56.562]   ..$ rscript         : NULL
[17:43:56.562]   ..$ homogeneous     : NULL
[17:43:56.562]   ..$ rscript_args    : NULL
[17:43:56.562]   ..$ rscript_envs    : NULL
[17:43:56.562]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:56.562]   ..$ rscript_startup : NULL
[17:43:56.562]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:56.562]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:56.562]   ..$ methods         : logi TRUE
[17:43:56.562]   ..$ socketOptions   : chr "no-delay"
[17:43:56.562]   ..$ useXDR          : logi FALSE
[17:43:56.562]   ..$ outfile         : chr "/dev/null"
[17:43:56.562]   ..$ renice          : int NA
[17:43:56.562]   ..$ rshcmd          : NULL
[17:43:56.562]   ..$ user            : NULL
[17:43:56.562]   ..$ revtunnel       : logi NA
[17:43:56.562]   ..$ rshlogfile      : NULL
[17:43:56.562]   ..$ rshopts         : NULL
[17:43:56.562]   ..$ rank            : int 1
[17:43:56.562]   ..$ manual          : logi FALSE
[17:43:56.562]   ..$ dryrun          : logi FALSE
[17:43:56.562]   ..$ quiet           : logi FALSE
[17:43:56.562]   ..$ setup_strategy  : chr "parallel"
[17:43:56.562]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:56.578] [local output] System call to launch all workers:
[17:43:56.578] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpzdXoYb/worker.rank=1.parallelly.parent=29082.719a34c3bf84.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11700 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:56.578] [local output] Starting PSOCK main server
[17:43:56.584] [local output] Workers launched
[17:43:56.584] [local output] Waiting for workers to connect back
[17:43:56.584]  - [local output] 0 workers out of 2 ready
[17:43:56.822]  - [local output] 0 workers out of 2 ready
[17:43:56.823]  - [local output] 1 workers out of 2 ready
[17:43:56.830]  - [local output] 1 workers out of 2 ready
[17:43:56.830]  - [local output] 2 workers out of 2 ready
[17:43:56.830] [local output] Launching of workers completed
[17:43:56.831] [local output] Collecting session information from workers
[17:43:56.832] [local output]  - Worker #1 of 2
[17:43:56.832] [local output]  - Worker #2 of 2
[17:43:56.832] [local output] makeClusterPSOCK() ... done
[17:43:56.843] Packages needed by the future expression (n = 0): <none>
[17:43:56.844] Packages needed by future strategies (n = 0): <none>
[17:43:56.844] {
[17:43:56.844]     {
[17:43:56.844]         {
[17:43:56.844]             ...future.startTime <- base::Sys.time()
[17:43:56.844]             {
[17:43:56.844]                 {
[17:43:56.844]                   {
[17:43:56.844]                     {
[17:43:56.844]                       base::local({
[17:43:56.844]                         has_future <- base::requireNamespace("future", 
[17:43:56.844]                           quietly = TRUE)
[17:43:56.844]                         if (has_future) {
[17:43:56.844]                           ns <- base::getNamespace("future")
[17:43:56.844]                           version <- ns[[".package"]][["version"]]
[17:43:56.844]                           if (is.null(version)) 
[17:43:56.844]                             version <- utils::packageVersion("future")
[17:43:56.844]                         }
[17:43:56.844]                         else {
[17:43:56.844]                           version <- NULL
[17:43:56.844]                         }
[17:43:56.844]                         if (!has_future || version < "1.8.0") {
[17:43:56.844]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.844]                             "", base::R.version$version.string), 
[17:43:56.844]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:56.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:56.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.844]                               "release", "version")], collapse = " "), 
[17:43:56.844]                             hostname = base::Sys.info()[["nodename"]])
[17:43:56.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.844]                             info)
[17:43:56.844]                           info <- base::paste(info, collapse = "; ")
[17:43:56.844]                           if (!has_future) {
[17:43:56.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.844]                               info)
[17:43:56.844]                           }
[17:43:56.844]                           else {
[17:43:56.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.844]                               info, version)
[17:43:56.844]                           }
[17:43:56.844]                           base::stop(msg)
[17:43:56.844]                         }
[17:43:56.844]                       })
[17:43:56.844]                     }
[17:43:56.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.844]                     base::options(mc.cores = 1L)
[17:43:56.844]                   }
[17:43:56.844]                   ...future.strategy.old <- future::plan("list")
[17:43:56.844]                   options(future.plan = NULL)
[17:43:56.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.844]                 }
[17:43:56.844]                 ...future.workdir <- getwd()
[17:43:56.844]             }
[17:43:56.844]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.844]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.844]         }
[17:43:56.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:56.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.844]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.844]             base::names(...future.oldOptions))
[17:43:56.844]     }
[17:43:56.844]     if (FALSE) {
[17:43:56.844]     }
[17:43:56.844]     else {
[17:43:56.844]         if (TRUE) {
[17:43:56.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.844]                 open = "w")
[17:43:56.844]         }
[17:43:56.844]         else {
[17:43:56.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.844]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.844]         }
[17:43:56.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.844]             base::sink(type = "output", split = FALSE)
[17:43:56.844]             base::close(...future.stdout)
[17:43:56.844]         }, add = TRUE)
[17:43:56.844]     }
[17:43:56.844]     ...future.frame <- base::sys.nframe()
[17:43:56.844]     ...future.conditions <- base::list()
[17:43:56.844]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.844]     if (FALSE) {
[17:43:56.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.844]     }
[17:43:56.844]     ...future.result <- base::tryCatch({
[17:43:56.844]         base::withCallingHandlers({
[17:43:56.844]             ...future.value <- base::withVisible(base::local({
[17:43:56.844]                 ...future.makeSendCondition <- base::local({
[17:43:56.844]                   sendCondition <- NULL
[17:43:56.844]                   function(frame = 1L) {
[17:43:56.844]                     if (is.function(sendCondition)) 
[17:43:56.844]                       return(sendCondition)
[17:43:56.844]                     ns <- getNamespace("parallel")
[17:43:56.844]                     if (exists("sendData", mode = "function", 
[17:43:56.844]                       envir = ns)) {
[17:43:56.844]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:56.844]                         envir = ns)
[17:43:56.844]                       envir <- sys.frame(frame)
[17:43:56.844]                       master <- NULL
[17:43:56.844]                       while (!identical(envir, .GlobalEnv) && 
[17:43:56.844]                         !identical(envir, emptyenv())) {
[17:43:56.844]                         if (exists("master", mode = "list", envir = envir, 
[17:43:56.844]                           inherits = FALSE)) {
[17:43:56.844]                           master <- get("master", mode = "list", 
[17:43:56.844]                             envir = envir, inherits = FALSE)
[17:43:56.844]                           if (inherits(master, c("SOCKnode", 
[17:43:56.844]                             "SOCK0node"))) {
[17:43:56.844]                             sendCondition <<- function(cond) {
[17:43:56.844]                               data <- list(type = "VALUE", value = cond, 
[17:43:56.844]                                 success = TRUE)
[17:43:56.844]                               parallel_sendData(master, data)
[17:43:56.844]                             }
[17:43:56.844]                             return(sendCondition)
[17:43:56.844]                           }
[17:43:56.844]                         }
[17:43:56.844]                         frame <- frame + 1L
[17:43:56.844]                         envir <- sys.frame(frame)
[17:43:56.844]                       }
[17:43:56.844]                     }
[17:43:56.844]                     sendCondition <<- function(cond) NULL
[17:43:56.844]                   }
[17:43:56.844]                 })
[17:43:56.844]                 withCallingHandlers({
[17:43:56.844]                   NA
[17:43:56.844]                 }, immediateCondition = function(cond) {
[17:43:56.844]                   sendCondition <- ...future.makeSendCondition()
[17:43:56.844]                   sendCondition(cond)
[17:43:56.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.844]                   {
[17:43:56.844]                     inherits <- base::inherits
[17:43:56.844]                     invokeRestart <- base::invokeRestart
[17:43:56.844]                     is.null <- base::is.null
[17:43:56.844]                     muffled <- FALSE
[17:43:56.844]                     if (inherits(cond, "message")) {
[17:43:56.844]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.844]                       if (muffled) 
[17:43:56.844]                         invokeRestart("muffleMessage")
[17:43:56.844]                     }
[17:43:56.844]                     else if (inherits(cond, "warning")) {
[17:43:56.844]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.844]                       if (muffled) 
[17:43:56.844]                         invokeRestart("muffleWarning")
[17:43:56.844]                     }
[17:43:56.844]                     else if (inherits(cond, "condition")) {
[17:43:56.844]                       if (!is.null(pattern)) {
[17:43:56.844]                         computeRestarts <- base::computeRestarts
[17:43:56.844]                         grepl <- base::grepl
[17:43:56.844]                         restarts <- computeRestarts(cond)
[17:43:56.844]                         for (restart in restarts) {
[17:43:56.844]                           name <- restart$name
[17:43:56.844]                           if (is.null(name)) 
[17:43:56.844]                             next
[17:43:56.844]                           if (!grepl(pattern, name)) 
[17:43:56.844]                             next
[17:43:56.844]                           invokeRestart(restart)
[17:43:56.844]                           muffled <- TRUE
[17:43:56.844]                           break
[17:43:56.844]                         }
[17:43:56.844]                       }
[17:43:56.844]                     }
[17:43:56.844]                     invisible(muffled)
[17:43:56.844]                   }
[17:43:56.844]                   muffleCondition(cond)
[17:43:56.844]                 })
[17:43:56.844]             }))
[17:43:56.844]             future::FutureResult(value = ...future.value$value, 
[17:43:56.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.844]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.844]                     ...future.globalenv.names))
[17:43:56.844]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.844]         }, condition = base::local({
[17:43:56.844]             c <- base::c
[17:43:56.844]             inherits <- base::inherits
[17:43:56.844]             invokeRestart <- base::invokeRestart
[17:43:56.844]             length <- base::length
[17:43:56.844]             list <- base::list
[17:43:56.844]             seq.int <- base::seq.int
[17:43:56.844]             signalCondition <- base::signalCondition
[17:43:56.844]             sys.calls <- base::sys.calls
[17:43:56.844]             `[[` <- base::`[[`
[17:43:56.844]             `+` <- base::`+`
[17:43:56.844]             `<<-` <- base::`<<-`
[17:43:56.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.844]                   3L)]
[17:43:56.844]             }
[17:43:56.844]             function(cond) {
[17:43:56.844]                 is_error <- inherits(cond, "error")
[17:43:56.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.844]                   NULL)
[17:43:56.844]                 if (is_error) {
[17:43:56.844]                   sessionInformation <- function() {
[17:43:56.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.844]                       search = base::search(), system = base::Sys.info())
[17:43:56.844]                   }
[17:43:56.844]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.844]                     cond$call), session = sessionInformation(), 
[17:43:56.844]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.844]                   signalCondition(cond)
[17:43:56.844]                 }
[17:43:56.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.844]                 "immediateCondition"))) {
[17:43:56.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.844]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.844]                   if (TRUE && !signal) {
[17:43:56.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.844]                     {
[17:43:56.844]                       inherits <- base::inherits
[17:43:56.844]                       invokeRestart <- base::invokeRestart
[17:43:56.844]                       is.null <- base::is.null
[17:43:56.844]                       muffled <- FALSE
[17:43:56.844]                       if (inherits(cond, "message")) {
[17:43:56.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.844]                         if (muffled) 
[17:43:56.844]                           invokeRestart("muffleMessage")
[17:43:56.844]                       }
[17:43:56.844]                       else if (inherits(cond, "warning")) {
[17:43:56.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.844]                         if (muffled) 
[17:43:56.844]                           invokeRestart("muffleWarning")
[17:43:56.844]                       }
[17:43:56.844]                       else if (inherits(cond, "condition")) {
[17:43:56.844]                         if (!is.null(pattern)) {
[17:43:56.844]                           computeRestarts <- base::computeRestarts
[17:43:56.844]                           grepl <- base::grepl
[17:43:56.844]                           restarts <- computeRestarts(cond)
[17:43:56.844]                           for (restart in restarts) {
[17:43:56.844]                             name <- restart$name
[17:43:56.844]                             if (is.null(name)) 
[17:43:56.844]                               next
[17:43:56.844]                             if (!grepl(pattern, name)) 
[17:43:56.844]                               next
[17:43:56.844]                             invokeRestart(restart)
[17:43:56.844]                             muffled <- TRUE
[17:43:56.844]                             break
[17:43:56.844]                           }
[17:43:56.844]                         }
[17:43:56.844]                       }
[17:43:56.844]                       invisible(muffled)
[17:43:56.844]                     }
[17:43:56.844]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.844]                   }
[17:43:56.844]                 }
[17:43:56.844]                 else {
[17:43:56.844]                   if (TRUE) {
[17:43:56.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.844]                     {
[17:43:56.844]                       inherits <- base::inherits
[17:43:56.844]                       invokeRestart <- base::invokeRestart
[17:43:56.844]                       is.null <- base::is.null
[17:43:56.844]                       muffled <- FALSE
[17:43:56.844]                       if (inherits(cond, "message")) {
[17:43:56.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.844]                         if (muffled) 
[17:43:56.844]                           invokeRestart("muffleMessage")
[17:43:56.844]                       }
[17:43:56.844]                       else if (inherits(cond, "warning")) {
[17:43:56.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.844]                         if (muffled) 
[17:43:56.844]                           invokeRestart("muffleWarning")
[17:43:56.844]                       }
[17:43:56.844]                       else if (inherits(cond, "condition")) {
[17:43:56.844]                         if (!is.null(pattern)) {
[17:43:56.844]                           computeRestarts <- base::computeRestarts
[17:43:56.844]                           grepl <- base::grepl
[17:43:56.844]                           restarts <- computeRestarts(cond)
[17:43:56.844]                           for (restart in restarts) {
[17:43:56.844]                             name <- restart$name
[17:43:56.844]                             if (is.null(name)) 
[17:43:56.844]                               next
[17:43:56.844]                             if (!grepl(pattern, name)) 
[17:43:56.844]                               next
[17:43:56.844]                             invokeRestart(restart)
[17:43:56.844]                             muffled <- TRUE
[17:43:56.844]                             break
[17:43:56.844]                           }
[17:43:56.844]                         }
[17:43:56.844]                       }
[17:43:56.844]                       invisible(muffled)
[17:43:56.844]                     }
[17:43:56.844]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.844]                   }
[17:43:56.844]                 }
[17:43:56.844]             }
[17:43:56.844]         }))
[17:43:56.844]     }, error = function(ex) {
[17:43:56.844]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.844]                 ...future.rng), started = ...future.startTime, 
[17:43:56.844]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.844]             version = "1.8"), class = "FutureResult")
[17:43:56.844]     }, finally = {
[17:43:56.844]         if (!identical(...future.workdir, getwd())) 
[17:43:56.844]             setwd(...future.workdir)
[17:43:56.844]         {
[17:43:56.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.844]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.844]             }
[17:43:56.844]             base::options(...future.oldOptions)
[17:43:56.844]             if (.Platform$OS.type == "windows") {
[17:43:56.844]                 old_names <- names(...future.oldEnvVars)
[17:43:56.844]                 envs <- base::Sys.getenv()
[17:43:56.844]                 names <- names(envs)
[17:43:56.844]                 common <- intersect(names, old_names)
[17:43:56.844]                 added <- setdiff(names, old_names)
[17:43:56.844]                 removed <- setdiff(old_names, names)
[17:43:56.844]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.844]                   envs[common]]
[17:43:56.844]                 NAMES <- toupper(changed)
[17:43:56.844]                 args <- list()
[17:43:56.844]                 for (kk in seq_along(NAMES)) {
[17:43:56.844]                   name <- changed[[kk]]
[17:43:56.844]                   NAME <- NAMES[[kk]]
[17:43:56.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.844]                     next
[17:43:56.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.844]                 }
[17:43:56.844]                 NAMES <- toupper(added)
[17:43:56.844]                 for (kk in seq_along(NAMES)) {
[17:43:56.844]                   name <- added[[kk]]
[17:43:56.844]                   NAME <- NAMES[[kk]]
[17:43:56.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.844]                     next
[17:43:56.844]                   args[[name]] <- ""
[17:43:56.844]                 }
[17:43:56.844]                 NAMES <- toupper(removed)
[17:43:56.844]                 for (kk in seq_along(NAMES)) {
[17:43:56.844]                   name <- removed[[kk]]
[17:43:56.844]                   NAME <- NAMES[[kk]]
[17:43:56.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.844]                     next
[17:43:56.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.844]                 }
[17:43:56.844]                 if (length(args) > 0) 
[17:43:56.844]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.844]             }
[17:43:56.844]             else {
[17:43:56.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.844]             }
[17:43:56.844]             {
[17:43:56.844]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.844]                   0L) {
[17:43:56.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.844]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.844]                   base::options(opts)
[17:43:56.844]                 }
[17:43:56.844]                 {
[17:43:56.844]                   {
[17:43:56.844]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.844]                     NULL
[17:43:56.844]                   }
[17:43:56.844]                   options(future.plan = NULL)
[17:43:56.844]                   if (is.na(NA_character_)) 
[17:43:56.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.844]                     .init = FALSE)
[17:43:56.844]                 }
[17:43:56.844]             }
[17:43:56.844]         }
[17:43:56.844]     })
[17:43:56.844]     if (TRUE) {
[17:43:56.844]         base::sink(type = "output", split = FALSE)
[17:43:56.844]         if (TRUE) {
[17:43:56.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.844]         }
[17:43:56.844]         else {
[17:43:56.844]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.844]         }
[17:43:56.844]         base::close(...future.stdout)
[17:43:56.844]         ...future.stdout <- NULL
[17:43:56.844]     }
[17:43:56.844]     ...future.result$conditions <- ...future.conditions
[17:43:56.844]     ...future.result$finished <- base::Sys.time()
[17:43:56.844]     ...future.result
[17:43:56.844] }
[17:43:56.896] MultisessionFuture started
[17:43:56.896] result() for ClusterFuture ...
[17:43:56.897] receiveMessageFromWorker() for ClusterFuture ...
[17:43:56.897] - Validating connection of MultisessionFuture
[17:43:56.929] - received message: FutureResult
[17:43:56.929] - Received FutureResult
[17:43:56.929] - Erased future from FutureRegistry
[17:43:56.929] result() for ClusterFuture ...
[17:43:56.929] - result already collected: FutureResult
[17:43:56.930] result() for ClusterFuture ... done
[17:43:56.930] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:56.930] result() for ClusterFuture ... done
[17:43:56.930] result() for ClusterFuture ...
[17:43:56.930] - result already collected: FutureResult
[17:43:56.930] result() for ClusterFuture ... done
[17:43:56.930] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:56.934] plan(): nbrOfWorkers() = 2
[17:43:56.934] future_lapply() ...
[17:43:56.938] Number of chunks: 2
[17:43:56.939] getGlobalsAndPackagesXApply() ...
[17:43:56.939]  - future.globals: TRUE
[17:43:56.939] getGlobalsAndPackages() ...
[17:43:56.939] Searching for globals...
[17:43:56.940] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:56.940] Searching for globals ... DONE
[17:43:56.941] Resolving globals: FALSE
[17:43:56.941] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:56.941] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:56.941] - globals: [1] ‘FUN’
[17:43:56.942] 
[17:43:56.942] getGlobalsAndPackages() ... DONE
[17:43:56.942]  - globals found/used: [n=1] ‘FUN’
[17:43:56.942]  - needed namespaces: [n=0] 
[17:43:56.942] Finding globals ... DONE
[17:43:56.942]  - use_args: TRUE
[17:43:56.942]  - Getting '...' globals ...
[17:43:56.943] resolve() on list ...
[17:43:56.943]  recursive: 0
[17:43:56.943]  length: 1
[17:43:56.943]  elements: ‘...’
[17:43:56.943]  length: 0 (resolved future 1)
[17:43:56.943] resolve() on list ... DONE
[17:43:56.943]    - '...' content: [n=0] 
[17:43:56.944] List of 1
[17:43:56.944]  $ ...: list()
[17:43:56.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.944]  - attr(*, "where")=List of 1
[17:43:56.944]   ..$ ...:<environment: 0x55813f4443a0> 
[17:43:56.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.944]  - attr(*, "resolved")= logi TRUE
[17:43:56.944]  - attr(*, "total_size")= num NA
[17:43:56.947]  - Getting '...' globals ... DONE
[17:43:56.947] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:56.947] List of 2
[17:43:56.947]  $ ...future.FUN:function (x, ...)  
[17:43:56.947]  $ ...          : list()
[17:43:56.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:56.947]  - attr(*, "where")=List of 2
[17:43:56.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:56.947]   ..$ ...          :<environment: 0x55813f4443a0> 
[17:43:56.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:56.947]  - attr(*, "resolved")= logi FALSE
[17:43:56.947]  - attr(*, "total_size")= num 1240
[17:43:56.950] Packages to be attached in all futures: [n=0] 
[17:43:56.950] getGlobalsAndPackagesXApply() ... DONE
[17:43:56.951] Number of futures (= number of chunks): 2
[17:43:56.951] Launching 2 futures (chunks) ...
[17:43:56.951] Chunk #1 of 2 ...
[17:43:56.951]  - Finding globals in 'X' for chunk #1 ...
[17:43:56.951] getGlobalsAndPackages() ...
[17:43:56.951] Searching for globals...
[17:43:56.952] 
[17:43:56.952] Searching for globals ... DONE
[17:43:56.952] - globals: [0] <none>
[17:43:56.952] getGlobalsAndPackages() ... DONE
[17:43:56.952]    + additional globals found: [n=0] 
[17:43:56.952]    + additional namespaces needed: [n=0] 
[17:43:56.952]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:56.952]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.952]  - seeds: <none>
[17:43:56.953]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.953] getGlobalsAndPackages() ...
[17:43:56.953] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.953] Resolving globals: FALSE
[17:43:56.953] Tweak future expression to call with '...' arguments ...
[17:43:56.953] {
[17:43:56.953]     do.call(function(...) {
[17:43:56.953]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.953]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.953]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.953]             on.exit(options(oopts), add = TRUE)
[17:43:56.953]         }
[17:43:56.953]         {
[17:43:56.953]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.953]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.953]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.953]             })
[17:43:56.953]         }
[17:43:56.953]     }, args = future.call.arguments)
[17:43:56.953] }
[17:43:56.954] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.954] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.954] 
[17:43:56.954] getGlobalsAndPackages() ... DONE
[17:43:56.955] run() for ‘Future’ ...
[17:43:56.955] - state: ‘created’
[17:43:56.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:56.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:56.970]   - Field: ‘node’
[17:43:56.970]   - Field: ‘label’
[17:43:56.970]   - Field: ‘local’
[17:43:56.970]   - Field: ‘owner’
[17:43:56.970]   - Field: ‘envir’
[17:43:56.970]   - Field: ‘workers’
[17:43:56.970]   - Field: ‘packages’
[17:43:56.970]   - Field: ‘gc’
[17:43:56.970]   - Field: ‘conditions’
[17:43:56.971]   - Field: ‘persistent’
[17:43:56.971]   - Field: ‘expr’
[17:43:56.971]   - Field: ‘uuid’
[17:43:56.971]   - Field: ‘seed’
[17:43:56.971]   - Field: ‘version’
[17:43:56.971]   - Field: ‘result’
[17:43:56.971]   - Field: ‘asynchronous’
[17:43:56.971]   - Field: ‘calls’
[17:43:56.972]   - Field: ‘globals’
[17:43:56.972]   - Field: ‘stdout’
[17:43:56.972]   - Field: ‘earlySignal’
[17:43:56.972]   - Field: ‘lazy’
[17:43:56.972]   - Field: ‘state’
[17:43:56.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:56.972] - Launch lazy future ...
[17:43:56.973] Packages needed by the future expression (n = 0): <none>
[17:43:56.973] Packages needed by future strategies (n = 0): <none>
[17:43:56.973] {
[17:43:56.973]     {
[17:43:56.973]         {
[17:43:56.973]             ...future.startTime <- base::Sys.time()
[17:43:56.973]             {
[17:43:56.973]                 {
[17:43:56.973]                   {
[17:43:56.973]                     {
[17:43:56.973]                       base::local({
[17:43:56.973]                         has_future <- base::requireNamespace("future", 
[17:43:56.973]                           quietly = TRUE)
[17:43:56.973]                         if (has_future) {
[17:43:56.973]                           ns <- base::getNamespace("future")
[17:43:56.973]                           version <- ns[[".package"]][["version"]]
[17:43:56.973]                           if (is.null(version)) 
[17:43:56.973]                             version <- utils::packageVersion("future")
[17:43:56.973]                         }
[17:43:56.973]                         else {
[17:43:56.973]                           version <- NULL
[17:43:56.973]                         }
[17:43:56.973]                         if (!has_future || version < "1.8.0") {
[17:43:56.973]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:56.973]                             "", base::R.version$version.string), 
[17:43:56.973]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:56.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:56.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:56.973]                               "release", "version")], collapse = " "), 
[17:43:56.973]                             hostname = base::Sys.info()[["nodename"]])
[17:43:56.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:56.973]                             info)
[17:43:56.973]                           info <- base::paste(info, collapse = "; ")
[17:43:56.973]                           if (!has_future) {
[17:43:56.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:56.973]                               info)
[17:43:56.973]                           }
[17:43:56.973]                           else {
[17:43:56.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:56.973]                               info, version)
[17:43:56.973]                           }
[17:43:56.973]                           base::stop(msg)
[17:43:56.973]                         }
[17:43:56.973]                       })
[17:43:56.973]                     }
[17:43:56.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:56.973]                     base::options(mc.cores = 1L)
[17:43:56.973]                   }
[17:43:56.973]                   ...future.strategy.old <- future::plan("list")
[17:43:56.973]                   options(future.plan = NULL)
[17:43:56.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:56.973]                 }
[17:43:56.973]                 ...future.workdir <- getwd()
[17:43:56.973]             }
[17:43:56.973]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:56.973]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:56.973]         }
[17:43:56.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:56.973]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:56.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:56.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:56.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:56.973]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:56.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:56.973]             base::names(...future.oldOptions))
[17:43:56.973]     }
[17:43:56.973]     if (FALSE) {
[17:43:56.973]     }
[17:43:56.973]     else {
[17:43:56.973]         if (TRUE) {
[17:43:56.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:56.973]                 open = "w")
[17:43:56.973]         }
[17:43:56.973]         else {
[17:43:56.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:56.973]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:56.973]         }
[17:43:56.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:56.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:56.973]             base::sink(type = "output", split = FALSE)
[17:43:56.973]             base::close(...future.stdout)
[17:43:56.973]         }, add = TRUE)
[17:43:56.973]     }
[17:43:56.973]     ...future.frame <- base::sys.nframe()
[17:43:56.973]     ...future.conditions <- base::list()
[17:43:56.973]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:56.973]     if (FALSE) {
[17:43:56.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:56.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:56.973]     }
[17:43:56.973]     ...future.result <- base::tryCatch({
[17:43:56.973]         base::withCallingHandlers({
[17:43:56.973]             ...future.value <- base::withVisible(base::local({
[17:43:56.973]                 ...future.makeSendCondition <- base::local({
[17:43:56.973]                   sendCondition <- NULL
[17:43:56.973]                   function(frame = 1L) {
[17:43:56.973]                     if (is.function(sendCondition)) 
[17:43:56.973]                       return(sendCondition)
[17:43:56.973]                     ns <- getNamespace("parallel")
[17:43:56.973]                     if (exists("sendData", mode = "function", 
[17:43:56.973]                       envir = ns)) {
[17:43:56.973]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:56.973]                         envir = ns)
[17:43:56.973]                       envir <- sys.frame(frame)
[17:43:56.973]                       master <- NULL
[17:43:56.973]                       while (!identical(envir, .GlobalEnv) && 
[17:43:56.973]                         !identical(envir, emptyenv())) {
[17:43:56.973]                         if (exists("master", mode = "list", envir = envir, 
[17:43:56.973]                           inherits = FALSE)) {
[17:43:56.973]                           master <- get("master", mode = "list", 
[17:43:56.973]                             envir = envir, inherits = FALSE)
[17:43:56.973]                           if (inherits(master, c("SOCKnode", 
[17:43:56.973]                             "SOCK0node"))) {
[17:43:56.973]                             sendCondition <<- function(cond) {
[17:43:56.973]                               data <- list(type = "VALUE", value = cond, 
[17:43:56.973]                                 success = TRUE)
[17:43:56.973]                               parallel_sendData(master, data)
[17:43:56.973]                             }
[17:43:56.973]                             return(sendCondition)
[17:43:56.973]                           }
[17:43:56.973]                         }
[17:43:56.973]                         frame <- frame + 1L
[17:43:56.973]                         envir <- sys.frame(frame)
[17:43:56.973]                       }
[17:43:56.973]                     }
[17:43:56.973]                     sendCondition <<- function(cond) NULL
[17:43:56.973]                   }
[17:43:56.973]                 })
[17:43:56.973]                 withCallingHandlers({
[17:43:56.973]                   {
[17:43:56.973]                     do.call(function(...) {
[17:43:56.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.973]                       if (!identical(...future.globals.maxSize.org, 
[17:43:56.973]                         ...future.globals.maxSize)) {
[17:43:56.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.973]                         on.exit(options(oopts), add = TRUE)
[17:43:56.973]                       }
[17:43:56.973]                       {
[17:43:56.973]                         lapply(seq_along(...future.elements_ii), 
[17:43:56.973]                           FUN = function(jj) {
[17:43:56.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.973]                             ...future.FUN(...future.X_jj, ...)
[17:43:56.973]                           })
[17:43:56.973]                       }
[17:43:56.973]                     }, args = future.call.arguments)
[17:43:56.973]                   }
[17:43:56.973]                 }, immediateCondition = function(cond) {
[17:43:56.973]                   sendCondition <- ...future.makeSendCondition()
[17:43:56.973]                   sendCondition(cond)
[17:43:56.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.973]                   {
[17:43:56.973]                     inherits <- base::inherits
[17:43:56.973]                     invokeRestart <- base::invokeRestart
[17:43:56.973]                     is.null <- base::is.null
[17:43:56.973]                     muffled <- FALSE
[17:43:56.973]                     if (inherits(cond, "message")) {
[17:43:56.973]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:56.973]                       if (muffled) 
[17:43:56.973]                         invokeRestart("muffleMessage")
[17:43:56.973]                     }
[17:43:56.973]                     else if (inherits(cond, "warning")) {
[17:43:56.973]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:56.973]                       if (muffled) 
[17:43:56.973]                         invokeRestart("muffleWarning")
[17:43:56.973]                     }
[17:43:56.973]                     else if (inherits(cond, "condition")) {
[17:43:56.973]                       if (!is.null(pattern)) {
[17:43:56.973]                         computeRestarts <- base::computeRestarts
[17:43:56.973]                         grepl <- base::grepl
[17:43:56.973]                         restarts <- computeRestarts(cond)
[17:43:56.973]                         for (restart in restarts) {
[17:43:56.973]                           name <- restart$name
[17:43:56.973]                           if (is.null(name)) 
[17:43:56.973]                             next
[17:43:56.973]                           if (!grepl(pattern, name)) 
[17:43:56.973]                             next
[17:43:56.973]                           invokeRestart(restart)
[17:43:56.973]                           muffled <- TRUE
[17:43:56.973]                           break
[17:43:56.973]                         }
[17:43:56.973]                       }
[17:43:56.973]                     }
[17:43:56.973]                     invisible(muffled)
[17:43:56.973]                   }
[17:43:56.973]                   muffleCondition(cond)
[17:43:56.973]                 })
[17:43:56.973]             }))
[17:43:56.973]             future::FutureResult(value = ...future.value$value, 
[17:43:56.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.973]                   ...future.rng), globalenv = if (FALSE) 
[17:43:56.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:56.973]                     ...future.globalenv.names))
[17:43:56.973]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:56.973]         }, condition = base::local({
[17:43:56.973]             c <- base::c
[17:43:56.973]             inherits <- base::inherits
[17:43:56.973]             invokeRestart <- base::invokeRestart
[17:43:56.973]             length <- base::length
[17:43:56.973]             list <- base::list
[17:43:56.973]             seq.int <- base::seq.int
[17:43:56.973]             signalCondition <- base::signalCondition
[17:43:56.973]             sys.calls <- base::sys.calls
[17:43:56.973]             `[[` <- base::`[[`
[17:43:56.973]             `+` <- base::`+`
[17:43:56.973]             `<<-` <- base::`<<-`
[17:43:56.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:56.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:56.973]                   3L)]
[17:43:56.973]             }
[17:43:56.973]             function(cond) {
[17:43:56.973]                 is_error <- inherits(cond, "error")
[17:43:56.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:56.973]                   NULL)
[17:43:56.973]                 if (is_error) {
[17:43:56.973]                   sessionInformation <- function() {
[17:43:56.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:56.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:56.973]                       search = base::search(), system = base::Sys.info())
[17:43:56.973]                   }
[17:43:56.973]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:56.973]                     cond$call), session = sessionInformation(), 
[17:43:56.973]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:56.973]                   signalCondition(cond)
[17:43:56.973]                 }
[17:43:56.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:56.973]                 "immediateCondition"))) {
[17:43:56.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:56.973]                   ...future.conditions[[length(...future.conditions) + 
[17:43:56.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:56.973]                   if (TRUE && !signal) {
[17:43:56.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.973]                     {
[17:43:56.973]                       inherits <- base::inherits
[17:43:56.973]                       invokeRestart <- base::invokeRestart
[17:43:56.973]                       is.null <- base::is.null
[17:43:56.973]                       muffled <- FALSE
[17:43:56.973]                       if (inherits(cond, "message")) {
[17:43:56.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.973]                         if (muffled) 
[17:43:56.973]                           invokeRestart("muffleMessage")
[17:43:56.973]                       }
[17:43:56.973]                       else if (inherits(cond, "warning")) {
[17:43:56.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.973]                         if (muffled) 
[17:43:56.973]                           invokeRestart("muffleWarning")
[17:43:56.973]                       }
[17:43:56.973]                       else if (inherits(cond, "condition")) {
[17:43:56.973]                         if (!is.null(pattern)) {
[17:43:56.973]                           computeRestarts <- base::computeRestarts
[17:43:56.973]                           grepl <- base::grepl
[17:43:56.973]                           restarts <- computeRestarts(cond)
[17:43:56.973]                           for (restart in restarts) {
[17:43:56.973]                             name <- restart$name
[17:43:56.973]                             if (is.null(name)) 
[17:43:56.973]                               next
[17:43:56.973]                             if (!grepl(pattern, name)) 
[17:43:56.973]                               next
[17:43:56.973]                             invokeRestart(restart)
[17:43:56.973]                             muffled <- TRUE
[17:43:56.973]                             break
[17:43:56.973]                           }
[17:43:56.973]                         }
[17:43:56.973]                       }
[17:43:56.973]                       invisible(muffled)
[17:43:56.973]                     }
[17:43:56.973]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.973]                   }
[17:43:56.973]                 }
[17:43:56.973]                 else {
[17:43:56.973]                   if (TRUE) {
[17:43:56.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:56.973]                     {
[17:43:56.973]                       inherits <- base::inherits
[17:43:56.973]                       invokeRestart <- base::invokeRestart
[17:43:56.973]                       is.null <- base::is.null
[17:43:56.973]                       muffled <- FALSE
[17:43:56.973]                       if (inherits(cond, "message")) {
[17:43:56.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:56.973]                         if (muffled) 
[17:43:56.973]                           invokeRestart("muffleMessage")
[17:43:56.973]                       }
[17:43:56.973]                       else if (inherits(cond, "warning")) {
[17:43:56.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:56.973]                         if (muffled) 
[17:43:56.973]                           invokeRestart("muffleWarning")
[17:43:56.973]                       }
[17:43:56.973]                       else if (inherits(cond, "condition")) {
[17:43:56.973]                         if (!is.null(pattern)) {
[17:43:56.973]                           computeRestarts <- base::computeRestarts
[17:43:56.973]                           grepl <- base::grepl
[17:43:56.973]                           restarts <- computeRestarts(cond)
[17:43:56.973]                           for (restart in restarts) {
[17:43:56.973]                             name <- restart$name
[17:43:56.973]                             if (is.null(name)) 
[17:43:56.973]                               next
[17:43:56.973]                             if (!grepl(pattern, name)) 
[17:43:56.973]                               next
[17:43:56.973]                             invokeRestart(restart)
[17:43:56.973]                             muffled <- TRUE
[17:43:56.973]                             break
[17:43:56.973]                           }
[17:43:56.973]                         }
[17:43:56.973]                       }
[17:43:56.973]                       invisible(muffled)
[17:43:56.973]                     }
[17:43:56.973]                     muffleCondition(cond, pattern = "^muffle")
[17:43:56.973]                   }
[17:43:56.973]                 }
[17:43:56.973]             }
[17:43:56.973]         }))
[17:43:56.973]     }, error = function(ex) {
[17:43:56.973]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:56.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:56.973]                 ...future.rng), started = ...future.startTime, 
[17:43:56.973]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:56.973]             version = "1.8"), class = "FutureResult")
[17:43:56.973]     }, finally = {
[17:43:56.973]         if (!identical(...future.workdir, getwd())) 
[17:43:56.973]             setwd(...future.workdir)
[17:43:56.973]         {
[17:43:56.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:56.973]                 ...future.oldOptions$nwarnings <- NULL
[17:43:56.973]             }
[17:43:56.973]             base::options(...future.oldOptions)
[17:43:56.973]             if (.Platform$OS.type == "windows") {
[17:43:56.973]                 old_names <- names(...future.oldEnvVars)
[17:43:56.973]                 envs <- base::Sys.getenv()
[17:43:56.973]                 names <- names(envs)
[17:43:56.973]                 common <- intersect(names, old_names)
[17:43:56.973]                 added <- setdiff(names, old_names)
[17:43:56.973]                 removed <- setdiff(old_names, names)
[17:43:56.973]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:56.973]                   envs[common]]
[17:43:56.973]                 NAMES <- toupper(changed)
[17:43:56.973]                 args <- list()
[17:43:56.973]                 for (kk in seq_along(NAMES)) {
[17:43:56.973]                   name <- changed[[kk]]
[17:43:56.973]                   NAME <- NAMES[[kk]]
[17:43:56.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.973]                     next
[17:43:56.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.973]                 }
[17:43:56.973]                 NAMES <- toupper(added)
[17:43:56.973]                 for (kk in seq_along(NAMES)) {
[17:43:56.973]                   name <- added[[kk]]
[17:43:56.973]                   NAME <- NAMES[[kk]]
[17:43:56.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.973]                     next
[17:43:56.973]                   args[[name]] <- ""
[17:43:56.973]                 }
[17:43:56.973]                 NAMES <- toupper(removed)
[17:43:56.973]                 for (kk in seq_along(NAMES)) {
[17:43:56.973]                   name <- removed[[kk]]
[17:43:56.973]                   NAME <- NAMES[[kk]]
[17:43:56.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:56.973]                     next
[17:43:56.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:56.973]                 }
[17:43:56.973]                 if (length(args) > 0) 
[17:43:56.973]                   base::do.call(base::Sys.setenv, args = args)
[17:43:56.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:56.973]             }
[17:43:56.973]             else {
[17:43:56.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:56.973]             }
[17:43:56.973]             {
[17:43:56.973]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:56.973]                   0L) {
[17:43:56.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:56.973]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:56.973]                   base::options(opts)
[17:43:56.973]                 }
[17:43:56.973]                 {
[17:43:56.973]                   {
[17:43:56.973]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:56.973]                     NULL
[17:43:56.973]                   }
[17:43:56.973]                   options(future.plan = NULL)
[17:43:56.973]                   if (is.na(NA_character_)) 
[17:43:56.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:56.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:56.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:56.973]                     .init = FALSE)
[17:43:56.973]                 }
[17:43:56.973]             }
[17:43:56.973]         }
[17:43:56.973]     })
[17:43:56.973]     if (TRUE) {
[17:43:56.973]         base::sink(type = "output", split = FALSE)
[17:43:56.973]         if (TRUE) {
[17:43:56.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:56.973]         }
[17:43:56.973]         else {
[17:43:56.973]             ...future.result["stdout"] <- base::list(NULL)
[17:43:56.973]         }
[17:43:56.973]         base::close(...future.stdout)
[17:43:56.973]         ...future.stdout <- NULL
[17:43:56.973]     }
[17:43:56.973]     ...future.result$conditions <- ...future.conditions
[17:43:56.973]     ...future.result$finished <- base::Sys.time()
[17:43:56.973]     ...future.result
[17:43:56.973] }
[17:43:56.976] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:43:56.976] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:43:56.977] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:43:56.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:56.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:56.978] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:43:56.978] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:43:56.978] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:56.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:56.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:56.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:56.980] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:43:56.980] MultisessionFuture started
[17:43:56.980] - Launch lazy future ... done
[17:43:56.981] run() for ‘MultisessionFuture’ ... done
[17:43:56.981] Created future:
[17:43:56.981] MultisessionFuture:
[17:43:56.981] Label: ‘future_eapply-1’
[17:43:56.981] Expression:
[17:43:56.981] {
[17:43:56.981]     do.call(function(...) {
[17:43:56.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.981]             on.exit(options(oopts), add = TRUE)
[17:43:56.981]         }
[17:43:56.981]         {
[17:43:56.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.981]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.981]             })
[17:43:56.981]         }
[17:43:56.981]     }, args = future.call.arguments)
[17:43:56.981] }
[17:43:56.981] Lazy evaluation: FALSE
[17:43:56.981] Asynchronous evaluation: TRUE
[17:43:56.981] Local evaluation: TRUE
[17:43:56.981] Environment: R_GlobalEnv
[17:43:56.981] Capture standard output: TRUE
[17:43:56.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:56.981] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:56.981] Packages: <none>
[17:43:56.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:56.981] Resolved: FALSE
[17:43:56.981] Value: <not collected>
[17:43:56.981] Conditions captured: <none>
[17:43:56.981] Early signaling: FALSE
[17:43:56.981] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:56.981] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:56.993] Chunk #1 of 2 ... DONE
[17:43:56.993] Chunk #2 of 2 ...
[17:43:56.993]  - Finding globals in 'X' for chunk #2 ...
[17:43:56.993] getGlobalsAndPackages() ...
[17:43:56.993] Searching for globals...
[17:43:56.994] 
[17:43:56.994] Searching for globals ... DONE
[17:43:56.994] - globals: [0] <none>
[17:43:56.994] getGlobalsAndPackages() ... DONE
[17:43:56.994]    + additional globals found: [n=0] 
[17:43:56.994]    + additional namespaces needed: [n=0] 
[17:43:56.994]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:56.994]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:56.994]  - seeds: <none>
[17:43:56.995]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.995] getGlobalsAndPackages() ...
[17:43:56.995] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.995] Resolving globals: FALSE
[17:43:56.995] Tweak future expression to call with '...' arguments ...
[17:43:56.995] {
[17:43:56.995]     do.call(function(...) {
[17:43:56.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:56.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:56.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:56.995]             on.exit(options(oopts), add = TRUE)
[17:43:56.995]         }
[17:43:56.995]         {
[17:43:56.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:56.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:56.995]                 ...future.FUN(...future.X_jj, ...)
[17:43:56.995]             })
[17:43:56.995]         }
[17:43:56.995]     }, args = future.call.arguments)
[17:43:56.995] }
[17:43:56.996] Tweak future expression to call with '...' arguments ... DONE
[17:43:56.996] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:56.996] 
[17:43:56.996] getGlobalsAndPackages() ... DONE
[17:43:56.997] run() for ‘Future’ ...
[17:43:56.997] - state: ‘created’
[17:43:56.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.011] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.011]   - Field: ‘node’
[17:43:57.011]   - Field: ‘label’
[17:43:57.012]   - Field: ‘local’
[17:43:57.012]   - Field: ‘owner’
[17:43:57.012]   - Field: ‘envir’
[17:43:57.012]   - Field: ‘workers’
[17:43:57.012]   - Field: ‘packages’
[17:43:57.012]   - Field: ‘gc’
[17:43:57.012]   - Field: ‘conditions’
[17:43:57.012]   - Field: ‘persistent’
[17:43:57.012]   - Field: ‘expr’
[17:43:57.012]   - Field: ‘uuid’
[17:43:57.013]   - Field: ‘seed’
[17:43:57.013]   - Field: ‘version’
[17:43:57.013]   - Field: ‘result’
[17:43:57.013]   - Field: ‘asynchronous’
[17:43:57.013]   - Field: ‘calls’
[17:43:57.013]   - Field: ‘globals’
[17:43:57.013]   - Field: ‘stdout’
[17:43:57.013]   - Field: ‘earlySignal’
[17:43:57.013]   - Field: ‘lazy’
[17:43:57.014]   - Field: ‘state’
[17:43:57.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.014] - Launch lazy future ...
[17:43:57.014] Packages needed by the future expression (n = 0): <none>
[17:43:57.014] Packages needed by future strategies (n = 0): <none>
[17:43:57.015] {
[17:43:57.015]     {
[17:43:57.015]         {
[17:43:57.015]             ...future.startTime <- base::Sys.time()
[17:43:57.015]             {
[17:43:57.015]                 {
[17:43:57.015]                   {
[17:43:57.015]                     {
[17:43:57.015]                       base::local({
[17:43:57.015]                         has_future <- base::requireNamespace("future", 
[17:43:57.015]                           quietly = TRUE)
[17:43:57.015]                         if (has_future) {
[17:43:57.015]                           ns <- base::getNamespace("future")
[17:43:57.015]                           version <- ns[[".package"]][["version"]]
[17:43:57.015]                           if (is.null(version)) 
[17:43:57.015]                             version <- utils::packageVersion("future")
[17:43:57.015]                         }
[17:43:57.015]                         else {
[17:43:57.015]                           version <- NULL
[17:43:57.015]                         }
[17:43:57.015]                         if (!has_future || version < "1.8.0") {
[17:43:57.015]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.015]                             "", base::R.version$version.string), 
[17:43:57.015]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:57.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:57.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.015]                               "release", "version")], collapse = " "), 
[17:43:57.015]                             hostname = base::Sys.info()[["nodename"]])
[17:43:57.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.015]                             info)
[17:43:57.015]                           info <- base::paste(info, collapse = "; ")
[17:43:57.015]                           if (!has_future) {
[17:43:57.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.015]                               info)
[17:43:57.015]                           }
[17:43:57.015]                           else {
[17:43:57.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.015]                               info, version)
[17:43:57.015]                           }
[17:43:57.015]                           base::stop(msg)
[17:43:57.015]                         }
[17:43:57.015]                       })
[17:43:57.015]                     }
[17:43:57.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.015]                     base::options(mc.cores = 1L)
[17:43:57.015]                   }
[17:43:57.015]                   ...future.strategy.old <- future::plan("list")
[17:43:57.015]                   options(future.plan = NULL)
[17:43:57.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.015]                 }
[17:43:57.015]                 ...future.workdir <- getwd()
[17:43:57.015]             }
[17:43:57.015]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.015]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.015]         }
[17:43:57.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.015]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.015]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.015]             base::names(...future.oldOptions))
[17:43:57.015]     }
[17:43:57.015]     if (FALSE) {
[17:43:57.015]     }
[17:43:57.015]     else {
[17:43:57.015]         if (TRUE) {
[17:43:57.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.015]                 open = "w")
[17:43:57.015]         }
[17:43:57.015]         else {
[17:43:57.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.015]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.015]         }
[17:43:57.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.015]             base::sink(type = "output", split = FALSE)
[17:43:57.015]             base::close(...future.stdout)
[17:43:57.015]         }, add = TRUE)
[17:43:57.015]     }
[17:43:57.015]     ...future.frame <- base::sys.nframe()
[17:43:57.015]     ...future.conditions <- base::list()
[17:43:57.015]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.015]     if (FALSE) {
[17:43:57.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.015]     }
[17:43:57.015]     ...future.result <- base::tryCatch({
[17:43:57.015]         base::withCallingHandlers({
[17:43:57.015]             ...future.value <- base::withVisible(base::local({
[17:43:57.015]                 ...future.makeSendCondition <- base::local({
[17:43:57.015]                   sendCondition <- NULL
[17:43:57.015]                   function(frame = 1L) {
[17:43:57.015]                     if (is.function(sendCondition)) 
[17:43:57.015]                       return(sendCondition)
[17:43:57.015]                     ns <- getNamespace("parallel")
[17:43:57.015]                     if (exists("sendData", mode = "function", 
[17:43:57.015]                       envir = ns)) {
[17:43:57.015]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.015]                         envir = ns)
[17:43:57.015]                       envir <- sys.frame(frame)
[17:43:57.015]                       master <- NULL
[17:43:57.015]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.015]                         !identical(envir, emptyenv())) {
[17:43:57.015]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.015]                           inherits = FALSE)) {
[17:43:57.015]                           master <- get("master", mode = "list", 
[17:43:57.015]                             envir = envir, inherits = FALSE)
[17:43:57.015]                           if (inherits(master, c("SOCKnode", 
[17:43:57.015]                             "SOCK0node"))) {
[17:43:57.015]                             sendCondition <<- function(cond) {
[17:43:57.015]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.015]                                 success = TRUE)
[17:43:57.015]                               parallel_sendData(master, data)
[17:43:57.015]                             }
[17:43:57.015]                             return(sendCondition)
[17:43:57.015]                           }
[17:43:57.015]                         }
[17:43:57.015]                         frame <- frame + 1L
[17:43:57.015]                         envir <- sys.frame(frame)
[17:43:57.015]                       }
[17:43:57.015]                     }
[17:43:57.015]                     sendCondition <<- function(cond) NULL
[17:43:57.015]                   }
[17:43:57.015]                 })
[17:43:57.015]                 withCallingHandlers({
[17:43:57.015]                   {
[17:43:57.015]                     do.call(function(...) {
[17:43:57.015]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.015]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.015]                         ...future.globals.maxSize)) {
[17:43:57.015]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.015]                         on.exit(options(oopts), add = TRUE)
[17:43:57.015]                       }
[17:43:57.015]                       {
[17:43:57.015]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.015]                           FUN = function(jj) {
[17:43:57.015]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.015]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.015]                           })
[17:43:57.015]                       }
[17:43:57.015]                     }, args = future.call.arguments)
[17:43:57.015]                   }
[17:43:57.015]                 }, immediateCondition = function(cond) {
[17:43:57.015]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.015]                   sendCondition(cond)
[17:43:57.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.015]                   {
[17:43:57.015]                     inherits <- base::inherits
[17:43:57.015]                     invokeRestart <- base::invokeRestart
[17:43:57.015]                     is.null <- base::is.null
[17:43:57.015]                     muffled <- FALSE
[17:43:57.015]                     if (inherits(cond, "message")) {
[17:43:57.015]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.015]                       if (muffled) 
[17:43:57.015]                         invokeRestart("muffleMessage")
[17:43:57.015]                     }
[17:43:57.015]                     else if (inherits(cond, "warning")) {
[17:43:57.015]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.015]                       if (muffled) 
[17:43:57.015]                         invokeRestart("muffleWarning")
[17:43:57.015]                     }
[17:43:57.015]                     else if (inherits(cond, "condition")) {
[17:43:57.015]                       if (!is.null(pattern)) {
[17:43:57.015]                         computeRestarts <- base::computeRestarts
[17:43:57.015]                         grepl <- base::grepl
[17:43:57.015]                         restarts <- computeRestarts(cond)
[17:43:57.015]                         for (restart in restarts) {
[17:43:57.015]                           name <- restart$name
[17:43:57.015]                           if (is.null(name)) 
[17:43:57.015]                             next
[17:43:57.015]                           if (!grepl(pattern, name)) 
[17:43:57.015]                             next
[17:43:57.015]                           invokeRestart(restart)
[17:43:57.015]                           muffled <- TRUE
[17:43:57.015]                           break
[17:43:57.015]                         }
[17:43:57.015]                       }
[17:43:57.015]                     }
[17:43:57.015]                     invisible(muffled)
[17:43:57.015]                   }
[17:43:57.015]                   muffleCondition(cond)
[17:43:57.015]                 })
[17:43:57.015]             }))
[17:43:57.015]             future::FutureResult(value = ...future.value$value, 
[17:43:57.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.015]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.015]                     ...future.globalenv.names))
[17:43:57.015]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.015]         }, condition = base::local({
[17:43:57.015]             c <- base::c
[17:43:57.015]             inherits <- base::inherits
[17:43:57.015]             invokeRestart <- base::invokeRestart
[17:43:57.015]             length <- base::length
[17:43:57.015]             list <- base::list
[17:43:57.015]             seq.int <- base::seq.int
[17:43:57.015]             signalCondition <- base::signalCondition
[17:43:57.015]             sys.calls <- base::sys.calls
[17:43:57.015]             `[[` <- base::`[[`
[17:43:57.015]             `+` <- base::`+`
[17:43:57.015]             `<<-` <- base::`<<-`
[17:43:57.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.015]                   3L)]
[17:43:57.015]             }
[17:43:57.015]             function(cond) {
[17:43:57.015]                 is_error <- inherits(cond, "error")
[17:43:57.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.015]                   NULL)
[17:43:57.015]                 if (is_error) {
[17:43:57.015]                   sessionInformation <- function() {
[17:43:57.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.015]                       search = base::search(), system = base::Sys.info())
[17:43:57.015]                   }
[17:43:57.015]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.015]                     cond$call), session = sessionInformation(), 
[17:43:57.015]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.015]                   signalCondition(cond)
[17:43:57.015]                 }
[17:43:57.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.015]                 "immediateCondition"))) {
[17:43:57.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.015]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.015]                   if (TRUE && !signal) {
[17:43:57.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.015]                     {
[17:43:57.015]                       inherits <- base::inherits
[17:43:57.015]                       invokeRestart <- base::invokeRestart
[17:43:57.015]                       is.null <- base::is.null
[17:43:57.015]                       muffled <- FALSE
[17:43:57.015]                       if (inherits(cond, "message")) {
[17:43:57.015]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.015]                         if (muffled) 
[17:43:57.015]                           invokeRestart("muffleMessage")
[17:43:57.015]                       }
[17:43:57.015]                       else if (inherits(cond, "warning")) {
[17:43:57.015]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.015]                         if (muffled) 
[17:43:57.015]                           invokeRestart("muffleWarning")
[17:43:57.015]                       }
[17:43:57.015]                       else if (inherits(cond, "condition")) {
[17:43:57.015]                         if (!is.null(pattern)) {
[17:43:57.015]                           computeRestarts <- base::computeRestarts
[17:43:57.015]                           grepl <- base::grepl
[17:43:57.015]                           restarts <- computeRestarts(cond)
[17:43:57.015]                           for (restart in restarts) {
[17:43:57.015]                             name <- restart$name
[17:43:57.015]                             if (is.null(name)) 
[17:43:57.015]                               next
[17:43:57.015]                             if (!grepl(pattern, name)) 
[17:43:57.015]                               next
[17:43:57.015]                             invokeRestart(restart)
[17:43:57.015]                             muffled <- TRUE
[17:43:57.015]                             break
[17:43:57.015]                           }
[17:43:57.015]                         }
[17:43:57.015]                       }
[17:43:57.015]                       invisible(muffled)
[17:43:57.015]                     }
[17:43:57.015]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.015]                   }
[17:43:57.015]                 }
[17:43:57.015]                 else {
[17:43:57.015]                   if (TRUE) {
[17:43:57.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.015]                     {
[17:43:57.015]                       inherits <- base::inherits
[17:43:57.015]                       invokeRestart <- base::invokeRestart
[17:43:57.015]                       is.null <- base::is.null
[17:43:57.015]                       muffled <- FALSE
[17:43:57.015]                       if (inherits(cond, "message")) {
[17:43:57.015]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.015]                         if (muffled) 
[17:43:57.015]                           invokeRestart("muffleMessage")
[17:43:57.015]                       }
[17:43:57.015]                       else if (inherits(cond, "warning")) {
[17:43:57.015]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.015]                         if (muffled) 
[17:43:57.015]                           invokeRestart("muffleWarning")
[17:43:57.015]                       }
[17:43:57.015]                       else if (inherits(cond, "condition")) {
[17:43:57.015]                         if (!is.null(pattern)) {
[17:43:57.015]                           computeRestarts <- base::computeRestarts
[17:43:57.015]                           grepl <- base::grepl
[17:43:57.015]                           restarts <- computeRestarts(cond)
[17:43:57.015]                           for (restart in restarts) {
[17:43:57.015]                             name <- restart$name
[17:43:57.015]                             if (is.null(name)) 
[17:43:57.015]                               next
[17:43:57.015]                             if (!grepl(pattern, name)) 
[17:43:57.015]                               next
[17:43:57.015]                             invokeRestart(restart)
[17:43:57.015]                             muffled <- TRUE
[17:43:57.015]                             break
[17:43:57.015]                           }
[17:43:57.015]                         }
[17:43:57.015]                       }
[17:43:57.015]                       invisible(muffled)
[17:43:57.015]                     }
[17:43:57.015]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.015]                   }
[17:43:57.015]                 }
[17:43:57.015]             }
[17:43:57.015]         }))
[17:43:57.015]     }, error = function(ex) {
[17:43:57.015]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.015]                 ...future.rng), started = ...future.startTime, 
[17:43:57.015]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.015]             version = "1.8"), class = "FutureResult")
[17:43:57.015]     }, finally = {
[17:43:57.015]         if (!identical(...future.workdir, getwd())) 
[17:43:57.015]             setwd(...future.workdir)
[17:43:57.015]         {
[17:43:57.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.015]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.015]             }
[17:43:57.015]             base::options(...future.oldOptions)
[17:43:57.015]             if (.Platform$OS.type == "windows") {
[17:43:57.015]                 old_names <- names(...future.oldEnvVars)
[17:43:57.015]                 envs <- base::Sys.getenv()
[17:43:57.015]                 names <- names(envs)
[17:43:57.015]                 common <- intersect(names, old_names)
[17:43:57.015]                 added <- setdiff(names, old_names)
[17:43:57.015]                 removed <- setdiff(old_names, names)
[17:43:57.015]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.015]                   envs[common]]
[17:43:57.015]                 NAMES <- toupper(changed)
[17:43:57.015]                 args <- list()
[17:43:57.015]                 for (kk in seq_along(NAMES)) {
[17:43:57.015]                   name <- changed[[kk]]
[17:43:57.015]                   NAME <- NAMES[[kk]]
[17:43:57.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.015]                     next
[17:43:57.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.015]                 }
[17:43:57.015]                 NAMES <- toupper(added)
[17:43:57.015]                 for (kk in seq_along(NAMES)) {
[17:43:57.015]                   name <- added[[kk]]
[17:43:57.015]                   NAME <- NAMES[[kk]]
[17:43:57.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.015]                     next
[17:43:57.015]                   args[[name]] <- ""
[17:43:57.015]                 }
[17:43:57.015]                 NAMES <- toupper(removed)
[17:43:57.015]                 for (kk in seq_along(NAMES)) {
[17:43:57.015]                   name <- removed[[kk]]
[17:43:57.015]                   NAME <- NAMES[[kk]]
[17:43:57.015]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.015]                     next
[17:43:57.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.015]                 }
[17:43:57.015]                 if (length(args) > 0) 
[17:43:57.015]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.015]             }
[17:43:57.015]             else {
[17:43:57.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.015]             }
[17:43:57.015]             {
[17:43:57.015]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.015]                   0L) {
[17:43:57.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.015]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.015]                   base::options(opts)
[17:43:57.015]                 }
[17:43:57.015]                 {
[17:43:57.015]                   {
[17:43:57.015]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.015]                     NULL
[17:43:57.015]                   }
[17:43:57.015]                   options(future.plan = NULL)
[17:43:57.015]                   if (is.na(NA_character_)) 
[17:43:57.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.015]                     .init = FALSE)
[17:43:57.015]                 }
[17:43:57.015]             }
[17:43:57.015]         }
[17:43:57.015]     })
[17:43:57.015]     if (TRUE) {
[17:43:57.015]         base::sink(type = "output", split = FALSE)
[17:43:57.015]         if (TRUE) {
[17:43:57.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.015]         }
[17:43:57.015]         else {
[17:43:57.015]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.015]         }
[17:43:57.015]         base::close(...future.stdout)
[17:43:57.015]         ...future.stdout <- NULL
[17:43:57.015]     }
[17:43:57.015]     ...future.result$conditions <- ...future.conditions
[17:43:57.015]     ...future.result$finished <- base::Sys.time()
[17:43:57.015]     ...future.result
[17:43:57.015] }
[17:43:57.066] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:43:57.066] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:43:57.067] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:43:57.067] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:57.068] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.068] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:43:57.068] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:43:57.068] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:57.069] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.069] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:57.069] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.069] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:43:57.070] MultisessionFuture started
[17:43:57.070] - Launch lazy future ... done
[17:43:57.070] run() for ‘MultisessionFuture’ ... done
[17:43:57.070] Created future:
[17:43:57.070] MultisessionFuture:
[17:43:57.070] Label: ‘future_eapply-2’
[17:43:57.070] Expression:
[17:43:57.070] {
[17:43:57.070]     do.call(function(...) {
[17:43:57.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.070]             on.exit(options(oopts), add = TRUE)
[17:43:57.070]         }
[17:43:57.070]         {
[17:43:57.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.070]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.070]             })
[17:43:57.070]         }
[17:43:57.070]     }, args = future.call.arguments)
[17:43:57.070] }
[17:43:57.070] Lazy evaluation: FALSE
[17:43:57.070] Asynchronous evaluation: TRUE
[17:43:57.070] Local evaluation: TRUE
[17:43:57.070] Environment: R_GlobalEnv
[17:43:57.070] Capture standard output: TRUE
[17:43:57.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.070] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.070] Packages: <none>
[17:43:57.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.070] Resolved: FALSE
[17:43:57.070] Value: <not collected>
[17:43:57.070] Conditions captured: <none>
[17:43:57.070] Early signaling: FALSE
[17:43:57.070] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.070] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.082] Chunk #2 of 2 ... DONE
[17:43:57.082] Launching 2 futures (chunks) ... DONE
[17:43:57.083] Resolving 2 futures (chunks) ...
[17:43:57.083] resolve() on list ...
[17:43:57.083]  recursive: 0
[17:43:57.083]  length: 2
[17:43:57.083] 
[17:43:57.084] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.084] - Validating connection of MultisessionFuture
[17:43:57.084] - received message: FutureResult
[17:43:57.084] - Received FutureResult
[17:43:57.084] - Erased future from FutureRegistry
[17:43:57.084] result() for ClusterFuture ...
[17:43:57.085] - result already collected: FutureResult
[17:43:57.085] result() for ClusterFuture ... done
[17:43:57.085] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.085] Future #1
[17:43:57.085] result() for ClusterFuture ...
[17:43:57.085] - result already collected: FutureResult
[17:43:57.085] result() for ClusterFuture ... done
[17:43:57.085] result() for ClusterFuture ...
[17:43:57.085] - result already collected: FutureResult
[17:43:57.086] result() for ClusterFuture ... done
[17:43:57.086] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:57.086] - nx: 2
[17:43:57.088] - relay: TRUE
[17:43:57.088] - stdout: TRUE
[17:43:57.088] - signal: TRUE
[17:43:57.088] - resignal: FALSE
[17:43:57.088] - force: TRUE
[17:43:57.089] - relayed: [n=2] FALSE, FALSE
[17:43:57.089] - queued futures: [n=2] FALSE, FALSE
[17:43:57.089]  - until=1
[17:43:57.089]  - relaying element #1
[17:43:57.089] result() for ClusterFuture ...
[17:43:57.089] - result already collected: FutureResult
[17:43:57.089] result() for ClusterFuture ... done
[17:43:57.089] result() for ClusterFuture ...
[17:43:57.089] - result already collected: FutureResult
[17:43:57.089] result() for ClusterFuture ... done
[17:43:57.089] result() for ClusterFuture ...
[17:43:57.090] - result already collected: FutureResult
[17:43:57.090] result() for ClusterFuture ... done
[17:43:57.090] result() for ClusterFuture ...
[17:43:57.090] - result already collected: FutureResult
[17:43:57.090] result() for ClusterFuture ... done
[17:43:57.090] - relayed: [n=2] TRUE, FALSE
[17:43:57.090] - queued futures: [n=2] TRUE, FALSE
[17:43:57.090] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:57.090]  length: 1 (resolved future 1)
[17:43:57.153] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.153] - Validating connection of MultisessionFuture
[17:43:57.153] - received message: FutureResult
[17:43:57.153] - Received FutureResult
[17:43:57.153] - Erased future from FutureRegistry
[17:43:57.153] result() for ClusterFuture ...
[17:43:57.153] - result already collected: FutureResult
[17:43:57.153] result() for ClusterFuture ... done
[17:43:57.154] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.154] Future #2
[17:43:57.154] result() for ClusterFuture ...
[17:43:57.154] - result already collected: FutureResult
[17:43:57.154] result() for ClusterFuture ... done
[17:43:57.154] result() for ClusterFuture ...
[17:43:57.154] - result already collected: FutureResult
[17:43:57.154] result() for ClusterFuture ... done
[17:43:57.154] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:57.154] - nx: 2
[17:43:57.154] - relay: TRUE
[17:43:57.155] - stdout: TRUE
[17:43:57.155] - signal: TRUE
[17:43:57.155] - resignal: FALSE
[17:43:57.155] - force: TRUE
[17:43:57.155] - relayed: [n=2] TRUE, FALSE
[17:43:57.155] - queued futures: [n=2] TRUE, FALSE
[17:43:57.155]  - until=2
[17:43:57.155]  - relaying element #2
[17:43:57.155] result() for ClusterFuture ...
[17:43:57.155] - result already collected: FutureResult
[17:43:57.155] result() for ClusterFuture ... done
[17:43:57.156] result() for ClusterFuture ...
[17:43:57.156] - result already collected: FutureResult
[17:43:57.156] result() for ClusterFuture ... done
[17:43:57.156] result() for ClusterFuture ...
[17:43:57.156] - result already collected: FutureResult
[17:43:57.156] result() for ClusterFuture ... done
[17:43:57.156] result() for ClusterFuture ...
[17:43:57.156] - result already collected: FutureResult
[17:43:57.156] result() for ClusterFuture ... done
[17:43:57.156] - relayed: [n=2] TRUE, TRUE
[17:43:57.156] - queued futures: [n=2] TRUE, TRUE
[17:43:57.157] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:57.157]  length: 0 (resolved future 2)
[17:43:57.157] Relaying remaining futures
[17:43:57.157] signalConditionsASAP(NULL, pos=0) ...
[17:43:57.157] - nx: 2
[17:43:57.157] - relay: TRUE
[17:43:57.157] - stdout: TRUE
[17:43:57.157] - signal: TRUE
[17:43:57.157] - resignal: FALSE
[17:43:57.157] - force: TRUE
[17:43:57.157] - relayed: [n=2] TRUE, TRUE
[17:43:57.157] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:57.158] - relayed: [n=2] TRUE, TRUE
[17:43:57.158] - queued futures: [n=2] TRUE, TRUE
[17:43:57.158] signalConditionsASAP(NULL, pos=0) ... done
[17:43:57.158] resolve() on list ... DONE
[17:43:57.158] result() for ClusterFuture ...
[17:43:57.158] - result already collected: FutureResult
[17:43:57.158] result() for ClusterFuture ... done
[17:43:57.158] result() for ClusterFuture ...
[17:43:57.158] - result already collected: FutureResult
[17:43:57.158] result() for ClusterFuture ... done
[17:43:57.159] result() for ClusterFuture ...
[17:43:57.159] - result already collected: FutureResult
[17:43:57.159] result() for ClusterFuture ... done
[17:43:57.159] result() for ClusterFuture ...
[17:43:57.159] - result already collected: FutureResult
[17:43:57.159] result() for ClusterFuture ... done
[17:43:57.159]  - Number of value chunks collected: 2
[17:43:57.159] Resolving 2 futures (chunks) ... DONE
[17:43:57.160] Reducing values from 2 chunks ...
[17:43:57.160]  - Number of values collected after concatenation: 3
[17:43:57.160]  - Number of values expected: 3
[17:43:57.160] Reducing values from 2 chunks ... DONE
[17:43:57.160] future_lapply() ... DONE
[17:43:57.161] future_lapply() ...
[17:43:57.166] Number of chunks: 2
[17:43:57.166] getGlobalsAndPackagesXApply() ...
[17:43:57.166]  - future.globals: TRUE
[17:43:57.166] getGlobalsAndPackages() ...
[17:43:57.166] Searching for globals...
[17:43:57.168] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:57.168] Searching for globals ... DONE
[17:43:57.168] Resolving globals: FALSE
[17:43:57.168] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:57.169] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:57.169] - globals: [1] ‘FUN’
[17:43:57.169] - packages: [1] ‘stats’
[17:43:57.169] getGlobalsAndPackages() ... DONE
[17:43:57.169]  - globals found/used: [n=1] ‘FUN’
[17:43:57.169]  - needed namespaces: [n=1] ‘stats’
[17:43:57.169] Finding globals ... DONE
[17:43:57.169]  - use_args: TRUE
[17:43:57.169]  - Getting '...' globals ...
[17:43:57.170] resolve() on list ...
[17:43:57.170]  recursive: 0
[17:43:57.170]  length: 1
[17:43:57.170]  elements: ‘...’
[17:43:57.170]  length: 0 (resolved future 1)
[17:43:57.170] resolve() on list ... DONE
[17:43:57.170]    - '...' content: [n=1] ‘probs’
[17:43:57.170] List of 1
[17:43:57.170]  $ ...:List of 1
[17:43:57.170]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:57.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:57.170]  - attr(*, "where")=List of 1
[17:43:57.170]   ..$ ...:<environment: 0x55813e260e28> 
[17:43:57.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:57.170]  - attr(*, "resolved")= logi TRUE
[17:43:57.170]  - attr(*, "total_size")= num NA
[17:43:57.173]  - Getting '...' globals ... DONE
[17:43:57.174] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:57.174] List of 2
[17:43:57.174]  $ ...future.FUN:function (x, ...)  
[17:43:57.174]  $ ...          :List of 1
[17:43:57.174]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:43:57.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:57.174]  - attr(*, "where")=List of 2
[17:43:57.174]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:57.174]   ..$ ...          :<environment: 0x55813e260e28> 
[17:43:57.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:57.174]  - attr(*, "resolved")= logi FALSE
[17:43:57.174]  - attr(*, "total_size")= num 1328
[17:43:57.177] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:57.177] getGlobalsAndPackagesXApply() ... DONE
[17:43:57.177] Number of futures (= number of chunks): 2
[17:43:57.177] Launching 2 futures (chunks) ...
[17:43:57.177] Chunk #1 of 2 ...
[17:43:57.177]  - Finding globals in 'X' for chunk #1 ...
[17:43:57.177] getGlobalsAndPackages() ...
[17:43:57.178] Searching for globals...
[17:43:57.178] 
[17:43:57.178] Searching for globals ... DONE
[17:43:57.178] - globals: [0] <none>
[17:43:57.178] getGlobalsAndPackages() ... DONE
[17:43:57.178]    + additional globals found: [n=0] 
[17:43:57.178]    + additional namespaces needed: [n=0] 
[17:43:57.178]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:57.178]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:57.179]  - seeds: <none>
[17:43:57.179]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.179] getGlobalsAndPackages() ...
[17:43:57.179] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.179] Resolving globals: FALSE
[17:43:57.179] Tweak future expression to call with '...' arguments ...
[17:43:57.179] {
[17:43:57.179]     do.call(function(...) {
[17:43:57.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.179]             on.exit(options(oopts), add = TRUE)
[17:43:57.179]         }
[17:43:57.179]         {
[17:43:57.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.179]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.179]             })
[17:43:57.179]         }
[17:43:57.179]     }, args = future.call.arguments)
[17:43:57.179] }
[17:43:57.179] Tweak future expression to call with '...' arguments ... DONE
[17:43:57.180] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.180] - packages: [1] ‘stats’
[17:43:57.180] getGlobalsAndPackages() ... DONE
[17:43:57.180] run() for ‘Future’ ...
[17:43:57.180] - state: ‘created’
[17:43:57.181] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.194] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.194]   - Field: ‘node’
[17:43:57.195]   - Field: ‘label’
[17:43:57.195]   - Field: ‘local’
[17:43:57.195]   - Field: ‘owner’
[17:43:57.195]   - Field: ‘envir’
[17:43:57.195]   - Field: ‘workers’
[17:43:57.195]   - Field: ‘packages’
[17:43:57.195]   - Field: ‘gc’
[17:43:57.195]   - Field: ‘conditions’
[17:43:57.195]   - Field: ‘persistent’
[17:43:57.195]   - Field: ‘expr’
[17:43:57.196]   - Field: ‘uuid’
[17:43:57.196]   - Field: ‘seed’
[17:43:57.196]   - Field: ‘version’
[17:43:57.196]   - Field: ‘result’
[17:43:57.196]   - Field: ‘asynchronous’
[17:43:57.196]   - Field: ‘calls’
[17:43:57.196]   - Field: ‘globals’
[17:43:57.196]   - Field: ‘stdout’
[17:43:57.196]   - Field: ‘earlySignal’
[17:43:57.196]   - Field: ‘lazy’
[17:43:57.196]   - Field: ‘state’
[17:43:57.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.197] - Launch lazy future ...
[17:43:57.197] Packages needed by the future expression (n = 1): ‘stats’
[17:43:57.197] Packages needed by future strategies (n = 0): <none>
[17:43:57.197] {
[17:43:57.197]     {
[17:43:57.197]         {
[17:43:57.197]             ...future.startTime <- base::Sys.time()
[17:43:57.197]             {
[17:43:57.197]                 {
[17:43:57.197]                   {
[17:43:57.197]                     {
[17:43:57.197]                       {
[17:43:57.197]                         base::local({
[17:43:57.197]                           has_future <- base::requireNamespace("future", 
[17:43:57.197]                             quietly = TRUE)
[17:43:57.197]                           if (has_future) {
[17:43:57.197]                             ns <- base::getNamespace("future")
[17:43:57.197]                             version <- ns[[".package"]][["version"]]
[17:43:57.197]                             if (is.null(version)) 
[17:43:57.197]                               version <- utils::packageVersion("future")
[17:43:57.197]                           }
[17:43:57.197]                           else {
[17:43:57.197]                             version <- NULL
[17:43:57.197]                           }
[17:43:57.197]                           if (!has_future || version < "1.8.0") {
[17:43:57.197]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.197]                               "", base::R.version$version.string), 
[17:43:57.197]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:57.197]                                 base::R.version$platform, 8 * 
[17:43:57.197]                                   base::.Machine$sizeof.pointer), 
[17:43:57.197]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.197]                                 "release", "version")], collapse = " "), 
[17:43:57.197]                               hostname = base::Sys.info()[["nodename"]])
[17:43:57.197]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.197]                               info)
[17:43:57.197]                             info <- base::paste(info, collapse = "; ")
[17:43:57.197]                             if (!has_future) {
[17:43:57.197]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.197]                                 info)
[17:43:57.197]                             }
[17:43:57.197]                             else {
[17:43:57.197]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.197]                                 info, version)
[17:43:57.197]                             }
[17:43:57.197]                             base::stop(msg)
[17:43:57.197]                           }
[17:43:57.197]                         })
[17:43:57.197]                       }
[17:43:57.197]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.197]                       base::options(mc.cores = 1L)
[17:43:57.197]                     }
[17:43:57.197]                     base::local({
[17:43:57.197]                       for (pkg in "stats") {
[17:43:57.197]                         base::loadNamespace(pkg)
[17:43:57.197]                         base::library(pkg, character.only = TRUE)
[17:43:57.197]                       }
[17:43:57.197]                     })
[17:43:57.197]                   }
[17:43:57.197]                   ...future.strategy.old <- future::plan("list")
[17:43:57.197]                   options(future.plan = NULL)
[17:43:57.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.197]                 }
[17:43:57.197]                 ...future.workdir <- getwd()
[17:43:57.197]             }
[17:43:57.197]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.197]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.197]         }
[17:43:57.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.197]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.197]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.197]             base::names(...future.oldOptions))
[17:43:57.197]     }
[17:43:57.197]     if (FALSE) {
[17:43:57.197]     }
[17:43:57.197]     else {
[17:43:57.197]         if (TRUE) {
[17:43:57.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.197]                 open = "w")
[17:43:57.197]         }
[17:43:57.197]         else {
[17:43:57.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.197]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.197]         }
[17:43:57.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.197]             base::sink(type = "output", split = FALSE)
[17:43:57.197]             base::close(...future.stdout)
[17:43:57.197]         }, add = TRUE)
[17:43:57.197]     }
[17:43:57.197]     ...future.frame <- base::sys.nframe()
[17:43:57.197]     ...future.conditions <- base::list()
[17:43:57.197]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.197]     if (FALSE) {
[17:43:57.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.197]     }
[17:43:57.197]     ...future.result <- base::tryCatch({
[17:43:57.197]         base::withCallingHandlers({
[17:43:57.197]             ...future.value <- base::withVisible(base::local({
[17:43:57.197]                 ...future.makeSendCondition <- base::local({
[17:43:57.197]                   sendCondition <- NULL
[17:43:57.197]                   function(frame = 1L) {
[17:43:57.197]                     if (is.function(sendCondition)) 
[17:43:57.197]                       return(sendCondition)
[17:43:57.197]                     ns <- getNamespace("parallel")
[17:43:57.197]                     if (exists("sendData", mode = "function", 
[17:43:57.197]                       envir = ns)) {
[17:43:57.197]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.197]                         envir = ns)
[17:43:57.197]                       envir <- sys.frame(frame)
[17:43:57.197]                       master <- NULL
[17:43:57.197]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.197]                         !identical(envir, emptyenv())) {
[17:43:57.197]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.197]                           inherits = FALSE)) {
[17:43:57.197]                           master <- get("master", mode = "list", 
[17:43:57.197]                             envir = envir, inherits = FALSE)
[17:43:57.197]                           if (inherits(master, c("SOCKnode", 
[17:43:57.197]                             "SOCK0node"))) {
[17:43:57.197]                             sendCondition <<- function(cond) {
[17:43:57.197]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.197]                                 success = TRUE)
[17:43:57.197]                               parallel_sendData(master, data)
[17:43:57.197]                             }
[17:43:57.197]                             return(sendCondition)
[17:43:57.197]                           }
[17:43:57.197]                         }
[17:43:57.197]                         frame <- frame + 1L
[17:43:57.197]                         envir <- sys.frame(frame)
[17:43:57.197]                       }
[17:43:57.197]                     }
[17:43:57.197]                     sendCondition <<- function(cond) NULL
[17:43:57.197]                   }
[17:43:57.197]                 })
[17:43:57.197]                 withCallingHandlers({
[17:43:57.197]                   {
[17:43:57.197]                     do.call(function(...) {
[17:43:57.197]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.197]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.197]                         ...future.globals.maxSize)) {
[17:43:57.197]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.197]                         on.exit(options(oopts), add = TRUE)
[17:43:57.197]                       }
[17:43:57.197]                       {
[17:43:57.197]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.197]                           FUN = function(jj) {
[17:43:57.197]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.197]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.197]                           })
[17:43:57.197]                       }
[17:43:57.197]                     }, args = future.call.arguments)
[17:43:57.197]                   }
[17:43:57.197]                 }, immediateCondition = function(cond) {
[17:43:57.197]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.197]                   sendCondition(cond)
[17:43:57.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.197]                   {
[17:43:57.197]                     inherits <- base::inherits
[17:43:57.197]                     invokeRestart <- base::invokeRestart
[17:43:57.197]                     is.null <- base::is.null
[17:43:57.197]                     muffled <- FALSE
[17:43:57.197]                     if (inherits(cond, "message")) {
[17:43:57.197]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.197]                       if (muffled) 
[17:43:57.197]                         invokeRestart("muffleMessage")
[17:43:57.197]                     }
[17:43:57.197]                     else if (inherits(cond, "warning")) {
[17:43:57.197]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.197]                       if (muffled) 
[17:43:57.197]                         invokeRestart("muffleWarning")
[17:43:57.197]                     }
[17:43:57.197]                     else if (inherits(cond, "condition")) {
[17:43:57.197]                       if (!is.null(pattern)) {
[17:43:57.197]                         computeRestarts <- base::computeRestarts
[17:43:57.197]                         grepl <- base::grepl
[17:43:57.197]                         restarts <- computeRestarts(cond)
[17:43:57.197]                         for (restart in restarts) {
[17:43:57.197]                           name <- restart$name
[17:43:57.197]                           if (is.null(name)) 
[17:43:57.197]                             next
[17:43:57.197]                           if (!grepl(pattern, name)) 
[17:43:57.197]                             next
[17:43:57.197]                           invokeRestart(restart)
[17:43:57.197]                           muffled <- TRUE
[17:43:57.197]                           break
[17:43:57.197]                         }
[17:43:57.197]                       }
[17:43:57.197]                     }
[17:43:57.197]                     invisible(muffled)
[17:43:57.197]                   }
[17:43:57.197]                   muffleCondition(cond)
[17:43:57.197]                 })
[17:43:57.197]             }))
[17:43:57.197]             future::FutureResult(value = ...future.value$value, 
[17:43:57.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.197]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.197]                     ...future.globalenv.names))
[17:43:57.197]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.197]         }, condition = base::local({
[17:43:57.197]             c <- base::c
[17:43:57.197]             inherits <- base::inherits
[17:43:57.197]             invokeRestart <- base::invokeRestart
[17:43:57.197]             length <- base::length
[17:43:57.197]             list <- base::list
[17:43:57.197]             seq.int <- base::seq.int
[17:43:57.197]             signalCondition <- base::signalCondition
[17:43:57.197]             sys.calls <- base::sys.calls
[17:43:57.197]             `[[` <- base::`[[`
[17:43:57.197]             `+` <- base::`+`
[17:43:57.197]             `<<-` <- base::`<<-`
[17:43:57.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.197]                   3L)]
[17:43:57.197]             }
[17:43:57.197]             function(cond) {
[17:43:57.197]                 is_error <- inherits(cond, "error")
[17:43:57.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.197]                   NULL)
[17:43:57.197]                 if (is_error) {
[17:43:57.197]                   sessionInformation <- function() {
[17:43:57.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.197]                       search = base::search(), system = base::Sys.info())
[17:43:57.197]                   }
[17:43:57.197]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.197]                     cond$call), session = sessionInformation(), 
[17:43:57.197]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.197]                   signalCondition(cond)
[17:43:57.197]                 }
[17:43:57.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.197]                 "immediateCondition"))) {
[17:43:57.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.197]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.197]                   if (TRUE && !signal) {
[17:43:57.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.197]                     {
[17:43:57.197]                       inherits <- base::inherits
[17:43:57.197]                       invokeRestart <- base::invokeRestart
[17:43:57.197]                       is.null <- base::is.null
[17:43:57.197]                       muffled <- FALSE
[17:43:57.197]                       if (inherits(cond, "message")) {
[17:43:57.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.197]                         if (muffled) 
[17:43:57.197]                           invokeRestart("muffleMessage")
[17:43:57.197]                       }
[17:43:57.197]                       else if (inherits(cond, "warning")) {
[17:43:57.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.197]                         if (muffled) 
[17:43:57.197]                           invokeRestart("muffleWarning")
[17:43:57.197]                       }
[17:43:57.197]                       else if (inherits(cond, "condition")) {
[17:43:57.197]                         if (!is.null(pattern)) {
[17:43:57.197]                           computeRestarts <- base::computeRestarts
[17:43:57.197]                           grepl <- base::grepl
[17:43:57.197]                           restarts <- computeRestarts(cond)
[17:43:57.197]                           for (restart in restarts) {
[17:43:57.197]                             name <- restart$name
[17:43:57.197]                             if (is.null(name)) 
[17:43:57.197]                               next
[17:43:57.197]                             if (!grepl(pattern, name)) 
[17:43:57.197]                               next
[17:43:57.197]                             invokeRestart(restart)
[17:43:57.197]                             muffled <- TRUE
[17:43:57.197]                             break
[17:43:57.197]                           }
[17:43:57.197]                         }
[17:43:57.197]                       }
[17:43:57.197]                       invisible(muffled)
[17:43:57.197]                     }
[17:43:57.197]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.197]                   }
[17:43:57.197]                 }
[17:43:57.197]                 else {
[17:43:57.197]                   if (TRUE) {
[17:43:57.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.197]                     {
[17:43:57.197]                       inherits <- base::inherits
[17:43:57.197]                       invokeRestart <- base::invokeRestart
[17:43:57.197]                       is.null <- base::is.null
[17:43:57.197]                       muffled <- FALSE
[17:43:57.197]                       if (inherits(cond, "message")) {
[17:43:57.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.197]                         if (muffled) 
[17:43:57.197]                           invokeRestart("muffleMessage")
[17:43:57.197]                       }
[17:43:57.197]                       else if (inherits(cond, "warning")) {
[17:43:57.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.197]                         if (muffled) 
[17:43:57.197]                           invokeRestart("muffleWarning")
[17:43:57.197]                       }
[17:43:57.197]                       else if (inherits(cond, "condition")) {
[17:43:57.197]                         if (!is.null(pattern)) {
[17:43:57.197]                           computeRestarts <- base::computeRestarts
[17:43:57.197]                           grepl <- base::grepl
[17:43:57.197]                           restarts <- computeRestarts(cond)
[17:43:57.197]                           for (restart in restarts) {
[17:43:57.197]                             name <- restart$name
[17:43:57.197]                             if (is.null(name)) 
[17:43:57.197]                               next
[17:43:57.197]                             if (!grepl(pattern, name)) 
[17:43:57.197]                               next
[17:43:57.197]                             invokeRestart(restart)
[17:43:57.197]                             muffled <- TRUE
[17:43:57.197]                             break
[17:43:57.197]                           }
[17:43:57.197]                         }
[17:43:57.197]                       }
[17:43:57.197]                       invisible(muffled)
[17:43:57.197]                     }
[17:43:57.197]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.197]                   }
[17:43:57.197]                 }
[17:43:57.197]             }
[17:43:57.197]         }))
[17:43:57.197]     }, error = function(ex) {
[17:43:57.197]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.197]                 ...future.rng), started = ...future.startTime, 
[17:43:57.197]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.197]             version = "1.8"), class = "FutureResult")
[17:43:57.197]     }, finally = {
[17:43:57.197]         if (!identical(...future.workdir, getwd())) 
[17:43:57.197]             setwd(...future.workdir)
[17:43:57.197]         {
[17:43:57.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.197]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.197]             }
[17:43:57.197]             base::options(...future.oldOptions)
[17:43:57.197]             if (.Platform$OS.type == "windows") {
[17:43:57.197]                 old_names <- names(...future.oldEnvVars)
[17:43:57.197]                 envs <- base::Sys.getenv()
[17:43:57.197]                 names <- names(envs)
[17:43:57.197]                 common <- intersect(names, old_names)
[17:43:57.197]                 added <- setdiff(names, old_names)
[17:43:57.197]                 removed <- setdiff(old_names, names)
[17:43:57.197]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.197]                   envs[common]]
[17:43:57.197]                 NAMES <- toupper(changed)
[17:43:57.197]                 args <- list()
[17:43:57.197]                 for (kk in seq_along(NAMES)) {
[17:43:57.197]                   name <- changed[[kk]]
[17:43:57.197]                   NAME <- NAMES[[kk]]
[17:43:57.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.197]                     next
[17:43:57.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.197]                 }
[17:43:57.197]                 NAMES <- toupper(added)
[17:43:57.197]                 for (kk in seq_along(NAMES)) {
[17:43:57.197]                   name <- added[[kk]]
[17:43:57.197]                   NAME <- NAMES[[kk]]
[17:43:57.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.197]                     next
[17:43:57.197]                   args[[name]] <- ""
[17:43:57.197]                 }
[17:43:57.197]                 NAMES <- toupper(removed)
[17:43:57.197]                 for (kk in seq_along(NAMES)) {
[17:43:57.197]                   name <- removed[[kk]]
[17:43:57.197]                   NAME <- NAMES[[kk]]
[17:43:57.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.197]                     next
[17:43:57.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.197]                 }
[17:43:57.197]                 if (length(args) > 0) 
[17:43:57.197]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.197]             }
[17:43:57.197]             else {
[17:43:57.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.197]             }
[17:43:57.197]             {
[17:43:57.197]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.197]                   0L) {
[17:43:57.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.197]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.197]                   base::options(opts)
[17:43:57.197]                 }
[17:43:57.197]                 {
[17:43:57.197]                   {
[17:43:57.197]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.197]                     NULL
[17:43:57.197]                   }
[17:43:57.197]                   options(future.plan = NULL)
[17:43:57.197]                   if (is.na(NA_character_)) 
[17:43:57.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.197]                     .init = FALSE)
[17:43:57.197]                 }
[17:43:57.197]             }
[17:43:57.197]         }
[17:43:57.197]     })
[17:43:57.197]     if (TRUE) {
[17:43:57.197]         base::sink(type = "output", split = FALSE)
[17:43:57.197]         if (TRUE) {
[17:43:57.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.197]         }
[17:43:57.197]         else {
[17:43:57.197]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.197]         }
[17:43:57.197]         base::close(...future.stdout)
[17:43:57.197]         ...future.stdout <- NULL
[17:43:57.197]     }
[17:43:57.197]     ...future.result$conditions <- ...future.conditions
[17:43:57.197]     ...future.result$finished <- base::Sys.time()
[17:43:57.197]     ...future.result
[17:43:57.197] }
[17:43:57.200] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[17:43:57.200] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:43:57.201] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:43:57.201] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[17:43:57.201] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[17:43:57.201] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:43:57.202] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:43:57.202] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:57.202] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.202] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:57.203] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.203] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[17:43:57.204] MultisessionFuture started
[17:43:57.204] - Launch lazy future ... done
[17:43:57.204] run() for ‘MultisessionFuture’ ... done
[17:43:57.204] Created future:
[17:43:57.204] MultisessionFuture:
[17:43:57.204] Label: ‘future_eapply-1’
[17:43:57.204] Expression:
[17:43:57.204] {
[17:43:57.204]     do.call(function(...) {
[17:43:57.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.204]             on.exit(options(oopts), add = TRUE)
[17:43:57.204]         }
[17:43:57.204]         {
[17:43:57.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.204]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.204]             })
[17:43:57.204]         }
[17:43:57.204]     }, args = future.call.arguments)
[17:43:57.204] }
[17:43:57.204] Lazy evaluation: FALSE
[17:43:57.204] Asynchronous evaluation: TRUE
[17:43:57.204] Local evaluation: TRUE
[17:43:57.204] Environment: R_GlobalEnv
[17:43:57.204] Capture standard output: TRUE
[17:43:57.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.204] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.204] Packages: 1 packages (‘stats’)
[17:43:57.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.204] Resolved: FALSE
[17:43:57.204] Value: <not collected>
[17:43:57.204] Conditions captured: <none>
[17:43:57.204] Early signaling: FALSE
[17:43:57.204] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.204] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.216] Chunk #1 of 2 ... DONE
[17:43:57.216] Chunk #2 of 2 ...
[17:43:57.216]  - Finding globals in 'X' for chunk #2 ...
[17:43:57.216] getGlobalsAndPackages() ...
[17:43:57.216] Searching for globals...
[17:43:57.217] 
[17:43:57.217] Searching for globals ... DONE
[17:43:57.217] - globals: [0] <none>
[17:43:57.217] getGlobalsAndPackages() ... DONE
[17:43:57.217]    + additional globals found: [n=0] 
[17:43:57.217]    + additional namespaces needed: [n=0] 
[17:43:57.217]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:57.217]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:57.217]  - seeds: <none>
[17:43:57.217]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.218] getGlobalsAndPackages() ...
[17:43:57.218] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.218] Resolving globals: FALSE
[17:43:57.218] Tweak future expression to call with '...' arguments ...
[17:43:57.218] {
[17:43:57.218]     do.call(function(...) {
[17:43:57.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.218]             on.exit(options(oopts), add = TRUE)
[17:43:57.218]         }
[17:43:57.218]         {
[17:43:57.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.218]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.218]             })
[17:43:57.218]         }
[17:43:57.218]     }, args = future.call.arguments)
[17:43:57.218] }
[17:43:57.218] Tweak future expression to call with '...' arguments ... DONE
[17:43:57.219] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.219] - packages: [1] ‘stats’
[17:43:57.219] getGlobalsAndPackages() ... DONE
[17:43:57.219] run() for ‘Future’ ...
[17:43:57.219] - state: ‘created’
[17:43:57.219] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.233]   - Field: ‘node’
[17:43:57.233]   - Field: ‘label’
[17:43:57.233]   - Field: ‘local’
[17:43:57.233]   - Field: ‘owner’
[17:43:57.233]   - Field: ‘envir’
[17:43:57.233]   - Field: ‘workers’
[17:43:57.233]   - Field: ‘packages’
[17:43:57.233]   - Field: ‘gc’
[17:43:57.234]   - Field: ‘conditions’
[17:43:57.234]   - Field: ‘persistent’
[17:43:57.234]   - Field: ‘expr’
[17:43:57.234]   - Field: ‘uuid’
[17:43:57.234]   - Field: ‘seed’
[17:43:57.234]   - Field: ‘version’
[17:43:57.234]   - Field: ‘result’
[17:43:57.234]   - Field: ‘asynchronous’
[17:43:57.234]   - Field: ‘calls’
[17:43:57.234]   - Field: ‘globals’
[17:43:57.234]   - Field: ‘stdout’
[17:43:57.235]   - Field: ‘earlySignal’
[17:43:57.235]   - Field: ‘lazy’
[17:43:57.235]   - Field: ‘state’
[17:43:57.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.235] - Launch lazy future ...
[17:43:57.235] Packages needed by the future expression (n = 1): ‘stats’
[17:43:57.235] Packages needed by future strategies (n = 0): <none>
[17:43:57.236] {
[17:43:57.236]     {
[17:43:57.236]         {
[17:43:57.236]             ...future.startTime <- base::Sys.time()
[17:43:57.236]             {
[17:43:57.236]                 {
[17:43:57.236]                   {
[17:43:57.236]                     {
[17:43:57.236]                       {
[17:43:57.236]                         base::local({
[17:43:57.236]                           has_future <- base::requireNamespace("future", 
[17:43:57.236]                             quietly = TRUE)
[17:43:57.236]                           if (has_future) {
[17:43:57.236]                             ns <- base::getNamespace("future")
[17:43:57.236]                             version <- ns[[".package"]][["version"]]
[17:43:57.236]                             if (is.null(version)) 
[17:43:57.236]                               version <- utils::packageVersion("future")
[17:43:57.236]                           }
[17:43:57.236]                           else {
[17:43:57.236]                             version <- NULL
[17:43:57.236]                           }
[17:43:57.236]                           if (!has_future || version < "1.8.0") {
[17:43:57.236]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.236]                               "", base::R.version$version.string), 
[17:43:57.236]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:57.236]                                 base::R.version$platform, 8 * 
[17:43:57.236]                                   base::.Machine$sizeof.pointer), 
[17:43:57.236]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.236]                                 "release", "version")], collapse = " "), 
[17:43:57.236]                               hostname = base::Sys.info()[["nodename"]])
[17:43:57.236]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.236]                               info)
[17:43:57.236]                             info <- base::paste(info, collapse = "; ")
[17:43:57.236]                             if (!has_future) {
[17:43:57.236]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.236]                                 info)
[17:43:57.236]                             }
[17:43:57.236]                             else {
[17:43:57.236]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.236]                                 info, version)
[17:43:57.236]                             }
[17:43:57.236]                             base::stop(msg)
[17:43:57.236]                           }
[17:43:57.236]                         })
[17:43:57.236]                       }
[17:43:57.236]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.236]                       base::options(mc.cores = 1L)
[17:43:57.236]                     }
[17:43:57.236]                     base::local({
[17:43:57.236]                       for (pkg in "stats") {
[17:43:57.236]                         base::loadNamespace(pkg)
[17:43:57.236]                         base::library(pkg, character.only = TRUE)
[17:43:57.236]                       }
[17:43:57.236]                     })
[17:43:57.236]                   }
[17:43:57.236]                   ...future.strategy.old <- future::plan("list")
[17:43:57.236]                   options(future.plan = NULL)
[17:43:57.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.236]                 }
[17:43:57.236]                 ...future.workdir <- getwd()
[17:43:57.236]             }
[17:43:57.236]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.236]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.236]         }
[17:43:57.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.236]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.236]             base::names(...future.oldOptions))
[17:43:57.236]     }
[17:43:57.236]     if (FALSE) {
[17:43:57.236]     }
[17:43:57.236]     else {
[17:43:57.236]         if (TRUE) {
[17:43:57.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.236]                 open = "w")
[17:43:57.236]         }
[17:43:57.236]         else {
[17:43:57.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.236]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.236]         }
[17:43:57.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.236]             base::sink(type = "output", split = FALSE)
[17:43:57.236]             base::close(...future.stdout)
[17:43:57.236]         }, add = TRUE)
[17:43:57.236]     }
[17:43:57.236]     ...future.frame <- base::sys.nframe()
[17:43:57.236]     ...future.conditions <- base::list()
[17:43:57.236]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.236]     if (FALSE) {
[17:43:57.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.236]     }
[17:43:57.236]     ...future.result <- base::tryCatch({
[17:43:57.236]         base::withCallingHandlers({
[17:43:57.236]             ...future.value <- base::withVisible(base::local({
[17:43:57.236]                 ...future.makeSendCondition <- base::local({
[17:43:57.236]                   sendCondition <- NULL
[17:43:57.236]                   function(frame = 1L) {
[17:43:57.236]                     if (is.function(sendCondition)) 
[17:43:57.236]                       return(sendCondition)
[17:43:57.236]                     ns <- getNamespace("parallel")
[17:43:57.236]                     if (exists("sendData", mode = "function", 
[17:43:57.236]                       envir = ns)) {
[17:43:57.236]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.236]                         envir = ns)
[17:43:57.236]                       envir <- sys.frame(frame)
[17:43:57.236]                       master <- NULL
[17:43:57.236]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.236]                         !identical(envir, emptyenv())) {
[17:43:57.236]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.236]                           inherits = FALSE)) {
[17:43:57.236]                           master <- get("master", mode = "list", 
[17:43:57.236]                             envir = envir, inherits = FALSE)
[17:43:57.236]                           if (inherits(master, c("SOCKnode", 
[17:43:57.236]                             "SOCK0node"))) {
[17:43:57.236]                             sendCondition <<- function(cond) {
[17:43:57.236]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.236]                                 success = TRUE)
[17:43:57.236]                               parallel_sendData(master, data)
[17:43:57.236]                             }
[17:43:57.236]                             return(sendCondition)
[17:43:57.236]                           }
[17:43:57.236]                         }
[17:43:57.236]                         frame <- frame + 1L
[17:43:57.236]                         envir <- sys.frame(frame)
[17:43:57.236]                       }
[17:43:57.236]                     }
[17:43:57.236]                     sendCondition <<- function(cond) NULL
[17:43:57.236]                   }
[17:43:57.236]                 })
[17:43:57.236]                 withCallingHandlers({
[17:43:57.236]                   {
[17:43:57.236]                     do.call(function(...) {
[17:43:57.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.236]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.236]                         ...future.globals.maxSize)) {
[17:43:57.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.236]                         on.exit(options(oopts), add = TRUE)
[17:43:57.236]                       }
[17:43:57.236]                       {
[17:43:57.236]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.236]                           FUN = function(jj) {
[17:43:57.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.236]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.236]                           })
[17:43:57.236]                       }
[17:43:57.236]                     }, args = future.call.arguments)
[17:43:57.236]                   }
[17:43:57.236]                 }, immediateCondition = function(cond) {
[17:43:57.236]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.236]                   sendCondition(cond)
[17:43:57.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.236]                   {
[17:43:57.236]                     inherits <- base::inherits
[17:43:57.236]                     invokeRestart <- base::invokeRestart
[17:43:57.236]                     is.null <- base::is.null
[17:43:57.236]                     muffled <- FALSE
[17:43:57.236]                     if (inherits(cond, "message")) {
[17:43:57.236]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.236]                       if (muffled) 
[17:43:57.236]                         invokeRestart("muffleMessage")
[17:43:57.236]                     }
[17:43:57.236]                     else if (inherits(cond, "warning")) {
[17:43:57.236]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.236]                       if (muffled) 
[17:43:57.236]                         invokeRestart("muffleWarning")
[17:43:57.236]                     }
[17:43:57.236]                     else if (inherits(cond, "condition")) {
[17:43:57.236]                       if (!is.null(pattern)) {
[17:43:57.236]                         computeRestarts <- base::computeRestarts
[17:43:57.236]                         grepl <- base::grepl
[17:43:57.236]                         restarts <- computeRestarts(cond)
[17:43:57.236]                         for (restart in restarts) {
[17:43:57.236]                           name <- restart$name
[17:43:57.236]                           if (is.null(name)) 
[17:43:57.236]                             next
[17:43:57.236]                           if (!grepl(pattern, name)) 
[17:43:57.236]                             next
[17:43:57.236]                           invokeRestart(restart)
[17:43:57.236]                           muffled <- TRUE
[17:43:57.236]                           break
[17:43:57.236]                         }
[17:43:57.236]                       }
[17:43:57.236]                     }
[17:43:57.236]                     invisible(muffled)
[17:43:57.236]                   }
[17:43:57.236]                   muffleCondition(cond)
[17:43:57.236]                 })
[17:43:57.236]             }))
[17:43:57.236]             future::FutureResult(value = ...future.value$value, 
[17:43:57.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.236]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.236]                     ...future.globalenv.names))
[17:43:57.236]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.236]         }, condition = base::local({
[17:43:57.236]             c <- base::c
[17:43:57.236]             inherits <- base::inherits
[17:43:57.236]             invokeRestart <- base::invokeRestart
[17:43:57.236]             length <- base::length
[17:43:57.236]             list <- base::list
[17:43:57.236]             seq.int <- base::seq.int
[17:43:57.236]             signalCondition <- base::signalCondition
[17:43:57.236]             sys.calls <- base::sys.calls
[17:43:57.236]             `[[` <- base::`[[`
[17:43:57.236]             `+` <- base::`+`
[17:43:57.236]             `<<-` <- base::`<<-`
[17:43:57.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.236]                   3L)]
[17:43:57.236]             }
[17:43:57.236]             function(cond) {
[17:43:57.236]                 is_error <- inherits(cond, "error")
[17:43:57.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.236]                   NULL)
[17:43:57.236]                 if (is_error) {
[17:43:57.236]                   sessionInformation <- function() {
[17:43:57.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.236]                       search = base::search(), system = base::Sys.info())
[17:43:57.236]                   }
[17:43:57.236]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.236]                     cond$call), session = sessionInformation(), 
[17:43:57.236]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.236]                   signalCondition(cond)
[17:43:57.236]                 }
[17:43:57.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.236]                 "immediateCondition"))) {
[17:43:57.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.236]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.236]                   if (TRUE && !signal) {
[17:43:57.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.236]                     {
[17:43:57.236]                       inherits <- base::inherits
[17:43:57.236]                       invokeRestart <- base::invokeRestart
[17:43:57.236]                       is.null <- base::is.null
[17:43:57.236]                       muffled <- FALSE
[17:43:57.236]                       if (inherits(cond, "message")) {
[17:43:57.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.236]                         if (muffled) 
[17:43:57.236]                           invokeRestart("muffleMessage")
[17:43:57.236]                       }
[17:43:57.236]                       else if (inherits(cond, "warning")) {
[17:43:57.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.236]                         if (muffled) 
[17:43:57.236]                           invokeRestart("muffleWarning")
[17:43:57.236]                       }
[17:43:57.236]                       else if (inherits(cond, "condition")) {
[17:43:57.236]                         if (!is.null(pattern)) {
[17:43:57.236]                           computeRestarts <- base::computeRestarts
[17:43:57.236]                           grepl <- base::grepl
[17:43:57.236]                           restarts <- computeRestarts(cond)
[17:43:57.236]                           for (restart in restarts) {
[17:43:57.236]                             name <- restart$name
[17:43:57.236]                             if (is.null(name)) 
[17:43:57.236]                               next
[17:43:57.236]                             if (!grepl(pattern, name)) 
[17:43:57.236]                               next
[17:43:57.236]                             invokeRestart(restart)
[17:43:57.236]                             muffled <- TRUE
[17:43:57.236]                             break
[17:43:57.236]                           }
[17:43:57.236]                         }
[17:43:57.236]                       }
[17:43:57.236]                       invisible(muffled)
[17:43:57.236]                     }
[17:43:57.236]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.236]                   }
[17:43:57.236]                 }
[17:43:57.236]                 else {
[17:43:57.236]                   if (TRUE) {
[17:43:57.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.236]                     {
[17:43:57.236]                       inherits <- base::inherits
[17:43:57.236]                       invokeRestart <- base::invokeRestart
[17:43:57.236]                       is.null <- base::is.null
[17:43:57.236]                       muffled <- FALSE
[17:43:57.236]                       if (inherits(cond, "message")) {
[17:43:57.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.236]                         if (muffled) 
[17:43:57.236]                           invokeRestart("muffleMessage")
[17:43:57.236]                       }
[17:43:57.236]                       else if (inherits(cond, "warning")) {
[17:43:57.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.236]                         if (muffled) 
[17:43:57.236]                           invokeRestart("muffleWarning")
[17:43:57.236]                       }
[17:43:57.236]                       else if (inherits(cond, "condition")) {
[17:43:57.236]                         if (!is.null(pattern)) {
[17:43:57.236]                           computeRestarts <- base::computeRestarts
[17:43:57.236]                           grepl <- base::grepl
[17:43:57.236]                           restarts <- computeRestarts(cond)
[17:43:57.236]                           for (restart in restarts) {
[17:43:57.236]                             name <- restart$name
[17:43:57.236]                             if (is.null(name)) 
[17:43:57.236]                               next
[17:43:57.236]                             if (!grepl(pattern, name)) 
[17:43:57.236]                               next
[17:43:57.236]                             invokeRestart(restart)
[17:43:57.236]                             muffled <- TRUE
[17:43:57.236]                             break
[17:43:57.236]                           }
[17:43:57.236]                         }
[17:43:57.236]                       }
[17:43:57.236]                       invisible(muffled)
[17:43:57.236]                     }
[17:43:57.236]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.236]                   }
[17:43:57.236]                 }
[17:43:57.236]             }
[17:43:57.236]         }))
[17:43:57.236]     }, error = function(ex) {
[17:43:57.236]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.236]                 ...future.rng), started = ...future.startTime, 
[17:43:57.236]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.236]             version = "1.8"), class = "FutureResult")
[17:43:57.236]     }, finally = {
[17:43:57.236]         if (!identical(...future.workdir, getwd())) 
[17:43:57.236]             setwd(...future.workdir)
[17:43:57.236]         {
[17:43:57.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.236]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.236]             }
[17:43:57.236]             base::options(...future.oldOptions)
[17:43:57.236]             if (.Platform$OS.type == "windows") {
[17:43:57.236]                 old_names <- names(...future.oldEnvVars)
[17:43:57.236]                 envs <- base::Sys.getenv()
[17:43:57.236]                 names <- names(envs)
[17:43:57.236]                 common <- intersect(names, old_names)
[17:43:57.236]                 added <- setdiff(names, old_names)
[17:43:57.236]                 removed <- setdiff(old_names, names)
[17:43:57.236]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.236]                   envs[common]]
[17:43:57.236]                 NAMES <- toupper(changed)
[17:43:57.236]                 args <- list()
[17:43:57.236]                 for (kk in seq_along(NAMES)) {
[17:43:57.236]                   name <- changed[[kk]]
[17:43:57.236]                   NAME <- NAMES[[kk]]
[17:43:57.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.236]                     next
[17:43:57.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.236]                 }
[17:43:57.236]                 NAMES <- toupper(added)
[17:43:57.236]                 for (kk in seq_along(NAMES)) {
[17:43:57.236]                   name <- added[[kk]]
[17:43:57.236]                   NAME <- NAMES[[kk]]
[17:43:57.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.236]                     next
[17:43:57.236]                   args[[name]] <- ""
[17:43:57.236]                 }
[17:43:57.236]                 NAMES <- toupper(removed)
[17:43:57.236]                 for (kk in seq_along(NAMES)) {
[17:43:57.236]                   name <- removed[[kk]]
[17:43:57.236]                   NAME <- NAMES[[kk]]
[17:43:57.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.236]                     next
[17:43:57.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.236]                 }
[17:43:57.236]                 if (length(args) > 0) 
[17:43:57.236]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.236]             }
[17:43:57.236]             else {
[17:43:57.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.236]             }
[17:43:57.236]             {
[17:43:57.236]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.236]                   0L) {
[17:43:57.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.236]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.236]                   base::options(opts)
[17:43:57.236]                 }
[17:43:57.236]                 {
[17:43:57.236]                   {
[17:43:57.236]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.236]                     NULL
[17:43:57.236]                   }
[17:43:57.236]                   options(future.plan = NULL)
[17:43:57.236]                   if (is.na(NA_character_)) 
[17:43:57.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.236]                     .init = FALSE)
[17:43:57.236]                 }
[17:43:57.236]             }
[17:43:57.236]         }
[17:43:57.236]     })
[17:43:57.236]     if (TRUE) {
[17:43:57.236]         base::sink(type = "output", split = FALSE)
[17:43:57.236]         if (TRUE) {
[17:43:57.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.236]         }
[17:43:57.236]         else {
[17:43:57.236]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.236]         }
[17:43:57.236]         base::close(...future.stdout)
[17:43:57.236]         ...future.stdout <- NULL
[17:43:57.236]     }
[17:43:57.236]     ...future.result$conditions <- ...future.conditions
[17:43:57.236]     ...future.result$finished <- base::Sys.time()
[17:43:57.236]     ...future.result
[17:43:57.236] }
[17:43:57.238] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[17:43:57.239] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:43:57.239] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:43:57.239] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[17:43:57.240] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[17:43:57.240] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:43:57.240] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:43:57.240] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:57.240] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.241] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:57.241] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.241] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[17:43:57.241] MultisessionFuture started
[17:43:57.241] - Launch lazy future ... done
[17:43:57.242] run() for ‘MultisessionFuture’ ... done
[17:43:57.242] Created future:
[17:43:57.242] MultisessionFuture:
[17:43:57.242] Label: ‘future_eapply-2’
[17:43:57.242] Expression:
[17:43:57.242] {
[17:43:57.242]     do.call(function(...) {
[17:43:57.242]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.242]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.242]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.242]             on.exit(options(oopts), add = TRUE)
[17:43:57.242]         }
[17:43:57.242]         {
[17:43:57.242]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.242]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.242]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.242]             })
[17:43:57.242]         }
[17:43:57.242]     }, args = future.call.arguments)
[17:43:57.242] }
[17:43:57.242] Lazy evaluation: FALSE
[17:43:57.242] Asynchronous evaluation: TRUE
[17:43:57.242] Local evaluation: TRUE
[17:43:57.242] Environment: R_GlobalEnv
[17:43:57.242] Capture standard output: TRUE
[17:43:57.242] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.242] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.242] Packages: 1 packages (‘stats’)
[17:43:57.242] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.242] Resolved: FALSE
[17:43:57.242] Value: <not collected>
[17:43:57.242] Conditions captured: <none>
[17:43:57.242] Early signaling: FALSE
[17:43:57.242] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.242] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.253] Chunk #2 of 2 ... DONE
[17:43:57.253] Launching 2 futures (chunks) ... DONE
[17:43:57.253] Resolving 2 futures (chunks) ...
[17:43:57.254] resolve() on list ...
[17:43:57.254]  recursive: 0
[17:43:57.254]  length: 2
[17:43:57.254] 
[17:43:57.254] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.254] - Validating connection of MultisessionFuture
[17:43:57.255] - received message: FutureResult
[17:43:57.255] - Received FutureResult
[17:43:57.255] - Erased future from FutureRegistry
[17:43:57.255] result() for ClusterFuture ...
[17:43:57.255] - result already collected: FutureResult
[17:43:57.255] result() for ClusterFuture ... done
[17:43:57.255] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.255] Future #1
[17:43:57.255] result() for ClusterFuture ...
[17:43:57.256] - result already collected: FutureResult
[17:43:57.256] result() for ClusterFuture ... done
[17:43:57.256] result() for ClusterFuture ...
[17:43:57.256] - result already collected: FutureResult
[17:43:57.256] result() for ClusterFuture ... done
[17:43:57.256] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:57.256] - nx: 2
[17:43:57.256] - relay: TRUE
[17:43:57.256] - stdout: TRUE
[17:43:57.256] - signal: TRUE
[17:43:57.256] - resignal: FALSE
[17:43:57.257] - force: TRUE
[17:43:57.257] - relayed: [n=2] FALSE, FALSE
[17:43:57.257] - queued futures: [n=2] FALSE, FALSE
[17:43:57.257]  - until=1
[17:43:57.257]  - relaying element #1
[17:43:57.257] result() for ClusterFuture ...
[17:43:57.257] - result already collected: FutureResult
[17:43:57.257] result() for ClusterFuture ... done
[17:43:57.257] result() for ClusterFuture ...
[17:43:57.257] - result already collected: FutureResult
[17:43:57.257] result() for ClusterFuture ... done
[17:43:57.257] result() for ClusterFuture ...
[17:43:57.258] - result already collected: FutureResult
[17:43:57.258] result() for ClusterFuture ... done
[17:43:57.258] result() for ClusterFuture ...
[17:43:57.258] - result already collected: FutureResult
[17:43:57.258] result() for ClusterFuture ... done
[17:43:57.258] - relayed: [n=2] TRUE, FALSE
[17:43:57.258] - queued futures: [n=2] TRUE, FALSE
[17:43:57.258] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:57.258]  length: 1 (resolved future 1)
[17:43:57.300] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.300] - Validating connection of MultisessionFuture
[17:43:57.300] - received message: FutureResult
[17:43:57.300] - Received FutureResult
[17:43:57.301] - Erased future from FutureRegistry
[17:43:57.301] result() for ClusterFuture ...
[17:43:57.301] - result already collected: FutureResult
[17:43:57.301] result() for ClusterFuture ... done
[17:43:57.301] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.301] Future #2
[17:43:57.301] result() for ClusterFuture ...
[17:43:57.301] - result already collected: FutureResult
[17:43:57.301] result() for ClusterFuture ... done
[17:43:57.301] result() for ClusterFuture ...
[17:43:57.301] - result already collected: FutureResult
[17:43:57.302] result() for ClusterFuture ... done
[17:43:57.302] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:57.302] - nx: 2
[17:43:57.302] - relay: TRUE
[17:43:57.302] - stdout: TRUE
[17:43:57.302] - signal: TRUE
[17:43:57.302] - resignal: FALSE
[17:43:57.302] - force: TRUE
[17:43:57.302] - relayed: [n=2] TRUE, FALSE
[17:43:57.302] - queued futures: [n=2] TRUE, FALSE
[17:43:57.302]  - until=2
[17:43:57.303]  - relaying element #2
[17:43:57.303] result() for ClusterFuture ...
[17:43:57.303] - result already collected: FutureResult
[17:43:57.303] result() for ClusterFuture ... done
[17:43:57.303] result() for ClusterFuture ...
[17:43:57.303] - result already collected: FutureResult
[17:43:57.303] result() for ClusterFuture ... done
[17:43:57.303] result() for ClusterFuture ...
[17:43:57.303] - result already collected: FutureResult
[17:43:57.303] result() for ClusterFuture ... done
[17:43:57.303] result() for ClusterFuture ...
[17:43:57.304] - result already collected: FutureResult
[17:43:57.304] result() for ClusterFuture ... done
[17:43:57.304] - relayed: [n=2] TRUE, TRUE
[17:43:57.304] - queued futures: [n=2] TRUE, TRUE
[17:43:57.304] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:57.304]  length: 0 (resolved future 2)
[17:43:57.304] Relaying remaining futures
[17:43:57.304] signalConditionsASAP(NULL, pos=0) ...
[17:43:57.304] - nx: 2
[17:43:57.304] - relay: TRUE
[17:43:57.304] - stdout: TRUE
[17:43:57.304] - signal: TRUE
[17:43:57.305] - resignal: FALSE
[17:43:57.305] - force: TRUE
[17:43:57.305] - relayed: [n=2] TRUE, TRUE
[17:43:57.305] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:57.305] - relayed: [n=2] TRUE, TRUE
[17:43:57.305] - queued futures: [n=2] TRUE, TRUE
[17:43:57.305] signalConditionsASAP(NULL, pos=0) ... done
[17:43:57.305] resolve() on list ... DONE
[17:43:57.305] result() for ClusterFuture ...
[17:43:57.305] - result already collected: FutureResult
[17:43:57.305] result() for ClusterFuture ... done
[17:43:57.306] result() for ClusterFuture ...
[17:43:57.306] - result already collected: FutureResult
[17:43:57.306] result() for ClusterFuture ... done
[17:43:57.306] result() for ClusterFuture ...
[17:43:57.306] - result already collected: FutureResult
[17:43:57.306] result() for ClusterFuture ... done
[17:43:57.306] result() for ClusterFuture ...
[17:43:57.306] - result already collected: FutureResult
[17:43:57.306] result() for ClusterFuture ... done
[17:43:57.306]  - Number of value chunks collected: 2
[17:43:57.306] Resolving 2 futures (chunks) ... DONE
[17:43:57.307] Reducing values from 2 chunks ...
[17:43:57.307]  - Number of values collected after concatenation: 3
[17:43:57.307]  - Number of values expected: 3
[17:43:57.307] Reducing values from 2 chunks ... DONE
[17:43:57.307] future_lapply() ... DONE
[17:43:57.308] future_lapply() ...
[17:43:57.312] Number of chunks: 2
[17:43:57.312] getGlobalsAndPackagesXApply() ...
[17:43:57.312]  - future.globals: TRUE
[17:43:57.312] getGlobalsAndPackages() ...
[17:43:57.312] Searching for globals...
[17:43:57.313] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:57.313] Searching for globals ... DONE
[17:43:57.313] Resolving globals: FALSE
[17:43:57.314] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:57.314] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:57.314] - globals: [1] ‘FUN’
[17:43:57.314] - packages: [1] ‘stats’
[17:43:57.314] getGlobalsAndPackages() ... DONE
[17:43:57.315]  - globals found/used: [n=1] ‘FUN’
[17:43:57.315]  - needed namespaces: [n=1] ‘stats’
[17:43:57.315] Finding globals ... DONE
[17:43:57.315]  - use_args: TRUE
[17:43:57.315]  - Getting '...' globals ...
[17:43:57.315] resolve() on list ...
[17:43:57.315]  recursive: 0
[17:43:57.315]  length: 1
[17:43:57.316]  elements: ‘...’
[17:43:57.316]  length: 0 (resolved future 1)
[17:43:57.316] resolve() on list ... DONE
[17:43:57.316]    - '...' content: [n=0] 
[17:43:57.316] List of 1
[17:43:57.316]  $ ...: list()
[17:43:57.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:57.316]  - attr(*, "where")=List of 1
[17:43:57.316]   ..$ ...:<environment: 0x5581403340c8> 
[17:43:57.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:57.316]  - attr(*, "resolved")= logi TRUE
[17:43:57.316]  - attr(*, "total_size")= num NA
[17:43:57.318]  - Getting '...' globals ... DONE
[17:43:57.324] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:57.324] List of 2
[17:43:57.324]  $ ...future.FUN:function (x, ...)  
[17:43:57.324]  $ ...          : list()
[17:43:57.324]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:57.324]  - attr(*, "where")=List of 2
[17:43:57.324]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:57.324]   ..$ ...          :<environment: 0x5581403340c8> 
[17:43:57.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:57.324]  - attr(*, "resolved")= logi FALSE
[17:43:57.324]  - attr(*, "total_size")= num 1248
[17:43:57.326] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:57.326] getGlobalsAndPackagesXApply() ... DONE
[17:43:57.327] Number of futures (= number of chunks): 2
[17:43:57.327] Launching 2 futures (chunks) ...
[17:43:57.327] Chunk #1 of 2 ...
[17:43:57.327]  - Finding globals in 'X' for chunk #1 ...
[17:43:57.327] getGlobalsAndPackages() ...
[17:43:57.327] Searching for globals...
[17:43:57.327] 
[17:43:57.328] Searching for globals ... DONE
[17:43:57.328] - globals: [0] <none>
[17:43:57.328] getGlobalsAndPackages() ... DONE
[17:43:57.328]    + additional globals found: [n=0] 
[17:43:57.328]    + additional namespaces needed: [n=0] 
[17:43:57.328]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:57.328]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:57.328]  - seeds: <none>
[17:43:57.328]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.328] getGlobalsAndPackages() ...
[17:43:57.328] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.329] Resolving globals: FALSE
[17:43:57.329] Tweak future expression to call with '...' arguments ...
[17:43:57.329] {
[17:43:57.329]     do.call(function(...) {
[17:43:57.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.329]             on.exit(options(oopts), add = TRUE)
[17:43:57.329]         }
[17:43:57.329]         {
[17:43:57.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.329]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.329]             })
[17:43:57.329]         }
[17:43:57.329]     }, args = future.call.arguments)
[17:43:57.329] }
[17:43:57.329] Tweak future expression to call with '...' arguments ... DONE
[17:43:57.329] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.329] - packages: [1] ‘stats’
[17:43:57.330] getGlobalsAndPackages() ... DONE
[17:43:57.330] run() for ‘Future’ ...
[17:43:57.330] - state: ‘created’
[17:43:57.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.343] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.344]   - Field: ‘node’
[17:43:57.344]   - Field: ‘label’
[17:43:57.344]   - Field: ‘local’
[17:43:57.344]   - Field: ‘owner’
[17:43:57.344]   - Field: ‘envir’
[17:43:57.344]   - Field: ‘workers’
[17:43:57.344]   - Field: ‘packages’
[17:43:57.344]   - Field: ‘gc’
[17:43:57.344]   - Field: ‘conditions’
[17:43:57.345]   - Field: ‘persistent’
[17:43:57.345]   - Field: ‘expr’
[17:43:57.345]   - Field: ‘uuid’
[17:43:57.345]   - Field: ‘seed’
[17:43:57.345]   - Field: ‘version’
[17:43:57.345]   - Field: ‘result’
[17:43:57.345]   - Field: ‘asynchronous’
[17:43:57.345]   - Field: ‘calls’
[17:43:57.345]   - Field: ‘globals’
[17:43:57.345]   - Field: ‘stdout’
[17:43:57.345]   - Field: ‘earlySignal’
[17:43:57.346]   - Field: ‘lazy’
[17:43:57.346]   - Field: ‘state’
[17:43:57.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.346] - Launch lazy future ...
[17:43:57.346] Packages needed by the future expression (n = 1): ‘stats’
[17:43:57.346] Packages needed by future strategies (n = 0): <none>
[17:43:57.347] {
[17:43:57.347]     {
[17:43:57.347]         {
[17:43:57.347]             ...future.startTime <- base::Sys.time()
[17:43:57.347]             {
[17:43:57.347]                 {
[17:43:57.347]                   {
[17:43:57.347]                     {
[17:43:57.347]                       {
[17:43:57.347]                         base::local({
[17:43:57.347]                           has_future <- base::requireNamespace("future", 
[17:43:57.347]                             quietly = TRUE)
[17:43:57.347]                           if (has_future) {
[17:43:57.347]                             ns <- base::getNamespace("future")
[17:43:57.347]                             version <- ns[[".package"]][["version"]]
[17:43:57.347]                             if (is.null(version)) 
[17:43:57.347]                               version <- utils::packageVersion("future")
[17:43:57.347]                           }
[17:43:57.347]                           else {
[17:43:57.347]                             version <- NULL
[17:43:57.347]                           }
[17:43:57.347]                           if (!has_future || version < "1.8.0") {
[17:43:57.347]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.347]                               "", base::R.version$version.string), 
[17:43:57.347]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:57.347]                                 base::R.version$platform, 8 * 
[17:43:57.347]                                   base::.Machine$sizeof.pointer), 
[17:43:57.347]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.347]                                 "release", "version")], collapse = " "), 
[17:43:57.347]                               hostname = base::Sys.info()[["nodename"]])
[17:43:57.347]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.347]                               info)
[17:43:57.347]                             info <- base::paste(info, collapse = "; ")
[17:43:57.347]                             if (!has_future) {
[17:43:57.347]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.347]                                 info)
[17:43:57.347]                             }
[17:43:57.347]                             else {
[17:43:57.347]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.347]                                 info, version)
[17:43:57.347]                             }
[17:43:57.347]                             base::stop(msg)
[17:43:57.347]                           }
[17:43:57.347]                         })
[17:43:57.347]                       }
[17:43:57.347]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.347]                       base::options(mc.cores = 1L)
[17:43:57.347]                     }
[17:43:57.347]                     base::local({
[17:43:57.347]                       for (pkg in "stats") {
[17:43:57.347]                         base::loadNamespace(pkg)
[17:43:57.347]                         base::library(pkg, character.only = TRUE)
[17:43:57.347]                       }
[17:43:57.347]                     })
[17:43:57.347]                   }
[17:43:57.347]                   ...future.strategy.old <- future::plan("list")
[17:43:57.347]                   options(future.plan = NULL)
[17:43:57.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.347]                 }
[17:43:57.347]                 ...future.workdir <- getwd()
[17:43:57.347]             }
[17:43:57.347]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.347]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.347]         }
[17:43:57.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.347]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.347]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.347]             base::names(...future.oldOptions))
[17:43:57.347]     }
[17:43:57.347]     if (FALSE) {
[17:43:57.347]     }
[17:43:57.347]     else {
[17:43:57.347]         if (TRUE) {
[17:43:57.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.347]                 open = "w")
[17:43:57.347]         }
[17:43:57.347]         else {
[17:43:57.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.347]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.347]         }
[17:43:57.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.347]             base::sink(type = "output", split = FALSE)
[17:43:57.347]             base::close(...future.stdout)
[17:43:57.347]         }, add = TRUE)
[17:43:57.347]     }
[17:43:57.347]     ...future.frame <- base::sys.nframe()
[17:43:57.347]     ...future.conditions <- base::list()
[17:43:57.347]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.347]     if (FALSE) {
[17:43:57.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.347]     }
[17:43:57.347]     ...future.result <- base::tryCatch({
[17:43:57.347]         base::withCallingHandlers({
[17:43:57.347]             ...future.value <- base::withVisible(base::local({
[17:43:57.347]                 ...future.makeSendCondition <- base::local({
[17:43:57.347]                   sendCondition <- NULL
[17:43:57.347]                   function(frame = 1L) {
[17:43:57.347]                     if (is.function(sendCondition)) 
[17:43:57.347]                       return(sendCondition)
[17:43:57.347]                     ns <- getNamespace("parallel")
[17:43:57.347]                     if (exists("sendData", mode = "function", 
[17:43:57.347]                       envir = ns)) {
[17:43:57.347]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.347]                         envir = ns)
[17:43:57.347]                       envir <- sys.frame(frame)
[17:43:57.347]                       master <- NULL
[17:43:57.347]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.347]                         !identical(envir, emptyenv())) {
[17:43:57.347]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.347]                           inherits = FALSE)) {
[17:43:57.347]                           master <- get("master", mode = "list", 
[17:43:57.347]                             envir = envir, inherits = FALSE)
[17:43:57.347]                           if (inherits(master, c("SOCKnode", 
[17:43:57.347]                             "SOCK0node"))) {
[17:43:57.347]                             sendCondition <<- function(cond) {
[17:43:57.347]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.347]                                 success = TRUE)
[17:43:57.347]                               parallel_sendData(master, data)
[17:43:57.347]                             }
[17:43:57.347]                             return(sendCondition)
[17:43:57.347]                           }
[17:43:57.347]                         }
[17:43:57.347]                         frame <- frame + 1L
[17:43:57.347]                         envir <- sys.frame(frame)
[17:43:57.347]                       }
[17:43:57.347]                     }
[17:43:57.347]                     sendCondition <<- function(cond) NULL
[17:43:57.347]                   }
[17:43:57.347]                 })
[17:43:57.347]                 withCallingHandlers({
[17:43:57.347]                   {
[17:43:57.347]                     do.call(function(...) {
[17:43:57.347]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.347]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.347]                         ...future.globals.maxSize)) {
[17:43:57.347]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.347]                         on.exit(options(oopts), add = TRUE)
[17:43:57.347]                       }
[17:43:57.347]                       {
[17:43:57.347]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.347]                           FUN = function(jj) {
[17:43:57.347]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.347]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.347]                           })
[17:43:57.347]                       }
[17:43:57.347]                     }, args = future.call.arguments)
[17:43:57.347]                   }
[17:43:57.347]                 }, immediateCondition = function(cond) {
[17:43:57.347]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.347]                   sendCondition(cond)
[17:43:57.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.347]                   {
[17:43:57.347]                     inherits <- base::inherits
[17:43:57.347]                     invokeRestart <- base::invokeRestart
[17:43:57.347]                     is.null <- base::is.null
[17:43:57.347]                     muffled <- FALSE
[17:43:57.347]                     if (inherits(cond, "message")) {
[17:43:57.347]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.347]                       if (muffled) 
[17:43:57.347]                         invokeRestart("muffleMessage")
[17:43:57.347]                     }
[17:43:57.347]                     else if (inherits(cond, "warning")) {
[17:43:57.347]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.347]                       if (muffled) 
[17:43:57.347]                         invokeRestart("muffleWarning")
[17:43:57.347]                     }
[17:43:57.347]                     else if (inherits(cond, "condition")) {
[17:43:57.347]                       if (!is.null(pattern)) {
[17:43:57.347]                         computeRestarts <- base::computeRestarts
[17:43:57.347]                         grepl <- base::grepl
[17:43:57.347]                         restarts <- computeRestarts(cond)
[17:43:57.347]                         for (restart in restarts) {
[17:43:57.347]                           name <- restart$name
[17:43:57.347]                           if (is.null(name)) 
[17:43:57.347]                             next
[17:43:57.347]                           if (!grepl(pattern, name)) 
[17:43:57.347]                             next
[17:43:57.347]                           invokeRestart(restart)
[17:43:57.347]                           muffled <- TRUE
[17:43:57.347]                           break
[17:43:57.347]                         }
[17:43:57.347]                       }
[17:43:57.347]                     }
[17:43:57.347]                     invisible(muffled)
[17:43:57.347]                   }
[17:43:57.347]                   muffleCondition(cond)
[17:43:57.347]                 })
[17:43:57.347]             }))
[17:43:57.347]             future::FutureResult(value = ...future.value$value, 
[17:43:57.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.347]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.347]                     ...future.globalenv.names))
[17:43:57.347]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.347]         }, condition = base::local({
[17:43:57.347]             c <- base::c
[17:43:57.347]             inherits <- base::inherits
[17:43:57.347]             invokeRestart <- base::invokeRestart
[17:43:57.347]             length <- base::length
[17:43:57.347]             list <- base::list
[17:43:57.347]             seq.int <- base::seq.int
[17:43:57.347]             signalCondition <- base::signalCondition
[17:43:57.347]             sys.calls <- base::sys.calls
[17:43:57.347]             `[[` <- base::`[[`
[17:43:57.347]             `+` <- base::`+`
[17:43:57.347]             `<<-` <- base::`<<-`
[17:43:57.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.347]                   3L)]
[17:43:57.347]             }
[17:43:57.347]             function(cond) {
[17:43:57.347]                 is_error <- inherits(cond, "error")
[17:43:57.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.347]                   NULL)
[17:43:57.347]                 if (is_error) {
[17:43:57.347]                   sessionInformation <- function() {
[17:43:57.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.347]                       search = base::search(), system = base::Sys.info())
[17:43:57.347]                   }
[17:43:57.347]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.347]                     cond$call), session = sessionInformation(), 
[17:43:57.347]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.347]                   signalCondition(cond)
[17:43:57.347]                 }
[17:43:57.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.347]                 "immediateCondition"))) {
[17:43:57.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.347]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.347]                   if (TRUE && !signal) {
[17:43:57.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.347]                     {
[17:43:57.347]                       inherits <- base::inherits
[17:43:57.347]                       invokeRestart <- base::invokeRestart
[17:43:57.347]                       is.null <- base::is.null
[17:43:57.347]                       muffled <- FALSE
[17:43:57.347]                       if (inherits(cond, "message")) {
[17:43:57.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.347]                         if (muffled) 
[17:43:57.347]                           invokeRestart("muffleMessage")
[17:43:57.347]                       }
[17:43:57.347]                       else if (inherits(cond, "warning")) {
[17:43:57.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.347]                         if (muffled) 
[17:43:57.347]                           invokeRestart("muffleWarning")
[17:43:57.347]                       }
[17:43:57.347]                       else if (inherits(cond, "condition")) {
[17:43:57.347]                         if (!is.null(pattern)) {
[17:43:57.347]                           computeRestarts <- base::computeRestarts
[17:43:57.347]                           grepl <- base::grepl
[17:43:57.347]                           restarts <- computeRestarts(cond)
[17:43:57.347]                           for (restart in restarts) {
[17:43:57.347]                             name <- restart$name
[17:43:57.347]                             if (is.null(name)) 
[17:43:57.347]                               next
[17:43:57.347]                             if (!grepl(pattern, name)) 
[17:43:57.347]                               next
[17:43:57.347]                             invokeRestart(restart)
[17:43:57.347]                             muffled <- TRUE
[17:43:57.347]                             break
[17:43:57.347]                           }
[17:43:57.347]                         }
[17:43:57.347]                       }
[17:43:57.347]                       invisible(muffled)
[17:43:57.347]                     }
[17:43:57.347]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.347]                   }
[17:43:57.347]                 }
[17:43:57.347]                 else {
[17:43:57.347]                   if (TRUE) {
[17:43:57.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.347]                     {
[17:43:57.347]                       inherits <- base::inherits
[17:43:57.347]                       invokeRestart <- base::invokeRestart
[17:43:57.347]                       is.null <- base::is.null
[17:43:57.347]                       muffled <- FALSE
[17:43:57.347]                       if (inherits(cond, "message")) {
[17:43:57.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.347]                         if (muffled) 
[17:43:57.347]                           invokeRestart("muffleMessage")
[17:43:57.347]                       }
[17:43:57.347]                       else if (inherits(cond, "warning")) {
[17:43:57.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.347]                         if (muffled) 
[17:43:57.347]                           invokeRestart("muffleWarning")
[17:43:57.347]                       }
[17:43:57.347]                       else if (inherits(cond, "condition")) {
[17:43:57.347]                         if (!is.null(pattern)) {
[17:43:57.347]                           computeRestarts <- base::computeRestarts
[17:43:57.347]                           grepl <- base::grepl
[17:43:57.347]                           restarts <- computeRestarts(cond)
[17:43:57.347]                           for (restart in restarts) {
[17:43:57.347]                             name <- restart$name
[17:43:57.347]                             if (is.null(name)) 
[17:43:57.347]                               next
[17:43:57.347]                             if (!grepl(pattern, name)) 
[17:43:57.347]                               next
[17:43:57.347]                             invokeRestart(restart)
[17:43:57.347]                             muffled <- TRUE
[17:43:57.347]                             break
[17:43:57.347]                           }
[17:43:57.347]                         }
[17:43:57.347]                       }
[17:43:57.347]                       invisible(muffled)
[17:43:57.347]                     }
[17:43:57.347]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.347]                   }
[17:43:57.347]                 }
[17:43:57.347]             }
[17:43:57.347]         }))
[17:43:57.347]     }, error = function(ex) {
[17:43:57.347]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.347]                 ...future.rng), started = ...future.startTime, 
[17:43:57.347]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.347]             version = "1.8"), class = "FutureResult")
[17:43:57.347]     }, finally = {
[17:43:57.347]         if (!identical(...future.workdir, getwd())) 
[17:43:57.347]             setwd(...future.workdir)
[17:43:57.347]         {
[17:43:57.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.347]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.347]             }
[17:43:57.347]             base::options(...future.oldOptions)
[17:43:57.347]             if (.Platform$OS.type == "windows") {
[17:43:57.347]                 old_names <- names(...future.oldEnvVars)
[17:43:57.347]                 envs <- base::Sys.getenv()
[17:43:57.347]                 names <- names(envs)
[17:43:57.347]                 common <- intersect(names, old_names)
[17:43:57.347]                 added <- setdiff(names, old_names)
[17:43:57.347]                 removed <- setdiff(old_names, names)
[17:43:57.347]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.347]                   envs[common]]
[17:43:57.347]                 NAMES <- toupper(changed)
[17:43:57.347]                 args <- list()
[17:43:57.347]                 for (kk in seq_along(NAMES)) {
[17:43:57.347]                   name <- changed[[kk]]
[17:43:57.347]                   NAME <- NAMES[[kk]]
[17:43:57.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.347]                     next
[17:43:57.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.347]                 }
[17:43:57.347]                 NAMES <- toupper(added)
[17:43:57.347]                 for (kk in seq_along(NAMES)) {
[17:43:57.347]                   name <- added[[kk]]
[17:43:57.347]                   NAME <- NAMES[[kk]]
[17:43:57.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.347]                     next
[17:43:57.347]                   args[[name]] <- ""
[17:43:57.347]                 }
[17:43:57.347]                 NAMES <- toupper(removed)
[17:43:57.347]                 for (kk in seq_along(NAMES)) {
[17:43:57.347]                   name <- removed[[kk]]
[17:43:57.347]                   NAME <- NAMES[[kk]]
[17:43:57.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.347]                     next
[17:43:57.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.347]                 }
[17:43:57.347]                 if (length(args) > 0) 
[17:43:57.347]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.347]             }
[17:43:57.347]             else {
[17:43:57.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.347]             }
[17:43:57.347]             {
[17:43:57.347]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.347]                   0L) {
[17:43:57.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.347]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.347]                   base::options(opts)
[17:43:57.347]                 }
[17:43:57.347]                 {
[17:43:57.347]                   {
[17:43:57.347]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.347]                     NULL
[17:43:57.347]                   }
[17:43:57.347]                   options(future.plan = NULL)
[17:43:57.347]                   if (is.na(NA_character_)) 
[17:43:57.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.347]                     .init = FALSE)
[17:43:57.347]                 }
[17:43:57.347]             }
[17:43:57.347]         }
[17:43:57.347]     })
[17:43:57.347]     if (TRUE) {
[17:43:57.347]         base::sink(type = "output", split = FALSE)
[17:43:57.347]         if (TRUE) {
[17:43:57.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.347]         }
[17:43:57.347]         else {
[17:43:57.347]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.347]         }
[17:43:57.347]         base::close(...future.stdout)
[17:43:57.347]         ...future.stdout <- NULL
[17:43:57.347]     }
[17:43:57.347]     ...future.result$conditions <- ...future.conditions
[17:43:57.347]     ...future.result$finished <- base::Sys.time()
[17:43:57.347]     ...future.result
[17:43:57.347] }
[17:43:57.349] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:43:57.350] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:43:57.350] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:43:57.350] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:57.350] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.351] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:43:57.351] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:43:57.351] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:57.351] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.351] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:57.352] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.352] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:43:57.352] MultisessionFuture started
[17:43:57.352] - Launch lazy future ... done
[17:43:57.353] run() for ‘MultisessionFuture’ ... done
[17:43:57.353] Created future:
[17:43:57.353] MultisessionFuture:
[17:43:57.353] Label: ‘future_eapply-1’
[17:43:57.353] Expression:
[17:43:57.353] {
[17:43:57.353]     do.call(function(...) {
[17:43:57.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.353]             on.exit(options(oopts), add = TRUE)
[17:43:57.353]         }
[17:43:57.353]         {
[17:43:57.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.353]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.353]             })
[17:43:57.353]         }
[17:43:57.353]     }, args = future.call.arguments)
[17:43:57.353] }
[17:43:57.353] Lazy evaluation: FALSE
[17:43:57.353] Asynchronous evaluation: TRUE
[17:43:57.353] Local evaluation: TRUE
[17:43:57.353] Environment: R_GlobalEnv
[17:43:57.353] Capture standard output: TRUE
[17:43:57.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.353] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.353] Packages: 1 packages (‘stats’)
[17:43:57.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.353] Resolved: FALSE
[17:43:57.353] Value: <not collected>
[17:43:57.353] Conditions captured: <none>
[17:43:57.353] Early signaling: FALSE
[17:43:57.353] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.353] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.364] Chunk #1 of 2 ... DONE
[17:43:57.364] Chunk #2 of 2 ...
[17:43:57.364]  - Finding globals in 'X' for chunk #2 ...
[17:43:57.365] getGlobalsAndPackages() ...
[17:43:57.365] Searching for globals...
[17:43:57.365] 
[17:43:57.365] Searching for globals ... DONE
[17:43:57.365] - globals: [0] <none>
[17:43:57.365] getGlobalsAndPackages() ... DONE
[17:43:57.365]    + additional globals found: [n=0] 
[17:43:57.365]    + additional namespaces needed: [n=0] 
[17:43:57.365]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:57.366]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:57.366]  - seeds: <none>
[17:43:57.366]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.366] getGlobalsAndPackages() ...
[17:43:57.366] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.366] Resolving globals: FALSE
[17:43:57.366] Tweak future expression to call with '...' arguments ...
[17:43:57.366] {
[17:43:57.366]     do.call(function(...) {
[17:43:57.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.366]             on.exit(options(oopts), add = TRUE)
[17:43:57.366]         }
[17:43:57.366]         {
[17:43:57.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.366]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.366]             })
[17:43:57.366]         }
[17:43:57.366]     }, args = future.call.arguments)
[17:43:57.366] }
[17:43:57.367] Tweak future expression to call with '...' arguments ... DONE
[17:43:57.367] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.367] - packages: [1] ‘stats’
[17:43:57.367] getGlobalsAndPackages() ... DONE
[17:43:57.367] run() for ‘Future’ ...
[17:43:57.368] - state: ‘created’
[17:43:57.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.383] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.383]   - Field: ‘node’
[17:43:57.383]   - Field: ‘label’
[17:43:57.383]   - Field: ‘local’
[17:43:57.384]   - Field: ‘owner’
[17:43:57.384]   - Field: ‘envir’
[17:43:57.384]   - Field: ‘workers’
[17:43:57.384]   - Field: ‘packages’
[17:43:57.384]   - Field: ‘gc’
[17:43:57.384]   - Field: ‘conditions’
[17:43:57.384]   - Field: ‘persistent’
[17:43:57.384]   - Field: ‘expr’
[17:43:57.384]   - Field: ‘uuid’
[17:43:57.384]   - Field: ‘seed’
[17:43:57.384]   - Field: ‘version’
[17:43:57.385]   - Field: ‘result’
[17:43:57.385]   - Field: ‘asynchronous’
[17:43:57.385]   - Field: ‘calls’
[17:43:57.385]   - Field: ‘globals’
[17:43:57.385]   - Field: ‘stdout’
[17:43:57.385]   - Field: ‘earlySignal’
[17:43:57.385]   - Field: ‘lazy’
[17:43:57.385]   - Field: ‘state’
[17:43:57.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.385] - Launch lazy future ...
[17:43:57.386] Packages needed by the future expression (n = 1): ‘stats’
[17:43:57.386] Packages needed by future strategies (n = 0): <none>
[17:43:57.386] {
[17:43:57.386]     {
[17:43:57.386]         {
[17:43:57.386]             ...future.startTime <- base::Sys.time()
[17:43:57.386]             {
[17:43:57.386]                 {
[17:43:57.386]                   {
[17:43:57.386]                     {
[17:43:57.386]                       {
[17:43:57.386]                         base::local({
[17:43:57.386]                           has_future <- base::requireNamespace("future", 
[17:43:57.386]                             quietly = TRUE)
[17:43:57.386]                           if (has_future) {
[17:43:57.386]                             ns <- base::getNamespace("future")
[17:43:57.386]                             version <- ns[[".package"]][["version"]]
[17:43:57.386]                             if (is.null(version)) 
[17:43:57.386]                               version <- utils::packageVersion("future")
[17:43:57.386]                           }
[17:43:57.386]                           else {
[17:43:57.386]                             version <- NULL
[17:43:57.386]                           }
[17:43:57.386]                           if (!has_future || version < "1.8.0") {
[17:43:57.386]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.386]                               "", base::R.version$version.string), 
[17:43:57.386]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:57.386]                                 base::R.version$platform, 8 * 
[17:43:57.386]                                   base::.Machine$sizeof.pointer), 
[17:43:57.386]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.386]                                 "release", "version")], collapse = " "), 
[17:43:57.386]                               hostname = base::Sys.info()[["nodename"]])
[17:43:57.386]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.386]                               info)
[17:43:57.386]                             info <- base::paste(info, collapse = "; ")
[17:43:57.386]                             if (!has_future) {
[17:43:57.386]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.386]                                 info)
[17:43:57.386]                             }
[17:43:57.386]                             else {
[17:43:57.386]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.386]                                 info, version)
[17:43:57.386]                             }
[17:43:57.386]                             base::stop(msg)
[17:43:57.386]                           }
[17:43:57.386]                         })
[17:43:57.386]                       }
[17:43:57.386]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.386]                       base::options(mc.cores = 1L)
[17:43:57.386]                     }
[17:43:57.386]                     base::local({
[17:43:57.386]                       for (pkg in "stats") {
[17:43:57.386]                         base::loadNamespace(pkg)
[17:43:57.386]                         base::library(pkg, character.only = TRUE)
[17:43:57.386]                       }
[17:43:57.386]                     })
[17:43:57.386]                   }
[17:43:57.386]                   ...future.strategy.old <- future::plan("list")
[17:43:57.386]                   options(future.plan = NULL)
[17:43:57.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.386]                 }
[17:43:57.386]                 ...future.workdir <- getwd()
[17:43:57.386]             }
[17:43:57.386]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.386]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.386]         }
[17:43:57.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.386]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.386]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.386]             base::names(...future.oldOptions))
[17:43:57.386]     }
[17:43:57.386]     if (FALSE) {
[17:43:57.386]     }
[17:43:57.386]     else {
[17:43:57.386]         if (TRUE) {
[17:43:57.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.386]                 open = "w")
[17:43:57.386]         }
[17:43:57.386]         else {
[17:43:57.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.386]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.386]         }
[17:43:57.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.386]             base::sink(type = "output", split = FALSE)
[17:43:57.386]             base::close(...future.stdout)
[17:43:57.386]         }, add = TRUE)
[17:43:57.386]     }
[17:43:57.386]     ...future.frame <- base::sys.nframe()
[17:43:57.386]     ...future.conditions <- base::list()
[17:43:57.386]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.386]     if (FALSE) {
[17:43:57.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.386]     }
[17:43:57.386]     ...future.result <- base::tryCatch({
[17:43:57.386]         base::withCallingHandlers({
[17:43:57.386]             ...future.value <- base::withVisible(base::local({
[17:43:57.386]                 ...future.makeSendCondition <- base::local({
[17:43:57.386]                   sendCondition <- NULL
[17:43:57.386]                   function(frame = 1L) {
[17:43:57.386]                     if (is.function(sendCondition)) 
[17:43:57.386]                       return(sendCondition)
[17:43:57.386]                     ns <- getNamespace("parallel")
[17:43:57.386]                     if (exists("sendData", mode = "function", 
[17:43:57.386]                       envir = ns)) {
[17:43:57.386]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.386]                         envir = ns)
[17:43:57.386]                       envir <- sys.frame(frame)
[17:43:57.386]                       master <- NULL
[17:43:57.386]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.386]                         !identical(envir, emptyenv())) {
[17:43:57.386]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.386]                           inherits = FALSE)) {
[17:43:57.386]                           master <- get("master", mode = "list", 
[17:43:57.386]                             envir = envir, inherits = FALSE)
[17:43:57.386]                           if (inherits(master, c("SOCKnode", 
[17:43:57.386]                             "SOCK0node"))) {
[17:43:57.386]                             sendCondition <<- function(cond) {
[17:43:57.386]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.386]                                 success = TRUE)
[17:43:57.386]                               parallel_sendData(master, data)
[17:43:57.386]                             }
[17:43:57.386]                             return(sendCondition)
[17:43:57.386]                           }
[17:43:57.386]                         }
[17:43:57.386]                         frame <- frame + 1L
[17:43:57.386]                         envir <- sys.frame(frame)
[17:43:57.386]                       }
[17:43:57.386]                     }
[17:43:57.386]                     sendCondition <<- function(cond) NULL
[17:43:57.386]                   }
[17:43:57.386]                 })
[17:43:57.386]                 withCallingHandlers({
[17:43:57.386]                   {
[17:43:57.386]                     do.call(function(...) {
[17:43:57.386]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.386]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.386]                         ...future.globals.maxSize)) {
[17:43:57.386]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.386]                         on.exit(options(oopts), add = TRUE)
[17:43:57.386]                       }
[17:43:57.386]                       {
[17:43:57.386]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.386]                           FUN = function(jj) {
[17:43:57.386]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.386]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.386]                           })
[17:43:57.386]                       }
[17:43:57.386]                     }, args = future.call.arguments)
[17:43:57.386]                   }
[17:43:57.386]                 }, immediateCondition = function(cond) {
[17:43:57.386]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.386]                   sendCondition(cond)
[17:43:57.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.386]                   {
[17:43:57.386]                     inherits <- base::inherits
[17:43:57.386]                     invokeRestart <- base::invokeRestart
[17:43:57.386]                     is.null <- base::is.null
[17:43:57.386]                     muffled <- FALSE
[17:43:57.386]                     if (inherits(cond, "message")) {
[17:43:57.386]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.386]                       if (muffled) 
[17:43:57.386]                         invokeRestart("muffleMessage")
[17:43:57.386]                     }
[17:43:57.386]                     else if (inherits(cond, "warning")) {
[17:43:57.386]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.386]                       if (muffled) 
[17:43:57.386]                         invokeRestart("muffleWarning")
[17:43:57.386]                     }
[17:43:57.386]                     else if (inherits(cond, "condition")) {
[17:43:57.386]                       if (!is.null(pattern)) {
[17:43:57.386]                         computeRestarts <- base::computeRestarts
[17:43:57.386]                         grepl <- base::grepl
[17:43:57.386]                         restarts <- computeRestarts(cond)
[17:43:57.386]                         for (restart in restarts) {
[17:43:57.386]                           name <- restart$name
[17:43:57.386]                           if (is.null(name)) 
[17:43:57.386]                             next
[17:43:57.386]                           if (!grepl(pattern, name)) 
[17:43:57.386]                             next
[17:43:57.386]                           invokeRestart(restart)
[17:43:57.386]                           muffled <- TRUE
[17:43:57.386]                           break
[17:43:57.386]                         }
[17:43:57.386]                       }
[17:43:57.386]                     }
[17:43:57.386]                     invisible(muffled)
[17:43:57.386]                   }
[17:43:57.386]                   muffleCondition(cond)
[17:43:57.386]                 })
[17:43:57.386]             }))
[17:43:57.386]             future::FutureResult(value = ...future.value$value, 
[17:43:57.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.386]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.386]                     ...future.globalenv.names))
[17:43:57.386]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.386]         }, condition = base::local({
[17:43:57.386]             c <- base::c
[17:43:57.386]             inherits <- base::inherits
[17:43:57.386]             invokeRestart <- base::invokeRestart
[17:43:57.386]             length <- base::length
[17:43:57.386]             list <- base::list
[17:43:57.386]             seq.int <- base::seq.int
[17:43:57.386]             signalCondition <- base::signalCondition
[17:43:57.386]             sys.calls <- base::sys.calls
[17:43:57.386]             `[[` <- base::`[[`
[17:43:57.386]             `+` <- base::`+`
[17:43:57.386]             `<<-` <- base::`<<-`
[17:43:57.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.386]                   3L)]
[17:43:57.386]             }
[17:43:57.386]             function(cond) {
[17:43:57.386]                 is_error <- inherits(cond, "error")
[17:43:57.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.386]                   NULL)
[17:43:57.386]                 if (is_error) {
[17:43:57.386]                   sessionInformation <- function() {
[17:43:57.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.386]                       search = base::search(), system = base::Sys.info())
[17:43:57.386]                   }
[17:43:57.386]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.386]                     cond$call), session = sessionInformation(), 
[17:43:57.386]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.386]                   signalCondition(cond)
[17:43:57.386]                 }
[17:43:57.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.386]                 "immediateCondition"))) {
[17:43:57.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.386]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.386]                   if (TRUE && !signal) {
[17:43:57.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.386]                     {
[17:43:57.386]                       inherits <- base::inherits
[17:43:57.386]                       invokeRestart <- base::invokeRestart
[17:43:57.386]                       is.null <- base::is.null
[17:43:57.386]                       muffled <- FALSE
[17:43:57.386]                       if (inherits(cond, "message")) {
[17:43:57.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.386]                         if (muffled) 
[17:43:57.386]                           invokeRestart("muffleMessage")
[17:43:57.386]                       }
[17:43:57.386]                       else if (inherits(cond, "warning")) {
[17:43:57.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.386]                         if (muffled) 
[17:43:57.386]                           invokeRestart("muffleWarning")
[17:43:57.386]                       }
[17:43:57.386]                       else if (inherits(cond, "condition")) {
[17:43:57.386]                         if (!is.null(pattern)) {
[17:43:57.386]                           computeRestarts <- base::computeRestarts
[17:43:57.386]                           grepl <- base::grepl
[17:43:57.386]                           restarts <- computeRestarts(cond)
[17:43:57.386]                           for (restart in restarts) {
[17:43:57.386]                             name <- restart$name
[17:43:57.386]                             if (is.null(name)) 
[17:43:57.386]                               next
[17:43:57.386]                             if (!grepl(pattern, name)) 
[17:43:57.386]                               next
[17:43:57.386]                             invokeRestart(restart)
[17:43:57.386]                             muffled <- TRUE
[17:43:57.386]                             break
[17:43:57.386]                           }
[17:43:57.386]                         }
[17:43:57.386]                       }
[17:43:57.386]                       invisible(muffled)
[17:43:57.386]                     }
[17:43:57.386]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.386]                   }
[17:43:57.386]                 }
[17:43:57.386]                 else {
[17:43:57.386]                   if (TRUE) {
[17:43:57.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.386]                     {
[17:43:57.386]                       inherits <- base::inherits
[17:43:57.386]                       invokeRestart <- base::invokeRestart
[17:43:57.386]                       is.null <- base::is.null
[17:43:57.386]                       muffled <- FALSE
[17:43:57.386]                       if (inherits(cond, "message")) {
[17:43:57.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.386]                         if (muffled) 
[17:43:57.386]                           invokeRestart("muffleMessage")
[17:43:57.386]                       }
[17:43:57.386]                       else if (inherits(cond, "warning")) {
[17:43:57.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.386]                         if (muffled) 
[17:43:57.386]                           invokeRestart("muffleWarning")
[17:43:57.386]                       }
[17:43:57.386]                       else if (inherits(cond, "condition")) {
[17:43:57.386]                         if (!is.null(pattern)) {
[17:43:57.386]                           computeRestarts <- base::computeRestarts
[17:43:57.386]                           grepl <- base::grepl
[17:43:57.386]                           restarts <- computeRestarts(cond)
[17:43:57.386]                           for (restart in restarts) {
[17:43:57.386]                             name <- restart$name
[17:43:57.386]                             if (is.null(name)) 
[17:43:57.386]                               next
[17:43:57.386]                             if (!grepl(pattern, name)) 
[17:43:57.386]                               next
[17:43:57.386]                             invokeRestart(restart)
[17:43:57.386]                             muffled <- TRUE
[17:43:57.386]                             break
[17:43:57.386]                           }
[17:43:57.386]                         }
[17:43:57.386]                       }
[17:43:57.386]                       invisible(muffled)
[17:43:57.386]                     }
[17:43:57.386]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.386]                   }
[17:43:57.386]                 }
[17:43:57.386]             }
[17:43:57.386]         }))
[17:43:57.386]     }, error = function(ex) {
[17:43:57.386]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.386]                 ...future.rng), started = ...future.startTime, 
[17:43:57.386]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.386]             version = "1.8"), class = "FutureResult")
[17:43:57.386]     }, finally = {
[17:43:57.386]         if (!identical(...future.workdir, getwd())) 
[17:43:57.386]             setwd(...future.workdir)
[17:43:57.386]         {
[17:43:57.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.386]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.386]             }
[17:43:57.386]             base::options(...future.oldOptions)
[17:43:57.386]             if (.Platform$OS.type == "windows") {
[17:43:57.386]                 old_names <- names(...future.oldEnvVars)
[17:43:57.386]                 envs <- base::Sys.getenv()
[17:43:57.386]                 names <- names(envs)
[17:43:57.386]                 common <- intersect(names, old_names)
[17:43:57.386]                 added <- setdiff(names, old_names)
[17:43:57.386]                 removed <- setdiff(old_names, names)
[17:43:57.386]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.386]                   envs[common]]
[17:43:57.386]                 NAMES <- toupper(changed)
[17:43:57.386]                 args <- list()
[17:43:57.386]                 for (kk in seq_along(NAMES)) {
[17:43:57.386]                   name <- changed[[kk]]
[17:43:57.386]                   NAME <- NAMES[[kk]]
[17:43:57.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.386]                     next
[17:43:57.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.386]                 }
[17:43:57.386]                 NAMES <- toupper(added)
[17:43:57.386]                 for (kk in seq_along(NAMES)) {
[17:43:57.386]                   name <- added[[kk]]
[17:43:57.386]                   NAME <- NAMES[[kk]]
[17:43:57.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.386]                     next
[17:43:57.386]                   args[[name]] <- ""
[17:43:57.386]                 }
[17:43:57.386]                 NAMES <- toupper(removed)
[17:43:57.386]                 for (kk in seq_along(NAMES)) {
[17:43:57.386]                   name <- removed[[kk]]
[17:43:57.386]                   NAME <- NAMES[[kk]]
[17:43:57.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.386]                     next
[17:43:57.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.386]                 }
[17:43:57.386]                 if (length(args) > 0) 
[17:43:57.386]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.386]             }
[17:43:57.386]             else {
[17:43:57.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.386]             }
[17:43:57.386]             {
[17:43:57.386]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.386]                   0L) {
[17:43:57.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.386]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.386]                   base::options(opts)
[17:43:57.386]                 }
[17:43:57.386]                 {
[17:43:57.386]                   {
[17:43:57.386]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.386]                     NULL
[17:43:57.386]                   }
[17:43:57.386]                   options(future.plan = NULL)
[17:43:57.386]                   if (is.na(NA_character_)) 
[17:43:57.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.386]                     .init = FALSE)
[17:43:57.386]                 }
[17:43:57.386]             }
[17:43:57.386]         }
[17:43:57.386]     })
[17:43:57.386]     if (TRUE) {
[17:43:57.386]         base::sink(type = "output", split = FALSE)
[17:43:57.386]         if (TRUE) {
[17:43:57.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.386]         }
[17:43:57.386]         else {
[17:43:57.386]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.386]         }
[17:43:57.386]         base::close(...future.stdout)
[17:43:57.386]         ...future.stdout <- NULL
[17:43:57.386]     }
[17:43:57.386]     ...future.result$conditions <- ...future.conditions
[17:43:57.386]     ...future.result$finished <- base::Sys.time()
[17:43:57.386]     ...future.result
[17:43:57.386] }
[17:43:57.389] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:43:57.389] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:43:57.390] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:43:57.390] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:57.390] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.390] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:43:57.391] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:43:57.391] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:57.391] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.391] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:57.391] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.392] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:43:57.392] MultisessionFuture started
[17:43:57.392] - Launch lazy future ... done
[17:43:57.392] run() for ‘MultisessionFuture’ ... done
[17:43:57.392] Created future:
[17:43:57.392] MultisessionFuture:
[17:43:57.392] Label: ‘future_eapply-2’
[17:43:57.392] Expression:
[17:43:57.392] {
[17:43:57.392]     do.call(function(...) {
[17:43:57.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.392]             on.exit(options(oopts), add = TRUE)
[17:43:57.392]         }
[17:43:57.392]         {
[17:43:57.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.392]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.392]             })
[17:43:57.392]         }
[17:43:57.392]     }, args = future.call.arguments)
[17:43:57.392] }
[17:43:57.392] Lazy evaluation: FALSE
[17:43:57.392] Asynchronous evaluation: TRUE
[17:43:57.392] Local evaluation: TRUE
[17:43:57.392] Environment: R_GlobalEnv
[17:43:57.392] Capture standard output: TRUE
[17:43:57.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.392] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.392] Packages: 1 packages (‘stats’)
[17:43:57.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.392] Resolved: FALSE
[17:43:57.392] Value: <not collected>
[17:43:57.392] Conditions captured: <none>
[17:43:57.392] Early signaling: FALSE
[17:43:57.392] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.392] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.404] Chunk #2 of 2 ... DONE
[17:43:57.404] Launching 2 futures (chunks) ... DONE
[17:43:57.404] Resolving 2 futures (chunks) ...
[17:43:57.404] resolve() on list ...
[17:43:57.404]  recursive: 0
[17:43:57.404]  length: 2
[17:43:57.405] 
[17:43:57.405] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.405] - Validating connection of MultisessionFuture
[17:43:57.405] - received message: FutureResult
[17:43:57.405] - Received FutureResult
[17:43:57.405] - Erased future from FutureRegistry
[17:43:57.406] result() for ClusterFuture ...
[17:43:57.406] - result already collected: FutureResult
[17:43:57.406] result() for ClusterFuture ... done
[17:43:57.406] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.406] Future #1
[17:43:57.406] result() for ClusterFuture ...
[17:43:57.406] - result already collected: FutureResult
[17:43:57.406] result() for ClusterFuture ... done
[17:43:57.406] result() for ClusterFuture ...
[17:43:57.406] - result already collected: FutureResult
[17:43:57.406] result() for ClusterFuture ... done
[17:43:57.407] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:57.407] - nx: 2
[17:43:57.407] - relay: TRUE
[17:43:57.407] - stdout: TRUE
[17:43:57.407] - signal: TRUE
[17:43:57.407] - resignal: FALSE
[17:43:57.407] - force: TRUE
[17:43:57.407] - relayed: [n=2] FALSE, FALSE
[17:43:57.407] - queued futures: [n=2] FALSE, FALSE
[17:43:57.407]  - until=1
[17:43:57.407]  - relaying element #1
[17:43:57.408] result() for ClusterFuture ...
[17:43:57.408] - result already collected: FutureResult
[17:43:57.408] result() for ClusterFuture ... done
[17:43:57.408] result() for ClusterFuture ...
[17:43:57.408] - result already collected: FutureResult
[17:43:57.408] result() for ClusterFuture ... done
[17:43:57.408] result() for ClusterFuture ...
[17:43:57.408] - result already collected: FutureResult
[17:43:57.408] result() for ClusterFuture ... done
[17:43:57.408] result() for ClusterFuture ...
[17:43:57.408] - result already collected: FutureResult
[17:43:57.409] result() for ClusterFuture ... done
[17:43:57.409] - relayed: [n=2] TRUE, FALSE
[17:43:57.409] - queued futures: [n=2] TRUE, FALSE
[17:43:57.409] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:57.409]  length: 1 (resolved future 1)
[17:43:57.438] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.438] - Validating connection of MultisessionFuture
[17:43:57.438] - received message: FutureResult
[17:43:57.438] - Received FutureResult
[17:43:57.438] - Erased future from FutureRegistry
[17:43:57.439] result() for ClusterFuture ...
[17:43:57.439] - result already collected: FutureResult
[17:43:57.439] result() for ClusterFuture ... done
[17:43:57.439] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.439] Future #2
[17:43:57.439] result() for ClusterFuture ...
[17:43:57.439] - result already collected: FutureResult
[17:43:57.439] result() for ClusterFuture ... done
[17:43:57.439] result() for ClusterFuture ...
[17:43:57.439] - result already collected: FutureResult
[17:43:57.439] result() for ClusterFuture ... done
[17:43:57.440] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:57.440] - nx: 2
[17:43:57.440] - relay: TRUE
[17:43:57.440] - stdout: TRUE
[17:43:57.440] - signal: TRUE
[17:43:57.440] - resignal: FALSE
[17:43:57.440] - force: TRUE
[17:43:57.440] - relayed: [n=2] TRUE, FALSE
[17:43:57.440] - queued futures: [n=2] TRUE, FALSE
[17:43:57.440]  - until=2
[17:43:57.440]  - relaying element #2
[17:43:57.441] result() for ClusterFuture ...
[17:43:57.441] - result already collected: FutureResult
[17:43:57.441] result() for ClusterFuture ... done
[17:43:57.441] result() for ClusterFuture ...
[17:43:57.441] - result already collected: FutureResult
[17:43:57.441] result() for ClusterFuture ... done
[17:43:57.441] result() for ClusterFuture ...
[17:43:57.441] - result already collected: FutureResult
[17:43:57.441] result() for ClusterFuture ... done
[17:43:57.441] result() for ClusterFuture ...
[17:43:57.441] - result already collected: FutureResult
[17:43:57.441] result() for ClusterFuture ... done
[17:43:57.442] - relayed: [n=2] TRUE, TRUE
[17:43:57.442] - queued futures: [n=2] TRUE, TRUE
[17:43:57.442] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:57.442]  length: 0 (resolved future 2)
[17:43:57.442] Relaying remaining futures
[17:43:57.442] signalConditionsASAP(NULL, pos=0) ...
[17:43:57.442] - nx: 2
[17:43:57.442] - relay: TRUE
[17:43:57.442] - stdout: TRUE
[17:43:57.442] - signal: TRUE
[17:43:57.442] - resignal: FALSE
[17:43:57.443] - force: TRUE
[17:43:57.443] - relayed: [n=2] TRUE, TRUE
[17:43:57.443] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:57.443] - relayed: [n=2] TRUE, TRUE
[17:43:57.443] - queued futures: [n=2] TRUE, TRUE
[17:43:57.443] signalConditionsASAP(NULL, pos=0) ... done
[17:43:57.443] resolve() on list ... DONE
[17:43:57.443] result() for ClusterFuture ...
[17:43:57.443] - result already collected: FutureResult
[17:43:57.443] result() for ClusterFuture ... done
[17:43:57.443] result() for ClusterFuture ...
[17:43:57.444] - result already collected: FutureResult
[17:43:57.444] result() for ClusterFuture ... done
[17:43:57.444] result() for ClusterFuture ...
[17:43:57.444] - result already collected: FutureResult
[17:43:57.444] result() for ClusterFuture ... done
[17:43:57.444] result() for ClusterFuture ...
[17:43:57.444] - result already collected: FutureResult
[17:43:57.444] result() for ClusterFuture ... done
[17:43:57.444]  - Number of value chunks collected: 2
[17:43:57.444] Resolving 2 futures (chunks) ... DONE
[17:43:57.444] Reducing values from 2 chunks ...
[17:43:57.445]  - Number of values collected after concatenation: 3
[17:43:57.445]  - Number of values expected: 3
[17:43:57.445] Reducing values from 2 chunks ... DONE
[17:43:57.445] future_lapply() ... DONE
[17:43:57.445] future_lapply() ...
[17:43:57.449] Number of chunks: 2
[17:43:57.449] getGlobalsAndPackagesXApply() ...
[17:43:57.449]  - future.globals: TRUE
[17:43:57.449] getGlobalsAndPackages() ...
[17:43:57.450] Searching for globals...
[17:43:57.451] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:57.451] Searching for globals ... DONE
[17:43:57.451] Resolving globals: FALSE
[17:43:57.451] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:57.452] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:57.452] - globals: [1] ‘FUN’
[17:43:57.452] - packages: [1] ‘stats’
[17:43:57.452] getGlobalsAndPackages() ... DONE
[17:43:57.452]  - globals found/used: [n=1] ‘FUN’
[17:43:57.452]  - needed namespaces: [n=1] ‘stats’
[17:43:57.452] Finding globals ... DONE
[17:43:57.452]  - use_args: TRUE
[17:43:57.452]  - Getting '...' globals ...
[17:43:57.453] resolve() on list ...
[17:43:57.453]  recursive: 0
[17:43:57.453]  length: 1
[17:43:57.453]  elements: ‘...’
[17:43:57.453]  length: 0 (resolved future 1)
[17:43:57.453] resolve() on list ... DONE
[17:43:57.453]    - '...' content: [n=0] 
[17:43:57.453] List of 1
[17:43:57.453]  $ ...: list()
[17:43:57.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:57.453]  - attr(*, "where")=List of 1
[17:43:57.453]   ..$ ...:<environment: 0x55813f464d18> 
[17:43:57.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:57.453]  - attr(*, "resolved")= logi TRUE
[17:43:57.453]  - attr(*, "total_size")= num NA
[17:43:57.456]  - Getting '...' globals ... DONE
[17:43:57.456] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:57.456] List of 2
[17:43:57.456]  $ ...future.FUN:function (x, ...)  
[17:43:57.456]  $ ...          : list()
[17:43:57.456]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:57.456]  - attr(*, "where")=List of 2
[17:43:57.456]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:57.456]   ..$ ...          :<environment: 0x55813f464d18> 
[17:43:57.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:57.456]  - attr(*, "resolved")= logi FALSE
[17:43:57.456]  - attr(*, "total_size")= num 1248
[17:43:57.459] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:57.459] getGlobalsAndPackagesXApply() ... DONE
[17:43:57.459] Number of futures (= number of chunks): 2
[17:43:57.459] Launching 2 futures (chunks) ...
[17:43:57.459] Chunk #1 of 2 ...
[17:43:57.459]  - Finding globals in 'X' for chunk #1 ...
[17:43:57.460] getGlobalsAndPackages() ...
[17:43:57.460] Searching for globals...
[17:43:57.460] 
[17:43:57.460] Searching for globals ... DONE
[17:43:57.460] - globals: [0] <none>
[17:43:57.460] getGlobalsAndPackages() ... DONE
[17:43:57.460]    + additional globals found: [n=0] 
[17:43:57.460]    + additional namespaces needed: [n=0] 
[17:43:57.460]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:57.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:57.461]  - seeds: <none>
[17:43:57.461]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.461] getGlobalsAndPackages() ...
[17:43:57.461] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.461] Resolving globals: FALSE
[17:43:57.461] Tweak future expression to call with '...' arguments ...
[17:43:57.461] {
[17:43:57.461]     do.call(function(...) {
[17:43:57.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.461]             on.exit(options(oopts), add = TRUE)
[17:43:57.461]         }
[17:43:57.461]         {
[17:43:57.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.461]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.461]             })
[17:43:57.461]         }
[17:43:57.461]     }, args = future.call.arguments)
[17:43:57.461] }
[17:43:57.461] Tweak future expression to call with '...' arguments ... DONE
[17:43:57.462] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.462] - packages: [1] ‘stats’
[17:43:57.462] getGlobalsAndPackages() ... DONE
[17:43:57.462] run() for ‘Future’ ...
[17:43:57.462] - state: ‘created’
[17:43:57.463] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.476]   - Field: ‘node’
[17:43:57.476]   - Field: ‘label’
[17:43:57.476]   - Field: ‘local’
[17:43:57.476]   - Field: ‘owner’
[17:43:57.476]   - Field: ‘envir’
[17:43:57.477]   - Field: ‘workers’
[17:43:57.477]   - Field: ‘packages’
[17:43:57.477]   - Field: ‘gc’
[17:43:57.477]   - Field: ‘conditions’
[17:43:57.477]   - Field: ‘persistent’
[17:43:57.477]   - Field: ‘expr’
[17:43:57.477]   - Field: ‘uuid’
[17:43:57.477]   - Field: ‘seed’
[17:43:57.477]   - Field: ‘version’
[17:43:57.477]   - Field: ‘result’
[17:43:57.477]   - Field: ‘asynchronous’
[17:43:57.478]   - Field: ‘calls’
[17:43:57.478]   - Field: ‘globals’
[17:43:57.478]   - Field: ‘stdout’
[17:43:57.478]   - Field: ‘earlySignal’
[17:43:57.478]   - Field: ‘lazy’
[17:43:57.478]   - Field: ‘state’
[17:43:57.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.478] - Launch lazy future ...
[17:43:57.478] Packages needed by the future expression (n = 1): ‘stats’
[17:43:57.479] Packages needed by future strategies (n = 0): <none>
[17:43:57.479] {
[17:43:57.479]     {
[17:43:57.479]         {
[17:43:57.479]             ...future.startTime <- base::Sys.time()
[17:43:57.479]             {
[17:43:57.479]                 {
[17:43:57.479]                   {
[17:43:57.479]                     {
[17:43:57.479]                       {
[17:43:57.479]                         base::local({
[17:43:57.479]                           has_future <- base::requireNamespace("future", 
[17:43:57.479]                             quietly = TRUE)
[17:43:57.479]                           if (has_future) {
[17:43:57.479]                             ns <- base::getNamespace("future")
[17:43:57.479]                             version <- ns[[".package"]][["version"]]
[17:43:57.479]                             if (is.null(version)) 
[17:43:57.479]                               version <- utils::packageVersion("future")
[17:43:57.479]                           }
[17:43:57.479]                           else {
[17:43:57.479]                             version <- NULL
[17:43:57.479]                           }
[17:43:57.479]                           if (!has_future || version < "1.8.0") {
[17:43:57.479]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.479]                               "", base::R.version$version.string), 
[17:43:57.479]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:57.479]                                 base::R.version$platform, 8 * 
[17:43:57.479]                                   base::.Machine$sizeof.pointer), 
[17:43:57.479]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.479]                                 "release", "version")], collapse = " "), 
[17:43:57.479]                               hostname = base::Sys.info()[["nodename"]])
[17:43:57.479]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.479]                               info)
[17:43:57.479]                             info <- base::paste(info, collapse = "; ")
[17:43:57.479]                             if (!has_future) {
[17:43:57.479]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.479]                                 info)
[17:43:57.479]                             }
[17:43:57.479]                             else {
[17:43:57.479]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.479]                                 info, version)
[17:43:57.479]                             }
[17:43:57.479]                             base::stop(msg)
[17:43:57.479]                           }
[17:43:57.479]                         })
[17:43:57.479]                       }
[17:43:57.479]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.479]                       base::options(mc.cores = 1L)
[17:43:57.479]                     }
[17:43:57.479]                     base::local({
[17:43:57.479]                       for (pkg in "stats") {
[17:43:57.479]                         base::loadNamespace(pkg)
[17:43:57.479]                         base::library(pkg, character.only = TRUE)
[17:43:57.479]                       }
[17:43:57.479]                     })
[17:43:57.479]                   }
[17:43:57.479]                   ...future.strategy.old <- future::plan("list")
[17:43:57.479]                   options(future.plan = NULL)
[17:43:57.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.479]                 }
[17:43:57.479]                 ...future.workdir <- getwd()
[17:43:57.479]             }
[17:43:57.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.479]         }
[17:43:57.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.479]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.479]             base::names(...future.oldOptions))
[17:43:57.479]     }
[17:43:57.479]     if (FALSE) {
[17:43:57.479]     }
[17:43:57.479]     else {
[17:43:57.479]         if (TRUE) {
[17:43:57.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.479]                 open = "w")
[17:43:57.479]         }
[17:43:57.479]         else {
[17:43:57.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.479]         }
[17:43:57.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.479]             base::sink(type = "output", split = FALSE)
[17:43:57.479]             base::close(...future.stdout)
[17:43:57.479]         }, add = TRUE)
[17:43:57.479]     }
[17:43:57.479]     ...future.frame <- base::sys.nframe()
[17:43:57.479]     ...future.conditions <- base::list()
[17:43:57.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.479]     if (FALSE) {
[17:43:57.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.479]     }
[17:43:57.479]     ...future.result <- base::tryCatch({
[17:43:57.479]         base::withCallingHandlers({
[17:43:57.479]             ...future.value <- base::withVisible(base::local({
[17:43:57.479]                 ...future.makeSendCondition <- base::local({
[17:43:57.479]                   sendCondition <- NULL
[17:43:57.479]                   function(frame = 1L) {
[17:43:57.479]                     if (is.function(sendCondition)) 
[17:43:57.479]                       return(sendCondition)
[17:43:57.479]                     ns <- getNamespace("parallel")
[17:43:57.479]                     if (exists("sendData", mode = "function", 
[17:43:57.479]                       envir = ns)) {
[17:43:57.479]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.479]                         envir = ns)
[17:43:57.479]                       envir <- sys.frame(frame)
[17:43:57.479]                       master <- NULL
[17:43:57.479]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.479]                         !identical(envir, emptyenv())) {
[17:43:57.479]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.479]                           inherits = FALSE)) {
[17:43:57.479]                           master <- get("master", mode = "list", 
[17:43:57.479]                             envir = envir, inherits = FALSE)
[17:43:57.479]                           if (inherits(master, c("SOCKnode", 
[17:43:57.479]                             "SOCK0node"))) {
[17:43:57.479]                             sendCondition <<- function(cond) {
[17:43:57.479]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.479]                                 success = TRUE)
[17:43:57.479]                               parallel_sendData(master, data)
[17:43:57.479]                             }
[17:43:57.479]                             return(sendCondition)
[17:43:57.479]                           }
[17:43:57.479]                         }
[17:43:57.479]                         frame <- frame + 1L
[17:43:57.479]                         envir <- sys.frame(frame)
[17:43:57.479]                       }
[17:43:57.479]                     }
[17:43:57.479]                     sendCondition <<- function(cond) NULL
[17:43:57.479]                   }
[17:43:57.479]                 })
[17:43:57.479]                 withCallingHandlers({
[17:43:57.479]                   {
[17:43:57.479]                     do.call(function(...) {
[17:43:57.479]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.479]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.479]                         ...future.globals.maxSize)) {
[17:43:57.479]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.479]                         on.exit(options(oopts), add = TRUE)
[17:43:57.479]                       }
[17:43:57.479]                       {
[17:43:57.479]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.479]                           FUN = function(jj) {
[17:43:57.479]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.479]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.479]                           })
[17:43:57.479]                       }
[17:43:57.479]                     }, args = future.call.arguments)
[17:43:57.479]                   }
[17:43:57.479]                 }, immediateCondition = function(cond) {
[17:43:57.479]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.479]                   sendCondition(cond)
[17:43:57.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.479]                   {
[17:43:57.479]                     inherits <- base::inherits
[17:43:57.479]                     invokeRestart <- base::invokeRestart
[17:43:57.479]                     is.null <- base::is.null
[17:43:57.479]                     muffled <- FALSE
[17:43:57.479]                     if (inherits(cond, "message")) {
[17:43:57.479]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.479]                       if (muffled) 
[17:43:57.479]                         invokeRestart("muffleMessage")
[17:43:57.479]                     }
[17:43:57.479]                     else if (inherits(cond, "warning")) {
[17:43:57.479]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.479]                       if (muffled) 
[17:43:57.479]                         invokeRestart("muffleWarning")
[17:43:57.479]                     }
[17:43:57.479]                     else if (inherits(cond, "condition")) {
[17:43:57.479]                       if (!is.null(pattern)) {
[17:43:57.479]                         computeRestarts <- base::computeRestarts
[17:43:57.479]                         grepl <- base::grepl
[17:43:57.479]                         restarts <- computeRestarts(cond)
[17:43:57.479]                         for (restart in restarts) {
[17:43:57.479]                           name <- restart$name
[17:43:57.479]                           if (is.null(name)) 
[17:43:57.479]                             next
[17:43:57.479]                           if (!grepl(pattern, name)) 
[17:43:57.479]                             next
[17:43:57.479]                           invokeRestart(restart)
[17:43:57.479]                           muffled <- TRUE
[17:43:57.479]                           break
[17:43:57.479]                         }
[17:43:57.479]                       }
[17:43:57.479]                     }
[17:43:57.479]                     invisible(muffled)
[17:43:57.479]                   }
[17:43:57.479]                   muffleCondition(cond)
[17:43:57.479]                 })
[17:43:57.479]             }))
[17:43:57.479]             future::FutureResult(value = ...future.value$value, 
[17:43:57.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.479]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.479]                     ...future.globalenv.names))
[17:43:57.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.479]         }, condition = base::local({
[17:43:57.479]             c <- base::c
[17:43:57.479]             inherits <- base::inherits
[17:43:57.479]             invokeRestart <- base::invokeRestart
[17:43:57.479]             length <- base::length
[17:43:57.479]             list <- base::list
[17:43:57.479]             seq.int <- base::seq.int
[17:43:57.479]             signalCondition <- base::signalCondition
[17:43:57.479]             sys.calls <- base::sys.calls
[17:43:57.479]             `[[` <- base::`[[`
[17:43:57.479]             `+` <- base::`+`
[17:43:57.479]             `<<-` <- base::`<<-`
[17:43:57.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.479]                   3L)]
[17:43:57.479]             }
[17:43:57.479]             function(cond) {
[17:43:57.479]                 is_error <- inherits(cond, "error")
[17:43:57.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.479]                   NULL)
[17:43:57.479]                 if (is_error) {
[17:43:57.479]                   sessionInformation <- function() {
[17:43:57.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.479]                       search = base::search(), system = base::Sys.info())
[17:43:57.479]                   }
[17:43:57.479]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.479]                     cond$call), session = sessionInformation(), 
[17:43:57.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.479]                   signalCondition(cond)
[17:43:57.479]                 }
[17:43:57.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.479]                 "immediateCondition"))) {
[17:43:57.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.479]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.479]                   if (TRUE && !signal) {
[17:43:57.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.479]                     {
[17:43:57.479]                       inherits <- base::inherits
[17:43:57.479]                       invokeRestart <- base::invokeRestart
[17:43:57.479]                       is.null <- base::is.null
[17:43:57.479]                       muffled <- FALSE
[17:43:57.479]                       if (inherits(cond, "message")) {
[17:43:57.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.479]                         if (muffled) 
[17:43:57.479]                           invokeRestart("muffleMessage")
[17:43:57.479]                       }
[17:43:57.479]                       else if (inherits(cond, "warning")) {
[17:43:57.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.479]                         if (muffled) 
[17:43:57.479]                           invokeRestart("muffleWarning")
[17:43:57.479]                       }
[17:43:57.479]                       else if (inherits(cond, "condition")) {
[17:43:57.479]                         if (!is.null(pattern)) {
[17:43:57.479]                           computeRestarts <- base::computeRestarts
[17:43:57.479]                           grepl <- base::grepl
[17:43:57.479]                           restarts <- computeRestarts(cond)
[17:43:57.479]                           for (restart in restarts) {
[17:43:57.479]                             name <- restart$name
[17:43:57.479]                             if (is.null(name)) 
[17:43:57.479]                               next
[17:43:57.479]                             if (!grepl(pattern, name)) 
[17:43:57.479]                               next
[17:43:57.479]                             invokeRestart(restart)
[17:43:57.479]                             muffled <- TRUE
[17:43:57.479]                             break
[17:43:57.479]                           }
[17:43:57.479]                         }
[17:43:57.479]                       }
[17:43:57.479]                       invisible(muffled)
[17:43:57.479]                     }
[17:43:57.479]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.479]                   }
[17:43:57.479]                 }
[17:43:57.479]                 else {
[17:43:57.479]                   if (TRUE) {
[17:43:57.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.479]                     {
[17:43:57.479]                       inherits <- base::inherits
[17:43:57.479]                       invokeRestart <- base::invokeRestart
[17:43:57.479]                       is.null <- base::is.null
[17:43:57.479]                       muffled <- FALSE
[17:43:57.479]                       if (inherits(cond, "message")) {
[17:43:57.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.479]                         if (muffled) 
[17:43:57.479]                           invokeRestart("muffleMessage")
[17:43:57.479]                       }
[17:43:57.479]                       else if (inherits(cond, "warning")) {
[17:43:57.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.479]                         if (muffled) 
[17:43:57.479]                           invokeRestart("muffleWarning")
[17:43:57.479]                       }
[17:43:57.479]                       else if (inherits(cond, "condition")) {
[17:43:57.479]                         if (!is.null(pattern)) {
[17:43:57.479]                           computeRestarts <- base::computeRestarts
[17:43:57.479]                           grepl <- base::grepl
[17:43:57.479]                           restarts <- computeRestarts(cond)
[17:43:57.479]                           for (restart in restarts) {
[17:43:57.479]                             name <- restart$name
[17:43:57.479]                             if (is.null(name)) 
[17:43:57.479]                               next
[17:43:57.479]                             if (!grepl(pattern, name)) 
[17:43:57.479]                               next
[17:43:57.479]                             invokeRestart(restart)
[17:43:57.479]                             muffled <- TRUE
[17:43:57.479]                             break
[17:43:57.479]                           }
[17:43:57.479]                         }
[17:43:57.479]                       }
[17:43:57.479]                       invisible(muffled)
[17:43:57.479]                     }
[17:43:57.479]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.479]                   }
[17:43:57.479]                 }
[17:43:57.479]             }
[17:43:57.479]         }))
[17:43:57.479]     }, error = function(ex) {
[17:43:57.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.479]                 ...future.rng), started = ...future.startTime, 
[17:43:57.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.479]             version = "1.8"), class = "FutureResult")
[17:43:57.479]     }, finally = {
[17:43:57.479]         if (!identical(...future.workdir, getwd())) 
[17:43:57.479]             setwd(...future.workdir)
[17:43:57.479]         {
[17:43:57.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.479]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.479]             }
[17:43:57.479]             base::options(...future.oldOptions)
[17:43:57.479]             if (.Platform$OS.type == "windows") {
[17:43:57.479]                 old_names <- names(...future.oldEnvVars)
[17:43:57.479]                 envs <- base::Sys.getenv()
[17:43:57.479]                 names <- names(envs)
[17:43:57.479]                 common <- intersect(names, old_names)
[17:43:57.479]                 added <- setdiff(names, old_names)
[17:43:57.479]                 removed <- setdiff(old_names, names)
[17:43:57.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.479]                   envs[common]]
[17:43:57.479]                 NAMES <- toupper(changed)
[17:43:57.479]                 args <- list()
[17:43:57.479]                 for (kk in seq_along(NAMES)) {
[17:43:57.479]                   name <- changed[[kk]]
[17:43:57.479]                   NAME <- NAMES[[kk]]
[17:43:57.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.479]                     next
[17:43:57.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.479]                 }
[17:43:57.479]                 NAMES <- toupper(added)
[17:43:57.479]                 for (kk in seq_along(NAMES)) {
[17:43:57.479]                   name <- added[[kk]]
[17:43:57.479]                   NAME <- NAMES[[kk]]
[17:43:57.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.479]                     next
[17:43:57.479]                   args[[name]] <- ""
[17:43:57.479]                 }
[17:43:57.479]                 NAMES <- toupper(removed)
[17:43:57.479]                 for (kk in seq_along(NAMES)) {
[17:43:57.479]                   name <- removed[[kk]]
[17:43:57.479]                   NAME <- NAMES[[kk]]
[17:43:57.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.479]                     next
[17:43:57.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.479]                 }
[17:43:57.479]                 if (length(args) > 0) 
[17:43:57.479]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.479]             }
[17:43:57.479]             else {
[17:43:57.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.479]             }
[17:43:57.479]             {
[17:43:57.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.479]                   0L) {
[17:43:57.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.479]                   base::options(opts)
[17:43:57.479]                 }
[17:43:57.479]                 {
[17:43:57.479]                   {
[17:43:57.479]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.479]                     NULL
[17:43:57.479]                   }
[17:43:57.479]                   options(future.plan = NULL)
[17:43:57.479]                   if (is.na(NA_character_)) 
[17:43:57.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.479]                     .init = FALSE)
[17:43:57.479]                 }
[17:43:57.479]             }
[17:43:57.479]         }
[17:43:57.479]     })
[17:43:57.479]     if (TRUE) {
[17:43:57.479]         base::sink(type = "output", split = FALSE)
[17:43:57.479]         if (TRUE) {
[17:43:57.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.479]         }
[17:43:57.479]         else {
[17:43:57.479]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.479]         }
[17:43:57.479]         base::close(...future.stdout)
[17:43:57.479]         ...future.stdout <- NULL
[17:43:57.479]     }
[17:43:57.479]     ...future.result$conditions <- ...future.conditions
[17:43:57.479]     ...future.result$finished <- base::Sys.time()
[17:43:57.479]     ...future.result
[17:43:57.479] }
[17:43:57.482] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:43:57.482] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:43:57.482] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:43:57.482] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:57.483] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.483] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:43:57.483] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:43:57.483] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:57.484] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.484] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:57.484] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:57.484] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:43:57.485] MultisessionFuture started
[17:43:57.485] - Launch lazy future ... done
[17:43:57.485] run() for ‘MultisessionFuture’ ... done
[17:43:57.485] Created future:
[17:43:57.485] MultisessionFuture:
[17:43:57.485] Label: ‘future_eapply-1’
[17:43:57.485] Expression:
[17:43:57.485] {
[17:43:57.485]     do.call(function(...) {
[17:43:57.485]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.485]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.485]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.485]             on.exit(options(oopts), add = TRUE)
[17:43:57.485]         }
[17:43:57.485]         {
[17:43:57.485]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.485]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.485]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.485]             })
[17:43:57.485]         }
[17:43:57.485]     }, args = future.call.arguments)
[17:43:57.485] }
[17:43:57.485] Lazy evaluation: FALSE
[17:43:57.485] Asynchronous evaluation: TRUE
[17:43:57.485] Local evaluation: TRUE
[17:43:57.485] Environment: R_GlobalEnv
[17:43:57.485] Capture standard output: TRUE
[17:43:57.485] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.485] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.485] Packages: 1 packages (‘stats’)
[17:43:57.485] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.485] Resolved: FALSE
[17:43:57.485] Value: <not collected>
[17:43:57.485] Conditions captured: <none>
[17:43:57.485] Early signaling: FALSE
[17:43:57.485] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.485] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.496] Chunk #1 of 2 ... DONE
[17:43:57.496] Chunk #2 of 2 ...
[17:43:57.497]  - Finding globals in 'X' for chunk #2 ...
[17:43:57.497] getGlobalsAndPackages() ...
[17:43:57.497] Searching for globals...
[17:43:57.497] 
[17:43:57.497] Searching for globals ... DONE
[17:43:57.497] - globals: [0] <none>
[17:43:57.497] getGlobalsAndPackages() ... DONE
[17:43:57.497]    + additional globals found: [n=0] 
[17:43:57.497]    + additional namespaces needed: [n=0] 
[17:43:57.498]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:57.498]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:57.498]  - seeds: <none>
[17:43:57.498]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.498] getGlobalsAndPackages() ...
[17:43:57.498] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.498] Resolving globals: FALSE
[17:43:57.498] Tweak future expression to call with '...' arguments ...
[17:43:57.498] {
[17:43:57.498]     do.call(function(...) {
[17:43:57.498]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.498]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.498]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.498]             on.exit(options(oopts), add = TRUE)
[17:43:57.498]         }
[17:43:57.498]         {
[17:43:57.498]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.498]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.498]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.498]             })
[17:43:57.498]         }
[17:43:57.498]     }, args = future.call.arguments)
[17:43:57.498] }
[17:43:57.499] Tweak future expression to call with '...' arguments ... DONE
[17:43:57.499] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:57.499] - packages: [1] ‘stats’
[17:43:57.499] getGlobalsAndPackages() ... DONE
[17:43:57.499] run() for ‘Future’ ...
[17:43:57.500] - state: ‘created’
[17:43:57.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:57.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:57.515]   - Field: ‘node’
[17:43:57.515]   - Field: ‘label’
[17:43:57.515]   - Field: ‘local’
[17:43:57.516]   - Field: ‘owner’
[17:43:57.516]   - Field: ‘envir’
[17:43:57.516]   - Field: ‘workers’
[17:43:57.516]   - Field: ‘packages’
[17:43:57.516]   - Field: ‘gc’
[17:43:57.516]   - Field: ‘conditions’
[17:43:57.516]   - Field: ‘persistent’
[17:43:57.516]   - Field: ‘expr’
[17:43:57.516]   - Field: ‘uuid’
[17:43:57.516]   - Field: ‘seed’
[17:43:57.516]   - Field: ‘version’
[17:43:57.517]   - Field: ‘result’
[17:43:57.517]   - Field: ‘asynchronous’
[17:43:57.517]   - Field: ‘calls’
[17:43:57.517]   - Field: ‘globals’
[17:43:57.517]   - Field: ‘stdout’
[17:43:57.517]   - Field: ‘earlySignal’
[17:43:57.517]   - Field: ‘lazy’
[17:43:57.517]   - Field: ‘state’
[17:43:57.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:57.517] - Launch lazy future ...
[17:43:57.518] Packages needed by the future expression (n = 1): ‘stats’
[17:43:57.518] Packages needed by future strategies (n = 0): <none>
[17:43:57.518] {
[17:43:57.518]     {
[17:43:57.518]         {
[17:43:57.518]             ...future.startTime <- base::Sys.time()
[17:43:57.518]             {
[17:43:57.518]                 {
[17:43:57.518]                   {
[17:43:57.518]                     {
[17:43:57.518]                       {
[17:43:57.518]                         base::local({
[17:43:57.518]                           has_future <- base::requireNamespace("future", 
[17:43:57.518]                             quietly = TRUE)
[17:43:57.518]                           if (has_future) {
[17:43:57.518]                             ns <- base::getNamespace("future")
[17:43:57.518]                             version <- ns[[".package"]][["version"]]
[17:43:57.518]                             if (is.null(version)) 
[17:43:57.518]                               version <- utils::packageVersion("future")
[17:43:57.518]                           }
[17:43:57.518]                           else {
[17:43:57.518]                             version <- NULL
[17:43:57.518]                           }
[17:43:57.518]                           if (!has_future || version < "1.8.0") {
[17:43:57.518]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:57.518]                               "", base::R.version$version.string), 
[17:43:57.518]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:57.518]                                 base::R.version$platform, 8 * 
[17:43:57.518]                                   base::.Machine$sizeof.pointer), 
[17:43:57.518]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:57.518]                                 "release", "version")], collapse = " "), 
[17:43:57.518]                               hostname = base::Sys.info()[["nodename"]])
[17:43:57.518]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:57.518]                               info)
[17:43:57.518]                             info <- base::paste(info, collapse = "; ")
[17:43:57.518]                             if (!has_future) {
[17:43:57.518]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:57.518]                                 info)
[17:43:57.518]                             }
[17:43:57.518]                             else {
[17:43:57.518]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:57.518]                                 info, version)
[17:43:57.518]                             }
[17:43:57.518]                             base::stop(msg)
[17:43:57.518]                           }
[17:43:57.518]                         })
[17:43:57.518]                       }
[17:43:57.518]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:57.518]                       base::options(mc.cores = 1L)
[17:43:57.518]                     }
[17:43:57.518]                     base::local({
[17:43:57.518]                       for (pkg in "stats") {
[17:43:57.518]                         base::loadNamespace(pkg)
[17:43:57.518]                         base::library(pkg, character.only = TRUE)
[17:43:57.518]                       }
[17:43:57.518]                     })
[17:43:57.518]                   }
[17:43:57.518]                   ...future.strategy.old <- future::plan("list")
[17:43:57.518]                   options(future.plan = NULL)
[17:43:57.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:57.518]                 }
[17:43:57.518]                 ...future.workdir <- getwd()
[17:43:57.518]             }
[17:43:57.518]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:57.518]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:57.518]         }
[17:43:57.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:57.518]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:57.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:57.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:57.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:57.518]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:57.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:57.518]             base::names(...future.oldOptions))
[17:43:57.518]     }
[17:43:57.518]     if (FALSE) {
[17:43:57.518]     }
[17:43:57.518]     else {
[17:43:57.518]         if (TRUE) {
[17:43:57.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:57.518]                 open = "w")
[17:43:57.518]         }
[17:43:57.518]         else {
[17:43:57.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:57.518]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:57.518]         }
[17:43:57.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:57.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:57.518]             base::sink(type = "output", split = FALSE)
[17:43:57.518]             base::close(...future.stdout)
[17:43:57.518]         }, add = TRUE)
[17:43:57.518]     }
[17:43:57.518]     ...future.frame <- base::sys.nframe()
[17:43:57.518]     ...future.conditions <- base::list()
[17:43:57.518]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:57.518]     if (FALSE) {
[17:43:57.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:57.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:57.518]     }
[17:43:57.518]     ...future.result <- base::tryCatch({
[17:43:57.518]         base::withCallingHandlers({
[17:43:57.518]             ...future.value <- base::withVisible(base::local({
[17:43:57.518]                 ...future.makeSendCondition <- base::local({
[17:43:57.518]                   sendCondition <- NULL
[17:43:57.518]                   function(frame = 1L) {
[17:43:57.518]                     if (is.function(sendCondition)) 
[17:43:57.518]                       return(sendCondition)
[17:43:57.518]                     ns <- getNamespace("parallel")
[17:43:57.518]                     if (exists("sendData", mode = "function", 
[17:43:57.518]                       envir = ns)) {
[17:43:57.518]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:57.518]                         envir = ns)
[17:43:57.518]                       envir <- sys.frame(frame)
[17:43:57.518]                       master <- NULL
[17:43:57.518]                       while (!identical(envir, .GlobalEnv) && 
[17:43:57.518]                         !identical(envir, emptyenv())) {
[17:43:57.518]                         if (exists("master", mode = "list", envir = envir, 
[17:43:57.518]                           inherits = FALSE)) {
[17:43:57.518]                           master <- get("master", mode = "list", 
[17:43:57.518]                             envir = envir, inherits = FALSE)
[17:43:57.518]                           if (inherits(master, c("SOCKnode", 
[17:43:57.518]                             "SOCK0node"))) {
[17:43:57.518]                             sendCondition <<- function(cond) {
[17:43:57.518]                               data <- list(type = "VALUE", value = cond, 
[17:43:57.518]                                 success = TRUE)
[17:43:57.518]                               parallel_sendData(master, data)
[17:43:57.518]                             }
[17:43:57.518]                             return(sendCondition)
[17:43:57.518]                           }
[17:43:57.518]                         }
[17:43:57.518]                         frame <- frame + 1L
[17:43:57.518]                         envir <- sys.frame(frame)
[17:43:57.518]                       }
[17:43:57.518]                     }
[17:43:57.518]                     sendCondition <<- function(cond) NULL
[17:43:57.518]                   }
[17:43:57.518]                 })
[17:43:57.518]                 withCallingHandlers({
[17:43:57.518]                   {
[17:43:57.518]                     do.call(function(...) {
[17:43:57.518]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.518]                       if (!identical(...future.globals.maxSize.org, 
[17:43:57.518]                         ...future.globals.maxSize)) {
[17:43:57.518]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.518]                         on.exit(options(oopts), add = TRUE)
[17:43:57.518]                       }
[17:43:57.518]                       {
[17:43:57.518]                         lapply(seq_along(...future.elements_ii), 
[17:43:57.518]                           FUN = function(jj) {
[17:43:57.518]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.518]                             ...future.FUN(...future.X_jj, ...)
[17:43:57.518]                           })
[17:43:57.518]                       }
[17:43:57.518]                     }, args = future.call.arguments)
[17:43:57.518]                   }
[17:43:57.518]                 }, immediateCondition = function(cond) {
[17:43:57.518]                   sendCondition <- ...future.makeSendCondition()
[17:43:57.518]                   sendCondition(cond)
[17:43:57.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.518]                   {
[17:43:57.518]                     inherits <- base::inherits
[17:43:57.518]                     invokeRestart <- base::invokeRestart
[17:43:57.518]                     is.null <- base::is.null
[17:43:57.518]                     muffled <- FALSE
[17:43:57.518]                     if (inherits(cond, "message")) {
[17:43:57.518]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:57.518]                       if (muffled) 
[17:43:57.518]                         invokeRestart("muffleMessage")
[17:43:57.518]                     }
[17:43:57.518]                     else if (inherits(cond, "warning")) {
[17:43:57.518]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:57.518]                       if (muffled) 
[17:43:57.518]                         invokeRestart("muffleWarning")
[17:43:57.518]                     }
[17:43:57.518]                     else if (inherits(cond, "condition")) {
[17:43:57.518]                       if (!is.null(pattern)) {
[17:43:57.518]                         computeRestarts <- base::computeRestarts
[17:43:57.518]                         grepl <- base::grepl
[17:43:57.518]                         restarts <- computeRestarts(cond)
[17:43:57.518]                         for (restart in restarts) {
[17:43:57.518]                           name <- restart$name
[17:43:57.518]                           if (is.null(name)) 
[17:43:57.518]                             next
[17:43:57.518]                           if (!grepl(pattern, name)) 
[17:43:57.518]                             next
[17:43:57.518]                           invokeRestart(restart)
[17:43:57.518]                           muffled <- TRUE
[17:43:57.518]                           break
[17:43:57.518]                         }
[17:43:57.518]                       }
[17:43:57.518]                     }
[17:43:57.518]                     invisible(muffled)
[17:43:57.518]                   }
[17:43:57.518]                   muffleCondition(cond)
[17:43:57.518]                 })
[17:43:57.518]             }))
[17:43:57.518]             future::FutureResult(value = ...future.value$value, 
[17:43:57.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.518]                   ...future.rng), globalenv = if (FALSE) 
[17:43:57.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:57.518]                     ...future.globalenv.names))
[17:43:57.518]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:57.518]         }, condition = base::local({
[17:43:57.518]             c <- base::c
[17:43:57.518]             inherits <- base::inherits
[17:43:57.518]             invokeRestart <- base::invokeRestart
[17:43:57.518]             length <- base::length
[17:43:57.518]             list <- base::list
[17:43:57.518]             seq.int <- base::seq.int
[17:43:57.518]             signalCondition <- base::signalCondition
[17:43:57.518]             sys.calls <- base::sys.calls
[17:43:57.518]             `[[` <- base::`[[`
[17:43:57.518]             `+` <- base::`+`
[17:43:57.518]             `<<-` <- base::`<<-`
[17:43:57.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:57.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:57.518]                   3L)]
[17:43:57.518]             }
[17:43:57.518]             function(cond) {
[17:43:57.518]                 is_error <- inherits(cond, "error")
[17:43:57.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:57.518]                   NULL)
[17:43:57.518]                 if (is_error) {
[17:43:57.518]                   sessionInformation <- function() {
[17:43:57.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:57.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:57.518]                       search = base::search(), system = base::Sys.info())
[17:43:57.518]                   }
[17:43:57.518]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:57.518]                     cond$call), session = sessionInformation(), 
[17:43:57.518]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:57.518]                   signalCondition(cond)
[17:43:57.518]                 }
[17:43:57.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:57.518]                 "immediateCondition"))) {
[17:43:57.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:57.518]                   ...future.conditions[[length(...future.conditions) + 
[17:43:57.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:57.518]                   if (TRUE && !signal) {
[17:43:57.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.518]                     {
[17:43:57.518]                       inherits <- base::inherits
[17:43:57.518]                       invokeRestart <- base::invokeRestart
[17:43:57.518]                       is.null <- base::is.null
[17:43:57.518]                       muffled <- FALSE
[17:43:57.518]                       if (inherits(cond, "message")) {
[17:43:57.518]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.518]                         if (muffled) 
[17:43:57.518]                           invokeRestart("muffleMessage")
[17:43:57.518]                       }
[17:43:57.518]                       else if (inherits(cond, "warning")) {
[17:43:57.518]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.518]                         if (muffled) 
[17:43:57.518]                           invokeRestart("muffleWarning")
[17:43:57.518]                       }
[17:43:57.518]                       else if (inherits(cond, "condition")) {
[17:43:57.518]                         if (!is.null(pattern)) {
[17:43:57.518]                           computeRestarts <- base::computeRestarts
[17:43:57.518]                           grepl <- base::grepl
[17:43:57.518]                           restarts <- computeRestarts(cond)
[17:43:57.518]                           for (restart in restarts) {
[17:43:57.518]                             name <- restart$name
[17:43:57.518]                             if (is.null(name)) 
[17:43:57.518]                               next
[17:43:57.518]                             if (!grepl(pattern, name)) 
[17:43:57.518]                               next
[17:43:57.518]                             invokeRestart(restart)
[17:43:57.518]                             muffled <- TRUE
[17:43:57.518]                             break
[17:43:57.518]                           }
[17:43:57.518]                         }
[17:43:57.518]                       }
[17:43:57.518]                       invisible(muffled)
[17:43:57.518]                     }
[17:43:57.518]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.518]                   }
[17:43:57.518]                 }
[17:43:57.518]                 else {
[17:43:57.518]                   if (TRUE) {
[17:43:57.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:57.518]                     {
[17:43:57.518]                       inherits <- base::inherits
[17:43:57.518]                       invokeRestart <- base::invokeRestart
[17:43:57.518]                       is.null <- base::is.null
[17:43:57.518]                       muffled <- FALSE
[17:43:57.518]                       if (inherits(cond, "message")) {
[17:43:57.518]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:57.518]                         if (muffled) 
[17:43:57.518]                           invokeRestart("muffleMessage")
[17:43:57.518]                       }
[17:43:57.518]                       else if (inherits(cond, "warning")) {
[17:43:57.518]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:57.518]                         if (muffled) 
[17:43:57.518]                           invokeRestart("muffleWarning")
[17:43:57.518]                       }
[17:43:57.518]                       else if (inherits(cond, "condition")) {
[17:43:57.518]                         if (!is.null(pattern)) {
[17:43:57.518]                           computeRestarts <- base::computeRestarts
[17:43:57.518]                           grepl <- base::grepl
[17:43:57.518]                           restarts <- computeRestarts(cond)
[17:43:57.518]                           for (restart in restarts) {
[17:43:57.518]                             name <- restart$name
[17:43:57.518]                             if (is.null(name)) 
[17:43:57.518]                               next
[17:43:57.518]                             if (!grepl(pattern, name)) 
[17:43:57.518]                               next
[17:43:57.518]                             invokeRestart(restart)
[17:43:57.518]                             muffled <- TRUE
[17:43:57.518]                             break
[17:43:57.518]                           }
[17:43:57.518]                         }
[17:43:57.518]                       }
[17:43:57.518]                       invisible(muffled)
[17:43:57.518]                     }
[17:43:57.518]                     muffleCondition(cond, pattern = "^muffle")
[17:43:57.518]                   }
[17:43:57.518]                 }
[17:43:57.518]             }
[17:43:57.518]         }))
[17:43:57.518]     }, error = function(ex) {
[17:43:57.518]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:57.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:57.518]                 ...future.rng), started = ...future.startTime, 
[17:43:57.518]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:57.518]             version = "1.8"), class = "FutureResult")
[17:43:57.518]     }, finally = {
[17:43:57.518]         if (!identical(...future.workdir, getwd())) 
[17:43:57.518]             setwd(...future.workdir)
[17:43:57.518]         {
[17:43:57.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:57.518]                 ...future.oldOptions$nwarnings <- NULL
[17:43:57.518]             }
[17:43:57.518]             base::options(...future.oldOptions)
[17:43:57.518]             if (.Platform$OS.type == "windows") {
[17:43:57.518]                 old_names <- names(...future.oldEnvVars)
[17:43:57.518]                 envs <- base::Sys.getenv()
[17:43:57.518]                 names <- names(envs)
[17:43:57.518]                 common <- intersect(names, old_names)
[17:43:57.518]                 added <- setdiff(names, old_names)
[17:43:57.518]                 removed <- setdiff(old_names, names)
[17:43:57.518]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:57.518]                   envs[common]]
[17:43:57.518]                 NAMES <- toupper(changed)
[17:43:57.518]                 args <- list()
[17:43:57.518]                 for (kk in seq_along(NAMES)) {
[17:43:57.518]                   name <- changed[[kk]]
[17:43:57.518]                   NAME <- NAMES[[kk]]
[17:43:57.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.518]                     next
[17:43:57.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.518]                 }
[17:43:57.518]                 NAMES <- toupper(added)
[17:43:57.518]                 for (kk in seq_along(NAMES)) {
[17:43:57.518]                   name <- added[[kk]]
[17:43:57.518]                   NAME <- NAMES[[kk]]
[17:43:57.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.518]                     next
[17:43:57.518]                   args[[name]] <- ""
[17:43:57.518]                 }
[17:43:57.518]                 NAMES <- toupper(removed)
[17:43:57.518]                 for (kk in seq_along(NAMES)) {
[17:43:57.518]                   name <- removed[[kk]]
[17:43:57.518]                   NAME <- NAMES[[kk]]
[17:43:57.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:57.518]                     next
[17:43:57.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:57.518]                 }
[17:43:57.518]                 if (length(args) > 0) 
[17:43:57.518]                   base::do.call(base::Sys.setenv, args = args)
[17:43:57.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:57.518]             }
[17:43:57.518]             else {
[17:43:57.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:57.518]             }
[17:43:57.518]             {
[17:43:57.518]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:57.518]                   0L) {
[17:43:57.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:57.518]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:57.518]                   base::options(opts)
[17:43:57.518]                 }
[17:43:57.518]                 {
[17:43:57.518]                   {
[17:43:57.518]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:57.518]                     NULL
[17:43:57.518]                   }
[17:43:57.518]                   options(future.plan = NULL)
[17:43:57.518]                   if (is.na(NA_character_)) 
[17:43:57.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:57.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:57.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:57.518]                     .init = FALSE)
[17:43:57.518]                 }
[17:43:57.518]             }
[17:43:57.518]         }
[17:43:57.518]     })
[17:43:57.518]     if (TRUE) {
[17:43:57.518]         base::sink(type = "output", split = FALSE)
[17:43:57.518]         if (TRUE) {
[17:43:57.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:57.518]         }
[17:43:57.518]         else {
[17:43:57.518]             ...future.result["stdout"] <- base::list(NULL)
[17:43:57.518]         }
[17:43:57.518]         base::close(...future.stdout)
[17:43:57.518]         ...future.stdout <- NULL
[17:43:57.518]     }
[17:43:57.518]     ...future.result$conditions <- ...future.conditions
[17:43:57.518]     ...future.result$finished <- base::Sys.time()
[17:43:57.518]     ...future.result
[17:43:57.518] }
[17:43:57.521] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:43:57.521] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:43:57.521] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:43:57.522] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:57.522] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.522] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:43:57.522] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:43:57.523] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:57.523] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:57.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:57.523] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:43:57.524] MultisessionFuture started
[17:43:57.524] - Launch lazy future ... done
[17:43:57.524] run() for ‘MultisessionFuture’ ... done
[17:43:57.524] Created future:
[17:43:57.524] MultisessionFuture:
[17:43:57.524] Label: ‘future_eapply-2’
[17:43:57.524] Expression:
[17:43:57.524] {
[17:43:57.524]     do.call(function(...) {
[17:43:57.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:57.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:57.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:57.524]             on.exit(options(oopts), add = TRUE)
[17:43:57.524]         }
[17:43:57.524]         {
[17:43:57.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:57.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:57.524]                 ...future.FUN(...future.X_jj, ...)
[17:43:57.524]             })
[17:43:57.524]         }
[17:43:57.524]     }, args = future.call.arguments)
[17:43:57.524] }
[17:43:57.524] Lazy evaluation: FALSE
[17:43:57.524] Asynchronous evaluation: TRUE
[17:43:57.524] Local evaluation: TRUE
[17:43:57.524] Environment: R_GlobalEnv
[17:43:57.524] Capture standard output: TRUE
[17:43:57.524] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:57.524] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:57.524] Packages: 1 packages (‘stats’)
[17:43:57.524] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:57.524] Resolved: FALSE
[17:43:57.524] Value: <not collected>
[17:43:57.524] Conditions captured: <none>
[17:43:57.524] Early signaling: FALSE
[17:43:57.524] Owner process: 32574bd5-3e7e-8e55-9f16-4fd03382e344
[17:43:57.524] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:57.536] Chunk #2 of 2 ... DONE
[17:43:57.536] Launching 2 futures (chunks) ... DONE
[17:43:57.536] Resolving 2 futures (chunks) ...
[17:43:57.536] resolve() on list ...
[17:43:57.536]  recursive: 0
[17:43:57.536]  length: 2
[17:43:57.536] 
[17:43:57.537] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.537] - Validating connection of MultisessionFuture
[17:43:57.537] - received message: FutureResult
[17:43:57.537] - Received FutureResult
[17:43:57.537] - Erased future from FutureRegistry
[17:43:57.537] result() for ClusterFuture ...
[17:43:57.538] - result already collected: FutureResult
[17:43:57.538] result() for ClusterFuture ... done
[17:43:57.538] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.538] Future #1
[17:43:57.538] result() for ClusterFuture ...
[17:43:57.538] - result already collected: FutureResult
[17:43:57.538] result() for ClusterFuture ... done
[17:43:57.538] result() for ClusterFuture ...
[17:43:57.538] - result already collected: FutureResult
[17:43:57.538] result() for ClusterFuture ... done
[17:43:57.538] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:57.538] - nx: 2
[17:43:57.539] - relay: TRUE
[17:43:57.539] - stdout: TRUE
[17:43:57.539] - signal: TRUE
[17:43:57.539] - resignal: FALSE
[17:43:57.539] - force: TRUE
[17:43:57.539] - relayed: [n=2] FALSE, FALSE
[17:43:57.539] - queued futures: [n=2] FALSE, FALSE
[17:43:57.539]  - until=1
[17:43:57.539]  - relaying element #1
[17:43:57.539] result() for ClusterFuture ...
[17:43:57.539] - result already collected: FutureResult
[17:43:57.540] result() for ClusterFuture ... done
[17:43:57.540] result() for ClusterFuture ...
[17:43:57.540] - result already collected: FutureResult
[17:43:57.540] result() for ClusterFuture ... done
[17:43:57.540] result() for ClusterFuture ...
[17:43:57.540] - result already collected: FutureResult
[17:43:57.540] result() for ClusterFuture ... done
[17:43:57.540] result() for ClusterFuture ...
[17:43:57.540] - result already collected: FutureResult
[17:43:57.540] result() for ClusterFuture ... done
[17:43:57.540] - relayed: [n=2] TRUE, FALSE
[17:43:57.540] - queued futures: [n=2] TRUE, FALSE
[17:43:57.541] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:57.541]  length: 1 (resolved future 1)
[17:43:57.569] receiveMessageFromWorker() for ClusterFuture ...
[17:43:57.570] - Validating connection of MultisessionFuture
[17:43:57.570] - received message: FutureResult
[17:43:57.570] - Received FutureResult
[17:43:57.570] - Erased future from FutureRegistry
[17:43:57.570] result() for ClusterFuture ...
[17:43:57.570] - result already collected: FutureResult
[17:43:57.570] result() for ClusterFuture ... done
[17:43:57.570] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:57.570] Future #2
[17:43:57.571] result() for ClusterFuture ...
[17:43:57.571] - result already collected: FutureResult
[17:43:57.571] result() for ClusterFuture ... done
[17:43:57.571] result() for ClusterFuture ...
[17:43:57.571] - result already collected: FutureResult
[17:43:57.571] result() for ClusterFuture ... done
[17:43:57.571] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:57.571] - nx: 2
[17:43:57.571] - relay: TRUE
[17:43:57.571] - stdout: TRUE
[17:43:57.572] - signal: TRUE
[17:43:57.572] - resignal: FALSE
[17:43:57.572] - force: TRUE
[17:43:57.572] - relayed: [n=2] TRUE, FALSE
[17:43:57.572] - queued futures: [n=2] TRUE, FALSE
[17:43:57.572]  - until=2
[17:43:57.572]  - relaying element #2
[17:43:57.572] result() for ClusterFuture ...
[17:43:57.572] - result already collected: FutureResult
[17:43:57.572] result() for ClusterFuture ... done
[17:43:57.572] result() for ClusterFuture ...
[17:43:57.572] - result already collected: FutureResult
[17:43:57.573] result() for ClusterFuture ... done
[17:43:57.573] result() for ClusterFuture ...
[17:43:57.573] - result already collected: FutureResult
[17:43:57.573] result() for ClusterFuture ... done
[17:43:57.573] result() for ClusterFuture ...
[17:43:57.573] - result already collected: FutureResult
[17:43:57.573] result() for ClusterFuture ... done
[17:43:57.573] - relayed: [n=2] TRUE, TRUE
[17:43:57.573] - queued futures: [n=2] TRUE, TRUE
[17:43:57.573] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:57.573]  length: 0 (resolved future 2)
[17:43:57.574] Relaying remaining futures
[17:43:57.574] signalConditionsASAP(NULL, pos=0) ...
[17:43:57.574] - nx: 2
[17:43:57.574] - relay: TRUE
[17:43:57.574] - stdout: TRUE
[17:43:57.574] - signal: TRUE
[17:43:57.574] - resignal: FALSE
[17:43:57.574] - force: TRUE
[17:43:57.574] - relayed: [n=2] TRUE, TRUE
[17:43:57.574] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:57.574] - relayed: [n=2] TRUE, TRUE
[17:43:57.574] - queued futures: [n=2] TRUE, TRUE
[17:43:57.575] signalConditionsASAP(NULL, pos=0) ... done
[17:43:57.575] resolve() on list ... DONE
[17:43:57.575] result() for ClusterFuture ...
[17:43:57.575] - result already collected: FutureResult
[17:43:57.575] result() for ClusterFuture ... done
[17:43:57.575] result() for ClusterFuture ...
[17:43:57.575] - result already collected: FutureResult
[17:43:57.575] result() for ClusterFuture ... done
[17:43:57.575] result() for ClusterFuture ...
[17:43:57.575] - result already collected: FutureResult
[17:43:57.575] result() for ClusterFuture ... done
[17:43:57.576] result() for ClusterFuture ...
[17:43:57.576] - result already collected: FutureResult
[17:43:57.576] result() for ClusterFuture ... done
[17:43:57.576]  - Number of value chunks collected: 2
[17:43:57.576] Resolving 2 futures (chunks) ... DONE
[17:43:57.576] Reducing values from 2 chunks ...
[17:43:57.576]  - Number of values collected after concatenation: 3
[17:43:57.576]  - Number of values expected: 3
[17:43:57.576] Reducing values from 2 chunks ... DONE
[17:43:57.576] future_lapply() ... DONE
[17:43:57.577] plan(): Setting new future strategy stack:
[17:43:57.577] List of future strategies:
[17:43:57.577] 1. sequential:
[17:43:57.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:57.577]    - tweaked: FALSE
[17:43:57.577]    - call: plan(sequential)
[17:43:57.578] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[17:43:57.578] plan(): Setting new future strategy stack:
[17:43:57.579] List of future strategies:
[17:43:57.579] 1. FutureStrategy:
[17:43:57.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:57.579]    - tweaked: FALSE
[17:43:57.579]    - call: future::plan(oplan)
[17:43:57.579] plan(): nbrOfWorkers() = 1
> 
