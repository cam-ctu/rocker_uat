
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:59:30.746] plan(): Setting new future strategy stack:
[17:59:30.747] List of future strategies:
[17:59:30.747] 1. sequential:
[17:59:30.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:30.747]    - tweaked: FALSE
[17:59:30.747]    - call: future::plan("sequential")
[17:59:30.775] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:59:30.820] plan(): Setting new future strategy stack:
[17:59:30.820] List of future strategies:
[17:59:30.820] 1. sequential:
[17:59:30.820]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:30.820]    - tweaked: FALSE
[17:59:30.820]    - call: plan(strategy)
[17:59:30.847] plan(): nbrOfWorkers() = 1
[17:59:30.848] future_lapply() ...
[17:59:30.855] Number of chunks: 1
[17:59:30.856] getGlobalsAndPackagesXApply() ...
[17:59:30.856]  - future.globals: TRUE
[17:59:30.857] getGlobalsAndPackages() ...
[17:59:30.858] Searching for globals...
[17:59:30.862] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:30.862] Searching for globals ... DONE
[17:59:30.863] Resolving globals: FALSE
[17:59:30.864] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:30.865] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:30.865] - globals: [1] ‘FUN’
[17:59:30.866] 
[17:59:30.866] getGlobalsAndPackages() ... DONE
[17:59:30.866]  - globals found/used: [n=1] ‘FUN’
[17:59:30.866]  - needed namespaces: [n=0] 
[17:59:30.867] Finding globals ... DONE
[17:59:30.867]  - use_args: TRUE
[17:59:30.867]  - Getting '...' globals ...
[17:59:30.868] resolve() on list ...
[17:59:30.869]  recursive: 0
[17:59:30.869]  length: 1
[17:59:30.869]  elements: ‘...’
[17:59:30.870]  length: 0 (resolved future 1)
[17:59:30.870] resolve() on list ... DONE
[17:59:30.870]    - '...' content: [n=0] 
[17:59:30.870] List of 1
[17:59:30.870]  $ ...: list()
[17:59:30.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.870]  - attr(*, "where")=List of 1
[17:59:30.870]   ..$ ...:<environment: 0x58d4c2918198> 
[17:59:30.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.870]  - attr(*, "resolved")= logi TRUE
[17:59:30.870]  - attr(*, "total_size")= num NA
[17:59:30.879]  - Getting '...' globals ... DONE
[17:59:30.879] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:30.879] List of 2
[17:59:30.879]  $ ...future.FUN:function (x, ...)  
[17:59:30.879]  $ ...          : list()
[17:59:30.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.879]  - attr(*, "where")=List of 2
[17:59:30.879]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:30.879]   ..$ ...          :<environment: 0x58d4c2918198> 
[17:59:30.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.879]  - attr(*, "resolved")= logi FALSE
[17:59:30.879]  - attr(*, "total_size")= num 1240
[17:59:30.885] Packages to be attached in all futures: [n=0] 
[17:59:30.885] getGlobalsAndPackagesXApply() ... DONE
[17:59:30.885] Number of futures (= number of chunks): 1
[17:59:30.886] Launching 1 futures (chunks) ...
[17:59:30.886] Chunk #1 of 1 ...
[17:59:30.886]  - Finding globals in 'X' for chunk #1 ...
[17:59:30.887] getGlobalsAndPackages() ...
[17:59:30.887] Searching for globals...
[17:59:30.887] 
[17:59:30.888] Searching for globals ... DONE
[17:59:30.888] - globals: [0] <none>
[17:59:30.888] getGlobalsAndPackages() ... DONE
[17:59:30.888]    + additional globals found: [n=0] 
[17:59:30.888]    + additional namespaces needed: [n=0] 
[17:59:30.889]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:30.889]  - seeds: <none>
[17:59:30.889]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.889] getGlobalsAndPackages() ...
[17:59:30.889] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.890] Resolving globals: FALSE
[17:59:30.890] Tweak future expression to call with '...' arguments ...
[17:59:30.890] {
[17:59:30.890]     do.call(function(...) {
[17:59:30.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.890]             on.exit(options(oopts), add = TRUE)
[17:59:30.890]         }
[17:59:30.890]         {
[17:59:30.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.890]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.890]             })
[17:59:30.890]         }
[17:59:30.890]     }, args = future.call.arguments)
[17:59:30.890] }
[17:59:30.891] Tweak future expression to call with '...' arguments ... DONE
[17:59:30.891] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.892] 
[17:59:30.892] getGlobalsAndPackages() ... DONE
[17:59:30.893] run() for ‘Future’ ...
[17:59:30.893] - state: ‘created’
[17:59:30.894] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:30.894] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:30.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:30.895]   - Field: ‘label’
[17:59:30.895]   - Field: ‘local’
[17:59:30.895]   - Field: ‘owner’
[17:59:30.895]   - Field: ‘envir’
[17:59:30.896]   - Field: ‘packages’
[17:59:30.896]   - Field: ‘gc’
[17:59:30.896]   - Field: ‘conditions’
[17:59:30.896]   - Field: ‘expr’
[17:59:30.896]   - Field: ‘uuid’
[17:59:30.897]   - Field: ‘seed’
[17:59:30.897]   - Field: ‘version’
[17:59:30.897]   - Field: ‘result’
[17:59:30.897]   - Field: ‘asynchronous’
[17:59:30.897]   - Field: ‘calls’
[17:59:30.897]   - Field: ‘globals’
[17:59:30.898]   - Field: ‘stdout’
[17:59:30.898]   - Field: ‘earlySignal’
[17:59:30.898]   - Field: ‘lazy’
[17:59:30.898]   - Field: ‘state’
[17:59:30.898] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:30.899] - Launch lazy future ...
[17:59:30.900] Packages needed by the future expression (n = 0): <none>
[17:59:30.900] Packages needed by future strategies (n = 0): <none>
[17:59:30.902] {
[17:59:30.902]     {
[17:59:30.902]         {
[17:59:30.902]             ...future.startTime <- base::Sys.time()
[17:59:30.902]             {
[17:59:30.902]                 {
[17:59:30.902]                   {
[17:59:30.902]                     base::local({
[17:59:30.902]                       has_future <- base::requireNamespace("future", 
[17:59:30.902]                         quietly = TRUE)
[17:59:30.902]                       if (has_future) {
[17:59:30.902]                         ns <- base::getNamespace("future")
[17:59:30.902]                         version <- ns[[".package"]][["version"]]
[17:59:30.902]                         if (is.null(version)) 
[17:59:30.902]                           version <- utils::packageVersion("future")
[17:59:30.902]                       }
[17:59:30.902]                       else {
[17:59:30.902]                         version <- NULL
[17:59:30.902]                       }
[17:59:30.902]                       if (!has_future || version < "1.8.0") {
[17:59:30.902]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:30.902]                           "", base::R.version$version.string), 
[17:59:30.902]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:30.902]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:30.902]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:30.902]                             "release", "version")], collapse = " "), 
[17:59:30.902]                           hostname = base::Sys.info()[["nodename"]])
[17:59:30.902]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:30.902]                           info)
[17:59:30.902]                         info <- base::paste(info, collapse = "; ")
[17:59:30.902]                         if (!has_future) {
[17:59:30.902]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:30.902]                             info)
[17:59:30.902]                         }
[17:59:30.902]                         else {
[17:59:30.902]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:30.902]                             info, version)
[17:59:30.902]                         }
[17:59:30.902]                         base::stop(msg)
[17:59:30.902]                       }
[17:59:30.902]                     })
[17:59:30.902]                   }
[17:59:30.902]                   ...future.strategy.old <- future::plan("list")
[17:59:30.902]                   options(future.plan = NULL)
[17:59:30.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:30.902]                 }
[17:59:30.902]                 ...future.workdir <- getwd()
[17:59:30.902]             }
[17:59:30.902]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:30.902]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:30.902]         }
[17:59:30.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:30.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:30.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:30.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:30.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:30.902]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:30.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:30.902]             base::names(...future.oldOptions))
[17:59:30.902]     }
[17:59:30.902]     if (FALSE) {
[17:59:30.902]     }
[17:59:30.902]     else {
[17:59:30.902]         if (TRUE) {
[17:59:30.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:30.902]                 open = "w")
[17:59:30.902]         }
[17:59:30.902]         else {
[17:59:30.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:30.902]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:30.902]         }
[17:59:30.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:30.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:30.902]             base::sink(type = "output", split = FALSE)
[17:59:30.902]             base::close(...future.stdout)
[17:59:30.902]         }, add = TRUE)
[17:59:30.902]     }
[17:59:30.902]     ...future.frame <- base::sys.nframe()
[17:59:30.902]     ...future.conditions <- base::list()
[17:59:30.902]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:30.902]     if (FALSE) {
[17:59:30.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:30.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:30.902]     }
[17:59:30.902]     ...future.result <- base::tryCatch({
[17:59:30.902]         base::withCallingHandlers({
[17:59:30.902]             ...future.value <- base::withVisible(base::local({
[17:59:30.902]                 do.call(function(...) {
[17:59:30.902]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.902]                   if (!identical(...future.globals.maxSize.org, 
[17:59:30.902]                     ...future.globals.maxSize)) {
[17:59:30.902]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.902]                     on.exit(options(oopts), add = TRUE)
[17:59:30.902]                   }
[17:59:30.902]                   {
[17:59:30.902]                     lapply(seq_along(...future.elements_ii), 
[17:59:30.902]                       FUN = function(jj) {
[17:59:30.902]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.902]                         ...future.FUN(...future.X_jj, ...)
[17:59:30.902]                       })
[17:59:30.902]                   }
[17:59:30.902]                 }, args = future.call.arguments)
[17:59:30.902]             }))
[17:59:30.902]             future::FutureResult(value = ...future.value$value, 
[17:59:30.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.902]                   ...future.rng), globalenv = if (FALSE) 
[17:59:30.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:30.902]                     ...future.globalenv.names))
[17:59:30.902]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:30.902]         }, condition = base::local({
[17:59:30.902]             c <- base::c
[17:59:30.902]             inherits <- base::inherits
[17:59:30.902]             invokeRestart <- base::invokeRestart
[17:59:30.902]             length <- base::length
[17:59:30.902]             list <- base::list
[17:59:30.902]             seq.int <- base::seq.int
[17:59:30.902]             signalCondition <- base::signalCondition
[17:59:30.902]             sys.calls <- base::sys.calls
[17:59:30.902]             `[[` <- base::`[[`
[17:59:30.902]             `+` <- base::`+`
[17:59:30.902]             `<<-` <- base::`<<-`
[17:59:30.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:30.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:30.902]                   3L)]
[17:59:30.902]             }
[17:59:30.902]             function(cond) {
[17:59:30.902]                 is_error <- inherits(cond, "error")
[17:59:30.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:30.902]                   NULL)
[17:59:30.902]                 if (is_error) {
[17:59:30.902]                   sessionInformation <- function() {
[17:59:30.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:30.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:30.902]                       search = base::search(), system = base::Sys.info())
[17:59:30.902]                   }
[17:59:30.902]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:30.902]                     cond$call), session = sessionInformation(), 
[17:59:30.902]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:30.902]                   signalCondition(cond)
[17:59:30.902]                 }
[17:59:30.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:30.902]                 "immediateCondition"))) {
[17:59:30.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:30.902]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:30.902]                   if (TRUE && !signal) {
[17:59:30.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.902]                     {
[17:59:30.902]                       inherits <- base::inherits
[17:59:30.902]                       invokeRestart <- base::invokeRestart
[17:59:30.902]                       is.null <- base::is.null
[17:59:30.902]                       muffled <- FALSE
[17:59:30.902]                       if (inherits(cond, "message")) {
[17:59:30.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.902]                         if (muffled) 
[17:59:30.902]                           invokeRestart("muffleMessage")
[17:59:30.902]                       }
[17:59:30.902]                       else if (inherits(cond, "warning")) {
[17:59:30.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.902]                         if (muffled) 
[17:59:30.902]                           invokeRestart("muffleWarning")
[17:59:30.902]                       }
[17:59:30.902]                       else if (inherits(cond, "condition")) {
[17:59:30.902]                         if (!is.null(pattern)) {
[17:59:30.902]                           computeRestarts <- base::computeRestarts
[17:59:30.902]                           grepl <- base::grepl
[17:59:30.902]                           restarts <- computeRestarts(cond)
[17:59:30.902]                           for (restart in restarts) {
[17:59:30.902]                             name <- restart$name
[17:59:30.902]                             if (is.null(name)) 
[17:59:30.902]                               next
[17:59:30.902]                             if (!grepl(pattern, name)) 
[17:59:30.902]                               next
[17:59:30.902]                             invokeRestart(restart)
[17:59:30.902]                             muffled <- TRUE
[17:59:30.902]                             break
[17:59:30.902]                           }
[17:59:30.902]                         }
[17:59:30.902]                       }
[17:59:30.902]                       invisible(muffled)
[17:59:30.902]                     }
[17:59:30.902]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.902]                   }
[17:59:30.902]                 }
[17:59:30.902]                 else {
[17:59:30.902]                   if (TRUE) {
[17:59:30.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.902]                     {
[17:59:30.902]                       inherits <- base::inherits
[17:59:30.902]                       invokeRestart <- base::invokeRestart
[17:59:30.902]                       is.null <- base::is.null
[17:59:30.902]                       muffled <- FALSE
[17:59:30.902]                       if (inherits(cond, "message")) {
[17:59:30.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.902]                         if (muffled) 
[17:59:30.902]                           invokeRestart("muffleMessage")
[17:59:30.902]                       }
[17:59:30.902]                       else if (inherits(cond, "warning")) {
[17:59:30.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.902]                         if (muffled) 
[17:59:30.902]                           invokeRestart("muffleWarning")
[17:59:30.902]                       }
[17:59:30.902]                       else if (inherits(cond, "condition")) {
[17:59:30.902]                         if (!is.null(pattern)) {
[17:59:30.902]                           computeRestarts <- base::computeRestarts
[17:59:30.902]                           grepl <- base::grepl
[17:59:30.902]                           restarts <- computeRestarts(cond)
[17:59:30.902]                           for (restart in restarts) {
[17:59:30.902]                             name <- restart$name
[17:59:30.902]                             if (is.null(name)) 
[17:59:30.902]                               next
[17:59:30.902]                             if (!grepl(pattern, name)) 
[17:59:30.902]                               next
[17:59:30.902]                             invokeRestart(restart)
[17:59:30.902]                             muffled <- TRUE
[17:59:30.902]                             break
[17:59:30.902]                           }
[17:59:30.902]                         }
[17:59:30.902]                       }
[17:59:30.902]                       invisible(muffled)
[17:59:30.902]                     }
[17:59:30.902]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.902]                   }
[17:59:30.902]                 }
[17:59:30.902]             }
[17:59:30.902]         }))
[17:59:30.902]     }, error = function(ex) {
[17:59:30.902]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:30.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.902]                 ...future.rng), started = ...future.startTime, 
[17:59:30.902]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:30.902]             version = "1.8"), class = "FutureResult")
[17:59:30.902]     }, finally = {
[17:59:30.902]         if (!identical(...future.workdir, getwd())) 
[17:59:30.902]             setwd(...future.workdir)
[17:59:30.902]         {
[17:59:30.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:30.902]                 ...future.oldOptions$nwarnings <- NULL
[17:59:30.902]             }
[17:59:30.902]             base::options(...future.oldOptions)
[17:59:30.902]             if (.Platform$OS.type == "windows") {
[17:59:30.902]                 old_names <- names(...future.oldEnvVars)
[17:59:30.902]                 envs <- base::Sys.getenv()
[17:59:30.902]                 names <- names(envs)
[17:59:30.902]                 common <- intersect(names, old_names)
[17:59:30.902]                 added <- setdiff(names, old_names)
[17:59:30.902]                 removed <- setdiff(old_names, names)
[17:59:30.902]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:30.902]                   envs[common]]
[17:59:30.902]                 NAMES <- toupper(changed)
[17:59:30.902]                 args <- list()
[17:59:30.902]                 for (kk in seq_along(NAMES)) {
[17:59:30.902]                   name <- changed[[kk]]
[17:59:30.902]                   NAME <- NAMES[[kk]]
[17:59:30.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.902]                     next
[17:59:30.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.902]                 }
[17:59:30.902]                 NAMES <- toupper(added)
[17:59:30.902]                 for (kk in seq_along(NAMES)) {
[17:59:30.902]                   name <- added[[kk]]
[17:59:30.902]                   NAME <- NAMES[[kk]]
[17:59:30.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.902]                     next
[17:59:30.902]                   args[[name]] <- ""
[17:59:30.902]                 }
[17:59:30.902]                 NAMES <- toupper(removed)
[17:59:30.902]                 for (kk in seq_along(NAMES)) {
[17:59:30.902]                   name <- removed[[kk]]
[17:59:30.902]                   NAME <- NAMES[[kk]]
[17:59:30.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.902]                     next
[17:59:30.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.902]                 }
[17:59:30.902]                 if (length(args) > 0) 
[17:59:30.902]                   base::do.call(base::Sys.setenv, args = args)
[17:59:30.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:30.902]             }
[17:59:30.902]             else {
[17:59:30.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:30.902]             }
[17:59:30.902]             {
[17:59:30.902]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:30.902]                   0L) {
[17:59:30.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:30.902]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:30.902]                   base::options(opts)
[17:59:30.902]                 }
[17:59:30.902]                 {
[17:59:30.902]                   {
[17:59:30.902]                     NULL
[17:59:30.902]                     RNGkind("Mersenne-Twister")
[17:59:30.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:30.902]                       inherits = FALSE)
[17:59:30.902]                   }
[17:59:30.902]                   options(future.plan = NULL)
[17:59:30.902]                   if (is.na(NA_character_)) 
[17:59:30.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:30.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:30.902]                     .init = FALSE)
[17:59:30.902]                 }
[17:59:30.902]             }
[17:59:30.902]         }
[17:59:30.902]     })
[17:59:30.902]     if (TRUE) {
[17:59:30.902]         base::sink(type = "output", split = FALSE)
[17:59:30.902]         if (TRUE) {
[17:59:30.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:30.902]         }
[17:59:30.902]         else {
[17:59:30.902]             ...future.result["stdout"] <- base::list(NULL)
[17:59:30.902]         }
[17:59:30.902]         base::close(...future.stdout)
[17:59:30.902]         ...future.stdout <- NULL
[17:59:30.902]     }
[17:59:30.902]     ...future.result$conditions <- ...future.conditions
[17:59:30.902]     ...future.result$finished <- base::Sys.time()
[17:59:30.902]     ...future.result
[17:59:30.902] }
[17:59:30.905] assign_globals() ...
[17:59:30.905] List of 5
[17:59:30.905]  $ ...future.FUN            :function (x, ...)  
[17:59:30.905]  $ future.call.arguments    : list()
[17:59:30.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.905]  $ ...future.elements_ii    :List of 3
[17:59:30.905]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:59:30.905]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:30.905]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:30.905]  $ ...future.seeds_ii       : NULL
[17:59:30.905]  $ ...future.globals.maxSize: NULL
[17:59:30.905]  - attr(*, "where")=List of 5
[17:59:30.905]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:30.905]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:30.905]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:30.905]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:30.905]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:30.905]  - attr(*, "resolved")= logi FALSE
[17:59:30.905]  - attr(*, "total_size")= num 1240
[17:59:30.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.905]  - attr(*, "already-done")= logi TRUE
[17:59:30.920] - copied ‘...future.FUN’ to environment
[17:59:30.921] - copied ‘future.call.arguments’ to environment
[17:59:30.921] - copied ‘...future.elements_ii’ to environment
[17:59:30.921] - copied ‘...future.seeds_ii’ to environment
[17:59:30.921] - copied ‘...future.globals.maxSize’ to environment
[17:59:30.922] assign_globals() ... done
[17:59:30.922] plan(): Setting new future strategy stack:
[17:59:30.922] List of future strategies:
[17:59:30.922] 1. sequential:
[17:59:30.922]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:30.922]    - tweaked: FALSE
[17:59:30.922]    - call: NULL
[17:59:30.923] plan(): nbrOfWorkers() = 1
[17:59:30.925] plan(): Setting new future strategy stack:
[17:59:30.926] List of future strategies:
[17:59:30.926] 1. sequential:
[17:59:30.926]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:30.926]    - tweaked: FALSE
[17:59:30.926]    - call: plan(strategy)
[17:59:30.926] plan(): nbrOfWorkers() = 1
[17:59:30.927] SequentialFuture started (and completed)
[17:59:30.928] - Launch lazy future ... done
[17:59:30.928] run() for ‘SequentialFuture’ ... done
[17:59:30.928] Created future:
[17:59:30.928] SequentialFuture:
[17:59:30.928] Label: ‘future_eapply-1’
[17:59:30.928] Expression:
[17:59:30.928] {
[17:59:30.928]     do.call(function(...) {
[17:59:30.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.928]             on.exit(options(oopts), add = TRUE)
[17:59:30.928]         }
[17:59:30.928]         {
[17:59:30.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.928]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.928]             })
[17:59:30.928]         }
[17:59:30.928]     }, args = future.call.arguments)
[17:59:30.928] }
[17:59:30.928] Lazy evaluation: FALSE
[17:59:30.928] Asynchronous evaluation: FALSE
[17:59:30.928] Local evaluation: TRUE
[17:59:30.928] Environment: R_GlobalEnv
[17:59:30.928] Capture standard output: TRUE
[17:59:30.928] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:30.928] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:30.928] Packages: <none>
[17:59:30.928] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:30.928] Resolved: TRUE
[17:59:30.928] Value: 168 bytes of class ‘list’
[17:59:30.928] Early signaling: FALSE
[17:59:30.928] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:30.928] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:30.931] Chunk #1 of 1 ... DONE
[17:59:30.931] Launching 1 futures (chunks) ... DONE
[17:59:30.931] Resolving 1 futures (chunks) ...
[17:59:30.932] resolve() on list ...
[17:59:30.932]  recursive: 0
[17:59:30.932]  length: 1
[17:59:30.932] 
[17:59:30.933] resolved() for ‘SequentialFuture’ ...
[17:59:30.933] - state: ‘finished’
[17:59:30.933] - run: TRUE
[17:59:30.933] - result: ‘FutureResult’
[17:59:30.933] resolved() for ‘SequentialFuture’ ... done
[17:59:30.934] Future #1
[17:59:30.934] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:30.935] - nx: 1
[17:59:30.935] - relay: TRUE
[17:59:30.935] - stdout: TRUE
[17:59:30.935] - signal: TRUE
[17:59:30.935] - resignal: FALSE
[17:59:30.935] - force: TRUE
[17:59:30.936] - relayed: [n=1] FALSE
[17:59:30.936] - queued futures: [n=1] FALSE
[17:59:30.936]  - until=1
[17:59:30.936]  - relaying element #1
[17:59:30.937] - relayed: [n=1] TRUE
[17:59:30.937] - queued futures: [n=1] TRUE
[17:59:30.937] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:30.937]  length: 0 (resolved future 1)
[17:59:30.938] Relaying remaining futures
[17:59:30.938] signalConditionsASAP(NULL, pos=0) ...
[17:59:30.938] - nx: 1
[17:59:30.938] - relay: TRUE
[17:59:30.938] - stdout: TRUE
[17:59:30.938] - signal: TRUE
[17:59:30.939] - resignal: FALSE
[17:59:30.939] - force: TRUE
[17:59:30.939] - relayed: [n=1] TRUE
[17:59:30.939] - queued futures: [n=1] TRUE
 - flush all
[17:59:30.939] - relayed: [n=1] TRUE
[17:59:30.940] - queued futures: [n=1] TRUE
[17:59:30.940] signalConditionsASAP(NULL, pos=0) ... done
[17:59:30.940] resolve() on list ... DONE
[17:59:30.940]  - Number of value chunks collected: 1
[17:59:30.940] Resolving 1 futures (chunks) ... DONE
[17:59:30.941] Reducing values from 1 chunks ...
[17:59:30.941]  - Number of values collected after concatenation: 3
[17:59:30.941]  - Number of values expected: 3
[17:59:30.941] Reducing values from 1 chunks ... DONE
[17:59:30.942] future_lapply() ... DONE
[17:59:30.945] future_lapply() ...
[17:59:30.946] Number of chunks: 1
[17:59:30.946] getGlobalsAndPackagesXApply() ...
[17:59:30.946]  - future.globals: TRUE
[17:59:30.947] getGlobalsAndPackages() ...
[17:59:30.947] Searching for globals...
[17:59:30.949] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:30.949] Searching for globals ... DONE
[17:59:30.949] Resolving globals: FALSE
[17:59:30.950] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:30.951] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:30.951] - globals: [1] ‘FUN’
[17:59:30.951] - packages: [1] ‘stats’
[17:59:30.951] getGlobalsAndPackages() ... DONE
[17:59:30.951]  - globals found/used: [n=1] ‘FUN’
[17:59:30.952]  - needed namespaces: [n=1] ‘stats’
[17:59:30.952] Finding globals ... DONE
[17:59:30.952]  - use_args: TRUE
[17:59:30.952]  - Getting '...' globals ...
[17:59:30.953] resolve() on list ...
[17:59:30.953]  recursive: 0
[17:59:30.953]  length: 1
[17:59:30.953]  elements: ‘...’
[17:59:30.954]  length: 0 (resolved future 1)
[17:59:30.954] resolve() on list ... DONE
[17:59:30.954]    - '...' content: [n=1] ‘probs’
[17:59:30.954] List of 1
[17:59:30.954]  $ ...:List of 1
[17:59:30.954]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:30.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.954]  - attr(*, "where")=List of 1
[17:59:30.954]   ..$ ...:<environment: 0x58d4c4771d40> 
[17:59:30.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.954]  - attr(*, "resolved")= logi TRUE
[17:59:30.954]  - attr(*, "total_size")= num NA
[17:59:30.960]  - Getting '...' globals ... DONE
[17:59:30.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:30.961] List of 2
[17:59:30.961]  $ ...future.FUN:function (x, ...)  
[17:59:30.961]  $ ...          :List of 1
[17:59:30.961]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:30.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.961]  - attr(*, "where")=List of 2
[17:59:30.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:30.961]   ..$ ...          :<environment: 0x58d4c4771d40> 
[17:59:30.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.961]  - attr(*, "resolved")= logi FALSE
[17:59:30.961]  - attr(*, "total_size")= num 1328
[17:59:30.967] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:30.967] getGlobalsAndPackagesXApply() ... DONE
[17:59:30.967] Number of futures (= number of chunks): 1
[17:59:30.968] Launching 1 futures (chunks) ...
[17:59:30.968] Chunk #1 of 1 ...
[17:59:30.968]  - Finding globals in 'X' for chunk #1 ...
[17:59:30.968] getGlobalsAndPackages() ...
[17:59:30.968] Searching for globals...
[17:59:30.969] 
[17:59:30.969] Searching for globals ... DONE
[17:59:30.969] - globals: [0] <none>
[17:59:30.969] getGlobalsAndPackages() ... DONE
[17:59:30.972]    + additional globals found: [n=0] 
[17:59:30.973]    + additional namespaces needed: [n=0] 
[17:59:30.973]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:30.973]  - seeds: <none>
[17:59:30.973]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.973] getGlobalsAndPackages() ...
[17:59:30.973] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.974] Resolving globals: FALSE
[17:59:30.974] Tweak future expression to call with '...' arguments ...
[17:59:30.974] {
[17:59:30.974]     do.call(function(...) {
[17:59:30.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.974]             on.exit(options(oopts), add = TRUE)
[17:59:30.974]         }
[17:59:30.974]         {
[17:59:30.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.974]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.974]             })
[17:59:30.974]         }
[17:59:30.974]     }, args = future.call.arguments)
[17:59:30.974] }
[17:59:30.975] Tweak future expression to call with '...' arguments ... DONE
[17:59:30.975] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.976] - packages: [1] ‘stats’
[17:59:30.976] getGlobalsAndPackages() ... DONE
[17:59:30.976] run() for ‘Future’ ...
[17:59:30.977] - state: ‘created’
[17:59:30.977] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:30.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:30.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:30.978]   - Field: ‘label’
[17:59:30.978]   - Field: ‘local’
[17:59:30.978]   - Field: ‘owner’
[17:59:30.978]   - Field: ‘envir’
[17:59:30.979]   - Field: ‘packages’
[17:59:30.979]   - Field: ‘gc’
[17:59:30.979]   - Field: ‘conditions’
[17:59:30.979]   - Field: ‘expr’
[17:59:30.979]   - Field: ‘uuid’
[17:59:30.980]   - Field: ‘seed’
[17:59:30.980]   - Field: ‘version’
[17:59:30.980]   - Field: ‘result’
[17:59:30.980]   - Field: ‘asynchronous’
[17:59:30.980]   - Field: ‘calls’
[17:59:30.981]   - Field: ‘globals’
[17:59:30.981]   - Field: ‘stdout’
[17:59:30.981]   - Field: ‘earlySignal’
[17:59:30.981]   - Field: ‘lazy’
[17:59:30.981]   - Field: ‘state’
[17:59:30.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:30.982] - Launch lazy future ...
[17:59:30.982] Packages needed by the future expression (n = 1): ‘stats’
[17:59:30.982] Packages needed by future strategies (n = 0): <none>
[17:59:30.983] {
[17:59:30.983]     {
[17:59:30.983]         {
[17:59:30.983]             ...future.startTime <- base::Sys.time()
[17:59:30.983]             {
[17:59:30.983]                 {
[17:59:30.983]                   {
[17:59:30.983]                     {
[17:59:30.983]                       base::local({
[17:59:30.983]                         has_future <- base::requireNamespace("future", 
[17:59:30.983]                           quietly = TRUE)
[17:59:30.983]                         if (has_future) {
[17:59:30.983]                           ns <- base::getNamespace("future")
[17:59:30.983]                           version <- ns[[".package"]][["version"]]
[17:59:30.983]                           if (is.null(version)) 
[17:59:30.983]                             version <- utils::packageVersion("future")
[17:59:30.983]                         }
[17:59:30.983]                         else {
[17:59:30.983]                           version <- NULL
[17:59:30.983]                         }
[17:59:30.983]                         if (!has_future || version < "1.8.0") {
[17:59:30.983]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:30.983]                             "", base::R.version$version.string), 
[17:59:30.983]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:30.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:30.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:30.983]                               "release", "version")], collapse = " "), 
[17:59:30.983]                             hostname = base::Sys.info()[["nodename"]])
[17:59:30.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:30.983]                             info)
[17:59:30.983]                           info <- base::paste(info, collapse = "; ")
[17:59:30.983]                           if (!has_future) {
[17:59:30.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:30.983]                               info)
[17:59:30.983]                           }
[17:59:30.983]                           else {
[17:59:30.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:30.983]                               info, version)
[17:59:30.983]                           }
[17:59:30.983]                           base::stop(msg)
[17:59:30.983]                         }
[17:59:30.983]                       })
[17:59:30.983]                     }
[17:59:30.983]                     base::local({
[17:59:30.983]                       for (pkg in "stats") {
[17:59:30.983]                         base::loadNamespace(pkg)
[17:59:30.983]                         base::library(pkg, character.only = TRUE)
[17:59:30.983]                       }
[17:59:30.983]                     })
[17:59:30.983]                   }
[17:59:30.983]                   ...future.strategy.old <- future::plan("list")
[17:59:30.983]                   options(future.plan = NULL)
[17:59:30.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:30.983]                 }
[17:59:30.983]                 ...future.workdir <- getwd()
[17:59:30.983]             }
[17:59:30.983]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:30.983]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:30.983]         }
[17:59:30.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:30.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:30.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:30.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:30.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:30.983]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:30.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:30.983]             base::names(...future.oldOptions))
[17:59:30.983]     }
[17:59:30.983]     if (FALSE) {
[17:59:30.983]     }
[17:59:30.983]     else {
[17:59:30.983]         if (TRUE) {
[17:59:30.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:30.983]                 open = "w")
[17:59:30.983]         }
[17:59:30.983]         else {
[17:59:30.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:30.983]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:30.983]         }
[17:59:30.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:30.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:30.983]             base::sink(type = "output", split = FALSE)
[17:59:30.983]             base::close(...future.stdout)
[17:59:30.983]         }, add = TRUE)
[17:59:30.983]     }
[17:59:30.983]     ...future.frame <- base::sys.nframe()
[17:59:30.983]     ...future.conditions <- base::list()
[17:59:30.983]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:30.983]     if (FALSE) {
[17:59:30.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:30.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:30.983]     }
[17:59:30.983]     ...future.result <- base::tryCatch({
[17:59:30.983]         base::withCallingHandlers({
[17:59:30.983]             ...future.value <- base::withVisible(base::local({
[17:59:30.983]                 do.call(function(...) {
[17:59:30.983]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.983]                   if (!identical(...future.globals.maxSize.org, 
[17:59:30.983]                     ...future.globals.maxSize)) {
[17:59:30.983]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.983]                     on.exit(options(oopts), add = TRUE)
[17:59:30.983]                   }
[17:59:30.983]                   {
[17:59:30.983]                     lapply(seq_along(...future.elements_ii), 
[17:59:30.983]                       FUN = function(jj) {
[17:59:30.983]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.983]                         ...future.FUN(...future.X_jj, ...)
[17:59:30.983]                       })
[17:59:30.983]                   }
[17:59:30.983]                 }, args = future.call.arguments)
[17:59:30.983]             }))
[17:59:30.983]             future::FutureResult(value = ...future.value$value, 
[17:59:30.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.983]                   ...future.rng), globalenv = if (FALSE) 
[17:59:30.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:30.983]                     ...future.globalenv.names))
[17:59:30.983]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:30.983]         }, condition = base::local({
[17:59:30.983]             c <- base::c
[17:59:30.983]             inherits <- base::inherits
[17:59:30.983]             invokeRestart <- base::invokeRestart
[17:59:30.983]             length <- base::length
[17:59:30.983]             list <- base::list
[17:59:30.983]             seq.int <- base::seq.int
[17:59:30.983]             signalCondition <- base::signalCondition
[17:59:30.983]             sys.calls <- base::sys.calls
[17:59:30.983]             `[[` <- base::`[[`
[17:59:30.983]             `+` <- base::`+`
[17:59:30.983]             `<<-` <- base::`<<-`
[17:59:30.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:30.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:30.983]                   3L)]
[17:59:30.983]             }
[17:59:30.983]             function(cond) {
[17:59:30.983]                 is_error <- inherits(cond, "error")
[17:59:30.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:30.983]                   NULL)
[17:59:30.983]                 if (is_error) {
[17:59:30.983]                   sessionInformation <- function() {
[17:59:30.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:30.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:30.983]                       search = base::search(), system = base::Sys.info())
[17:59:30.983]                   }
[17:59:30.983]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:30.983]                     cond$call), session = sessionInformation(), 
[17:59:30.983]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:30.983]                   signalCondition(cond)
[17:59:30.983]                 }
[17:59:30.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:30.983]                 "immediateCondition"))) {
[17:59:30.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:30.983]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:30.983]                   if (TRUE && !signal) {
[17:59:30.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.983]                     {
[17:59:30.983]                       inherits <- base::inherits
[17:59:30.983]                       invokeRestart <- base::invokeRestart
[17:59:30.983]                       is.null <- base::is.null
[17:59:30.983]                       muffled <- FALSE
[17:59:30.983]                       if (inherits(cond, "message")) {
[17:59:30.983]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.983]                         if (muffled) 
[17:59:30.983]                           invokeRestart("muffleMessage")
[17:59:30.983]                       }
[17:59:30.983]                       else if (inherits(cond, "warning")) {
[17:59:30.983]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.983]                         if (muffled) 
[17:59:30.983]                           invokeRestart("muffleWarning")
[17:59:30.983]                       }
[17:59:30.983]                       else if (inherits(cond, "condition")) {
[17:59:30.983]                         if (!is.null(pattern)) {
[17:59:30.983]                           computeRestarts <- base::computeRestarts
[17:59:30.983]                           grepl <- base::grepl
[17:59:30.983]                           restarts <- computeRestarts(cond)
[17:59:30.983]                           for (restart in restarts) {
[17:59:30.983]                             name <- restart$name
[17:59:30.983]                             if (is.null(name)) 
[17:59:30.983]                               next
[17:59:30.983]                             if (!grepl(pattern, name)) 
[17:59:30.983]                               next
[17:59:30.983]                             invokeRestart(restart)
[17:59:30.983]                             muffled <- TRUE
[17:59:30.983]                             break
[17:59:30.983]                           }
[17:59:30.983]                         }
[17:59:30.983]                       }
[17:59:30.983]                       invisible(muffled)
[17:59:30.983]                     }
[17:59:30.983]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.983]                   }
[17:59:30.983]                 }
[17:59:30.983]                 else {
[17:59:30.983]                   if (TRUE) {
[17:59:30.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.983]                     {
[17:59:30.983]                       inherits <- base::inherits
[17:59:30.983]                       invokeRestart <- base::invokeRestart
[17:59:30.983]                       is.null <- base::is.null
[17:59:30.983]                       muffled <- FALSE
[17:59:30.983]                       if (inherits(cond, "message")) {
[17:59:30.983]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.983]                         if (muffled) 
[17:59:30.983]                           invokeRestart("muffleMessage")
[17:59:30.983]                       }
[17:59:30.983]                       else if (inherits(cond, "warning")) {
[17:59:30.983]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.983]                         if (muffled) 
[17:59:30.983]                           invokeRestart("muffleWarning")
[17:59:30.983]                       }
[17:59:30.983]                       else if (inherits(cond, "condition")) {
[17:59:30.983]                         if (!is.null(pattern)) {
[17:59:30.983]                           computeRestarts <- base::computeRestarts
[17:59:30.983]                           grepl <- base::grepl
[17:59:30.983]                           restarts <- computeRestarts(cond)
[17:59:30.983]                           for (restart in restarts) {
[17:59:30.983]                             name <- restart$name
[17:59:30.983]                             if (is.null(name)) 
[17:59:30.983]                               next
[17:59:30.983]                             if (!grepl(pattern, name)) 
[17:59:30.983]                               next
[17:59:30.983]                             invokeRestart(restart)
[17:59:30.983]                             muffled <- TRUE
[17:59:30.983]                             break
[17:59:30.983]                           }
[17:59:30.983]                         }
[17:59:30.983]                       }
[17:59:30.983]                       invisible(muffled)
[17:59:30.983]                     }
[17:59:30.983]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.983]                   }
[17:59:30.983]                 }
[17:59:30.983]             }
[17:59:30.983]         }))
[17:59:30.983]     }, error = function(ex) {
[17:59:30.983]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:30.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.983]                 ...future.rng), started = ...future.startTime, 
[17:59:30.983]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:30.983]             version = "1.8"), class = "FutureResult")
[17:59:30.983]     }, finally = {
[17:59:30.983]         if (!identical(...future.workdir, getwd())) 
[17:59:30.983]             setwd(...future.workdir)
[17:59:30.983]         {
[17:59:30.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:30.983]                 ...future.oldOptions$nwarnings <- NULL
[17:59:30.983]             }
[17:59:30.983]             base::options(...future.oldOptions)
[17:59:30.983]             if (.Platform$OS.type == "windows") {
[17:59:30.983]                 old_names <- names(...future.oldEnvVars)
[17:59:30.983]                 envs <- base::Sys.getenv()
[17:59:30.983]                 names <- names(envs)
[17:59:30.983]                 common <- intersect(names, old_names)
[17:59:30.983]                 added <- setdiff(names, old_names)
[17:59:30.983]                 removed <- setdiff(old_names, names)
[17:59:30.983]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:30.983]                   envs[common]]
[17:59:30.983]                 NAMES <- toupper(changed)
[17:59:30.983]                 args <- list()
[17:59:30.983]                 for (kk in seq_along(NAMES)) {
[17:59:30.983]                   name <- changed[[kk]]
[17:59:30.983]                   NAME <- NAMES[[kk]]
[17:59:30.983]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.983]                     next
[17:59:30.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.983]                 }
[17:59:30.983]                 NAMES <- toupper(added)
[17:59:30.983]                 for (kk in seq_along(NAMES)) {
[17:59:30.983]                   name <- added[[kk]]
[17:59:30.983]                   NAME <- NAMES[[kk]]
[17:59:30.983]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.983]                     next
[17:59:30.983]                   args[[name]] <- ""
[17:59:30.983]                 }
[17:59:30.983]                 NAMES <- toupper(removed)
[17:59:30.983]                 for (kk in seq_along(NAMES)) {
[17:59:30.983]                   name <- removed[[kk]]
[17:59:30.983]                   NAME <- NAMES[[kk]]
[17:59:30.983]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.983]                     next
[17:59:30.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.983]                 }
[17:59:30.983]                 if (length(args) > 0) 
[17:59:30.983]                   base::do.call(base::Sys.setenv, args = args)
[17:59:30.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:30.983]             }
[17:59:30.983]             else {
[17:59:30.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:30.983]             }
[17:59:30.983]             {
[17:59:30.983]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:30.983]                   0L) {
[17:59:30.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:30.983]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:30.983]                   base::options(opts)
[17:59:30.983]                 }
[17:59:30.983]                 {
[17:59:30.983]                   {
[17:59:30.983]                     NULL
[17:59:30.983]                     RNGkind("Mersenne-Twister")
[17:59:30.983]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:30.983]                       inherits = FALSE)
[17:59:30.983]                   }
[17:59:30.983]                   options(future.plan = NULL)
[17:59:30.983]                   if (is.na(NA_character_)) 
[17:59:30.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:30.983]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:30.983]                     .init = FALSE)
[17:59:30.983]                 }
[17:59:30.983]             }
[17:59:30.983]         }
[17:59:30.983]     })
[17:59:30.983]     if (TRUE) {
[17:59:30.983]         base::sink(type = "output", split = FALSE)
[17:59:30.983]         if (TRUE) {
[17:59:30.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:30.983]         }
[17:59:30.983]         else {
[17:59:30.983]             ...future.result["stdout"] <- base::list(NULL)
[17:59:30.983]         }
[17:59:30.983]         base::close(...future.stdout)
[17:59:30.983]         ...future.stdout <- NULL
[17:59:30.983]     }
[17:59:30.983]     ...future.result$conditions <- ...future.conditions
[17:59:30.983]     ...future.result$finished <- base::Sys.time()
[17:59:30.983]     ...future.result
[17:59:30.983] }
[17:59:30.987] assign_globals() ...
[17:59:30.987] List of 5
[17:59:30.987]  $ ...future.FUN            :function (x, ...)  
[17:59:30.987]  $ future.call.arguments    :List of 1
[17:59:30.987]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:30.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.987]  $ ...future.elements_ii    :List of 3
[17:59:30.987]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:59:30.987]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:30.987]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:30.987]  $ ...future.seeds_ii       : NULL
[17:59:30.987]  $ ...future.globals.maxSize: NULL
[17:59:30.987]  - attr(*, "where")=List of 5
[17:59:30.987]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:30.987]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:30.987]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:30.987]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:30.987]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:30.987]  - attr(*, "resolved")= logi FALSE
[17:59:30.987]  - attr(*, "total_size")= num 1328
[17:59:30.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.987]  - attr(*, "already-done")= logi TRUE
[17:59:30.998] - copied ‘...future.FUN’ to environment
[17:59:30.998] - copied ‘future.call.arguments’ to environment
[17:59:30.999] - copied ‘...future.elements_ii’ to environment
[17:59:30.999] - copied ‘...future.seeds_ii’ to environment
[17:59:30.999] - copied ‘...future.globals.maxSize’ to environment
[17:59:30.999] assign_globals() ... done
[17:59:31.000] plan(): Setting new future strategy stack:
[17:59:31.000] List of future strategies:
[17:59:31.000] 1. sequential:
[17:59:31.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.000]    - tweaked: FALSE
[17:59:31.000]    - call: NULL
[17:59:31.001] plan(): nbrOfWorkers() = 1
[17:59:31.003] plan(): Setting new future strategy stack:
[17:59:31.004] List of future strategies:
[17:59:31.004] 1. sequential:
[17:59:31.004]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.004]    - tweaked: FALSE
[17:59:31.004]    - call: plan(strategy)
[17:59:31.004] plan(): nbrOfWorkers() = 1
[17:59:31.005] SequentialFuture started (and completed)
[17:59:31.005] - Launch lazy future ... done
[17:59:31.005] run() for ‘SequentialFuture’ ... done
[17:59:31.006] Created future:
[17:59:31.006] SequentialFuture:
[17:59:31.006] Label: ‘future_eapply-1’
[17:59:31.006] Expression:
[17:59:31.006] {
[17:59:31.006]     do.call(function(...) {
[17:59:31.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.006]             on.exit(options(oopts), add = TRUE)
[17:59:31.006]         }
[17:59:31.006]         {
[17:59:31.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.006]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.006]             })
[17:59:31.006]         }
[17:59:31.006]     }, args = future.call.arguments)
[17:59:31.006] }
[17:59:31.006] Lazy evaluation: FALSE
[17:59:31.006] Asynchronous evaluation: FALSE
[17:59:31.006] Local evaluation: TRUE
[17:59:31.006] Environment: R_GlobalEnv
[17:59:31.006] Capture standard output: TRUE
[17:59:31.006] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.006] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.006] Packages: 1 packages (‘stats’)
[17:59:31.006] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.006] Resolved: TRUE
[17:59:31.006] Value: 1.29 KiB of class ‘list’
[17:59:31.006] Early signaling: FALSE
[17:59:31.006] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.006] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:31.008] Chunk #1 of 1 ... DONE
[17:59:31.008] Launching 1 futures (chunks) ... DONE
[17:59:31.008] Resolving 1 futures (chunks) ...
[17:59:31.008] resolve() on list ...
[17:59:31.008]  recursive: 0
[17:59:31.009]  length: 1
[17:59:31.009] 
[17:59:31.009] resolved() for ‘SequentialFuture’ ...
[17:59:31.009] - state: ‘finished’
[17:59:31.009] - run: TRUE
[17:59:31.010] - result: ‘FutureResult’
[17:59:31.010] resolved() for ‘SequentialFuture’ ... done
[17:59:31.010] Future #1
[17:59:31.010] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:31.011] - nx: 1
[17:59:31.011] - relay: TRUE
[17:59:31.011] - stdout: TRUE
[17:59:31.011] - signal: TRUE
[17:59:31.011] - resignal: FALSE
[17:59:31.011] - force: TRUE
[17:59:31.012] - relayed: [n=1] FALSE
[17:59:31.012] - queued futures: [n=1] FALSE
[17:59:31.012]  - until=1
[17:59:31.012]  - relaying element #1
[17:59:31.013] - relayed: [n=1] TRUE
[17:59:31.013] - queued futures: [n=1] TRUE
[17:59:31.013] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:31.013]  length: 0 (resolved future 1)
[17:59:31.013] Relaying remaining futures
[17:59:31.014] signalConditionsASAP(NULL, pos=0) ...
[17:59:31.014] - nx: 1
[17:59:31.014] - relay: TRUE
[17:59:31.014] - stdout: TRUE
[17:59:31.014] - signal: TRUE
[17:59:31.014] - resignal: FALSE
[17:59:31.015] - force: TRUE
[17:59:31.015] - relayed: [n=1] TRUE
[17:59:31.015] - queued futures: [n=1] TRUE
 - flush all
[17:59:31.015] - relayed: [n=1] TRUE
[17:59:31.015] - queued futures: [n=1] TRUE
[17:59:31.016] signalConditionsASAP(NULL, pos=0) ... done
[17:59:31.016] resolve() on list ... DONE
[17:59:31.016]  - Number of value chunks collected: 1
[17:59:31.016] Resolving 1 futures (chunks) ... DONE
[17:59:31.016] Reducing values from 1 chunks ...
[17:59:31.017]  - Number of values collected after concatenation: 3
[17:59:31.017]  - Number of values expected: 3
[17:59:31.017] Reducing values from 1 chunks ... DONE
[17:59:31.017] future_lapply() ... DONE
[17:59:31.019] future_lapply() ...
[17:59:31.021] Number of chunks: 1
[17:59:31.021] getGlobalsAndPackagesXApply() ...
[17:59:31.021]  - future.globals: TRUE
[17:59:31.021] getGlobalsAndPackages() ...
[17:59:31.021] Searching for globals...
[17:59:31.023] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:31.024] Searching for globals ... DONE
[17:59:31.024] Resolving globals: FALSE
[17:59:31.027] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:31.027] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:31.028] - globals: [1] ‘FUN’
[17:59:31.028] - packages: [1] ‘stats’
[17:59:31.028] getGlobalsAndPackages() ... DONE
[17:59:31.028]  - globals found/used: [n=1] ‘FUN’
[17:59:31.029]  - needed namespaces: [n=1] ‘stats’
[17:59:31.029] Finding globals ... DONE
[17:59:31.029]  - use_args: TRUE
[17:59:31.029]  - Getting '...' globals ...
[17:59:31.030] resolve() on list ...
[17:59:31.030]  recursive: 0
[17:59:31.030]  length: 1
[17:59:31.030]  elements: ‘...’
[17:59:31.031]  length: 0 (resolved future 1)
[17:59:31.031] resolve() on list ... DONE
[17:59:31.031]    - '...' content: [n=0] 
[17:59:31.031] List of 1
[17:59:31.031]  $ ...: list()
[17:59:31.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.031]  - attr(*, "where")=List of 1
[17:59:31.031]   ..$ ...:<environment: 0x58d4c4ddc240> 
[17:59:31.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.031]  - attr(*, "resolved")= logi TRUE
[17:59:31.031]  - attr(*, "total_size")= num NA
[17:59:31.036]  - Getting '...' globals ... DONE
[17:59:31.036] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:31.037] List of 2
[17:59:31.037]  $ ...future.FUN:function (x, ...)  
[17:59:31.037]  $ ...          : list()
[17:59:31.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.037]  - attr(*, "where")=List of 2
[17:59:31.037]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:31.037]   ..$ ...          :<environment: 0x58d4c4ddc240> 
[17:59:31.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.037]  - attr(*, "resolved")= logi FALSE
[17:59:31.037]  - attr(*, "total_size")= num 1248
[17:59:31.042] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:31.043] getGlobalsAndPackagesXApply() ... DONE
[17:59:31.043] Number of futures (= number of chunks): 1
[17:59:31.043] Launching 1 futures (chunks) ...
[17:59:31.044] Chunk #1 of 1 ...
[17:59:31.044]  - Finding globals in 'X' for chunk #1 ...
[17:59:31.044] getGlobalsAndPackages() ...
[17:59:31.044] Searching for globals...
[17:59:31.045] 
[17:59:31.045] Searching for globals ... DONE
[17:59:31.045] - globals: [0] <none>
[17:59:31.046] getGlobalsAndPackages() ... DONE
[17:59:31.046]    + additional globals found: [n=0] 
[17:59:31.046]    + additional namespaces needed: [n=0] 
[17:59:31.046]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:31.046]  - seeds: <none>
[17:59:31.046]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.047] getGlobalsAndPackages() ...
[17:59:31.047] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.047] Resolving globals: FALSE
[17:59:31.047] Tweak future expression to call with '...' arguments ...
[17:59:31.048] {
[17:59:31.048]     do.call(function(...) {
[17:59:31.048]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.048]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.048]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.048]             on.exit(options(oopts), add = TRUE)
[17:59:31.048]         }
[17:59:31.048]         {
[17:59:31.048]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.048]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.048]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.048]             })
[17:59:31.048]         }
[17:59:31.048]     }, args = future.call.arguments)
[17:59:31.048] }
[17:59:31.048] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.049] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.050] - packages: [1] ‘stats’
[17:59:31.050] getGlobalsAndPackages() ... DONE
[17:59:31.050] run() for ‘Future’ ...
[17:59:31.051] - state: ‘created’
[17:59:31.051] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:31.051] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:31.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:31.052]   - Field: ‘label’
[17:59:31.052]   - Field: ‘local’
[17:59:31.052]   - Field: ‘owner’
[17:59:31.053]   - Field: ‘envir’
[17:59:31.053]   - Field: ‘packages’
[17:59:31.053]   - Field: ‘gc’
[17:59:31.053]   - Field: ‘conditions’
[17:59:31.053]   - Field: ‘expr’
[17:59:31.054]   - Field: ‘uuid’
[17:59:31.054]   - Field: ‘seed’
[17:59:31.054]   - Field: ‘version’
[17:59:31.054]   - Field: ‘result’
[17:59:31.054]   - Field: ‘asynchronous’
[17:59:31.054]   - Field: ‘calls’
[17:59:31.055]   - Field: ‘globals’
[17:59:31.055]   - Field: ‘stdout’
[17:59:31.055]   - Field: ‘earlySignal’
[17:59:31.055]   - Field: ‘lazy’
[17:59:31.055]   - Field: ‘state’
[17:59:31.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:31.056] - Launch lazy future ...
[17:59:31.056] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.057] Packages needed by future strategies (n = 0): <none>
[17:59:31.058] {
[17:59:31.058]     {
[17:59:31.058]         {
[17:59:31.058]             ...future.startTime <- base::Sys.time()
[17:59:31.058]             {
[17:59:31.058]                 {
[17:59:31.058]                   {
[17:59:31.058]                     {
[17:59:31.058]                       base::local({
[17:59:31.058]                         has_future <- base::requireNamespace("future", 
[17:59:31.058]                           quietly = TRUE)
[17:59:31.058]                         if (has_future) {
[17:59:31.058]                           ns <- base::getNamespace("future")
[17:59:31.058]                           version <- ns[[".package"]][["version"]]
[17:59:31.058]                           if (is.null(version)) 
[17:59:31.058]                             version <- utils::packageVersion("future")
[17:59:31.058]                         }
[17:59:31.058]                         else {
[17:59:31.058]                           version <- NULL
[17:59:31.058]                         }
[17:59:31.058]                         if (!has_future || version < "1.8.0") {
[17:59:31.058]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.058]                             "", base::R.version$version.string), 
[17:59:31.058]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:31.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:31.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.058]                               "release", "version")], collapse = " "), 
[17:59:31.058]                             hostname = base::Sys.info()[["nodename"]])
[17:59:31.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.058]                             info)
[17:59:31.058]                           info <- base::paste(info, collapse = "; ")
[17:59:31.058]                           if (!has_future) {
[17:59:31.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.058]                               info)
[17:59:31.058]                           }
[17:59:31.058]                           else {
[17:59:31.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.058]                               info, version)
[17:59:31.058]                           }
[17:59:31.058]                           base::stop(msg)
[17:59:31.058]                         }
[17:59:31.058]                       })
[17:59:31.058]                     }
[17:59:31.058]                     base::local({
[17:59:31.058]                       for (pkg in "stats") {
[17:59:31.058]                         base::loadNamespace(pkg)
[17:59:31.058]                         base::library(pkg, character.only = TRUE)
[17:59:31.058]                       }
[17:59:31.058]                     })
[17:59:31.058]                   }
[17:59:31.058]                   ...future.strategy.old <- future::plan("list")
[17:59:31.058]                   options(future.plan = NULL)
[17:59:31.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.058]                 }
[17:59:31.058]                 ...future.workdir <- getwd()
[17:59:31.058]             }
[17:59:31.058]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.058]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.058]         }
[17:59:31.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:31.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.058]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.058]             base::names(...future.oldOptions))
[17:59:31.058]     }
[17:59:31.058]     if (FALSE) {
[17:59:31.058]     }
[17:59:31.058]     else {
[17:59:31.058]         if (TRUE) {
[17:59:31.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.058]                 open = "w")
[17:59:31.058]         }
[17:59:31.058]         else {
[17:59:31.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.058]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.058]         }
[17:59:31.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.058]             base::sink(type = "output", split = FALSE)
[17:59:31.058]             base::close(...future.stdout)
[17:59:31.058]         }, add = TRUE)
[17:59:31.058]     }
[17:59:31.058]     ...future.frame <- base::sys.nframe()
[17:59:31.058]     ...future.conditions <- base::list()
[17:59:31.058]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.058]     if (FALSE) {
[17:59:31.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.058]     }
[17:59:31.058]     ...future.result <- base::tryCatch({
[17:59:31.058]         base::withCallingHandlers({
[17:59:31.058]             ...future.value <- base::withVisible(base::local({
[17:59:31.058]                 do.call(function(...) {
[17:59:31.058]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.058]                   if (!identical(...future.globals.maxSize.org, 
[17:59:31.058]                     ...future.globals.maxSize)) {
[17:59:31.058]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.058]                     on.exit(options(oopts), add = TRUE)
[17:59:31.058]                   }
[17:59:31.058]                   {
[17:59:31.058]                     lapply(seq_along(...future.elements_ii), 
[17:59:31.058]                       FUN = function(jj) {
[17:59:31.058]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.058]                         ...future.FUN(...future.X_jj, ...)
[17:59:31.058]                       })
[17:59:31.058]                   }
[17:59:31.058]                 }, args = future.call.arguments)
[17:59:31.058]             }))
[17:59:31.058]             future::FutureResult(value = ...future.value$value, 
[17:59:31.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.058]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.058]                     ...future.globalenv.names))
[17:59:31.058]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.058]         }, condition = base::local({
[17:59:31.058]             c <- base::c
[17:59:31.058]             inherits <- base::inherits
[17:59:31.058]             invokeRestart <- base::invokeRestart
[17:59:31.058]             length <- base::length
[17:59:31.058]             list <- base::list
[17:59:31.058]             seq.int <- base::seq.int
[17:59:31.058]             signalCondition <- base::signalCondition
[17:59:31.058]             sys.calls <- base::sys.calls
[17:59:31.058]             `[[` <- base::`[[`
[17:59:31.058]             `+` <- base::`+`
[17:59:31.058]             `<<-` <- base::`<<-`
[17:59:31.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.058]                   3L)]
[17:59:31.058]             }
[17:59:31.058]             function(cond) {
[17:59:31.058]                 is_error <- inherits(cond, "error")
[17:59:31.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.058]                   NULL)
[17:59:31.058]                 if (is_error) {
[17:59:31.058]                   sessionInformation <- function() {
[17:59:31.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.058]                       search = base::search(), system = base::Sys.info())
[17:59:31.058]                   }
[17:59:31.058]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.058]                     cond$call), session = sessionInformation(), 
[17:59:31.058]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.058]                   signalCondition(cond)
[17:59:31.058]                 }
[17:59:31.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.058]                 "immediateCondition"))) {
[17:59:31.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.058]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.058]                   if (TRUE && !signal) {
[17:59:31.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.058]                     {
[17:59:31.058]                       inherits <- base::inherits
[17:59:31.058]                       invokeRestart <- base::invokeRestart
[17:59:31.058]                       is.null <- base::is.null
[17:59:31.058]                       muffled <- FALSE
[17:59:31.058]                       if (inherits(cond, "message")) {
[17:59:31.058]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.058]                         if (muffled) 
[17:59:31.058]                           invokeRestart("muffleMessage")
[17:59:31.058]                       }
[17:59:31.058]                       else if (inherits(cond, "warning")) {
[17:59:31.058]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.058]                         if (muffled) 
[17:59:31.058]                           invokeRestart("muffleWarning")
[17:59:31.058]                       }
[17:59:31.058]                       else if (inherits(cond, "condition")) {
[17:59:31.058]                         if (!is.null(pattern)) {
[17:59:31.058]                           computeRestarts <- base::computeRestarts
[17:59:31.058]                           grepl <- base::grepl
[17:59:31.058]                           restarts <- computeRestarts(cond)
[17:59:31.058]                           for (restart in restarts) {
[17:59:31.058]                             name <- restart$name
[17:59:31.058]                             if (is.null(name)) 
[17:59:31.058]                               next
[17:59:31.058]                             if (!grepl(pattern, name)) 
[17:59:31.058]                               next
[17:59:31.058]                             invokeRestart(restart)
[17:59:31.058]                             muffled <- TRUE
[17:59:31.058]                             break
[17:59:31.058]                           }
[17:59:31.058]                         }
[17:59:31.058]                       }
[17:59:31.058]                       invisible(muffled)
[17:59:31.058]                     }
[17:59:31.058]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.058]                   }
[17:59:31.058]                 }
[17:59:31.058]                 else {
[17:59:31.058]                   if (TRUE) {
[17:59:31.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.058]                     {
[17:59:31.058]                       inherits <- base::inherits
[17:59:31.058]                       invokeRestart <- base::invokeRestart
[17:59:31.058]                       is.null <- base::is.null
[17:59:31.058]                       muffled <- FALSE
[17:59:31.058]                       if (inherits(cond, "message")) {
[17:59:31.058]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.058]                         if (muffled) 
[17:59:31.058]                           invokeRestart("muffleMessage")
[17:59:31.058]                       }
[17:59:31.058]                       else if (inherits(cond, "warning")) {
[17:59:31.058]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.058]                         if (muffled) 
[17:59:31.058]                           invokeRestart("muffleWarning")
[17:59:31.058]                       }
[17:59:31.058]                       else if (inherits(cond, "condition")) {
[17:59:31.058]                         if (!is.null(pattern)) {
[17:59:31.058]                           computeRestarts <- base::computeRestarts
[17:59:31.058]                           grepl <- base::grepl
[17:59:31.058]                           restarts <- computeRestarts(cond)
[17:59:31.058]                           for (restart in restarts) {
[17:59:31.058]                             name <- restart$name
[17:59:31.058]                             if (is.null(name)) 
[17:59:31.058]                               next
[17:59:31.058]                             if (!grepl(pattern, name)) 
[17:59:31.058]                               next
[17:59:31.058]                             invokeRestart(restart)
[17:59:31.058]                             muffled <- TRUE
[17:59:31.058]                             break
[17:59:31.058]                           }
[17:59:31.058]                         }
[17:59:31.058]                       }
[17:59:31.058]                       invisible(muffled)
[17:59:31.058]                     }
[17:59:31.058]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.058]                   }
[17:59:31.058]                 }
[17:59:31.058]             }
[17:59:31.058]         }))
[17:59:31.058]     }, error = function(ex) {
[17:59:31.058]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.058]                 ...future.rng), started = ...future.startTime, 
[17:59:31.058]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.058]             version = "1.8"), class = "FutureResult")
[17:59:31.058]     }, finally = {
[17:59:31.058]         if (!identical(...future.workdir, getwd())) 
[17:59:31.058]             setwd(...future.workdir)
[17:59:31.058]         {
[17:59:31.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.058]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.058]             }
[17:59:31.058]             base::options(...future.oldOptions)
[17:59:31.058]             if (.Platform$OS.type == "windows") {
[17:59:31.058]                 old_names <- names(...future.oldEnvVars)
[17:59:31.058]                 envs <- base::Sys.getenv()
[17:59:31.058]                 names <- names(envs)
[17:59:31.058]                 common <- intersect(names, old_names)
[17:59:31.058]                 added <- setdiff(names, old_names)
[17:59:31.058]                 removed <- setdiff(old_names, names)
[17:59:31.058]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.058]                   envs[common]]
[17:59:31.058]                 NAMES <- toupper(changed)
[17:59:31.058]                 args <- list()
[17:59:31.058]                 for (kk in seq_along(NAMES)) {
[17:59:31.058]                   name <- changed[[kk]]
[17:59:31.058]                   NAME <- NAMES[[kk]]
[17:59:31.058]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.058]                     next
[17:59:31.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.058]                 }
[17:59:31.058]                 NAMES <- toupper(added)
[17:59:31.058]                 for (kk in seq_along(NAMES)) {
[17:59:31.058]                   name <- added[[kk]]
[17:59:31.058]                   NAME <- NAMES[[kk]]
[17:59:31.058]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.058]                     next
[17:59:31.058]                   args[[name]] <- ""
[17:59:31.058]                 }
[17:59:31.058]                 NAMES <- toupper(removed)
[17:59:31.058]                 for (kk in seq_along(NAMES)) {
[17:59:31.058]                   name <- removed[[kk]]
[17:59:31.058]                   NAME <- NAMES[[kk]]
[17:59:31.058]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.058]                     next
[17:59:31.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.058]                 }
[17:59:31.058]                 if (length(args) > 0) 
[17:59:31.058]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.058]             }
[17:59:31.058]             else {
[17:59:31.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.058]             }
[17:59:31.058]             {
[17:59:31.058]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.058]                   0L) {
[17:59:31.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.058]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.058]                   base::options(opts)
[17:59:31.058]                 }
[17:59:31.058]                 {
[17:59:31.058]                   {
[17:59:31.058]                     NULL
[17:59:31.058]                     RNGkind("Mersenne-Twister")
[17:59:31.058]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:31.058]                       inherits = FALSE)
[17:59:31.058]                   }
[17:59:31.058]                   options(future.plan = NULL)
[17:59:31.058]                   if (is.na(NA_character_)) 
[17:59:31.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.058]                     .init = FALSE)
[17:59:31.058]                 }
[17:59:31.058]             }
[17:59:31.058]         }
[17:59:31.058]     })
[17:59:31.058]     if (TRUE) {
[17:59:31.058]         base::sink(type = "output", split = FALSE)
[17:59:31.058]         if (TRUE) {
[17:59:31.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.058]         }
[17:59:31.058]         else {
[17:59:31.058]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.058]         }
[17:59:31.058]         base::close(...future.stdout)
[17:59:31.058]         ...future.stdout <- NULL
[17:59:31.058]     }
[17:59:31.058]     ...future.result$conditions <- ...future.conditions
[17:59:31.058]     ...future.result$finished <- base::Sys.time()
[17:59:31.058]     ...future.result
[17:59:31.058] }
[17:59:31.061] assign_globals() ...
[17:59:31.061] List of 5
[17:59:31.061]  $ ...future.FUN            :function (x, ...)  
[17:59:31.061]  $ future.call.arguments    : list()
[17:59:31.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.061]  $ ...future.elements_ii    :List of 3
[17:59:31.061]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:59:31.061]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:31.061]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:31.061]  $ ...future.seeds_ii       : NULL
[17:59:31.061]  $ ...future.globals.maxSize: NULL
[17:59:31.061]  - attr(*, "where")=List of 5
[17:59:31.061]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.061]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.061]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.061]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.061]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.061]  - attr(*, "resolved")= logi FALSE
[17:59:31.061]  - attr(*, "total_size")= num 1248
[17:59:31.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.061]  - attr(*, "already-done")= logi TRUE
[17:59:31.073] - copied ‘...future.FUN’ to environment
[17:59:31.073] - copied ‘future.call.arguments’ to environment
[17:59:31.074] - copied ‘...future.elements_ii’ to environment
[17:59:31.074] - copied ‘...future.seeds_ii’ to environment
[17:59:31.074] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.074] assign_globals() ... done
[17:59:31.075] plan(): Setting new future strategy stack:
[17:59:31.075] List of future strategies:
[17:59:31.075] 1. sequential:
[17:59:31.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.075]    - tweaked: FALSE
[17:59:31.075]    - call: NULL
[17:59:31.076] plan(): nbrOfWorkers() = 1
[17:59:31.078] plan(): Setting new future strategy stack:
[17:59:31.079] List of future strategies:
[17:59:31.079] 1. sequential:
[17:59:31.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.079]    - tweaked: FALSE
[17:59:31.079]    - call: plan(strategy)
[17:59:31.079] plan(): nbrOfWorkers() = 1
[17:59:31.082] SequentialFuture started (and completed)
[17:59:31.082] - Launch lazy future ... done
[17:59:31.083] run() for ‘SequentialFuture’ ... done
[17:59:31.083] Created future:
[17:59:31.083] SequentialFuture:
[17:59:31.083] Label: ‘future_eapply-1’
[17:59:31.083] Expression:
[17:59:31.083] {
[17:59:31.083]     do.call(function(...) {
[17:59:31.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.083]             on.exit(options(oopts), add = TRUE)
[17:59:31.083]         }
[17:59:31.083]         {
[17:59:31.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.083]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.083]             })
[17:59:31.083]         }
[17:59:31.083]     }, args = future.call.arguments)
[17:59:31.083] }
[17:59:31.083] Lazy evaluation: FALSE
[17:59:31.083] Asynchronous evaluation: FALSE
[17:59:31.083] Local evaluation: TRUE
[17:59:31.083] Environment: R_GlobalEnv
[17:59:31.083] Capture standard output: TRUE
[17:59:31.083] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.083] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.083] Packages: 1 packages (‘stats’)
[17:59:31.083] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.083] Resolved: TRUE
[17:59:31.083] Value: 1.71 KiB of class ‘list’
[17:59:31.083] Early signaling: FALSE
[17:59:31.083] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.083] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:31.085] Chunk #1 of 1 ... DONE
[17:59:31.086] Launching 1 futures (chunks) ... DONE
[17:59:31.086] Resolving 1 futures (chunks) ...
[17:59:31.086] resolve() on list ...
[17:59:31.086]  recursive: 0
[17:59:31.086]  length: 1
[17:59:31.087] 
[17:59:31.087] resolved() for ‘SequentialFuture’ ...
[17:59:31.087] - state: ‘finished’
[17:59:31.087] - run: TRUE
[17:59:31.087] - result: ‘FutureResult’
[17:59:31.088] resolved() for ‘SequentialFuture’ ... done
[17:59:31.088] Future #1
[17:59:31.088] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:31.088] - nx: 1
[17:59:31.088] - relay: TRUE
[17:59:31.089] - stdout: TRUE
[17:59:31.089] - signal: TRUE
[17:59:31.089] - resignal: FALSE
[17:59:31.089] - force: TRUE
[17:59:31.089] - relayed: [n=1] FALSE
[17:59:31.089] - queued futures: [n=1] FALSE
[17:59:31.090]  - until=1
[17:59:31.090]  - relaying element #1
[17:59:31.090] - relayed: [n=1] TRUE
[17:59:31.090] - queued futures: [n=1] TRUE
[17:59:31.091] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:31.091]  length: 0 (resolved future 1)
[17:59:31.091] Relaying remaining futures
[17:59:31.091] signalConditionsASAP(NULL, pos=0) ...
[17:59:31.091] - nx: 1
[17:59:31.091] - relay: TRUE
[17:59:31.092] - stdout: TRUE
[17:59:31.092] - signal: TRUE
[17:59:31.092] - resignal: FALSE
[17:59:31.092] - force: TRUE
[17:59:31.092] - relayed: [n=1] TRUE
[17:59:31.092] - queued futures: [n=1] TRUE
 - flush all
[17:59:31.093] - relayed: [n=1] TRUE
[17:59:31.093] - queued futures: [n=1] TRUE
[17:59:31.093] signalConditionsASAP(NULL, pos=0) ... done
[17:59:31.093] resolve() on list ... DONE
[17:59:31.094]  - Number of value chunks collected: 1
[17:59:31.094] Resolving 1 futures (chunks) ... DONE
[17:59:31.094] Reducing values from 1 chunks ...
[17:59:31.094]  - Number of values collected after concatenation: 3
[17:59:31.094]  - Number of values expected: 3
[17:59:31.095] Reducing values from 1 chunks ... DONE
[17:59:31.095] future_lapply() ... DONE
[17:59:31.095] future_lapply() ...
[17:59:31.096] Number of chunks: 1
[17:59:31.096] getGlobalsAndPackagesXApply() ...
[17:59:31.097]  - future.globals: TRUE
[17:59:31.097] getGlobalsAndPackages() ...
[17:59:31.097] Searching for globals...
[17:59:31.099] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:31.099] Searching for globals ... DONE
[17:59:31.099] Resolving globals: FALSE
[17:59:31.100] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:31.101] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:31.101] - globals: [1] ‘FUN’
[17:59:31.101] - packages: [1] ‘stats’
[17:59:31.101] getGlobalsAndPackages() ... DONE
[17:59:31.102]  - globals found/used: [n=1] ‘FUN’
[17:59:31.102]  - needed namespaces: [n=1] ‘stats’
[17:59:31.102] Finding globals ... DONE
[17:59:31.102]  - use_args: TRUE
[17:59:31.102]  - Getting '...' globals ...
[17:59:31.103] resolve() on list ...
[17:59:31.103]  recursive: 0
[17:59:31.103]  length: 1
[17:59:31.104]  elements: ‘...’
[17:59:31.104]  length: 0 (resolved future 1)
[17:59:31.104] resolve() on list ... DONE
[17:59:31.104]    - '...' content: [n=0] 
[17:59:31.104] List of 1
[17:59:31.104]  $ ...: list()
[17:59:31.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.104]  - attr(*, "where")=List of 1
[17:59:31.104]   ..$ ...:<environment: 0x58d4c3b0cac0> 
[17:59:31.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.104]  - attr(*, "resolved")= logi TRUE
[17:59:31.104]  - attr(*, "total_size")= num NA
[17:59:31.109]  - Getting '...' globals ... DONE
[17:59:31.110] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:31.110] List of 2
[17:59:31.110]  $ ...future.FUN:function (x, ...)  
[17:59:31.110]  $ ...          : list()
[17:59:31.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.110]  - attr(*, "where")=List of 2
[17:59:31.110]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:31.110]   ..$ ...          :<environment: 0x58d4c3b0cac0> 
[17:59:31.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.110]  - attr(*, "resolved")= logi FALSE
[17:59:31.110]  - attr(*, "total_size")= num 1248
[17:59:31.115] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:31.115] getGlobalsAndPackagesXApply() ... DONE
[17:59:31.116] Number of futures (= number of chunks): 1
[17:59:31.116] Launching 1 futures (chunks) ...
[17:59:31.116] Chunk #1 of 1 ...
[17:59:31.116]  - Finding globals in 'X' for chunk #1 ...
[17:59:31.117] getGlobalsAndPackages() ...
[17:59:31.117] Searching for globals...
[17:59:31.117] 
[17:59:31.118] Searching for globals ... DONE
[17:59:31.118] - globals: [0] <none>
[17:59:31.118] getGlobalsAndPackages() ... DONE
[17:59:31.118]    + additional globals found: [n=0] 
[17:59:31.118]    + additional namespaces needed: [n=0] 
[17:59:31.119]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:31.119]  - seeds: <none>
[17:59:31.119]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.119] getGlobalsAndPackages() ...
[17:59:31.119] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.120] Resolving globals: FALSE
[17:59:31.120] Tweak future expression to call with '...' arguments ...
[17:59:31.120] {
[17:59:31.120]     do.call(function(...) {
[17:59:31.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.120]             on.exit(options(oopts), add = TRUE)
[17:59:31.120]         }
[17:59:31.120]         {
[17:59:31.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.120]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.120]             })
[17:59:31.120]         }
[17:59:31.120]     }, args = future.call.arguments)
[17:59:31.120] }
[17:59:31.121] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.121] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.122] - packages: [1] ‘stats’
[17:59:31.122] getGlobalsAndPackages() ... DONE
[17:59:31.122] run() for ‘Future’ ...
[17:59:31.123] - state: ‘created’
[17:59:31.123] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:31.124] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:31.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:31.124]   - Field: ‘label’
[17:59:31.124]   - Field: ‘local’
[17:59:31.124]   - Field: ‘owner’
[17:59:31.125]   - Field: ‘envir’
[17:59:31.125]   - Field: ‘packages’
[17:59:31.125]   - Field: ‘gc’
[17:59:31.125]   - Field: ‘conditions’
[17:59:31.125]   - Field: ‘expr’
[17:59:31.126]   - Field: ‘uuid’
[17:59:31.126]   - Field: ‘seed’
[17:59:31.126]   - Field: ‘version’
[17:59:31.126]   - Field: ‘result’
[17:59:31.126]   - Field: ‘asynchronous’
[17:59:31.127]   - Field: ‘calls’
[17:59:31.127]   - Field: ‘globals’
[17:59:31.127]   - Field: ‘stdout’
[17:59:31.127]   - Field: ‘earlySignal’
[17:59:31.127]   - Field: ‘lazy’
[17:59:31.128]   - Field: ‘state’
[17:59:31.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:31.128] - Launch lazy future ...
[17:59:31.128] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.129] Packages needed by future strategies (n = 0): <none>
[17:59:31.130] {
[17:59:31.130]     {
[17:59:31.130]         {
[17:59:31.130]             ...future.startTime <- base::Sys.time()
[17:59:31.130]             {
[17:59:31.130]                 {
[17:59:31.130]                   {
[17:59:31.130]                     {
[17:59:31.130]                       base::local({
[17:59:31.130]                         has_future <- base::requireNamespace("future", 
[17:59:31.130]                           quietly = TRUE)
[17:59:31.130]                         if (has_future) {
[17:59:31.130]                           ns <- base::getNamespace("future")
[17:59:31.130]                           version <- ns[[".package"]][["version"]]
[17:59:31.130]                           if (is.null(version)) 
[17:59:31.130]                             version <- utils::packageVersion("future")
[17:59:31.130]                         }
[17:59:31.130]                         else {
[17:59:31.130]                           version <- NULL
[17:59:31.130]                         }
[17:59:31.130]                         if (!has_future || version < "1.8.0") {
[17:59:31.130]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.130]                             "", base::R.version$version.string), 
[17:59:31.130]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:31.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:31.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.130]                               "release", "version")], collapse = " "), 
[17:59:31.130]                             hostname = base::Sys.info()[["nodename"]])
[17:59:31.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.130]                             info)
[17:59:31.130]                           info <- base::paste(info, collapse = "; ")
[17:59:31.130]                           if (!has_future) {
[17:59:31.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.130]                               info)
[17:59:31.130]                           }
[17:59:31.130]                           else {
[17:59:31.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.130]                               info, version)
[17:59:31.130]                           }
[17:59:31.130]                           base::stop(msg)
[17:59:31.130]                         }
[17:59:31.130]                       })
[17:59:31.130]                     }
[17:59:31.130]                     base::local({
[17:59:31.130]                       for (pkg in "stats") {
[17:59:31.130]                         base::loadNamespace(pkg)
[17:59:31.130]                         base::library(pkg, character.only = TRUE)
[17:59:31.130]                       }
[17:59:31.130]                     })
[17:59:31.130]                   }
[17:59:31.130]                   ...future.strategy.old <- future::plan("list")
[17:59:31.130]                   options(future.plan = NULL)
[17:59:31.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.130]                 }
[17:59:31.130]                 ...future.workdir <- getwd()
[17:59:31.130]             }
[17:59:31.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.130]         }
[17:59:31.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:31.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.130]             base::names(...future.oldOptions))
[17:59:31.130]     }
[17:59:31.130]     if (FALSE) {
[17:59:31.130]     }
[17:59:31.130]     else {
[17:59:31.130]         if (TRUE) {
[17:59:31.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.130]                 open = "w")
[17:59:31.130]         }
[17:59:31.130]         else {
[17:59:31.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.130]         }
[17:59:31.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.130]             base::sink(type = "output", split = FALSE)
[17:59:31.130]             base::close(...future.stdout)
[17:59:31.130]         }, add = TRUE)
[17:59:31.130]     }
[17:59:31.130]     ...future.frame <- base::sys.nframe()
[17:59:31.130]     ...future.conditions <- base::list()
[17:59:31.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.130]     if (FALSE) {
[17:59:31.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.130]     }
[17:59:31.130]     ...future.result <- base::tryCatch({
[17:59:31.130]         base::withCallingHandlers({
[17:59:31.130]             ...future.value <- base::withVisible(base::local({
[17:59:31.130]                 do.call(function(...) {
[17:59:31.130]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.130]                   if (!identical(...future.globals.maxSize.org, 
[17:59:31.130]                     ...future.globals.maxSize)) {
[17:59:31.130]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.130]                     on.exit(options(oopts), add = TRUE)
[17:59:31.130]                   }
[17:59:31.130]                   {
[17:59:31.130]                     lapply(seq_along(...future.elements_ii), 
[17:59:31.130]                       FUN = function(jj) {
[17:59:31.130]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.130]                         ...future.FUN(...future.X_jj, ...)
[17:59:31.130]                       })
[17:59:31.130]                   }
[17:59:31.130]                 }, args = future.call.arguments)
[17:59:31.130]             }))
[17:59:31.130]             future::FutureResult(value = ...future.value$value, 
[17:59:31.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.130]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.130]                     ...future.globalenv.names))
[17:59:31.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.130]         }, condition = base::local({
[17:59:31.130]             c <- base::c
[17:59:31.130]             inherits <- base::inherits
[17:59:31.130]             invokeRestart <- base::invokeRestart
[17:59:31.130]             length <- base::length
[17:59:31.130]             list <- base::list
[17:59:31.130]             seq.int <- base::seq.int
[17:59:31.130]             signalCondition <- base::signalCondition
[17:59:31.130]             sys.calls <- base::sys.calls
[17:59:31.130]             `[[` <- base::`[[`
[17:59:31.130]             `+` <- base::`+`
[17:59:31.130]             `<<-` <- base::`<<-`
[17:59:31.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.130]                   3L)]
[17:59:31.130]             }
[17:59:31.130]             function(cond) {
[17:59:31.130]                 is_error <- inherits(cond, "error")
[17:59:31.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.130]                   NULL)
[17:59:31.130]                 if (is_error) {
[17:59:31.130]                   sessionInformation <- function() {
[17:59:31.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.130]                       search = base::search(), system = base::Sys.info())
[17:59:31.130]                   }
[17:59:31.130]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.130]                     cond$call), session = sessionInformation(), 
[17:59:31.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.130]                   signalCondition(cond)
[17:59:31.130]                 }
[17:59:31.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.130]                 "immediateCondition"))) {
[17:59:31.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.130]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.130]                   if (TRUE && !signal) {
[17:59:31.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.130]                     {
[17:59:31.130]                       inherits <- base::inherits
[17:59:31.130]                       invokeRestart <- base::invokeRestart
[17:59:31.130]                       is.null <- base::is.null
[17:59:31.130]                       muffled <- FALSE
[17:59:31.130]                       if (inherits(cond, "message")) {
[17:59:31.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.130]                         if (muffled) 
[17:59:31.130]                           invokeRestart("muffleMessage")
[17:59:31.130]                       }
[17:59:31.130]                       else if (inherits(cond, "warning")) {
[17:59:31.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.130]                         if (muffled) 
[17:59:31.130]                           invokeRestart("muffleWarning")
[17:59:31.130]                       }
[17:59:31.130]                       else if (inherits(cond, "condition")) {
[17:59:31.130]                         if (!is.null(pattern)) {
[17:59:31.130]                           computeRestarts <- base::computeRestarts
[17:59:31.130]                           grepl <- base::grepl
[17:59:31.130]                           restarts <- computeRestarts(cond)
[17:59:31.130]                           for (restart in restarts) {
[17:59:31.130]                             name <- restart$name
[17:59:31.130]                             if (is.null(name)) 
[17:59:31.130]                               next
[17:59:31.130]                             if (!grepl(pattern, name)) 
[17:59:31.130]                               next
[17:59:31.130]                             invokeRestart(restart)
[17:59:31.130]                             muffled <- TRUE
[17:59:31.130]                             break
[17:59:31.130]                           }
[17:59:31.130]                         }
[17:59:31.130]                       }
[17:59:31.130]                       invisible(muffled)
[17:59:31.130]                     }
[17:59:31.130]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.130]                   }
[17:59:31.130]                 }
[17:59:31.130]                 else {
[17:59:31.130]                   if (TRUE) {
[17:59:31.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.130]                     {
[17:59:31.130]                       inherits <- base::inherits
[17:59:31.130]                       invokeRestart <- base::invokeRestart
[17:59:31.130]                       is.null <- base::is.null
[17:59:31.130]                       muffled <- FALSE
[17:59:31.130]                       if (inherits(cond, "message")) {
[17:59:31.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.130]                         if (muffled) 
[17:59:31.130]                           invokeRestart("muffleMessage")
[17:59:31.130]                       }
[17:59:31.130]                       else if (inherits(cond, "warning")) {
[17:59:31.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.130]                         if (muffled) 
[17:59:31.130]                           invokeRestart("muffleWarning")
[17:59:31.130]                       }
[17:59:31.130]                       else if (inherits(cond, "condition")) {
[17:59:31.130]                         if (!is.null(pattern)) {
[17:59:31.130]                           computeRestarts <- base::computeRestarts
[17:59:31.130]                           grepl <- base::grepl
[17:59:31.130]                           restarts <- computeRestarts(cond)
[17:59:31.130]                           for (restart in restarts) {
[17:59:31.130]                             name <- restart$name
[17:59:31.130]                             if (is.null(name)) 
[17:59:31.130]                               next
[17:59:31.130]                             if (!grepl(pattern, name)) 
[17:59:31.130]                               next
[17:59:31.130]                             invokeRestart(restart)
[17:59:31.130]                             muffled <- TRUE
[17:59:31.130]                             break
[17:59:31.130]                           }
[17:59:31.130]                         }
[17:59:31.130]                       }
[17:59:31.130]                       invisible(muffled)
[17:59:31.130]                     }
[17:59:31.130]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.130]                   }
[17:59:31.130]                 }
[17:59:31.130]             }
[17:59:31.130]         }))
[17:59:31.130]     }, error = function(ex) {
[17:59:31.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.130]                 ...future.rng), started = ...future.startTime, 
[17:59:31.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.130]             version = "1.8"), class = "FutureResult")
[17:59:31.130]     }, finally = {
[17:59:31.130]         if (!identical(...future.workdir, getwd())) 
[17:59:31.130]             setwd(...future.workdir)
[17:59:31.130]         {
[17:59:31.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.130]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.130]             }
[17:59:31.130]             base::options(...future.oldOptions)
[17:59:31.130]             if (.Platform$OS.type == "windows") {
[17:59:31.130]                 old_names <- names(...future.oldEnvVars)
[17:59:31.130]                 envs <- base::Sys.getenv()
[17:59:31.130]                 names <- names(envs)
[17:59:31.130]                 common <- intersect(names, old_names)
[17:59:31.130]                 added <- setdiff(names, old_names)
[17:59:31.130]                 removed <- setdiff(old_names, names)
[17:59:31.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.130]                   envs[common]]
[17:59:31.130]                 NAMES <- toupper(changed)
[17:59:31.130]                 args <- list()
[17:59:31.130]                 for (kk in seq_along(NAMES)) {
[17:59:31.130]                   name <- changed[[kk]]
[17:59:31.130]                   NAME <- NAMES[[kk]]
[17:59:31.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.130]                     next
[17:59:31.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.130]                 }
[17:59:31.130]                 NAMES <- toupper(added)
[17:59:31.130]                 for (kk in seq_along(NAMES)) {
[17:59:31.130]                   name <- added[[kk]]
[17:59:31.130]                   NAME <- NAMES[[kk]]
[17:59:31.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.130]                     next
[17:59:31.130]                   args[[name]] <- ""
[17:59:31.130]                 }
[17:59:31.130]                 NAMES <- toupper(removed)
[17:59:31.130]                 for (kk in seq_along(NAMES)) {
[17:59:31.130]                   name <- removed[[kk]]
[17:59:31.130]                   NAME <- NAMES[[kk]]
[17:59:31.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.130]                     next
[17:59:31.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.130]                 }
[17:59:31.130]                 if (length(args) > 0) 
[17:59:31.130]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.130]             }
[17:59:31.130]             else {
[17:59:31.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.130]             }
[17:59:31.130]             {
[17:59:31.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.130]                   0L) {
[17:59:31.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.130]                   base::options(opts)
[17:59:31.130]                 }
[17:59:31.130]                 {
[17:59:31.130]                   {
[17:59:31.130]                     NULL
[17:59:31.130]                     RNGkind("Mersenne-Twister")
[17:59:31.130]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:31.130]                       inherits = FALSE)
[17:59:31.130]                   }
[17:59:31.130]                   options(future.plan = NULL)
[17:59:31.130]                   if (is.na(NA_character_)) 
[17:59:31.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.130]                     .init = FALSE)
[17:59:31.130]                 }
[17:59:31.130]             }
[17:59:31.130]         }
[17:59:31.130]     })
[17:59:31.130]     if (TRUE) {
[17:59:31.130]         base::sink(type = "output", split = FALSE)
[17:59:31.130]         if (TRUE) {
[17:59:31.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.130]         }
[17:59:31.130]         else {
[17:59:31.130]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.130]         }
[17:59:31.130]         base::close(...future.stdout)
[17:59:31.130]         ...future.stdout <- NULL
[17:59:31.130]     }
[17:59:31.130]     ...future.result$conditions <- ...future.conditions
[17:59:31.130]     ...future.result$finished <- base::Sys.time()
[17:59:31.130]     ...future.result
[17:59:31.130] }
[17:59:31.136] assign_globals() ...
[17:59:31.136] List of 5
[17:59:31.136]  $ ...future.FUN            :function (x, ...)  
[17:59:31.136]  $ future.call.arguments    : list()
[17:59:31.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.136]  $ ...future.elements_ii    :List of 3
[17:59:31.136]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:59:31.136]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:31.136]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:31.136]  $ ...future.seeds_ii       : NULL
[17:59:31.136]  $ ...future.globals.maxSize: NULL
[17:59:31.136]  - attr(*, "where")=List of 5
[17:59:31.136]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.136]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.136]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.136]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.136]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.136]  - attr(*, "resolved")= logi FALSE
[17:59:31.136]  - attr(*, "total_size")= num 1248
[17:59:31.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.136]  - attr(*, "already-done")= logi TRUE
[17:59:31.147] - copied ‘...future.FUN’ to environment
[17:59:31.148] - copied ‘future.call.arguments’ to environment
[17:59:31.148] - copied ‘...future.elements_ii’ to environment
[17:59:31.148] - copied ‘...future.seeds_ii’ to environment
[17:59:31.148] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.148] assign_globals() ... done
[17:59:31.149] plan(): Setting new future strategy stack:
[17:59:31.149] List of future strategies:
[17:59:31.149] 1. sequential:
[17:59:31.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.149]    - tweaked: FALSE
[17:59:31.149]    - call: NULL
[17:59:31.150] plan(): nbrOfWorkers() = 1
[17:59:31.153] plan(): Setting new future strategy stack:
[17:59:31.153] List of future strategies:
[17:59:31.153] 1. sequential:
[17:59:31.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.153]    - tweaked: FALSE
[17:59:31.153]    - call: plan(strategy)
[17:59:31.154] plan(): nbrOfWorkers() = 1
[17:59:31.154] SequentialFuture started (and completed)
[17:59:31.155] - Launch lazy future ... done
[17:59:31.155] run() for ‘SequentialFuture’ ... done
[17:59:31.155] Created future:
[17:59:31.155] SequentialFuture:
[17:59:31.155] Label: ‘future_eapply-1’
[17:59:31.155] Expression:
[17:59:31.155] {
[17:59:31.155]     do.call(function(...) {
[17:59:31.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.155]             on.exit(options(oopts), add = TRUE)
[17:59:31.155]         }
[17:59:31.155]         {
[17:59:31.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.155]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.155]             })
[17:59:31.155]         }
[17:59:31.155]     }, args = future.call.arguments)
[17:59:31.155] }
[17:59:31.155] Lazy evaluation: FALSE
[17:59:31.155] Asynchronous evaluation: FALSE
[17:59:31.155] Local evaluation: TRUE
[17:59:31.155] Environment: R_GlobalEnv
[17:59:31.155] Capture standard output: TRUE
[17:59:31.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.155] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.155] Packages: 1 packages (‘stats’)
[17:59:31.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.155] Resolved: TRUE
[17:59:31.155] Value: 1.71 KiB of class ‘list’
[17:59:31.155] Early signaling: FALSE
[17:59:31.155] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.155] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:31.157] Chunk #1 of 1 ... DONE
[17:59:31.157] Launching 1 futures (chunks) ... DONE
[17:59:31.158] Resolving 1 futures (chunks) ...
[17:59:31.158] resolve() on list ...
[17:59:31.158]  recursive: 0
[17:59:31.158]  length: 1
[17:59:31.158] 
[17:59:31.159] resolved() for ‘SequentialFuture’ ...
[17:59:31.159] - state: ‘finished’
[17:59:31.159] - run: TRUE
[17:59:31.159] - result: ‘FutureResult’
[17:59:31.159] resolved() for ‘SequentialFuture’ ... done
[17:59:31.160] Future #1
[17:59:31.160] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:31.160] - nx: 1
[17:59:31.160] - relay: TRUE
[17:59:31.160] - stdout: TRUE
[17:59:31.161] - signal: TRUE
[17:59:31.161] - resignal: FALSE
[17:59:31.161] - force: TRUE
[17:59:31.161] - relayed: [n=1] FALSE
[17:59:31.161] - queued futures: [n=1] FALSE
[17:59:31.162]  - until=1
[17:59:31.162]  - relaying element #1
[17:59:31.162] - relayed: [n=1] TRUE
[17:59:31.162] - queued futures: [n=1] TRUE
[17:59:31.162] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:31.163]  length: 0 (resolved future 1)
[17:59:31.163] Relaying remaining futures
[17:59:31.163] signalConditionsASAP(NULL, pos=0) ...
[17:59:31.163] - nx: 1
[17:59:31.163] - relay: TRUE
[17:59:31.164] - stdout: TRUE
[17:59:31.164] - signal: TRUE
[17:59:31.164] - resignal: FALSE
[17:59:31.164] - force: TRUE
[17:59:31.164] - relayed: [n=1] TRUE
[17:59:31.164] - queued futures: [n=1] TRUE
 - flush all
[17:59:31.165] - relayed: [n=1] TRUE
[17:59:31.165] - queued futures: [n=1] TRUE
[17:59:31.165] signalConditionsASAP(NULL, pos=0) ... done
[17:59:31.165] resolve() on list ... DONE
[17:59:31.166]  - Number of value chunks collected: 1
[17:59:31.166] Resolving 1 futures (chunks) ... DONE
[17:59:31.166] Reducing values from 1 chunks ...
[17:59:31.166]  - Number of values collected after concatenation: 3
[17:59:31.166]  - Number of values expected: 3
[17:59:31.166] Reducing values from 1 chunks ... DONE
[17:59:31.167] future_lapply() ... DONE
[17:59:31.167] plan(): Setting new future strategy stack:
[17:59:31.167] List of future strategies:
[17:59:31.167] 1. sequential:
[17:59:31.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.167]    - tweaked: FALSE
[17:59:31.167]    - call: plan(sequential)
[17:59:31.168] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:59:31.169] plan(): Setting new future strategy stack:
[17:59:31.169] List of future strategies:
[17:59:31.169] 1. multicore:
[17:59:31.169]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.169]    - tweaked: FALSE
[17:59:31.169]    - call: plan(strategy)
[17:59:31.176] plan(): nbrOfWorkers() = 2
[17:59:31.176] future_lapply() ...
[17:59:31.183] Number of chunks: 2
[17:59:31.184] getGlobalsAndPackagesXApply() ...
[17:59:31.184]  - future.globals: TRUE
[17:59:31.184] getGlobalsAndPackages() ...
[17:59:31.184] Searching for globals...
[17:59:31.186] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:31.187] Searching for globals ... DONE
[17:59:31.187] Resolving globals: FALSE
[17:59:31.187] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:31.188] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:31.188] - globals: [1] ‘FUN’
[17:59:31.188] 
[17:59:31.189] getGlobalsAndPackages() ... DONE
[17:59:31.189]  - globals found/used: [n=1] ‘FUN’
[17:59:31.189]  - needed namespaces: [n=0] 
[17:59:31.189] Finding globals ... DONE
[17:59:31.189]  - use_args: TRUE
[17:59:31.190]  - Getting '...' globals ...
[17:59:31.190] resolve() on list ...
[17:59:31.190]  recursive: 0
[17:59:31.191]  length: 1
[17:59:31.191]  elements: ‘...’
[17:59:31.191]  length: 0 (resolved future 1)
[17:59:31.191] resolve() on list ... DONE
[17:59:31.191]    - '...' content: [n=0] 
[17:59:31.194] List of 1
[17:59:31.194]  $ ...: list()
[17:59:31.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.194]  - attr(*, "where")=List of 1
[17:59:31.194]   ..$ ...:<environment: 0x58d4c4b4aea0> 
[17:59:31.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.194]  - attr(*, "resolved")= logi TRUE
[17:59:31.194]  - attr(*, "total_size")= num NA
[17:59:31.199]  - Getting '...' globals ... DONE
[17:59:31.199] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:31.200] List of 2
[17:59:31.200]  $ ...future.FUN:function (x, ...)  
[17:59:31.200]  $ ...          : list()
[17:59:31.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.200]  - attr(*, "where")=List of 2
[17:59:31.200]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:31.200]   ..$ ...          :<environment: 0x58d4c4b4aea0> 
[17:59:31.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.200]  - attr(*, "resolved")= logi FALSE
[17:59:31.200]  - attr(*, "total_size")= num 1240
[17:59:31.205] Packages to be attached in all futures: [n=0] 
[17:59:31.205] getGlobalsAndPackagesXApply() ... DONE
[17:59:31.206] Number of futures (= number of chunks): 2
[17:59:31.206] Launching 2 futures (chunks) ...
[17:59:31.206] Chunk #1 of 2 ...
[17:59:31.206]  - Finding globals in 'X' for chunk #1 ...
[17:59:31.207] getGlobalsAndPackages() ...
[17:59:31.207] Searching for globals...
[17:59:31.207] 
[17:59:31.208] Searching for globals ... DONE
[17:59:31.208] - globals: [0] <none>
[17:59:31.208] getGlobalsAndPackages() ... DONE
[17:59:31.208]    + additional globals found: [n=0] 
[17:59:31.208]    + additional namespaces needed: [n=0] 
[17:59:31.209]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:31.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.209]  - seeds: <none>
[17:59:31.209]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.209] getGlobalsAndPackages() ...
[17:59:31.210] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.210] Resolving globals: FALSE
[17:59:31.210] Tweak future expression to call with '...' arguments ...
[17:59:31.210] {
[17:59:31.210]     do.call(function(...) {
[17:59:31.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.210]             on.exit(options(oopts), add = TRUE)
[17:59:31.210]         }
[17:59:31.210]         {
[17:59:31.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.210]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.210]             })
[17:59:31.210]         }
[17:59:31.210]     }, args = future.call.arguments)
[17:59:31.210] }
[17:59:31.211] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.211] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.212] 
[17:59:31.212] getGlobalsAndPackages() ... DONE
[17:59:31.212] run() for ‘Future’ ...
[17:59:31.213] - state: ‘created’
[17:59:31.213] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.219] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.220]   - Field: ‘label’
[17:59:31.220]   - Field: ‘local’
[17:59:31.220]   - Field: ‘owner’
[17:59:31.220]   - Field: ‘envir’
[17:59:31.220]   - Field: ‘workers’
[17:59:31.221]   - Field: ‘packages’
[17:59:31.221]   - Field: ‘gc’
[17:59:31.221]   - Field: ‘job’
[17:59:31.221]   - Field: ‘conditions’
[17:59:31.221]   - Field: ‘expr’
[17:59:31.222]   - Field: ‘uuid’
[17:59:31.222]   - Field: ‘seed’
[17:59:31.222]   - Field: ‘version’
[17:59:31.222]   - Field: ‘result’
[17:59:31.222]   - Field: ‘asynchronous’
[17:59:31.223]   - Field: ‘calls’
[17:59:31.223]   - Field: ‘globals’
[17:59:31.223]   - Field: ‘stdout’
[17:59:31.223]   - Field: ‘earlySignal’
[17:59:31.223]   - Field: ‘lazy’
[17:59:31.224]   - Field: ‘state’
[17:59:31.224] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.224] - Launch lazy future ...
[17:59:31.226] Packages needed by the future expression (n = 0): <none>
[17:59:31.226] Packages needed by future strategies (n = 0): <none>
[17:59:31.227] {
[17:59:31.227]     {
[17:59:31.227]         {
[17:59:31.227]             ...future.startTime <- base::Sys.time()
[17:59:31.227]             {
[17:59:31.227]                 {
[17:59:31.227]                   {
[17:59:31.227]                     {
[17:59:31.227]                       base::local({
[17:59:31.227]                         has_future <- base::requireNamespace("future", 
[17:59:31.227]                           quietly = TRUE)
[17:59:31.227]                         if (has_future) {
[17:59:31.227]                           ns <- base::getNamespace("future")
[17:59:31.227]                           version <- ns[[".package"]][["version"]]
[17:59:31.227]                           if (is.null(version)) 
[17:59:31.227]                             version <- utils::packageVersion("future")
[17:59:31.227]                         }
[17:59:31.227]                         else {
[17:59:31.227]                           version <- NULL
[17:59:31.227]                         }
[17:59:31.227]                         if (!has_future || version < "1.8.0") {
[17:59:31.227]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.227]                             "", base::R.version$version.string), 
[17:59:31.227]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:31.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:31.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.227]                               "release", "version")], collapse = " "), 
[17:59:31.227]                             hostname = base::Sys.info()[["nodename"]])
[17:59:31.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.227]                             info)
[17:59:31.227]                           info <- base::paste(info, collapse = "; ")
[17:59:31.227]                           if (!has_future) {
[17:59:31.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.227]                               info)
[17:59:31.227]                           }
[17:59:31.227]                           else {
[17:59:31.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.227]                               info, version)
[17:59:31.227]                           }
[17:59:31.227]                           base::stop(msg)
[17:59:31.227]                         }
[17:59:31.227]                       })
[17:59:31.227]                     }
[17:59:31.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.227]                     base::options(mc.cores = 1L)
[17:59:31.227]                   }
[17:59:31.227]                   ...future.strategy.old <- future::plan("list")
[17:59:31.227]                   options(future.plan = NULL)
[17:59:31.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.227]                 }
[17:59:31.227]                 ...future.workdir <- getwd()
[17:59:31.227]             }
[17:59:31.227]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.227]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.227]         }
[17:59:31.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.227]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.227]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.227]             base::names(...future.oldOptions))
[17:59:31.227]     }
[17:59:31.227]     if (FALSE) {
[17:59:31.227]     }
[17:59:31.227]     else {
[17:59:31.227]         if (TRUE) {
[17:59:31.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.227]                 open = "w")
[17:59:31.227]         }
[17:59:31.227]         else {
[17:59:31.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.227]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.227]         }
[17:59:31.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.227]             base::sink(type = "output", split = FALSE)
[17:59:31.227]             base::close(...future.stdout)
[17:59:31.227]         }, add = TRUE)
[17:59:31.227]     }
[17:59:31.227]     ...future.frame <- base::sys.nframe()
[17:59:31.227]     ...future.conditions <- base::list()
[17:59:31.227]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.227]     if (FALSE) {
[17:59:31.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.227]     }
[17:59:31.227]     ...future.result <- base::tryCatch({
[17:59:31.227]         base::withCallingHandlers({
[17:59:31.227]             ...future.value <- base::withVisible(base::local({
[17:59:31.227]                 withCallingHandlers({
[17:59:31.227]                   {
[17:59:31.227]                     do.call(function(...) {
[17:59:31.227]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.227]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.227]                         ...future.globals.maxSize)) {
[17:59:31.227]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.227]                         on.exit(options(oopts), add = TRUE)
[17:59:31.227]                       }
[17:59:31.227]                       {
[17:59:31.227]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.227]                           FUN = function(jj) {
[17:59:31.227]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.227]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.227]                           })
[17:59:31.227]                       }
[17:59:31.227]                     }, args = future.call.arguments)
[17:59:31.227]                   }
[17:59:31.227]                 }, immediateCondition = function(cond) {
[17:59:31.227]                   save_rds <- function (object, pathname, ...) 
[17:59:31.227]                   {
[17:59:31.227]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.227]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.227]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.227]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.227]                         fi_tmp[["mtime"]])
[17:59:31.227]                     }
[17:59:31.227]                     tryCatch({
[17:59:31.227]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.227]                     }, error = function(ex) {
[17:59:31.227]                       msg <- conditionMessage(ex)
[17:59:31.227]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.227]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.227]                         fi_tmp[["mtime"]], msg)
[17:59:31.227]                       ex$message <- msg
[17:59:31.227]                       stop(ex)
[17:59:31.227]                     })
[17:59:31.227]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.227]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.227]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.227]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.227]                       fi <- file.info(pathname)
[17:59:31.227]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.227]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.227]                         fi[["size"]], fi[["mtime"]])
[17:59:31.227]                       stop(msg)
[17:59:31.227]                     }
[17:59:31.227]                     invisible(pathname)
[17:59:31.227]                   }
[17:59:31.227]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.227]                     rootPath = tempdir()) 
[17:59:31.227]                   {
[17:59:31.227]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.227]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.227]                       tmpdir = path, fileext = ".rds")
[17:59:31.227]                     save_rds(obj, file)
[17:59:31.227]                   }
[17:59:31.227]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.227]                   {
[17:59:31.227]                     inherits <- base::inherits
[17:59:31.227]                     invokeRestart <- base::invokeRestart
[17:59:31.227]                     is.null <- base::is.null
[17:59:31.227]                     muffled <- FALSE
[17:59:31.227]                     if (inherits(cond, "message")) {
[17:59:31.227]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.227]                       if (muffled) 
[17:59:31.227]                         invokeRestart("muffleMessage")
[17:59:31.227]                     }
[17:59:31.227]                     else if (inherits(cond, "warning")) {
[17:59:31.227]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.227]                       if (muffled) 
[17:59:31.227]                         invokeRestart("muffleWarning")
[17:59:31.227]                     }
[17:59:31.227]                     else if (inherits(cond, "condition")) {
[17:59:31.227]                       if (!is.null(pattern)) {
[17:59:31.227]                         computeRestarts <- base::computeRestarts
[17:59:31.227]                         grepl <- base::grepl
[17:59:31.227]                         restarts <- computeRestarts(cond)
[17:59:31.227]                         for (restart in restarts) {
[17:59:31.227]                           name <- restart$name
[17:59:31.227]                           if (is.null(name)) 
[17:59:31.227]                             next
[17:59:31.227]                           if (!grepl(pattern, name)) 
[17:59:31.227]                             next
[17:59:31.227]                           invokeRestart(restart)
[17:59:31.227]                           muffled <- TRUE
[17:59:31.227]                           break
[17:59:31.227]                         }
[17:59:31.227]                       }
[17:59:31.227]                     }
[17:59:31.227]                     invisible(muffled)
[17:59:31.227]                   }
[17:59:31.227]                   muffleCondition(cond)
[17:59:31.227]                 })
[17:59:31.227]             }))
[17:59:31.227]             future::FutureResult(value = ...future.value$value, 
[17:59:31.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.227]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.227]                     ...future.globalenv.names))
[17:59:31.227]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.227]         }, condition = base::local({
[17:59:31.227]             c <- base::c
[17:59:31.227]             inherits <- base::inherits
[17:59:31.227]             invokeRestart <- base::invokeRestart
[17:59:31.227]             length <- base::length
[17:59:31.227]             list <- base::list
[17:59:31.227]             seq.int <- base::seq.int
[17:59:31.227]             signalCondition <- base::signalCondition
[17:59:31.227]             sys.calls <- base::sys.calls
[17:59:31.227]             `[[` <- base::`[[`
[17:59:31.227]             `+` <- base::`+`
[17:59:31.227]             `<<-` <- base::`<<-`
[17:59:31.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.227]                   3L)]
[17:59:31.227]             }
[17:59:31.227]             function(cond) {
[17:59:31.227]                 is_error <- inherits(cond, "error")
[17:59:31.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.227]                   NULL)
[17:59:31.227]                 if (is_error) {
[17:59:31.227]                   sessionInformation <- function() {
[17:59:31.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.227]                       search = base::search(), system = base::Sys.info())
[17:59:31.227]                   }
[17:59:31.227]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.227]                     cond$call), session = sessionInformation(), 
[17:59:31.227]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.227]                   signalCondition(cond)
[17:59:31.227]                 }
[17:59:31.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.227]                 "immediateCondition"))) {
[17:59:31.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.227]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.227]                   if (TRUE && !signal) {
[17:59:31.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.227]                     {
[17:59:31.227]                       inherits <- base::inherits
[17:59:31.227]                       invokeRestart <- base::invokeRestart
[17:59:31.227]                       is.null <- base::is.null
[17:59:31.227]                       muffled <- FALSE
[17:59:31.227]                       if (inherits(cond, "message")) {
[17:59:31.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.227]                         if (muffled) 
[17:59:31.227]                           invokeRestart("muffleMessage")
[17:59:31.227]                       }
[17:59:31.227]                       else if (inherits(cond, "warning")) {
[17:59:31.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.227]                         if (muffled) 
[17:59:31.227]                           invokeRestart("muffleWarning")
[17:59:31.227]                       }
[17:59:31.227]                       else if (inherits(cond, "condition")) {
[17:59:31.227]                         if (!is.null(pattern)) {
[17:59:31.227]                           computeRestarts <- base::computeRestarts
[17:59:31.227]                           grepl <- base::grepl
[17:59:31.227]                           restarts <- computeRestarts(cond)
[17:59:31.227]                           for (restart in restarts) {
[17:59:31.227]                             name <- restart$name
[17:59:31.227]                             if (is.null(name)) 
[17:59:31.227]                               next
[17:59:31.227]                             if (!grepl(pattern, name)) 
[17:59:31.227]                               next
[17:59:31.227]                             invokeRestart(restart)
[17:59:31.227]                             muffled <- TRUE
[17:59:31.227]                             break
[17:59:31.227]                           }
[17:59:31.227]                         }
[17:59:31.227]                       }
[17:59:31.227]                       invisible(muffled)
[17:59:31.227]                     }
[17:59:31.227]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.227]                   }
[17:59:31.227]                 }
[17:59:31.227]                 else {
[17:59:31.227]                   if (TRUE) {
[17:59:31.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.227]                     {
[17:59:31.227]                       inherits <- base::inherits
[17:59:31.227]                       invokeRestart <- base::invokeRestart
[17:59:31.227]                       is.null <- base::is.null
[17:59:31.227]                       muffled <- FALSE
[17:59:31.227]                       if (inherits(cond, "message")) {
[17:59:31.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.227]                         if (muffled) 
[17:59:31.227]                           invokeRestart("muffleMessage")
[17:59:31.227]                       }
[17:59:31.227]                       else if (inherits(cond, "warning")) {
[17:59:31.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.227]                         if (muffled) 
[17:59:31.227]                           invokeRestart("muffleWarning")
[17:59:31.227]                       }
[17:59:31.227]                       else if (inherits(cond, "condition")) {
[17:59:31.227]                         if (!is.null(pattern)) {
[17:59:31.227]                           computeRestarts <- base::computeRestarts
[17:59:31.227]                           grepl <- base::grepl
[17:59:31.227]                           restarts <- computeRestarts(cond)
[17:59:31.227]                           for (restart in restarts) {
[17:59:31.227]                             name <- restart$name
[17:59:31.227]                             if (is.null(name)) 
[17:59:31.227]                               next
[17:59:31.227]                             if (!grepl(pattern, name)) 
[17:59:31.227]                               next
[17:59:31.227]                             invokeRestart(restart)
[17:59:31.227]                             muffled <- TRUE
[17:59:31.227]                             break
[17:59:31.227]                           }
[17:59:31.227]                         }
[17:59:31.227]                       }
[17:59:31.227]                       invisible(muffled)
[17:59:31.227]                     }
[17:59:31.227]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.227]                   }
[17:59:31.227]                 }
[17:59:31.227]             }
[17:59:31.227]         }))
[17:59:31.227]     }, error = function(ex) {
[17:59:31.227]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.227]                 ...future.rng), started = ...future.startTime, 
[17:59:31.227]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.227]             version = "1.8"), class = "FutureResult")
[17:59:31.227]     }, finally = {
[17:59:31.227]         if (!identical(...future.workdir, getwd())) 
[17:59:31.227]             setwd(...future.workdir)
[17:59:31.227]         {
[17:59:31.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.227]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.227]             }
[17:59:31.227]             base::options(...future.oldOptions)
[17:59:31.227]             if (.Platform$OS.type == "windows") {
[17:59:31.227]                 old_names <- names(...future.oldEnvVars)
[17:59:31.227]                 envs <- base::Sys.getenv()
[17:59:31.227]                 names <- names(envs)
[17:59:31.227]                 common <- intersect(names, old_names)
[17:59:31.227]                 added <- setdiff(names, old_names)
[17:59:31.227]                 removed <- setdiff(old_names, names)
[17:59:31.227]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.227]                   envs[common]]
[17:59:31.227]                 NAMES <- toupper(changed)
[17:59:31.227]                 args <- list()
[17:59:31.227]                 for (kk in seq_along(NAMES)) {
[17:59:31.227]                   name <- changed[[kk]]
[17:59:31.227]                   NAME <- NAMES[[kk]]
[17:59:31.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.227]                     next
[17:59:31.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.227]                 }
[17:59:31.227]                 NAMES <- toupper(added)
[17:59:31.227]                 for (kk in seq_along(NAMES)) {
[17:59:31.227]                   name <- added[[kk]]
[17:59:31.227]                   NAME <- NAMES[[kk]]
[17:59:31.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.227]                     next
[17:59:31.227]                   args[[name]] <- ""
[17:59:31.227]                 }
[17:59:31.227]                 NAMES <- toupper(removed)
[17:59:31.227]                 for (kk in seq_along(NAMES)) {
[17:59:31.227]                   name <- removed[[kk]]
[17:59:31.227]                   NAME <- NAMES[[kk]]
[17:59:31.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.227]                     next
[17:59:31.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.227]                 }
[17:59:31.227]                 if (length(args) > 0) 
[17:59:31.227]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.227]             }
[17:59:31.227]             else {
[17:59:31.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.227]             }
[17:59:31.227]             {
[17:59:31.227]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.227]                   0L) {
[17:59:31.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.227]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.227]                   base::options(opts)
[17:59:31.227]                 }
[17:59:31.227]                 {
[17:59:31.227]                   {
[17:59:31.227]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.227]                     NULL
[17:59:31.227]                   }
[17:59:31.227]                   options(future.plan = NULL)
[17:59:31.227]                   if (is.na(NA_character_)) 
[17:59:31.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.227]                     .init = FALSE)
[17:59:31.227]                 }
[17:59:31.227]             }
[17:59:31.227]         }
[17:59:31.227]     })
[17:59:31.227]     if (TRUE) {
[17:59:31.227]         base::sink(type = "output", split = FALSE)
[17:59:31.227]         if (TRUE) {
[17:59:31.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.227]         }
[17:59:31.227]         else {
[17:59:31.227]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.227]         }
[17:59:31.227]         base::close(...future.stdout)
[17:59:31.227]         ...future.stdout <- NULL
[17:59:31.227]     }
[17:59:31.227]     ...future.result$conditions <- ...future.conditions
[17:59:31.227]     ...future.result$finished <- base::Sys.time()
[17:59:31.227]     ...future.result
[17:59:31.227] }
[17:59:31.231] assign_globals() ...
[17:59:31.231] List of 5
[17:59:31.231]  $ ...future.FUN            :function (x, ...)  
[17:59:31.231]  $ future.call.arguments    : list()
[17:59:31.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.231]  $ ...future.elements_ii    :List of 1
[17:59:31.231]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:59:31.231]  $ ...future.seeds_ii       : NULL
[17:59:31.231]  $ ...future.globals.maxSize: NULL
[17:59:31.231]  - attr(*, "where")=List of 5
[17:59:31.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.231]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.231]  - attr(*, "resolved")= logi FALSE
[17:59:31.231]  - attr(*, "total_size")= num 1240
[17:59:31.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.231]  - attr(*, "already-done")= logi TRUE
[17:59:31.241] - copied ‘...future.FUN’ to environment
[17:59:31.241] - copied ‘future.call.arguments’ to environment
[17:59:31.241] - copied ‘...future.elements_ii’ to environment
[17:59:31.241] - copied ‘...future.seeds_ii’ to environment
[17:59:31.242] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.242] assign_globals() ... done
[17:59:31.242] requestCore(): workers = 2
[17:59:31.247] MulticoreFuture started
[17:59:31.247] - Launch lazy future ... done
[17:59:31.248] run() for ‘MulticoreFuture’ ... done
[17:59:31.248] Created future:
[17:59:31.248] plan(): Setting new future strategy stack:
[17:59:31.249] List of future strategies:
[17:59:31.249] 1. sequential:
[17:59:31.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.249]    - tweaked: FALSE
[17:59:31.249]    - call: NULL
[17:59:31.251] plan(): nbrOfWorkers() = 1
[17:59:31.254] plan(): Setting new future strategy stack:
[17:59:31.255] List of future strategies:
[17:59:31.255] 1. multicore:
[17:59:31.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.255]    - tweaked: FALSE
[17:59:31.255]    - call: plan(strategy)
[17:59:31.249] MulticoreFuture:
[17:59:31.249] Label: ‘future_eapply-1’
[17:59:31.249] Expression:
[17:59:31.249] {
[17:59:31.249]     do.call(function(...) {
[17:59:31.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.249]             on.exit(options(oopts), add = TRUE)
[17:59:31.249]         }
[17:59:31.249]         {
[17:59:31.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.249]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.249]             })
[17:59:31.249]         }
[17:59:31.249]     }, args = future.call.arguments)
[17:59:31.249] }
[17:59:31.249] Lazy evaluation: FALSE
[17:59:31.249] Asynchronous evaluation: TRUE
[17:59:31.249] Local evaluation: TRUE
[17:59:31.249] Environment: R_GlobalEnv
[17:59:31.249] Capture standard output: TRUE
[17:59:31.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.249] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.249] Packages: <none>
[17:59:31.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.249] Resolved: FALSE
[17:59:31.249] Value: <not collected>
[17:59:31.249] Conditions captured: <none>
[17:59:31.249] Early signaling: FALSE
[17:59:31.249] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.249] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.266] Chunk #1 of 2 ... DONE
[17:59:31.266] Chunk #2 of 2 ...
[17:59:31.267]  - Finding globals in 'X' for chunk #2 ...
[17:59:31.267] getGlobalsAndPackages() ...
[17:59:31.267] Searching for globals...
[17:59:31.270] plan(): nbrOfWorkers() = 2
[17:59:31.268] 
[17:59:31.273] Searching for globals ... DONE
[17:59:31.273] - globals: [0] <none>
[17:59:31.274] getGlobalsAndPackages() ... DONE
[17:59:31.274]    + additional globals found: [n=0] 
[17:59:31.274]    + additional namespaces needed: [n=0] 
[17:59:31.275]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:31.275]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.275]  - seeds: <none>
[17:59:31.275]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.276] getGlobalsAndPackages() ...
[17:59:31.276] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.276] Resolving globals: FALSE
[17:59:31.277] Tweak future expression to call with '...' arguments ...
[17:59:31.277] {
[17:59:31.277]     do.call(function(...) {
[17:59:31.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.277]             on.exit(options(oopts), add = TRUE)
[17:59:31.277]         }
[17:59:31.277]         {
[17:59:31.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.277]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.277]             })
[17:59:31.277]         }
[17:59:31.277]     }, args = future.call.arguments)
[17:59:31.277] }
[17:59:31.278] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.280] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.281] 
[17:59:31.281] getGlobalsAndPackages() ... DONE
[17:59:31.282] run() for ‘Future’ ...
[17:59:31.282] - state: ‘created’
[17:59:31.283] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.291] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.292]   - Field: ‘label’
[17:59:31.293]   - Field: ‘local’
[17:59:31.293]   - Field: ‘owner’
[17:59:31.293]   - Field: ‘envir’
[17:59:31.294]   - Field: ‘workers’
[17:59:31.294]   - Field: ‘packages’
[17:59:31.295]   - Field: ‘gc’
[17:59:31.295]   - Field: ‘job’
[17:59:31.295]   - Field: ‘conditions’
[17:59:31.296]   - Field: ‘expr’
[17:59:31.296]   - Field: ‘uuid’
[17:59:31.296]   - Field: ‘seed’
[17:59:31.296]   - Field: ‘version’
[17:59:31.297]   - Field: ‘result’
[17:59:31.297]   - Field: ‘asynchronous’
[17:59:31.298]   - Field: ‘calls’
[17:59:31.298]   - Field: ‘globals’
[17:59:31.298]   - Field: ‘stdout’
[17:59:31.298]   - Field: ‘earlySignal’
[17:59:31.299]   - Field: ‘lazy’
[17:59:31.299]   - Field: ‘state’
[17:59:31.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.300] - Launch lazy future ...
[17:59:31.300] Packages needed by the future expression (n = 0): <none>
[17:59:31.301] Packages needed by future strategies (n = 0): <none>
[17:59:31.302] {
[17:59:31.302]     {
[17:59:31.302]         {
[17:59:31.302]             ...future.startTime <- base::Sys.time()
[17:59:31.302]             {
[17:59:31.302]                 {
[17:59:31.302]                   {
[17:59:31.302]                     {
[17:59:31.302]                       base::local({
[17:59:31.302]                         has_future <- base::requireNamespace("future", 
[17:59:31.302]                           quietly = TRUE)
[17:59:31.302]                         if (has_future) {
[17:59:31.302]                           ns <- base::getNamespace("future")
[17:59:31.302]                           version <- ns[[".package"]][["version"]]
[17:59:31.302]                           if (is.null(version)) 
[17:59:31.302]                             version <- utils::packageVersion("future")
[17:59:31.302]                         }
[17:59:31.302]                         else {
[17:59:31.302]                           version <- NULL
[17:59:31.302]                         }
[17:59:31.302]                         if (!has_future || version < "1.8.0") {
[17:59:31.302]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.302]                             "", base::R.version$version.string), 
[17:59:31.302]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:31.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:31.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.302]                               "release", "version")], collapse = " "), 
[17:59:31.302]                             hostname = base::Sys.info()[["nodename"]])
[17:59:31.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.302]                             info)
[17:59:31.302]                           info <- base::paste(info, collapse = "; ")
[17:59:31.302]                           if (!has_future) {
[17:59:31.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.302]                               info)
[17:59:31.302]                           }
[17:59:31.302]                           else {
[17:59:31.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.302]                               info, version)
[17:59:31.302]                           }
[17:59:31.302]                           base::stop(msg)
[17:59:31.302]                         }
[17:59:31.302]                       })
[17:59:31.302]                     }
[17:59:31.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.302]                     base::options(mc.cores = 1L)
[17:59:31.302]                   }
[17:59:31.302]                   ...future.strategy.old <- future::plan("list")
[17:59:31.302]                   options(future.plan = NULL)
[17:59:31.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.302]                 }
[17:59:31.302]                 ...future.workdir <- getwd()
[17:59:31.302]             }
[17:59:31.302]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.302]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.302]         }
[17:59:31.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.302]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.302]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.302]             base::names(...future.oldOptions))
[17:59:31.302]     }
[17:59:31.302]     if (FALSE) {
[17:59:31.302]     }
[17:59:31.302]     else {
[17:59:31.302]         if (TRUE) {
[17:59:31.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.302]                 open = "w")
[17:59:31.302]         }
[17:59:31.302]         else {
[17:59:31.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.302]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.302]         }
[17:59:31.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.302]             base::sink(type = "output", split = FALSE)
[17:59:31.302]             base::close(...future.stdout)
[17:59:31.302]         }, add = TRUE)
[17:59:31.302]     }
[17:59:31.302]     ...future.frame <- base::sys.nframe()
[17:59:31.302]     ...future.conditions <- base::list()
[17:59:31.302]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.302]     if (FALSE) {
[17:59:31.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.302]     }
[17:59:31.302]     ...future.result <- base::tryCatch({
[17:59:31.302]         base::withCallingHandlers({
[17:59:31.302]             ...future.value <- base::withVisible(base::local({
[17:59:31.302]                 withCallingHandlers({
[17:59:31.302]                   {
[17:59:31.302]                     do.call(function(...) {
[17:59:31.302]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.302]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.302]                         ...future.globals.maxSize)) {
[17:59:31.302]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.302]                         on.exit(options(oopts), add = TRUE)
[17:59:31.302]                       }
[17:59:31.302]                       {
[17:59:31.302]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.302]                           FUN = function(jj) {
[17:59:31.302]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.302]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.302]                           })
[17:59:31.302]                       }
[17:59:31.302]                     }, args = future.call.arguments)
[17:59:31.302]                   }
[17:59:31.302]                 }, immediateCondition = function(cond) {
[17:59:31.302]                   save_rds <- function (object, pathname, ...) 
[17:59:31.302]                   {
[17:59:31.302]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.302]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.302]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.302]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.302]                         fi_tmp[["mtime"]])
[17:59:31.302]                     }
[17:59:31.302]                     tryCatch({
[17:59:31.302]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.302]                     }, error = function(ex) {
[17:59:31.302]                       msg <- conditionMessage(ex)
[17:59:31.302]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.302]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.302]                         fi_tmp[["mtime"]], msg)
[17:59:31.302]                       ex$message <- msg
[17:59:31.302]                       stop(ex)
[17:59:31.302]                     })
[17:59:31.302]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.302]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.302]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.302]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.302]                       fi <- file.info(pathname)
[17:59:31.302]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.302]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.302]                         fi[["size"]], fi[["mtime"]])
[17:59:31.302]                       stop(msg)
[17:59:31.302]                     }
[17:59:31.302]                     invisible(pathname)
[17:59:31.302]                   }
[17:59:31.302]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.302]                     rootPath = tempdir()) 
[17:59:31.302]                   {
[17:59:31.302]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.302]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.302]                       tmpdir = path, fileext = ".rds")
[17:59:31.302]                     save_rds(obj, file)
[17:59:31.302]                   }
[17:59:31.302]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.302]                   {
[17:59:31.302]                     inherits <- base::inherits
[17:59:31.302]                     invokeRestart <- base::invokeRestart
[17:59:31.302]                     is.null <- base::is.null
[17:59:31.302]                     muffled <- FALSE
[17:59:31.302]                     if (inherits(cond, "message")) {
[17:59:31.302]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.302]                       if (muffled) 
[17:59:31.302]                         invokeRestart("muffleMessage")
[17:59:31.302]                     }
[17:59:31.302]                     else if (inherits(cond, "warning")) {
[17:59:31.302]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.302]                       if (muffled) 
[17:59:31.302]                         invokeRestart("muffleWarning")
[17:59:31.302]                     }
[17:59:31.302]                     else if (inherits(cond, "condition")) {
[17:59:31.302]                       if (!is.null(pattern)) {
[17:59:31.302]                         computeRestarts <- base::computeRestarts
[17:59:31.302]                         grepl <- base::grepl
[17:59:31.302]                         restarts <- computeRestarts(cond)
[17:59:31.302]                         for (restart in restarts) {
[17:59:31.302]                           name <- restart$name
[17:59:31.302]                           if (is.null(name)) 
[17:59:31.302]                             next
[17:59:31.302]                           if (!grepl(pattern, name)) 
[17:59:31.302]                             next
[17:59:31.302]                           invokeRestart(restart)
[17:59:31.302]                           muffled <- TRUE
[17:59:31.302]                           break
[17:59:31.302]                         }
[17:59:31.302]                       }
[17:59:31.302]                     }
[17:59:31.302]                     invisible(muffled)
[17:59:31.302]                   }
[17:59:31.302]                   muffleCondition(cond)
[17:59:31.302]                 })
[17:59:31.302]             }))
[17:59:31.302]             future::FutureResult(value = ...future.value$value, 
[17:59:31.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.302]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.302]                     ...future.globalenv.names))
[17:59:31.302]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.302]         }, condition = base::local({
[17:59:31.302]             c <- base::c
[17:59:31.302]             inherits <- base::inherits
[17:59:31.302]             invokeRestart <- base::invokeRestart
[17:59:31.302]             length <- base::length
[17:59:31.302]             list <- base::list
[17:59:31.302]             seq.int <- base::seq.int
[17:59:31.302]             signalCondition <- base::signalCondition
[17:59:31.302]             sys.calls <- base::sys.calls
[17:59:31.302]             `[[` <- base::`[[`
[17:59:31.302]             `+` <- base::`+`
[17:59:31.302]             `<<-` <- base::`<<-`
[17:59:31.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.302]                   3L)]
[17:59:31.302]             }
[17:59:31.302]             function(cond) {
[17:59:31.302]                 is_error <- inherits(cond, "error")
[17:59:31.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.302]                   NULL)
[17:59:31.302]                 if (is_error) {
[17:59:31.302]                   sessionInformation <- function() {
[17:59:31.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.302]                       search = base::search(), system = base::Sys.info())
[17:59:31.302]                   }
[17:59:31.302]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.302]                     cond$call), session = sessionInformation(), 
[17:59:31.302]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.302]                   signalCondition(cond)
[17:59:31.302]                 }
[17:59:31.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.302]                 "immediateCondition"))) {
[17:59:31.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.302]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.302]                   if (TRUE && !signal) {
[17:59:31.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.302]                     {
[17:59:31.302]                       inherits <- base::inherits
[17:59:31.302]                       invokeRestart <- base::invokeRestart
[17:59:31.302]                       is.null <- base::is.null
[17:59:31.302]                       muffled <- FALSE
[17:59:31.302]                       if (inherits(cond, "message")) {
[17:59:31.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.302]                         if (muffled) 
[17:59:31.302]                           invokeRestart("muffleMessage")
[17:59:31.302]                       }
[17:59:31.302]                       else if (inherits(cond, "warning")) {
[17:59:31.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.302]                         if (muffled) 
[17:59:31.302]                           invokeRestart("muffleWarning")
[17:59:31.302]                       }
[17:59:31.302]                       else if (inherits(cond, "condition")) {
[17:59:31.302]                         if (!is.null(pattern)) {
[17:59:31.302]                           computeRestarts <- base::computeRestarts
[17:59:31.302]                           grepl <- base::grepl
[17:59:31.302]                           restarts <- computeRestarts(cond)
[17:59:31.302]                           for (restart in restarts) {
[17:59:31.302]                             name <- restart$name
[17:59:31.302]                             if (is.null(name)) 
[17:59:31.302]                               next
[17:59:31.302]                             if (!grepl(pattern, name)) 
[17:59:31.302]                               next
[17:59:31.302]                             invokeRestart(restart)
[17:59:31.302]                             muffled <- TRUE
[17:59:31.302]                             break
[17:59:31.302]                           }
[17:59:31.302]                         }
[17:59:31.302]                       }
[17:59:31.302]                       invisible(muffled)
[17:59:31.302]                     }
[17:59:31.302]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.302]                   }
[17:59:31.302]                 }
[17:59:31.302]                 else {
[17:59:31.302]                   if (TRUE) {
[17:59:31.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.302]                     {
[17:59:31.302]                       inherits <- base::inherits
[17:59:31.302]                       invokeRestart <- base::invokeRestart
[17:59:31.302]                       is.null <- base::is.null
[17:59:31.302]                       muffled <- FALSE
[17:59:31.302]                       if (inherits(cond, "message")) {
[17:59:31.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.302]                         if (muffled) 
[17:59:31.302]                           invokeRestart("muffleMessage")
[17:59:31.302]                       }
[17:59:31.302]                       else if (inherits(cond, "warning")) {
[17:59:31.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.302]                         if (muffled) 
[17:59:31.302]                           invokeRestart("muffleWarning")
[17:59:31.302]                       }
[17:59:31.302]                       else if (inherits(cond, "condition")) {
[17:59:31.302]                         if (!is.null(pattern)) {
[17:59:31.302]                           computeRestarts <- base::computeRestarts
[17:59:31.302]                           grepl <- base::grepl
[17:59:31.302]                           restarts <- computeRestarts(cond)
[17:59:31.302]                           for (restart in restarts) {
[17:59:31.302]                             name <- restart$name
[17:59:31.302]                             if (is.null(name)) 
[17:59:31.302]                               next
[17:59:31.302]                             if (!grepl(pattern, name)) 
[17:59:31.302]                               next
[17:59:31.302]                             invokeRestart(restart)
[17:59:31.302]                             muffled <- TRUE
[17:59:31.302]                             break
[17:59:31.302]                           }
[17:59:31.302]                         }
[17:59:31.302]                       }
[17:59:31.302]                       invisible(muffled)
[17:59:31.302]                     }
[17:59:31.302]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.302]                   }
[17:59:31.302]                 }
[17:59:31.302]             }
[17:59:31.302]         }))
[17:59:31.302]     }, error = function(ex) {
[17:59:31.302]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.302]                 ...future.rng), started = ...future.startTime, 
[17:59:31.302]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.302]             version = "1.8"), class = "FutureResult")
[17:59:31.302]     }, finally = {
[17:59:31.302]         if (!identical(...future.workdir, getwd())) 
[17:59:31.302]             setwd(...future.workdir)
[17:59:31.302]         {
[17:59:31.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.302]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.302]             }
[17:59:31.302]             base::options(...future.oldOptions)
[17:59:31.302]             if (.Platform$OS.type == "windows") {
[17:59:31.302]                 old_names <- names(...future.oldEnvVars)
[17:59:31.302]                 envs <- base::Sys.getenv()
[17:59:31.302]                 names <- names(envs)
[17:59:31.302]                 common <- intersect(names, old_names)
[17:59:31.302]                 added <- setdiff(names, old_names)
[17:59:31.302]                 removed <- setdiff(old_names, names)
[17:59:31.302]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.302]                   envs[common]]
[17:59:31.302]                 NAMES <- toupper(changed)
[17:59:31.302]                 args <- list()
[17:59:31.302]                 for (kk in seq_along(NAMES)) {
[17:59:31.302]                   name <- changed[[kk]]
[17:59:31.302]                   NAME <- NAMES[[kk]]
[17:59:31.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.302]                     next
[17:59:31.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.302]                 }
[17:59:31.302]                 NAMES <- toupper(added)
[17:59:31.302]                 for (kk in seq_along(NAMES)) {
[17:59:31.302]                   name <- added[[kk]]
[17:59:31.302]                   NAME <- NAMES[[kk]]
[17:59:31.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.302]                     next
[17:59:31.302]                   args[[name]] <- ""
[17:59:31.302]                 }
[17:59:31.302]                 NAMES <- toupper(removed)
[17:59:31.302]                 for (kk in seq_along(NAMES)) {
[17:59:31.302]                   name <- removed[[kk]]
[17:59:31.302]                   NAME <- NAMES[[kk]]
[17:59:31.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.302]                     next
[17:59:31.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.302]                 }
[17:59:31.302]                 if (length(args) > 0) 
[17:59:31.302]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.302]             }
[17:59:31.302]             else {
[17:59:31.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.302]             }
[17:59:31.302]             {
[17:59:31.302]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.302]                   0L) {
[17:59:31.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.302]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.302]                   base::options(opts)
[17:59:31.302]                 }
[17:59:31.302]                 {
[17:59:31.302]                   {
[17:59:31.302]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.302]                     NULL
[17:59:31.302]                   }
[17:59:31.302]                   options(future.plan = NULL)
[17:59:31.302]                   if (is.na(NA_character_)) 
[17:59:31.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.302]                     .init = FALSE)
[17:59:31.302]                 }
[17:59:31.302]             }
[17:59:31.302]         }
[17:59:31.302]     })
[17:59:31.302]     if (TRUE) {
[17:59:31.302]         base::sink(type = "output", split = FALSE)
[17:59:31.302]         if (TRUE) {
[17:59:31.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.302]         }
[17:59:31.302]         else {
[17:59:31.302]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.302]         }
[17:59:31.302]         base::close(...future.stdout)
[17:59:31.302]         ...future.stdout <- NULL
[17:59:31.302]     }
[17:59:31.302]     ...future.result$conditions <- ...future.conditions
[17:59:31.302]     ...future.result$finished <- base::Sys.time()
[17:59:31.302]     ...future.result
[17:59:31.302] }
[17:59:31.307] assign_globals() ...
[17:59:31.307] List of 5
[17:59:31.307]  $ ...future.FUN            :function (x, ...)  
[17:59:31.307]  $ future.call.arguments    : list()
[17:59:31.307]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.307]  $ ...future.elements_ii    :List of 2
[17:59:31.307]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:31.307]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:31.307]  $ ...future.seeds_ii       : NULL
[17:59:31.307]  $ ...future.globals.maxSize: NULL
[17:59:31.307]  - attr(*, "where")=List of 5
[17:59:31.307]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.307]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.307]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.307]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.307]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.307]  - attr(*, "resolved")= logi FALSE
[17:59:31.307]  - attr(*, "total_size")= num 1240
[17:59:31.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.307]  - attr(*, "already-done")= logi TRUE
[17:59:31.323] - copied ‘...future.FUN’ to environment
[17:59:31.323] - copied ‘future.call.arguments’ to environment
[17:59:31.324] - copied ‘...future.elements_ii’ to environment
[17:59:31.324] - copied ‘...future.seeds_ii’ to environment
[17:59:31.324] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.325] assign_globals() ... done
[17:59:31.325] requestCore(): workers = 2
[17:59:31.336] MulticoreFuture started
[17:59:31.337] - Launch lazy future ... done
[17:59:31.337] run() for ‘MulticoreFuture’ ... done
[17:59:31.338] Created future:
[17:59:31.338] plan(): Setting new future strategy stack:
[17:59:31.338] List of future strategies:
[17:59:31.338] 1. sequential:
[17:59:31.338]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.338]    - tweaked: FALSE
[17:59:31.338]    - call: NULL
[17:59:31.341] plan(): nbrOfWorkers() = 1
[17:59:31.347] plan(): Setting new future strategy stack:
[17:59:31.347] List of future strategies:
[17:59:31.347] 1. multicore:
[17:59:31.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.347]    - tweaked: FALSE
[17:59:31.347]    - call: plan(strategy)
[17:59:31.338] MulticoreFuture:
[17:59:31.338] Label: ‘future_eapply-2’
[17:59:31.338] Expression:
[17:59:31.338] {
[17:59:31.338]     do.call(function(...) {
[17:59:31.338]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.338]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.338]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.338]             on.exit(options(oopts), add = TRUE)
[17:59:31.338]         }
[17:59:31.338]         {
[17:59:31.338]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.338]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.338]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.338]             })
[17:59:31.338]         }
[17:59:31.338]     }, args = future.call.arguments)
[17:59:31.338] }
[17:59:31.338] Lazy evaluation: FALSE
[17:59:31.338] Asynchronous evaluation: TRUE
[17:59:31.338] Local evaluation: TRUE
[17:59:31.338] Environment: R_GlobalEnv
[17:59:31.338] Capture standard output: TRUE
[17:59:31.338] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.338] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.338] Packages: <none>
[17:59:31.338] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.338] Resolved: FALSE
[17:59:31.338] Value: <not collected>
[17:59:31.338] Conditions captured: <none>
[17:59:31.338] Early signaling: FALSE
[17:59:31.338] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.338] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.356] Chunk #2 of 2 ... DONE
[17:59:31.356] plan(): nbrOfWorkers() = 2
[17:59:31.356] Launching 2 futures (chunks) ... DONE
[17:59:31.357] Resolving 2 futures (chunks) ...
[17:59:31.357] resolve() on list ...
[17:59:31.357]  recursive: 0
[17:59:31.358]  length: 2
[17:59:31.358] 
[17:59:31.359] Future #1
[17:59:31.360] result() for MulticoreFuture ...
[17:59:31.364] result() for MulticoreFuture ...
[17:59:31.364] result() for MulticoreFuture ... done
[17:59:31.364] result() for MulticoreFuture ... done
[17:59:31.365] result() for MulticoreFuture ...
[17:59:31.365] result() for MulticoreFuture ... done
[17:59:31.365] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:31.366] - nx: 2
[17:59:31.366] - relay: TRUE
[17:59:31.366] - stdout: TRUE
[17:59:31.367] - signal: TRUE
[17:59:31.367] - resignal: FALSE
[17:59:31.367] - force: TRUE
[17:59:31.368] - relayed: [n=2] FALSE, FALSE
[17:59:31.368] - queued futures: [n=2] FALSE, FALSE
[17:59:31.368]  - until=1
[17:59:31.369]  - relaying element #1
[17:59:31.369] result() for MulticoreFuture ...
[17:59:31.369] result() for MulticoreFuture ... done
[17:59:31.370] result() for MulticoreFuture ...
[17:59:31.370] result() for MulticoreFuture ... done
[17:59:31.370] result() for MulticoreFuture ...
[17:59:31.371] result() for MulticoreFuture ... done
[17:59:31.371] result() for MulticoreFuture ...
[17:59:31.371] result() for MulticoreFuture ... done
[17:59:31.372] - relayed: [n=2] TRUE, FALSE
[17:59:31.372] - queued futures: [n=2] TRUE, FALSE
[17:59:31.372] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:31.372]  length: 1 (resolved future 1)
[17:59:31.373] Future #2
[17:59:31.373] result() for MulticoreFuture ...
[17:59:31.376] result() for MulticoreFuture ...
[17:59:31.376] result() for MulticoreFuture ... done
[17:59:31.388] result() for MulticoreFuture ... done
[17:59:31.389] result() for MulticoreFuture ...
[17:59:31.389] result() for MulticoreFuture ... done
[17:59:31.389] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:31.389] - nx: 2
[17:59:31.390] - relay: TRUE
[17:59:31.390] - stdout: TRUE
[17:59:31.390] - signal: TRUE
[17:59:31.390] - resignal: FALSE
[17:59:31.391] - force: TRUE
[17:59:31.391] - relayed: [n=2] TRUE, FALSE
[17:59:31.391] - queued futures: [n=2] TRUE, FALSE
[17:59:31.391]  - until=2
[17:59:31.392]  - relaying element #2
[17:59:31.392] result() for MulticoreFuture ...
[17:59:31.392] result() for MulticoreFuture ... done
[17:59:31.392] result() for MulticoreFuture ...
[17:59:31.393] result() for MulticoreFuture ... done
[17:59:31.393] result() for MulticoreFuture ...
[17:59:31.393] result() for MulticoreFuture ... done
[17:59:31.394] result() for MulticoreFuture ...
[17:59:31.394] result() for MulticoreFuture ... done
[17:59:31.394] - relayed: [n=2] TRUE, TRUE
[17:59:31.394] - queued futures: [n=2] TRUE, TRUE
[17:59:31.395] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:31.395]  length: 0 (resolved future 2)
[17:59:31.395] Relaying remaining futures
[17:59:31.396] signalConditionsASAP(NULL, pos=0) ...
[17:59:31.396] - nx: 2
[17:59:31.396] - relay: TRUE
[17:59:31.396] - stdout: TRUE
[17:59:31.397] - signal: TRUE
[17:59:31.397] - resignal: FALSE
[17:59:31.397] - force: TRUE
[17:59:31.397] - relayed: [n=2] TRUE, TRUE
[17:59:31.397] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:31.398] - relayed: [n=2] TRUE, TRUE
[17:59:31.398] - queued futures: [n=2] TRUE, TRUE
[17:59:31.398] signalConditionsASAP(NULL, pos=0) ... done
[17:59:31.399] resolve() on list ... DONE
[17:59:31.399] result() for MulticoreFuture ...
[17:59:31.399] result() for MulticoreFuture ... done
[17:59:31.399] result() for MulticoreFuture ...
[17:59:31.400] result() for MulticoreFuture ... done
[17:59:31.400] result() for MulticoreFuture ...
[17:59:31.400] result() for MulticoreFuture ... done
[17:59:31.400] result() for MulticoreFuture ...
[17:59:31.401] result() for MulticoreFuture ... done
[17:59:31.401]  - Number of value chunks collected: 2
[17:59:31.401] Resolving 2 futures (chunks) ... DONE
[17:59:31.401] Reducing values from 2 chunks ...
[17:59:31.401]  - Number of values collected after concatenation: 3
[17:59:31.402]  - Number of values expected: 3
[17:59:31.402] Reducing values from 2 chunks ... DONE
[17:59:31.402] future_lapply() ... DONE
[17:59:31.404] future_lapply() ...
[17:59:31.411] Number of chunks: 2
[17:59:31.411] getGlobalsAndPackagesXApply() ...
[17:59:31.412]  - future.globals: TRUE
[17:59:31.412] getGlobalsAndPackages() ...
[17:59:31.412] Searching for globals...
[17:59:31.415] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:31.415] Searching for globals ... DONE
[17:59:31.415] Resolving globals: FALSE
[17:59:31.416] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:31.417] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:31.417] - globals: [1] ‘FUN’
[17:59:31.417] - packages: [1] ‘stats’
[17:59:31.418] getGlobalsAndPackages() ... DONE
[17:59:31.418]  - globals found/used: [n=1] ‘FUN’
[17:59:31.418]  - needed namespaces: [n=1] ‘stats’
[17:59:31.418] Finding globals ... DONE
[17:59:31.419]  - use_args: TRUE
[17:59:31.419]  - Getting '...' globals ...
[17:59:31.420] resolve() on list ...
[17:59:31.420]  recursive: 0
[17:59:31.420]  length: 1
[17:59:31.420]  elements: ‘...’
[17:59:31.421]  length: 0 (resolved future 1)
[17:59:31.421] resolve() on list ... DONE
[17:59:31.421]    - '...' content: [n=1] ‘probs’
[17:59:31.421] List of 1
[17:59:31.421]  $ ...:List of 1
[17:59:31.421]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:31.421]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.421]  - attr(*, "where")=List of 1
[17:59:31.421]   ..$ ...:<environment: 0x58d4c292f6b0> 
[17:59:31.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.421]  - attr(*, "resolved")= logi TRUE
[17:59:31.421]  - attr(*, "total_size")= num NA
[17:59:31.428]  - Getting '...' globals ... DONE
[17:59:31.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:31.429] List of 2
[17:59:31.429]  $ ...future.FUN:function (x, ...)  
[17:59:31.429]  $ ...          :List of 1
[17:59:31.429]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:31.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.429]  - attr(*, "where")=List of 2
[17:59:31.429]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:31.429]   ..$ ...          :<environment: 0x58d4c292f6b0> 
[17:59:31.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.429]  - attr(*, "resolved")= logi FALSE
[17:59:31.429]  - attr(*, "total_size")= num 1328
[17:59:31.435] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:31.435] getGlobalsAndPackagesXApply() ... DONE
[17:59:31.436] Number of futures (= number of chunks): 2
[17:59:31.436] Launching 2 futures (chunks) ...
[17:59:31.436] Chunk #1 of 2 ...
[17:59:31.436]  - Finding globals in 'X' for chunk #1 ...
[17:59:31.437] getGlobalsAndPackages() ...
[17:59:31.437] Searching for globals...
[17:59:31.438] 
[17:59:31.438] Searching for globals ... DONE
[17:59:31.438] - globals: [0] <none>
[17:59:31.438] getGlobalsAndPackages() ... DONE
[17:59:31.439]    + additional globals found: [n=0] 
[17:59:31.439]    + additional namespaces needed: [n=0] 
[17:59:31.439]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:31.439]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.439]  - seeds: <none>
[17:59:31.440]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.440] getGlobalsAndPackages() ...
[17:59:31.440] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.440] Resolving globals: FALSE
[17:59:31.440] Tweak future expression to call with '...' arguments ...
[17:59:31.441] {
[17:59:31.441]     do.call(function(...) {
[17:59:31.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.441]             on.exit(options(oopts), add = TRUE)
[17:59:31.441]         }
[17:59:31.441]         {
[17:59:31.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.441]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.441]             })
[17:59:31.441]         }
[17:59:31.441]     }, args = future.call.arguments)
[17:59:31.441] }
[17:59:31.441] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.442] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.442] - packages: [1] ‘stats’
[17:59:31.442] getGlobalsAndPackages() ... DONE
[17:59:31.443] run() for ‘Future’ ...
[17:59:31.443] - state: ‘created’
[17:59:31.443] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.453]   - Field: ‘label’
[17:59:31.453]   - Field: ‘local’
[17:59:31.453]   - Field: ‘owner’
[17:59:31.453]   - Field: ‘envir’
[17:59:31.453]   - Field: ‘workers’
[17:59:31.454]   - Field: ‘packages’
[17:59:31.454]   - Field: ‘gc’
[17:59:31.454]   - Field: ‘job’
[17:59:31.454]   - Field: ‘conditions’
[17:59:31.454]   - Field: ‘expr’
[17:59:31.455]   - Field: ‘uuid’
[17:59:31.455]   - Field: ‘seed’
[17:59:31.455]   - Field: ‘version’
[17:59:31.455]   - Field: ‘result’
[17:59:31.455]   - Field: ‘asynchronous’
[17:59:31.456]   - Field: ‘calls’
[17:59:31.456]   - Field: ‘globals’
[17:59:31.456]   - Field: ‘stdout’
[17:59:31.456]   - Field: ‘earlySignal’
[17:59:31.456]   - Field: ‘lazy’
[17:59:31.457]   - Field: ‘state’
[17:59:31.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.457] - Launch lazy future ...
[17:59:31.458] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.458] Packages needed by future strategies (n = 0): <none>
[17:59:31.459] {
[17:59:31.459]     {
[17:59:31.459]         {
[17:59:31.459]             ...future.startTime <- base::Sys.time()
[17:59:31.459]             {
[17:59:31.459]                 {
[17:59:31.459]                   {
[17:59:31.459]                     {
[17:59:31.459]                       {
[17:59:31.459]                         base::local({
[17:59:31.459]                           has_future <- base::requireNamespace("future", 
[17:59:31.459]                             quietly = TRUE)
[17:59:31.459]                           if (has_future) {
[17:59:31.459]                             ns <- base::getNamespace("future")
[17:59:31.459]                             version <- ns[[".package"]][["version"]]
[17:59:31.459]                             if (is.null(version)) 
[17:59:31.459]                               version <- utils::packageVersion("future")
[17:59:31.459]                           }
[17:59:31.459]                           else {
[17:59:31.459]                             version <- NULL
[17:59:31.459]                           }
[17:59:31.459]                           if (!has_future || version < "1.8.0") {
[17:59:31.459]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.459]                               "", base::R.version$version.string), 
[17:59:31.459]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:31.459]                                 base::R.version$platform, 8 * 
[17:59:31.459]                                   base::.Machine$sizeof.pointer), 
[17:59:31.459]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.459]                                 "release", "version")], collapse = " "), 
[17:59:31.459]                               hostname = base::Sys.info()[["nodename"]])
[17:59:31.459]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.459]                               info)
[17:59:31.459]                             info <- base::paste(info, collapse = "; ")
[17:59:31.459]                             if (!has_future) {
[17:59:31.459]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.459]                                 info)
[17:59:31.459]                             }
[17:59:31.459]                             else {
[17:59:31.459]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.459]                                 info, version)
[17:59:31.459]                             }
[17:59:31.459]                             base::stop(msg)
[17:59:31.459]                           }
[17:59:31.459]                         })
[17:59:31.459]                       }
[17:59:31.459]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.459]                       base::options(mc.cores = 1L)
[17:59:31.459]                     }
[17:59:31.459]                     base::local({
[17:59:31.459]                       for (pkg in "stats") {
[17:59:31.459]                         base::loadNamespace(pkg)
[17:59:31.459]                         base::library(pkg, character.only = TRUE)
[17:59:31.459]                       }
[17:59:31.459]                     })
[17:59:31.459]                   }
[17:59:31.459]                   ...future.strategy.old <- future::plan("list")
[17:59:31.459]                   options(future.plan = NULL)
[17:59:31.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.459]                 }
[17:59:31.459]                 ...future.workdir <- getwd()
[17:59:31.459]             }
[17:59:31.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.459]         }
[17:59:31.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.459]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.459]             base::names(...future.oldOptions))
[17:59:31.459]     }
[17:59:31.459]     if (FALSE) {
[17:59:31.459]     }
[17:59:31.459]     else {
[17:59:31.459]         if (TRUE) {
[17:59:31.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.459]                 open = "w")
[17:59:31.459]         }
[17:59:31.459]         else {
[17:59:31.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.459]         }
[17:59:31.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.459]             base::sink(type = "output", split = FALSE)
[17:59:31.459]             base::close(...future.stdout)
[17:59:31.459]         }, add = TRUE)
[17:59:31.459]     }
[17:59:31.459]     ...future.frame <- base::sys.nframe()
[17:59:31.459]     ...future.conditions <- base::list()
[17:59:31.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.459]     if (FALSE) {
[17:59:31.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.459]     }
[17:59:31.459]     ...future.result <- base::tryCatch({
[17:59:31.459]         base::withCallingHandlers({
[17:59:31.459]             ...future.value <- base::withVisible(base::local({
[17:59:31.459]                 withCallingHandlers({
[17:59:31.459]                   {
[17:59:31.459]                     do.call(function(...) {
[17:59:31.459]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.459]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.459]                         ...future.globals.maxSize)) {
[17:59:31.459]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.459]                         on.exit(options(oopts), add = TRUE)
[17:59:31.459]                       }
[17:59:31.459]                       {
[17:59:31.459]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.459]                           FUN = function(jj) {
[17:59:31.459]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.459]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.459]                           })
[17:59:31.459]                       }
[17:59:31.459]                     }, args = future.call.arguments)
[17:59:31.459]                   }
[17:59:31.459]                 }, immediateCondition = function(cond) {
[17:59:31.459]                   save_rds <- function (object, pathname, ...) 
[17:59:31.459]                   {
[17:59:31.459]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.459]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.459]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.459]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.459]                         fi_tmp[["mtime"]])
[17:59:31.459]                     }
[17:59:31.459]                     tryCatch({
[17:59:31.459]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.459]                     }, error = function(ex) {
[17:59:31.459]                       msg <- conditionMessage(ex)
[17:59:31.459]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.459]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.459]                         fi_tmp[["mtime"]], msg)
[17:59:31.459]                       ex$message <- msg
[17:59:31.459]                       stop(ex)
[17:59:31.459]                     })
[17:59:31.459]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.459]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.459]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.459]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.459]                       fi <- file.info(pathname)
[17:59:31.459]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.459]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.459]                         fi[["size"]], fi[["mtime"]])
[17:59:31.459]                       stop(msg)
[17:59:31.459]                     }
[17:59:31.459]                     invisible(pathname)
[17:59:31.459]                   }
[17:59:31.459]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.459]                     rootPath = tempdir()) 
[17:59:31.459]                   {
[17:59:31.459]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.459]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.459]                       tmpdir = path, fileext = ".rds")
[17:59:31.459]                     save_rds(obj, file)
[17:59:31.459]                   }
[17:59:31.459]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.459]                   {
[17:59:31.459]                     inherits <- base::inherits
[17:59:31.459]                     invokeRestart <- base::invokeRestart
[17:59:31.459]                     is.null <- base::is.null
[17:59:31.459]                     muffled <- FALSE
[17:59:31.459]                     if (inherits(cond, "message")) {
[17:59:31.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.459]                       if (muffled) 
[17:59:31.459]                         invokeRestart("muffleMessage")
[17:59:31.459]                     }
[17:59:31.459]                     else if (inherits(cond, "warning")) {
[17:59:31.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.459]                       if (muffled) 
[17:59:31.459]                         invokeRestart("muffleWarning")
[17:59:31.459]                     }
[17:59:31.459]                     else if (inherits(cond, "condition")) {
[17:59:31.459]                       if (!is.null(pattern)) {
[17:59:31.459]                         computeRestarts <- base::computeRestarts
[17:59:31.459]                         grepl <- base::grepl
[17:59:31.459]                         restarts <- computeRestarts(cond)
[17:59:31.459]                         for (restart in restarts) {
[17:59:31.459]                           name <- restart$name
[17:59:31.459]                           if (is.null(name)) 
[17:59:31.459]                             next
[17:59:31.459]                           if (!grepl(pattern, name)) 
[17:59:31.459]                             next
[17:59:31.459]                           invokeRestart(restart)
[17:59:31.459]                           muffled <- TRUE
[17:59:31.459]                           break
[17:59:31.459]                         }
[17:59:31.459]                       }
[17:59:31.459]                     }
[17:59:31.459]                     invisible(muffled)
[17:59:31.459]                   }
[17:59:31.459]                   muffleCondition(cond)
[17:59:31.459]                 })
[17:59:31.459]             }))
[17:59:31.459]             future::FutureResult(value = ...future.value$value, 
[17:59:31.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.459]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.459]                     ...future.globalenv.names))
[17:59:31.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.459]         }, condition = base::local({
[17:59:31.459]             c <- base::c
[17:59:31.459]             inherits <- base::inherits
[17:59:31.459]             invokeRestart <- base::invokeRestart
[17:59:31.459]             length <- base::length
[17:59:31.459]             list <- base::list
[17:59:31.459]             seq.int <- base::seq.int
[17:59:31.459]             signalCondition <- base::signalCondition
[17:59:31.459]             sys.calls <- base::sys.calls
[17:59:31.459]             `[[` <- base::`[[`
[17:59:31.459]             `+` <- base::`+`
[17:59:31.459]             `<<-` <- base::`<<-`
[17:59:31.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.459]                   3L)]
[17:59:31.459]             }
[17:59:31.459]             function(cond) {
[17:59:31.459]                 is_error <- inherits(cond, "error")
[17:59:31.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.459]                   NULL)
[17:59:31.459]                 if (is_error) {
[17:59:31.459]                   sessionInformation <- function() {
[17:59:31.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.459]                       search = base::search(), system = base::Sys.info())
[17:59:31.459]                   }
[17:59:31.459]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.459]                     cond$call), session = sessionInformation(), 
[17:59:31.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.459]                   signalCondition(cond)
[17:59:31.459]                 }
[17:59:31.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.459]                 "immediateCondition"))) {
[17:59:31.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.459]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.459]                   if (TRUE && !signal) {
[17:59:31.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.459]                     {
[17:59:31.459]                       inherits <- base::inherits
[17:59:31.459]                       invokeRestart <- base::invokeRestart
[17:59:31.459]                       is.null <- base::is.null
[17:59:31.459]                       muffled <- FALSE
[17:59:31.459]                       if (inherits(cond, "message")) {
[17:59:31.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.459]                         if (muffled) 
[17:59:31.459]                           invokeRestart("muffleMessage")
[17:59:31.459]                       }
[17:59:31.459]                       else if (inherits(cond, "warning")) {
[17:59:31.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.459]                         if (muffled) 
[17:59:31.459]                           invokeRestart("muffleWarning")
[17:59:31.459]                       }
[17:59:31.459]                       else if (inherits(cond, "condition")) {
[17:59:31.459]                         if (!is.null(pattern)) {
[17:59:31.459]                           computeRestarts <- base::computeRestarts
[17:59:31.459]                           grepl <- base::grepl
[17:59:31.459]                           restarts <- computeRestarts(cond)
[17:59:31.459]                           for (restart in restarts) {
[17:59:31.459]                             name <- restart$name
[17:59:31.459]                             if (is.null(name)) 
[17:59:31.459]                               next
[17:59:31.459]                             if (!grepl(pattern, name)) 
[17:59:31.459]                               next
[17:59:31.459]                             invokeRestart(restart)
[17:59:31.459]                             muffled <- TRUE
[17:59:31.459]                             break
[17:59:31.459]                           }
[17:59:31.459]                         }
[17:59:31.459]                       }
[17:59:31.459]                       invisible(muffled)
[17:59:31.459]                     }
[17:59:31.459]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.459]                   }
[17:59:31.459]                 }
[17:59:31.459]                 else {
[17:59:31.459]                   if (TRUE) {
[17:59:31.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.459]                     {
[17:59:31.459]                       inherits <- base::inherits
[17:59:31.459]                       invokeRestart <- base::invokeRestart
[17:59:31.459]                       is.null <- base::is.null
[17:59:31.459]                       muffled <- FALSE
[17:59:31.459]                       if (inherits(cond, "message")) {
[17:59:31.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.459]                         if (muffled) 
[17:59:31.459]                           invokeRestart("muffleMessage")
[17:59:31.459]                       }
[17:59:31.459]                       else if (inherits(cond, "warning")) {
[17:59:31.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.459]                         if (muffled) 
[17:59:31.459]                           invokeRestart("muffleWarning")
[17:59:31.459]                       }
[17:59:31.459]                       else if (inherits(cond, "condition")) {
[17:59:31.459]                         if (!is.null(pattern)) {
[17:59:31.459]                           computeRestarts <- base::computeRestarts
[17:59:31.459]                           grepl <- base::grepl
[17:59:31.459]                           restarts <- computeRestarts(cond)
[17:59:31.459]                           for (restart in restarts) {
[17:59:31.459]                             name <- restart$name
[17:59:31.459]                             if (is.null(name)) 
[17:59:31.459]                               next
[17:59:31.459]                             if (!grepl(pattern, name)) 
[17:59:31.459]                               next
[17:59:31.459]                             invokeRestart(restart)
[17:59:31.459]                             muffled <- TRUE
[17:59:31.459]                             break
[17:59:31.459]                           }
[17:59:31.459]                         }
[17:59:31.459]                       }
[17:59:31.459]                       invisible(muffled)
[17:59:31.459]                     }
[17:59:31.459]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.459]                   }
[17:59:31.459]                 }
[17:59:31.459]             }
[17:59:31.459]         }))
[17:59:31.459]     }, error = function(ex) {
[17:59:31.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.459]                 ...future.rng), started = ...future.startTime, 
[17:59:31.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.459]             version = "1.8"), class = "FutureResult")
[17:59:31.459]     }, finally = {
[17:59:31.459]         if (!identical(...future.workdir, getwd())) 
[17:59:31.459]             setwd(...future.workdir)
[17:59:31.459]         {
[17:59:31.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.459]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.459]             }
[17:59:31.459]             base::options(...future.oldOptions)
[17:59:31.459]             if (.Platform$OS.type == "windows") {
[17:59:31.459]                 old_names <- names(...future.oldEnvVars)
[17:59:31.459]                 envs <- base::Sys.getenv()
[17:59:31.459]                 names <- names(envs)
[17:59:31.459]                 common <- intersect(names, old_names)
[17:59:31.459]                 added <- setdiff(names, old_names)
[17:59:31.459]                 removed <- setdiff(old_names, names)
[17:59:31.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.459]                   envs[common]]
[17:59:31.459]                 NAMES <- toupper(changed)
[17:59:31.459]                 args <- list()
[17:59:31.459]                 for (kk in seq_along(NAMES)) {
[17:59:31.459]                   name <- changed[[kk]]
[17:59:31.459]                   NAME <- NAMES[[kk]]
[17:59:31.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.459]                     next
[17:59:31.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.459]                 }
[17:59:31.459]                 NAMES <- toupper(added)
[17:59:31.459]                 for (kk in seq_along(NAMES)) {
[17:59:31.459]                   name <- added[[kk]]
[17:59:31.459]                   NAME <- NAMES[[kk]]
[17:59:31.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.459]                     next
[17:59:31.459]                   args[[name]] <- ""
[17:59:31.459]                 }
[17:59:31.459]                 NAMES <- toupper(removed)
[17:59:31.459]                 for (kk in seq_along(NAMES)) {
[17:59:31.459]                   name <- removed[[kk]]
[17:59:31.459]                   NAME <- NAMES[[kk]]
[17:59:31.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.459]                     next
[17:59:31.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.459]                 }
[17:59:31.459]                 if (length(args) > 0) 
[17:59:31.459]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.459]             }
[17:59:31.459]             else {
[17:59:31.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.459]             }
[17:59:31.459]             {
[17:59:31.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.459]                   0L) {
[17:59:31.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.459]                   base::options(opts)
[17:59:31.459]                 }
[17:59:31.459]                 {
[17:59:31.459]                   {
[17:59:31.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.459]                     NULL
[17:59:31.459]                   }
[17:59:31.459]                   options(future.plan = NULL)
[17:59:31.459]                   if (is.na(NA_character_)) 
[17:59:31.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.459]                     .init = FALSE)
[17:59:31.459]                 }
[17:59:31.459]             }
[17:59:31.459]         }
[17:59:31.459]     })
[17:59:31.459]     if (TRUE) {
[17:59:31.459]         base::sink(type = "output", split = FALSE)
[17:59:31.459]         if (TRUE) {
[17:59:31.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.459]         }
[17:59:31.459]         else {
[17:59:31.459]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.459]         }
[17:59:31.459]         base::close(...future.stdout)
[17:59:31.459]         ...future.stdout <- NULL
[17:59:31.459]     }
[17:59:31.459]     ...future.result$conditions <- ...future.conditions
[17:59:31.459]     ...future.result$finished <- base::Sys.time()
[17:59:31.459]     ...future.result
[17:59:31.459] }
[17:59:31.463] assign_globals() ...
[17:59:31.463] List of 5
[17:59:31.463]  $ ...future.FUN            :function (x, ...)  
[17:59:31.463]  $ future.call.arguments    :List of 1
[17:59:31.463]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:31.463]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.463]  $ ...future.elements_ii    :List of 1
[17:59:31.463]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:59:31.463]  $ ...future.seeds_ii       : NULL
[17:59:31.463]  $ ...future.globals.maxSize: NULL
[17:59:31.463]  - attr(*, "where")=List of 5
[17:59:31.463]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.463]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.463]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.463]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.463]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.463]  - attr(*, "resolved")= logi FALSE
[17:59:31.463]  - attr(*, "total_size")= num 1328
[17:59:31.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.463]  - attr(*, "already-done")= logi TRUE
[17:59:31.474] - copied ‘...future.FUN’ to environment
[17:59:31.474] - copied ‘future.call.arguments’ to environment
[17:59:31.474] - copied ‘...future.elements_ii’ to environment
[17:59:31.474] - copied ‘...future.seeds_ii’ to environment
[17:59:31.474] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.475] assign_globals() ... done
[17:59:31.475] requestCore(): workers = 2
[17:59:31.478] MulticoreFuture started
[17:59:31.479] - Launch lazy future ... done
[17:59:31.479] run() for ‘MulticoreFuture’ ... done
[17:59:31.480] Created future:
[17:59:31.481] plan(): Setting new future strategy stack:
[17:59:31.481] List of future strategies:
[17:59:31.481] 1. sequential:
[17:59:31.481]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.481]    - tweaked: FALSE
[17:59:31.481]    - call: NULL
[17:59:31.483] plan(): nbrOfWorkers() = 1
[17:59:31.488] plan(): Setting new future strategy stack:
[17:59:31.489] List of future strategies:
[17:59:31.489] 1. multicore:
[17:59:31.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.489]    - tweaked: FALSE
[17:59:31.489]    - call: plan(strategy)
[17:59:31.480] MulticoreFuture:
[17:59:31.480] Label: ‘future_eapply-1’
[17:59:31.480] Expression:
[17:59:31.480] {
[17:59:31.480]     do.call(function(...) {
[17:59:31.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.480]             on.exit(options(oopts), add = TRUE)
[17:59:31.480]         }
[17:59:31.480]         {
[17:59:31.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.480]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.480]             })
[17:59:31.480]         }
[17:59:31.480]     }, args = future.call.arguments)
[17:59:31.480] }
[17:59:31.480] Lazy evaluation: FALSE
[17:59:31.480] Asynchronous evaluation: TRUE
[17:59:31.480] Local evaluation: TRUE
[17:59:31.480] Environment: R_GlobalEnv
[17:59:31.480] Capture standard output: TRUE
[17:59:31.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.480] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.480] Packages: 1 packages (‘stats’)
[17:59:31.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.480] Resolved: FALSE
[17:59:31.480] Value: <not collected>
[17:59:31.480] Conditions captured: <none>
[17:59:31.480] Early signaling: FALSE
[17:59:31.480] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.480] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.496] Chunk #1 of 2 ... DONE
[17:59:31.496] Chunk #2 of 2 ...
[17:59:31.497]  - Finding globals in 'X' for chunk #2 ...
[17:59:31.497] getGlobalsAndPackages() ...
[17:59:31.497] Searching for globals...
[17:59:31.498] 
[17:59:31.499] Searching for globals ... DONE
[17:59:31.499] plan(): nbrOfWorkers() = 2
[17:59:31.499] - globals: [0] <none>
[17:59:31.499] getGlobalsAndPackages() ... DONE
[17:59:31.499]    + additional globals found: [n=0] 
[17:59:31.500]    + additional namespaces needed: [n=0] 
[17:59:31.500]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:31.500]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.500]  - seeds: <none>
[17:59:31.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.501] getGlobalsAndPackages() ...
[17:59:31.501] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.502] Resolving globals: FALSE
[17:59:31.502] Tweak future expression to call with '...' arguments ...
[17:59:31.502] {
[17:59:31.502]     do.call(function(...) {
[17:59:31.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.502]             on.exit(options(oopts), add = TRUE)
[17:59:31.502]         }
[17:59:31.502]         {
[17:59:31.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.502]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.502]             })
[17:59:31.502]         }
[17:59:31.502]     }, args = future.call.arguments)
[17:59:31.502] }
[17:59:31.503] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.504] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.505] - packages: [1] ‘stats’
[17:59:31.505] getGlobalsAndPackages() ... DONE
[17:59:31.506] run() for ‘Future’ ...
[17:59:31.506] - state: ‘created’
[17:59:31.507] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.515] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.516]   - Field: ‘label’
[17:59:31.516]   - Field: ‘local’
[17:59:31.517]   - Field: ‘owner’
[17:59:31.517]   - Field: ‘envir’
[17:59:31.517]   - Field: ‘workers’
[17:59:31.518]   - Field: ‘packages’
[17:59:31.518]   - Field: ‘gc’
[17:59:31.518]   - Field: ‘job’
[17:59:31.519]   - Field: ‘conditions’
[17:59:31.519]   - Field: ‘expr’
[17:59:31.519]   - Field: ‘uuid’
[17:59:31.520]   - Field: ‘seed’
[17:59:31.520]   - Field: ‘version’
[17:59:31.520]   - Field: ‘result’
[17:59:31.520]   - Field: ‘asynchronous’
[17:59:31.521]   - Field: ‘calls’
[17:59:31.521]   - Field: ‘globals’
[17:59:31.521]   - Field: ‘stdout’
[17:59:31.522]   - Field: ‘earlySignal’
[17:59:31.522]   - Field: ‘lazy’
[17:59:31.522]   - Field: ‘state’
[17:59:31.522] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.523] - Launch lazy future ...
[17:59:31.524] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.524] Packages needed by future strategies (n = 0): <none>
[17:59:31.526] {
[17:59:31.526]     {
[17:59:31.526]         {
[17:59:31.526]             ...future.startTime <- base::Sys.time()
[17:59:31.526]             {
[17:59:31.526]                 {
[17:59:31.526]                   {
[17:59:31.526]                     {
[17:59:31.526]                       {
[17:59:31.526]                         base::local({
[17:59:31.526]                           has_future <- base::requireNamespace("future", 
[17:59:31.526]                             quietly = TRUE)
[17:59:31.526]                           if (has_future) {
[17:59:31.526]                             ns <- base::getNamespace("future")
[17:59:31.526]                             version <- ns[[".package"]][["version"]]
[17:59:31.526]                             if (is.null(version)) 
[17:59:31.526]                               version <- utils::packageVersion("future")
[17:59:31.526]                           }
[17:59:31.526]                           else {
[17:59:31.526]                             version <- NULL
[17:59:31.526]                           }
[17:59:31.526]                           if (!has_future || version < "1.8.0") {
[17:59:31.526]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.526]                               "", base::R.version$version.string), 
[17:59:31.526]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:31.526]                                 base::R.version$platform, 8 * 
[17:59:31.526]                                   base::.Machine$sizeof.pointer), 
[17:59:31.526]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.526]                                 "release", "version")], collapse = " "), 
[17:59:31.526]                               hostname = base::Sys.info()[["nodename"]])
[17:59:31.526]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.526]                               info)
[17:59:31.526]                             info <- base::paste(info, collapse = "; ")
[17:59:31.526]                             if (!has_future) {
[17:59:31.526]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.526]                                 info)
[17:59:31.526]                             }
[17:59:31.526]                             else {
[17:59:31.526]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.526]                                 info, version)
[17:59:31.526]                             }
[17:59:31.526]                             base::stop(msg)
[17:59:31.526]                           }
[17:59:31.526]                         })
[17:59:31.526]                       }
[17:59:31.526]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.526]                       base::options(mc.cores = 1L)
[17:59:31.526]                     }
[17:59:31.526]                     base::local({
[17:59:31.526]                       for (pkg in "stats") {
[17:59:31.526]                         base::loadNamespace(pkg)
[17:59:31.526]                         base::library(pkg, character.only = TRUE)
[17:59:31.526]                       }
[17:59:31.526]                     })
[17:59:31.526]                   }
[17:59:31.526]                   ...future.strategy.old <- future::plan("list")
[17:59:31.526]                   options(future.plan = NULL)
[17:59:31.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.526]                 }
[17:59:31.526]                 ...future.workdir <- getwd()
[17:59:31.526]             }
[17:59:31.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.526]         }
[17:59:31.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.526]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.526]             base::names(...future.oldOptions))
[17:59:31.526]     }
[17:59:31.526]     if (FALSE) {
[17:59:31.526]     }
[17:59:31.526]     else {
[17:59:31.526]         if (TRUE) {
[17:59:31.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.526]                 open = "w")
[17:59:31.526]         }
[17:59:31.526]         else {
[17:59:31.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.526]         }
[17:59:31.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.526]             base::sink(type = "output", split = FALSE)
[17:59:31.526]             base::close(...future.stdout)
[17:59:31.526]         }, add = TRUE)
[17:59:31.526]     }
[17:59:31.526]     ...future.frame <- base::sys.nframe()
[17:59:31.526]     ...future.conditions <- base::list()
[17:59:31.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.526]     if (FALSE) {
[17:59:31.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.526]     }
[17:59:31.526]     ...future.result <- base::tryCatch({
[17:59:31.526]         base::withCallingHandlers({
[17:59:31.526]             ...future.value <- base::withVisible(base::local({
[17:59:31.526]                 withCallingHandlers({
[17:59:31.526]                   {
[17:59:31.526]                     do.call(function(...) {
[17:59:31.526]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.526]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.526]                         ...future.globals.maxSize)) {
[17:59:31.526]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.526]                         on.exit(options(oopts), add = TRUE)
[17:59:31.526]                       }
[17:59:31.526]                       {
[17:59:31.526]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.526]                           FUN = function(jj) {
[17:59:31.526]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.526]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.526]                           })
[17:59:31.526]                       }
[17:59:31.526]                     }, args = future.call.arguments)
[17:59:31.526]                   }
[17:59:31.526]                 }, immediateCondition = function(cond) {
[17:59:31.526]                   save_rds <- function (object, pathname, ...) 
[17:59:31.526]                   {
[17:59:31.526]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.526]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.526]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.526]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.526]                         fi_tmp[["mtime"]])
[17:59:31.526]                     }
[17:59:31.526]                     tryCatch({
[17:59:31.526]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.526]                     }, error = function(ex) {
[17:59:31.526]                       msg <- conditionMessage(ex)
[17:59:31.526]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.526]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.526]                         fi_tmp[["mtime"]], msg)
[17:59:31.526]                       ex$message <- msg
[17:59:31.526]                       stop(ex)
[17:59:31.526]                     })
[17:59:31.526]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.526]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.526]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.526]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.526]                       fi <- file.info(pathname)
[17:59:31.526]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.526]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.526]                         fi[["size"]], fi[["mtime"]])
[17:59:31.526]                       stop(msg)
[17:59:31.526]                     }
[17:59:31.526]                     invisible(pathname)
[17:59:31.526]                   }
[17:59:31.526]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.526]                     rootPath = tempdir()) 
[17:59:31.526]                   {
[17:59:31.526]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.526]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.526]                       tmpdir = path, fileext = ".rds")
[17:59:31.526]                     save_rds(obj, file)
[17:59:31.526]                   }
[17:59:31.526]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.526]                   {
[17:59:31.526]                     inherits <- base::inherits
[17:59:31.526]                     invokeRestart <- base::invokeRestart
[17:59:31.526]                     is.null <- base::is.null
[17:59:31.526]                     muffled <- FALSE
[17:59:31.526]                     if (inherits(cond, "message")) {
[17:59:31.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.526]                       if (muffled) 
[17:59:31.526]                         invokeRestart("muffleMessage")
[17:59:31.526]                     }
[17:59:31.526]                     else if (inherits(cond, "warning")) {
[17:59:31.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.526]                       if (muffled) 
[17:59:31.526]                         invokeRestart("muffleWarning")
[17:59:31.526]                     }
[17:59:31.526]                     else if (inherits(cond, "condition")) {
[17:59:31.526]                       if (!is.null(pattern)) {
[17:59:31.526]                         computeRestarts <- base::computeRestarts
[17:59:31.526]                         grepl <- base::grepl
[17:59:31.526]                         restarts <- computeRestarts(cond)
[17:59:31.526]                         for (restart in restarts) {
[17:59:31.526]                           name <- restart$name
[17:59:31.526]                           if (is.null(name)) 
[17:59:31.526]                             next
[17:59:31.526]                           if (!grepl(pattern, name)) 
[17:59:31.526]                             next
[17:59:31.526]                           invokeRestart(restart)
[17:59:31.526]                           muffled <- TRUE
[17:59:31.526]                           break
[17:59:31.526]                         }
[17:59:31.526]                       }
[17:59:31.526]                     }
[17:59:31.526]                     invisible(muffled)
[17:59:31.526]                   }
[17:59:31.526]                   muffleCondition(cond)
[17:59:31.526]                 })
[17:59:31.526]             }))
[17:59:31.526]             future::FutureResult(value = ...future.value$value, 
[17:59:31.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.526]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.526]                     ...future.globalenv.names))
[17:59:31.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.526]         }, condition = base::local({
[17:59:31.526]             c <- base::c
[17:59:31.526]             inherits <- base::inherits
[17:59:31.526]             invokeRestart <- base::invokeRestart
[17:59:31.526]             length <- base::length
[17:59:31.526]             list <- base::list
[17:59:31.526]             seq.int <- base::seq.int
[17:59:31.526]             signalCondition <- base::signalCondition
[17:59:31.526]             sys.calls <- base::sys.calls
[17:59:31.526]             `[[` <- base::`[[`
[17:59:31.526]             `+` <- base::`+`
[17:59:31.526]             `<<-` <- base::`<<-`
[17:59:31.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.526]                   3L)]
[17:59:31.526]             }
[17:59:31.526]             function(cond) {
[17:59:31.526]                 is_error <- inherits(cond, "error")
[17:59:31.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.526]                   NULL)
[17:59:31.526]                 if (is_error) {
[17:59:31.526]                   sessionInformation <- function() {
[17:59:31.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.526]                       search = base::search(), system = base::Sys.info())
[17:59:31.526]                   }
[17:59:31.526]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.526]                     cond$call), session = sessionInformation(), 
[17:59:31.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.526]                   signalCondition(cond)
[17:59:31.526]                 }
[17:59:31.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.526]                 "immediateCondition"))) {
[17:59:31.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.526]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.526]                   if (TRUE && !signal) {
[17:59:31.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.526]                     {
[17:59:31.526]                       inherits <- base::inherits
[17:59:31.526]                       invokeRestart <- base::invokeRestart
[17:59:31.526]                       is.null <- base::is.null
[17:59:31.526]                       muffled <- FALSE
[17:59:31.526]                       if (inherits(cond, "message")) {
[17:59:31.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.526]                         if (muffled) 
[17:59:31.526]                           invokeRestart("muffleMessage")
[17:59:31.526]                       }
[17:59:31.526]                       else if (inherits(cond, "warning")) {
[17:59:31.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.526]                         if (muffled) 
[17:59:31.526]                           invokeRestart("muffleWarning")
[17:59:31.526]                       }
[17:59:31.526]                       else if (inherits(cond, "condition")) {
[17:59:31.526]                         if (!is.null(pattern)) {
[17:59:31.526]                           computeRestarts <- base::computeRestarts
[17:59:31.526]                           grepl <- base::grepl
[17:59:31.526]                           restarts <- computeRestarts(cond)
[17:59:31.526]                           for (restart in restarts) {
[17:59:31.526]                             name <- restart$name
[17:59:31.526]                             if (is.null(name)) 
[17:59:31.526]                               next
[17:59:31.526]                             if (!grepl(pattern, name)) 
[17:59:31.526]                               next
[17:59:31.526]                             invokeRestart(restart)
[17:59:31.526]                             muffled <- TRUE
[17:59:31.526]                             break
[17:59:31.526]                           }
[17:59:31.526]                         }
[17:59:31.526]                       }
[17:59:31.526]                       invisible(muffled)
[17:59:31.526]                     }
[17:59:31.526]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.526]                   }
[17:59:31.526]                 }
[17:59:31.526]                 else {
[17:59:31.526]                   if (TRUE) {
[17:59:31.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.526]                     {
[17:59:31.526]                       inherits <- base::inherits
[17:59:31.526]                       invokeRestart <- base::invokeRestart
[17:59:31.526]                       is.null <- base::is.null
[17:59:31.526]                       muffled <- FALSE
[17:59:31.526]                       if (inherits(cond, "message")) {
[17:59:31.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.526]                         if (muffled) 
[17:59:31.526]                           invokeRestart("muffleMessage")
[17:59:31.526]                       }
[17:59:31.526]                       else if (inherits(cond, "warning")) {
[17:59:31.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.526]                         if (muffled) 
[17:59:31.526]                           invokeRestart("muffleWarning")
[17:59:31.526]                       }
[17:59:31.526]                       else if (inherits(cond, "condition")) {
[17:59:31.526]                         if (!is.null(pattern)) {
[17:59:31.526]                           computeRestarts <- base::computeRestarts
[17:59:31.526]                           grepl <- base::grepl
[17:59:31.526]                           restarts <- computeRestarts(cond)
[17:59:31.526]                           for (restart in restarts) {
[17:59:31.526]                             name <- restart$name
[17:59:31.526]                             if (is.null(name)) 
[17:59:31.526]                               next
[17:59:31.526]                             if (!grepl(pattern, name)) 
[17:59:31.526]                               next
[17:59:31.526]                             invokeRestart(restart)
[17:59:31.526]                             muffled <- TRUE
[17:59:31.526]                             break
[17:59:31.526]                           }
[17:59:31.526]                         }
[17:59:31.526]                       }
[17:59:31.526]                       invisible(muffled)
[17:59:31.526]                     }
[17:59:31.526]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.526]                   }
[17:59:31.526]                 }
[17:59:31.526]             }
[17:59:31.526]         }))
[17:59:31.526]     }, error = function(ex) {
[17:59:31.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.526]                 ...future.rng), started = ...future.startTime, 
[17:59:31.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.526]             version = "1.8"), class = "FutureResult")
[17:59:31.526]     }, finally = {
[17:59:31.526]         if (!identical(...future.workdir, getwd())) 
[17:59:31.526]             setwd(...future.workdir)
[17:59:31.526]         {
[17:59:31.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.526]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.526]             }
[17:59:31.526]             base::options(...future.oldOptions)
[17:59:31.526]             if (.Platform$OS.type == "windows") {
[17:59:31.526]                 old_names <- names(...future.oldEnvVars)
[17:59:31.526]                 envs <- base::Sys.getenv()
[17:59:31.526]                 names <- names(envs)
[17:59:31.526]                 common <- intersect(names, old_names)
[17:59:31.526]                 added <- setdiff(names, old_names)
[17:59:31.526]                 removed <- setdiff(old_names, names)
[17:59:31.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.526]                   envs[common]]
[17:59:31.526]                 NAMES <- toupper(changed)
[17:59:31.526]                 args <- list()
[17:59:31.526]                 for (kk in seq_along(NAMES)) {
[17:59:31.526]                   name <- changed[[kk]]
[17:59:31.526]                   NAME <- NAMES[[kk]]
[17:59:31.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.526]                     next
[17:59:31.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.526]                 }
[17:59:31.526]                 NAMES <- toupper(added)
[17:59:31.526]                 for (kk in seq_along(NAMES)) {
[17:59:31.526]                   name <- added[[kk]]
[17:59:31.526]                   NAME <- NAMES[[kk]]
[17:59:31.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.526]                     next
[17:59:31.526]                   args[[name]] <- ""
[17:59:31.526]                 }
[17:59:31.526]                 NAMES <- toupper(removed)
[17:59:31.526]                 for (kk in seq_along(NAMES)) {
[17:59:31.526]                   name <- removed[[kk]]
[17:59:31.526]                   NAME <- NAMES[[kk]]
[17:59:31.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.526]                     next
[17:59:31.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.526]                 }
[17:59:31.526]                 if (length(args) > 0) 
[17:59:31.526]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.526]             }
[17:59:31.526]             else {
[17:59:31.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.526]             }
[17:59:31.526]             {
[17:59:31.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.526]                   0L) {
[17:59:31.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.526]                   base::options(opts)
[17:59:31.526]                 }
[17:59:31.526]                 {
[17:59:31.526]                   {
[17:59:31.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.526]                     NULL
[17:59:31.526]                   }
[17:59:31.526]                   options(future.plan = NULL)
[17:59:31.526]                   if (is.na(NA_character_)) 
[17:59:31.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.526]                     .init = FALSE)
[17:59:31.526]                 }
[17:59:31.526]             }
[17:59:31.526]         }
[17:59:31.526]     })
[17:59:31.526]     if (TRUE) {
[17:59:31.526]         base::sink(type = "output", split = FALSE)
[17:59:31.526]         if (TRUE) {
[17:59:31.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.526]         }
[17:59:31.526]         else {
[17:59:31.526]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.526]         }
[17:59:31.526]         base::close(...future.stdout)
[17:59:31.526]         ...future.stdout <- NULL
[17:59:31.526]     }
[17:59:31.526]     ...future.result$conditions <- ...future.conditions
[17:59:31.526]     ...future.result$finished <- base::Sys.time()
[17:59:31.526]     ...future.result
[17:59:31.526] }
[17:59:31.532] assign_globals() ...
[17:59:31.532] List of 5
[17:59:31.532]  $ ...future.FUN            :function (x, ...)  
[17:59:31.532]  $ future.call.arguments    :List of 1
[17:59:31.532]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:31.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.532]  $ ...future.elements_ii    :List of 2
[17:59:31.532]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:31.532]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:31.532]  $ ...future.seeds_ii       : NULL
[17:59:31.532]  $ ...future.globals.maxSize: NULL
[17:59:31.532]  - attr(*, "where")=List of 5
[17:59:31.532]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.532]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.532]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.532]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.532]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.532]  - attr(*, "resolved")= logi FALSE
[17:59:31.532]  - attr(*, "total_size")= num 1328
[17:59:31.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.532]  - attr(*, "already-done")= logi TRUE
[17:59:31.555] - copied ‘...future.FUN’ to environment
[17:59:31.556] - copied ‘future.call.arguments’ to environment
[17:59:31.556] - copied ‘...future.elements_ii’ to environment
[17:59:31.556] - copied ‘...future.seeds_ii’ to environment
[17:59:31.557] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.557] assign_globals() ... done
[17:59:31.558] requestCore(): workers = 2
[17:59:31.561] MulticoreFuture started
[17:59:31.562] - Launch lazy future ... done
[17:59:31.563] run() for ‘MulticoreFuture’ ... done
[17:59:31.563] Created future:
[17:59:31.564] plan(): Setting new future strategy stack:
[17:59:31.565] List of future strategies:
[17:59:31.565] 1. sequential:
[17:59:31.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.565]    - tweaked: FALSE
[17:59:31.565]    - call: NULL
[17:59:31.567] plan(): nbrOfWorkers() = 1
[17:59:31.573] plan(): Setting new future strategy stack:
[17:59:31.573] List of future strategies:
[17:59:31.573] 1. multicore:
[17:59:31.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.573]    - tweaked: FALSE
[17:59:31.573]    - call: plan(strategy)
[17:59:31.564] MulticoreFuture:
[17:59:31.564] Label: ‘future_eapply-2’
[17:59:31.564] Expression:
[17:59:31.564] {
[17:59:31.564]     do.call(function(...) {
[17:59:31.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.564]             on.exit(options(oopts), add = TRUE)
[17:59:31.564]         }
[17:59:31.564]         {
[17:59:31.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.564]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.564]             })
[17:59:31.564]         }
[17:59:31.564]     }, args = future.call.arguments)
[17:59:31.564] }
[17:59:31.564] Lazy evaluation: FALSE
[17:59:31.564] Asynchronous evaluation: TRUE
[17:59:31.564] Local evaluation: TRUE
[17:59:31.564] Environment: R_GlobalEnv
[17:59:31.564] Capture standard output: TRUE
[17:59:31.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.564] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.564] Packages: 1 packages (‘stats’)
[17:59:31.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.564] Resolved: FALSE
[17:59:31.564] Value: <not collected>
[17:59:31.564] Conditions captured: <none>
[17:59:31.564] Early signaling: FALSE
[17:59:31.564] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.564] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.579] Chunk #2 of 2 ... DONE
[17:59:31.580] Launching 2 futures (chunks) ... DONE
[17:59:31.580] Resolving 2 futures (chunks) ...
[17:59:31.580] resolve() on list ...
[17:59:31.581]  recursive: 0
[17:59:31.581]  length: 2
[17:59:31.581] 
[17:59:31.582] Future #1
[17:59:31.582] plan(): nbrOfWorkers() = 2
[17:59:31.582] result() for MulticoreFuture ...
[17:59:31.584] result() for MulticoreFuture ...
[17:59:31.585] result() for MulticoreFuture ... done
[17:59:31.585] result() for MulticoreFuture ... done
[17:59:31.585] result() for MulticoreFuture ...
[17:59:31.586] result() for MulticoreFuture ... done
[17:59:31.586] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:31.586] - nx: 2
[17:59:31.586] - relay: TRUE
[17:59:31.587] - stdout: TRUE
[17:59:31.587] - signal: TRUE
[17:59:31.587] - resignal: FALSE
[17:59:31.588] - force: TRUE
[17:59:31.588] - relayed: [n=2] FALSE, FALSE
[17:59:31.588] - queued futures: [n=2] FALSE, FALSE
[17:59:31.589]  - until=1
[17:59:31.589]  - relaying element #1
[17:59:31.589] result() for MulticoreFuture ...
[17:59:31.590] result() for MulticoreFuture ... done
[17:59:31.590] result() for MulticoreFuture ...
[17:59:31.590] result() for MulticoreFuture ... done
[17:59:31.591] result() for MulticoreFuture ...
[17:59:31.591] result() for MulticoreFuture ... done
[17:59:31.592] result() for MulticoreFuture ...
[17:59:31.592] result() for MulticoreFuture ... done
[17:59:31.592] - relayed: [n=2] TRUE, FALSE
[17:59:31.592] - queued futures: [n=2] TRUE, FALSE
[17:59:31.593] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:31.593]  length: 1 (resolved future 1)
[17:59:31.594] Future #2
[17:59:31.594] result() for MulticoreFuture ...
[17:59:31.596] result() for MulticoreFuture ...
[17:59:31.596] result() for MulticoreFuture ... done
[17:59:31.597] result() for MulticoreFuture ... done
[17:59:31.597] result() for MulticoreFuture ...
[17:59:31.597] result() for MulticoreFuture ... done
[17:59:31.598] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:31.598] - nx: 2
[17:59:31.598] - relay: TRUE
[17:59:31.599] - stdout: TRUE
[17:59:31.599] - signal: TRUE
[17:59:31.599] - resignal: FALSE
[17:59:31.599] - force: TRUE
[17:59:31.600] - relayed: [n=2] TRUE, FALSE
[17:59:31.600] - queued futures: [n=2] TRUE, FALSE
[17:59:31.600]  - until=2
[17:59:31.601]  - relaying element #2
[17:59:31.601] result() for MulticoreFuture ...
[17:59:31.601] result() for MulticoreFuture ... done
[17:59:31.601] result() for MulticoreFuture ...
[17:59:31.601] result() for MulticoreFuture ... done
[17:59:31.602] result() for MulticoreFuture ...
[17:59:31.602] result() for MulticoreFuture ... done
[17:59:31.602] result() for MulticoreFuture ...
[17:59:31.602] result() for MulticoreFuture ... done
[17:59:31.603] - relayed: [n=2] TRUE, TRUE
[17:59:31.603] - queued futures: [n=2] TRUE, TRUE
[17:59:31.603] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:31.603]  length: 0 (resolved future 2)
[17:59:31.604] Relaying remaining futures
[17:59:31.604] signalConditionsASAP(NULL, pos=0) ...
[17:59:31.604] - nx: 2
[17:59:31.604] - relay: TRUE
[17:59:31.605] - stdout: TRUE
[17:59:31.605] - signal: TRUE
[17:59:31.605] - resignal: FALSE
[17:59:31.605] - force: TRUE
[17:59:31.605] - relayed: [n=2] TRUE, TRUE
[17:59:31.606] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:31.606] - relayed: [n=2] TRUE, TRUE
[17:59:31.606] - queued futures: [n=2] TRUE, TRUE
[17:59:31.606] signalConditionsASAP(NULL, pos=0) ... done
[17:59:31.607] resolve() on list ... DONE
[17:59:31.607] result() for MulticoreFuture ...
[17:59:31.607] result() for MulticoreFuture ... done
[17:59:31.607] result() for MulticoreFuture ...
[17:59:31.608] result() for MulticoreFuture ... done
[17:59:31.608] result() for MulticoreFuture ...
[17:59:31.608] result() for MulticoreFuture ... done
[17:59:31.608] result() for MulticoreFuture ...
[17:59:31.609] result() for MulticoreFuture ... done
[17:59:31.609]  - Number of value chunks collected: 2
[17:59:31.609] Resolving 2 futures (chunks) ... DONE
[17:59:31.609] Reducing values from 2 chunks ...
[17:59:31.610]  - Number of values collected after concatenation: 3
[17:59:31.610]  - Number of values expected: 3
[17:59:31.610] Reducing values from 2 chunks ... DONE
[17:59:31.610] future_lapply() ... DONE
[17:59:31.613] future_lapply() ...
[17:59:31.621] Number of chunks: 2
[17:59:31.621] getGlobalsAndPackagesXApply() ...
[17:59:31.621]  - future.globals: TRUE
[17:59:31.622] getGlobalsAndPackages() ...
[17:59:31.622] Searching for globals...
[17:59:31.624] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:31.625] Searching for globals ... DONE
[17:59:31.625] Resolving globals: FALSE
[17:59:31.626] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:31.626] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:31.627] - globals: [1] ‘FUN’
[17:59:31.627] - packages: [1] ‘stats’
[17:59:31.627] getGlobalsAndPackages() ... DONE
[17:59:31.627]  - globals found/used: [n=1] ‘FUN’
[17:59:31.628]  - needed namespaces: [n=1] ‘stats’
[17:59:31.628] Finding globals ... DONE
[17:59:31.628]  - use_args: TRUE
[17:59:31.631]  - Getting '...' globals ...
[17:59:31.632] resolve() on list ...
[17:59:31.632]  recursive: 0
[17:59:31.632]  length: 1
[17:59:31.632]  elements: ‘...’
[17:59:31.633]  length: 0 (resolved future 1)
[17:59:31.633] resolve() on list ... DONE
[17:59:31.633]    - '...' content: [n=0] 
[17:59:31.633] List of 1
[17:59:31.633]  $ ...: list()
[17:59:31.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.633]  - attr(*, "where")=List of 1
[17:59:31.633]   ..$ ...:<environment: 0x58d4c4aed358> 
[17:59:31.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.633]  - attr(*, "resolved")= logi TRUE
[17:59:31.633]  - attr(*, "total_size")= num NA
[17:59:31.640]  - Getting '...' globals ... DONE
[17:59:31.641] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:31.641] List of 2
[17:59:31.641]  $ ...future.FUN:function (x, ...)  
[17:59:31.641]  $ ...          : list()
[17:59:31.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.641]  - attr(*, "where")=List of 2
[17:59:31.641]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:31.641]   ..$ ...          :<environment: 0x58d4c4aed358> 
[17:59:31.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.641]  - attr(*, "resolved")= logi FALSE
[17:59:31.641]  - attr(*, "total_size")= num 1248
[17:59:31.647] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:31.647] getGlobalsAndPackagesXApply() ... DONE
[17:59:31.647] Number of futures (= number of chunks): 2
[17:59:31.648] Launching 2 futures (chunks) ...
[17:59:31.648] Chunk #1 of 2 ...
[17:59:31.648]  - Finding globals in 'X' for chunk #1 ...
[17:59:31.648] getGlobalsAndPackages() ...
[17:59:31.648] Searching for globals...
[17:59:31.649] 
[17:59:31.649] Searching for globals ... DONE
[17:59:31.649] - globals: [0] <none>
[17:59:31.649] getGlobalsAndPackages() ... DONE
[17:59:31.650]    + additional globals found: [n=0] 
[17:59:31.650]    + additional namespaces needed: [n=0] 
[17:59:31.650]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:31.650]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.651]  - seeds: <none>
[17:59:31.651]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.651] getGlobalsAndPackages() ...
[17:59:31.651] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.652] Resolving globals: FALSE
[17:59:31.652] Tweak future expression to call with '...' arguments ...
[17:59:31.652] {
[17:59:31.652]     do.call(function(...) {
[17:59:31.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.652]             on.exit(options(oopts), add = TRUE)
[17:59:31.652]         }
[17:59:31.652]         {
[17:59:31.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.652]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.652]             })
[17:59:31.652]         }
[17:59:31.652]     }, args = future.call.arguments)
[17:59:31.652] }
[17:59:31.653] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.653] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.654] - packages: [1] ‘stats’
[17:59:31.654] getGlobalsAndPackages() ... DONE
[17:59:31.655] run() for ‘Future’ ...
[17:59:31.655] - state: ‘created’
[17:59:31.655] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.664] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.664]   - Field: ‘label’
[17:59:31.665]   - Field: ‘local’
[17:59:31.665]   - Field: ‘owner’
[17:59:31.665]   - Field: ‘envir’
[17:59:31.665]   - Field: ‘workers’
[17:59:31.665]   - Field: ‘packages’
[17:59:31.666]   - Field: ‘gc’
[17:59:31.666]   - Field: ‘job’
[17:59:31.666]   - Field: ‘conditions’
[17:59:31.666]   - Field: ‘expr’
[17:59:31.666]   - Field: ‘uuid’
[17:59:31.667]   - Field: ‘seed’
[17:59:31.667]   - Field: ‘version’
[17:59:31.667]   - Field: ‘result’
[17:59:31.667]   - Field: ‘asynchronous’
[17:59:31.668]   - Field: ‘calls’
[17:59:31.668]   - Field: ‘globals’
[17:59:31.668]   - Field: ‘stdout’
[17:59:31.668]   - Field: ‘earlySignal’
[17:59:31.668]   - Field: ‘lazy’
[17:59:31.669]   - Field: ‘state’
[17:59:31.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.669] - Launch lazy future ...
[17:59:31.670] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.670] Packages needed by future strategies (n = 0): <none>
[17:59:31.671] {
[17:59:31.671]     {
[17:59:31.671]         {
[17:59:31.671]             ...future.startTime <- base::Sys.time()
[17:59:31.671]             {
[17:59:31.671]                 {
[17:59:31.671]                   {
[17:59:31.671]                     {
[17:59:31.671]                       {
[17:59:31.671]                         base::local({
[17:59:31.671]                           has_future <- base::requireNamespace("future", 
[17:59:31.671]                             quietly = TRUE)
[17:59:31.671]                           if (has_future) {
[17:59:31.671]                             ns <- base::getNamespace("future")
[17:59:31.671]                             version <- ns[[".package"]][["version"]]
[17:59:31.671]                             if (is.null(version)) 
[17:59:31.671]                               version <- utils::packageVersion("future")
[17:59:31.671]                           }
[17:59:31.671]                           else {
[17:59:31.671]                             version <- NULL
[17:59:31.671]                           }
[17:59:31.671]                           if (!has_future || version < "1.8.0") {
[17:59:31.671]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.671]                               "", base::R.version$version.string), 
[17:59:31.671]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:31.671]                                 base::R.version$platform, 8 * 
[17:59:31.671]                                   base::.Machine$sizeof.pointer), 
[17:59:31.671]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.671]                                 "release", "version")], collapse = " "), 
[17:59:31.671]                               hostname = base::Sys.info()[["nodename"]])
[17:59:31.671]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.671]                               info)
[17:59:31.671]                             info <- base::paste(info, collapse = "; ")
[17:59:31.671]                             if (!has_future) {
[17:59:31.671]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.671]                                 info)
[17:59:31.671]                             }
[17:59:31.671]                             else {
[17:59:31.671]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.671]                                 info, version)
[17:59:31.671]                             }
[17:59:31.671]                             base::stop(msg)
[17:59:31.671]                           }
[17:59:31.671]                         })
[17:59:31.671]                       }
[17:59:31.671]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.671]                       base::options(mc.cores = 1L)
[17:59:31.671]                     }
[17:59:31.671]                     base::local({
[17:59:31.671]                       for (pkg in "stats") {
[17:59:31.671]                         base::loadNamespace(pkg)
[17:59:31.671]                         base::library(pkg, character.only = TRUE)
[17:59:31.671]                       }
[17:59:31.671]                     })
[17:59:31.671]                   }
[17:59:31.671]                   ...future.strategy.old <- future::plan("list")
[17:59:31.671]                   options(future.plan = NULL)
[17:59:31.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.671]                 }
[17:59:31.671]                 ...future.workdir <- getwd()
[17:59:31.671]             }
[17:59:31.671]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.671]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.671]         }
[17:59:31.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.671]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.671]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.671]             base::names(...future.oldOptions))
[17:59:31.671]     }
[17:59:31.671]     if (FALSE) {
[17:59:31.671]     }
[17:59:31.671]     else {
[17:59:31.671]         if (TRUE) {
[17:59:31.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.671]                 open = "w")
[17:59:31.671]         }
[17:59:31.671]         else {
[17:59:31.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.671]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.671]         }
[17:59:31.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.671]             base::sink(type = "output", split = FALSE)
[17:59:31.671]             base::close(...future.stdout)
[17:59:31.671]         }, add = TRUE)
[17:59:31.671]     }
[17:59:31.671]     ...future.frame <- base::sys.nframe()
[17:59:31.671]     ...future.conditions <- base::list()
[17:59:31.671]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.671]     if (FALSE) {
[17:59:31.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.671]     }
[17:59:31.671]     ...future.result <- base::tryCatch({
[17:59:31.671]         base::withCallingHandlers({
[17:59:31.671]             ...future.value <- base::withVisible(base::local({
[17:59:31.671]                 withCallingHandlers({
[17:59:31.671]                   {
[17:59:31.671]                     do.call(function(...) {
[17:59:31.671]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.671]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.671]                         ...future.globals.maxSize)) {
[17:59:31.671]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.671]                         on.exit(options(oopts), add = TRUE)
[17:59:31.671]                       }
[17:59:31.671]                       {
[17:59:31.671]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.671]                           FUN = function(jj) {
[17:59:31.671]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.671]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.671]                           })
[17:59:31.671]                       }
[17:59:31.671]                     }, args = future.call.arguments)
[17:59:31.671]                   }
[17:59:31.671]                 }, immediateCondition = function(cond) {
[17:59:31.671]                   save_rds <- function (object, pathname, ...) 
[17:59:31.671]                   {
[17:59:31.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.671]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.671]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.671]                         fi_tmp[["mtime"]])
[17:59:31.671]                     }
[17:59:31.671]                     tryCatch({
[17:59:31.671]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.671]                     }, error = function(ex) {
[17:59:31.671]                       msg <- conditionMessage(ex)
[17:59:31.671]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.671]                         fi_tmp[["mtime"]], msg)
[17:59:31.671]                       ex$message <- msg
[17:59:31.671]                       stop(ex)
[17:59:31.671]                     })
[17:59:31.671]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.671]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.671]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.671]                       fi <- file.info(pathname)
[17:59:31.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.671]                         fi[["size"]], fi[["mtime"]])
[17:59:31.671]                       stop(msg)
[17:59:31.671]                     }
[17:59:31.671]                     invisible(pathname)
[17:59:31.671]                   }
[17:59:31.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.671]                     rootPath = tempdir()) 
[17:59:31.671]                   {
[17:59:31.671]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.671]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.671]                       tmpdir = path, fileext = ".rds")
[17:59:31.671]                     save_rds(obj, file)
[17:59:31.671]                   }
[17:59:31.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.671]                   {
[17:59:31.671]                     inherits <- base::inherits
[17:59:31.671]                     invokeRestart <- base::invokeRestart
[17:59:31.671]                     is.null <- base::is.null
[17:59:31.671]                     muffled <- FALSE
[17:59:31.671]                     if (inherits(cond, "message")) {
[17:59:31.671]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.671]                       if (muffled) 
[17:59:31.671]                         invokeRestart("muffleMessage")
[17:59:31.671]                     }
[17:59:31.671]                     else if (inherits(cond, "warning")) {
[17:59:31.671]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.671]                       if (muffled) 
[17:59:31.671]                         invokeRestart("muffleWarning")
[17:59:31.671]                     }
[17:59:31.671]                     else if (inherits(cond, "condition")) {
[17:59:31.671]                       if (!is.null(pattern)) {
[17:59:31.671]                         computeRestarts <- base::computeRestarts
[17:59:31.671]                         grepl <- base::grepl
[17:59:31.671]                         restarts <- computeRestarts(cond)
[17:59:31.671]                         for (restart in restarts) {
[17:59:31.671]                           name <- restart$name
[17:59:31.671]                           if (is.null(name)) 
[17:59:31.671]                             next
[17:59:31.671]                           if (!grepl(pattern, name)) 
[17:59:31.671]                             next
[17:59:31.671]                           invokeRestart(restart)
[17:59:31.671]                           muffled <- TRUE
[17:59:31.671]                           break
[17:59:31.671]                         }
[17:59:31.671]                       }
[17:59:31.671]                     }
[17:59:31.671]                     invisible(muffled)
[17:59:31.671]                   }
[17:59:31.671]                   muffleCondition(cond)
[17:59:31.671]                 })
[17:59:31.671]             }))
[17:59:31.671]             future::FutureResult(value = ...future.value$value, 
[17:59:31.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.671]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.671]                     ...future.globalenv.names))
[17:59:31.671]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.671]         }, condition = base::local({
[17:59:31.671]             c <- base::c
[17:59:31.671]             inherits <- base::inherits
[17:59:31.671]             invokeRestart <- base::invokeRestart
[17:59:31.671]             length <- base::length
[17:59:31.671]             list <- base::list
[17:59:31.671]             seq.int <- base::seq.int
[17:59:31.671]             signalCondition <- base::signalCondition
[17:59:31.671]             sys.calls <- base::sys.calls
[17:59:31.671]             `[[` <- base::`[[`
[17:59:31.671]             `+` <- base::`+`
[17:59:31.671]             `<<-` <- base::`<<-`
[17:59:31.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.671]                   3L)]
[17:59:31.671]             }
[17:59:31.671]             function(cond) {
[17:59:31.671]                 is_error <- inherits(cond, "error")
[17:59:31.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.671]                   NULL)
[17:59:31.671]                 if (is_error) {
[17:59:31.671]                   sessionInformation <- function() {
[17:59:31.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.671]                       search = base::search(), system = base::Sys.info())
[17:59:31.671]                   }
[17:59:31.671]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.671]                     cond$call), session = sessionInformation(), 
[17:59:31.671]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.671]                   signalCondition(cond)
[17:59:31.671]                 }
[17:59:31.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.671]                 "immediateCondition"))) {
[17:59:31.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.671]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.671]                   if (TRUE && !signal) {
[17:59:31.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.671]                     {
[17:59:31.671]                       inherits <- base::inherits
[17:59:31.671]                       invokeRestart <- base::invokeRestart
[17:59:31.671]                       is.null <- base::is.null
[17:59:31.671]                       muffled <- FALSE
[17:59:31.671]                       if (inherits(cond, "message")) {
[17:59:31.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.671]                         if (muffled) 
[17:59:31.671]                           invokeRestart("muffleMessage")
[17:59:31.671]                       }
[17:59:31.671]                       else if (inherits(cond, "warning")) {
[17:59:31.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.671]                         if (muffled) 
[17:59:31.671]                           invokeRestart("muffleWarning")
[17:59:31.671]                       }
[17:59:31.671]                       else if (inherits(cond, "condition")) {
[17:59:31.671]                         if (!is.null(pattern)) {
[17:59:31.671]                           computeRestarts <- base::computeRestarts
[17:59:31.671]                           grepl <- base::grepl
[17:59:31.671]                           restarts <- computeRestarts(cond)
[17:59:31.671]                           for (restart in restarts) {
[17:59:31.671]                             name <- restart$name
[17:59:31.671]                             if (is.null(name)) 
[17:59:31.671]                               next
[17:59:31.671]                             if (!grepl(pattern, name)) 
[17:59:31.671]                               next
[17:59:31.671]                             invokeRestart(restart)
[17:59:31.671]                             muffled <- TRUE
[17:59:31.671]                             break
[17:59:31.671]                           }
[17:59:31.671]                         }
[17:59:31.671]                       }
[17:59:31.671]                       invisible(muffled)
[17:59:31.671]                     }
[17:59:31.671]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.671]                   }
[17:59:31.671]                 }
[17:59:31.671]                 else {
[17:59:31.671]                   if (TRUE) {
[17:59:31.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.671]                     {
[17:59:31.671]                       inherits <- base::inherits
[17:59:31.671]                       invokeRestart <- base::invokeRestart
[17:59:31.671]                       is.null <- base::is.null
[17:59:31.671]                       muffled <- FALSE
[17:59:31.671]                       if (inherits(cond, "message")) {
[17:59:31.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.671]                         if (muffled) 
[17:59:31.671]                           invokeRestart("muffleMessage")
[17:59:31.671]                       }
[17:59:31.671]                       else if (inherits(cond, "warning")) {
[17:59:31.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.671]                         if (muffled) 
[17:59:31.671]                           invokeRestart("muffleWarning")
[17:59:31.671]                       }
[17:59:31.671]                       else if (inherits(cond, "condition")) {
[17:59:31.671]                         if (!is.null(pattern)) {
[17:59:31.671]                           computeRestarts <- base::computeRestarts
[17:59:31.671]                           grepl <- base::grepl
[17:59:31.671]                           restarts <- computeRestarts(cond)
[17:59:31.671]                           for (restart in restarts) {
[17:59:31.671]                             name <- restart$name
[17:59:31.671]                             if (is.null(name)) 
[17:59:31.671]                               next
[17:59:31.671]                             if (!grepl(pattern, name)) 
[17:59:31.671]                               next
[17:59:31.671]                             invokeRestart(restart)
[17:59:31.671]                             muffled <- TRUE
[17:59:31.671]                             break
[17:59:31.671]                           }
[17:59:31.671]                         }
[17:59:31.671]                       }
[17:59:31.671]                       invisible(muffled)
[17:59:31.671]                     }
[17:59:31.671]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.671]                   }
[17:59:31.671]                 }
[17:59:31.671]             }
[17:59:31.671]         }))
[17:59:31.671]     }, error = function(ex) {
[17:59:31.671]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.671]                 ...future.rng), started = ...future.startTime, 
[17:59:31.671]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.671]             version = "1.8"), class = "FutureResult")
[17:59:31.671]     }, finally = {
[17:59:31.671]         if (!identical(...future.workdir, getwd())) 
[17:59:31.671]             setwd(...future.workdir)
[17:59:31.671]         {
[17:59:31.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.671]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.671]             }
[17:59:31.671]             base::options(...future.oldOptions)
[17:59:31.671]             if (.Platform$OS.type == "windows") {
[17:59:31.671]                 old_names <- names(...future.oldEnvVars)
[17:59:31.671]                 envs <- base::Sys.getenv()
[17:59:31.671]                 names <- names(envs)
[17:59:31.671]                 common <- intersect(names, old_names)
[17:59:31.671]                 added <- setdiff(names, old_names)
[17:59:31.671]                 removed <- setdiff(old_names, names)
[17:59:31.671]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.671]                   envs[common]]
[17:59:31.671]                 NAMES <- toupper(changed)
[17:59:31.671]                 args <- list()
[17:59:31.671]                 for (kk in seq_along(NAMES)) {
[17:59:31.671]                   name <- changed[[kk]]
[17:59:31.671]                   NAME <- NAMES[[kk]]
[17:59:31.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.671]                     next
[17:59:31.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.671]                 }
[17:59:31.671]                 NAMES <- toupper(added)
[17:59:31.671]                 for (kk in seq_along(NAMES)) {
[17:59:31.671]                   name <- added[[kk]]
[17:59:31.671]                   NAME <- NAMES[[kk]]
[17:59:31.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.671]                     next
[17:59:31.671]                   args[[name]] <- ""
[17:59:31.671]                 }
[17:59:31.671]                 NAMES <- toupper(removed)
[17:59:31.671]                 for (kk in seq_along(NAMES)) {
[17:59:31.671]                   name <- removed[[kk]]
[17:59:31.671]                   NAME <- NAMES[[kk]]
[17:59:31.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.671]                     next
[17:59:31.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.671]                 }
[17:59:31.671]                 if (length(args) > 0) 
[17:59:31.671]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.671]             }
[17:59:31.671]             else {
[17:59:31.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.671]             }
[17:59:31.671]             {
[17:59:31.671]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.671]                   0L) {
[17:59:31.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.671]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.671]                   base::options(opts)
[17:59:31.671]                 }
[17:59:31.671]                 {
[17:59:31.671]                   {
[17:59:31.671]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.671]                     NULL
[17:59:31.671]                   }
[17:59:31.671]                   options(future.plan = NULL)
[17:59:31.671]                   if (is.na(NA_character_)) 
[17:59:31.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.671]                     .init = FALSE)
[17:59:31.671]                 }
[17:59:31.671]             }
[17:59:31.671]         }
[17:59:31.671]     })
[17:59:31.671]     if (TRUE) {
[17:59:31.671]         base::sink(type = "output", split = FALSE)
[17:59:31.671]         if (TRUE) {
[17:59:31.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.671]         }
[17:59:31.671]         else {
[17:59:31.671]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.671]         }
[17:59:31.671]         base::close(...future.stdout)
[17:59:31.671]         ...future.stdout <- NULL
[17:59:31.671]     }
[17:59:31.671]     ...future.result$conditions <- ...future.conditions
[17:59:31.671]     ...future.result$finished <- base::Sys.time()
[17:59:31.671]     ...future.result
[17:59:31.671] }
[17:59:31.676] assign_globals() ...
[17:59:31.676] List of 5
[17:59:31.676]  $ ...future.FUN            :function (x, ...)  
[17:59:31.676]  $ future.call.arguments    : list()
[17:59:31.676]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.676]  $ ...future.elements_ii    :List of 1
[17:59:31.676]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:59:31.676]  $ ...future.seeds_ii       : NULL
[17:59:31.676]  $ ...future.globals.maxSize: NULL
[17:59:31.676]  - attr(*, "where")=List of 5
[17:59:31.676]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.676]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.676]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.676]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.676]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.676]  - attr(*, "resolved")= logi FALSE
[17:59:31.676]  - attr(*, "total_size")= num 1248
[17:59:31.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.676]  - attr(*, "already-done")= logi TRUE
[17:59:31.686] - copied ‘...future.FUN’ to environment
[17:59:31.686] - copied ‘future.call.arguments’ to environment
[17:59:31.687] - copied ‘...future.elements_ii’ to environment
[17:59:31.687] - copied ‘...future.seeds_ii’ to environment
[17:59:31.687] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.687] assign_globals() ... done
[17:59:31.687] requestCore(): workers = 2
[17:59:31.691] MulticoreFuture started
[17:59:31.692] - Launch lazy future ... done
[17:59:31.692] run() for ‘MulticoreFuture’ ... done
[17:59:31.698] Created future:
[17:59:31.699] plan(): Setting new future strategy stack:
[17:59:31.699] List of future strategies:
[17:59:31.699] 1. sequential:
[17:59:31.699]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.699]    - tweaked: FALSE
[17:59:31.699]    - call: NULL
[17:59:31.701] plan(): nbrOfWorkers() = 1
[17:59:31.706] plan(): Setting new future strategy stack:
[17:59:31.706] List of future strategies:
[17:59:31.706] 1. multicore:
[17:59:31.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.706]    - tweaked: FALSE
[17:59:31.706]    - call: plan(strategy)
[17:59:31.699] MulticoreFuture:
[17:59:31.699] Label: ‘future_eapply-1’
[17:59:31.699] Expression:
[17:59:31.699] {
[17:59:31.699]     do.call(function(...) {
[17:59:31.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.699]             on.exit(options(oopts), add = TRUE)
[17:59:31.699]         }
[17:59:31.699]         {
[17:59:31.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.699]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.699]             })
[17:59:31.699]         }
[17:59:31.699]     }, args = future.call.arguments)
[17:59:31.699] }
[17:59:31.699] Lazy evaluation: FALSE
[17:59:31.699] Asynchronous evaluation: TRUE
[17:59:31.699] Local evaluation: TRUE
[17:59:31.699] Environment: R_GlobalEnv
[17:59:31.699] Capture standard output: TRUE
[17:59:31.699] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.699] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.699] Packages: 1 packages (‘stats’)
[17:59:31.699] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.699] Resolved: FALSE
[17:59:31.699] Value: <not collected>
[17:59:31.699] Conditions captured: <none>
[17:59:31.699] Early signaling: FALSE
[17:59:31.699] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.699] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.714] Chunk #1 of 2 ... DONE
[17:59:31.714] Chunk #2 of 2 ...
[17:59:31.714]  - Finding globals in 'X' for chunk #2 ...
[17:59:31.715] getGlobalsAndPackages() ...
[17:59:31.715] Searching for globals...
[17:59:31.716] plan(): nbrOfWorkers() = 2
[17:59:31.716] 
[17:59:31.716] Searching for globals ... DONE
[17:59:31.717] - globals: [0] <none>
[17:59:31.717] getGlobalsAndPackages() ... DONE
[17:59:31.717]    + additional globals found: [n=0] 
[17:59:31.718]    + additional namespaces needed: [n=0] 
[17:59:31.718]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:31.718]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.718]  - seeds: <none>
[17:59:31.719]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.719] getGlobalsAndPackages() ...
[17:59:31.719] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.720] Resolving globals: FALSE
[17:59:31.720] Tweak future expression to call with '...' arguments ...
[17:59:31.721] {
[17:59:31.721]     do.call(function(...) {
[17:59:31.721]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.721]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.721]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.721]             on.exit(options(oopts), add = TRUE)
[17:59:31.721]         }
[17:59:31.721]         {
[17:59:31.721]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.721]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.721]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.721]             })
[17:59:31.721]         }
[17:59:31.721]     }, args = future.call.arguments)
[17:59:31.721] }
[17:59:31.722] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.723] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.723] - packages: [1] ‘stats’
[17:59:31.724] getGlobalsAndPackages() ... DONE
[17:59:31.725] run() for ‘Future’ ...
[17:59:31.725] - state: ‘created’
[17:59:31.726] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.734] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.735]   - Field: ‘label’
[17:59:31.735]   - Field: ‘local’
[17:59:31.735]   - Field: ‘owner’
[17:59:31.735]   - Field: ‘envir’
[17:59:31.736]   - Field: ‘workers’
[17:59:31.736]   - Field: ‘packages’
[17:59:31.736]   - Field: ‘gc’
[17:59:31.737]   - Field: ‘job’
[17:59:31.737]   - Field: ‘conditions’
[17:59:31.737]   - Field: ‘expr’
[17:59:31.738]   - Field: ‘uuid’
[17:59:31.738]   - Field: ‘seed’
[17:59:31.738]   - Field: ‘version’
[17:59:31.739]   - Field: ‘result’
[17:59:31.739]   - Field: ‘asynchronous’
[17:59:31.739]   - Field: ‘calls’
[17:59:31.739]   - Field: ‘globals’
[17:59:31.740]   - Field: ‘stdout’
[17:59:31.740]   - Field: ‘earlySignal’
[17:59:31.740]   - Field: ‘lazy’
[17:59:31.741]   - Field: ‘state’
[17:59:31.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.741] - Launch lazy future ...
[17:59:31.742] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.743] Packages needed by future strategies (n = 0): <none>
[17:59:31.744] {
[17:59:31.744]     {
[17:59:31.744]         {
[17:59:31.744]             ...future.startTime <- base::Sys.time()
[17:59:31.744]             {
[17:59:31.744]                 {
[17:59:31.744]                   {
[17:59:31.744]                     {
[17:59:31.744]                       {
[17:59:31.744]                         base::local({
[17:59:31.744]                           has_future <- base::requireNamespace("future", 
[17:59:31.744]                             quietly = TRUE)
[17:59:31.744]                           if (has_future) {
[17:59:31.744]                             ns <- base::getNamespace("future")
[17:59:31.744]                             version <- ns[[".package"]][["version"]]
[17:59:31.744]                             if (is.null(version)) 
[17:59:31.744]                               version <- utils::packageVersion("future")
[17:59:31.744]                           }
[17:59:31.744]                           else {
[17:59:31.744]                             version <- NULL
[17:59:31.744]                           }
[17:59:31.744]                           if (!has_future || version < "1.8.0") {
[17:59:31.744]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.744]                               "", base::R.version$version.string), 
[17:59:31.744]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:31.744]                                 base::R.version$platform, 8 * 
[17:59:31.744]                                   base::.Machine$sizeof.pointer), 
[17:59:31.744]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.744]                                 "release", "version")], collapse = " "), 
[17:59:31.744]                               hostname = base::Sys.info()[["nodename"]])
[17:59:31.744]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.744]                               info)
[17:59:31.744]                             info <- base::paste(info, collapse = "; ")
[17:59:31.744]                             if (!has_future) {
[17:59:31.744]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.744]                                 info)
[17:59:31.744]                             }
[17:59:31.744]                             else {
[17:59:31.744]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.744]                                 info, version)
[17:59:31.744]                             }
[17:59:31.744]                             base::stop(msg)
[17:59:31.744]                           }
[17:59:31.744]                         })
[17:59:31.744]                       }
[17:59:31.744]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.744]                       base::options(mc.cores = 1L)
[17:59:31.744]                     }
[17:59:31.744]                     base::local({
[17:59:31.744]                       for (pkg in "stats") {
[17:59:31.744]                         base::loadNamespace(pkg)
[17:59:31.744]                         base::library(pkg, character.only = TRUE)
[17:59:31.744]                       }
[17:59:31.744]                     })
[17:59:31.744]                   }
[17:59:31.744]                   ...future.strategy.old <- future::plan("list")
[17:59:31.744]                   options(future.plan = NULL)
[17:59:31.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.744]                 }
[17:59:31.744]                 ...future.workdir <- getwd()
[17:59:31.744]             }
[17:59:31.744]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.744]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.744]         }
[17:59:31.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.744]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.744]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.744]             base::names(...future.oldOptions))
[17:59:31.744]     }
[17:59:31.744]     if (FALSE) {
[17:59:31.744]     }
[17:59:31.744]     else {
[17:59:31.744]         if (TRUE) {
[17:59:31.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.744]                 open = "w")
[17:59:31.744]         }
[17:59:31.744]         else {
[17:59:31.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.744]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.744]         }
[17:59:31.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.744]             base::sink(type = "output", split = FALSE)
[17:59:31.744]             base::close(...future.stdout)
[17:59:31.744]         }, add = TRUE)
[17:59:31.744]     }
[17:59:31.744]     ...future.frame <- base::sys.nframe()
[17:59:31.744]     ...future.conditions <- base::list()
[17:59:31.744]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.744]     if (FALSE) {
[17:59:31.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.744]     }
[17:59:31.744]     ...future.result <- base::tryCatch({
[17:59:31.744]         base::withCallingHandlers({
[17:59:31.744]             ...future.value <- base::withVisible(base::local({
[17:59:31.744]                 withCallingHandlers({
[17:59:31.744]                   {
[17:59:31.744]                     do.call(function(...) {
[17:59:31.744]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.744]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.744]                         ...future.globals.maxSize)) {
[17:59:31.744]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.744]                         on.exit(options(oopts), add = TRUE)
[17:59:31.744]                       }
[17:59:31.744]                       {
[17:59:31.744]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.744]                           FUN = function(jj) {
[17:59:31.744]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.744]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.744]                           })
[17:59:31.744]                       }
[17:59:31.744]                     }, args = future.call.arguments)
[17:59:31.744]                   }
[17:59:31.744]                 }, immediateCondition = function(cond) {
[17:59:31.744]                   save_rds <- function (object, pathname, ...) 
[17:59:31.744]                   {
[17:59:31.744]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.744]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.744]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.744]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.744]                         fi_tmp[["mtime"]])
[17:59:31.744]                     }
[17:59:31.744]                     tryCatch({
[17:59:31.744]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.744]                     }, error = function(ex) {
[17:59:31.744]                       msg <- conditionMessage(ex)
[17:59:31.744]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.744]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.744]                         fi_tmp[["mtime"]], msg)
[17:59:31.744]                       ex$message <- msg
[17:59:31.744]                       stop(ex)
[17:59:31.744]                     })
[17:59:31.744]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.744]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.744]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.744]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.744]                       fi <- file.info(pathname)
[17:59:31.744]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.744]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.744]                         fi[["size"]], fi[["mtime"]])
[17:59:31.744]                       stop(msg)
[17:59:31.744]                     }
[17:59:31.744]                     invisible(pathname)
[17:59:31.744]                   }
[17:59:31.744]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.744]                     rootPath = tempdir()) 
[17:59:31.744]                   {
[17:59:31.744]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.744]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.744]                       tmpdir = path, fileext = ".rds")
[17:59:31.744]                     save_rds(obj, file)
[17:59:31.744]                   }
[17:59:31.744]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.744]                   {
[17:59:31.744]                     inherits <- base::inherits
[17:59:31.744]                     invokeRestart <- base::invokeRestart
[17:59:31.744]                     is.null <- base::is.null
[17:59:31.744]                     muffled <- FALSE
[17:59:31.744]                     if (inherits(cond, "message")) {
[17:59:31.744]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.744]                       if (muffled) 
[17:59:31.744]                         invokeRestart("muffleMessage")
[17:59:31.744]                     }
[17:59:31.744]                     else if (inherits(cond, "warning")) {
[17:59:31.744]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.744]                       if (muffled) 
[17:59:31.744]                         invokeRestart("muffleWarning")
[17:59:31.744]                     }
[17:59:31.744]                     else if (inherits(cond, "condition")) {
[17:59:31.744]                       if (!is.null(pattern)) {
[17:59:31.744]                         computeRestarts <- base::computeRestarts
[17:59:31.744]                         grepl <- base::grepl
[17:59:31.744]                         restarts <- computeRestarts(cond)
[17:59:31.744]                         for (restart in restarts) {
[17:59:31.744]                           name <- restart$name
[17:59:31.744]                           if (is.null(name)) 
[17:59:31.744]                             next
[17:59:31.744]                           if (!grepl(pattern, name)) 
[17:59:31.744]                             next
[17:59:31.744]                           invokeRestart(restart)
[17:59:31.744]                           muffled <- TRUE
[17:59:31.744]                           break
[17:59:31.744]                         }
[17:59:31.744]                       }
[17:59:31.744]                     }
[17:59:31.744]                     invisible(muffled)
[17:59:31.744]                   }
[17:59:31.744]                   muffleCondition(cond)
[17:59:31.744]                 })
[17:59:31.744]             }))
[17:59:31.744]             future::FutureResult(value = ...future.value$value, 
[17:59:31.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.744]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.744]                     ...future.globalenv.names))
[17:59:31.744]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.744]         }, condition = base::local({
[17:59:31.744]             c <- base::c
[17:59:31.744]             inherits <- base::inherits
[17:59:31.744]             invokeRestart <- base::invokeRestart
[17:59:31.744]             length <- base::length
[17:59:31.744]             list <- base::list
[17:59:31.744]             seq.int <- base::seq.int
[17:59:31.744]             signalCondition <- base::signalCondition
[17:59:31.744]             sys.calls <- base::sys.calls
[17:59:31.744]             `[[` <- base::`[[`
[17:59:31.744]             `+` <- base::`+`
[17:59:31.744]             `<<-` <- base::`<<-`
[17:59:31.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.744]                   3L)]
[17:59:31.744]             }
[17:59:31.744]             function(cond) {
[17:59:31.744]                 is_error <- inherits(cond, "error")
[17:59:31.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.744]                   NULL)
[17:59:31.744]                 if (is_error) {
[17:59:31.744]                   sessionInformation <- function() {
[17:59:31.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.744]                       search = base::search(), system = base::Sys.info())
[17:59:31.744]                   }
[17:59:31.744]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.744]                     cond$call), session = sessionInformation(), 
[17:59:31.744]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.744]                   signalCondition(cond)
[17:59:31.744]                 }
[17:59:31.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.744]                 "immediateCondition"))) {
[17:59:31.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.744]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.744]                   if (TRUE && !signal) {
[17:59:31.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.744]                     {
[17:59:31.744]                       inherits <- base::inherits
[17:59:31.744]                       invokeRestart <- base::invokeRestart
[17:59:31.744]                       is.null <- base::is.null
[17:59:31.744]                       muffled <- FALSE
[17:59:31.744]                       if (inherits(cond, "message")) {
[17:59:31.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.744]                         if (muffled) 
[17:59:31.744]                           invokeRestart("muffleMessage")
[17:59:31.744]                       }
[17:59:31.744]                       else if (inherits(cond, "warning")) {
[17:59:31.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.744]                         if (muffled) 
[17:59:31.744]                           invokeRestart("muffleWarning")
[17:59:31.744]                       }
[17:59:31.744]                       else if (inherits(cond, "condition")) {
[17:59:31.744]                         if (!is.null(pattern)) {
[17:59:31.744]                           computeRestarts <- base::computeRestarts
[17:59:31.744]                           grepl <- base::grepl
[17:59:31.744]                           restarts <- computeRestarts(cond)
[17:59:31.744]                           for (restart in restarts) {
[17:59:31.744]                             name <- restart$name
[17:59:31.744]                             if (is.null(name)) 
[17:59:31.744]                               next
[17:59:31.744]                             if (!grepl(pattern, name)) 
[17:59:31.744]                               next
[17:59:31.744]                             invokeRestart(restart)
[17:59:31.744]                             muffled <- TRUE
[17:59:31.744]                             break
[17:59:31.744]                           }
[17:59:31.744]                         }
[17:59:31.744]                       }
[17:59:31.744]                       invisible(muffled)
[17:59:31.744]                     }
[17:59:31.744]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.744]                   }
[17:59:31.744]                 }
[17:59:31.744]                 else {
[17:59:31.744]                   if (TRUE) {
[17:59:31.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.744]                     {
[17:59:31.744]                       inherits <- base::inherits
[17:59:31.744]                       invokeRestart <- base::invokeRestart
[17:59:31.744]                       is.null <- base::is.null
[17:59:31.744]                       muffled <- FALSE
[17:59:31.744]                       if (inherits(cond, "message")) {
[17:59:31.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.744]                         if (muffled) 
[17:59:31.744]                           invokeRestart("muffleMessage")
[17:59:31.744]                       }
[17:59:31.744]                       else if (inherits(cond, "warning")) {
[17:59:31.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.744]                         if (muffled) 
[17:59:31.744]                           invokeRestart("muffleWarning")
[17:59:31.744]                       }
[17:59:31.744]                       else if (inherits(cond, "condition")) {
[17:59:31.744]                         if (!is.null(pattern)) {
[17:59:31.744]                           computeRestarts <- base::computeRestarts
[17:59:31.744]                           grepl <- base::grepl
[17:59:31.744]                           restarts <- computeRestarts(cond)
[17:59:31.744]                           for (restart in restarts) {
[17:59:31.744]                             name <- restart$name
[17:59:31.744]                             if (is.null(name)) 
[17:59:31.744]                               next
[17:59:31.744]                             if (!grepl(pattern, name)) 
[17:59:31.744]                               next
[17:59:31.744]                             invokeRestart(restart)
[17:59:31.744]                             muffled <- TRUE
[17:59:31.744]                             break
[17:59:31.744]                           }
[17:59:31.744]                         }
[17:59:31.744]                       }
[17:59:31.744]                       invisible(muffled)
[17:59:31.744]                     }
[17:59:31.744]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.744]                   }
[17:59:31.744]                 }
[17:59:31.744]             }
[17:59:31.744]         }))
[17:59:31.744]     }, error = function(ex) {
[17:59:31.744]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.744]                 ...future.rng), started = ...future.startTime, 
[17:59:31.744]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.744]             version = "1.8"), class = "FutureResult")
[17:59:31.744]     }, finally = {
[17:59:31.744]         if (!identical(...future.workdir, getwd())) 
[17:59:31.744]             setwd(...future.workdir)
[17:59:31.744]         {
[17:59:31.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.744]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.744]             }
[17:59:31.744]             base::options(...future.oldOptions)
[17:59:31.744]             if (.Platform$OS.type == "windows") {
[17:59:31.744]                 old_names <- names(...future.oldEnvVars)
[17:59:31.744]                 envs <- base::Sys.getenv()
[17:59:31.744]                 names <- names(envs)
[17:59:31.744]                 common <- intersect(names, old_names)
[17:59:31.744]                 added <- setdiff(names, old_names)
[17:59:31.744]                 removed <- setdiff(old_names, names)
[17:59:31.744]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.744]                   envs[common]]
[17:59:31.744]                 NAMES <- toupper(changed)
[17:59:31.744]                 args <- list()
[17:59:31.744]                 for (kk in seq_along(NAMES)) {
[17:59:31.744]                   name <- changed[[kk]]
[17:59:31.744]                   NAME <- NAMES[[kk]]
[17:59:31.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.744]                     next
[17:59:31.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.744]                 }
[17:59:31.744]                 NAMES <- toupper(added)
[17:59:31.744]                 for (kk in seq_along(NAMES)) {
[17:59:31.744]                   name <- added[[kk]]
[17:59:31.744]                   NAME <- NAMES[[kk]]
[17:59:31.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.744]                     next
[17:59:31.744]                   args[[name]] <- ""
[17:59:31.744]                 }
[17:59:31.744]                 NAMES <- toupper(removed)
[17:59:31.744]                 for (kk in seq_along(NAMES)) {
[17:59:31.744]                   name <- removed[[kk]]
[17:59:31.744]                   NAME <- NAMES[[kk]]
[17:59:31.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.744]                     next
[17:59:31.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.744]                 }
[17:59:31.744]                 if (length(args) > 0) 
[17:59:31.744]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.744]             }
[17:59:31.744]             else {
[17:59:31.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.744]             }
[17:59:31.744]             {
[17:59:31.744]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.744]                   0L) {
[17:59:31.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.744]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.744]                   base::options(opts)
[17:59:31.744]                 }
[17:59:31.744]                 {
[17:59:31.744]                   {
[17:59:31.744]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.744]                     NULL
[17:59:31.744]                   }
[17:59:31.744]                   options(future.plan = NULL)
[17:59:31.744]                   if (is.na(NA_character_)) 
[17:59:31.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.744]                     .init = FALSE)
[17:59:31.744]                 }
[17:59:31.744]             }
[17:59:31.744]         }
[17:59:31.744]     })
[17:59:31.744]     if (TRUE) {
[17:59:31.744]         base::sink(type = "output", split = FALSE)
[17:59:31.744]         if (TRUE) {
[17:59:31.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.744]         }
[17:59:31.744]         else {
[17:59:31.744]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.744]         }
[17:59:31.744]         base::close(...future.stdout)
[17:59:31.744]         ...future.stdout <- NULL
[17:59:31.744]     }
[17:59:31.744]     ...future.result$conditions <- ...future.conditions
[17:59:31.744]     ...future.result$finished <- base::Sys.time()
[17:59:31.744]     ...future.result
[17:59:31.744] }
[17:59:31.749] assign_globals() ...
[17:59:31.749] List of 5
[17:59:31.749]  $ ...future.FUN            :function (x, ...)  
[17:59:31.749]  $ future.call.arguments    : list()
[17:59:31.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.749]  $ ...future.elements_ii    :List of 2
[17:59:31.749]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:31.749]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:31.749]  $ ...future.seeds_ii       : NULL
[17:59:31.749]  $ ...future.globals.maxSize: NULL
[17:59:31.749]  - attr(*, "where")=List of 5
[17:59:31.749]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.749]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.749]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.749]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.749]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.749]  - attr(*, "resolved")= logi FALSE
[17:59:31.749]  - attr(*, "total_size")= num 1248
[17:59:31.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.749]  - attr(*, "already-done")= logi TRUE
[17:59:31.765] - copied ‘...future.FUN’ to environment
[17:59:31.765] - copied ‘future.call.arguments’ to environment
[17:59:31.765] - copied ‘...future.elements_ii’ to environment
[17:59:31.766] - copied ‘...future.seeds_ii’ to environment
[17:59:31.766] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.766] assign_globals() ... done
[17:59:31.767] requestCore(): workers = 2
[17:59:31.770] MulticoreFuture started
[17:59:31.771] - Launch lazy future ... done
[17:59:31.771] run() for ‘MulticoreFuture’ ... done
[17:59:31.772] Created future:
[17:59:31.773] plan(): Setting new future strategy stack:
[17:59:31.773] List of future strategies:
[17:59:31.773] 1. sequential:
[17:59:31.773]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.773]    - tweaked: FALSE
[17:59:31.773]    - call: NULL
[17:59:31.775] plan(): nbrOfWorkers() = 1
[17:59:31.781] plan(): Setting new future strategy stack:
[17:59:31.781] List of future strategies:
[17:59:31.781] 1. multicore:
[17:59:31.781]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.781]    - tweaked: FALSE
[17:59:31.781]    - call: plan(strategy)
[17:59:31.772] MulticoreFuture:
[17:59:31.772] Label: ‘future_eapply-2’
[17:59:31.772] Expression:
[17:59:31.772] {
[17:59:31.772]     do.call(function(...) {
[17:59:31.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.772]             on.exit(options(oopts), add = TRUE)
[17:59:31.772]         }
[17:59:31.772]         {
[17:59:31.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.772]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.772]             })
[17:59:31.772]         }
[17:59:31.772]     }, args = future.call.arguments)
[17:59:31.772] }
[17:59:31.772] Lazy evaluation: FALSE
[17:59:31.772] Asynchronous evaluation: TRUE
[17:59:31.772] Local evaluation: TRUE
[17:59:31.772] Environment: R_GlobalEnv
[17:59:31.772] Capture standard output: TRUE
[17:59:31.772] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.772] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.772] Packages: 1 packages (‘stats’)
[17:59:31.772] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.772] Resolved: FALSE
[17:59:31.772] Value: <not collected>
[17:59:31.772] Conditions captured: <none>
[17:59:31.772] Early signaling: FALSE
[17:59:31.772] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.772] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.788] Chunk #2 of 2 ... DONE
[17:59:31.788] Launching 2 futures (chunks) ... DONE
[17:59:31.789] Resolving 2 futures (chunks) ...
[17:59:31.789] resolve() on list ...
[17:59:31.789]  recursive: 0
[17:59:31.790]  length: 2
[17:59:31.790] 
[17:59:31.791] Future #1
[17:59:31.791] plan(): nbrOfWorkers() = 2
[17:59:31.791] result() for MulticoreFuture ...
[17:59:31.793] result() for MulticoreFuture ...
[17:59:31.793] result() for MulticoreFuture ... done
[17:59:31.794] result() for MulticoreFuture ... done
[17:59:31.794] result() for MulticoreFuture ...
[17:59:31.794] result() for MulticoreFuture ... done
[17:59:31.795] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:31.795] - nx: 2
[17:59:31.795] - relay: TRUE
[17:59:31.796] - stdout: TRUE
[17:59:31.796] - signal: TRUE
[17:59:31.796] - resignal: FALSE
[17:59:31.797] - force: TRUE
[17:59:31.797] - relayed: [n=2] FALSE, FALSE
[17:59:31.797] - queued futures: [n=2] FALSE, FALSE
[17:59:31.797]  - until=1
[17:59:31.798]  - relaying element #1
[17:59:31.798] result() for MulticoreFuture ...
[17:59:31.798] result() for MulticoreFuture ... done
[17:59:31.799] result() for MulticoreFuture ...
[17:59:31.799] result() for MulticoreFuture ... done
[17:59:31.799] result() for MulticoreFuture ...
[17:59:31.800] result() for MulticoreFuture ... done
[17:59:31.800] result() for MulticoreFuture ...
[17:59:31.800] result() for MulticoreFuture ... done
[17:59:31.801] - relayed: [n=2] TRUE, FALSE
[17:59:31.801] - queued futures: [n=2] TRUE, FALSE
[17:59:31.801] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:31.802]  length: 1 (resolved future 1)
[17:59:31.802] Future #2
[17:59:31.803] result() for MulticoreFuture ...
[17:59:31.804] result() for MulticoreFuture ...
[17:59:31.804] result() for MulticoreFuture ... done
[17:59:31.805] result() for MulticoreFuture ... done
[17:59:31.805] result() for MulticoreFuture ...
[17:59:31.809] result() for MulticoreFuture ... done
[17:59:31.809] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:31.809] - nx: 2
[17:59:31.810] - relay: TRUE
[17:59:31.810] - stdout: TRUE
[17:59:31.810] - signal: TRUE
[17:59:31.810] - resignal: FALSE
[17:59:31.810] - force: TRUE
[17:59:31.811] - relayed: [n=2] TRUE, FALSE
[17:59:31.811] - queued futures: [n=2] TRUE, FALSE
[17:59:31.811]  - until=2
[17:59:31.811]  - relaying element #2
[17:59:31.812] result() for MulticoreFuture ...
[17:59:31.812] result() for MulticoreFuture ... done
[17:59:31.812] result() for MulticoreFuture ...
[17:59:31.812] result() for MulticoreFuture ... done
[17:59:31.813] result() for MulticoreFuture ...
[17:59:31.813] result() for MulticoreFuture ... done
[17:59:31.813] result() for MulticoreFuture ...
[17:59:31.814] result() for MulticoreFuture ... done
[17:59:31.814] - relayed: [n=2] TRUE, TRUE
[17:59:31.814] - queued futures: [n=2] TRUE, TRUE
[17:59:31.814] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:31.815]  length: 0 (resolved future 2)
[17:59:31.815] Relaying remaining futures
[17:59:31.815] signalConditionsASAP(NULL, pos=0) ...
[17:59:31.815] - nx: 2
[17:59:31.816] - relay: TRUE
[17:59:31.816] - stdout: TRUE
[17:59:31.816] - signal: TRUE
[17:59:31.816] - resignal: FALSE
[17:59:31.816] - force: TRUE
[17:59:31.817] - relayed: [n=2] TRUE, TRUE
[17:59:31.817] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:31.817] - relayed: [n=2] TRUE, TRUE
[17:59:31.817] - queued futures: [n=2] TRUE, TRUE
[17:59:31.818] signalConditionsASAP(NULL, pos=0) ... done
[17:59:31.818] resolve() on list ... DONE
[17:59:31.819] result() for MulticoreFuture ...
[17:59:31.819] result() for MulticoreFuture ... done
[17:59:31.819] result() for MulticoreFuture ...
[17:59:31.819] result() for MulticoreFuture ... done
[17:59:31.820] result() for MulticoreFuture ...
[17:59:31.820] result() for MulticoreFuture ... done
[17:59:31.820] result() for MulticoreFuture ...
[17:59:31.820] result() for MulticoreFuture ... done
[17:59:31.821]  - Number of value chunks collected: 2
[17:59:31.821] Resolving 2 futures (chunks) ... DONE
[17:59:31.821] Reducing values from 2 chunks ...
[17:59:31.821]  - Number of values collected after concatenation: 3
[17:59:31.821]  - Number of values expected: 3
[17:59:31.822] Reducing values from 2 chunks ... DONE
[17:59:31.822] future_lapply() ... DONE
[17:59:31.823] future_lapply() ...
[17:59:31.831] Number of chunks: 2
[17:59:31.831] getGlobalsAndPackagesXApply() ...
[17:59:31.831]  - future.globals: TRUE
[17:59:31.831] getGlobalsAndPackages() ...
[17:59:31.832] Searching for globals...
[17:59:31.834] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:31.835] Searching for globals ... DONE
[17:59:31.835] Resolving globals: FALSE
[17:59:31.836] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:31.836] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:31.837] - globals: [1] ‘FUN’
[17:59:31.837] - packages: [1] ‘stats’
[17:59:31.837] getGlobalsAndPackages() ... DONE
[17:59:31.837]  - globals found/used: [n=1] ‘FUN’
[17:59:31.838]  - needed namespaces: [n=1] ‘stats’
[17:59:31.838] Finding globals ... DONE
[17:59:31.838]  - use_args: TRUE
[17:59:31.838]  - Getting '...' globals ...
[17:59:31.839] resolve() on list ...
[17:59:31.839]  recursive: 0
[17:59:31.840]  length: 1
[17:59:31.840]  elements: ‘...’
[17:59:31.840]  length: 0 (resolved future 1)
[17:59:31.840] resolve() on list ... DONE
[17:59:31.840]    - '...' content: [n=0] 
[17:59:31.841] List of 1
[17:59:31.841]  $ ...: list()
[17:59:31.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.841]  - attr(*, "where")=List of 1
[17:59:31.841]   ..$ ...:<environment: 0x58d4c24dfe88> 
[17:59:31.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.841]  - attr(*, "resolved")= logi TRUE
[17:59:31.841]  - attr(*, "total_size")= num NA
[17:59:31.847]  - Getting '...' globals ... DONE
[17:59:31.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:31.847] List of 2
[17:59:31.847]  $ ...future.FUN:function (x, ...)  
[17:59:31.847]  $ ...          : list()
[17:59:31.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.847]  - attr(*, "where")=List of 2
[17:59:31.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:31.847]   ..$ ...          :<environment: 0x58d4c24dfe88> 
[17:59:31.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.847]  - attr(*, "resolved")= logi FALSE
[17:59:31.847]  - attr(*, "total_size")= num 1248
[17:59:31.853] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:31.853] getGlobalsAndPackagesXApply() ... DONE
[17:59:31.854] Number of futures (= number of chunks): 2
[17:59:31.854] Launching 2 futures (chunks) ...
[17:59:31.854] Chunk #1 of 2 ...
[17:59:31.854]  - Finding globals in 'X' for chunk #1 ...
[17:59:31.854] getGlobalsAndPackages() ...
[17:59:31.855] Searching for globals...
[17:59:31.855] 
[17:59:31.855] Searching for globals ... DONE
[17:59:31.856] - globals: [0] <none>
[17:59:31.856] getGlobalsAndPackages() ... DONE
[17:59:31.856]    + additional globals found: [n=0] 
[17:59:31.856]    + additional namespaces needed: [n=0] 
[17:59:31.856]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:31.857]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.857]  - seeds: <none>
[17:59:31.857]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.857] getGlobalsAndPackages() ...
[17:59:31.857] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.858] Resolving globals: FALSE
[17:59:31.858] Tweak future expression to call with '...' arguments ...
[17:59:31.858] {
[17:59:31.858]     do.call(function(...) {
[17:59:31.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.858]             on.exit(options(oopts), add = TRUE)
[17:59:31.858]         }
[17:59:31.858]         {
[17:59:31.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.858]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.858]             })
[17:59:31.858]         }
[17:59:31.858]     }, args = future.call.arguments)
[17:59:31.858] }
[17:59:31.859] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.859] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.860] - packages: [1] ‘stats’
[17:59:31.860] getGlobalsAndPackages() ... DONE
[17:59:31.860] run() for ‘Future’ ...
[17:59:31.861] - state: ‘created’
[17:59:31.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.870] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.870]   - Field: ‘label’
[17:59:31.871]   - Field: ‘local’
[17:59:31.871]   - Field: ‘owner’
[17:59:31.871]   - Field: ‘envir’
[17:59:31.871]   - Field: ‘workers’
[17:59:31.872]   - Field: ‘packages’
[17:59:31.872]   - Field: ‘gc’
[17:59:31.872]   - Field: ‘job’
[17:59:31.872]   - Field: ‘conditions’
[17:59:31.872]   - Field: ‘expr’
[17:59:31.873]   - Field: ‘uuid’
[17:59:31.873]   - Field: ‘seed’
[17:59:31.873]   - Field: ‘version’
[17:59:31.873]   - Field: ‘result’
[17:59:31.873]   - Field: ‘asynchronous’
[17:59:31.874]   - Field: ‘calls’
[17:59:31.874]   - Field: ‘globals’
[17:59:31.874]   - Field: ‘stdout’
[17:59:31.874]   - Field: ‘earlySignal’
[17:59:31.874]   - Field: ‘lazy’
[17:59:31.875]   - Field: ‘state’
[17:59:31.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.875] - Launch lazy future ...
[17:59:31.876] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.876] Packages needed by future strategies (n = 0): <none>
[17:59:31.877] {
[17:59:31.877]     {
[17:59:31.877]         {
[17:59:31.877]             ...future.startTime <- base::Sys.time()
[17:59:31.877]             {
[17:59:31.877]                 {
[17:59:31.877]                   {
[17:59:31.877]                     {
[17:59:31.877]                       {
[17:59:31.877]                         base::local({
[17:59:31.877]                           has_future <- base::requireNamespace("future", 
[17:59:31.877]                             quietly = TRUE)
[17:59:31.877]                           if (has_future) {
[17:59:31.877]                             ns <- base::getNamespace("future")
[17:59:31.877]                             version <- ns[[".package"]][["version"]]
[17:59:31.877]                             if (is.null(version)) 
[17:59:31.877]                               version <- utils::packageVersion("future")
[17:59:31.877]                           }
[17:59:31.877]                           else {
[17:59:31.877]                             version <- NULL
[17:59:31.877]                           }
[17:59:31.877]                           if (!has_future || version < "1.8.0") {
[17:59:31.877]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.877]                               "", base::R.version$version.string), 
[17:59:31.877]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:31.877]                                 base::R.version$platform, 8 * 
[17:59:31.877]                                   base::.Machine$sizeof.pointer), 
[17:59:31.877]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.877]                                 "release", "version")], collapse = " "), 
[17:59:31.877]                               hostname = base::Sys.info()[["nodename"]])
[17:59:31.877]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.877]                               info)
[17:59:31.877]                             info <- base::paste(info, collapse = "; ")
[17:59:31.877]                             if (!has_future) {
[17:59:31.877]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.877]                                 info)
[17:59:31.877]                             }
[17:59:31.877]                             else {
[17:59:31.877]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.877]                                 info, version)
[17:59:31.877]                             }
[17:59:31.877]                             base::stop(msg)
[17:59:31.877]                           }
[17:59:31.877]                         })
[17:59:31.877]                       }
[17:59:31.877]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.877]                       base::options(mc.cores = 1L)
[17:59:31.877]                     }
[17:59:31.877]                     base::local({
[17:59:31.877]                       for (pkg in "stats") {
[17:59:31.877]                         base::loadNamespace(pkg)
[17:59:31.877]                         base::library(pkg, character.only = TRUE)
[17:59:31.877]                       }
[17:59:31.877]                     })
[17:59:31.877]                   }
[17:59:31.877]                   ...future.strategy.old <- future::plan("list")
[17:59:31.877]                   options(future.plan = NULL)
[17:59:31.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.877]                 }
[17:59:31.877]                 ...future.workdir <- getwd()
[17:59:31.877]             }
[17:59:31.877]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.877]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.877]         }
[17:59:31.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.877]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.877]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.877]             base::names(...future.oldOptions))
[17:59:31.877]     }
[17:59:31.877]     if (FALSE) {
[17:59:31.877]     }
[17:59:31.877]     else {
[17:59:31.877]         if (TRUE) {
[17:59:31.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.877]                 open = "w")
[17:59:31.877]         }
[17:59:31.877]         else {
[17:59:31.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.877]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.877]         }
[17:59:31.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.877]             base::sink(type = "output", split = FALSE)
[17:59:31.877]             base::close(...future.stdout)
[17:59:31.877]         }, add = TRUE)
[17:59:31.877]     }
[17:59:31.877]     ...future.frame <- base::sys.nframe()
[17:59:31.877]     ...future.conditions <- base::list()
[17:59:31.877]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.877]     if (FALSE) {
[17:59:31.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.877]     }
[17:59:31.877]     ...future.result <- base::tryCatch({
[17:59:31.877]         base::withCallingHandlers({
[17:59:31.877]             ...future.value <- base::withVisible(base::local({
[17:59:31.877]                 withCallingHandlers({
[17:59:31.877]                   {
[17:59:31.877]                     do.call(function(...) {
[17:59:31.877]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.877]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.877]                         ...future.globals.maxSize)) {
[17:59:31.877]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.877]                         on.exit(options(oopts), add = TRUE)
[17:59:31.877]                       }
[17:59:31.877]                       {
[17:59:31.877]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.877]                           FUN = function(jj) {
[17:59:31.877]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.877]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.877]                           })
[17:59:31.877]                       }
[17:59:31.877]                     }, args = future.call.arguments)
[17:59:31.877]                   }
[17:59:31.877]                 }, immediateCondition = function(cond) {
[17:59:31.877]                   save_rds <- function (object, pathname, ...) 
[17:59:31.877]                   {
[17:59:31.877]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.877]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.877]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.877]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.877]                         fi_tmp[["mtime"]])
[17:59:31.877]                     }
[17:59:31.877]                     tryCatch({
[17:59:31.877]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.877]                     }, error = function(ex) {
[17:59:31.877]                       msg <- conditionMessage(ex)
[17:59:31.877]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.877]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.877]                         fi_tmp[["mtime"]], msg)
[17:59:31.877]                       ex$message <- msg
[17:59:31.877]                       stop(ex)
[17:59:31.877]                     })
[17:59:31.877]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.877]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.877]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.877]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.877]                       fi <- file.info(pathname)
[17:59:31.877]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.877]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.877]                         fi[["size"]], fi[["mtime"]])
[17:59:31.877]                       stop(msg)
[17:59:31.877]                     }
[17:59:31.877]                     invisible(pathname)
[17:59:31.877]                   }
[17:59:31.877]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.877]                     rootPath = tempdir()) 
[17:59:31.877]                   {
[17:59:31.877]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.877]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.877]                       tmpdir = path, fileext = ".rds")
[17:59:31.877]                     save_rds(obj, file)
[17:59:31.877]                   }
[17:59:31.877]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.877]                   {
[17:59:31.877]                     inherits <- base::inherits
[17:59:31.877]                     invokeRestart <- base::invokeRestart
[17:59:31.877]                     is.null <- base::is.null
[17:59:31.877]                     muffled <- FALSE
[17:59:31.877]                     if (inherits(cond, "message")) {
[17:59:31.877]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.877]                       if (muffled) 
[17:59:31.877]                         invokeRestart("muffleMessage")
[17:59:31.877]                     }
[17:59:31.877]                     else if (inherits(cond, "warning")) {
[17:59:31.877]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.877]                       if (muffled) 
[17:59:31.877]                         invokeRestart("muffleWarning")
[17:59:31.877]                     }
[17:59:31.877]                     else if (inherits(cond, "condition")) {
[17:59:31.877]                       if (!is.null(pattern)) {
[17:59:31.877]                         computeRestarts <- base::computeRestarts
[17:59:31.877]                         grepl <- base::grepl
[17:59:31.877]                         restarts <- computeRestarts(cond)
[17:59:31.877]                         for (restart in restarts) {
[17:59:31.877]                           name <- restart$name
[17:59:31.877]                           if (is.null(name)) 
[17:59:31.877]                             next
[17:59:31.877]                           if (!grepl(pattern, name)) 
[17:59:31.877]                             next
[17:59:31.877]                           invokeRestart(restart)
[17:59:31.877]                           muffled <- TRUE
[17:59:31.877]                           break
[17:59:31.877]                         }
[17:59:31.877]                       }
[17:59:31.877]                     }
[17:59:31.877]                     invisible(muffled)
[17:59:31.877]                   }
[17:59:31.877]                   muffleCondition(cond)
[17:59:31.877]                 })
[17:59:31.877]             }))
[17:59:31.877]             future::FutureResult(value = ...future.value$value, 
[17:59:31.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.877]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.877]                     ...future.globalenv.names))
[17:59:31.877]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.877]         }, condition = base::local({
[17:59:31.877]             c <- base::c
[17:59:31.877]             inherits <- base::inherits
[17:59:31.877]             invokeRestart <- base::invokeRestart
[17:59:31.877]             length <- base::length
[17:59:31.877]             list <- base::list
[17:59:31.877]             seq.int <- base::seq.int
[17:59:31.877]             signalCondition <- base::signalCondition
[17:59:31.877]             sys.calls <- base::sys.calls
[17:59:31.877]             `[[` <- base::`[[`
[17:59:31.877]             `+` <- base::`+`
[17:59:31.877]             `<<-` <- base::`<<-`
[17:59:31.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.877]                   3L)]
[17:59:31.877]             }
[17:59:31.877]             function(cond) {
[17:59:31.877]                 is_error <- inherits(cond, "error")
[17:59:31.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.877]                   NULL)
[17:59:31.877]                 if (is_error) {
[17:59:31.877]                   sessionInformation <- function() {
[17:59:31.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.877]                       search = base::search(), system = base::Sys.info())
[17:59:31.877]                   }
[17:59:31.877]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.877]                     cond$call), session = sessionInformation(), 
[17:59:31.877]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.877]                   signalCondition(cond)
[17:59:31.877]                 }
[17:59:31.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.877]                 "immediateCondition"))) {
[17:59:31.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.877]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.877]                   if (TRUE && !signal) {
[17:59:31.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.877]                     {
[17:59:31.877]                       inherits <- base::inherits
[17:59:31.877]                       invokeRestart <- base::invokeRestart
[17:59:31.877]                       is.null <- base::is.null
[17:59:31.877]                       muffled <- FALSE
[17:59:31.877]                       if (inherits(cond, "message")) {
[17:59:31.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.877]                         if (muffled) 
[17:59:31.877]                           invokeRestart("muffleMessage")
[17:59:31.877]                       }
[17:59:31.877]                       else if (inherits(cond, "warning")) {
[17:59:31.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.877]                         if (muffled) 
[17:59:31.877]                           invokeRestart("muffleWarning")
[17:59:31.877]                       }
[17:59:31.877]                       else if (inherits(cond, "condition")) {
[17:59:31.877]                         if (!is.null(pattern)) {
[17:59:31.877]                           computeRestarts <- base::computeRestarts
[17:59:31.877]                           grepl <- base::grepl
[17:59:31.877]                           restarts <- computeRestarts(cond)
[17:59:31.877]                           for (restart in restarts) {
[17:59:31.877]                             name <- restart$name
[17:59:31.877]                             if (is.null(name)) 
[17:59:31.877]                               next
[17:59:31.877]                             if (!grepl(pattern, name)) 
[17:59:31.877]                               next
[17:59:31.877]                             invokeRestart(restart)
[17:59:31.877]                             muffled <- TRUE
[17:59:31.877]                             break
[17:59:31.877]                           }
[17:59:31.877]                         }
[17:59:31.877]                       }
[17:59:31.877]                       invisible(muffled)
[17:59:31.877]                     }
[17:59:31.877]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.877]                   }
[17:59:31.877]                 }
[17:59:31.877]                 else {
[17:59:31.877]                   if (TRUE) {
[17:59:31.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.877]                     {
[17:59:31.877]                       inherits <- base::inherits
[17:59:31.877]                       invokeRestart <- base::invokeRestart
[17:59:31.877]                       is.null <- base::is.null
[17:59:31.877]                       muffled <- FALSE
[17:59:31.877]                       if (inherits(cond, "message")) {
[17:59:31.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.877]                         if (muffled) 
[17:59:31.877]                           invokeRestart("muffleMessage")
[17:59:31.877]                       }
[17:59:31.877]                       else if (inherits(cond, "warning")) {
[17:59:31.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.877]                         if (muffled) 
[17:59:31.877]                           invokeRestart("muffleWarning")
[17:59:31.877]                       }
[17:59:31.877]                       else if (inherits(cond, "condition")) {
[17:59:31.877]                         if (!is.null(pattern)) {
[17:59:31.877]                           computeRestarts <- base::computeRestarts
[17:59:31.877]                           grepl <- base::grepl
[17:59:31.877]                           restarts <- computeRestarts(cond)
[17:59:31.877]                           for (restart in restarts) {
[17:59:31.877]                             name <- restart$name
[17:59:31.877]                             if (is.null(name)) 
[17:59:31.877]                               next
[17:59:31.877]                             if (!grepl(pattern, name)) 
[17:59:31.877]                               next
[17:59:31.877]                             invokeRestart(restart)
[17:59:31.877]                             muffled <- TRUE
[17:59:31.877]                             break
[17:59:31.877]                           }
[17:59:31.877]                         }
[17:59:31.877]                       }
[17:59:31.877]                       invisible(muffled)
[17:59:31.877]                     }
[17:59:31.877]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.877]                   }
[17:59:31.877]                 }
[17:59:31.877]             }
[17:59:31.877]         }))
[17:59:31.877]     }, error = function(ex) {
[17:59:31.877]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.877]                 ...future.rng), started = ...future.startTime, 
[17:59:31.877]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.877]             version = "1.8"), class = "FutureResult")
[17:59:31.877]     }, finally = {
[17:59:31.877]         if (!identical(...future.workdir, getwd())) 
[17:59:31.877]             setwd(...future.workdir)
[17:59:31.877]         {
[17:59:31.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.877]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.877]             }
[17:59:31.877]             base::options(...future.oldOptions)
[17:59:31.877]             if (.Platform$OS.type == "windows") {
[17:59:31.877]                 old_names <- names(...future.oldEnvVars)
[17:59:31.877]                 envs <- base::Sys.getenv()
[17:59:31.877]                 names <- names(envs)
[17:59:31.877]                 common <- intersect(names, old_names)
[17:59:31.877]                 added <- setdiff(names, old_names)
[17:59:31.877]                 removed <- setdiff(old_names, names)
[17:59:31.877]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.877]                   envs[common]]
[17:59:31.877]                 NAMES <- toupper(changed)
[17:59:31.877]                 args <- list()
[17:59:31.877]                 for (kk in seq_along(NAMES)) {
[17:59:31.877]                   name <- changed[[kk]]
[17:59:31.877]                   NAME <- NAMES[[kk]]
[17:59:31.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.877]                     next
[17:59:31.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.877]                 }
[17:59:31.877]                 NAMES <- toupper(added)
[17:59:31.877]                 for (kk in seq_along(NAMES)) {
[17:59:31.877]                   name <- added[[kk]]
[17:59:31.877]                   NAME <- NAMES[[kk]]
[17:59:31.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.877]                     next
[17:59:31.877]                   args[[name]] <- ""
[17:59:31.877]                 }
[17:59:31.877]                 NAMES <- toupper(removed)
[17:59:31.877]                 for (kk in seq_along(NAMES)) {
[17:59:31.877]                   name <- removed[[kk]]
[17:59:31.877]                   NAME <- NAMES[[kk]]
[17:59:31.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.877]                     next
[17:59:31.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.877]                 }
[17:59:31.877]                 if (length(args) > 0) 
[17:59:31.877]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.877]             }
[17:59:31.877]             else {
[17:59:31.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.877]             }
[17:59:31.877]             {
[17:59:31.877]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.877]                   0L) {
[17:59:31.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.877]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.877]                   base::options(opts)
[17:59:31.877]                 }
[17:59:31.877]                 {
[17:59:31.877]                   {
[17:59:31.877]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.877]                     NULL
[17:59:31.877]                   }
[17:59:31.877]                   options(future.plan = NULL)
[17:59:31.877]                   if (is.na(NA_character_)) 
[17:59:31.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.877]                     .init = FALSE)
[17:59:31.877]                 }
[17:59:31.877]             }
[17:59:31.877]         }
[17:59:31.877]     })
[17:59:31.877]     if (TRUE) {
[17:59:31.877]         base::sink(type = "output", split = FALSE)
[17:59:31.877]         if (TRUE) {
[17:59:31.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.877]         }
[17:59:31.877]         else {
[17:59:31.877]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.877]         }
[17:59:31.877]         base::close(...future.stdout)
[17:59:31.877]         ...future.stdout <- NULL
[17:59:31.877]     }
[17:59:31.877]     ...future.result$conditions <- ...future.conditions
[17:59:31.877]     ...future.result$finished <- base::Sys.time()
[17:59:31.877]     ...future.result
[17:59:31.877] }
[17:59:31.882] assign_globals() ...
[17:59:31.882] List of 5
[17:59:31.882]  $ ...future.FUN            :function (x, ...)  
[17:59:31.882]  $ future.call.arguments    : list()
[17:59:31.882]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.882]  $ ...future.elements_ii    :List of 1
[17:59:31.882]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:59:31.882]  $ ...future.seeds_ii       : NULL
[17:59:31.882]  $ ...future.globals.maxSize: NULL
[17:59:31.882]  - attr(*, "where")=List of 5
[17:59:31.882]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.882]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.882]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.882]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.882]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.882]  - attr(*, "resolved")= logi FALSE
[17:59:31.882]  - attr(*, "total_size")= num 1248
[17:59:31.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.882]  - attr(*, "already-done")= logi TRUE
[17:59:31.893] - copied ‘...future.FUN’ to environment
[17:59:31.894] - copied ‘future.call.arguments’ to environment
[17:59:31.894] - copied ‘...future.elements_ii’ to environment
[17:59:31.894] - copied ‘...future.seeds_ii’ to environment
[17:59:31.894] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.895] assign_globals() ... done
[17:59:31.895] requestCore(): workers = 2
[17:59:31.899] MulticoreFuture started
[17:59:31.900] - Launch lazy future ... done
[17:59:31.900] run() for ‘MulticoreFuture’ ... done
[17:59:31.901] Created future:
[17:59:31.905] plan(): Setting new future strategy stack:
[17:59:31.907] List of future strategies:
[17:59:31.907] 1. sequential:
[17:59:31.907]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:31.907]    - tweaked: FALSE
[17:59:31.907]    - call: NULL
[17:59:31.909] plan(): nbrOfWorkers() = 1
[17:59:31.914] plan(): Setting new future strategy stack:
[17:59:31.915] List of future strategies:
[17:59:31.915] 1. multicore:
[17:59:31.915]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:31.915]    - tweaked: FALSE
[17:59:31.915]    - call: plan(strategy)
[17:59:31.901] MulticoreFuture:
[17:59:31.901] Label: ‘future_eapply-1’
[17:59:31.901] Expression:
[17:59:31.901] {
[17:59:31.901]     do.call(function(...) {
[17:59:31.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.901]             on.exit(options(oopts), add = TRUE)
[17:59:31.901]         }
[17:59:31.901]         {
[17:59:31.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.901]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.901]             })
[17:59:31.901]         }
[17:59:31.901]     }, args = future.call.arguments)
[17:59:31.901] }
[17:59:31.901] Lazy evaluation: FALSE
[17:59:31.901] Asynchronous evaluation: TRUE
[17:59:31.901] Local evaluation: TRUE
[17:59:31.901] Environment: R_GlobalEnv
[17:59:31.901] Capture standard output: TRUE
[17:59:31.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.901] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.901] Packages: 1 packages (‘stats’)
[17:59:31.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.901] Resolved: FALSE
[17:59:31.901] Value: <not collected>
[17:59:31.901] Conditions captured: <none>
[17:59:31.901] Early signaling: FALSE
[17:59:31.901] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.901] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.918] Chunk #1 of 2 ... DONE
[17:59:31.918] Chunk #2 of 2 ...
[17:59:31.921]  - Finding globals in 'X' for chunk #2 ...
[17:59:31.921] getGlobalsAndPackages() ...
[17:59:31.921] Searching for globals...
[17:59:31.922] 
[17:59:31.923] Searching for globals ... DONE
[17:59:31.923] - globals: [0] <none>
[17:59:31.923] getGlobalsAndPackages() ... DONE
[17:59:31.924]    + additional globals found: [n=0] 
[17:59:31.924]    + additional namespaces needed: [n=0] 
[17:59:31.924]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:31.925]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:31.925]  - seeds: <none>
[17:59:31.925]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.926] getGlobalsAndPackages() ...
[17:59:31.928] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.928] Resolving globals: FALSE
[17:59:31.930] plan(): nbrOfWorkers() = 2
[17:59:31.931] Tweak future expression to call with '...' arguments ...
[17:59:31.931] {
[17:59:31.931]     do.call(function(...) {
[17:59:31.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.931]             on.exit(options(oopts), add = TRUE)
[17:59:31.931]         }
[17:59:31.931]         {
[17:59:31.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.931]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.931]             })
[17:59:31.931]         }
[17:59:31.931]     }, args = future.call.arguments)
[17:59:31.931] }
[17:59:31.932] Tweak future expression to call with '...' arguments ... DONE
[17:59:31.934] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:31.935] - packages: [1] ‘stats’
[17:59:31.935] getGlobalsAndPackages() ... DONE
[17:59:31.936] run() for ‘Future’ ...
[17:59:31.937] - state: ‘created’
[17:59:31.937] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:31.946] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:31.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:31.946]   - Field: ‘label’
[17:59:31.947]   - Field: ‘local’
[17:59:31.947]   - Field: ‘owner’
[17:59:31.947]   - Field: ‘envir’
[17:59:31.948]   - Field: ‘workers’
[17:59:31.948]   - Field: ‘packages’
[17:59:31.948]   - Field: ‘gc’
[17:59:31.949]   - Field: ‘job’
[17:59:31.949]   - Field: ‘conditions’
[17:59:31.949]   - Field: ‘expr’
[17:59:31.950]   - Field: ‘uuid’
[17:59:31.950]   - Field: ‘seed’
[17:59:31.950]   - Field: ‘version’
[17:59:31.951]   - Field: ‘result’
[17:59:31.951]   - Field: ‘asynchronous’
[17:59:31.951]   - Field: ‘calls’
[17:59:31.952]   - Field: ‘globals’
[17:59:31.952]   - Field: ‘stdout’
[17:59:31.952]   - Field: ‘earlySignal’
[17:59:31.952]   - Field: ‘lazy’
[17:59:31.953]   - Field: ‘state’
[17:59:31.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:31.954] - Launch lazy future ...
[17:59:31.955] Packages needed by the future expression (n = 1): ‘stats’
[17:59:31.955] Packages needed by future strategies (n = 0): <none>
[17:59:31.957] {
[17:59:31.957]     {
[17:59:31.957]         {
[17:59:31.957]             ...future.startTime <- base::Sys.time()
[17:59:31.957]             {
[17:59:31.957]                 {
[17:59:31.957]                   {
[17:59:31.957]                     {
[17:59:31.957]                       {
[17:59:31.957]                         base::local({
[17:59:31.957]                           has_future <- base::requireNamespace("future", 
[17:59:31.957]                             quietly = TRUE)
[17:59:31.957]                           if (has_future) {
[17:59:31.957]                             ns <- base::getNamespace("future")
[17:59:31.957]                             version <- ns[[".package"]][["version"]]
[17:59:31.957]                             if (is.null(version)) 
[17:59:31.957]                               version <- utils::packageVersion("future")
[17:59:31.957]                           }
[17:59:31.957]                           else {
[17:59:31.957]                             version <- NULL
[17:59:31.957]                           }
[17:59:31.957]                           if (!has_future || version < "1.8.0") {
[17:59:31.957]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:31.957]                               "", base::R.version$version.string), 
[17:59:31.957]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:31.957]                                 base::R.version$platform, 8 * 
[17:59:31.957]                                   base::.Machine$sizeof.pointer), 
[17:59:31.957]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:31.957]                                 "release", "version")], collapse = " "), 
[17:59:31.957]                               hostname = base::Sys.info()[["nodename"]])
[17:59:31.957]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:31.957]                               info)
[17:59:31.957]                             info <- base::paste(info, collapse = "; ")
[17:59:31.957]                             if (!has_future) {
[17:59:31.957]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:31.957]                                 info)
[17:59:31.957]                             }
[17:59:31.957]                             else {
[17:59:31.957]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:31.957]                                 info, version)
[17:59:31.957]                             }
[17:59:31.957]                             base::stop(msg)
[17:59:31.957]                           }
[17:59:31.957]                         })
[17:59:31.957]                       }
[17:59:31.957]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:31.957]                       base::options(mc.cores = 1L)
[17:59:31.957]                     }
[17:59:31.957]                     base::local({
[17:59:31.957]                       for (pkg in "stats") {
[17:59:31.957]                         base::loadNamespace(pkg)
[17:59:31.957]                         base::library(pkg, character.only = TRUE)
[17:59:31.957]                       }
[17:59:31.957]                     })
[17:59:31.957]                   }
[17:59:31.957]                   ...future.strategy.old <- future::plan("list")
[17:59:31.957]                   options(future.plan = NULL)
[17:59:31.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:31.957]                 }
[17:59:31.957]                 ...future.workdir <- getwd()
[17:59:31.957]             }
[17:59:31.957]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:31.957]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:31.957]         }
[17:59:31.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:31.957]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:31.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:31.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:31.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:31.957]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:31.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:31.957]             base::names(...future.oldOptions))
[17:59:31.957]     }
[17:59:31.957]     if (FALSE) {
[17:59:31.957]     }
[17:59:31.957]     else {
[17:59:31.957]         if (TRUE) {
[17:59:31.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:31.957]                 open = "w")
[17:59:31.957]         }
[17:59:31.957]         else {
[17:59:31.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:31.957]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:31.957]         }
[17:59:31.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:31.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:31.957]             base::sink(type = "output", split = FALSE)
[17:59:31.957]             base::close(...future.stdout)
[17:59:31.957]         }, add = TRUE)
[17:59:31.957]     }
[17:59:31.957]     ...future.frame <- base::sys.nframe()
[17:59:31.957]     ...future.conditions <- base::list()
[17:59:31.957]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:31.957]     if (FALSE) {
[17:59:31.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:31.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:31.957]     }
[17:59:31.957]     ...future.result <- base::tryCatch({
[17:59:31.957]         base::withCallingHandlers({
[17:59:31.957]             ...future.value <- base::withVisible(base::local({
[17:59:31.957]                 withCallingHandlers({
[17:59:31.957]                   {
[17:59:31.957]                     do.call(function(...) {
[17:59:31.957]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.957]                       if (!identical(...future.globals.maxSize.org, 
[17:59:31.957]                         ...future.globals.maxSize)) {
[17:59:31.957]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.957]                         on.exit(options(oopts), add = TRUE)
[17:59:31.957]                       }
[17:59:31.957]                       {
[17:59:31.957]                         lapply(seq_along(...future.elements_ii), 
[17:59:31.957]                           FUN = function(jj) {
[17:59:31.957]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.957]                             ...future.FUN(...future.X_jj, ...)
[17:59:31.957]                           })
[17:59:31.957]                       }
[17:59:31.957]                     }, args = future.call.arguments)
[17:59:31.957]                   }
[17:59:31.957]                 }, immediateCondition = function(cond) {
[17:59:31.957]                   save_rds <- function (object, pathname, ...) 
[17:59:31.957]                   {
[17:59:31.957]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:31.957]                     if (file_test("-f", pathname_tmp)) {
[17:59:31.957]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.957]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:31.957]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.957]                         fi_tmp[["mtime"]])
[17:59:31.957]                     }
[17:59:31.957]                     tryCatch({
[17:59:31.957]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:31.957]                     }, error = function(ex) {
[17:59:31.957]                       msg <- conditionMessage(ex)
[17:59:31.957]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.957]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:31.957]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.957]                         fi_tmp[["mtime"]], msg)
[17:59:31.957]                       ex$message <- msg
[17:59:31.957]                       stop(ex)
[17:59:31.957]                     })
[17:59:31.957]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:31.957]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:31.957]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:31.957]                       fi_tmp <- file.info(pathname_tmp)
[17:59:31.957]                       fi <- file.info(pathname)
[17:59:31.957]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:31.957]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:31.957]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:31.957]                         fi[["size"]], fi[["mtime"]])
[17:59:31.957]                       stop(msg)
[17:59:31.957]                     }
[17:59:31.957]                     invisible(pathname)
[17:59:31.957]                   }
[17:59:31.957]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:31.957]                     rootPath = tempdir()) 
[17:59:31.957]                   {
[17:59:31.957]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:31.957]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:31.957]                       tmpdir = path, fileext = ".rds")
[17:59:31.957]                     save_rds(obj, file)
[17:59:31.957]                   }
[17:59:31.957]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8h3IW/.future/immediateConditions")
[17:59:31.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.957]                   {
[17:59:31.957]                     inherits <- base::inherits
[17:59:31.957]                     invokeRestart <- base::invokeRestart
[17:59:31.957]                     is.null <- base::is.null
[17:59:31.957]                     muffled <- FALSE
[17:59:31.957]                     if (inherits(cond, "message")) {
[17:59:31.957]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:31.957]                       if (muffled) 
[17:59:31.957]                         invokeRestart("muffleMessage")
[17:59:31.957]                     }
[17:59:31.957]                     else if (inherits(cond, "warning")) {
[17:59:31.957]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:31.957]                       if (muffled) 
[17:59:31.957]                         invokeRestart("muffleWarning")
[17:59:31.957]                     }
[17:59:31.957]                     else if (inherits(cond, "condition")) {
[17:59:31.957]                       if (!is.null(pattern)) {
[17:59:31.957]                         computeRestarts <- base::computeRestarts
[17:59:31.957]                         grepl <- base::grepl
[17:59:31.957]                         restarts <- computeRestarts(cond)
[17:59:31.957]                         for (restart in restarts) {
[17:59:31.957]                           name <- restart$name
[17:59:31.957]                           if (is.null(name)) 
[17:59:31.957]                             next
[17:59:31.957]                           if (!grepl(pattern, name)) 
[17:59:31.957]                             next
[17:59:31.957]                           invokeRestart(restart)
[17:59:31.957]                           muffled <- TRUE
[17:59:31.957]                           break
[17:59:31.957]                         }
[17:59:31.957]                       }
[17:59:31.957]                     }
[17:59:31.957]                     invisible(muffled)
[17:59:31.957]                   }
[17:59:31.957]                   muffleCondition(cond)
[17:59:31.957]                 })
[17:59:31.957]             }))
[17:59:31.957]             future::FutureResult(value = ...future.value$value, 
[17:59:31.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.957]                   ...future.rng), globalenv = if (FALSE) 
[17:59:31.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:31.957]                     ...future.globalenv.names))
[17:59:31.957]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:31.957]         }, condition = base::local({
[17:59:31.957]             c <- base::c
[17:59:31.957]             inherits <- base::inherits
[17:59:31.957]             invokeRestart <- base::invokeRestart
[17:59:31.957]             length <- base::length
[17:59:31.957]             list <- base::list
[17:59:31.957]             seq.int <- base::seq.int
[17:59:31.957]             signalCondition <- base::signalCondition
[17:59:31.957]             sys.calls <- base::sys.calls
[17:59:31.957]             `[[` <- base::`[[`
[17:59:31.957]             `+` <- base::`+`
[17:59:31.957]             `<<-` <- base::`<<-`
[17:59:31.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:31.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:31.957]                   3L)]
[17:59:31.957]             }
[17:59:31.957]             function(cond) {
[17:59:31.957]                 is_error <- inherits(cond, "error")
[17:59:31.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:31.957]                   NULL)
[17:59:31.957]                 if (is_error) {
[17:59:31.957]                   sessionInformation <- function() {
[17:59:31.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:31.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:31.957]                       search = base::search(), system = base::Sys.info())
[17:59:31.957]                   }
[17:59:31.957]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:31.957]                     cond$call), session = sessionInformation(), 
[17:59:31.957]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:31.957]                   signalCondition(cond)
[17:59:31.957]                 }
[17:59:31.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:31.957]                 "immediateCondition"))) {
[17:59:31.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:31.957]                   ...future.conditions[[length(...future.conditions) + 
[17:59:31.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:31.957]                   if (TRUE && !signal) {
[17:59:31.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.957]                     {
[17:59:31.957]                       inherits <- base::inherits
[17:59:31.957]                       invokeRestart <- base::invokeRestart
[17:59:31.957]                       is.null <- base::is.null
[17:59:31.957]                       muffled <- FALSE
[17:59:31.957]                       if (inherits(cond, "message")) {
[17:59:31.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.957]                         if (muffled) 
[17:59:31.957]                           invokeRestart("muffleMessage")
[17:59:31.957]                       }
[17:59:31.957]                       else if (inherits(cond, "warning")) {
[17:59:31.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.957]                         if (muffled) 
[17:59:31.957]                           invokeRestart("muffleWarning")
[17:59:31.957]                       }
[17:59:31.957]                       else if (inherits(cond, "condition")) {
[17:59:31.957]                         if (!is.null(pattern)) {
[17:59:31.957]                           computeRestarts <- base::computeRestarts
[17:59:31.957]                           grepl <- base::grepl
[17:59:31.957]                           restarts <- computeRestarts(cond)
[17:59:31.957]                           for (restart in restarts) {
[17:59:31.957]                             name <- restart$name
[17:59:31.957]                             if (is.null(name)) 
[17:59:31.957]                               next
[17:59:31.957]                             if (!grepl(pattern, name)) 
[17:59:31.957]                               next
[17:59:31.957]                             invokeRestart(restart)
[17:59:31.957]                             muffled <- TRUE
[17:59:31.957]                             break
[17:59:31.957]                           }
[17:59:31.957]                         }
[17:59:31.957]                       }
[17:59:31.957]                       invisible(muffled)
[17:59:31.957]                     }
[17:59:31.957]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.957]                   }
[17:59:31.957]                 }
[17:59:31.957]                 else {
[17:59:31.957]                   if (TRUE) {
[17:59:31.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:31.957]                     {
[17:59:31.957]                       inherits <- base::inherits
[17:59:31.957]                       invokeRestart <- base::invokeRestart
[17:59:31.957]                       is.null <- base::is.null
[17:59:31.957]                       muffled <- FALSE
[17:59:31.957]                       if (inherits(cond, "message")) {
[17:59:31.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:31.957]                         if (muffled) 
[17:59:31.957]                           invokeRestart("muffleMessage")
[17:59:31.957]                       }
[17:59:31.957]                       else if (inherits(cond, "warning")) {
[17:59:31.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:31.957]                         if (muffled) 
[17:59:31.957]                           invokeRestart("muffleWarning")
[17:59:31.957]                       }
[17:59:31.957]                       else if (inherits(cond, "condition")) {
[17:59:31.957]                         if (!is.null(pattern)) {
[17:59:31.957]                           computeRestarts <- base::computeRestarts
[17:59:31.957]                           grepl <- base::grepl
[17:59:31.957]                           restarts <- computeRestarts(cond)
[17:59:31.957]                           for (restart in restarts) {
[17:59:31.957]                             name <- restart$name
[17:59:31.957]                             if (is.null(name)) 
[17:59:31.957]                               next
[17:59:31.957]                             if (!grepl(pattern, name)) 
[17:59:31.957]                               next
[17:59:31.957]                             invokeRestart(restart)
[17:59:31.957]                             muffled <- TRUE
[17:59:31.957]                             break
[17:59:31.957]                           }
[17:59:31.957]                         }
[17:59:31.957]                       }
[17:59:31.957]                       invisible(muffled)
[17:59:31.957]                     }
[17:59:31.957]                     muffleCondition(cond, pattern = "^muffle")
[17:59:31.957]                   }
[17:59:31.957]                 }
[17:59:31.957]             }
[17:59:31.957]         }))
[17:59:31.957]     }, error = function(ex) {
[17:59:31.957]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:31.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:31.957]                 ...future.rng), started = ...future.startTime, 
[17:59:31.957]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:31.957]             version = "1.8"), class = "FutureResult")
[17:59:31.957]     }, finally = {
[17:59:31.957]         if (!identical(...future.workdir, getwd())) 
[17:59:31.957]             setwd(...future.workdir)
[17:59:31.957]         {
[17:59:31.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:31.957]                 ...future.oldOptions$nwarnings <- NULL
[17:59:31.957]             }
[17:59:31.957]             base::options(...future.oldOptions)
[17:59:31.957]             if (.Platform$OS.type == "windows") {
[17:59:31.957]                 old_names <- names(...future.oldEnvVars)
[17:59:31.957]                 envs <- base::Sys.getenv()
[17:59:31.957]                 names <- names(envs)
[17:59:31.957]                 common <- intersect(names, old_names)
[17:59:31.957]                 added <- setdiff(names, old_names)
[17:59:31.957]                 removed <- setdiff(old_names, names)
[17:59:31.957]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:31.957]                   envs[common]]
[17:59:31.957]                 NAMES <- toupper(changed)
[17:59:31.957]                 args <- list()
[17:59:31.957]                 for (kk in seq_along(NAMES)) {
[17:59:31.957]                   name <- changed[[kk]]
[17:59:31.957]                   NAME <- NAMES[[kk]]
[17:59:31.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.957]                     next
[17:59:31.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.957]                 }
[17:59:31.957]                 NAMES <- toupper(added)
[17:59:31.957]                 for (kk in seq_along(NAMES)) {
[17:59:31.957]                   name <- added[[kk]]
[17:59:31.957]                   NAME <- NAMES[[kk]]
[17:59:31.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.957]                     next
[17:59:31.957]                   args[[name]] <- ""
[17:59:31.957]                 }
[17:59:31.957]                 NAMES <- toupper(removed)
[17:59:31.957]                 for (kk in seq_along(NAMES)) {
[17:59:31.957]                   name <- removed[[kk]]
[17:59:31.957]                   NAME <- NAMES[[kk]]
[17:59:31.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:31.957]                     next
[17:59:31.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:31.957]                 }
[17:59:31.957]                 if (length(args) > 0) 
[17:59:31.957]                   base::do.call(base::Sys.setenv, args = args)
[17:59:31.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:31.957]             }
[17:59:31.957]             else {
[17:59:31.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:31.957]             }
[17:59:31.957]             {
[17:59:31.957]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:31.957]                   0L) {
[17:59:31.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:31.957]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:31.957]                   base::options(opts)
[17:59:31.957]                 }
[17:59:31.957]                 {
[17:59:31.957]                   {
[17:59:31.957]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:31.957]                     NULL
[17:59:31.957]                   }
[17:59:31.957]                   options(future.plan = NULL)
[17:59:31.957]                   if (is.na(NA_character_)) 
[17:59:31.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:31.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:31.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:31.957]                     .init = FALSE)
[17:59:31.957]                 }
[17:59:31.957]             }
[17:59:31.957]         }
[17:59:31.957]     })
[17:59:31.957]     if (TRUE) {
[17:59:31.957]         base::sink(type = "output", split = FALSE)
[17:59:31.957]         if (TRUE) {
[17:59:31.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:31.957]         }
[17:59:31.957]         else {
[17:59:31.957]             ...future.result["stdout"] <- base::list(NULL)
[17:59:31.957]         }
[17:59:31.957]         base::close(...future.stdout)
[17:59:31.957]         ...future.stdout <- NULL
[17:59:31.957]     }
[17:59:31.957]     ...future.result$conditions <- ...future.conditions
[17:59:31.957]     ...future.result$finished <- base::Sys.time()
[17:59:31.957]     ...future.result
[17:59:31.957] }
[17:59:31.963] assign_globals() ...
[17:59:31.964] List of 5
[17:59:31.964]  $ ...future.FUN            :function (x, ...)  
[17:59:31.964]  $ future.call.arguments    : list()
[17:59:31.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:31.964]  $ ...future.elements_ii    :List of 2
[17:59:31.964]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:59:31.964]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:59:31.964]  $ ...future.seeds_ii       : NULL
[17:59:31.964]  $ ...future.globals.maxSize: NULL
[17:59:31.964]  - attr(*, "where")=List of 5
[17:59:31.964]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:31.964]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:31.964]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:31.964]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:31.964]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:31.964]  - attr(*, "resolved")= logi FALSE
[17:59:31.964]  - attr(*, "total_size")= num 1248
[17:59:31.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:31.964]  - attr(*, "already-done")= logi TRUE
[17:59:31.987] - copied ‘...future.FUN’ to environment
[17:59:31.987] - copied ‘future.call.arguments’ to environment
[17:59:31.987] - copied ‘...future.elements_ii’ to environment
[17:59:31.988] - copied ‘...future.seeds_ii’ to environment
[17:59:31.988] - copied ‘...future.globals.maxSize’ to environment
[17:59:31.988] assign_globals() ... done
[17:59:31.989] requestCore(): workers = 2
[17:59:31.993] MulticoreFuture started
[17:59:31.994] - Launch lazy future ... done
[17:59:31.994] run() for ‘MulticoreFuture’ ... done
[17:59:31.995] Created future:
[17:59:31.999] plan(): Setting new future strategy stack:
[17:59:32.000] List of future strategies:
[17:59:32.000] 1. sequential:
[17:59:32.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:32.000]    - tweaked: FALSE
[17:59:32.000]    - call: NULL
[17:59:32.002] plan(): nbrOfWorkers() = 1
[17:59:32.009] plan(): Setting new future strategy stack:
[17:59:32.009] List of future strategies:
[17:59:32.009] 1. multicore:
[17:59:32.009]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:32.009]    - tweaked: FALSE
[17:59:32.009]    - call: plan(strategy)
[17:59:31.995] MulticoreFuture:
[17:59:31.995] Label: ‘future_eapply-2’
[17:59:31.995] Expression:
[17:59:31.995] {
[17:59:31.995]     do.call(function(...) {
[17:59:31.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:31.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:31.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:31.995]             on.exit(options(oopts), add = TRUE)
[17:59:31.995]         }
[17:59:31.995]         {
[17:59:31.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:31.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:31.995]                 ...future.FUN(...future.X_jj, ...)
[17:59:31.995]             })
[17:59:31.995]         }
[17:59:31.995]     }, args = future.call.arguments)
[17:59:31.995] }
[17:59:31.995] Lazy evaluation: FALSE
[17:59:31.995] Asynchronous evaluation: TRUE
[17:59:31.995] Local evaluation: TRUE
[17:59:31.995] Environment: R_GlobalEnv
[17:59:31.995] Capture standard output: TRUE
[17:59:31.995] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:31.995] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:31.995] Packages: 1 packages (‘stats’)
[17:59:31.995] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:31.995] Resolved: FALSE
[17:59:31.995] Value: <not collected>
[17:59:31.995] Conditions captured: <none>
[17:59:31.995] Early signaling: FALSE
[17:59:31.995] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:31.995] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:32.013] Chunk #2 of 2 ... DONE
[17:59:32.014] Launching 2 futures (chunks) ... DONE
[17:59:32.015] Resolving 2 futures (chunks) ...
[17:59:32.016] resolve() on list ...
[17:59:32.016]  recursive: 0
[17:59:32.016]  length: 2
[17:59:32.017] 
[17:59:32.018] Future #1
[17:59:32.018] result() for MulticoreFuture ...
[17:59:32.022] result() for MulticoreFuture ...
[17:59:32.022] result() for MulticoreFuture ... done
[17:59:32.023] result() for MulticoreFuture ... done
[17:59:32.027] result() for MulticoreFuture ...
[17:59:32.027] result() for MulticoreFuture ... done
[17:59:32.028] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:32.028] - nx: 2
[17:59:32.028] - relay: TRUE
[17:59:32.027] plan(): nbrOfWorkers() = 2
[17:59:32.029] - stdout: TRUE
[17:59:32.031] - signal: TRUE
[17:59:32.031] - resignal: FALSE
[17:59:32.031] - force: TRUE
[17:59:32.032] - relayed: [n=2] FALSE, FALSE
[17:59:32.032] - queued futures: [n=2] FALSE, FALSE
[17:59:32.032]  - until=1
[17:59:32.033]  - relaying element #1
[17:59:32.033] result() for MulticoreFuture ...
[17:59:32.033] result() for MulticoreFuture ... done
[17:59:32.034] result() for MulticoreFuture ...
[17:59:32.034] result() for MulticoreFuture ... done
[17:59:32.034] result() for MulticoreFuture ...
[17:59:32.035] result() for MulticoreFuture ... done
[17:59:32.035] result() for MulticoreFuture ...
[17:59:32.035] result() for MulticoreFuture ... done
[17:59:32.035] - relayed: [n=2] TRUE, FALSE
[17:59:32.036] - queued futures: [n=2] TRUE, FALSE
[17:59:32.036] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:32.036]  length: 1 (resolved future 1)
[17:59:32.037] Future #2
[17:59:32.037] result() for MulticoreFuture ...
[17:59:32.039] result() for MulticoreFuture ...
[17:59:32.039] result() for MulticoreFuture ... done
[17:59:32.040] result() for MulticoreFuture ... done
[17:59:32.040] result() for MulticoreFuture ...
[17:59:32.040] result() for MulticoreFuture ... done
[17:59:32.041] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:32.041] - nx: 2
[17:59:32.041] - relay: TRUE
[17:59:32.041] - stdout: TRUE
[17:59:32.042] - signal: TRUE
[17:59:32.042] - resignal: FALSE
[17:59:32.042] - force: TRUE
[17:59:32.042] - relayed: [n=2] TRUE, FALSE
[17:59:32.042] - queued futures: [n=2] TRUE, FALSE
[17:59:32.043]  - until=2
[17:59:32.043]  - relaying element #2
[17:59:32.043] result() for MulticoreFuture ...
[17:59:32.043] result() for MulticoreFuture ... done
[17:59:32.044] result() for MulticoreFuture ...
[17:59:32.044] result() for MulticoreFuture ... done
[17:59:32.044] result() for MulticoreFuture ...
[17:59:32.044] result() for MulticoreFuture ... done
[17:59:32.045] result() for MulticoreFuture ...
[17:59:32.045] result() for MulticoreFuture ... done
[17:59:32.045] - relayed: [n=2] TRUE, TRUE
[17:59:32.045] - queued futures: [n=2] TRUE, TRUE
[17:59:32.046] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:32.046]  length: 0 (resolved future 2)
[17:59:32.046] Relaying remaining futures
[17:59:32.046] signalConditionsASAP(NULL, pos=0) ...
[17:59:32.046] - nx: 2
[17:59:32.047] - relay: TRUE
[17:59:32.047] - stdout: TRUE
[17:59:32.047] - signal: TRUE
[17:59:32.047] - resignal: FALSE
[17:59:32.047] - force: TRUE
[17:59:32.048] - relayed: [n=2] TRUE, TRUE
[17:59:32.048] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:32.048] - relayed: [n=2] TRUE, TRUE
[17:59:32.048] - queued futures: [n=2] TRUE, TRUE
[17:59:32.049] signalConditionsASAP(NULL, pos=0) ... done
[17:59:32.049] resolve() on list ... DONE
[17:59:32.049] result() for MulticoreFuture ...
[17:59:32.049] result() for MulticoreFuture ... done
[17:59:32.050] result() for MulticoreFuture ...
[17:59:32.050] result() for MulticoreFuture ... done
[17:59:32.050] result() for MulticoreFuture ...
[17:59:32.050] result() for MulticoreFuture ... done
[17:59:32.051] result() for MulticoreFuture ...
[17:59:32.051] result() for MulticoreFuture ... done
[17:59:32.051]  - Number of value chunks collected: 2
[17:59:32.051] Resolving 2 futures (chunks) ... DONE
[17:59:32.051] Reducing values from 2 chunks ...
[17:59:32.052]  - Number of values collected after concatenation: 3
[17:59:32.052]  - Number of values expected: 3
[17:59:32.052] Reducing values from 2 chunks ... DONE
[17:59:32.052] future_lapply() ... DONE
[17:59:32.053] plan(): Setting new future strategy stack:
[17:59:32.053] List of future strategies:
[17:59:32.053] 1. sequential:
[17:59:32.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:32.053]    - tweaked: FALSE
[17:59:32.053]    - call: plan(sequential)
[17:59:32.055] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:59:32.055] plan(): Setting new future strategy stack:
[17:59:32.056] List of future strategies:
[17:59:32.056] 1. multisession:
[17:59:32.056]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:32.056]    - tweaked: FALSE
[17:59:32.056]    - call: plan(strategy)
[17:59:32.056] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:59:32.057] multisession:
[17:59:32.057] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:32.057] - tweaked: FALSE
[17:59:32.057] - call: plan(strategy)
[17:59:32.067] getGlobalsAndPackages() ...
[17:59:32.068] Not searching for globals
[17:59:32.068] - globals: [0] <none>
[17:59:32.068] getGlobalsAndPackages() ... DONE
[17:59:32.069] [local output] makeClusterPSOCK() ...
[17:59:32.135] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:59:32.137] [local output] Base port: 11318
[17:59:32.138] [local output] Getting setup options for 2 cluster nodes ...
[17:59:32.138] [local output]  - Node 1 of 2 ...
[17:59:32.139] [local output] localMachine=TRUE => revtunnel=FALSE

[17:59:32.140] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpW8h3IW/worker.rank=1.parallelly.parent=308299.4b44b3613ceb.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpW8h3IW/worker.rank=1.parallelly.parent=308299.4b44b3613ceb.pid")'’
[17:59:32.403] - Possible to infer worker's PID: TRUE
[17:59:32.403] [local output] Rscript port: 11318

[17:59:32.404] [local output]  - Node 2 of 2 ...
[17:59:32.405] [local output] localMachine=TRUE => revtunnel=FALSE

[17:59:32.406] [local output] Rscript port: 11318

[17:59:32.406] [local output] Getting setup options for 2 cluster nodes ... done
[17:59:32.407] [local output]  - Parallel setup requested for some PSOCK nodes
[17:59:32.408] [local output] Setting up PSOCK nodes in parallel
[17:59:32.408] List of 36
[17:59:32.408]  $ worker          : chr "localhost"
[17:59:32.408]   ..- attr(*, "localhost")= logi TRUE
[17:59:32.408]  $ master          : chr "localhost"
[17:59:32.408]  $ port            : int 11318
[17:59:32.408]  $ connectTimeout  : num 120
[17:59:32.408]  $ timeout         : num 2592000
[17:59:32.408]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:59:32.408]  $ homogeneous     : logi TRUE
[17:59:32.408]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:59:32.408]  $ rscript_envs    : NULL
[17:59:32.408]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:59:32.408]  $ rscript_startup : NULL
[17:59:32.408]  $ rscript_sh      : chr "sh"
[17:59:32.408]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:59:32.408]  $ methods         : logi TRUE
[17:59:32.408]  $ socketOptions   : chr "no-delay"
[17:59:32.408]  $ useXDR          : logi FALSE
[17:59:32.408]  $ outfile         : chr "/dev/null"
[17:59:32.408]  $ renice          : int NA
[17:59:32.408]  $ rshcmd          : NULL
[17:59:32.408]  $ user            : chr(0) 
[17:59:32.408]  $ revtunnel       : logi FALSE
[17:59:32.408]  $ rshlogfile      : NULL
[17:59:32.408]  $ rshopts         : chr(0) 
[17:59:32.408]  $ rank            : int 1
[17:59:32.408]  $ manual          : logi FALSE
[17:59:32.408]  $ dryrun          : logi FALSE
[17:59:32.408]  $ quiet           : logi FALSE
[17:59:32.408]  $ setup_strategy  : chr "parallel"
[17:59:32.408]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:59:32.408]  $ pidfile         : chr "/tmp/RtmpW8h3IW/worker.rank=1.parallelly.parent=308299.4b44b3613ceb.pid"
[17:59:32.408]  $ rshcmd_label    : NULL
[17:59:32.408]  $ rsh_call        : NULL
[17:59:32.408]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:59:32.408]  $ localMachine    : logi TRUE
[17:59:32.408]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:59:32.408]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:59:32.408]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:59:32.408]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:59:32.408]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:59:32.408]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:59:32.408]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:59:32.408]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:59:32.408]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:59:32.408]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:59:32.408]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:59:32.408]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:59:32.408]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:59:32.408]  $ arguments       :List of 28
[17:59:32.408]   ..$ worker          : chr "localhost"
[17:59:32.408]   ..$ master          : NULL
[17:59:32.408]   ..$ port            : int 11318
[17:59:32.408]   ..$ connectTimeout  : num 120
[17:59:32.408]   ..$ timeout         : num 2592000
[17:59:32.408]   ..$ rscript         : NULL
[17:59:32.408]   ..$ homogeneous     : NULL
[17:59:32.408]   ..$ rscript_args    : NULL
[17:59:32.408]   ..$ rscript_envs    : NULL
[17:59:32.408]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:59:32.408]   ..$ rscript_startup : NULL
[17:59:32.408]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:59:32.408]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:59:32.408]   ..$ methods         : logi TRUE
[17:59:32.408]   ..$ socketOptions   : chr "no-delay"
[17:59:32.408]   ..$ useXDR          : logi FALSE
[17:59:32.408]   ..$ outfile         : chr "/dev/null"
[17:59:32.408]   ..$ renice          : int NA
[17:59:32.408]   ..$ rshcmd          : NULL
[17:59:32.408]   ..$ user            : NULL
[17:59:32.408]   ..$ revtunnel       : logi NA
[17:59:32.408]   ..$ rshlogfile      : NULL
[17:59:32.408]   ..$ rshopts         : NULL
[17:59:32.408]   ..$ rank            : int 1
[17:59:32.408]   ..$ manual          : logi FALSE
[17:59:32.408]   ..$ dryrun          : logi FALSE
[17:59:32.408]   ..$ quiet           : logi FALSE
[17:59:32.408]   ..$ setup_strategy  : chr "parallel"
[17:59:32.408]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:59:32.441] [local output] System call to launch all workers:
[17:59:32.441] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpW8h3IW/worker.rank=1.parallelly.parent=308299.4b44b3613ceb.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11318 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:59:32.441] [local output] Starting PSOCK main server
[17:59:32.450] [local output] Workers launched
[17:59:32.450] [local output] Waiting for workers to connect back
[17:59:32.450]  - [local output] 0 workers out of 2 ready
[17:59:32.801]  - [local output] 0 workers out of 2 ready
[17:59:32.802]  - [local output] 1 workers out of 2 ready
[17:59:32.803]  - [local output] 2 workers out of 2 ready
[17:59:32.803] [local output] Launching of workers completed
[17:59:32.803] [local output] Collecting session information from workers
[17:59:32.805] [local output]  - Worker #1 of 2
[17:59:32.806] [local output]  - Worker #2 of 2
[17:59:32.806] [local output] makeClusterPSOCK() ... done
[17:59:32.826] Packages needed by the future expression (n = 0): <none>
[17:59:32.826] Packages needed by future strategies (n = 0): <none>
[17:59:32.827] {
[17:59:32.827]     {
[17:59:32.827]         {
[17:59:32.827]             ...future.startTime <- base::Sys.time()
[17:59:32.827]             {
[17:59:32.827]                 {
[17:59:32.827]                   {
[17:59:32.827]                     {
[17:59:32.827]                       base::local({
[17:59:32.827]                         has_future <- base::requireNamespace("future", 
[17:59:32.827]                           quietly = TRUE)
[17:59:32.827]                         if (has_future) {
[17:59:32.827]                           ns <- base::getNamespace("future")
[17:59:32.827]                           version <- ns[[".package"]][["version"]]
[17:59:32.827]                           if (is.null(version)) 
[17:59:32.827]                             version <- utils::packageVersion("future")
[17:59:32.827]                         }
[17:59:32.827]                         else {
[17:59:32.827]                           version <- NULL
[17:59:32.827]                         }
[17:59:32.827]                         if (!has_future || version < "1.8.0") {
[17:59:32.827]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:32.827]                             "", base::R.version$version.string), 
[17:59:32.827]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:32.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:32.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:32.827]                               "release", "version")], collapse = " "), 
[17:59:32.827]                             hostname = base::Sys.info()[["nodename"]])
[17:59:32.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:32.827]                             info)
[17:59:32.827]                           info <- base::paste(info, collapse = "; ")
[17:59:32.827]                           if (!has_future) {
[17:59:32.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:32.827]                               info)
[17:59:32.827]                           }
[17:59:32.827]                           else {
[17:59:32.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:32.827]                               info, version)
[17:59:32.827]                           }
[17:59:32.827]                           base::stop(msg)
[17:59:32.827]                         }
[17:59:32.827]                       })
[17:59:32.827]                     }
[17:59:32.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:32.827]                     base::options(mc.cores = 1L)
[17:59:32.827]                   }
[17:59:32.827]                   ...future.strategy.old <- future::plan("list")
[17:59:32.827]                   options(future.plan = NULL)
[17:59:32.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:32.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:32.827]                 }
[17:59:32.827]                 ...future.workdir <- getwd()
[17:59:32.827]             }
[17:59:32.827]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:32.827]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:32.827]         }
[17:59:32.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:32.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:32.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:32.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:32.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:32.827]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:32.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:32.827]             base::names(...future.oldOptions))
[17:59:32.827]     }
[17:59:32.827]     if (FALSE) {
[17:59:32.827]     }
[17:59:32.827]     else {
[17:59:32.827]         if (TRUE) {
[17:59:32.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:32.827]                 open = "w")
[17:59:32.827]         }
[17:59:32.827]         else {
[17:59:32.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:32.827]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:32.827]         }
[17:59:32.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:32.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:32.827]             base::sink(type = "output", split = FALSE)
[17:59:32.827]             base::close(...future.stdout)
[17:59:32.827]         }, add = TRUE)
[17:59:32.827]     }
[17:59:32.827]     ...future.frame <- base::sys.nframe()
[17:59:32.827]     ...future.conditions <- base::list()
[17:59:32.827]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:32.827]     if (FALSE) {
[17:59:32.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:32.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:32.827]     }
[17:59:32.827]     ...future.result <- base::tryCatch({
[17:59:32.827]         base::withCallingHandlers({
[17:59:32.827]             ...future.value <- base::withVisible(base::local({
[17:59:32.827]                 ...future.makeSendCondition <- base::local({
[17:59:32.827]                   sendCondition <- NULL
[17:59:32.827]                   function(frame = 1L) {
[17:59:32.827]                     if (is.function(sendCondition)) 
[17:59:32.827]                       return(sendCondition)
[17:59:32.827]                     ns <- getNamespace("parallel")
[17:59:32.827]                     if (exists("sendData", mode = "function", 
[17:59:32.827]                       envir = ns)) {
[17:59:32.827]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:32.827]                         envir = ns)
[17:59:32.827]                       envir <- sys.frame(frame)
[17:59:32.827]                       master <- NULL
[17:59:32.827]                       while (!identical(envir, .GlobalEnv) && 
[17:59:32.827]                         !identical(envir, emptyenv())) {
[17:59:32.827]                         if (exists("master", mode = "list", envir = envir, 
[17:59:32.827]                           inherits = FALSE)) {
[17:59:32.827]                           master <- get("master", mode = "list", 
[17:59:32.827]                             envir = envir, inherits = FALSE)
[17:59:32.827]                           if (inherits(master, c("SOCKnode", 
[17:59:32.827]                             "SOCK0node"))) {
[17:59:32.827]                             sendCondition <<- function(cond) {
[17:59:32.827]                               data <- list(type = "VALUE", value = cond, 
[17:59:32.827]                                 success = TRUE)
[17:59:32.827]                               parallel_sendData(master, data)
[17:59:32.827]                             }
[17:59:32.827]                             return(sendCondition)
[17:59:32.827]                           }
[17:59:32.827]                         }
[17:59:32.827]                         frame <- frame + 1L
[17:59:32.827]                         envir <- sys.frame(frame)
[17:59:32.827]                       }
[17:59:32.827]                     }
[17:59:32.827]                     sendCondition <<- function(cond) NULL
[17:59:32.827]                   }
[17:59:32.827]                 })
[17:59:32.827]                 withCallingHandlers({
[17:59:32.827]                   NA
[17:59:32.827]                 }, immediateCondition = function(cond) {
[17:59:32.827]                   sendCondition <- ...future.makeSendCondition()
[17:59:32.827]                   sendCondition(cond)
[17:59:32.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:32.827]                   {
[17:59:32.827]                     inherits <- base::inherits
[17:59:32.827]                     invokeRestart <- base::invokeRestart
[17:59:32.827]                     is.null <- base::is.null
[17:59:32.827]                     muffled <- FALSE
[17:59:32.827]                     if (inherits(cond, "message")) {
[17:59:32.827]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:32.827]                       if (muffled) 
[17:59:32.827]                         invokeRestart("muffleMessage")
[17:59:32.827]                     }
[17:59:32.827]                     else if (inherits(cond, "warning")) {
[17:59:32.827]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:32.827]                       if (muffled) 
[17:59:32.827]                         invokeRestart("muffleWarning")
[17:59:32.827]                     }
[17:59:32.827]                     else if (inherits(cond, "condition")) {
[17:59:32.827]                       if (!is.null(pattern)) {
[17:59:32.827]                         computeRestarts <- base::computeRestarts
[17:59:32.827]                         grepl <- base::grepl
[17:59:32.827]                         restarts <- computeRestarts(cond)
[17:59:32.827]                         for (restart in restarts) {
[17:59:32.827]                           name <- restart$name
[17:59:32.827]                           if (is.null(name)) 
[17:59:32.827]                             next
[17:59:32.827]                           if (!grepl(pattern, name)) 
[17:59:32.827]                             next
[17:59:32.827]                           invokeRestart(restart)
[17:59:32.827]                           muffled <- TRUE
[17:59:32.827]                           break
[17:59:32.827]                         }
[17:59:32.827]                       }
[17:59:32.827]                     }
[17:59:32.827]                     invisible(muffled)
[17:59:32.827]                   }
[17:59:32.827]                   muffleCondition(cond)
[17:59:32.827]                 })
[17:59:32.827]             }))
[17:59:32.827]             future::FutureResult(value = ...future.value$value, 
[17:59:32.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:32.827]                   ...future.rng), globalenv = if (FALSE) 
[17:59:32.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:32.827]                     ...future.globalenv.names))
[17:59:32.827]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:32.827]         }, condition = base::local({
[17:59:32.827]             c <- base::c
[17:59:32.827]             inherits <- base::inherits
[17:59:32.827]             invokeRestart <- base::invokeRestart
[17:59:32.827]             length <- base::length
[17:59:32.827]             list <- base::list
[17:59:32.827]             seq.int <- base::seq.int
[17:59:32.827]             signalCondition <- base::signalCondition
[17:59:32.827]             sys.calls <- base::sys.calls
[17:59:32.827]             `[[` <- base::`[[`
[17:59:32.827]             `+` <- base::`+`
[17:59:32.827]             `<<-` <- base::`<<-`
[17:59:32.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:32.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:32.827]                   3L)]
[17:59:32.827]             }
[17:59:32.827]             function(cond) {
[17:59:32.827]                 is_error <- inherits(cond, "error")
[17:59:32.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:32.827]                   NULL)
[17:59:32.827]                 if (is_error) {
[17:59:32.827]                   sessionInformation <- function() {
[17:59:32.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:32.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:32.827]                       search = base::search(), system = base::Sys.info())
[17:59:32.827]                   }
[17:59:32.827]                   ...future.conditions[[length(...future.conditions) + 
[17:59:32.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:32.827]                     cond$call), session = sessionInformation(), 
[17:59:32.827]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:32.827]                   signalCondition(cond)
[17:59:32.827]                 }
[17:59:32.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:32.827]                 "immediateCondition"))) {
[17:59:32.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:32.827]                   ...future.conditions[[length(...future.conditions) + 
[17:59:32.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:32.827]                   if (TRUE && !signal) {
[17:59:32.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:32.827]                     {
[17:59:32.827]                       inherits <- base::inherits
[17:59:32.827]                       invokeRestart <- base::invokeRestart
[17:59:32.827]                       is.null <- base::is.null
[17:59:32.827]                       muffled <- FALSE
[17:59:32.827]                       if (inherits(cond, "message")) {
[17:59:32.827]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:32.827]                         if (muffled) 
[17:59:32.827]                           invokeRestart("muffleMessage")
[17:59:32.827]                       }
[17:59:32.827]                       else if (inherits(cond, "warning")) {
[17:59:32.827]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:32.827]                         if (muffled) 
[17:59:32.827]                           invokeRestart("muffleWarning")
[17:59:32.827]                       }
[17:59:32.827]                       else if (inherits(cond, "condition")) {
[17:59:32.827]                         if (!is.null(pattern)) {
[17:59:32.827]                           computeRestarts <- base::computeRestarts
[17:59:32.827]                           grepl <- base::grepl
[17:59:32.827]                           restarts <- computeRestarts(cond)
[17:59:32.827]                           for (restart in restarts) {
[17:59:32.827]                             name <- restart$name
[17:59:32.827]                             if (is.null(name)) 
[17:59:32.827]                               next
[17:59:32.827]                             if (!grepl(pattern, name)) 
[17:59:32.827]                               next
[17:59:32.827]                             invokeRestart(restart)
[17:59:32.827]                             muffled <- TRUE
[17:59:32.827]                             break
[17:59:32.827]                           }
[17:59:32.827]                         }
[17:59:32.827]                       }
[17:59:32.827]                       invisible(muffled)
[17:59:32.827]                     }
[17:59:32.827]                     muffleCondition(cond, pattern = "^muffle")
[17:59:32.827]                   }
[17:59:32.827]                 }
[17:59:32.827]                 else {
[17:59:32.827]                   if (TRUE) {
[17:59:32.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:32.827]                     {
[17:59:32.827]                       inherits <- base::inherits
[17:59:32.827]                       invokeRestart <- base::invokeRestart
[17:59:32.827]                       is.null <- base::is.null
[17:59:32.827]                       muffled <- FALSE
[17:59:32.827]                       if (inherits(cond, "message")) {
[17:59:32.827]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:32.827]                         if (muffled) 
[17:59:32.827]                           invokeRestart("muffleMessage")
[17:59:32.827]                       }
[17:59:32.827]                       else if (inherits(cond, "warning")) {
[17:59:32.827]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:32.827]                         if (muffled) 
[17:59:32.827]                           invokeRestart("muffleWarning")
[17:59:32.827]                       }
[17:59:32.827]                       else if (inherits(cond, "condition")) {
[17:59:32.827]                         if (!is.null(pattern)) {
[17:59:32.827]                           computeRestarts <- base::computeRestarts
[17:59:32.827]                           grepl <- base::grepl
[17:59:32.827]                           restarts <- computeRestarts(cond)
[17:59:32.827]                           for (restart in restarts) {
[17:59:32.827]                             name <- restart$name
[17:59:32.827]                             if (is.null(name)) 
[17:59:32.827]                               next
[17:59:32.827]                             if (!grepl(pattern, name)) 
[17:59:32.827]                               next
[17:59:32.827]                             invokeRestart(restart)
[17:59:32.827]                             muffled <- TRUE
[17:59:32.827]                             break
[17:59:32.827]                           }
[17:59:32.827]                         }
[17:59:32.827]                       }
[17:59:32.827]                       invisible(muffled)
[17:59:32.827]                     }
[17:59:32.827]                     muffleCondition(cond, pattern = "^muffle")
[17:59:32.827]                   }
[17:59:32.827]                 }
[17:59:32.827]             }
[17:59:32.827]         }))
[17:59:32.827]     }, error = function(ex) {
[17:59:32.827]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:32.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:32.827]                 ...future.rng), started = ...future.startTime, 
[17:59:32.827]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:32.827]             version = "1.8"), class = "FutureResult")
[17:59:32.827]     }, finally = {
[17:59:32.827]         if (!identical(...future.workdir, getwd())) 
[17:59:32.827]             setwd(...future.workdir)
[17:59:32.827]         {
[17:59:32.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:32.827]                 ...future.oldOptions$nwarnings <- NULL
[17:59:32.827]             }
[17:59:32.827]             base::options(...future.oldOptions)
[17:59:32.827]             if (.Platform$OS.type == "windows") {
[17:59:32.827]                 old_names <- names(...future.oldEnvVars)
[17:59:32.827]                 envs <- base::Sys.getenv()
[17:59:32.827]                 names <- names(envs)
[17:59:32.827]                 common <- intersect(names, old_names)
[17:59:32.827]                 added <- setdiff(names, old_names)
[17:59:32.827]                 removed <- setdiff(old_names, names)
[17:59:32.827]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:32.827]                   envs[common]]
[17:59:32.827]                 NAMES <- toupper(changed)
[17:59:32.827]                 args <- list()
[17:59:32.827]                 for (kk in seq_along(NAMES)) {
[17:59:32.827]                   name <- changed[[kk]]
[17:59:32.827]                   NAME <- NAMES[[kk]]
[17:59:32.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:32.827]                     next
[17:59:32.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:32.827]                 }
[17:59:32.827]                 NAMES <- toupper(added)
[17:59:32.827]                 for (kk in seq_along(NAMES)) {
[17:59:32.827]                   name <- added[[kk]]
[17:59:32.827]                   NAME <- NAMES[[kk]]
[17:59:32.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:32.827]                     next
[17:59:32.827]                   args[[name]] <- ""
[17:59:32.827]                 }
[17:59:32.827]                 NAMES <- toupper(removed)
[17:59:32.827]                 for (kk in seq_along(NAMES)) {
[17:59:32.827]                   name <- removed[[kk]]
[17:59:32.827]                   NAME <- NAMES[[kk]]
[17:59:32.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:32.827]                     next
[17:59:32.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:32.827]                 }
[17:59:32.827]                 if (length(args) > 0) 
[17:59:32.827]                   base::do.call(base::Sys.setenv, args = args)
[17:59:32.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:32.827]             }
[17:59:32.827]             else {
[17:59:32.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:32.827]             }
[17:59:32.827]             {
[17:59:32.827]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:32.827]                   0L) {
[17:59:32.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:32.827]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:32.827]                   base::options(opts)
[17:59:32.827]                 }
[17:59:32.827]                 {
[17:59:32.827]                   {
[17:59:32.827]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:32.827]                     NULL
[17:59:32.827]                   }
[17:59:32.827]                   options(future.plan = NULL)
[17:59:32.827]                   if (is.na(NA_character_)) 
[17:59:32.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:32.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:32.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:32.827]                     .init = FALSE)
[17:59:32.827]                 }
[17:59:32.827]             }
[17:59:32.827]         }
[17:59:32.827]     })
[17:59:32.827]     if (TRUE) {
[17:59:32.827]         base::sink(type = "output", split = FALSE)
[17:59:32.827]         if (TRUE) {
[17:59:32.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:32.827]         }
[17:59:32.827]         else {
[17:59:32.827]             ...future.result["stdout"] <- base::list(NULL)
[17:59:32.827]         }
[17:59:32.827]         base::close(...future.stdout)
[17:59:32.827]         ...future.stdout <- NULL
[17:59:32.827]     }
[17:59:32.827]     ...future.result$conditions <- ...future.conditions
[17:59:32.827]     ...future.result$finished <- base::Sys.time()
[17:59:32.827]     ...future.result
[17:59:32.827] }
[17:59:32.926] MultisessionFuture started
[17:59:32.927] result() for ClusterFuture ...
[17:59:32.928] receiveMessageFromWorker() for ClusterFuture ...
[17:59:32.928] - Validating connection of MultisessionFuture
[17:59:32.990] - received message: FutureResult
[17:59:32.991] - Received FutureResult
[17:59:32.991] - Erased future from FutureRegistry
[17:59:32.992] result() for ClusterFuture ...
[17:59:32.992] - result already collected: FutureResult
[17:59:32.992] result() for ClusterFuture ... done
[17:59:32.992] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:32.993] result() for ClusterFuture ... done
[17:59:32.993] result() for ClusterFuture ...
[17:59:32.993] - result already collected: FutureResult
[17:59:32.994] result() for ClusterFuture ... done
[17:59:32.994] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:59:33.001] plan(): nbrOfWorkers() = 2
[17:59:33.002] future_lapply() ...
[17:59:33.010] Number of chunks: 2
[17:59:33.010] getGlobalsAndPackagesXApply() ...
[17:59:33.010]  - future.globals: TRUE
[17:59:33.011] getGlobalsAndPackages() ...
[17:59:33.011] Searching for globals...
[17:59:33.014] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:33.014] Searching for globals ... DONE
[17:59:33.014] Resolving globals: FALSE
[17:59:33.015] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:33.016] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:33.016] - globals: [1] ‘FUN’
[17:59:33.017] 
[17:59:33.017] getGlobalsAndPackages() ... DONE
[17:59:33.017]  - globals found/used: [n=1] ‘FUN’
[17:59:33.018]  - needed namespaces: [n=0] 
[17:59:33.018] Finding globals ... DONE
[17:59:33.018]  - use_args: TRUE
[17:59:33.018]  - Getting '...' globals ...
[17:59:33.019] resolve() on list ...
[17:59:33.019]  recursive: 0
[17:59:33.020]  length: 1
[17:59:33.020]  elements: ‘...’
[17:59:33.020]  length: 0 (resolved future 1)
[17:59:33.020] resolve() on list ... DONE
[17:59:33.021]    - '...' content: [n=0] 
[17:59:33.021] List of 1
[17:59:33.021]  $ ...: list()
[17:59:33.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.021]  - attr(*, "where")=List of 1
[17:59:33.021]   ..$ ...:<environment: 0x58d4c5c01a58> 
[17:59:33.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.021]  - attr(*, "resolved")= logi TRUE
[17:59:33.021]  - attr(*, "total_size")= num NA
[17:59:33.028]  - Getting '...' globals ... DONE
[17:59:33.028] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:33.028] List of 2
[17:59:33.028]  $ ...future.FUN:function (x, ...)  
[17:59:33.028]  $ ...          : list()
[17:59:33.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.028]  - attr(*, "where")=List of 2
[17:59:33.028]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:33.028]   ..$ ...          :<environment: 0x58d4c5c01a58> 
[17:59:33.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.028]  - attr(*, "resolved")= logi FALSE
[17:59:33.028]  - attr(*, "total_size")= num 1240
[17:59:33.036] Packages to be attached in all futures: [n=0] 
[17:59:33.036] getGlobalsAndPackagesXApply() ... DONE
[17:59:33.037] Number of futures (= number of chunks): 2
[17:59:33.037] Launching 2 futures (chunks) ...
[17:59:33.037] Chunk #1 of 2 ...
[17:59:33.038]  - Finding globals in 'X' for chunk #1 ...
[17:59:33.038] getGlobalsAndPackages() ...
[17:59:33.038] Searching for globals...
[17:59:33.039] 
[17:59:33.039] Searching for globals ... DONE
[17:59:33.039] - globals: [0] <none>
[17:59:33.040] getGlobalsAndPackages() ... DONE
[17:59:33.040]    + additional globals found: [n=0] 
[17:59:33.040]    + additional namespaces needed: [n=0] 
[17:59:33.040]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:33.041]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.041]  - seeds: <none>
[17:59:33.041]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.041] getGlobalsAndPackages() ...
[17:59:33.042] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.042] Resolving globals: FALSE
[17:59:33.042] Tweak future expression to call with '...' arguments ...
[17:59:33.042] {
[17:59:33.042]     do.call(function(...) {
[17:59:33.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.042]             on.exit(options(oopts), add = TRUE)
[17:59:33.042]         }
[17:59:33.042]         {
[17:59:33.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.042]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.042]             })
[17:59:33.042]         }
[17:59:33.042]     }, args = future.call.arguments)
[17:59:33.042] }
[17:59:33.043] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.044] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.045] 
[17:59:33.045] getGlobalsAndPackages() ... DONE
[17:59:33.045] run() for ‘Future’ ...
[17:59:33.046] - state: ‘created’
[17:59:33.046] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.073] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.074]   - Field: ‘node’
[17:59:33.074]   - Field: ‘label’
[17:59:33.074]   - Field: ‘local’
[17:59:33.074]   - Field: ‘owner’
[17:59:33.074]   - Field: ‘envir’
[17:59:33.075]   - Field: ‘workers’
[17:59:33.075]   - Field: ‘packages’
[17:59:33.075]   - Field: ‘gc’
[17:59:33.075]   - Field: ‘conditions’
[17:59:33.075]   - Field: ‘persistent’
[17:59:33.076]   - Field: ‘expr’
[17:59:33.076]   - Field: ‘uuid’
[17:59:33.076]   - Field: ‘seed’
[17:59:33.076]   - Field: ‘version’
[17:59:33.077]   - Field: ‘result’
[17:59:33.077]   - Field: ‘asynchronous’
[17:59:33.077]   - Field: ‘calls’
[17:59:33.077]   - Field: ‘globals’
[17:59:33.078]   - Field: ‘stdout’
[17:59:33.078]   - Field: ‘earlySignal’
[17:59:33.078]   - Field: ‘lazy’
[17:59:33.078]   - Field: ‘state’
[17:59:33.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.079] - Launch lazy future ...
[17:59:33.079] Packages needed by the future expression (n = 0): <none>
[17:59:33.080] Packages needed by future strategies (n = 0): <none>
[17:59:33.081] {
[17:59:33.081]     {
[17:59:33.081]         {
[17:59:33.081]             ...future.startTime <- base::Sys.time()
[17:59:33.081]             {
[17:59:33.081]                 {
[17:59:33.081]                   {
[17:59:33.081]                     {
[17:59:33.081]                       base::local({
[17:59:33.081]                         has_future <- base::requireNamespace("future", 
[17:59:33.081]                           quietly = TRUE)
[17:59:33.081]                         if (has_future) {
[17:59:33.081]                           ns <- base::getNamespace("future")
[17:59:33.081]                           version <- ns[[".package"]][["version"]]
[17:59:33.081]                           if (is.null(version)) 
[17:59:33.081]                             version <- utils::packageVersion("future")
[17:59:33.081]                         }
[17:59:33.081]                         else {
[17:59:33.081]                           version <- NULL
[17:59:33.081]                         }
[17:59:33.081]                         if (!has_future || version < "1.8.0") {
[17:59:33.081]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.081]                             "", base::R.version$version.string), 
[17:59:33.081]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:33.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:33.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.081]                               "release", "version")], collapse = " "), 
[17:59:33.081]                             hostname = base::Sys.info()[["nodename"]])
[17:59:33.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.081]                             info)
[17:59:33.081]                           info <- base::paste(info, collapse = "; ")
[17:59:33.081]                           if (!has_future) {
[17:59:33.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.081]                               info)
[17:59:33.081]                           }
[17:59:33.081]                           else {
[17:59:33.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.081]                               info, version)
[17:59:33.081]                           }
[17:59:33.081]                           base::stop(msg)
[17:59:33.081]                         }
[17:59:33.081]                       })
[17:59:33.081]                     }
[17:59:33.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.081]                     base::options(mc.cores = 1L)
[17:59:33.081]                   }
[17:59:33.081]                   ...future.strategy.old <- future::plan("list")
[17:59:33.081]                   options(future.plan = NULL)
[17:59:33.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.081]                 }
[17:59:33.081]                 ...future.workdir <- getwd()
[17:59:33.081]             }
[17:59:33.081]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.081]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.081]         }
[17:59:33.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.081]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.081]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.081]             base::names(...future.oldOptions))
[17:59:33.081]     }
[17:59:33.081]     if (FALSE) {
[17:59:33.081]     }
[17:59:33.081]     else {
[17:59:33.081]         if (TRUE) {
[17:59:33.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.081]                 open = "w")
[17:59:33.081]         }
[17:59:33.081]         else {
[17:59:33.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.081]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.081]         }
[17:59:33.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.081]             base::sink(type = "output", split = FALSE)
[17:59:33.081]             base::close(...future.stdout)
[17:59:33.081]         }, add = TRUE)
[17:59:33.081]     }
[17:59:33.081]     ...future.frame <- base::sys.nframe()
[17:59:33.081]     ...future.conditions <- base::list()
[17:59:33.081]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.081]     if (FALSE) {
[17:59:33.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.081]     }
[17:59:33.081]     ...future.result <- base::tryCatch({
[17:59:33.081]         base::withCallingHandlers({
[17:59:33.081]             ...future.value <- base::withVisible(base::local({
[17:59:33.081]                 ...future.makeSendCondition <- base::local({
[17:59:33.081]                   sendCondition <- NULL
[17:59:33.081]                   function(frame = 1L) {
[17:59:33.081]                     if (is.function(sendCondition)) 
[17:59:33.081]                       return(sendCondition)
[17:59:33.081]                     ns <- getNamespace("parallel")
[17:59:33.081]                     if (exists("sendData", mode = "function", 
[17:59:33.081]                       envir = ns)) {
[17:59:33.081]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.081]                         envir = ns)
[17:59:33.081]                       envir <- sys.frame(frame)
[17:59:33.081]                       master <- NULL
[17:59:33.081]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.081]                         !identical(envir, emptyenv())) {
[17:59:33.081]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.081]                           inherits = FALSE)) {
[17:59:33.081]                           master <- get("master", mode = "list", 
[17:59:33.081]                             envir = envir, inherits = FALSE)
[17:59:33.081]                           if (inherits(master, c("SOCKnode", 
[17:59:33.081]                             "SOCK0node"))) {
[17:59:33.081]                             sendCondition <<- function(cond) {
[17:59:33.081]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.081]                                 success = TRUE)
[17:59:33.081]                               parallel_sendData(master, data)
[17:59:33.081]                             }
[17:59:33.081]                             return(sendCondition)
[17:59:33.081]                           }
[17:59:33.081]                         }
[17:59:33.081]                         frame <- frame + 1L
[17:59:33.081]                         envir <- sys.frame(frame)
[17:59:33.081]                       }
[17:59:33.081]                     }
[17:59:33.081]                     sendCondition <<- function(cond) NULL
[17:59:33.081]                   }
[17:59:33.081]                 })
[17:59:33.081]                 withCallingHandlers({
[17:59:33.081]                   {
[17:59:33.081]                     do.call(function(...) {
[17:59:33.081]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.081]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.081]                         ...future.globals.maxSize)) {
[17:59:33.081]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.081]                         on.exit(options(oopts), add = TRUE)
[17:59:33.081]                       }
[17:59:33.081]                       {
[17:59:33.081]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.081]                           FUN = function(jj) {
[17:59:33.081]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.081]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.081]                           })
[17:59:33.081]                       }
[17:59:33.081]                     }, args = future.call.arguments)
[17:59:33.081]                   }
[17:59:33.081]                 }, immediateCondition = function(cond) {
[17:59:33.081]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.081]                   sendCondition(cond)
[17:59:33.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.081]                   {
[17:59:33.081]                     inherits <- base::inherits
[17:59:33.081]                     invokeRestart <- base::invokeRestart
[17:59:33.081]                     is.null <- base::is.null
[17:59:33.081]                     muffled <- FALSE
[17:59:33.081]                     if (inherits(cond, "message")) {
[17:59:33.081]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.081]                       if (muffled) 
[17:59:33.081]                         invokeRestart("muffleMessage")
[17:59:33.081]                     }
[17:59:33.081]                     else if (inherits(cond, "warning")) {
[17:59:33.081]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.081]                       if (muffled) 
[17:59:33.081]                         invokeRestart("muffleWarning")
[17:59:33.081]                     }
[17:59:33.081]                     else if (inherits(cond, "condition")) {
[17:59:33.081]                       if (!is.null(pattern)) {
[17:59:33.081]                         computeRestarts <- base::computeRestarts
[17:59:33.081]                         grepl <- base::grepl
[17:59:33.081]                         restarts <- computeRestarts(cond)
[17:59:33.081]                         for (restart in restarts) {
[17:59:33.081]                           name <- restart$name
[17:59:33.081]                           if (is.null(name)) 
[17:59:33.081]                             next
[17:59:33.081]                           if (!grepl(pattern, name)) 
[17:59:33.081]                             next
[17:59:33.081]                           invokeRestart(restart)
[17:59:33.081]                           muffled <- TRUE
[17:59:33.081]                           break
[17:59:33.081]                         }
[17:59:33.081]                       }
[17:59:33.081]                     }
[17:59:33.081]                     invisible(muffled)
[17:59:33.081]                   }
[17:59:33.081]                   muffleCondition(cond)
[17:59:33.081]                 })
[17:59:33.081]             }))
[17:59:33.081]             future::FutureResult(value = ...future.value$value, 
[17:59:33.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.081]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.081]                     ...future.globalenv.names))
[17:59:33.081]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.081]         }, condition = base::local({
[17:59:33.081]             c <- base::c
[17:59:33.081]             inherits <- base::inherits
[17:59:33.081]             invokeRestart <- base::invokeRestart
[17:59:33.081]             length <- base::length
[17:59:33.081]             list <- base::list
[17:59:33.081]             seq.int <- base::seq.int
[17:59:33.081]             signalCondition <- base::signalCondition
[17:59:33.081]             sys.calls <- base::sys.calls
[17:59:33.081]             `[[` <- base::`[[`
[17:59:33.081]             `+` <- base::`+`
[17:59:33.081]             `<<-` <- base::`<<-`
[17:59:33.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.081]                   3L)]
[17:59:33.081]             }
[17:59:33.081]             function(cond) {
[17:59:33.081]                 is_error <- inherits(cond, "error")
[17:59:33.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.081]                   NULL)
[17:59:33.081]                 if (is_error) {
[17:59:33.081]                   sessionInformation <- function() {
[17:59:33.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.081]                       search = base::search(), system = base::Sys.info())
[17:59:33.081]                   }
[17:59:33.081]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.081]                     cond$call), session = sessionInformation(), 
[17:59:33.081]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.081]                   signalCondition(cond)
[17:59:33.081]                 }
[17:59:33.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.081]                 "immediateCondition"))) {
[17:59:33.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.081]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.081]                   if (TRUE && !signal) {
[17:59:33.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.081]                     {
[17:59:33.081]                       inherits <- base::inherits
[17:59:33.081]                       invokeRestart <- base::invokeRestart
[17:59:33.081]                       is.null <- base::is.null
[17:59:33.081]                       muffled <- FALSE
[17:59:33.081]                       if (inherits(cond, "message")) {
[17:59:33.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.081]                         if (muffled) 
[17:59:33.081]                           invokeRestart("muffleMessage")
[17:59:33.081]                       }
[17:59:33.081]                       else if (inherits(cond, "warning")) {
[17:59:33.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.081]                         if (muffled) 
[17:59:33.081]                           invokeRestart("muffleWarning")
[17:59:33.081]                       }
[17:59:33.081]                       else if (inherits(cond, "condition")) {
[17:59:33.081]                         if (!is.null(pattern)) {
[17:59:33.081]                           computeRestarts <- base::computeRestarts
[17:59:33.081]                           grepl <- base::grepl
[17:59:33.081]                           restarts <- computeRestarts(cond)
[17:59:33.081]                           for (restart in restarts) {
[17:59:33.081]                             name <- restart$name
[17:59:33.081]                             if (is.null(name)) 
[17:59:33.081]                               next
[17:59:33.081]                             if (!grepl(pattern, name)) 
[17:59:33.081]                               next
[17:59:33.081]                             invokeRestart(restart)
[17:59:33.081]                             muffled <- TRUE
[17:59:33.081]                             break
[17:59:33.081]                           }
[17:59:33.081]                         }
[17:59:33.081]                       }
[17:59:33.081]                       invisible(muffled)
[17:59:33.081]                     }
[17:59:33.081]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.081]                   }
[17:59:33.081]                 }
[17:59:33.081]                 else {
[17:59:33.081]                   if (TRUE) {
[17:59:33.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.081]                     {
[17:59:33.081]                       inherits <- base::inherits
[17:59:33.081]                       invokeRestart <- base::invokeRestart
[17:59:33.081]                       is.null <- base::is.null
[17:59:33.081]                       muffled <- FALSE
[17:59:33.081]                       if (inherits(cond, "message")) {
[17:59:33.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.081]                         if (muffled) 
[17:59:33.081]                           invokeRestart("muffleMessage")
[17:59:33.081]                       }
[17:59:33.081]                       else if (inherits(cond, "warning")) {
[17:59:33.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.081]                         if (muffled) 
[17:59:33.081]                           invokeRestart("muffleWarning")
[17:59:33.081]                       }
[17:59:33.081]                       else if (inherits(cond, "condition")) {
[17:59:33.081]                         if (!is.null(pattern)) {
[17:59:33.081]                           computeRestarts <- base::computeRestarts
[17:59:33.081]                           grepl <- base::grepl
[17:59:33.081]                           restarts <- computeRestarts(cond)
[17:59:33.081]                           for (restart in restarts) {
[17:59:33.081]                             name <- restart$name
[17:59:33.081]                             if (is.null(name)) 
[17:59:33.081]                               next
[17:59:33.081]                             if (!grepl(pattern, name)) 
[17:59:33.081]                               next
[17:59:33.081]                             invokeRestart(restart)
[17:59:33.081]                             muffled <- TRUE
[17:59:33.081]                             break
[17:59:33.081]                           }
[17:59:33.081]                         }
[17:59:33.081]                       }
[17:59:33.081]                       invisible(muffled)
[17:59:33.081]                     }
[17:59:33.081]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.081]                   }
[17:59:33.081]                 }
[17:59:33.081]             }
[17:59:33.081]         }))
[17:59:33.081]     }, error = function(ex) {
[17:59:33.081]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.081]                 ...future.rng), started = ...future.startTime, 
[17:59:33.081]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.081]             version = "1.8"), class = "FutureResult")
[17:59:33.081]     }, finally = {
[17:59:33.081]         if (!identical(...future.workdir, getwd())) 
[17:59:33.081]             setwd(...future.workdir)
[17:59:33.081]         {
[17:59:33.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.081]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.081]             }
[17:59:33.081]             base::options(...future.oldOptions)
[17:59:33.081]             if (.Platform$OS.type == "windows") {
[17:59:33.081]                 old_names <- names(...future.oldEnvVars)
[17:59:33.081]                 envs <- base::Sys.getenv()
[17:59:33.081]                 names <- names(envs)
[17:59:33.081]                 common <- intersect(names, old_names)
[17:59:33.081]                 added <- setdiff(names, old_names)
[17:59:33.081]                 removed <- setdiff(old_names, names)
[17:59:33.081]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.081]                   envs[common]]
[17:59:33.081]                 NAMES <- toupper(changed)
[17:59:33.081]                 args <- list()
[17:59:33.081]                 for (kk in seq_along(NAMES)) {
[17:59:33.081]                   name <- changed[[kk]]
[17:59:33.081]                   NAME <- NAMES[[kk]]
[17:59:33.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.081]                     next
[17:59:33.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.081]                 }
[17:59:33.081]                 NAMES <- toupper(added)
[17:59:33.081]                 for (kk in seq_along(NAMES)) {
[17:59:33.081]                   name <- added[[kk]]
[17:59:33.081]                   NAME <- NAMES[[kk]]
[17:59:33.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.081]                     next
[17:59:33.081]                   args[[name]] <- ""
[17:59:33.081]                 }
[17:59:33.081]                 NAMES <- toupper(removed)
[17:59:33.081]                 for (kk in seq_along(NAMES)) {
[17:59:33.081]                   name <- removed[[kk]]
[17:59:33.081]                   NAME <- NAMES[[kk]]
[17:59:33.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.081]                     next
[17:59:33.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.081]                 }
[17:59:33.081]                 if (length(args) > 0) 
[17:59:33.081]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.081]             }
[17:59:33.081]             else {
[17:59:33.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.081]             }
[17:59:33.081]             {
[17:59:33.081]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.081]                   0L) {
[17:59:33.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.081]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.081]                   base::options(opts)
[17:59:33.081]                 }
[17:59:33.081]                 {
[17:59:33.081]                   {
[17:59:33.081]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.081]                     NULL
[17:59:33.081]                   }
[17:59:33.081]                   options(future.plan = NULL)
[17:59:33.081]                   if (is.na(NA_character_)) 
[17:59:33.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.081]                     .init = FALSE)
[17:59:33.081]                 }
[17:59:33.081]             }
[17:59:33.081]         }
[17:59:33.081]     })
[17:59:33.081]     if (TRUE) {
[17:59:33.081]         base::sink(type = "output", split = FALSE)
[17:59:33.081]         if (TRUE) {
[17:59:33.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.081]         }
[17:59:33.081]         else {
[17:59:33.081]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.081]         }
[17:59:33.081]         base::close(...future.stdout)
[17:59:33.081]         ...future.stdout <- NULL
[17:59:33.081]     }
[17:59:33.081]     ...future.result$conditions <- ...future.conditions
[17:59:33.081]     ...future.result$finished <- base::Sys.time()
[17:59:33.081]     ...future.result
[17:59:33.081] }
[17:59:33.086] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:59:33.087] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:59:33.087] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:59:33.088] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:33.089] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.089] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:59:33.090] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:59:33.091] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:33.091] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.092] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:33.093] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.093] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:59:33.094] MultisessionFuture started
[17:59:33.094] - Launch lazy future ... done
[17:59:33.095] run() for ‘MultisessionFuture’ ... done
[17:59:33.095] Created future:
[17:59:33.095] MultisessionFuture:
[17:59:33.095] Label: ‘future_eapply-1’
[17:59:33.095] Expression:
[17:59:33.095] {
[17:59:33.095]     do.call(function(...) {
[17:59:33.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.095]             on.exit(options(oopts), add = TRUE)
[17:59:33.095]         }
[17:59:33.095]         {
[17:59:33.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.095]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.095]             })
[17:59:33.095]         }
[17:59:33.095]     }, args = future.call.arguments)
[17:59:33.095] }
[17:59:33.095] Lazy evaluation: FALSE
[17:59:33.095] Asynchronous evaluation: TRUE
[17:59:33.095] Local evaluation: TRUE
[17:59:33.095] Environment: R_GlobalEnv
[17:59:33.095] Capture standard output: TRUE
[17:59:33.095] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.095] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.095] Packages: <none>
[17:59:33.095] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.095] Resolved: FALSE
[17:59:33.095] Value: <not collected>
[17:59:33.095] Conditions captured: <none>
[17:59:33.095] Early signaling: FALSE
[17:59:33.095] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.095] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.109] Chunk #1 of 2 ... DONE
[17:59:33.109] Chunk #2 of 2 ...
[17:59:33.110]  - Finding globals in 'X' for chunk #2 ...
[17:59:33.110] getGlobalsAndPackages() ...
[17:59:33.110] Searching for globals...
[17:59:33.111] 
[17:59:33.111] Searching for globals ... DONE
[17:59:33.111] - globals: [0] <none>
[17:59:33.112] getGlobalsAndPackages() ... DONE
[17:59:33.112]    + additional globals found: [n=0] 
[17:59:33.112]    + additional namespaces needed: [n=0] 
[17:59:33.112]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:33.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.113]  - seeds: <none>
[17:59:33.113]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.113] getGlobalsAndPackages() ...
[17:59:33.114] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.114] Resolving globals: FALSE
[17:59:33.114] Tweak future expression to call with '...' arguments ...
[17:59:33.114] {
[17:59:33.114]     do.call(function(...) {
[17:59:33.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.114]             on.exit(options(oopts), add = TRUE)
[17:59:33.114]         }
[17:59:33.114]         {
[17:59:33.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.114]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.114]             })
[17:59:33.114]         }
[17:59:33.114]     }, args = future.call.arguments)
[17:59:33.114] }
[17:59:33.115] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.116] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.116] 
[17:59:33.116] getGlobalsAndPackages() ... DONE
[17:59:33.117] run() for ‘Future’ ...
[17:59:33.117] - state: ‘created’
[17:59:33.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.148]   - Field: ‘node’
[17:59:33.148]   - Field: ‘label’
[17:59:33.148]   - Field: ‘local’
[17:59:33.148]   - Field: ‘owner’
[17:59:33.149]   - Field: ‘envir’
[17:59:33.149]   - Field: ‘workers’
[17:59:33.149]   - Field: ‘packages’
[17:59:33.149]   - Field: ‘gc’
[17:59:33.149]   - Field: ‘conditions’
[17:59:33.150]   - Field: ‘persistent’
[17:59:33.150]   - Field: ‘expr’
[17:59:33.150]   - Field: ‘uuid’
[17:59:33.150]   - Field: ‘seed’
[17:59:33.151]   - Field: ‘version’
[17:59:33.151]   - Field: ‘result’
[17:59:33.151]   - Field: ‘asynchronous’
[17:59:33.151]   - Field: ‘calls’
[17:59:33.152]   - Field: ‘globals’
[17:59:33.152]   - Field: ‘stdout’
[17:59:33.152]   - Field: ‘earlySignal’
[17:59:33.152]   - Field: ‘lazy’
[17:59:33.152]   - Field: ‘state’
[17:59:33.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.153] - Launch lazy future ...
[17:59:33.154] Packages needed by the future expression (n = 0): <none>
[17:59:33.154] Packages needed by future strategies (n = 0): <none>
[17:59:33.155] {
[17:59:33.155]     {
[17:59:33.155]         {
[17:59:33.155]             ...future.startTime <- base::Sys.time()
[17:59:33.155]             {
[17:59:33.155]                 {
[17:59:33.155]                   {
[17:59:33.155]                     {
[17:59:33.155]                       base::local({
[17:59:33.155]                         has_future <- base::requireNamespace("future", 
[17:59:33.155]                           quietly = TRUE)
[17:59:33.155]                         if (has_future) {
[17:59:33.155]                           ns <- base::getNamespace("future")
[17:59:33.155]                           version <- ns[[".package"]][["version"]]
[17:59:33.155]                           if (is.null(version)) 
[17:59:33.155]                             version <- utils::packageVersion("future")
[17:59:33.155]                         }
[17:59:33.155]                         else {
[17:59:33.155]                           version <- NULL
[17:59:33.155]                         }
[17:59:33.155]                         if (!has_future || version < "1.8.0") {
[17:59:33.155]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.155]                             "", base::R.version$version.string), 
[17:59:33.155]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:33.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:33.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.155]                               "release", "version")], collapse = " "), 
[17:59:33.155]                             hostname = base::Sys.info()[["nodename"]])
[17:59:33.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.155]                             info)
[17:59:33.155]                           info <- base::paste(info, collapse = "; ")
[17:59:33.155]                           if (!has_future) {
[17:59:33.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.155]                               info)
[17:59:33.155]                           }
[17:59:33.155]                           else {
[17:59:33.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.155]                               info, version)
[17:59:33.155]                           }
[17:59:33.155]                           base::stop(msg)
[17:59:33.155]                         }
[17:59:33.155]                       })
[17:59:33.155]                     }
[17:59:33.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.155]                     base::options(mc.cores = 1L)
[17:59:33.155]                   }
[17:59:33.155]                   ...future.strategy.old <- future::plan("list")
[17:59:33.155]                   options(future.plan = NULL)
[17:59:33.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.155]                 }
[17:59:33.155]                 ...future.workdir <- getwd()
[17:59:33.155]             }
[17:59:33.155]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.155]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.155]         }
[17:59:33.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.155]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.155]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.155]             base::names(...future.oldOptions))
[17:59:33.155]     }
[17:59:33.155]     if (FALSE) {
[17:59:33.155]     }
[17:59:33.155]     else {
[17:59:33.155]         if (TRUE) {
[17:59:33.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.155]                 open = "w")
[17:59:33.155]         }
[17:59:33.155]         else {
[17:59:33.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.155]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.155]         }
[17:59:33.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.155]             base::sink(type = "output", split = FALSE)
[17:59:33.155]             base::close(...future.stdout)
[17:59:33.155]         }, add = TRUE)
[17:59:33.155]     }
[17:59:33.155]     ...future.frame <- base::sys.nframe()
[17:59:33.155]     ...future.conditions <- base::list()
[17:59:33.155]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.155]     if (FALSE) {
[17:59:33.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.155]     }
[17:59:33.155]     ...future.result <- base::tryCatch({
[17:59:33.155]         base::withCallingHandlers({
[17:59:33.155]             ...future.value <- base::withVisible(base::local({
[17:59:33.155]                 ...future.makeSendCondition <- base::local({
[17:59:33.155]                   sendCondition <- NULL
[17:59:33.155]                   function(frame = 1L) {
[17:59:33.155]                     if (is.function(sendCondition)) 
[17:59:33.155]                       return(sendCondition)
[17:59:33.155]                     ns <- getNamespace("parallel")
[17:59:33.155]                     if (exists("sendData", mode = "function", 
[17:59:33.155]                       envir = ns)) {
[17:59:33.155]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.155]                         envir = ns)
[17:59:33.155]                       envir <- sys.frame(frame)
[17:59:33.155]                       master <- NULL
[17:59:33.155]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.155]                         !identical(envir, emptyenv())) {
[17:59:33.155]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.155]                           inherits = FALSE)) {
[17:59:33.155]                           master <- get("master", mode = "list", 
[17:59:33.155]                             envir = envir, inherits = FALSE)
[17:59:33.155]                           if (inherits(master, c("SOCKnode", 
[17:59:33.155]                             "SOCK0node"))) {
[17:59:33.155]                             sendCondition <<- function(cond) {
[17:59:33.155]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.155]                                 success = TRUE)
[17:59:33.155]                               parallel_sendData(master, data)
[17:59:33.155]                             }
[17:59:33.155]                             return(sendCondition)
[17:59:33.155]                           }
[17:59:33.155]                         }
[17:59:33.155]                         frame <- frame + 1L
[17:59:33.155]                         envir <- sys.frame(frame)
[17:59:33.155]                       }
[17:59:33.155]                     }
[17:59:33.155]                     sendCondition <<- function(cond) NULL
[17:59:33.155]                   }
[17:59:33.155]                 })
[17:59:33.155]                 withCallingHandlers({
[17:59:33.155]                   {
[17:59:33.155]                     do.call(function(...) {
[17:59:33.155]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.155]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.155]                         ...future.globals.maxSize)) {
[17:59:33.155]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.155]                         on.exit(options(oopts), add = TRUE)
[17:59:33.155]                       }
[17:59:33.155]                       {
[17:59:33.155]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.155]                           FUN = function(jj) {
[17:59:33.155]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.155]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.155]                           })
[17:59:33.155]                       }
[17:59:33.155]                     }, args = future.call.arguments)
[17:59:33.155]                   }
[17:59:33.155]                 }, immediateCondition = function(cond) {
[17:59:33.155]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.155]                   sendCondition(cond)
[17:59:33.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.155]                   {
[17:59:33.155]                     inherits <- base::inherits
[17:59:33.155]                     invokeRestart <- base::invokeRestart
[17:59:33.155]                     is.null <- base::is.null
[17:59:33.155]                     muffled <- FALSE
[17:59:33.155]                     if (inherits(cond, "message")) {
[17:59:33.155]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.155]                       if (muffled) 
[17:59:33.155]                         invokeRestart("muffleMessage")
[17:59:33.155]                     }
[17:59:33.155]                     else if (inherits(cond, "warning")) {
[17:59:33.155]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.155]                       if (muffled) 
[17:59:33.155]                         invokeRestart("muffleWarning")
[17:59:33.155]                     }
[17:59:33.155]                     else if (inherits(cond, "condition")) {
[17:59:33.155]                       if (!is.null(pattern)) {
[17:59:33.155]                         computeRestarts <- base::computeRestarts
[17:59:33.155]                         grepl <- base::grepl
[17:59:33.155]                         restarts <- computeRestarts(cond)
[17:59:33.155]                         for (restart in restarts) {
[17:59:33.155]                           name <- restart$name
[17:59:33.155]                           if (is.null(name)) 
[17:59:33.155]                             next
[17:59:33.155]                           if (!grepl(pattern, name)) 
[17:59:33.155]                             next
[17:59:33.155]                           invokeRestart(restart)
[17:59:33.155]                           muffled <- TRUE
[17:59:33.155]                           break
[17:59:33.155]                         }
[17:59:33.155]                       }
[17:59:33.155]                     }
[17:59:33.155]                     invisible(muffled)
[17:59:33.155]                   }
[17:59:33.155]                   muffleCondition(cond)
[17:59:33.155]                 })
[17:59:33.155]             }))
[17:59:33.155]             future::FutureResult(value = ...future.value$value, 
[17:59:33.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.155]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.155]                     ...future.globalenv.names))
[17:59:33.155]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.155]         }, condition = base::local({
[17:59:33.155]             c <- base::c
[17:59:33.155]             inherits <- base::inherits
[17:59:33.155]             invokeRestart <- base::invokeRestart
[17:59:33.155]             length <- base::length
[17:59:33.155]             list <- base::list
[17:59:33.155]             seq.int <- base::seq.int
[17:59:33.155]             signalCondition <- base::signalCondition
[17:59:33.155]             sys.calls <- base::sys.calls
[17:59:33.155]             `[[` <- base::`[[`
[17:59:33.155]             `+` <- base::`+`
[17:59:33.155]             `<<-` <- base::`<<-`
[17:59:33.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.155]                   3L)]
[17:59:33.155]             }
[17:59:33.155]             function(cond) {
[17:59:33.155]                 is_error <- inherits(cond, "error")
[17:59:33.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.155]                   NULL)
[17:59:33.155]                 if (is_error) {
[17:59:33.155]                   sessionInformation <- function() {
[17:59:33.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.155]                       search = base::search(), system = base::Sys.info())
[17:59:33.155]                   }
[17:59:33.155]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.155]                     cond$call), session = sessionInformation(), 
[17:59:33.155]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.155]                   signalCondition(cond)
[17:59:33.155]                 }
[17:59:33.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.155]                 "immediateCondition"))) {
[17:59:33.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.155]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.155]                   if (TRUE && !signal) {
[17:59:33.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.155]                     {
[17:59:33.155]                       inherits <- base::inherits
[17:59:33.155]                       invokeRestart <- base::invokeRestart
[17:59:33.155]                       is.null <- base::is.null
[17:59:33.155]                       muffled <- FALSE
[17:59:33.155]                       if (inherits(cond, "message")) {
[17:59:33.155]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.155]                         if (muffled) 
[17:59:33.155]                           invokeRestart("muffleMessage")
[17:59:33.155]                       }
[17:59:33.155]                       else if (inherits(cond, "warning")) {
[17:59:33.155]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.155]                         if (muffled) 
[17:59:33.155]                           invokeRestart("muffleWarning")
[17:59:33.155]                       }
[17:59:33.155]                       else if (inherits(cond, "condition")) {
[17:59:33.155]                         if (!is.null(pattern)) {
[17:59:33.155]                           computeRestarts <- base::computeRestarts
[17:59:33.155]                           grepl <- base::grepl
[17:59:33.155]                           restarts <- computeRestarts(cond)
[17:59:33.155]                           for (restart in restarts) {
[17:59:33.155]                             name <- restart$name
[17:59:33.155]                             if (is.null(name)) 
[17:59:33.155]                               next
[17:59:33.155]                             if (!grepl(pattern, name)) 
[17:59:33.155]                               next
[17:59:33.155]                             invokeRestart(restart)
[17:59:33.155]                             muffled <- TRUE
[17:59:33.155]                             break
[17:59:33.155]                           }
[17:59:33.155]                         }
[17:59:33.155]                       }
[17:59:33.155]                       invisible(muffled)
[17:59:33.155]                     }
[17:59:33.155]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.155]                   }
[17:59:33.155]                 }
[17:59:33.155]                 else {
[17:59:33.155]                   if (TRUE) {
[17:59:33.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.155]                     {
[17:59:33.155]                       inherits <- base::inherits
[17:59:33.155]                       invokeRestart <- base::invokeRestart
[17:59:33.155]                       is.null <- base::is.null
[17:59:33.155]                       muffled <- FALSE
[17:59:33.155]                       if (inherits(cond, "message")) {
[17:59:33.155]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.155]                         if (muffled) 
[17:59:33.155]                           invokeRestart("muffleMessage")
[17:59:33.155]                       }
[17:59:33.155]                       else if (inherits(cond, "warning")) {
[17:59:33.155]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.155]                         if (muffled) 
[17:59:33.155]                           invokeRestart("muffleWarning")
[17:59:33.155]                       }
[17:59:33.155]                       else if (inherits(cond, "condition")) {
[17:59:33.155]                         if (!is.null(pattern)) {
[17:59:33.155]                           computeRestarts <- base::computeRestarts
[17:59:33.155]                           grepl <- base::grepl
[17:59:33.155]                           restarts <- computeRestarts(cond)
[17:59:33.155]                           for (restart in restarts) {
[17:59:33.155]                             name <- restart$name
[17:59:33.155]                             if (is.null(name)) 
[17:59:33.155]                               next
[17:59:33.155]                             if (!grepl(pattern, name)) 
[17:59:33.155]                               next
[17:59:33.155]                             invokeRestart(restart)
[17:59:33.155]                             muffled <- TRUE
[17:59:33.155]                             break
[17:59:33.155]                           }
[17:59:33.155]                         }
[17:59:33.155]                       }
[17:59:33.155]                       invisible(muffled)
[17:59:33.155]                     }
[17:59:33.155]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.155]                   }
[17:59:33.155]                 }
[17:59:33.155]             }
[17:59:33.155]         }))
[17:59:33.155]     }, error = function(ex) {
[17:59:33.155]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.155]                 ...future.rng), started = ...future.startTime, 
[17:59:33.155]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.155]             version = "1.8"), class = "FutureResult")
[17:59:33.155]     }, finally = {
[17:59:33.155]         if (!identical(...future.workdir, getwd())) 
[17:59:33.155]             setwd(...future.workdir)
[17:59:33.155]         {
[17:59:33.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.155]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.155]             }
[17:59:33.155]             base::options(...future.oldOptions)
[17:59:33.155]             if (.Platform$OS.type == "windows") {
[17:59:33.155]                 old_names <- names(...future.oldEnvVars)
[17:59:33.155]                 envs <- base::Sys.getenv()
[17:59:33.155]                 names <- names(envs)
[17:59:33.155]                 common <- intersect(names, old_names)
[17:59:33.155]                 added <- setdiff(names, old_names)
[17:59:33.155]                 removed <- setdiff(old_names, names)
[17:59:33.155]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.155]                   envs[common]]
[17:59:33.155]                 NAMES <- toupper(changed)
[17:59:33.155]                 args <- list()
[17:59:33.155]                 for (kk in seq_along(NAMES)) {
[17:59:33.155]                   name <- changed[[kk]]
[17:59:33.155]                   NAME <- NAMES[[kk]]
[17:59:33.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.155]                     next
[17:59:33.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.155]                 }
[17:59:33.155]                 NAMES <- toupper(added)
[17:59:33.155]                 for (kk in seq_along(NAMES)) {
[17:59:33.155]                   name <- added[[kk]]
[17:59:33.155]                   NAME <- NAMES[[kk]]
[17:59:33.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.155]                     next
[17:59:33.155]                   args[[name]] <- ""
[17:59:33.155]                 }
[17:59:33.155]                 NAMES <- toupper(removed)
[17:59:33.155]                 for (kk in seq_along(NAMES)) {
[17:59:33.155]                   name <- removed[[kk]]
[17:59:33.155]                   NAME <- NAMES[[kk]]
[17:59:33.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.155]                     next
[17:59:33.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.155]                 }
[17:59:33.155]                 if (length(args) > 0) 
[17:59:33.155]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.155]             }
[17:59:33.155]             else {
[17:59:33.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.155]             }
[17:59:33.155]             {
[17:59:33.155]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.155]                   0L) {
[17:59:33.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.155]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.155]                   base::options(opts)
[17:59:33.155]                 }
[17:59:33.155]                 {
[17:59:33.155]                   {
[17:59:33.155]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.155]                     NULL
[17:59:33.155]                   }
[17:59:33.155]                   options(future.plan = NULL)
[17:59:33.155]                   if (is.na(NA_character_)) 
[17:59:33.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.155]                     .init = FALSE)
[17:59:33.155]                 }
[17:59:33.155]             }
[17:59:33.155]         }
[17:59:33.155]     })
[17:59:33.155]     if (TRUE) {
[17:59:33.155]         base::sink(type = "output", split = FALSE)
[17:59:33.155]         if (TRUE) {
[17:59:33.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.155]         }
[17:59:33.155]         else {
[17:59:33.155]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.155]         }
[17:59:33.155]         base::close(...future.stdout)
[17:59:33.155]         ...future.stdout <- NULL
[17:59:33.155]     }
[17:59:33.155]     ...future.result$conditions <- ...future.conditions
[17:59:33.155]     ...future.result$finished <- base::Sys.time()
[17:59:33.155]     ...future.result
[17:59:33.155] }
[17:59:33.252] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:59:33.253] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:59:33.254] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:59:33.254] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:33.255] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.255] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:59:33.256] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:59:33.257] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:33.258] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.258] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:33.259] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.260] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:59:33.262] MultisessionFuture started
[17:59:33.262] - Launch lazy future ... done
[17:59:33.262] run() for ‘MultisessionFuture’ ... done
[17:59:33.263] Created future:
[17:59:33.263] MultisessionFuture:
[17:59:33.263] Label: ‘future_eapply-2’
[17:59:33.263] Expression:
[17:59:33.263] {
[17:59:33.263]     do.call(function(...) {
[17:59:33.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.263]             on.exit(options(oopts), add = TRUE)
[17:59:33.263]         }
[17:59:33.263]         {
[17:59:33.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.263]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.263]             })
[17:59:33.263]         }
[17:59:33.263]     }, args = future.call.arguments)
[17:59:33.263] }
[17:59:33.263] Lazy evaluation: FALSE
[17:59:33.263] Asynchronous evaluation: TRUE
[17:59:33.263] Local evaluation: TRUE
[17:59:33.263] Environment: R_GlobalEnv
[17:59:33.263] Capture standard output: TRUE
[17:59:33.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.263] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.263] Packages: <none>
[17:59:33.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.263] Resolved: FALSE
[17:59:33.263] Value: <not collected>
[17:59:33.263] Conditions captured: <none>
[17:59:33.263] Early signaling: FALSE
[17:59:33.263] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.263] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.278] Chunk #2 of 2 ... DONE
[17:59:33.279] Launching 2 futures (chunks) ... DONE
[17:59:33.279] Resolving 2 futures (chunks) ...
[17:59:33.280] resolve() on list ...
[17:59:33.280]  recursive: 0
[17:59:33.280]  length: 2
[17:59:33.281] 
[17:59:33.282] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.283] - Validating connection of MultisessionFuture
[17:59:33.284] - received message: FutureResult
[17:59:33.284] - Received FutureResult
[17:59:33.284] - Erased future from FutureRegistry
[17:59:33.285] result() for ClusterFuture ...
[17:59:33.285] - result already collected: FutureResult
[17:59:33.286] result() for ClusterFuture ... done
[17:59:33.286] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.286] Future #1
[17:59:33.287] result() for ClusterFuture ...
[17:59:33.287] - result already collected: FutureResult
[17:59:33.287] result() for ClusterFuture ... done
[17:59:33.288] result() for ClusterFuture ...
[17:59:33.288] - result already collected: FutureResult
[17:59:33.289] result() for ClusterFuture ... done
[17:59:33.289] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:33.290] - nx: 2
[17:59:33.290] - relay: TRUE
[17:59:33.290] - stdout: TRUE
[17:59:33.295] - signal: TRUE
[17:59:33.295] - resignal: FALSE
[17:59:33.295] - force: TRUE
[17:59:33.296] - relayed: [n=2] FALSE, FALSE
[17:59:33.296] - queued futures: [n=2] FALSE, FALSE
[17:59:33.296]  - until=1
[17:59:33.297]  - relaying element #1
[17:59:33.297] result() for ClusterFuture ...
[17:59:33.297] - result already collected: FutureResult
[17:59:33.297] result() for ClusterFuture ... done
[17:59:33.298] result() for ClusterFuture ...
[17:59:33.298] - result already collected: FutureResult
[17:59:33.298] result() for ClusterFuture ... done
[17:59:33.299] result() for ClusterFuture ...
[17:59:33.299] - result already collected: FutureResult
[17:59:33.299] result() for ClusterFuture ... done
[17:59:33.300] result() for ClusterFuture ...
[17:59:33.300] - result already collected: FutureResult
[17:59:33.300] result() for ClusterFuture ... done
[17:59:33.301] - relayed: [n=2] TRUE, FALSE
[17:59:33.301] - queued futures: [n=2] TRUE, FALSE
[17:59:33.301] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:33.302]  length: 1 (resolved future 1)
[17:59:33.389] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.390] - Validating connection of MultisessionFuture
[17:59:33.390] - received message: FutureResult
[17:59:33.390] - Received FutureResult
[17:59:33.390] - Erased future from FutureRegistry
[17:59:33.391] result() for ClusterFuture ...
[17:59:33.391] - result already collected: FutureResult
[17:59:33.391] result() for ClusterFuture ... done
[17:59:33.391] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.391] Future #2
[17:59:33.391] result() for ClusterFuture ...
[17:59:33.392] - result already collected: FutureResult
[17:59:33.392] result() for ClusterFuture ... done
[17:59:33.392] result() for ClusterFuture ...
[17:59:33.392] - result already collected: FutureResult
[17:59:33.392] result() for ClusterFuture ... done
[17:59:33.393] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:33.393] - nx: 2
[17:59:33.393] - relay: TRUE
[17:59:33.393] - stdout: TRUE
[17:59:33.393] - signal: TRUE
[17:59:33.393] - resignal: FALSE
[17:59:33.394] - force: TRUE
[17:59:33.394] - relayed: [n=2] TRUE, FALSE
[17:59:33.394] - queued futures: [n=2] TRUE, FALSE
[17:59:33.394]  - until=2
[17:59:33.394]  - relaying element #2
[17:59:33.395] result() for ClusterFuture ...
[17:59:33.395] - result already collected: FutureResult
[17:59:33.395] result() for ClusterFuture ... done
[17:59:33.395] result() for ClusterFuture ...
[17:59:33.395] - result already collected: FutureResult
[17:59:33.395] result() for ClusterFuture ... done
[17:59:33.396] result() for ClusterFuture ...
[17:59:33.396] - result already collected: FutureResult
[17:59:33.396] result() for ClusterFuture ... done
[17:59:33.396] result() for ClusterFuture ...
[17:59:33.396] - result already collected: FutureResult
[17:59:33.397] result() for ClusterFuture ... done
[17:59:33.397] - relayed: [n=2] TRUE, TRUE
[17:59:33.397] - queued futures: [n=2] TRUE, TRUE
[17:59:33.397] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:33.397]  length: 0 (resolved future 2)
[17:59:33.398] Relaying remaining futures
[17:59:33.398] signalConditionsASAP(NULL, pos=0) ...
[17:59:33.398] - nx: 2
[17:59:33.398] - relay: TRUE
[17:59:33.398] - stdout: TRUE
[17:59:33.398] - signal: TRUE
[17:59:33.399] - resignal: FALSE
[17:59:33.399] - force: TRUE
[17:59:33.399] - relayed: [n=2] TRUE, TRUE
[17:59:33.399] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:33.399] - relayed: [n=2] TRUE, TRUE
[17:59:33.400] - queued futures: [n=2] TRUE, TRUE
[17:59:33.400] signalConditionsASAP(NULL, pos=0) ... done
[17:59:33.400] resolve() on list ... DONE
[17:59:33.400] result() for ClusterFuture ...
[17:59:33.400] - result already collected: FutureResult
[17:59:33.400] result() for ClusterFuture ... done
[17:59:33.401] result() for ClusterFuture ...
[17:59:33.401] - result already collected: FutureResult
[17:59:33.401] result() for ClusterFuture ... done
[17:59:33.401] result() for ClusterFuture ...
[17:59:33.401] - result already collected: FutureResult
[17:59:33.402] result() for ClusterFuture ... done
[17:59:33.402] result() for ClusterFuture ...
[17:59:33.402] - result already collected: FutureResult
[17:59:33.402] result() for ClusterFuture ... done
[17:59:33.402]  - Number of value chunks collected: 2
[17:59:33.403] Resolving 2 futures (chunks) ... DONE
[17:59:33.403] Reducing values from 2 chunks ...
[17:59:33.403]  - Number of values collected after concatenation: 3
[17:59:33.403]  - Number of values expected: 3
[17:59:33.403] Reducing values from 2 chunks ... DONE
[17:59:33.403] future_lapply() ... DONE
[17:59:33.404] future_lapply() ...
[17:59:33.411] Number of chunks: 2
[17:59:33.411] getGlobalsAndPackagesXApply() ...
[17:59:33.411]  - future.globals: TRUE
[17:59:33.412] getGlobalsAndPackages() ...
[17:59:33.412] Searching for globals...
[17:59:33.414] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:33.414] Searching for globals ... DONE
[17:59:33.414] Resolving globals: FALSE
[17:59:33.415] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:33.416] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:33.416] - globals: [1] ‘FUN’
[17:59:33.416] - packages: [1] ‘stats’
[17:59:33.416] getGlobalsAndPackages() ... DONE
[17:59:33.417]  - globals found/used: [n=1] ‘FUN’
[17:59:33.417]  - needed namespaces: [n=1] ‘stats’
[17:59:33.417] Finding globals ... DONE
[17:59:33.417]  - use_args: TRUE
[17:59:33.417]  - Getting '...' globals ...
[17:59:33.418] resolve() on list ...
[17:59:33.418]  recursive: 0
[17:59:33.418]  length: 1
[17:59:33.418]  elements: ‘...’
[17:59:33.419]  length: 0 (resolved future 1)
[17:59:33.419] resolve() on list ... DONE
[17:59:33.419]    - '...' content: [n=1] ‘probs’
[17:59:33.419] List of 1
[17:59:33.419]  $ ...:List of 1
[17:59:33.419]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:33.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.419]  - attr(*, "where")=List of 1
[17:59:33.419]   ..$ ...:<environment: 0x58d4c4a1d208> 
[17:59:33.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.419]  - attr(*, "resolved")= logi TRUE
[17:59:33.419]  - attr(*, "total_size")= num NA
[17:59:33.425]  - Getting '...' globals ... DONE
[17:59:33.425] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:33.426] List of 2
[17:59:33.426]  $ ...future.FUN:function (x, ...)  
[17:59:33.426]  $ ...          :List of 1
[17:59:33.426]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:59:33.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.426]  - attr(*, "where")=List of 2
[17:59:33.426]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:33.426]   ..$ ...          :<environment: 0x58d4c4a1d208> 
[17:59:33.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.426]  - attr(*, "resolved")= logi FALSE
[17:59:33.426]  - attr(*, "total_size")= num 1328
[17:59:33.432] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:33.433] getGlobalsAndPackagesXApply() ... DONE
[17:59:33.433] Number of futures (= number of chunks): 2
[17:59:33.433] Launching 2 futures (chunks) ...
[17:59:33.433] Chunk #1 of 2 ...
[17:59:33.434]  - Finding globals in 'X' for chunk #1 ...
[17:59:33.434] getGlobalsAndPackages() ...
[17:59:33.434] Searching for globals...
[17:59:33.434] 
[17:59:33.435] Searching for globals ... DONE
[17:59:33.435] - globals: [0] <none>
[17:59:33.435] getGlobalsAndPackages() ... DONE
[17:59:33.435]    + additional globals found: [n=0] 
[17:59:33.435]    + additional namespaces needed: [n=0] 
[17:59:33.436]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:33.436]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.436]  - seeds: <none>
[17:59:33.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.436] getGlobalsAndPackages() ...
[17:59:33.437] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.437] Resolving globals: FALSE
[17:59:33.437] Tweak future expression to call with '...' arguments ...
[17:59:33.437] {
[17:59:33.437]     do.call(function(...) {
[17:59:33.437]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.437]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.437]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.437]             on.exit(options(oopts), add = TRUE)
[17:59:33.437]         }
[17:59:33.437]         {
[17:59:33.437]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.437]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.437]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.437]             })
[17:59:33.437]         }
[17:59:33.437]     }, args = future.call.arguments)
[17:59:33.437] }
[17:59:33.438] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.439] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.439] - packages: [1] ‘stats’
[17:59:33.439] getGlobalsAndPackages() ... DONE
[17:59:33.439] run() for ‘Future’ ...
[17:59:33.440] - state: ‘created’
[17:59:33.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.464]   - Field: ‘node’
[17:59:33.465]   - Field: ‘label’
[17:59:33.465]   - Field: ‘local’
[17:59:33.465]   - Field: ‘owner’
[17:59:33.465]   - Field: ‘envir’
[17:59:33.465]   - Field: ‘workers’
[17:59:33.466]   - Field: ‘packages’
[17:59:33.466]   - Field: ‘gc’
[17:59:33.466]   - Field: ‘conditions’
[17:59:33.466]   - Field: ‘persistent’
[17:59:33.466]   - Field: ‘expr’
[17:59:33.467]   - Field: ‘uuid’
[17:59:33.467]   - Field: ‘seed’
[17:59:33.467]   - Field: ‘version’
[17:59:33.467]   - Field: ‘result’
[17:59:33.467]   - Field: ‘asynchronous’
[17:59:33.468]   - Field: ‘calls’
[17:59:33.468]   - Field: ‘globals’
[17:59:33.468]   - Field: ‘stdout’
[17:59:33.468]   - Field: ‘earlySignal’
[17:59:33.468]   - Field: ‘lazy’
[17:59:33.468]   - Field: ‘state’
[17:59:33.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.469] - Launch lazy future ...
[17:59:33.469] Packages needed by the future expression (n = 1): ‘stats’
[17:59:33.470] Packages needed by future strategies (n = 0): <none>
[17:59:33.471] {
[17:59:33.471]     {
[17:59:33.471]         {
[17:59:33.471]             ...future.startTime <- base::Sys.time()
[17:59:33.471]             {
[17:59:33.471]                 {
[17:59:33.471]                   {
[17:59:33.471]                     {
[17:59:33.471]                       {
[17:59:33.471]                         base::local({
[17:59:33.471]                           has_future <- base::requireNamespace("future", 
[17:59:33.471]                             quietly = TRUE)
[17:59:33.471]                           if (has_future) {
[17:59:33.471]                             ns <- base::getNamespace("future")
[17:59:33.471]                             version <- ns[[".package"]][["version"]]
[17:59:33.471]                             if (is.null(version)) 
[17:59:33.471]                               version <- utils::packageVersion("future")
[17:59:33.471]                           }
[17:59:33.471]                           else {
[17:59:33.471]                             version <- NULL
[17:59:33.471]                           }
[17:59:33.471]                           if (!has_future || version < "1.8.0") {
[17:59:33.471]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.471]                               "", base::R.version$version.string), 
[17:59:33.471]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:33.471]                                 base::R.version$platform, 8 * 
[17:59:33.471]                                   base::.Machine$sizeof.pointer), 
[17:59:33.471]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.471]                                 "release", "version")], collapse = " "), 
[17:59:33.471]                               hostname = base::Sys.info()[["nodename"]])
[17:59:33.471]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.471]                               info)
[17:59:33.471]                             info <- base::paste(info, collapse = "; ")
[17:59:33.471]                             if (!has_future) {
[17:59:33.471]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.471]                                 info)
[17:59:33.471]                             }
[17:59:33.471]                             else {
[17:59:33.471]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.471]                                 info, version)
[17:59:33.471]                             }
[17:59:33.471]                             base::stop(msg)
[17:59:33.471]                           }
[17:59:33.471]                         })
[17:59:33.471]                       }
[17:59:33.471]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.471]                       base::options(mc.cores = 1L)
[17:59:33.471]                     }
[17:59:33.471]                     base::local({
[17:59:33.471]                       for (pkg in "stats") {
[17:59:33.471]                         base::loadNamespace(pkg)
[17:59:33.471]                         base::library(pkg, character.only = TRUE)
[17:59:33.471]                       }
[17:59:33.471]                     })
[17:59:33.471]                   }
[17:59:33.471]                   ...future.strategy.old <- future::plan("list")
[17:59:33.471]                   options(future.plan = NULL)
[17:59:33.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.471]                 }
[17:59:33.471]                 ...future.workdir <- getwd()
[17:59:33.471]             }
[17:59:33.471]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.471]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.471]         }
[17:59:33.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.471]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.471]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.471]             base::names(...future.oldOptions))
[17:59:33.471]     }
[17:59:33.471]     if (FALSE) {
[17:59:33.471]     }
[17:59:33.471]     else {
[17:59:33.471]         if (TRUE) {
[17:59:33.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.471]                 open = "w")
[17:59:33.471]         }
[17:59:33.471]         else {
[17:59:33.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.471]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.471]         }
[17:59:33.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.471]             base::sink(type = "output", split = FALSE)
[17:59:33.471]             base::close(...future.stdout)
[17:59:33.471]         }, add = TRUE)
[17:59:33.471]     }
[17:59:33.471]     ...future.frame <- base::sys.nframe()
[17:59:33.471]     ...future.conditions <- base::list()
[17:59:33.471]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.471]     if (FALSE) {
[17:59:33.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.471]     }
[17:59:33.471]     ...future.result <- base::tryCatch({
[17:59:33.471]         base::withCallingHandlers({
[17:59:33.471]             ...future.value <- base::withVisible(base::local({
[17:59:33.471]                 ...future.makeSendCondition <- base::local({
[17:59:33.471]                   sendCondition <- NULL
[17:59:33.471]                   function(frame = 1L) {
[17:59:33.471]                     if (is.function(sendCondition)) 
[17:59:33.471]                       return(sendCondition)
[17:59:33.471]                     ns <- getNamespace("parallel")
[17:59:33.471]                     if (exists("sendData", mode = "function", 
[17:59:33.471]                       envir = ns)) {
[17:59:33.471]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.471]                         envir = ns)
[17:59:33.471]                       envir <- sys.frame(frame)
[17:59:33.471]                       master <- NULL
[17:59:33.471]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.471]                         !identical(envir, emptyenv())) {
[17:59:33.471]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.471]                           inherits = FALSE)) {
[17:59:33.471]                           master <- get("master", mode = "list", 
[17:59:33.471]                             envir = envir, inherits = FALSE)
[17:59:33.471]                           if (inherits(master, c("SOCKnode", 
[17:59:33.471]                             "SOCK0node"))) {
[17:59:33.471]                             sendCondition <<- function(cond) {
[17:59:33.471]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.471]                                 success = TRUE)
[17:59:33.471]                               parallel_sendData(master, data)
[17:59:33.471]                             }
[17:59:33.471]                             return(sendCondition)
[17:59:33.471]                           }
[17:59:33.471]                         }
[17:59:33.471]                         frame <- frame + 1L
[17:59:33.471]                         envir <- sys.frame(frame)
[17:59:33.471]                       }
[17:59:33.471]                     }
[17:59:33.471]                     sendCondition <<- function(cond) NULL
[17:59:33.471]                   }
[17:59:33.471]                 })
[17:59:33.471]                 withCallingHandlers({
[17:59:33.471]                   {
[17:59:33.471]                     do.call(function(...) {
[17:59:33.471]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.471]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.471]                         ...future.globals.maxSize)) {
[17:59:33.471]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.471]                         on.exit(options(oopts), add = TRUE)
[17:59:33.471]                       }
[17:59:33.471]                       {
[17:59:33.471]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.471]                           FUN = function(jj) {
[17:59:33.471]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.471]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.471]                           })
[17:59:33.471]                       }
[17:59:33.471]                     }, args = future.call.arguments)
[17:59:33.471]                   }
[17:59:33.471]                 }, immediateCondition = function(cond) {
[17:59:33.471]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.471]                   sendCondition(cond)
[17:59:33.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.471]                   {
[17:59:33.471]                     inherits <- base::inherits
[17:59:33.471]                     invokeRestart <- base::invokeRestart
[17:59:33.471]                     is.null <- base::is.null
[17:59:33.471]                     muffled <- FALSE
[17:59:33.471]                     if (inherits(cond, "message")) {
[17:59:33.471]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.471]                       if (muffled) 
[17:59:33.471]                         invokeRestart("muffleMessage")
[17:59:33.471]                     }
[17:59:33.471]                     else if (inherits(cond, "warning")) {
[17:59:33.471]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.471]                       if (muffled) 
[17:59:33.471]                         invokeRestart("muffleWarning")
[17:59:33.471]                     }
[17:59:33.471]                     else if (inherits(cond, "condition")) {
[17:59:33.471]                       if (!is.null(pattern)) {
[17:59:33.471]                         computeRestarts <- base::computeRestarts
[17:59:33.471]                         grepl <- base::grepl
[17:59:33.471]                         restarts <- computeRestarts(cond)
[17:59:33.471]                         for (restart in restarts) {
[17:59:33.471]                           name <- restart$name
[17:59:33.471]                           if (is.null(name)) 
[17:59:33.471]                             next
[17:59:33.471]                           if (!grepl(pattern, name)) 
[17:59:33.471]                             next
[17:59:33.471]                           invokeRestart(restart)
[17:59:33.471]                           muffled <- TRUE
[17:59:33.471]                           break
[17:59:33.471]                         }
[17:59:33.471]                       }
[17:59:33.471]                     }
[17:59:33.471]                     invisible(muffled)
[17:59:33.471]                   }
[17:59:33.471]                   muffleCondition(cond)
[17:59:33.471]                 })
[17:59:33.471]             }))
[17:59:33.471]             future::FutureResult(value = ...future.value$value, 
[17:59:33.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.471]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.471]                     ...future.globalenv.names))
[17:59:33.471]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.471]         }, condition = base::local({
[17:59:33.471]             c <- base::c
[17:59:33.471]             inherits <- base::inherits
[17:59:33.471]             invokeRestart <- base::invokeRestart
[17:59:33.471]             length <- base::length
[17:59:33.471]             list <- base::list
[17:59:33.471]             seq.int <- base::seq.int
[17:59:33.471]             signalCondition <- base::signalCondition
[17:59:33.471]             sys.calls <- base::sys.calls
[17:59:33.471]             `[[` <- base::`[[`
[17:59:33.471]             `+` <- base::`+`
[17:59:33.471]             `<<-` <- base::`<<-`
[17:59:33.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.471]                   3L)]
[17:59:33.471]             }
[17:59:33.471]             function(cond) {
[17:59:33.471]                 is_error <- inherits(cond, "error")
[17:59:33.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.471]                   NULL)
[17:59:33.471]                 if (is_error) {
[17:59:33.471]                   sessionInformation <- function() {
[17:59:33.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.471]                       search = base::search(), system = base::Sys.info())
[17:59:33.471]                   }
[17:59:33.471]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.471]                     cond$call), session = sessionInformation(), 
[17:59:33.471]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.471]                   signalCondition(cond)
[17:59:33.471]                 }
[17:59:33.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.471]                 "immediateCondition"))) {
[17:59:33.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.471]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.471]                   if (TRUE && !signal) {
[17:59:33.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.471]                     {
[17:59:33.471]                       inherits <- base::inherits
[17:59:33.471]                       invokeRestart <- base::invokeRestart
[17:59:33.471]                       is.null <- base::is.null
[17:59:33.471]                       muffled <- FALSE
[17:59:33.471]                       if (inherits(cond, "message")) {
[17:59:33.471]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.471]                         if (muffled) 
[17:59:33.471]                           invokeRestart("muffleMessage")
[17:59:33.471]                       }
[17:59:33.471]                       else if (inherits(cond, "warning")) {
[17:59:33.471]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.471]                         if (muffled) 
[17:59:33.471]                           invokeRestart("muffleWarning")
[17:59:33.471]                       }
[17:59:33.471]                       else if (inherits(cond, "condition")) {
[17:59:33.471]                         if (!is.null(pattern)) {
[17:59:33.471]                           computeRestarts <- base::computeRestarts
[17:59:33.471]                           grepl <- base::grepl
[17:59:33.471]                           restarts <- computeRestarts(cond)
[17:59:33.471]                           for (restart in restarts) {
[17:59:33.471]                             name <- restart$name
[17:59:33.471]                             if (is.null(name)) 
[17:59:33.471]                               next
[17:59:33.471]                             if (!grepl(pattern, name)) 
[17:59:33.471]                               next
[17:59:33.471]                             invokeRestart(restart)
[17:59:33.471]                             muffled <- TRUE
[17:59:33.471]                             break
[17:59:33.471]                           }
[17:59:33.471]                         }
[17:59:33.471]                       }
[17:59:33.471]                       invisible(muffled)
[17:59:33.471]                     }
[17:59:33.471]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.471]                   }
[17:59:33.471]                 }
[17:59:33.471]                 else {
[17:59:33.471]                   if (TRUE) {
[17:59:33.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.471]                     {
[17:59:33.471]                       inherits <- base::inherits
[17:59:33.471]                       invokeRestart <- base::invokeRestart
[17:59:33.471]                       is.null <- base::is.null
[17:59:33.471]                       muffled <- FALSE
[17:59:33.471]                       if (inherits(cond, "message")) {
[17:59:33.471]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.471]                         if (muffled) 
[17:59:33.471]                           invokeRestart("muffleMessage")
[17:59:33.471]                       }
[17:59:33.471]                       else if (inherits(cond, "warning")) {
[17:59:33.471]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.471]                         if (muffled) 
[17:59:33.471]                           invokeRestart("muffleWarning")
[17:59:33.471]                       }
[17:59:33.471]                       else if (inherits(cond, "condition")) {
[17:59:33.471]                         if (!is.null(pattern)) {
[17:59:33.471]                           computeRestarts <- base::computeRestarts
[17:59:33.471]                           grepl <- base::grepl
[17:59:33.471]                           restarts <- computeRestarts(cond)
[17:59:33.471]                           for (restart in restarts) {
[17:59:33.471]                             name <- restart$name
[17:59:33.471]                             if (is.null(name)) 
[17:59:33.471]                               next
[17:59:33.471]                             if (!grepl(pattern, name)) 
[17:59:33.471]                               next
[17:59:33.471]                             invokeRestart(restart)
[17:59:33.471]                             muffled <- TRUE
[17:59:33.471]                             break
[17:59:33.471]                           }
[17:59:33.471]                         }
[17:59:33.471]                       }
[17:59:33.471]                       invisible(muffled)
[17:59:33.471]                     }
[17:59:33.471]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.471]                   }
[17:59:33.471]                 }
[17:59:33.471]             }
[17:59:33.471]         }))
[17:59:33.471]     }, error = function(ex) {
[17:59:33.471]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.471]                 ...future.rng), started = ...future.startTime, 
[17:59:33.471]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.471]             version = "1.8"), class = "FutureResult")
[17:59:33.471]     }, finally = {
[17:59:33.471]         if (!identical(...future.workdir, getwd())) 
[17:59:33.471]             setwd(...future.workdir)
[17:59:33.471]         {
[17:59:33.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.471]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.471]             }
[17:59:33.471]             base::options(...future.oldOptions)
[17:59:33.471]             if (.Platform$OS.type == "windows") {
[17:59:33.471]                 old_names <- names(...future.oldEnvVars)
[17:59:33.471]                 envs <- base::Sys.getenv()
[17:59:33.471]                 names <- names(envs)
[17:59:33.471]                 common <- intersect(names, old_names)
[17:59:33.471]                 added <- setdiff(names, old_names)
[17:59:33.471]                 removed <- setdiff(old_names, names)
[17:59:33.471]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.471]                   envs[common]]
[17:59:33.471]                 NAMES <- toupper(changed)
[17:59:33.471]                 args <- list()
[17:59:33.471]                 for (kk in seq_along(NAMES)) {
[17:59:33.471]                   name <- changed[[kk]]
[17:59:33.471]                   NAME <- NAMES[[kk]]
[17:59:33.471]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.471]                     next
[17:59:33.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.471]                 }
[17:59:33.471]                 NAMES <- toupper(added)
[17:59:33.471]                 for (kk in seq_along(NAMES)) {
[17:59:33.471]                   name <- added[[kk]]
[17:59:33.471]                   NAME <- NAMES[[kk]]
[17:59:33.471]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.471]                     next
[17:59:33.471]                   args[[name]] <- ""
[17:59:33.471]                 }
[17:59:33.471]                 NAMES <- toupper(removed)
[17:59:33.471]                 for (kk in seq_along(NAMES)) {
[17:59:33.471]                   name <- removed[[kk]]
[17:59:33.471]                   NAME <- NAMES[[kk]]
[17:59:33.471]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.471]                     next
[17:59:33.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.471]                 }
[17:59:33.471]                 if (length(args) > 0) 
[17:59:33.471]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.471]             }
[17:59:33.471]             else {
[17:59:33.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.471]             }
[17:59:33.471]             {
[17:59:33.471]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.471]                   0L) {
[17:59:33.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.471]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.471]                   base::options(opts)
[17:59:33.471]                 }
[17:59:33.471]                 {
[17:59:33.471]                   {
[17:59:33.471]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.471]                     NULL
[17:59:33.471]                   }
[17:59:33.471]                   options(future.plan = NULL)
[17:59:33.471]                   if (is.na(NA_character_)) 
[17:59:33.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.471]                     .init = FALSE)
[17:59:33.471]                 }
[17:59:33.471]             }
[17:59:33.471]         }
[17:59:33.471]     })
[17:59:33.471]     if (TRUE) {
[17:59:33.471]         base::sink(type = "output", split = FALSE)
[17:59:33.471]         if (TRUE) {
[17:59:33.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.471]         }
[17:59:33.471]         else {
[17:59:33.471]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.471]         }
[17:59:33.471]         base::close(...future.stdout)
[17:59:33.471]         ...future.stdout <- NULL
[17:59:33.471]     }
[17:59:33.471]     ...future.result$conditions <- ...future.conditions
[17:59:33.471]     ...future.result$finished <- base::Sys.time()
[17:59:33.471]     ...future.result
[17:59:33.471] }
[17:59:33.476] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[17:59:33.476] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:59:33.477] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:59:33.478] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[17:59:33.478] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[17:59:33.479] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:59:33.480] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:59:33.480] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:33.481] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.481] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:33.482] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.482] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[17:59:33.483] MultisessionFuture started
[17:59:33.483] - Launch lazy future ... done
[17:59:33.484] run() for ‘MultisessionFuture’ ... done
[17:59:33.484] Created future:
[17:59:33.484] MultisessionFuture:
[17:59:33.484] Label: ‘future_eapply-1’
[17:59:33.484] Expression:
[17:59:33.484] {
[17:59:33.484]     do.call(function(...) {
[17:59:33.484]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.484]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.484]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.484]             on.exit(options(oopts), add = TRUE)
[17:59:33.484]         }
[17:59:33.484]         {
[17:59:33.484]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.484]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.484]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.484]             })
[17:59:33.484]         }
[17:59:33.484]     }, args = future.call.arguments)
[17:59:33.484] }
[17:59:33.484] Lazy evaluation: FALSE
[17:59:33.484] Asynchronous evaluation: TRUE
[17:59:33.484] Local evaluation: TRUE
[17:59:33.484] Environment: R_GlobalEnv
[17:59:33.484] Capture standard output: TRUE
[17:59:33.484] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.484] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.484] Packages: 1 packages (‘stats’)
[17:59:33.484] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.484] Resolved: FALSE
[17:59:33.484] Value: <not collected>
[17:59:33.484] Conditions captured: <none>
[17:59:33.484] Early signaling: FALSE
[17:59:33.484] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.484] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.497] Chunk #1 of 2 ... DONE
[17:59:33.498] Chunk #2 of 2 ...
[17:59:33.498]  - Finding globals in 'X' for chunk #2 ...
[17:59:33.498] getGlobalsAndPackages() ...
[17:59:33.498] Searching for globals...
[17:59:33.499] 
[17:59:33.499] Searching for globals ... DONE
[17:59:33.499] - globals: [0] <none>
[17:59:33.499] getGlobalsAndPackages() ... DONE
[17:59:33.500]    + additional globals found: [n=0] 
[17:59:33.500]    + additional namespaces needed: [n=0] 
[17:59:33.500]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:33.500]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.500]  - seeds: <none>
[17:59:33.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.501] getGlobalsAndPackages() ...
[17:59:33.501] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.501] Resolving globals: FALSE
[17:59:33.502] Tweak future expression to call with '...' arguments ...
[17:59:33.502] {
[17:59:33.502]     do.call(function(...) {
[17:59:33.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.502]             on.exit(options(oopts), add = TRUE)
[17:59:33.502]         }
[17:59:33.502]         {
[17:59:33.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.502]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.502]             })
[17:59:33.502]         }
[17:59:33.502]     }, args = future.call.arguments)
[17:59:33.502] }
[17:59:33.502] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.503] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.503] - packages: [1] ‘stats’
[17:59:33.504] getGlobalsAndPackages() ... DONE
[17:59:33.504] run() for ‘Future’ ...
[17:59:33.504] - state: ‘created’
[17:59:33.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.529]   - Field: ‘node’
[17:59:33.529]   - Field: ‘label’
[17:59:33.529]   - Field: ‘local’
[17:59:33.530]   - Field: ‘owner’
[17:59:33.530]   - Field: ‘envir’
[17:59:33.530]   - Field: ‘workers’
[17:59:33.530]   - Field: ‘packages’
[17:59:33.530]   - Field: ‘gc’
[17:59:33.531]   - Field: ‘conditions’
[17:59:33.531]   - Field: ‘persistent’
[17:59:33.531]   - Field: ‘expr’
[17:59:33.531]   - Field: ‘uuid’
[17:59:33.531]   - Field: ‘seed’
[17:59:33.532]   - Field: ‘version’
[17:59:33.532]   - Field: ‘result’
[17:59:33.532]   - Field: ‘asynchronous’
[17:59:33.532]   - Field: ‘calls’
[17:59:33.532]   - Field: ‘globals’
[17:59:33.533]   - Field: ‘stdout’
[17:59:33.533]   - Field: ‘earlySignal’
[17:59:33.533]   - Field: ‘lazy’
[17:59:33.533]   - Field: ‘state’
[17:59:33.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.534] - Launch lazy future ...
[17:59:33.534] Packages needed by the future expression (n = 1): ‘stats’
[17:59:33.534] Packages needed by future strategies (n = 0): <none>
[17:59:33.535] {
[17:59:33.535]     {
[17:59:33.535]         {
[17:59:33.535]             ...future.startTime <- base::Sys.time()
[17:59:33.535]             {
[17:59:33.535]                 {
[17:59:33.535]                   {
[17:59:33.535]                     {
[17:59:33.535]                       {
[17:59:33.535]                         base::local({
[17:59:33.535]                           has_future <- base::requireNamespace("future", 
[17:59:33.535]                             quietly = TRUE)
[17:59:33.535]                           if (has_future) {
[17:59:33.535]                             ns <- base::getNamespace("future")
[17:59:33.535]                             version <- ns[[".package"]][["version"]]
[17:59:33.535]                             if (is.null(version)) 
[17:59:33.535]                               version <- utils::packageVersion("future")
[17:59:33.535]                           }
[17:59:33.535]                           else {
[17:59:33.535]                             version <- NULL
[17:59:33.535]                           }
[17:59:33.535]                           if (!has_future || version < "1.8.0") {
[17:59:33.535]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.535]                               "", base::R.version$version.string), 
[17:59:33.535]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:33.535]                                 base::R.version$platform, 8 * 
[17:59:33.535]                                   base::.Machine$sizeof.pointer), 
[17:59:33.535]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.535]                                 "release", "version")], collapse = " "), 
[17:59:33.535]                               hostname = base::Sys.info()[["nodename"]])
[17:59:33.535]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.535]                               info)
[17:59:33.535]                             info <- base::paste(info, collapse = "; ")
[17:59:33.535]                             if (!has_future) {
[17:59:33.535]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.535]                                 info)
[17:59:33.535]                             }
[17:59:33.535]                             else {
[17:59:33.535]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.535]                                 info, version)
[17:59:33.535]                             }
[17:59:33.535]                             base::stop(msg)
[17:59:33.535]                           }
[17:59:33.535]                         })
[17:59:33.535]                       }
[17:59:33.535]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.535]                       base::options(mc.cores = 1L)
[17:59:33.535]                     }
[17:59:33.535]                     base::local({
[17:59:33.535]                       for (pkg in "stats") {
[17:59:33.535]                         base::loadNamespace(pkg)
[17:59:33.535]                         base::library(pkg, character.only = TRUE)
[17:59:33.535]                       }
[17:59:33.535]                     })
[17:59:33.535]                   }
[17:59:33.535]                   ...future.strategy.old <- future::plan("list")
[17:59:33.535]                   options(future.plan = NULL)
[17:59:33.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.535]                 }
[17:59:33.535]                 ...future.workdir <- getwd()
[17:59:33.535]             }
[17:59:33.535]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.535]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.535]         }
[17:59:33.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.535]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.535]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.535]             base::names(...future.oldOptions))
[17:59:33.535]     }
[17:59:33.535]     if (FALSE) {
[17:59:33.535]     }
[17:59:33.535]     else {
[17:59:33.535]         if (TRUE) {
[17:59:33.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.535]                 open = "w")
[17:59:33.535]         }
[17:59:33.535]         else {
[17:59:33.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.535]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.535]         }
[17:59:33.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.535]             base::sink(type = "output", split = FALSE)
[17:59:33.535]             base::close(...future.stdout)
[17:59:33.535]         }, add = TRUE)
[17:59:33.535]     }
[17:59:33.535]     ...future.frame <- base::sys.nframe()
[17:59:33.535]     ...future.conditions <- base::list()
[17:59:33.535]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.535]     if (FALSE) {
[17:59:33.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.535]     }
[17:59:33.535]     ...future.result <- base::tryCatch({
[17:59:33.535]         base::withCallingHandlers({
[17:59:33.535]             ...future.value <- base::withVisible(base::local({
[17:59:33.535]                 ...future.makeSendCondition <- base::local({
[17:59:33.535]                   sendCondition <- NULL
[17:59:33.535]                   function(frame = 1L) {
[17:59:33.535]                     if (is.function(sendCondition)) 
[17:59:33.535]                       return(sendCondition)
[17:59:33.535]                     ns <- getNamespace("parallel")
[17:59:33.535]                     if (exists("sendData", mode = "function", 
[17:59:33.535]                       envir = ns)) {
[17:59:33.535]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.535]                         envir = ns)
[17:59:33.535]                       envir <- sys.frame(frame)
[17:59:33.535]                       master <- NULL
[17:59:33.535]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.535]                         !identical(envir, emptyenv())) {
[17:59:33.535]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.535]                           inherits = FALSE)) {
[17:59:33.535]                           master <- get("master", mode = "list", 
[17:59:33.535]                             envir = envir, inherits = FALSE)
[17:59:33.535]                           if (inherits(master, c("SOCKnode", 
[17:59:33.535]                             "SOCK0node"))) {
[17:59:33.535]                             sendCondition <<- function(cond) {
[17:59:33.535]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.535]                                 success = TRUE)
[17:59:33.535]                               parallel_sendData(master, data)
[17:59:33.535]                             }
[17:59:33.535]                             return(sendCondition)
[17:59:33.535]                           }
[17:59:33.535]                         }
[17:59:33.535]                         frame <- frame + 1L
[17:59:33.535]                         envir <- sys.frame(frame)
[17:59:33.535]                       }
[17:59:33.535]                     }
[17:59:33.535]                     sendCondition <<- function(cond) NULL
[17:59:33.535]                   }
[17:59:33.535]                 })
[17:59:33.535]                 withCallingHandlers({
[17:59:33.535]                   {
[17:59:33.535]                     do.call(function(...) {
[17:59:33.535]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.535]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.535]                         ...future.globals.maxSize)) {
[17:59:33.535]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.535]                         on.exit(options(oopts), add = TRUE)
[17:59:33.535]                       }
[17:59:33.535]                       {
[17:59:33.535]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.535]                           FUN = function(jj) {
[17:59:33.535]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.535]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.535]                           })
[17:59:33.535]                       }
[17:59:33.535]                     }, args = future.call.arguments)
[17:59:33.535]                   }
[17:59:33.535]                 }, immediateCondition = function(cond) {
[17:59:33.535]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.535]                   sendCondition(cond)
[17:59:33.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.535]                   {
[17:59:33.535]                     inherits <- base::inherits
[17:59:33.535]                     invokeRestart <- base::invokeRestart
[17:59:33.535]                     is.null <- base::is.null
[17:59:33.535]                     muffled <- FALSE
[17:59:33.535]                     if (inherits(cond, "message")) {
[17:59:33.535]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.535]                       if (muffled) 
[17:59:33.535]                         invokeRestart("muffleMessage")
[17:59:33.535]                     }
[17:59:33.535]                     else if (inherits(cond, "warning")) {
[17:59:33.535]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.535]                       if (muffled) 
[17:59:33.535]                         invokeRestart("muffleWarning")
[17:59:33.535]                     }
[17:59:33.535]                     else if (inherits(cond, "condition")) {
[17:59:33.535]                       if (!is.null(pattern)) {
[17:59:33.535]                         computeRestarts <- base::computeRestarts
[17:59:33.535]                         grepl <- base::grepl
[17:59:33.535]                         restarts <- computeRestarts(cond)
[17:59:33.535]                         for (restart in restarts) {
[17:59:33.535]                           name <- restart$name
[17:59:33.535]                           if (is.null(name)) 
[17:59:33.535]                             next
[17:59:33.535]                           if (!grepl(pattern, name)) 
[17:59:33.535]                             next
[17:59:33.535]                           invokeRestart(restart)
[17:59:33.535]                           muffled <- TRUE
[17:59:33.535]                           break
[17:59:33.535]                         }
[17:59:33.535]                       }
[17:59:33.535]                     }
[17:59:33.535]                     invisible(muffled)
[17:59:33.535]                   }
[17:59:33.535]                   muffleCondition(cond)
[17:59:33.535]                 })
[17:59:33.535]             }))
[17:59:33.535]             future::FutureResult(value = ...future.value$value, 
[17:59:33.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.535]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.535]                     ...future.globalenv.names))
[17:59:33.535]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.535]         }, condition = base::local({
[17:59:33.535]             c <- base::c
[17:59:33.535]             inherits <- base::inherits
[17:59:33.535]             invokeRestart <- base::invokeRestart
[17:59:33.535]             length <- base::length
[17:59:33.535]             list <- base::list
[17:59:33.535]             seq.int <- base::seq.int
[17:59:33.535]             signalCondition <- base::signalCondition
[17:59:33.535]             sys.calls <- base::sys.calls
[17:59:33.535]             `[[` <- base::`[[`
[17:59:33.535]             `+` <- base::`+`
[17:59:33.535]             `<<-` <- base::`<<-`
[17:59:33.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.535]                   3L)]
[17:59:33.535]             }
[17:59:33.535]             function(cond) {
[17:59:33.535]                 is_error <- inherits(cond, "error")
[17:59:33.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.535]                   NULL)
[17:59:33.535]                 if (is_error) {
[17:59:33.535]                   sessionInformation <- function() {
[17:59:33.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.535]                       search = base::search(), system = base::Sys.info())
[17:59:33.535]                   }
[17:59:33.535]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.535]                     cond$call), session = sessionInformation(), 
[17:59:33.535]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.535]                   signalCondition(cond)
[17:59:33.535]                 }
[17:59:33.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.535]                 "immediateCondition"))) {
[17:59:33.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.535]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.535]                   if (TRUE && !signal) {
[17:59:33.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.535]                     {
[17:59:33.535]                       inherits <- base::inherits
[17:59:33.535]                       invokeRestart <- base::invokeRestart
[17:59:33.535]                       is.null <- base::is.null
[17:59:33.535]                       muffled <- FALSE
[17:59:33.535]                       if (inherits(cond, "message")) {
[17:59:33.535]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.535]                         if (muffled) 
[17:59:33.535]                           invokeRestart("muffleMessage")
[17:59:33.535]                       }
[17:59:33.535]                       else if (inherits(cond, "warning")) {
[17:59:33.535]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.535]                         if (muffled) 
[17:59:33.535]                           invokeRestart("muffleWarning")
[17:59:33.535]                       }
[17:59:33.535]                       else if (inherits(cond, "condition")) {
[17:59:33.535]                         if (!is.null(pattern)) {
[17:59:33.535]                           computeRestarts <- base::computeRestarts
[17:59:33.535]                           grepl <- base::grepl
[17:59:33.535]                           restarts <- computeRestarts(cond)
[17:59:33.535]                           for (restart in restarts) {
[17:59:33.535]                             name <- restart$name
[17:59:33.535]                             if (is.null(name)) 
[17:59:33.535]                               next
[17:59:33.535]                             if (!grepl(pattern, name)) 
[17:59:33.535]                               next
[17:59:33.535]                             invokeRestart(restart)
[17:59:33.535]                             muffled <- TRUE
[17:59:33.535]                             break
[17:59:33.535]                           }
[17:59:33.535]                         }
[17:59:33.535]                       }
[17:59:33.535]                       invisible(muffled)
[17:59:33.535]                     }
[17:59:33.535]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.535]                   }
[17:59:33.535]                 }
[17:59:33.535]                 else {
[17:59:33.535]                   if (TRUE) {
[17:59:33.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.535]                     {
[17:59:33.535]                       inherits <- base::inherits
[17:59:33.535]                       invokeRestart <- base::invokeRestart
[17:59:33.535]                       is.null <- base::is.null
[17:59:33.535]                       muffled <- FALSE
[17:59:33.535]                       if (inherits(cond, "message")) {
[17:59:33.535]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.535]                         if (muffled) 
[17:59:33.535]                           invokeRestart("muffleMessage")
[17:59:33.535]                       }
[17:59:33.535]                       else if (inherits(cond, "warning")) {
[17:59:33.535]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.535]                         if (muffled) 
[17:59:33.535]                           invokeRestart("muffleWarning")
[17:59:33.535]                       }
[17:59:33.535]                       else if (inherits(cond, "condition")) {
[17:59:33.535]                         if (!is.null(pattern)) {
[17:59:33.535]                           computeRestarts <- base::computeRestarts
[17:59:33.535]                           grepl <- base::grepl
[17:59:33.535]                           restarts <- computeRestarts(cond)
[17:59:33.535]                           for (restart in restarts) {
[17:59:33.535]                             name <- restart$name
[17:59:33.535]                             if (is.null(name)) 
[17:59:33.535]                               next
[17:59:33.535]                             if (!grepl(pattern, name)) 
[17:59:33.535]                               next
[17:59:33.535]                             invokeRestart(restart)
[17:59:33.535]                             muffled <- TRUE
[17:59:33.535]                             break
[17:59:33.535]                           }
[17:59:33.535]                         }
[17:59:33.535]                       }
[17:59:33.535]                       invisible(muffled)
[17:59:33.535]                     }
[17:59:33.535]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.535]                   }
[17:59:33.535]                 }
[17:59:33.535]             }
[17:59:33.535]         }))
[17:59:33.535]     }, error = function(ex) {
[17:59:33.535]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.535]                 ...future.rng), started = ...future.startTime, 
[17:59:33.535]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.535]             version = "1.8"), class = "FutureResult")
[17:59:33.535]     }, finally = {
[17:59:33.535]         if (!identical(...future.workdir, getwd())) 
[17:59:33.535]             setwd(...future.workdir)
[17:59:33.535]         {
[17:59:33.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.535]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.535]             }
[17:59:33.535]             base::options(...future.oldOptions)
[17:59:33.535]             if (.Platform$OS.type == "windows") {
[17:59:33.535]                 old_names <- names(...future.oldEnvVars)
[17:59:33.535]                 envs <- base::Sys.getenv()
[17:59:33.535]                 names <- names(envs)
[17:59:33.535]                 common <- intersect(names, old_names)
[17:59:33.535]                 added <- setdiff(names, old_names)
[17:59:33.535]                 removed <- setdiff(old_names, names)
[17:59:33.535]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.535]                   envs[common]]
[17:59:33.535]                 NAMES <- toupper(changed)
[17:59:33.535]                 args <- list()
[17:59:33.535]                 for (kk in seq_along(NAMES)) {
[17:59:33.535]                   name <- changed[[kk]]
[17:59:33.535]                   NAME <- NAMES[[kk]]
[17:59:33.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.535]                     next
[17:59:33.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.535]                 }
[17:59:33.535]                 NAMES <- toupper(added)
[17:59:33.535]                 for (kk in seq_along(NAMES)) {
[17:59:33.535]                   name <- added[[kk]]
[17:59:33.535]                   NAME <- NAMES[[kk]]
[17:59:33.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.535]                     next
[17:59:33.535]                   args[[name]] <- ""
[17:59:33.535]                 }
[17:59:33.535]                 NAMES <- toupper(removed)
[17:59:33.535]                 for (kk in seq_along(NAMES)) {
[17:59:33.535]                   name <- removed[[kk]]
[17:59:33.535]                   NAME <- NAMES[[kk]]
[17:59:33.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.535]                     next
[17:59:33.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.535]                 }
[17:59:33.535]                 if (length(args) > 0) 
[17:59:33.535]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.535]             }
[17:59:33.535]             else {
[17:59:33.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.535]             }
[17:59:33.535]             {
[17:59:33.535]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.535]                   0L) {
[17:59:33.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.535]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.535]                   base::options(opts)
[17:59:33.535]                 }
[17:59:33.535]                 {
[17:59:33.535]                   {
[17:59:33.535]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.535]                     NULL
[17:59:33.535]                   }
[17:59:33.535]                   options(future.plan = NULL)
[17:59:33.535]                   if (is.na(NA_character_)) 
[17:59:33.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.535]                     .init = FALSE)
[17:59:33.535]                 }
[17:59:33.535]             }
[17:59:33.535]         }
[17:59:33.535]     })
[17:59:33.535]     if (TRUE) {
[17:59:33.535]         base::sink(type = "output", split = FALSE)
[17:59:33.535]         if (TRUE) {
[17:59:33.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.535]         }
[17:59:33.535]         else {
[17:59:33.535]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.535]         }
[17:59:33.535]         base::close(...future.stdout)
[17:59:33.535]         ...future.stdout <- NULL
[17:59:33.535]     }
[17:59:33.535]     ...future.result$conditions <- ...future.conditions
[17:59:33.535]     ...future.result$finished <- base::Sys.time()
[17:59:33.535]     ...future.result
[17:59:33.535] }
[17:59:33.540] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[17:59:33.541] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:59:33.542] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:59:33.542] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[17:59:33.543] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[17:59:33.543] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:59:33.544] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:59:33.544] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:33.545] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.546] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:33.546] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.547] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[17:59:33.548] MultisessionFuture started
[17:59:33.548] - Launch lazy future ... done
[17:59:33.548] run() for ‘MultisessionFuture’ ... done
[17:59:33.548] Created future:
[17:59:33.549] MultisessionFuture:
[17:59:33.549] Label: ‘future_eapply-2’
[17:59:33.549] Expression:
[17:59:33.549] {
[17:59:33.549]     do.call(function(...) {
[17:59:33.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.549]             on.exit(options(oopts), add = TRUE)
[17:59:33.549]         }
[17:59:33.549]         {
[17:59:33.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.549]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.549]             })
[17:59:33.549]         }
[17:59:33.549]     }, args = future.call.arguments)
[17:59:33.549] }
[17:59:33.549] Lazy evaluation: FALSE
[17:59:33.549] Asynchronous evaluation: TRUE
[17:59:33.549] Local evaluation: TRUE
[17:59:33.549] Environment: R_GlobalEnv
[17:59:33.549] Capture standard output: TRUE
[17:59:33.549] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.549] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.549] Packages: 1 packages (‘stats’)
[17:59:33.549] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.549] Resolved: FALSE
[17:59:33.549] Value: <not collected>
[17:59:33.549] Conditions captured: <none>
[17:59:33.549] Early signaling: FALSE
[17:59:33.549] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.549] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.561] Chunk #2 of 2 ... DONE
[17:59:33.562] Launching 2 futures (chunks) ... DONE
[17:59:33.562] Resolving 2 futures (chunks) ...
[17:59:33.562] resolve() on list ...
[17:59:33.562]  recursive: 0
[17:59:33.562]  length: 2
[17:59:33.563] 
[17:59:33.564] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.564] - Validating connection of MultisessionFuture
[17:59:33.564] - received message: FutureResult
[17:59:33.564] - Received FutureResult
[17:59:33.565] - Erased future from FutureRegistry
[17:59:33.565] result() for ClusterFuture ...
[17:59:33.565] - result already collected: FutureResult
[17:59:33.565] result() for ClusterFuture ... done
[17:59:33.565] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.566] Future #1
[17:59:33.566] result() for ClusterFuture ...
[17:59:33.566] - result already collected: FutureResult
[17:59:33.566] result() for ClusterFuture ... done
[17:59:33.566] result() for ClusterFuture ...
[17:59:33.567] - result already collected: FutureResult
[17:59:33.567] result() for ClusterFuture ... done
[17:59:33.567] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:33.567] - nx: 2
[17:59:33.567] - relay: TRUE
[17:59:33.568] - stdout: TRUE
[17:59:33.568] - signal: TRUE
[17:59:33.568] - resignal: FALSE
[17:59:33.568] - force: TRUE
[17:59:33.568] - relayed: [n=2] FALSE, FALSE
[17:59:33.569] - queued futures: [n=2] FALSE, FALSE
[17:59:33.570]  - until=1
[17:59:33.571]  - relaying element #1
[17:59:33.571] result() for ClusterFuture ...
[17:59:33.571] - result already collected: FutureResult
[17:59:33.571] result() for ClusterFuture ... done
[17:59:33.572] result() for ClusterFuture ...
[17:59:33.572] - result already collected: FutureResult
[17:59:33.572] result() for ClusterFuture ... done
[17:59:33.572] result() for ClusterFuture ...
[17:59:33.573] - result already collected: FutureResult
[17:59:33.574] result() for ClusterFuture ... done
[17:59:33.574] result() for ClusterFuture ...
[17:59:33.575] - result already collected: FutureResult
[17:59:33.577] result() for ClusterFuture ... done
[17:59:33.577] - relayed: [n=2] TRUE, FALSE
[17:59:33.577] - queued futures: [n=2] TRUE, FALSE
[17:59:33.578] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:33.578]  length: 1 (resolved future 1)
[17:59:33.600] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.601] - Validating connection of MultisessionFuture
[17:59:33.601] - received message: FutureResult
[17:59:33.601] - Received FutureResult
[17:59:33.602] - Erased future from FutureRegistry
[17:59:33.602] result() for ClusterFuture ...
[17:59:33.602] - result already collected: FutureResult
[17:59:33.602] result() for ClusterFuture ... done
[17:59:33.602] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.603] Future #2
[17:59:33.603] result() for ClusterFuture ...
[17:59:33.603] - result already collected: FutureResult
[17:59:33.603] result() for ClusterFuture ... done
[17:59:33.603] result() for ClusterFuture ...
[17:59:33.604] - result already collected: FutureResult
[17:59:33.604] result() for ClusterFuture ... done
[17:59:33.604] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:33.604] - nx: 2
[17:59:33.604] - relay: TRUE
[17:59:33.604] - stdout: TRUE
[17:59:33.605] - signal: TRUE
[17:59:33.605] - resignal: FALSE
[17:59:33.605] - force: TRUE
[17:59:33.605] - relayed: [n=2] TRUE, FALSE
[17:59:33.605] - queued futures: [n=2] TRUE, FALSE
[17:59:33.606]  - until=2
[17:59:33.606]  - relaying element #2
[17:59:33.606] result() for ClusterFuture ...
[17:59:33.606] - result already collected: FutureResult
[17:59:33.606] result() for ClusterFuture ... done
[17:59:33.606] result() for ClusterFuture ...
[17:59:33.607] - result already collected: FutureResult
[17:59:33.607] result() for ClusterFuture ... done
[17:59:33.607] result() for ClusterFuture ...
[17:59:33.607] - result already collected: FutureResult
[17:59:33.607] result() for ClusterFuture ... done
[17:59:33.608] result() for ClusterFuture ...
[17:59:33.608] - result already collected: FutureResult
[17:59:33.608] result() for ClusterFuture ... done
[17:59:33.608] - relayed: [n=2] TRUE, TRUE
[17:59:33.608] - queued futures: [n=2] TRUE, TRUE
[17:59:33.609] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:33.609]  length: 0 (resolved future 2)
[17:59:33.609] Relaying remaining futures
[17:59:33.609] signalConditionsASAP(NULL, pos=0) ...
[17:59:33.609] - nx: 2
[17:59:33.609] - relay: TRUE
[17:59:33.610] - stdout: TRUE
[17:59:33.610] - signal: TRUE
[17:59:33.610] - resignal: FALSE
[17:59:33.610] - force: TRUE
[17:59:33.610] - relayed: [n=2] TRUE, TRUE
[17:59:33.610] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:33.611] - relayed: [n=2] TRUE, TRUE
[17:59:33.611] - queued futures: [n=2] TRUE, TRUE
[17:59:33.611] signalConditionsASAP(NULL, pos=0) ... done
[17:59:33.611] resolve() on list ... DONE
[17:59:33.612] result() for ClusterFuture ...
[17:59:33.612] - result already collected: FutureResult
[17:59:33.612] result() for ClusterFuture ... done
[17:59:33.612] result() for ClusterFuture ...
[17:59:33.612] - result already collected: FutureResult
[17:59:33.612] result() for ClusterFuture ... done
[17:59:33.613] result() for ClusterFuture ...
[17:59:33.613] - result already collected: FutureResult
[17:59:33.613] result() for ClusterFuture ... done
[17:59:33.613] result() for ClusterFuture ...
[17:59:33.613] - result already collected: FutureResult
[17:59:33.614] result() for ClusterFuture ... done
[17:59:33.614]  - Number of value chunks collected: 2
[17:59:33.614] Resolving 2 futures (chunks) ... DONE
[17:59:33.614] Reducing values from 2 chunks ...
[17:59:33.614]  - Number of values collected after concatenation: 3
[17:59:33.614]  - Number of values expected: 3
[17:59:33.615] Reducing values from 2 chunks ... DONE
[17:59:33.615] future_lapply() ... DONE
[17:59:33.616] future_lapply() ...
[17:59:33.623] Number of chunks: 2
[17:59:33.623] getGlobalsAndPackagesXApply() ...
[17:59:33.623]  - future.globals: TRUE
[17:59:33.624] getGlobalsAndPackages() ...
[17:59:33.624] Searching for globals...
[17:59:33.626] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:33.626] Searching for globals ... DONE
[17:59:33.626] Resolving globals: FALSE
[17:59:33.627] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:33.628] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:33.628] - globals: [1] ‘FUN’
[17:59:33.628] - packages: [1] ‘stats’
[17:59:33.628] getGlobalsAndPackages() ... DONE
[17:59:33.629]  - globals found/used: [n=1] ‘FUN’
[17:59:33.629]  - needed namespaces: [n=1] ‘stats’
[17:59:33.629] Finding globals ... DONE
[17:59:33.629]  - use_args: TRUE
[17:59:33.629]  - Getting '...' globals ...
[17:59:33.630] resolve() on list ...
[17:59:33.630]  recursive: 0
[17:59:33.630]  length: 1
[17:59:33.631]  elements: ‘...’
[17:59:33.631]  length: 0 (resolved future 1)
[17:59:33.631] resolve() on list ... DONE
[17:59:33.631]    - '...' content: [n=0] 
[17:59:33.632] List of 1
[17:59:33.632]  $ ...: list()
[17:59:33.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.632]  - attr(*, "where")=List of 1
[17:59:33.632]   ..$ ...:<environment: 0x58d4c6af90d0> 
[17:59:33.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.632]  - attr(*, "resolved")= logi TRUE
[17:59:33.632]  - attr(*, "total_size")= num NA
[17:59:33.637]  - Getting '...' globals ... DONE
[17:59:33.645] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:33.646] List of 2
[17:59:33.646]  $ ...future.FUN:function (x, ...)  
[17:59:33.646]  $ ...          : list()
[17:59:33.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.646]  - attr(*, "where")=List of 2
[17:59:33.646]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:33.646]   ..$ ...          :<environment: 0x58d4c6af90d0> 
[17:59:33.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.646]  - attr(*, "resolved")= logi FALSE
[17:59:33.646]  - attr(*, "total_size")= num 1248
[17:59:33.652] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:33.652] getGlobalsAndPackagesXApply() ... DONE
[17:59:33.652] Number of futures (= number of chunks): 2
[17:59:33.653] Launching 2 futures (chunks) ...
[17:59:33.653] Chunk #1 of 2 ...
[17:59:33.654]  - Finding globals in 'X' for chunk #1 ...
[17:59:33.654] getGlobalsAndPackages() ...
[17:59:33.654] Searching for globals...
[17:59:33.655] 
[17:59:33.655] Searching for globals ... DONE
[17:59:33.655] - globals: [0] <none>
[17:59:33.655] getGlobalsAndPackages() ... DONE
[17:59:33.655]    + additional globals found: [n=0] 
[17:59:33.656]    + additional namespaces needed: [n=0] 
[17:59:33.656]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:33.656]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.656]  - seeds: <none>
[17:59:33.656]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.657] getGlobalsAndPackages() ...
[17:59:33.657] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.657] Resolving globals: FALSE
[17:59:33.657] Tweak future expression to call with '...' arguments ...
[17:59:33.657] {
[17:59:33.657]     do.call(function(...) {
[17:59:33.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.657]             on.exit(options(oopts), add = TRUE)
[17:59:33.657]         }
[17:59:33.657]         {
[17:59:33.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.657]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.657]             })
[17:59:33.657]         }
[17:59:33.657]     }, args = future.call.arguments)
[17:59:33.657] }
[17:59:33.658] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.659] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.659] - packages: [1] ‘stats’
[17:59:33.659] getGlobalsAndPackages() ... DONE
[17:59:33.660] run() for ‘Future’ ...
[17:59:33.660] - state: ‘created’
[17:59:33.660] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.682] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.683]   - Field: ‘node’
[17:59:33.683]   - Field: ‘label’
[17:59:33.683]   - Field: ‘local’
[17:59:33.683]   - Field: ‘owner’
[17:59:33.684]   - Field: ‘envir’
[17:59:33.684]   - Field: ‘workers’
[17:59:33.684]   - Field: ‘packages’
[17:59:33.684]   - Field: ‘gc’
[17:59:33.684]   - Field: ‘conditions’
[17:59:33.684]   - Field: ‘persistent’
[17:59:33.685]   - Field: ‘expr’
[17:59:33.685]   - Field: ‘uuid’
[17:59:33.685]   - Field: ‘seed’
[17:59:33.685]   - Field: ‘version’
[17:59:33.685]   - Field: ‘result’
[17:59:33.686]   - Field: ‘asynchronous’
[17:59:33.686]   - Field: ‘calls’
[17:59:33.686]   - Field: ‘globals’
[17:59:33.686]   - Field: ‘stdout’
[17:59:33.686]   - Field: ‘earlySignal’
[17:59:33.687]   - Field: ‘lazy’
[17:59:33.687]   - Field: ‘state’
[17:59:33.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.687] - Launch lazy future ...
[17:59:33.688] Packages needed by the future expression (n = 1): ‘stats’
[17:59:33.688] Packages needed by future strategies (n = 0): <none>
[17:59:33.689] {
[17:59:33.689]     {
[17:59:33.689]         {
[17:59:33.689]             ...future.startTime <- base::Sys.time()
[17:59:33.689]             {
[17:59:33.689]                 {
[17:59:33.689]                   {
[17:59:33.689]                     {
[17:59:33.689]                       {
[17:59:33.689]                         base::local({
[17:59:33.689]                           has_future <- base::requireNamespace("future", 
[17:59:33.689]                             quietly = TRUE)
[17:59:33.689]                           if (has_future) {
[17:59:33.689]                             ns <- base::getNamespace("future")
[17:59:33.689]                             version <- ns[[".package"]][["version"]]
[17:59:33.689]                             if (is.null(version)) 
[17:59:33.689]                               version <- utils::packageVersion("future")
[17:59:33.689]                           }
[17:59:33.689]                           else {
[17:59:33.689]                             version <- NULL
[17:59:33.689]                           }
[17:59:33.689]                           if (!has_future || version < "1.8.0") {
[17:59:33.689]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.689]                               "", base::R.version$version.string), 
[17:59:33.689]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:33.689]                                 base::R.version$platform, 8 * 
[17:59:33.689]                                   base::.Machine$sizeof.pointer), 
[17:59:33.689]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.689]                                 "release", "version")], collapse = " "), 
[17:59:33.689]                               hostname = base::Sys.info()[["nodename"]])
[17:59:33.689]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.689]                               info)
[17:59:33.689]                             info <- base::paste(info, collapse = "; ")
[17:59:33.689]                             if (!has_future) {
[17:59:33.689]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.689]                                 info)
[17:59:33.689]                             }
[17:59:33.689]                             else {
[17:59:33.689]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.689]                                 info, version)
[17:59:33.689]                             }
[17:59:33.689]                             base::stop(msg)
[17:59:33.689]                           }
[17:59:33.689]                         })
[17:59:33.689]                       }
[17:59:33.689]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.689]                       base::options(mc.cores = 1L)
[17:59:33.689]                     }
[17:59:33.689]                     base::local({
[17:59:33.689]                       for (pkg in "stats") {
[17:59:33.689]                         base::loadNamespace(pkg)
[17:59:33.689]                         base::library(pkg, character.only = TRUE)
[17:59:33.689]                       }
[17:59:33.689]                     })
[17:59:33.689]                   }
[17:59:33.689]                   ...future.strategy.old <- future::plan("list")
[17:59:33.689]                   options(future.plan = NULL)
[17:59:33.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.689]                 }
[17:59:33.689]                 ...future.workdir <- getwd()
[17:59:33.689]             }
[17:59:33.689]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.689]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.689]         }
[17:59:33.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.689]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.689]             base::names(...future.oldOptions))
[17:59:33.689]     }
[17:59:33.689]     if (FALSE) {
[17:59:33.689]     }
[17:59:33.689]     else {
[17:59:33.689]         if (TRUE) {
[17:59:33.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.689]                 open = "w")
[17:59:33.689]         }
[17:59:33.689]         else {
[17:59:33.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.689]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.689]         }
[17:59:33.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.689]             base::sink(type = "output", split = FALSE)
[17:59:33.689]             base::close(...future.stdout)
[17:59:33.689]         }, add = TRUE)
[17:59:33.689]     }
[17:59:33.689]     ...future.frame <- base::sys.nframe()
[17:59:33.689]     ...future.conditions <- base::list()
[17:59:33.689]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.689]     if (FALSE) {
[17:59:33.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.689]     }
[17:59:33.689]     ...future.result <- base::tryCatch({
[17:59:33.689]         base::withCallingHandlers({
[17:59:33.689]             ...future.value <- base::withVisible(base::local({
[17:59:33.689]                 ...future.makeSendCondition <- base::local({
[17:59:33.689]                   sendCondition <- NULL
[17:59:33.689]                   function(frame = 1L) {
[17:59:33.689]                     if (is.function(sendCondition)) 
[17:59:33.689]                       return(sendCondition)
[17:59:33.689]                     ns <- getNamespace("parallel")
[17:59:33.689]                     if (exists("sendData", mode = "function", 
[17:59:33.689]                       envir = ns)) {
[17:59:33.689]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.689]                         envir = ns)
[17:59:33.689]                       envir <- sys.frame(frame)
[17:59:33.689]                       master <- NULL
[17:59:33.689]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.689]                         !identical(envir, emptyenv())) {
[17:59:33.689]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.689]                           inherits = FALSE)) {
[17:59:33.689]                           master <- get("master", mode = "list", 
[17:59:33.689]                             envir = envir, inherits = FALSE)
[17:59:33.689]                           if (inherits(master, c("SOCKnode", 
[17:59:33.689]                             "SOCK0node"))) {
[17:59:33.689]                             sendCondition <<- function(cond) {
[17:59:33.689]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.689]                                 success = TRUE)
[17:59:33.689]                               parallel_sendData(master, data)
[17:59:33.689]                             }
[17:59:33.689]                             return(sendCondition)
[17:59:33.689]                           }
[17:59:33.689]                         }
[17:59:33.689]                         frame <- frame + 1L
[17:59:33.689]                         envir <- sys.frame(frame)
[17:59:33.689]                       }
[17:59:33.689]                     }
[17:59:33.689]                     sendCondition <<- function(cond) NULL
[17:59:33.689]                   }
[17:59:33.689]                 })
[17:59:33.689]                 withCallingHandlers({
[17:59:33.689]                   {
[17:59:33.689]                     do.call(function(...) {
[17:59:33.689]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.689]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.689]                         ...future.globals.maxSize)) {
[17:59:33.689]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.689]                         on.exit(options(oopts), add = TRUE)
[17:59:33.689]                       }
[17:59:33.689]                       {
[17:59:33.689]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.689]                           FUN = function(jj) {
[17:59:33.689]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.689]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.689]                           })
[17:59:33.689]                       }
[17:59:33.689]                     }, args = future.call.arguments)
[17:59:33.689]                   }
[17:59:33.689]                 }, immediateCondition = function(cond) {
[17:59:33.689]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.689]                   sendCondition(cond)
[17:59:33.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.689]                   {
[17:59:33.689]                     inherits <- base::inherits
[17:59:33.689]                     invokeRestart <- base::invokeRestart
[17:59:33.689]                     is.null <- base::is.null
[17:59:33.689]                     muffled <- FALSE
[17:59:33.689]                     if (inherits(cond, "message")) {
[17:59:33.689]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.689]                       if (muffled) 
[17:59:33.689]                         invokeRestart("muffleMessage")
[17:59:33.689]                     }
[17:59:33.689]                     else if (inherits(cond, "warning")) {
[17:59:33.689]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.689]                       if (muffled) 
[17:59:33.689]                         invokeRestart("muffleWarning")
[17:59:33.689]                     }
[17:59:33.689]                     else if (inherits(cond, "condition")) {
[17:59:33.689]                       if (!is.null(pattern)) {
[17:59:33.689]                         computeRestarts <- base::computeRestarts
[17:59:33.689]                         grepl <- base::grepl
[17:59:33.689]                         restarts <- computeRestarts(cond)
[17:59:33.689]                         for (restart in restarts) {
[17:59:33.689]                           name <- restart$name
[17:59:33.689]                           if (is.null(name)) 
[17:59:33.689]                             next
[17:59:33.689]                           if (!grepl(pattern, name)) 
[17:59:33.689]                             next
[17:59:33.689]                           invokeRestart(restart)
[17:59:33.689]                           muffled <- TRUE
[17:59:33.689]                           break
[17:59:33.689]                         }
[17:59:33.689]                       }
[17:59:33.689]                     }
[17:59:33.689]                     invisible(muffled)
[17:59:33.689]                   }
[17:59:33.689]                   muffleCondition(cond)
[17:59:33.689]                 })
[17:59:33.689]             }))
[17:59:33.689]             future::FutureResult(value = ...future.value$value, 
[17:59:33.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.689]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.689]                     ...future.globalenv.names))
[17:59:33.689]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.689]         }, condition = base::local({
[17:59:33.689]             c <- base::c
[17:59:33.689]             inherits <- base::inherits
[17:59:33.689]             invokeRestart <- base::invokeRestart
[17:59:33.689]             length <- base::length
[17:59:33.689]             list <- base::list
[17:59:33.689]             seq.int <- base::seq.int
[17:59:33.689]             signalCondition <- base::signalCondition
[17:59:33.689]             sys.calls <- base::sys.calls
[17:59:33.689]             `[[` <- base::`[[`
[17:59:33.689]             `+` <- base::`+`
[17:59:33.689]             `<<-` <- base::`<<-`
[17:59:33.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.689]                   3L)]
[17:59:33.689]             }
[17:59:33.689]             function(cond) {
[17:59:33.689]                 is_error <- inherits(cond, "error")
[17:59:33.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.689]                   NULL)
[17:59:33.689]                 if (is_error) {
[17:59:33.689]                   sessionInformation <- function() {
[17:59:33.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.689]                       search = base::search(), system = base::Sys.info())
[17:59:33.689]                   }
[17:59:33.689]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.689]                     cond$call), session = sessionInformation(), 
[17:59:33.689]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.689]                   signalCondition(cond)
[17:59:33.689]                 }
[17:59:33.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.689]                 "immediateCondition"))) {
[17:59:33.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.689]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.689]                   if (TRUE && !signal) {
[17:59:33.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.689]                     {
[17:59:33.689]                       inherits <- base::inherits
[17:59:33.689]                       invokeRestart <- base::invokeRestart
[17:59:33.689]                       is.null <- base::is.null
[17:59:33.689]                       muffled <- FALSE
[17:59:33.689]                       if (inherits(cond, "message")) {
[17:59:33.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.689]                         if (muffled) 
[17:59:33.689]                           invokeRestart("muffleMessage")
[17:59:33.689]                       }
[17:59:33.689]                       else if (inherits(cond, "warning")) {
[17:59:33.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.689]                         if (muffled) 
[17:59:33.689]                           invokeRestart("muffleWarning")
[17:59:33.689]                       }
[17:59:33.689]                       else if (inherits(cond, "condition")) {
[17:59:33.689]                         if (!is.null(pattern)) {
[17:59:33.689]                           computeRestarts <- base::computeRestarts
[17:59:33.689]                           grepl <- base::grepl
[17:59:33.689]                           restarts <- computeRestarts(cond)
[17:59:33.689]                           for (restart in restarts) {
[17:59:33.689]                             name <- restart$name
[17:59:33.689]                             if (is.null(name)) 
[17:59:33.689]                               next
[17:59:33.689]                             if (!grepl(pattern, name)) 
[17:59:33.689]                               next
[17:59:33.689]                             invokeRestart(restart)
[17:59:33.689]                             muffled <- TRUE
[17:59:33.689]                             break
[17:59:33.689]                           }
[17:59:33.689]                         }
[17:59:33.689]                       }
[17:59:33.689]                       invisible(muffled)
[17:59:33.689]                     }
[17:59:33.689]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.689]                   }
[17:59:33.689]                 }
[17:59:33.689]                 else {
[17:59:33.689]                   if (TRUE) {
[17:59:33.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.689]                     {
[17:59:33.689]                       inherits <- base::inherits
[17:59:33.689]                       invokeRestart <- base::invokeRestart
[17:59:33.689]                       is.null <- base::is.null
[17:59:33.689]                       muffled <- FALSE
[17:59:33.689]                       if (inherits(cond, "message")) {
[17:59:33.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.689]                         if (muffled) 
[17:59:33.689]                           invokeRestart("muffleMessage")
[17:59:33.689]                       }
[17:59:33.689]                       else if (inherits(cond, "warning")) {
[17:59:33.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.689]                         if (muffled) 
[17:59:33.689]                           invokeRestart("muffleWarning")
[17:59:33.689]                       }
[17:59:33.689]                       else if (inherits(cond, "condition")) {
[17:59:33.689]                         if (!is.null(pattern)) {
[17:59:33.689]                           computeRestarts <- base::computeRestarts
[17:59:33.689]                           grepl <- base::grepl
[17:59:33.689]                           restarts <- computeRestarts(cond)
[17:59:33.689]                           for (restart in restarts) {
[17:59:33.689]                             name <- restart$name
[17:59:33.689]                             if (is.null(name)) 
[17:59:33.689]                               next
[17:59:33.689]                             if (!grepl(pattern, name)) 
[17:59:33.689]                               next
[17:59:33.689]                             invokeRestart(restart)
[17:59:33.689]                             muffled <- TRUE
[17:59:33.689]                             break
[17:59:33.689]                           }
[17:59:33.689]                         }
[17:59:33.689]                       }
[17:59:33.689]                       invisible(muffled)
[17:59:33.689]                     }
[17:59:33.689]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.689]                   }
[17:59:33.689]                 }
[17:59:33.689]             }
[17:59:33.689]         }))
[17:59:33.689]     }, error = function(ex) {
[17:59:33.689]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.689]                 ...future.rng), started = ...future.startTime, 
[17:59:33.689]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.689]             version = "1.8"), class = "FutureResult")
[17:59:33.689]     }, finally = {
[17:59:33.689]         if (!identical(...future.workdir, getwd())) 
[17:59:33.689]             setwd(...future.workdir)
[17:59:33.689]         {
[17:59:33.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.689]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.689]             }
[17:59:33.689]             base::options(...future.oldOptions)
[17:59:33.689]             if (.Platform$OS.type == "windows") {
[17:59:33.689]                 old_names <- names(...future.oldEnvVars)
[17:59:33.689]                 envs <- base::Sys.getenv()
[17:59:33.689]                 names <- names(envs)
[17:59:33.689]                 common <- intersect(names, old_names)
[17:59:33.689]                 added <- setdiff(names, old_names)
[17:59:33.689]                 removed <- setdiff(old_names, names)
[17:59:33.689]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.689]                   envs[common]]
[17:59:33.689]                 NAMES <- toupper(changed)
[17:59:33.689]                 args <- list()
[17:59:33.689]                 for (kk in seq_along(NAMES)) {
[17:59:33.689]                   name <- changed[[kk]]
[17:59:33.689]                   NAME <- NAMES[[kk]]
[17:59:33.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.689]                     next
[17:59:33.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.689]                 }
[17:59:33.689]                 NAMES <- toupper(added)
[17:59:33.689]                 for (kk in seq_along(NAMES)) {
[17:59:33.689]                   name <- added[[kk]]
[17:59:33.689]                   NAME <- NAMES[[kk]]
[17:59:33.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.689]                     next
[17:59:33.689]                   args[[name]] <- ""
[17:59:33.689]                 }
[17:59:33.689]                 NAMES <- toupper(removed)
[17:59:33.689]                 for (kk in seq_along(NAMES)) {
[17:59:33.689]                   name <- removed[[kk]]
[17:59:33.689]                   NAME <- NAMES[[kk]]
[17:59:33.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.689]                     next
[17:59:33.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.689]                 }
[17:59:33.689]                 if (length(args) > 0) 
[17:59:33.689]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.689]             }
[17:59:33.689]             else {
[17:59:33.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.689]             }
[17:59:33.689]             {
[17:59:33.689]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.689]                   0L) {
[17:59:33.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.689]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.689]                   base::options(opts)
[17:59:33.689]                 }
[17:59:33.689]                 {
[17:59:33.689]                   {
[17:59:33.689]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.689]                     NULL
[17:59:33.689]                   }
[17:59:33.689]                   options(future.plan = NULL)
[17:59:33.689]                   if (is.na(NA_character_)) 
[17:59:33.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.689]                     .init = FALSE)
[17:59:33.689]                 }
[17:59:33.689]             }
[17:59:33.689]         }
[17:59:33.689]     })
[17:59:33.689]     if (TRUE) {
[17:59:33.689]         base::sink(type = "output", split = FALSE)
[17:59:33.689]         if (TRUE) {
[17:59:33.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.689]         }
[17:59:33.689]         else {
[17:59:33.689]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.689]         }
[17:59:33.689]         base::close(...future.stdout)
[17:59:33.689]         ...future.stdout <- NULL
[17:59:33.689]     }
[17:59:33.689]     ...future.result$conditions <- ...future.conditions
[17:59:33.689]     ...future.result$finished <- base::Sys.time()
[17:59:33.689]     ...future.result
[17:59:33.689] }
[17:59:33.694] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:59:33.694] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:59:33.695] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:59:33.696] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:33.696] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.697] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:59:33.697] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:59:33.698] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:33.698] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.699] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:33.700] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.700] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:59:33.701] MultisessionFuture started
[17:59:33.701] - Launch lazy future ... done
[17:59:33.701] run() for ‘MultisessionFuture’ ... done
[17:59:33.701] Created future:
[17:59:33.702] MultisessionFuture:
[17:59:33.702] Label: ‘future_eapply-1’
[17:59:33.702] Expression:
[17:59:33.702] {
[17:59:33.702]     do.call(function(...) {
[17:59:33.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.702]             on.exit(options(oopts), add = TRUE)
[17:59:33.702]         }
[17:59:33.702]         {
[17:59:33.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.702]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.702]             })
[17:59:33.702]         }
[17:59:33.702]     }, args = future.call.arguments)
[17:59:33.702] }
[17:59:33.702] Lazy evaluation: FALSE
[17:59:33.702] Asynchronous evaluation: TRUE
[17:59:33.702] Local evaluation: TRUE
[17:59:33.702] Environment: R_GlobalEnv
[17:59:33.702] Capture standard output: TRUE
[17:59:33.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.702] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.702] Packages: 1 packages (‘stats’)
[17:59:33.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.702] Resolved: FALSE
[17:59:33.702] Value: <not collected>
[17:59:33.702] Conditions captured: <none>
[17:59:33.702] Early signaling: FALSE
[17:59:33.702] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.702] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.714] Chunk #1 of 2 ... DONE
[17:59:33.715] Chunk #2 of 2 ...
[17:59:33.715]  - Finding globals in 'X' for chunk #2 ...
[17:59:33.715] getGlobalsAndPackages() ...
[17:59:33.715] Searching for globals...
[17:59:33.716] 
[17:59:33.716] Searching for globals ... DONE
[17:59:33.716] - globals: [0] <none>
[17:59:33.716] getGlobalsAndPackages() ... DONE
[17:59:33.717]    + additional globals found: [n=0] 
[17:59:33.717]    + additional namespaces needed: [n=0] 
[17:59:33.717]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:33.717]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.717]  - seeds: <none>
[17:59:33.718]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.718] getGlobalsAndPackages() ...
[17:59:33.718] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.718] Resolving globals: FALSE
[17:59:33.718] Tweak future expression to call with '...' arguments ...
[17:59:33.719] {
[17:59:33.719]     do.call(function(...) {
[17:59:33.719]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.719]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.719]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.719]             on.exit(options(oopts), add = TRUE)
[17:59:33.719]         }
[17:59:33.719]         {
[17:59:33.719]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.719]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.719]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.719]             })
[17:59:33.719]         }
[17:59:33.719]     }, args = future.call.arguments)
[17:59:33.719] }
[17:59:33.719] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.720] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.720] - packages: [1] ‘stats’
[17:59:33.720] getGlobalsAndPackages() ... DONE
[17:59:33.721] run() for ‘Future’ ...
[17:59:33.721] - state: ‘created’
[17:59:33.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.745]   - Field: ‘node’
[17:59:33.745]   - Field: ‘label’
[17:59:33.746]   - Field: ‘local’
[17:59:33.746]   - Field: ‘owner’
[17:59:33.746]   - Field: ‘envir’
[17:59:33.746]   - Field: ‘workers’
[17:59:33.746]   - Field: ‘packages’
[17:59:33.747]   - Field: ‘gc’
[17:59:33.747]   - Field: ‘conditions’
[17:59:33.747]   - Field: ‘persistent’
[17:59:33.747]   - Field: ‘expr’
[17:59:33.747]   - Field: ‘uuid’
[17:59:33.748]   - Field: ‘seed’
[17:59:33.748]   - Field: ‘version’
[17:59:33.748]   - Field: ‘result’
[17:59:33.748]   - Field: ‘asynchronous’
[17:59:33.748]   - Field: ‘calls’
[17:59:33.748]   - Field: ‘globals’
[17:59:33.749]   - Field: ‘stdout’
[17:59:33.749]   - Field: ‘earlySignal’
[17:59:33.749]   - Field: ‘lazy’
[17:59:33.749]   - Field: ‘state’
[17:59:33.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.750] - Launch lazy future ...
[17:59:33.750] Packages needed by the future expression (n = 1): ‘stats’
[17:59:33.750] Packages needed by future strategies (n = 0): <none>
[17:59:33.751] {
[17:59:33.751]     {
[17:59:33.751]         {
[17:59:33.751]             ...future.startTime <- base::Sys.time()
[17:59:33.751]             {
[17:59:33.751]                 {
[17:59:33.751]                   {
[17:59:33.751]                     {
[17:59:33.751]                       {
[17:59:33.751]                         base::local({
[17:59:33.751]                           has_future <- base::requireNamespace("future", 
[17:59:33.751]                             quietly = TRUE)
[17:59:33.751]                           if (has_future) {
[17:59:33.751]                             ns <- base::getNamespace("future")
[17:59:33.751]                             version <- ns[[".package"]][["version"]]
[17:59:33.751]                             if (is.null(version)) 
[17:59:33.751]                               version <- utils::packageVersion("future")
[17:59:33.751]                           }
[17:59:33.751]                           else {
[17:59:33.751]                             version <- NULL
[17:59:33.751]                           }
[17:59:33.751]                           if (!has_future || version < "1.8.0") {
[17:59:33.751]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.751]                               "", base::R.version$version.string), 
[17:59:33.751]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:33.751]                                 base::R.version$platform, 8 * 
[17:59:33.751]                                   base::.Machine$sizeof.pointer), 
[17:59:33.751]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.751]                                 "release", "version")], collapse = " "), 
[17:59:33.751]                               hostname = base::Sys.info()[["nodename"]])
[17:59:33.751]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.751]                               info)
[17:59:33.751]                             info <- base::paste(info, collapse = "; ")
[17:59:33.751]                             if (!has_future) {
[17:59:33.751]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.751]                                 info)
[17:59:33.751]                             }
[17:59:33.751]                             else {
[17:59:33.751]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.751]                                 info, version)
[17:59:33.751]                             }
[17:59:33.751]                             base::stop(msg)
[17:59:33.751]                           }
[17:59:33.751]                         })
[17:59:33.751]                       }
[17:59:33.751]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.751]                       base::options(mc.cores = 1L)
[17:59:33.751]                     }
[17:59:33.751]                     base::local({
[17:59:33.751]                       for (pkg in "stats") {
[17:59:33.751]                         base::loadNamespace(pkg)
[17:59:33.751]                         base::library(pkg, character.only = TRUE)
[17:59:33.751]                       }
[17:59:33.751]                     })
[17:59:33.751]                   }
[17:59:33.751]                   ...future.strategy.old <- future::plan("list")
[17:59:33.751]                   options(future.plan = NULL)
[17:59:33.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.751]                 }
[17:59:33.751]                 ...future.workdir <- getwd()
[17:59:33.751]             }
[17:59:33.751]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.751]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.751]         }
[17:59:33.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.751]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.751]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.751]             base::names(...future.oldOptions))
[17:59:33.751]     }
[17:59:33.751]     if (FALSE) {
[17:59:33.751]     }
[17:59:33.751]     else {
[17:59:33.751]         if (TRUE) {
[17:59:33.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.751]                 open = "w")
[17:59:33.751]         }
[17:59:33.751]         else {
[17:59:33.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.751]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.751]         }
[17:59:33.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.751]             base::sink(type = "output", split = FALSE)
[17:59:33.751]             base::close(...future.stdout)
[17:59:33.751]         }, add = TRUE)
[17:59:33.751]     }
[17:59:33.751]     ...future.frame <- base::sys.nframe()
[17:59:33.751]     ...future.conditions <- base::list()
[17:59:33.751]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.751]     if (FALSE) {
[17:59:33.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.751]     }
[17:59:33.751]     ...future.result <- base::tryCatch({
[17:59:33.751]         base::withCallingHandlers({
[17:59:33.751]             ...future.value <- base::withVisible(base::local({
[17:59:33.751]                 ...future.makeSendCondition <- base::local({
[17:59:33.751]                   sendCondition <- NULL
[17:59:33.751]                   function(frame = 1L) {
[17:59:33.751]                     if (is.function(sendCondition)) 
[17:59:33.751]                       return(sendCondition)
[17:59:33.751]                     ns <- getNamespace("parallel")
[17:59:33.751]                     if (exists("sendData", mode = "function", 
[17:59:33.751]                       envir = ns)) {
[17:59:33.751]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.751]                         envir = ns)
[17:59:33.751]                       envir <- sys.frame(frame)
[17:59:33.751]                       master <- NULL
[17:59:33.751]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.751]                         !identical(envir, emptyenv())) {
[17:59:33.751]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.751]                           inherits = FALSE)) {
[17:59:33.751]                           master <- get("master", mode = "list", 
[17:59:33.751]                             envir = envir, inherits = FALSE)
[17:59:33.751]                           if (inherits(master, c("SOCKnode", 
[17:59:33.751]                             "SOCK0node"))) {
[17:59:33.751]                             sendCondition <<- function(cond) {
[17:59:33.751]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.751]                                 success = TRUE)
[17:59:33.751]                               parallel_sendData(master, data)
[17:59:33.751]                             }
[17:59:33.751]                             return(sendCondition)
[17:59:33.751]                           }
[17:59:33.751]                         }
[17:59:33.751]                         frame <- frame + 1L
[17:59:33.751]                         envir <- sys.frame(frame)
[17:59:33.751]                       }
[17:59:33.751]                     }
[17:59:33.751]                     sendCondition <<- function(cond) NULL
[17:59:33.751]                   }
[17:59:33.751]                 })
[17:59:33.751]                 withCallingHandlers({
[17:59:33.751]                   {
[17:59:33.751]                     do.call(function(...) {
[17:59:33.751]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.751]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.751]                         ...future.globals.maxSize)) {
[17:59:33.751]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.751]                         on.exit(options(oopts), add = TRUE)
[17:59:33.751]                       }
[17:59:33.751]                       {
[17:59:33.751]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.751]                           FUN = function(jj) {
[17:59:33.751]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.751]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.751]                           })
[17:59:33.751]                       }
[17:59:33.751]                     }, args = future.call.arguments)
[17:59:33.751]                   }
[17:59:33.751]                 }, immediateCondition = function(cond) {
[17:59:33.751]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.751]                   sendCondition(cond)
[17:59:33.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.751]                   {
[17:59:33.751]                     inherits <- base::inherits
[17:59:33.751]                     invokeRestart <- base::invokeRestart
[17:59:33.751]                     is.null <- base::is.null
[17:59:33.751]                     muffled <- FALSE
[17:59:33.751]                     if (inherits(cond, "message")) {
[17:59:33.751]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.751]                       if (muffled) 
[17:59:33.751]                         invokeRestart("muffleMessage")
[17:59:33.751]                     }
[17:59:33.751]                     else if (inherits(cond, "warning")) {
[17:59:33.751]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.751]                       if (muffled) 
[17:59:33.751]                         invokeRestart("muffleWarning")
[17:59:33.751]                     }
[17:59:33.751]                     else if (inherits(cond, "condition")) {
[17:59:33.751]                       if (!is.null(pattern)) {
[17:59:33.751]                         computeRestarts <- base::computeRestarts
[17:59:33.751]                         grepl <- base::grepl
[17:59:33.751]                         restarts <- computeRestarts(cond)
[17:59:33.751]                         for (restart in restarts) {
[17:59:33.751]                           name <- restart$name
[17:59:33.751]                           if (is.null(name)) 
[17:59:33.751]                             next
[17:59:33.751]                           if (!grepl(pattern, name)) 
[17:59:33.751]                             next
[17:59:33.751]                           invokeRestart(restart)
[17:59:33.751]                           muffled <- TRUE
[17:59:33.751]                           break
[17:59:33.751]                         }
[17:59:33.751]                       }
[17:59:33.751]                     }
[17:59:33.751]                     invisible(muffled)
[17:59:33.751]                   }
[17:59:33.751]                   muffleCondition(cond)
[17:59:33.751]                 })
[17:59:33.751]             }))
[17:59:33.751]             future::FutureResult(value = ...future.value$value, 
[17:59:33.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.751]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.751]                     ...future.globalenv.names))
[17:59:33.751]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.751]         }, condition = base::local({
[17:59:33.751]             c <- base::c
[17:59:33.751]             inherits <- base::inherits
[17:59:33.751]             invokeRestart <- base::invokeRestart
[17:59:33.751]             length <- base::length
[17:59:33.751]             list <- base::list
[17:59:33.751]             seq.int <- base::seq.int
[17:59:33.751]             signalCondition <- base::signalCondition
[17:59:33.751]             sys.calls <- base::sys.calls
[17:59:33.751]             `[[` <- base::`[[`
[17:59:33.751]             `+` <- base::`+`
[17:59:33.751]             `<<-` <- base::`<<-`
[17:59:33.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.751]                   3L)]
[17:59:33.751]             }
[17:59:33.751]             function(cond) {
[17:59:33.751]                 is_error <- inherits(cond, "error")
[17:59:33.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.751]                   NULL)
[17:59:33.751]                 if (is_error) {
[17:59:33.751]                   sessionInformation <- function() {
[17:59:33.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.751]                       search = base::search(), system = base::Sys.info())
[17:59:33.751]                   }
[17:59:33.751]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.751]                     cond$call), session = sessionInformation(), 
[17:59:33.751]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.751]                   signalCondition(cond)
[17:59:33.751]                 }
[17:59:33.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.751]                 "immediateCondition"))) {
[17:59:33.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.751]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.751]                   if (TRUE && !signal) {
[17:59:33.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.751]                     {
[17:59:33.751]                       inherits <- base::inherits
[17:59:33.751]                       invokeRestart <- base::invokeRestart
[17:59:33.751]                       is.null <- base::is.null
[17:59:33.751]                       muffled <- FALSE
[17:59:33.751]                       if (inherits(cond, "message")) {
[17:59:33.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.751]                         if (muffled) 
[17:59:33.751]                           invokeRestart("muffleMessage")
[17:59:33.751]                       }
[17:59:33.751]                       else if (inherits(cond, "warning")) {
[17:59:33.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.751]                         if (muffled) 
[17:59:33.751]                           invokeRestart("muffleWarning")
[17:59:33.751]                       }
[17:59:33.751]                       else if (inherits(cond, "condition")) {
[17:59:33.751]                         if (!is.null(pattern)) {
[17:59:33.751]                           computeRestarts <- base::computeRestarts
[17:59:33.751]                           grepl <- base::grepl
[17:59:33.751]                           restarts <- computeRestarts(cond)
[17:59:33.751]                           for (restart in restarts) {
[17:59:33.751]                             name <- restart$name
[17:59:33.751]                             if (is.null(name)) 
[17:59:33.751]                               next
[17:59:33.751]                             if (!grepl(pattern, name)) 
[17:59:33.751]                               next
[17:59:33.751]                             invokeRestart(restart)
[17:59:33.751]                             muffled <- TRUE
[17:59:33.751]                             break
[17:59:33.751]                           }
[17:59:33.751]                         }
[17:59:33.751]                       }
[17:59:33.751]                       invisible(muffled)
[17:59:33.751]                     }
[17:59:33.751]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.751]                   }
[17:59:33.751]                 }
[17:59:33.751]                 else {
[17:59:33.751]                   if (TRUE) {
[17:59:33.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.751]                     {
[17:59:33.751]                       inherits <- base::inherits
[17:59:33.751]                       invokeRestart <- base::invokeRestart
[17:59:33.751]                       is.null <- base::is.null
[17:59:33.751]                       muffled <- FALSE
[17:59:33.751]                       if (inherits(cond, "message")) {
[17:59:33.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.751]                         if (muffled) 
[17:59:33.751]                           invokeRestart("muffleMessage")
[17:59:33.751]                       }
[17:59:33.751]                       else if (inherits(cond, "warning")) {
[17:59:33.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.751]                         if (muffled) 
[17:59:33.751]                           invokeRestart("muffleWarning")
[17:59:33.751]                       }
[17:59:33.751]                       else if (inherits(cond, "condition")) {
[17:59:33.751]                         if (!is.null(pattern)) {
[17:59:33.751]                           computeRestarts <- base::computeRestarts
[17:59:33.751]                           grepl <- base::grepl
[17:59:33.751]                           restarts <- computeRestarts(cond)
[17:59:33.751]                           for (restart in restarts) {
[17:59:33.751]                             name <- restart$name
[17:59:33.751]                             if (is.null(name)) 
[17:59:33.751]                               next
[17:59:33.751]                             if (!grepl(pattern, name)) 
[17:59:33.751]                               next
[17:59:33.751]                             invokeRestart(restart)
[17:59:33.751]                             muffled <- TRUE
[17:59:33.751]                             break
[17:59:33.751]                           }
[17:59:33.751]                         }
[17:59:33.751]                       }
[17:59:33.751]                       invisible(muffled)
[17:59:33.751]                     }
[17:59:33.751]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.751]                   }
[17:59:33.751]                 }
[17:59:33.751]             }
[17:59:33.751]         }))
[17:59:33.751]     }, error = function(ex) {
[17:59:33.751]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.751]                 ...future.rng), started = ...future.startTime, 
[17:59:33.751]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.751]             version = "1.8"), class = "FutureResult")
[17:59:33.751]     }, finally = {
[17:59:33.751]         if (!identical(...future.workdir, getwd())) 
[17:59:33.751]             setwd(...future.workdir)
[17:59:33.751]         {
[17:59:33.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.751]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.751]             }
[17:59:33.751]             base::options(...future.oldOptions)
[17:59:33.751]             if (.Platform$OS.type == "windows") {
[17:59:33.751]                 old_names <- names(...future.oldEnvVars)
[17:59:33.751]                 envs <- base::Sys.getenv()
[17:59:33.751]                 names <- names(envs)
[17:59:33.751]                 common <- intersect(names, old_names)
[17:59:33.751]                 added <- setdiff(names, old_names)
[17:59:33.751]                 removed <- setdiff(old_names, names)
[17:59:33.751]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.751]                   envs[common]]
[17:59:33.751]                 NAMES <- toupper(changed)
[17:59:33.751]                 args <- list()
[17:59:33.751]                 for (kk in seq_along(NAMES)) {
[17:59:33.751]                   name <- changed[[kk]]
[17:59:33.751]                   NAME <- NAMES[[kk]]
[17:59:33.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.751]                     next
[17:59:33.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.751]                 }
[17:59:33.751]                 NAMES <- toupper(added)
[17:59:33.751]                 for (kk in seq_along(NAMES)) {
[17:59:33.751]                   name <- added[[kk]]
[17:59:33.751]                   NAME <- NAMES[[kk]]
[17:59:33.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.751]                     next
[17:59:33.751]                   args[[name]] <- ""
[17:59:33.751]                 }
[17:59:33.751]                 NAMES <- toupper(removed)
[17:59:33.751]                 for (kk in seq_along(NAMES)) {
[17:59:33.751]                   name <- removed[[kk]]
[17:59:33.751]                   NAME <- NAMES[[kk]]
[17:59:33.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.751]                     next
[17:59:33.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.751]                 }
[17:59:33.751]                 if (length(args) > 0) 
[17:59:33.751]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.751]             }
[17:59:33.751]             else {
[17:59:33.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.751]             }
[17:59:33.751]             {
[17:59:33.751]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.751]                   0L) {
[17:59:33.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.751]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.751]                   base::options(opts)
[17:59:33.751]                 }
[17:59:33.751]                 {
[17:59:33.751]                   {
[17:59:33.751]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.751]                     NULL
[17:59:33.751]                   }
[17:59:33.751]                   options(future.plan = NULL)
[17:59:33.751]                   if (is.na(NA_character_)) 
[17:59:33.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.751]                     .init = FALSE)
[17:59:33.751]                 }
[17:59:33.751]             }
[17:59:33.751]         }
[17:59:33.751]     })
[17:59:33.751]     if (TRUE) {
[17:59:33.751]         base::sink(type = "output", split = FALSE)
[17:59:33.751]         if (TRUE) {
[17:59:33.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.751]         }
[17:59:33.751]         else {
[17:59:33.751]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.751]         }
[17:59:33.751]         base::close(...future.stdout)
[17:59:33.751]         ...future.stdout <- NULL
[17:59:33.751]     }
[17:59:33.751]     ...future.result$conditions <- ...future.conditions
[17:59:33.751]     ...future.result$finished <- base::Sys.time()
[17:59:33.751]     ...future.result
[17:59:33.751] }
[17:59:33.757] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:59:33.757] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:59:33.758] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:59:33.758] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:33.759] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.759] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:59:33.760] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:59:33.761] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:33.761] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.762] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:33.762] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.763] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:59:33.764] MultisessionFuture started
[17:59:33.764] - Launch lazy future ... done
[17:59:33.764] run() for ‘MultisessionFuture’ ... done
[17:59:33.764] Created future:
[17:59:33.765] MultisessionFuture:
[17:59:33.765] Label: ‘future_eapply-2’
[17:59:33.765] Expression:
[17:59:33.765] {
[17:59:33.765]     do.call(function(...) {
[17:59:33.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.765]             on.exit(options(oopts), add = TRUE)
[17:59:33.765]         }
[17:59:33.765]         {
[17:59:33.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.765]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.765]             })
[17:59:33.765]         }
[17:59:33.765]     }, args = future.call.arguments)
[17:59:33.765] }
[17:59:33.765] Lazy evaluation: FALSE
[17:59:33.765] Asynchronous evaluation: TRUE
[17:59:33.765] Local evaluation: TRUE
[17:59:33.765] Environment: R_GlobalEnv
[17:59:33.765] Capture standard output: TRUE
[17:59:33.765] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.765] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.765] Packages: 1 packages (‘stats’)
[17:59:33.765] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.765] Resolved: FALSE
[17:59:33.765] Value: <not collected>
[17:59:33.765] Conditions captured: <none>
[17:59:33.765] Early signaling: FALSE
[17:59:33.765] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.765] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.778] Chunk #2 of 2 ... DONE
[17:59:33.778] Launching 2 futures (chunks) ... DONE
[17:59:33.778] Resolving 2 futures (chunks) ...
[17:59:33.778] resolve() on list ...
[17:59:33.778]  recursive: 0
[17:59:33.779]  length: 2
[17:59:33.779] 
[17:59:33.780] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.780] - Validating connection of MultisessionFuture
[17:59:33.780] - received message: FutureResult
[17:59:33.781] - Received FutureResult
[17:59:33.781] - Erased future from FutureRegistry
[17:59:33.781] result() for ClusterFuture ...
[17:59:33.781] - result already collected: FutureResult
[17:59:33.781] result() for ClusterFuture ... done
[17:59:33.782] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.782] Future #1
[17:59:33.782] result() for ClusterFuture ...
[17:59:33.782] - result already collected: FutureResult
[17:59:33.782] result() for ClusterFuture ... done
[17:59:33.782] result() for ClusterFuture ...
[17:59:33.783] - result already collected: FutureResult
[17:59:33.783] result() for ClusterFuture ... done
[17:59:33.783] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:33.783] - nx: 2
[17:59:33.783] - relay: TRUE
[17:59:33.784] - stdout: TRUE
[17:59:33.784] - signal: TRUE
[17:59:33.784] - resignal: FALSE
[17:59:33.784] - force: TRUE
[17:59:33.784] - relayed: [n=2] FALSE, FALSE
[17:59:33.784] - queued futures: [n=2] FALSE, FALSE
[17:59:33.785]  - until=1
[17:59:33.785]  - relaying element #1
[17:59:33.785] result() for ClusterFuture ...
[17:59:33.785] - result already collected: FutureResult
[17:59:33.785] result() for ClusterFuture ... done
[17:59:33.786] result() for ClusterFuture ...
[17:59:33.786] - result already collected: FutureResult
[17:59:33.786] result() for ClusterFuture ... done
[17:59:33.786] result() for ClusterFuture ...
[17:59:33.786] - result already collected: FutureResult
[17:59:33.787] result() for ClusterFuture ... done
[17:59:33.787] result() for ClusterFuture ...
[17:59:33.787] - result already collected: FutureResult
[17:59:33.787] result() for ClusterFuture ... done
[17:59:33.787] - relayed: [n=2] TRUE, FALSE
[17:59:33.787] - queued futures: [n=2] TRUE, FALSE
[17:59:33.788] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:33.788]  length: 1 (resolved future 1)
[17:59:33.810] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.811] - Validating connection of MultisessionFuture
[17:59:33.811] - received message: FutureResult
[17:59:33.811] - Received FutureResult
[17:59:33.812] - Erased future from FutureRegistry
[17:59:33.812] result() for ClusterFuture ...
[17:59:33.812] - result already collected: FutureResult
[17:59:33.812] result() for ClusterFuture ... done
[17:59:33.812] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.813] Future #2
[17:59:33.813] result() for ClusterFuture ...
[17:59:33.813] - result already collected: FutureResult
[17:59:33.813] result() for ClusterFuture ... done
[17:59:33.813] result() for ClusterFuture ...
[17:59:33.813] - result already collected: FutureResult
[17:59:33.814] result() for ClusterFuture ... done
[17:59:33.814] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:33.814] - nx: 2
[17:59:33.814] - relay: TRUE
[17:59:33.814] - stdout: TRUE
[17:59:33.815] - signal: TRUE
[17:59:33.815] - resignal: FALSE
[17:59:33.815] - force: TRUE
[17:59:33.815] - relayed: [n=2] TRUE, FALSE
[17:59:33.815] - queued futures: [n=2] TRUE, FALSE
[17:59:33.816]  - until=2
[17:59:33.816]  - relaying element #2
[17:59:33.816] result() for ClusterFuture ...
[17:59:33.816] - result already collected: FutureResult
[17:59:33.816] result() for ClusterFuture ... done
[17:59:33.816] result() for ClusterFuture ...
[17:59:33.817] - result already collected: FutureResult
[17:59:33.817] result() for ClusterFuture ... done
[17:59:33.817] result() for ClusterFuture ...
[17:59:33.817] - result already collected: FutureResult
[17:59:33.817] result() for ClusterFuture ... done
[17:59:33.818] result() for ClusterFuture ...
[17:59:33.818] - result already collected: FutureResult
[17:59:33.818] result() for ClusterFuture ... done
[17:59:33.818] - relayed: [n=2] TRUE, TRUE
[17:59:33.818] - queued futures: [n=2] TRUE, TRUE
[17:59:33.819] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:33.819]  length: 0 (resolved future 2)
[17:59:33.819] Relaying remaining futures
[17:59:33.819] signalConditionsASAP(NULL, pos=0) ...
[17:59:33.819] - nx: 2
[17:59:33.819] - relay: TRUE
[17:59:33.820] - stdout: TRUE
[17:59:33.820] - signal: TRUE
[17:59:33.820] - resignal: FALSE
[17:59:33.820] - force: TRUE
[17:59:33.820] - relayed: [n=2] TRUE, TRUE
[17:59:33.820] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:33.821] - relayed: [n=2] TRUE, TRUE
[17:59:33.821] - queued futures: [n=2] TRUE, TRUE
[17:59:33.821] signalConditionsASAP(NULL, pos=0) ... done
[17:59:33.821] resolve() on list ... DONE
[17:59:33.822] result() for ClusterFuture ...
[17:59:33.822] - result already collected: FutureResult
[17:59:33.822] result() for ClusterFuture ... done
[17:59:33.822] result() for ClusterFuture ...
[17:59:33.822] - result already collected: FutureResult
[17:59:33.822] result() for ClusterFuture ... done
[17:59:33.823] result() for ClusterFuture ...
[17:59:33.823] - result already collected: FutureResult
[17:59:33.823] result() for ClusterFuture ... done
[17:59:33.823] result() for ClusterFuture ...
[17:59:33.823] - result already collected: FutureResult
[17:59:33.824] result() for ClusterFuture ... done
[17:59:33.824]  - Number of value chunks collected: 2
[17:59:33.824] Resolving 2 futures (chunks) ... DONE
[17:59:33.824] Reducing values from 2 chunks ...
[17:59:33.824]  - Number of values collected after concatenation: 3
[17:59:33.825]  - Number of values expected: 3
[17:59:33.825] Reducing values from 2 chunks ... DONE
[17:59:33.825] future_lapply() ... DONE
[17:59:33.825] future_lapply() ...
[17:59:33.832] Number of chunks: 2
[17:59:33.833] getGlobalsAndPackagesXApply() ...
[17:59:33.833]  - future.globals: TRUE
[17:59:33.833] getGlobalsAndPackages() ...
[17:59:33.833] Searching for globals...
[17:59:33.835] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:33.836] Searching for globals ... DONE
[17:59:33.836] Resolving globals: FALSE
[17:59:33.836] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:59:33.837] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:59:33.837] - globals: [1] ‘FUN’
[17:59:33.838] - packages: [1] ‘stats’
[17:59:33.838] getGlobalsAndPackages() ... DONE
[17:59:33.838]  - globals found/used: [n=1] ‘FUN’
[17:59:33.838]  - needed namespaces: [n=1] ‘stats’
[17:59:33.838] Finding globals ... DONE
[17:59:33.839]  - use_args: TRUE
[17:59:33.839]  - Getting '...' globals ...
[17:59:33.839] resolve() on list ...
[17:59:33.840]  recursive: 0
[17:59:33.840]  length: 1
[17:59:33.840]  elements: ‘...’
[17:59:33.840]  length: 0 (resolved future 1)
[17:59:33.840] resolve() on list ... DONE
[17:59:33.841]    - '...' content: [n=0] 
[17:59:33.841] List of 1
[17:59:33.841]  $ ...: list()
[17:59:33.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.841]  - attr(*, "where")=List of 1
[17:59:33.841]   ..$ ...:<environment: 0x58d4c5e044b0> 
[17:59:33.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.841]  - attr(*, "resolved")= logi TRUE
[17:59:33.841]  - attr(*, "total_size")= num NA
[17:59:33.846]  - Getting '...' globals ... DONE
[17:59:33.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:33.847] List of 2
[17:59:33.847]  $ ...future.FUN:function (x, ...)  
[17:59:33.847]  $ ...          : list()
[17:59:33.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:33.847]  - attr(*, "where")=List of 2
[17:59:33.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:33.847]   ..$ ...          :<environment: 0x58d4c5e044b0> 
[17:59:33.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:33.847]  - attr(*, "resolved")= logi FALSE
[17:59:33.847]  - attr(*, "total_size")= num 1248
[17:59:33.853] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:33.853] getGlobalsAndPackagesXApply() ... DONE
[17:59:33.854] Number of futures (= number of chunks): 2
[17:59:33.854] Launching 2 futures (chunks) ...
[17:59:33.854] Chunk #1 of 2 ...
[17:59:33.855]  - Finding globals in 'X' for chunk #1 ...
[17:59:33.855] getGlobalsAndPackages() ...
[17:59:33.855] Searching for globals...
[17:59:33.856] 
[17:59:33.856] Searching for globals ... DONE
[17:59:33.856] - globals: [0] <none>
[17:59:33.856] getGlobalsAndPackages() ... DONE
[17:59:33.856]    + additional globals found: [n=0] 
[17:59:33.857]    + additional namespaces needed: [n=0] 
[17:59:33.857]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:33.857]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.857]  - seeds: <none>
[17:59:33.857]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.858] getGlobalsAndPackages() ...
[17:59:33.858] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.858] Resolving globals: FALSE
[17:59:33.858] Tweak future expression to call with '...' arguments ...
[17:59:33.858] {
[17:59:33.858]     do.call(function(...) {
[17:59:33.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.858]             on.exit(options(oopts), add = TRUE)
[17:59:33.858]         }
[17:59:33.858]         {
[17:59:33.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.858]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.858]             })
[17:59:33.858]         }
[17:59:33.858]     }, args = future.call.arguments)
[17:59:33.858] }
[17:59:33.859] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.860] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.860] - packages: [1] ‘stats’
[17:59:33.861] getGlobalsAndPackages() ... DONE
[17:59:33.861] run() for ‘Future’ ...
[17:59:33.861] - state: ‘created’
[17:59:33.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.886]   - Field: ‘node’
[17:59:33.887]   - Field: ‘label’
[17:59:33.887]   - Field: ‘local’
[17:59:33.887]   - Field: ‘owner’
[17:59:33.887]   - Field: ‘envir’
[17:59:33.887]   - Field: ‘workers’
[17:59:33.888]   - Field: ‘packages’
[17:59:33.888]   - Field: ‘gc’
[17:59:33.888]   - Field: ‘conditions’
[17:59:33.888]   - Field: ‘persistent’
[17:59:33.888]   - Field: ‘expr’
[17:59:33.889]   - Field: ‘uuid’
[17:59:33.889]   - Field: ‘seed’
[17:59:33.889]   - Field: ‘version’
[17:59:33.889]   - Field: ‘result’
[17:59:33.889]   - Field: ‘asynchronous’
[17:59:33.890]   - Field: ‘calls’
[17:59:33.890]   - Field: ‘globals’
[17:59:33.890]   - Field: ‘stdout’
[17:59:33.890]   - Field: ‘earlySignal’
[17:59:33.890]   - Field: ‘lazy’
[17:59:33.891]   - Field: ‘state’
[17:59:33.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.891] - Launch lazy future ...
[17:59:33.892] Packages needed by the future expression (n = 1): ‘stats’
[17:59:33.892] Packages needed by future strategies (n = 0): <none>
[17:59:33.893] {
[17:59:33.893]     {
[17:59:33.893]         {
[17:59:33.893]             ...future.startTime <- base::Sys.time()
[17:59:33.893]             {
[17:59:33.893]                 {
[17:59:33.893]                   {
[17:59:33.893]                     {
[17:59:33.893]                       {
[17:59:33.893]                         base::local({
[17:59:33.893]                           has_future <- base::requireNamespace("future", 
[17:59:33.893]                             quietly = TRUE)
[17:59:33.893]                           if (has_future) {
[17:59:33.893]                             ns <- base::getNamespace("future")
[17:59:33.893]                             version <- ns[[".package"]][["version"]]
[17:59:33.893]                             if (is.null(version)) 
[17:59:33.893]                               version <- utils::packageVersion("future")
[17:59:33.893]                           }
[17:59:33.893]                           else {
[17:59:33.893]                             version <- NULL
[17:59:33.893]                           }
[17:59:33.893]                           if (!has_future || version < "1.8.0") {
[17:59:33.893]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.893]                               "", base::R.version$version.string), 
[17:59:33.893]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:33.893]                                 base::R.version$platform, 8 * 
[17:59:33.893]                                   base::.Machine$sizeof.pointer), 
[17:59:33.893]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.893]                                 "release", "version")], collapse = " "), 
[17:59:33.893]                               hostname = base::Sys.info()[["nodename"]])
[17:59:33.893]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.893]                               info)
[17:59:33.893]                             info <- base::paste(info, collapse = "; ")
[17:59:33.893]                             if (!has_future) {
[17:59:33.893]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.893]                                 info)
[17:59:33.893]                             }
[17:59:33.893]                             else {
[17:59:33.893]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.893]                                 info, version)
[17:59:33.893]                             }
[17:59:33.893]                             base::stop(msg)
[17:59:33.893]                           }
[17:59:33.893]                         })
[17:59:33.893]                       }
[17:59:33.893]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.893]                       base::options(mc.cores = 1L)
[17:59:33.893]                     }
[17:59:33.893]                     base::local({
[17:59:33.893]                       for (pkg in "stats") {
[17:59:33.893]                         base::loadNamespace(pkg)
[17:59:33.893]                         base::library(pkg, character.only = TRUE)
[17:59:33.893]                       }
[17:59:33.893]                     })
[17:59:33.893]                   }
[17:59:33.893]                   ...future.strategy.old <- future::plan("list")
[17:59:33.893]                   options(future.plan = NULL)
[17:59:33.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.893]                 }
[17:59:33.893]                 ...future.workdir <- getwd()
[17:59:33.893]             }
[17:59:33.893]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.893]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.893]         }
[17:59:33.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.893]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.893]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.893]             base::names(...future.oldOptions))
[17:59:33.893]     }
[17:59:33.893]     if (FALSE) {
[17:59:33.893]     }
[17:59:33.893]     else {
[17:59:33.893]         if (TRUE) {
[17:59:33.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.893]                 open = "w")
[17:59:33.893]         }
[17:59:33.893]         else {
[17:59:33.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.893]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.893]         }
[17:59:33.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.893]             base::sink(type = "output", split = FALSE)
[17:59:33.893]             base::close(...future.stdout)
[17:59:33.893]         }, add = TRUE)
[17:59:33.893]     }
[17:59:33.893]     ...future.frame <- base::sys.nframe()
[17:59:33.893]     ...future.conditions <- base::list()
[17:59:33.893]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.893]     if (FALSE) {
[17:59:33.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.893]     }
[17:59:33.893]     ...future.result <- base::tryCatch({
[17:59:33.893]         base::withCallingHandlers({
[17:59:33.893]             ...future.value <- base::withVisible(base::local({
[17:59:33.893]                 ...future.makeSendCondition <- base::local({
[17:59:33.893]                   sendCondition <- NULL
[17:59:33.893]                   function(frame = 1L) {
[17:59:33.893]                     if (is.function(sendCondition)) 
[17:59:33.893]                       return(sendCondition)
[17:59:33.893]                     ns <- getNamespace("parallel")
[17:59:33.893]                     if (exists("sendData", mode = "function", 
[17:59:33.893]                       envir = ns)) {
[17:59:33.893]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.893]                         envir = ns)
[17:59:33.893]                       envir <- sys.frame(frame)
[17:59:33.893]                       master <- NULL
[17:59:33.893]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.893]                         !identical(envir, emptyenv())) {
[17:59:33.893]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.893]                           inherits = FALSE)) {
[17:59:33.893]                           master <- get("master", mode = "list", 
[17:59:33.893]                             envir = envir, inherits = FALSE)
[17:59:33.893]                           if (inherits(master, c("SOCKnode", 
[17:59:33.893]                             "SOCK0node"))) {
[17:59:33.893]                             sendCondition <<- function(cond) {
[17:59:33.893]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.893]                                 success = TRUE)
[17:59:33.893]                               parallel_sendData(master, data)
[17:59:33.893]                             }
[17:59:33.893]                             return(sendCondition)
[17:59:33.893]                           }
[17:59:33.893]                         }
[17:59:33.893]                         frame <- frame + 1L
[17:59:33.893]                         envir <- sys.frame(frame)
[17:59:33.893]                       }
[17:59:33.893]                     }
[17:59:33.893]                     sendCondition <<- function(cond) NULL
[17:59:33.893]                   }
[17:59:33.893]                 })
[17:59:33.893]                 withCallingHandlers({
[17:59:33.893]                   {
[17:59:33.893]                     do.call(function(...) {
[17:59:33.893]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.893]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.893]                         ...future.globals.maxSize)) {
[17:59:33.893]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.893]                         on.exit(options(oopts), add = TRUE)
[17:59:33.893]                       }
[17:59:33.893]                       {
[17:59:33.893]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.893]                           FUN = function(jj) {
[17:59:33.893]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.893]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.893]                           })
[17:59:33.893]                       }
[17:59:33.893]                     }, args = future.call.arguments)
[17:59:33.893]                   }
[17:59:33.893]                 }, immediateCondition = function(cond) {
[17:59:33.893]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.893]                   sendCondition(cond)
[17:59:33.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.893]                   {
[17:59:33.893]                     inherits <- base::inherits
[17:59:33.893]                     invokeRestart <- base::invokeRestart
[17:59:33.893]                     is.null <- base::is.null
[17:59:33.893]                     muffled <- FALSE
[17:59:33.893]                     if (inherits(cond, "message")) {
[17:59:33.893]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.893]                       if (muffled) 
[17:59:33.893]                         invokeRestart("muffleMessage")
[17:59:33.893]                     }
[17:59:33.893]                     else if (inherits(cond, "warning")) {
[17:59:33.893]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.893]                       if (muffled) 
[17:59:33.893]                         invokeRestart("muffleWarning")
[17:59:33.893]                     }
[17:59:33.893]                     else if (inherits(cond, "condition")) {
[17:59:33.893]                       if (!is.null(pattern)) {
[17:59:33.893]                         computeRestarts <- base::computeRestarts
[17:59:33.893]                         grepl <- base::grepl
[17:59:33.893]                         restarts <- computeRestarts(cond)
[17:59:33.893]                         for (restart in restarts) {
[17:59:33.893]                           name <- restart$name
[17:59:33.893]                           if (is.null(name)) 
[17:59:33.893]                             next
[17:59:33.893]                           if (!grepl(pattern, name)) 
[17:59:33.893]                             next
[17:59:33.893]                           invokeRestart(restart)
[17:59:33.893]                           muffled <- TRUE
[17:59:33.893]                           break
[17:59:33.893]                         }
[17:59:33.893]                       }
[17:59:33.893]                     }
[17:59:33.893]                     invisible(muffled)
[17:59:33.893]                   }
[17:59:33.893]                   muffleCondition(cond)
[17:59:33.893]                 })
[17:59:33.893]             }))
[17:59:33.893]             future::FutureResult(value = ...future.value$value, 
[17:59:33.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.893]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.893]                     ...future.globalenv.names))
[17:59:33.893]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.893]         }, condition = base::local({
[17:59:33.893]             c <- base::c
[17:59:33.893]             inherits <- base::inherits
[17:59:33.893]             invokeRestart <- base::invokeRestart
[17:59:33.893]             length <- base::length
[17:59:33.893]             list <- base::list
[17:59:33.893]             seq.int <- base::seq.int
[17:59:33.893]             signalCondition <- base::signalCondition
[17:59:33.893]             sys.calls <- base::sys.calls
[17:59:33.893]             `[[` <- base::`[[`
[17:59:33.893]             `+` <- base::`+`
[17:59:33.893]             `<<-` <- base::`<<-`
[17:59:33.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.893]                   3L)]
[17:59:33.893]             }
[17:59:33.893]             function(cond) {
[17:59:33.893]                 is_error <- inherits(cond, "error")
[17:59:33.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.893]                   NULL)
[17:59:33.893]                 if (is_error) {
[17:59:33.893]                   sessionInformation <- function() {
[17:59:33.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.893]                       search = base::search(), system = base::Sys.info())
[17:59:33.893]                   }
[17:59:33.893]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.893]                     cond$call), session = sessionInformation(), 
[17:59:33.893]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.893]                   signalCondition(cond)
[17:59:33.893]                 }
[17:59:33.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.893]                 "immediateCondition"))) {
[17:59:33.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.893]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.893]                   if (TRUE && !signal) {
[17:59:33.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.893]                     {
[17:59:33.893]                       inherits <- base::inherits
[17:59:33.893]                       invokeRestart <- base::invokeRestart
[17:59:33.893]                       is.null <- base::is.null
[17:59:33.893]                       muffled <- FALSE
[17:59:33.893]                       if (inherits(cond, "message")) {
[17:59:33.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.893]                         if (muffled) 
[17:59:33.893]                           invokeRestart("muffleMessage")
[17:59:33.893]                       }
[17:59:33.893]                       else if (inherits(cond, "warning")) {
[17:59:33.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.893]                         if (muffled) 
[17:59:33.893]                           invokeRestart("muffleWarning")
[17:59:33.893]                       }
[17:59:33.893]                       else if (inherits(cond, "condition")) {
[17:59:33.893]                         if (!is.null(pattern)) {
[17:59:33.893]                           computeRestarts <- base::computeRestarts
[17:59:33.893]                           grepl <- base::grepl
[17:59:33.893]                           restarts <- computeRestarts(cond)
[17:59:33.893]                           for (restart in restarts) {
[17:59:33.893]                             name <- restart$name
[17:59:33.893]                             if (is.null(name)) 
[17:59:33.893]                               next
[17:59:33.893]                             if (!grepl(pattern, name)) 
[17:59:33.893]                               next
[17:59:33.893]                             invokeRestart(restart)
[17:59:33.893]                             muffled <- TRUE
[17:59:33.893]                             break
[17:59:33.893]                           }
[17:59:33.893]                         }
[17:59:33.893]                       }
[17:59:33.893]                       invisible(muffled)
[17:59:33.893]                     }
[17:59:33.893]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.893]                   }
[17:59:33.893]                 }
[17:59:33.893]                 else {
[17:59:33.893]                   if (TRUE) {
[17:59:33.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.893]                     {
[17:59:33.893]                       inherits <- base::inherits
[17:59:33.893]                       invokeRestart <- base::invokeRestart
[17:59:33.893]                       is.null <- base::is.null
[17:59:33.893]                       muffled <- FALSE
[17:59:33.893]                       if (inherits(cond, "message")) {
[17:59:33.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.893]                         if (muffled) 
[17:59:33.893]                           invokeRestart("muffleMessage")
[17:59:33.893]                       }
[17:59:33.893]                       else if (inherits(cond, "warning")) {
[17:59:33.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.893]                         if (muffled) 
[17:59:33.893]                           invokeRestart("muffleWarning")
[17:59:33.893]                       }
[17:59:33.893]                       else if (inherits(cond, "condition")) {
[17:59:33.893]                         if (!is.null(pattern)) {
[17:59:33.893]                           computeRestarts <- base::computeRestarts
[17:59:33.893]                           grepl <- base::grepl
[17:59:33.893]                           restarts <- computeRestarts(cond)
[17:59:33.893]                           for (restart in restarts) {
[17:59:33.893]                             name <- restart$name
[17:59:33.893]                             if (is.null(name)) 
[17:59:33.893]                               next
[17:59:33.893]                             if (!grepl(pattern, name)) 
[17:59:33.893]                               next
[17:59:33.893]                             invokeRestart(restart)
[17:59:33.893]                             muffled <- TRUE
[17:59:33.893]                             break
[17:59:33.893]                           }
[17:59:33.893]                         }
[17:59:33.893]                       }
[17:59:33.893]                       invisible(muffled)
[17:59:33.893]                     }
[17:59:33.893]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.893]                   }
[17:59:33.893]                 }
[17:59:33.893]             }
[17:59:33.893]         }))
[17:59:33.893]     }, error = function(ex) {
[17:59:33.893]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.893]                 ...future.rng), started = ...future.startTime, 
[17:59:33.893]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.893]             version = "1.8"), class = "FutureResult")
[17:59:33.893]     }, finally = {
[17:59:33.893]         if (!identical(...future.workdir, getwd())) 
[17:59:33.893]             setwd(...future.workdir)
[17:59:33.893]         {
[17:59:33.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.893]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.893]             }
[17:59:33.893]             base::options(...future.oldOptions)
[17:59:33.893]             if (.Platform$OS.type == "windows") {
[17:59:33.893]                 old_names <- names(...future.oldEnvVars)
[17:59:33.893]                 envs <- base::Sys.getenv()
[17:59:33.893]                 names <- names(envs)
[17:59:33.893]                 common <- intersect(names, old_names)
[17:59:33.893]                 added <- setdiff(names, old_names)
[17:59:33.893]                 removed <- setdiff(old_names, names)
[17:59:33.893]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.893]                   envs[common]]
[17:59:33.893]                 NAMES <- toupper(changed)
[17:59:33.893]                 args <- list()
[17:59:33.893]                 for (kk in seq_along(NAMES)) {
[17:59:33.893]                   name <- changed[[kk]]
[17:59:33.893]                   NAME <- NAMES[[kk]]
[17:59:33.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.893]                     next
[17:59:33.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.893]                 }
[17:59:33.893]                 NAMES <- toupper(added)
[17:59:33.893]                 for (kk in seq_along(NAMES)) {
[17:59:33.893]                   name <- added[[kk]]
[17:59:33.893]                   NAME <- NAMES[[kk]]
[17:59:33.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.893]                     next
[17:59:33.893]                   args[[name]] <- ""
[17:59:33.893]                 }
[17:59:33.893]                 NAMES <- toupper(removed)
[17:59:33.893]                 for (kk in seq_along(NAMES)) {
[17:59:33.893]                   name <- removed[[kk]]
[17:59:33.893]                   NAME <- NAMES[[kk]]
[17:59:33.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.893]                     next
[17:59:33.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.893]                 }
[17:59:33.893]                 if (length(args) > 0) 
[17:59:33.893]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.893]             }
[17:59:33.893]             else {
[17:59:33.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.893]             }
[17:59:33.893]             {
[17:59:33.893]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.893]                   0L) {
[17:59:33.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.893]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.893]                   base::options(opts)
[17:59:33.893]                 }
[17:59:33.893]                 {
[17:59:33.893]                   {
[17:59:33.893]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.893]                     NULL
[17:59:33.893]                   }
[17:59:33.893]                   options(future.plan = NULL)
[17:59:33.893]                   if (is.na(NA_character_)) 
[17:59:33.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.893]                     .init = FALSE)
[17:59:33.893]                 }
[17:59:33.893]             }
[17:59:33.893]         }
[17:59:33.893]     })
[17:59:33.893]     if (TRUE) {
[17:59:33.893]         base::sink(type = "output", split = FALSE)
[17:59:33.893]         if (TRUE) {
[17:59:33.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.893]         }
[17:59:33.893]         else {
[17:59:33.893]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.893]         }
[17:59:33.893]         base::close(...future.stdout)
[17:59:33.893]         ...future.stdout <- NULL
[17:59:33.893]     }
[17:59:33.893]     ...future.result$conditions <- ...future.conditions
[17:59:33.893]     ...future.result$finished <- base::Sys.time()
[17:59:33.893]     ...future.result
[17:59:33.893] }
[17:59:33.898] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:59:33.899] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:59:33.899] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:59:33.900] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:33.901] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.901] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:59:33.902] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:59:33.902] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:33.903] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.903] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:33.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:33.904] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:59:33.905] MultisessionFuture started
[17:59:33.906] - Launch lazy future ... done
[17:59:33.906] run() for ‘MultisessionFuture’ ... done
[17:59:33.906] Created future:
[17:59:33.906] MultisessionFuture:
[17:59:33.906] Label: ‘future_eapply-1’
[17:59:33.906] Expression:
[17:59:33.906] {
[17:59:33.906]     do.call(function(...) {
[17:59:33.906]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.906]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.906]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.906]             on.exit(options(oopts), add = TRUE)
[17:59:33.906]         }
[17:59:33.906]         {
[17:59:33.906]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.906]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.906]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.906]             })
[17:59:33.906]         }
[17:59:33.906]     }, args = future.call.arguments)
[17:59:33.906] }
[17:59:33.906] Lazy evaluation: FALSE
[17:59:33.906] Asynchronous evaluation: TRUE
[17:59:33.906] Local evaluation: TRUE
[17:59:33.906] Environment: R_GlobalEnv
[17:59:33.906] Capture standard output: TRUE
[17:59:33.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.906] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.906] Packages: 1 packages (‘stats’)
[17:59:33.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.906] Resolved: FALSE
[17:59:33.906] Value: <not collected>
[17:59:33.906] Conditions captured: <none>
[17:59:33.906] Early signaling: FALSE
[17:59:33.906] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.906] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.919] Chunk #1 of 2 ... DONE
[17:59:33.920] Chunk #2 of 2 ...
[17:59:33.920]  - Finding globals in 'X' for chunk #2 ...
[17:59:33.920] getGlobalsAndPackages() ...
[17:59:33.920] Searching for globals...
[17:59:33.921] 
[17:59:33.921] Searching for globals ... DONE
[17:59:33.921] - globals: [0] <none>
[17:59:33.922] getGlobalsAndPackages() ... DONE
[17:59:33.922]    + additional globals found: [n=0] 
[17:59:33.922]    + additional namespaces needed: [n=0] 
[17:59:33.922]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:33.922]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:33.923]  - seeds: <none>
[17:59:33.923]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.923] getGlobalsAndPackages() ...
[17:59:33.923] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.923] Resolving globals: FALSE
[17:59:33.924] Tweak future expression to call with '...' arguments ...
[17:59:33.924] {
[17:59:33.924]     do.call(function(...) {
[17:59:33.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.924]             on.exit(options(oopts), add = TRUE)
[17:59:33.924]         }
[17:59:33.924]         {
[17:59:33.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.924]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.924]             })
[17:59:33.924]         }
[17:59:33.924]     }, args = future.call.arguments)
[17:59:33.924] }
[17:59:33.925] Tweak future expression to call with '...' arguments ... DONE
[17:59:33.925] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:33.926] - packages: [1] ‘stats’
[17:59:33.926] getGlobalsAndPackages() ... DONE
[17:59:33.926] run() for ‘Future’ ...
[17:59:33.927] - state: ‘created’
[17:59:33.927] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:33.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:33.955]   - Field: ‘node’
[17:59:33.955]   - Field: ‘label’
[17:59:33.955]   - Field: ‘local’
[17:59:33.956]   - Field: ‘owner’
[17:59:33.956]   - Field: ‘envir’
[17:59:33.956]   - Field: ‘workers’
[17:59:33.956]   - Field: ‘packages’
[17:59:33.956]   - Field: ‘gc’
[17:59:33.957]   - Field: ‘conditions’
[17:59:33.957]   - Field: ‘persistent’
[17:59:33.957]   - Field: ‘expr’
[17:59:33.957]   - Field: ‘uuid’
[17:59:33.957]   - Field: ‘seed’
[17:59:33.958]   - Field: ‘version’
[17:59:33.958]   - Field: ‘result’
[17:59:33.958]   - Field: ‘asynchronous’
[17:59:33.958]   - Field: ‘calls’
[17:59:33.958]   - Field: ‘globals’
[17:59:33.958]   - Field: ‘stdout’
[17:59:33.959]   - Field: ‘earlySignal’
[17:59:33.959]   - Field: ‘lazy’
[17:59:33.959]   - Field: ‘state’
[17:59:33.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:33.959] - Launch lazy future ...
[17:59:33.960] Packages needed by the future expression (n = 1): ‘stats’
[17:59:33.960] Packages needed by future strategies (n = 0): <none>
[17:59:33.961] {
[17:59:33.961]     {
[17:59:33.961]         {
[17:59:33.961]             ...future.startTime <- base::Sys.time()
[17:59:33.961]             {
[17:59:33.961]                 {
[17:59:33.961]                   {
[17:59:33.961]                     {
[17:59:33.961]                       {
[17:59:33.961]                         base::local({
[17:59:33.961]                           has_future <- base::requireNamespace("future", 
[17:59:33.961]                             quietly = TRUE)
[17:59:33.961]                           if (has_future) {
[17:59:33.961]                             ns <- base::getNamespace("future")
[17:59:33.961]                             version <- ns[[".package"]][["version"]]
[17:59:33.961]                             if (is.null(version)) 
[17:59:33.961]                               version <- utils::packageVersion("future")
[17:59:33.961]                           }
[17:59:33.961]                           else {
[17:59:33.961]                             version <- NULL
[17:59:33.961]                           }
[17:59:33.961]                           if (!has_future || version < "1.8.0") {
[17:59:33.961]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:33.961]                               "", base::R.version$version.string), 
[17:59:33.961]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:33.961]                                 base::R.version$platform, 8 * 
[17:59:33.961]                                   base::.Machine$sizeof.pointer), 
[17:59:33.961]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:33.961]                                 "release", "version")], collapse = " "), 
[17:59:33.961]                               hostname = base::Sys.info()[["nodename"]])
[17:59:33.961]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:33.961]                               info)
[17:59:33.961]                             info <- base::paste(info, collapse = "; ")
[17:59:33.961]                             if (!has_future) {
[17:59:33.961]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:33.961]                                 info)
[17:59:33.961]                             }
[17:59:33.961]                             else {
[17:59:33.961]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:33.961]                                 info, version)
[17:59:33.961]                             }
[17:59:33.961]                             base::stop(msg)
[17:59:33.961]                           }
[17:59:33.961]                         })
[17:59:33.961]                       }
[17:59:33.961]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:33.961]                       base::options(mc.cores = 1L)
[17:59:33.961]                     }
[17:59:33.961]                     base::local({
[17:59:33.961]                       for (pkg in "stats") {
[17:59:33.961]                         base::loadNamespace(pkg)
[17:59:33.961]                         base::library(pkg, character.only = TRUE)
[17:59:33.961]                       }
[17:59:33.961]                     })
[17:59:33.961]                   }
[17:59:33.961]                   ...future.strategy.old <- future::plan("list")
[17:59:33.961]                   options(future.plan = NULL)
[17:59:33.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:33.961]                 }
[17:59:33.961]                 ...future.workdir <- getwd()
[17:59:33.961]             }
[17:59:33.961]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:33.961]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:33.961]         }
[17:59:33.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:33.961]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:33.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:33.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:33.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:33.961]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:33.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:33.961]             base::names(...future.oldOptions))
[17:59:33.961]     }
[17:59:33.961]     if (FALSE) {
[17:59:33.961]     }
[17:59:33.961]     else {
[17:59:33.961]         if (TRUE) {
[17:59:33.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:33.961]                 open = "w")
[17:59:33.961]         }
[17:59:33.961]         else {
[17:59:33.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:33.961]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:33.961]         }
[17:59:33.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:33.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:33.961]             base::sink(type = "output", split = FALSE)
[17:59:33.961]             base::close(...future.stdout)
[17:59:33.961]         }, add = TRUE)
[17:59:33.961]     }
[17:59:33.961]     ...future.frame <- base::sys.nframe()
[17:59:33.961]     ...future.conditions <- base::list()
[17:59:33.961]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:33.961]     if (FALSE) {
[17:59:33.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:33.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:33.961]     }
[17:59:33.961]     ...future.result <- base::tryCatch({
[17:59:33.961]         base::withCallingHandlers({
[17:59:33.961]             ...future.value <- base::withVisible(base::local({
[17:59:33.961]                 ...future.makeSendCondition <- base::local({
[17:59:33.961]                   sendCondition <- NULL
[17:59:33.961]                   function(frame = 1L) {
[17:59:33.961]                     if (is.function(sendCondition)) 
[17:59:33.961]                       return(sendCondition)
[17:59:33.961]                     ns <- getNamespace("parallel")
[17:59:33.961]                     if (exists("sendData", mode = "function", 
[17:59:33.961]                       envir = ns)) {
[17:59:33.961]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:33.961]                         envir = ns)
[17:59:33.961]                       envir <- sys.frame(frame)
[17:59:33.961]                       master <- NULL
[17:59:33.961]                       while (!identical(envir, .GlobalEnv) && 
[17:59:33.961]                         !identical(envir, emptyenv())) {
[17:59:33.961]                         if (exists("master", mode = "list", envir = envir, 
[17:59:33.961]                           inherits = FALSE)) {
[17:59:33.961]                           master <- get("master", mode = "list", 
[17:59:33.961]                             envir = envir, inherits = FALSE)
[17:59:33.961]                           if (inherits(master, c("SOCKnode", 
[17:59:33.961]                             "SOCK0node"))) {
[17:59:33.961]                             sendCondition <<- function(cond) {
[17:59:33.961]                               data <- list(type = "VALUE", value = cond, 
[17:59:33.961]                                 success = TRUE)
[17:59:33.961]                               parallel_sendData(master, data)
[17:59:33.961]                             }
[17:59:33.961]                             return(sendCondition)
[17:59:33.961]                           }
[17:59:33.961]                         }
[17:59:33.961]                         frame <- frame + 1L
[17:59:33.961]                         envir <- sys.frame(frame)
[17:59:33.961]                       }
[17:59:33.961]                     }
[17:59:33.961]                     sendCondition <<- function(cond) NULL
[17:59:33.961]                   }
[17:59:33.961]                 })
[17:59:33.961]                 withCallingHandlers({
[17:59:33.961]                   {
[17:59:33.961]                     do.call(function(...) {
[17:59:33.961]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.961]                       if (!identical(...future.globals.maxSize.org, 
[17:59:33.961]                         ...future.globals.maxSize)) {
[17:59:33.961]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.961]                         on.exit(options(oopts), add = TRUE)
[17:59:33.961]                       }
[17:59:33.961]                       {
[17:59:33.961]                         lapply(seq_along(...future.elements_ii), 
[17:59:33.961]                           FUN = function(jj) {
[17:59:33.961]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.961]                             ...future.FUN(...future.X_jj, ...)
[17:59:33.961]                           })
[17:59:33.961]                       }
[17:59:33.961]                     }, args = future.call.arguments)
[17:59:33.961]                   }
[17:59:33.961]                 }, immediateCondition = function(cond) {
[17:59:33.961]                   sendCondition <- ...future.makeSendCondition()
[17:59:33.961]                   sendCondition(cond)
[17:59:33.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.961]                   {
[17:59:33.961]                     inherits <- base::inherits
[17:59:33.961]                     invokeRestart <- base::invokeRestart
[17:59:33.961]                     is.null <- base::is.null
[17:59:33.961]                     muffled <- FALSE
[17:59:33.961]                     if (inherits(cond, "message")) {
[17:59:33.961]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:33.961]                       if (muffled) 
[17:59:33.961]                         invokeRestart("muffleMessage")
[17:59:33.961]                     }
[17:59:33.961]                     else if (inherits(cond, "warning")) {
[17:59:33.961]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:33.961]                       if (muffled) 
[17:59:33.961]                         invokeRestart("muffleWarning")
[17:59:33.961]                     }
[17:59:33.961]                     else if (inherits(cond, "condition")) {
[17:59:33.961]                       if (!is.null(pattern)) {
[17:59:33.961]                         computeRestarts <- base::computeRestarts
[17:59:33.961]                         grepl <- base::grepl
[17:59:33.961]                         restarts <- computeRestarts(cond)
[17:59:33.961]                         for (restart in restarts) {
[17:59:33.961]                           name <- restart$name
[17:59:33.961]                           if (is.null(name)) 
[17:59:33.961]                             next
[17:59:33.961]                           if (!grepl(pattern, name)) 
[17:59:33.961]                             next
[17:59:33.961]                           invokeRestart(restart)
[17:59:33.961]                           muffled <- TRUE
[17:59:33.961]                           break
[17:59:33.961]                         }
[17:59:33.961]                       }
[17:59:33.961]                     }
[17:59:33.961]                     invisible(muffled)
[17:59:33.961]                   }
[17:59:33.961]                   muffleCondition(cond)
[17:59:33.961]                 })
[17:59:33.961]             }))
[17:59:33.961]             future::FutureResult(value = ...future.value$value, 
[17:59:33.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.961]                   ...future.rng), globalenv = if (FALSE) 
[17:59:33.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:33.961]                     ...future.globalenv.names))
[17:59:33.961]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:33.961]         }, condition = base::local({
[17:59:33.961]             c <- base::c
[17:59:33.961]             inherits <- base::inherits
[17:59:33.961]             invokeRestart <- base::invokeRestart
[17:59:33.961]             length <- base::length
[17:59:33.961]             list <- base::list
[17:59:33.961]             seq.int <- base::seq.int
[17:59:33.961]             signalCondition <- base::signalCondition
[17:59:33.961]             sys.calls <- base::sys.calls
[17:59:33.961]             `[[` <- base::`[[`
[17:59:33.961]             `+` <- base::`+`
[17:59:33.961]             `<<-` <- base::`<<-`
[17:59:33.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:33.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:33.961]                   3L)]
[17:59:33.961]             }
[17:59:33.961]             function(cond) {
[17:59:33.961]                 is_error <- inherits(cond, "error")
[17:59:33.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:33.961]                   NULL)
[17:59:33.961]                 if (is_error) {
[17:59:33.961]                   sessionInformation <- function() {
[17:59:33.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:33.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:33.961]                       search = base::search(), system = base::Sys.info())
[17:59:33.961]                   }
[17:59:33.961]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:33.961]                     cond$call), session = sessionInformation(), 
[17:59:33.961]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:33.961]                   signalCondition(cond)
[17:59:33.961]                 }
[17:59:33.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:33.961]                 "immediateCondition"))) {
[17:59:33.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:33.961]                   ...future.conditions[[length(...future.conditions) + 
[17:59:33.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:33.961]                   if (TRUE && !signal) {
[17:59:33.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.961]                     {
[17:59:33.961]                       inherits <- base::inherits
[17:59:33.961]                       invokeRestart <- base::invokeRestart
[17:59:33.961]                       is.null <- base::is.null
[17:59:33.961]                       muffled <- FALSE
[17:59:33.961]                       if (inherits(cond, "message")) {
[17:59:33.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.961]                         if (muffled) 
[17:59:33.961]                           invokeRestart("muffleMessage")
[17:59:33.961]                       }
[17:59:33.961]                       else if (inherits(cond, "warning")) {
[17:59:33.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.961]                         if (muffled) 
[17:59:33.961]                           invokeRestart("muffleWarning")
[17:59:33.961]                       }
[17:59:33.961]                       else if (inherits(cond, "condition")) {
[17:59:33.961]                         if (!is.null(pattern)) {
[17:59:33.961]                           computeRestarts <- base::computeRestarts
[17:59:33.961]                           grepl <- base::grepl
[17:59:33.961]                           restarts <- computeRestarts(cond)
[17:59:33.961]                           for (restart in restarts) {
[17:59:33.961]                             name <- restart$name
[17:59:33.961]                             if (is.null(name)) 
[17:59:33.961]                               next
[17:59:33.961]                             if (!grepl(pattern, name)) 
[17:59:33.961]                               next
[17:59:33.961]                             invokeRestart(restart)
[17:59:33.961]                             muffled <- TRUE
[17:59:33.961]                             break
[17:59:33.961]                           }
[17:59:33.961]                         }
[17:59:33.961]                       }
[17:59:33.961]                       invisible(muffled)
[17:59:33.961]                     }
[17:59:33.961]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.961]                   }
[17:59:33.961]                 }
[17:59:33.961]                 else {
[17:59:33.961]                   if (TRUE) {
[17:59:33.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:33.961]                     {
[17:59:33.961]                       inherits <- base::inherits
[17:59:33.961]                       invokeRestart <- base::invokeRestart
[17:59:33.961]                       is.null <- base::is.null
[17:59:33.961]                       muffled <- FALSE
[17:59:33.961]                       if (inherits(cond, "message")) {
[17:59:33.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:33.961]                         if (muffled) 
[17:59:33.961]                           invokeRestart("muffleMessage")
[17:59:33.961]                       }
[17:59:33.961]                       else if (inherits(cond, "warning")) {
[17:59:33.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:33.961]                         if (muffled) 
[17:59:33.961]                           invokeRestart("muffleWarning")
[17:59:33.961]                       }
[17:59:33.961]                       else if (inherits(cond, "condition")) {
[17:59:33.961]                         if (!is.null(pattern)) {
[17:59:33.961]                           computeRestarts <- base::computeRestarts
[17:59:33.961]                           grepl <- base::grepl
[17:59:33.961]                           restarts <- computeRestarts(cond)
[17:59:33.961]                           for (restart in restarts) {
[17:59:33.961]                             name <- restart$name
[17:59:33.961]                             if (is.null(name)) 
[17:59:33.961]                               next
[17:59:33.961]                             if (!grepl(pattern, name)) 
[17:59:33.961]                               next
[17:59:33.961]                             invokeRestart(restart)
[17:59:33.961]                             muffled <- TRUE
[17:59:33.961]                             break
[17:59:33.961]                           }
[17:59:33.961]                         }
[17:59:33.961]                       }
[17:59:33.961]                       invisible(muffled)
[17:59:33.961]                     }
[17:59:33.961]                     muffleCondition(cond, pattern = "^muffle")
[17:59:33.961]                   }
[17:59:33.961]                 }
[17:59:33.961]             }
[17:59:33.961]         }))
[17:59:33.961]     }, error = function(ex) {
[17:59:33.961]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:33.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:33.961]                 ...future.rng), started = ...future.startTime, 
[17:59:33.961]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:33.961]             version = "1.8"), class = "FutureResult")
[17:59:33.961]     }, finally = {
[17:59:33.961]         if (!identical(...future.workdir, getwd())) 
[17:59:33.961]             setwd(...future.workdir)
[17:59:33.961]         {
[17:59:33.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:33.961]                 ...future.oldOptions$nwarnings <- NULL
[17:59:33.961]             }
[17:59:33.961]             base::options(...future.oldOptions)
[17:59:33.961]             if (.Platform$OS.type == "windows") {
[17:59:33.961]                 old_names <- names(...future.oldEnvVars)
[17:59:33.961]                 envs <- base::Sys.getenv()
[17:59:33.961]                 names <- names(envs)
[17:59:33.961]                 common <- intersect(names, old_names)
[17:59:33.961]                 added <- setdiff(names, old_names)
[17:59:33.961]                 removed <- setdiff(old_names, names)
[17:59:33.961]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:33.961]                   envs[common]]
[17:59:33.961]                 NAMES <- toupper(changed)
[17:59:33.961]                 args <- list()
[17:59:33.961]                 for (kk in seq_along(NAMES)) {
[17:59:33.961]                   name <- changed[[kk]]
[17:59:33.961]                   NAME <- NAMES[[kk]]
[17:59:33.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.961]                     next
[17:59:33.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.961]                 }
[17:59:33.961]                 NAMES <- toupper(added)
[17:59:33.961]                 for (kk in seq_along(NAMES)) {
[17:59:33.961]                   name <- added[[kk]]
[17:59:33.961]                   NAME <- NAMES[[kk]]
[17:59:33.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.961]                     next
[17:59:33.961]                   args[[name]] <- ""
[17:59:33.961]                 }
[17:59:33.961]                 NAMES <- toupper(removed)
[17:59:33.961]                 for (kk in seq_along(NAMES)) {
[17:59:33.961]                   name <- removed[[kk]]
[17:59:33.961]                   NAME <- NAMES[[kk]]
[17:59:33.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:33.961]                     next
[17:59:33.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:33.961]                 }
[17:59:33.961]                 if (length(args) > 0) 
[17:59:33.961]                   base::do.call(base::Sys.setenv, args = args)
[17:59:33.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:33.961]             }
[17:59:33.961]             else {
[17:59:33.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:33.961]             }
[17:59:33.961]             {
[17:59:33.961]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:33.961]                   0L) {
[17:59:33.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:33.961]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:33.961]                   base::options(opts)
[17:59:33.961]                 }
[17:59:33.961]                 {
[17:59:33.961]                   {
[17:59:33.961]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:33.961]                     NULL
[17:59:33.961]                   }
[17:59:33.961]                   options(future.plan = NULL)
[17:59:33.961]                   if (is.na(NA_character_)) 
[17:59:33.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:33.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:33.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:33.961]                     .init = FALSE)
[17:59:33.961]                 }
[17:59:33.961]             }
[17:59:33.961]         }
[17:59:33.961]     })
[17:59:33.961]     if (TRUE) {
[17:59:33.961]         base::sink(type = "output", split = FALSE)
[17:59:33.961]         if (TRUE) {
[17:59:33.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:33.961]         }
[17:59:33.961]         else {
[17:59:33.961]             ...future.result["stdout"] <- base::list(NULL)
[17:59:33.961]         }
[17:59:33.961]         base::close(...future.stdout)
[17:59:33.961]         ...future.stdout <- NULL
[17:59:33.961]     }
[17:59:33.961]     ...future.result$conditions <- ...future.conditions
[17:59:33.961]     ...future.result$finished <- base::Sys.time()
[17:59:33.961]     ...future.result
[17:59:33.961] }
[17:59:33.966] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:59:33.967] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:59:33.968] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:59:33.968] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:33.969] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.969] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:59:33.970] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:59:33.970] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:33.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.971] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:33.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:33.972] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:59:33.973] MultisessionFuture started
[17:59:33.974] - Launch lazy future ... done
[17:59:33.974] run() for ‘MultisessionFuture’ ... done
[17:59:33.974] Created future:
[17:59:33.974] MultisessionFuture:
[17:59:33.974] Label: ‘future_eapply-2’
[17:59:33.974] Expression:
[17:59:33.974] {
[17:59:33.974]     do.call(function(...) {
[17:59:33.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:33.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:33.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:33.974]             on.exit(options(oopts), add = TRUE)
[17:59:33.974]         }
[17:59:33.974]         {
[17:59:33.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:33.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:33.974]                 ...future.FUN(...future.X_jj, ...)
[17:59:33.974]             })
[17:59:33.974]         }
[17:59:33.974]     }, args = future.call.arguments)
[17:59:33.974] }
[17:59:33.974] Lazy evaluation: FALSE
[17:59:33.974] Asynchronous evaluation: TRUE
[17:59:33.974] Local evaluation: TRUE
[17:59:33.974] Environment: R_GlobalEnv
[17:59:33.974] Capture standard output: TRUE
[17:59:33.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:33.974] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:33.974] Packages: 1 packages (‘stats’)
[17:59:33.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:33.974] Resolved: FALSE
[17:59:33.974] Value: <not collected>
[17:59:33.974] Conditions captured: <none>
[17:59:33.974] Early signaling: FALSE
[17:59:33.974] Owner process: 8aa36561-d701-6e0c-ea9b-66a8f090ed6f
[17:59:33.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:33.987] Chunk #2 of 2 ... DONE
[17:59:33.987] Launching 2 futures (chunks) ... DONE
[17:59:33.988] Resolving 2 futures (chunks) ...
[17:59:33.988] resolve() on list ...
[17:59:33.988]  recursive: 0
[17:59:33.988]  length: 2
[17:59:33.988] 
[17:59:33.989] receiveMessageFromWorker() for ClusterFuture ...
[17:59:33.989] - Validating connection of MultisessionFuture
[17:59:33.990] - received message: FutureResult
[17:59:33.990] - Received FutureResult
[17:59:33.990] - Erased future from FutureRegistry
[17:59:33.990] result() for ClusterFuture ...
[17:59:33.991] - result already collected: FutureResult
[17:59:33.991] result() for ClusterFuture ... done
[17:59:33.991] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:33.991] Future #1
[17:59:33.991] result() for ClusterFuture ...
[17:59:33.991] - result already collected: FutureResult
[17:59:33.992] result() for ClusterFuture ... done
[17:59:33.992] result() for ClusterFuture ...
[17:59:33.992] - result already collected: FutureResult
[17:59:33.992] result() for ClusterFuture ... done
[17:59:33.992] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:33.993] - nx: 2
[17:59:33.993] - relay: TRUE
[17:59:33.993] - stdout: TRUE
[17:59:33.993] - signal: TRUE
[17:59:33.993] - resignal: FALSE
[17:59:33.993] - force: TRUE
[17:59:33.994] - relayed: [n=2] FALSE, FALSE
[17:59:33.994] - queued futures: [n=2] FALSE, FALSE
[17:59:33.994]  - until=1
[17:59:33.994]  - relaying element #1
[17:59:33.994] result() for ClusterFuture ...
[17:59:33.994] - result already collected: FutureResult
[17:59:33.995] result() for ClusterFuture ... done
[17:59:33.995] result() for ClusterFuture ...
[17:59:33.995] - result already collected: FutureResult
[17:59:33.995] result() for ClusterFuture ... done
[17:59:33.995] result() for ClusterFuture ...
[17:59:33.996] - result already collected: FutureResult
[17:59:33.996] result() for ClusterFuture ... done
[17:59:33.996] result() for ClusterFuture ...
[17:59:33.996] - result already collected: FutureResult
[17:59:33.996] result() for ClusterFuture ... done
[17:59:33.997] - relayed: [n=2] TRUE, FALSE
[17:59:33.997] - queued futures: [n=2] TRUE, FALSE
[17:59:33.997] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:33.997]  length: 1 (resolved future 1)
[17:59:34.019] receiveMessageFromWorker() for ClusterFuture ...
[17:59:34.020] - Validating connection of MultisessionFuture
[17:59:34.020] - received message: FutureResult
[17:59:34.020] - Received FutureResult
[17:59:34.020] - Erased future from FutureRegistry
[17:59:34.021] result() for ClusterFuture ...
[17:59:34.021] - result already collected: FutureResult
[17:59:34.021] result() for ClusterFuture ... done
[17:59:34.021] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:34.021] Future #2
[17:59:34.021] result() for ClusterFuture ...
[17:59:34.022] - result already collected: FutureResult
[17:59:34.022] result() for ClusterFuture ... done
[17:59:34.022] result() for ClusterFuture ...
[17:59:34.022] - result already collected: FutureResult
[17:59:34.022] result() for ClusterFuture ... done
[17:59:34.023] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:34.023] - nx: 2
[17:59:34.023] - relay: TRUE
[17:59:34.023] - stdout: TRUE
[17:59:34.023] - signal: TRUE
[17:59:34.023] - resignal: FALSE
[17:59:34.024] - force: TRUE
[17:59:34.024] - relayed: [n=2] TRUE, FALSE
[17:59:34.024] - queued futures: [n=2] TRUE, FALSE
[17:59:34.024]  - until=2
[17:59:34.024]  - relaying element #2
[17:59:34.025] result() for ClusterFuture ...
[17:59:34.025] - result already collected: FutureResult
[17:59:34.025] result() for ClusterFuture ... done
[17:59:34.025] result() for ClusterFuture ...
[17:59:34.025] - result already collected: FutureResult
[17:59:34.025] result() for ClusterFuture ... done
[17:59:34.026] result() for ClusterFuture ...
[17:59:34.026] - result already collected: FutureResult
[17:59:34.026] result() for ClusterFuture ... done
[17:59:34.026] result() for ClusterFuture ...
[17:59:34.026] - result already collected: FutureResult
[17:59:34.027] result() for ClusterFuture ... done
[17:59:34.027] - relayed: [n=2] TRUE, TRUE
[17:59:34.027] - queued futures: [n=2] TRUE, TRUE
[17:59:34.027] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:34.027]  length: 0 (resolved future 2)
[17:59:34.028] Relaying remaining futures
[17:59:34.028] signalConditionsASAP(NULL, pos=0) ...
[17:59:34.028] - nx: 2
[17:59:34.028] - relay: TRUE
[17:59:34.028] - stdout: TRUE
[17:59:34.028] - signal: TRUE
[17:59:34.029] - resignal: FALSE
[17:59:34.029] - force: TRUE
[17:59:34.029] - relayed: [n=2] TRUE, TRUE
[17:59:34.029] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:34.029] - relayed: [n=2] TRUE, TRUE
[17:59:34.030] - queued futures: [n=2] TRUE, TRUE
[17:59:34.030] signalConditionsASAP(NULL, pos=0) ... done
[17:59:34.030] resolve() on list ... DONE
[17:59:34.030] result() for ClusterFuture ...
[17:59:34.030] - result already collected: FutureResult
[17:59:34.030] result() for ClusterFuture ... done
[17:59:34.031] result() for ClusterFuture ...
[17:59:34.031] - result already collected: FutureResult
[17:59:34.031] result() for ClusterFuture ... done
[17:59:34.031] result() for ClusterFuture ...
[17:59:34.031] - result already collected: FutureResult
[17:59:34.032] result() for ClusterFuture ... done
[17:59:34.032] result() for ClusterFuture ...
[17:59:34.032] - result already collected: FutureResult
[17:59:34.032] result() for ClusterFuture ... done
[17:59:34.032]  - Number of value chunks collected: 2
[17:59:34.032] Resolving 2 futures (chunks) ... DONE
[17:59:34.033] Reducing values from 2 chunks ...
[17:59:34.033]  - Number of values collected after concatenation: 3
[17:59:34.033]  - Number of values expected: 3
[17:59:34.033] Reducing values from 2 chunks ... DONE
[17:59:34.033] future_lapply() ... DONE
[17:59:34.034] plan(): Setting new future strategy stack:
[17:59:34.034] List of future strategies:
[17:59:34.034] 1. sequential:
[17:59:34.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:34.034]    - tweaked: FALSE
[17:59:34.034]    - call: plan(sequential)
[17:59:34.036] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[17:59:34.037] plan(): Setting new future strategy stack:
[17:59:34.038] List of future strategies:
[17:59:34.038] 1. FutureStrategy:
[17:59:34.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:34.038]    - tweaked: FALSE
[17:59:34.038]    - call: future::plan(oplan)
[17:59:34.042] plan(): nbrOfWorkers() = 1
> 
