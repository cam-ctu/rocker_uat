
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:43:51.822] plan(): Setting new future strategy stack:
[17:43:51.822] List of future strategies:
[17:43:51.822] 1. sequential:
[17:43:51.822]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.822]    - tweaked: FALSE
[17:43:51.822]    - call: future::plan("sequential")
[17:43:51.836] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[17:43:51.892] plan(): Setting new future strategy stack:
[17:43:51.892] List of future strategies:
[17:43:51.892] 1. sequential:
[17:43:51.892]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.892]    - tweaked: FALSE
[17:43:51.892]    - call: plan(strategy)
[17:43:51.905] plan(): nbrOfWorkers() = 1
[17:43:51.905] future_by_internal() ...
[17:43:51.906] future_lapply() ...
[17:43:51.910] Number of chunks: 1
[17:43:51.910] getGlobalsAndPackagesXApply() ...
[17:43:51.910]  - future.globals: TRUE
[17:43:51.911] getGlobalsAndPackages() ...
[17:43:51.911] Searching for globals...
[17:43:51.913] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:51.913] Searching for globals ... DONE
[17:43:51.913] Resolving globals: FALSE
[17:43:51.914] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:51.915] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:51.915] - globals: [1] ‘FUN’
[17:43:51.915] 
[17:43:51.915] getGlobalsAndPackages() ... DONE
[17:43:51.915]  - globals found/used: [n=1] ‘FUN’
[17:43:51.915]  - needed namespaces: [n=0] 
[17:43:51.915] Finding globals ... DONE
[17:43:51.915]  - use_args: TRUE
[17:43:51.915]  - Getting '...' globals ...
[17:43:51.916] resolve() on list ...
[17:43:51.916]  recursive: 0
[17:43:51.916]  length: 1
[17:43:51.917]  elements: ‘...’
[17:43:51.917]  length: 0 (resolved future 1)
[17:43:51.917] resolve() on list ... DONE
[17:43:51.917]    - '...' content: [n=0] 
[17:43:51.917] List of 1
[17:43:51.917]  $ ...: list()
[17:43:51.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.917]  - attr(*, "where")=List of 1
[17:43:51.917]   ..$ ...:<environment: 0x55d6b95889e0> 
[17:43:51.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.917]  - attr(*, "resolved")= logi TRUE
[17:43:51.917]  - attr(*, "total_size")= num NA
[17:43:51.921]  - Getting '...' globals ... DONE
[17:43:51.921] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:51.921] List of 2
[17:43:51.921]  $ ...future.FUN:function (object, ...)  
[17:43:51.921]  $ ...          : list()
[17:43:51.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.921]  - attr(*, "where")=List of 2
[17:43:51.921]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:51.921]   ..$ ...          :<environment: 0x55d6b95889e0> 
[17:43:51.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.921]  - attr(*, "resolved")= logi FALSE
[17:43:51.921]  - attr(*, "total_size")= num 1240
[17:43:51.924] Packages to be attached in all futures: [n=0] 
[17:43:51.924] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.924] Number of futures (= number of chunks): 1
[17:43:51.924] Launching 1 futures (chunks) ...
[17:43:51.925] Chunk #1 of 1 ...
[17:43:51.925]  - Finding globals in 'X' for chunk #1 ...
[17:43:51.925] getGlobalsAndPackages() ...
[17:43:51.925] Searching for globals...
[17:43:51.926] 
[17:43:51.926] Searching for globals ... DONE
[17:43:51.926] - globals: [0] <none>
[17:43:51.926] getGlobalsAndPackages() ... DONE
[17:43:51.926]    + additional globals found: [n=0] 
[17:43:51.926]    + additional namespaces needed: [n=0] 
[17:43:51.926]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:51.926]  - seeds: <none>
[17:43:51.926]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.926] getGlobalsAndPackages() ...
[17:43:51.927] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.927] Resolving globals: FALSE
[17:43:51.927] Tweak future expression to call with '...' arguments ...
[17:43:51.927] {
[17:43:51.927]     do.call(function(...) {
[17:43:51.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.927]             on.exit(options(oopts), add = TRUE)
[17:43:51.927]         }
[17:43:51.927]         {
[17:43:51.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.927]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.927]             })
[17:43:51.927]         }
[17:43:51.927]     }, args = future.call.arguments)
[17:43:51.927] }
[17:43:51.927] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.927] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.928] 
[17:43:51.928] getGlobalsAndPackages() ... DONE
[17:43:51.928] run() for ‘Future’ ...
[17:43:51.929] - state: ‘created’
[17:43:51.929] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:51.929] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:51.929] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:51.929]   - Field: ‘label’
[17:43:51.929]   - Field: ‘local’
[17:43:51.929]   - Field: ‘owner’
[17:43:51.930]   - Field: ‘envir’
[17:43:51.930]   - Field: ‘packages’
[17:43:51.930]   - Field: ‘gc’
[17:43:51.930]   - Field: ‘conditions’
[17:43:51.930]   - Field: ‘expr’
[17:43:51.930]   - Field: ‘uuid’
[17:43:51.930]   - Field: ‘seed’
[17:43:51.930]   - Field: ‘version’
[17:43:51.930]   - Field: ‘result’
[17:43:51.930]   - Field: ‘asynchronous’
[17:43:51.930]   - Field: ‘calls’
[17:43:51.931]   - Field: ‘globals’
[17:43:51.931]   - Field: ‘stdout’
[17:43:51.931]   - Field: ‘earlySignal’
[17:43:51.931]   - Field: ‘lazy’
[17:43:51.931]   - Field: ‘state’
[17:43:51.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:51.931] - Launch lazy future ...
[17:43:51.932] Packages needed by the future expression (n = 0): <none>
[17:43:51.932] Packages needed by future strategies (n = 0): <none>
[17:43:51.933] {
[17:43:51.933]     {
[17:43:51.933]         {
[17:43:51.933]             ...future.startTime <- base::Sys.time()
[17:43:51.933]             {
[17:43:51.933]                 {
[17:43:51.933]                   {
[17:43:51.933]                     base::local({
[17:43:51.933]                       has_future <- base::requireNamespace("future", 
[17:43:51.933]                         quietly = TRUE)
[17:43:51.933]                       if (has_future) {
[17:43:51.933]                         ns <- base::getNamespace("future")
[17:43:51.933]                         version <- ns[[".package"]][["version"]]
[17:43:51.933]                         if (is.null(version)) 
[17:43:51.933]                           version <- utils::packageVersion("future")
[17:43:51.933]                       }
[17:43:51.933]                       else {
[17:43:51.933]                         version <- NULL
[17:43:51.933]                       }
[17:43:51.933]                       if (!has_future || version < "1.8.0") {
[17:43:51.933]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.933]                           "", base::R.version$version.string), 
[17:43:51.933]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:51.933]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.933]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.933]                             "release", "version")], collapse = " "), 
[17:43:51.933]                           hostname = base::Sys.info()[["nodename"]])
[17:43:51.933]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.933]                           info)
[17:43:51.933]                         info <- base::paste(info, collapse = "; ")
[17:43:51.933]                         if (!has_future) {
[17:43:51.933]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.933]                             info)
[17:43:51.933]                         }
[17:43:51.933]                         else {
[17:43:51.933]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.933]                             info, version)
[17:43:51.933]                         }
[17:43:51.933]                         base::stop(msg)
[17:43:51.933]                       }
[17:43:51.933]                     })
[17:43:51.933]                   }
[17:43:51.933]                   ...future.strategy.old <- future::plan("list")
[17:43:51.933]                   options(future.plan = NULL)
[17:43:51.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.933]                 }
[17:43:51.933]                 ...future.workdir <- getwd()
[17:43:51.933]             }
[17:43:51.933]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.933]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.933]         }
[17:43:51.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:51.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.933]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.933]             base::names(...future.oldOptions))
[17:43:51.933]     }
[17:43:51.933]     if (FALSE) {
[17:43:51.933]     }
[17:43:51.933]     else {
[17:43:51.933]         if (TRUE) {
[17:43:51.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.933]                 open = "w")
[17:43:51.933]         }
[17:43:51.933]         else {
[17:43:51.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.933]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.933]         }
[17:43:51.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.933]             base::sink(type = "output", split = FALSE)
[17:43:51.933]             base::close(...future.stdout)
[17:43:51.933]         }, add = TRUE)
[17:43:51.933]     }
[17:43:51.933]     ...future.frame <- base::sys.nframe()
[17:43:51.933]     ...future.conditions <- base::list()
[17:43:51.933]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.933]     if (FALSE) {
[17:43:51.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.933]     }
[17:43:51.933]     ...future.result <- base::tryCatch({
[17:43:51.933]         base::withCallingHandlers({
[17:43:51.933]             ...future.value <- base::withVisible(base::local({
[17:43:51.933]                 do.call(function(...) {
[17:43:51.933]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.933]                   if (!identical(...future.globals.maxSize.org, 
[17:43:51.933]                     ...future.globals.maxSize)) {
[17:43:51.933]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.933]                     on.exit(options(oopts), add = TRUE)
[17:43:51.933]                   }
[17:43:51.933]                   {
[17:43:51.933]                     lapply(seq_along(...future.elements_ii), 
[17:43:51.933]                       FUN = function(jj) {
[17:43:51.933]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.933]                         ...future.FUN(...future.X_jj, ...)
[17:43:51.933]                       })
[17:43:51.933]                   }
[17:43:51.933]                 }, args = future.call.arguments)
[17:43:51.933]             }))
[17:43:51.933]             future::FutureResult(value = ...future.value$value, 
[17:43:51.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.933]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.933]                     ...future.globalenv.names))
[17:43:51.933]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.933]         }, condition = base::local({
[17:43:51.933]             c <- base::c
[17:43:51.933]             inherits <- base::inherits
[17:43:51.933]             invokeRestart <- base::invokeRestart
[17:43:51.933]             length <- base::length
[17:43:51.933]             list <- base::list
[17:43:51.933]             seq.int <- base::seq.int
[17:43:51.933]             signalCondition <- base::signalCondition
[17:43:51.933]             sys.calls <- base::sys.calls
[17:43:51.933]             `[[` <- base::`[[`
[17:43:51.933]             `+` <- base::`+`
[17:43:51.933]             `<<-` <- base::`<<-`
[17:43:51.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.933]                   3L)]
[17:43:51.933]             }
[17:43:51.933]             function(cond) {
[17:43:51.933]                 is_error <- inherits(cond, "error")
[17:43:51.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.933]                   NULL)
[17:43:51.933]                 if (is_error) {
[17:43:51.933]                   sessionInformation <- function() {
[17:43:51.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.933]                       search = base::search(), system = base::Sys.info())
[17:43:51.933]                   }
[17:43:51.933]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.933]                     cond$call), session = sessionInformation(), 
[17:43:51.933]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.933]                   signalCondition(cond)
[17:43:51.933]                 }
[17:43:51.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.933]                 "immediateCondition"))) {
[17:43:51.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.933]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.933]                   if (TRUE && !signal) {
[17:43:51.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.933]                     {
[17:43:51.933]                       inherits <- base::inherits
[17:43:51.933]                       invokeRestart <- base::invokeRestart
[17:43:51.933]                       is.null <- base::is.null
[17:43:51.933]                       muffled <- FALSE
[17:43:51.933]                       if (inherits(cond, "message")) {
[17:43:51.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.933]                         if (muffled) 
[17:43:51.933]                           invokeRestart("muffleMessage")
[17:43:51.933]                       }
[17:43:51.933]                       else if (inherits(cond, "warning")) {
[17:43:51.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.933]                         if (muffled) 
[17:43:51.933]                           invokeRestart("muffleWarning")
[17:43:51.933]                       }
[17:43:51.933]                       else if (inherits(cond, "condition")) {
[17:43:51.933]                         if (!is.null(pattern)) {
[17:43:51.933]                           computeRestarts <- base::computeRestarts
[17:43:51.933]                           grepl <- base::grepl
[17:43:51.933]                           restarts <- computeRestarts(cond)
[17:43:51.933]                           for (restart in restarts) {
[17:43:51.933]                             name <- restart$name
[17:43:51.933]                             if (is.null(name)) 
[17:43:51.933]                               next
[17:43:51.933]                             if (!grepl(pattern, name)) 
[17:43:51.933]                               next
[17:43:51.933]                             invokeRestart(restart)
[17:43:51.933]                             muffled <- TRUE
[17:43:51.933]                             break
[17:43:51.933]                           }
[17:43:51.933]                         }
[17:43:51.933]                       }
[17:43:51.933]                       invisible(muffled)
[17:43:51.933]                     }
[17:43:51.933]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.933]                   }
[17:43:51.933]                 }
[17:43:51.933]                 else {
[17:43:51.933]                   if (TRUE) {
[17:43:51.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.933]                     {
[17:43:51.933]                       inherits <- base::inherits
[17:43:51.933]                       invokeRestart <- base::invokeRestart
[17:43:51.933]                       is.null <- base::is.null
[17:43:51.933]                       muffled <- FALSE
[17:43:51.933]                       if (inherits(cond, "message")) {
[17:43:51.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.933]                         if (muffled) 
[17:43:51.933]                           invokeRestart("muffleMessage")
[17:43:51.933]                       }
[17:43:51.933]                       else if (inherits(cond, "warning")) {
[17:43:51.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.933]                         if (muffled) 
[17:43:51.933]                           invokeRestart("muffleWarning")
[17:43:51.933]                       }
[17:43:51.933]                       else if (inherits(cond, "condition")) {
[17:43:51.933]                         if (!is.null(pattern)) {
[17:43:51.933]                           computeRestarts <- base::computeRestarts
[17:43:51.933]                           grepl <- base::grepl
[17:43:51.933]                           restarts <- computeRestarts(cond)
[17:43:51.933]                           for (restart in restarts) {
[17:43:51.933]                             name <- restart$name
[17:43:51.933]                             if (is.null(name)) 
[17:43:51.933]                               next
[17:43:51.933]                             if (!grepl(pattern, name)) 
[17:43:51.933]                               next
[17:43:51.933]                             invokeRestart(restart)
[17:43:51.933]                             muffled <- TRUE
[17:43:51.933]                             break
[17:43:51.933]                           }
[17:43:51.933]                         }
[17:43:51.933]                       }
[17:43:51.933]                       invisible(muffled)
[17:43:51.933]                     }
[17:43:51.933]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.933]                   }
[17:43:51.933]                 }
[17:43:51.933]             }
[17:43:51.933]         }))
[17:43:51.933]     }, error = function(ex) {
[17:43:51.933]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.933]                 ...future.rng), started = ...future.startTime, 
[17:43:51.933]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.933]             version = "1.8"), class = "FutureResult")
[17:43:51.933]     }, finally = {
[17:43:51.933]         if (!identical(...future.workdir, getwd())) 
[17:43:51.933]             setwd(...future.workdir)
[17:43:51.933]         {
[17:43:51.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.933]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.933]             }
[17:43:51.933]             base::options(...future.oldOptions)
[17:43:51.933]             if (.Platform$OS.type == "windows") {
[17:43:51.933]                 old_names <- names(...future.oldEnvVars)
[17:43:51.933]                 envs <- base::Sys.getenv()
[17:43:51.933]                 names <- names(envs)
[17:43:51.933]                 common <- intersect(names, old_names)
[17:43:51.933]                 added <- setdiff(names, old_names)
[17:43:51.933]                 removed <- setdiff(old_names, names)
[17:43:51.933]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.933]                   envs[common]]
[17:43:51.933]                 NAMES <- toupper(changed)
[17:43:51.933]                 args <- list()
[17:43:51.933]                 for (kk in seq_along(NAMES)) {
[17:43:51.933]                   name <- changed[[kk]]
[17:43:51.933]                   NAME <- NAMES[[kk]]
[17:43:51.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.933]                     next
[17:43:51.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.933]                 }
[17:43:51.933]                 NAMES <- toupper(added)
[17:43:51.933]                 for (kk in seq_along(NAMES)) {
[17:43:51.933]                   name <- added[[kk]]
[17:43:51.933]                   NAME <- NAMES[[kk]]
[17:43:51.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.933]                     next
[17:43:51.933]                   args[[name]] <- ""
[17:43:51.933]                 }
[17:43:51.933]                 NAMES <- toupper(removed)
[17:43:51.933]                 for (kk in seq_along(NAMES)) {
[17:43:51.933]                   name <- removed[[kk]]
[17:43:51.933]                   NAME <- NAMES[[kk]]
[17:43:51.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.933]                     next
[17:43:51.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.933]                 }
[17:43:51.933]                 if (length(args) > 0) 
[17:43:51.933]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.933]             }
[17:43:51.933]             else {
[17:43:51.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.933]             }
[17:43:51.933]             {
[17:43:51.933]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.933]                   0L) {
[17:43:51.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.933]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.933]                   base::options(opts)
[17:43:51.933]                 }
[17:43:51.933]                 {
[17:43:51.933]                   {
[17:43:51.933]                     NULL
[17:43:51.933]                     RNGkind("Mersenne-Twister")
[17:43:51.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:51.933]                       inherits = FALSE)
[17:43:51.933]                   }
[17:43:51.933]                   options(future.plan = NULL)
[17:43:51.933]                   if (is.na(NA_character_)) 
[17:43:51.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.933]                     .init = FALSE)
[17:43:51.933]                 }
[17:43:51.933]             }
[17:43:51.933]         }
[17:43:51.933]     })
[17:43:51.933]     if (TRUE) {
[17:43:51.933]         base::sink(type = "output", split = FALSE)
[17:43:51.933]         if (TRUE) {
[17:43:51.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.933]         }
[17:43:51.933]         else {
[17:43:51.933]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.933]         }
[17:43:51.933]         base::close(...future.stdout)
[17:43:51.933]         ...future.stdout <- NULL
[17:43:51.933]     }
[17:43:51.933]     ...future.result$conditions <- ...future.conditions
[17:43:51.933]     ...future.result$finished <- base::Sys.time()
[17:43:51.933]     ...future.result
[17:43:51.933] }
[17:43:51.935] assign_globals() ...
[17:43:51.935] List of 5
[17:43:51.935]  $ ...future.FUN            :function (object, ...)  
[17:43:51.935]  $ future.call.arguments    : list()
[17:43:51.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.935]  $ ...future.elements_ii    :List of 3
[17:43:51.935]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:51.935]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:51.935]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:51.935]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:51.935]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:51.935]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:51.935]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:51.935]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:51.935]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:51.935]  $ ...future.seeds_ii       : NULL
[17:43:51.935]  $ ...future.globals.maxSize: NULL
[17:43:51.935]  - attr(*, "where")=List of 5
[17:43:51.935]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:51.935]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:51.935]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:51.935]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:51.935]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:51.935]  - attr(*, "resolved")= logi FALSE
[17:43:51.935]  - attr(*, "total_size")= num 1240
[17:43:51.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.935]  - attr(*, "already-done")= logi TRUE
[17:43:51.946] - copied ‘...future.FUN’ to environment
[17:43:51.946] - copied ‘future.call.arguments’ to environment
[17:43:51.946] - copied ‘...future.elements_ii’ to environment
[17:43:51.946] - copied ‘...future.seeds_ii’ to environment
[17:43:51.946] - copied ‘...future.globals.maxSize’ to environment
[17:43:51.946] assign_globals() ... done
[17:43:51.946] plan(): Setting new future strategy stack:
[17:43:51.947] List of future strategies:
[17:43:51.947] 1. sequential:
[17:43:51.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.947]    - tweaked: FALSE
[17:43:51.947]    - call: NULL
[17:43:51.947] plan(): nbrOfWorkers() = 1
[17:43:51.949] plan(): Setting new future strategy stack:
[17:43:51.949] List of future strategies:
[17:43:51.949] 1. sequential:
[17:43:51.949]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.949]    - tweaked: FALSE
[17:43:51.949]    - call: plan(strategy)
[17:43:51.950] plan(): nbrOfWorkers() = 1
[17:43:51.950] SequentialFuture started (and completed)
[17:43:51.951] - Launch lazy future ... done
[17:43:51.951] run() for ‘SequentialFuture’ ... done
[17:43:51.951] Created future:
[17:43:51.951] SequentialFuture:
[17:43:51.951] Label: ‘future_by-1’
[17:43:51.951] Expression:
[17:43:51.951] {
[17:43:51.951]     do.call(function(...) {
[17:43:51.951]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.951]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.951]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.951]             on.exit(options(oopts), add = TRUE)
[17:43:51.951]         }
[17:43:51.951]         {
[17:43:51.951]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.951]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.951]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.951]             })
[17:43:51.951]         }
[17:43:51.951]     }, args = future.call.arguments)
[17:43:51.951] }
[17:43:51.951] Lazy evaluation: FALSE
[17:43:51.951] Asynchronous evaluation: FALSE
[17:43:51.951] Local evaluation: TRUE
[17:43:51.951] Environment: R_GlobalEnv
[17:43:51.951] Capture standard output: TRUE
[17:43:51.951] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:51.951] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:51.951] Packages: <none>
[17:43:51.951] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:51.951] Resolved: TRUE
[17:43:51.951] Value: 4.62 KiB of class ‘list’
[17:43:51.951] Early signaling: FALSE
[17:43:51.951] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:51.951] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:51.952] Chunk #1 of 1 ... DONE
[17:43:51.953] Launching 1 futures (chunks) ... DONE
[17:43:51.953] Resolving 1 futures (chunks) ...
[17:43:51.953] resolve() on list ...
[17:43:51.953]  recursive: 0
[17:43:51.953]  length: 1
[17:43:51.953] 
[17:43:51.953] resolved() for ‘SequentialFuture’ ...
[17:43:51.953] - state: ‘finished’
[17:43:51.954] - run: TRUE
[17:43:51.954] - result: ‘FutureResult’
[17:43:51.954] resolved() for ‘SequentialFuture’ ... done
[17:43:51.954] Future #1
[17:43:51.954] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:51.954] - nx: 1
[17:43:51.954] - relay: TRUE
[17:43:51.954] - stdout: TRUE
[17:43:51.955] - signal: TRUE
[17:43:51.955] - resignal: FALSE
[17:43:51.955] - force: TRUE
[17:43:51.955] - relayed: [n=1] FALSE
[17:43:51.955] - queued futures: [n=1] FALSE
[17:43:51.955]  - until=1
[17:43:51.955]  - relaying element #1
[17:43:51.955] - relayed: [n=1] TRUE
[17:43:51.955] - queued futures: [n=1] TRUE
[17:43:51.955] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:51.956]  length: 0 (resolved future 1)
[17:43:51.956] Relaying remaining futures
[17:43:51.956] signalConditionsASAP(NULL, pos=0) ...
[17:43:51.956] - nx: 1
[17:43:51.956] - relay: TRUE
[17:43:51.956] - stdout: TRUE
[17:43:51.956] - signal: TRUE
[17:43:51.956] - resignal: FALSE
[17:43:51.956] - force: TRUE
[17:43:51.956] - relayed: [n=1] TRUE
[17:43:51.957] - queued futures: [n=1] TRUE
 - flush all
[17:43:51.957] - relayed: [n=1] TRUE
[17:43:51.957] - queued futures: [n=1] TRUE
[17:43:51.957] signalConditionsASAP(NULL, pos=0) ... done
[17:43:51.957] resolve() on list ... DONE
[17:43:51.957]  - Number of value chunks collected: 1
[17:43:51.957] Resolving 1 futures (chunks) ... DONE
[17:43:51.957] Reducing values from 1 chunks ...
[17:43:51.957]  - Number of values collected after concatenation: 3
[17:43:51.957]  - Number of values expected: 3
[17:43:51.958] Reducing values from 1 chunks ... DONE
[17:43:51.958] future_lapply() ... DONE
[17:43:51.958] future_by_internal() ... DONE
[17:43:51.958] future_by_internal() ...
[17:43:51.959] future_lapply() ...
[17:43:51.959] Number of chunks: 1
[17:43:51.959] getGlobalsAndPackagesXApply() ...
[17:43:51.959]  - future.globals: TRUE
[17:43:51.960] getGlobalsAndPackages() ...
[17:43:51.960] Searching for globals...
[17:43:51.961] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:51.961] Searching for globals ... DONE
[17:43:51.961] Resolving globals: FALSE
[17:43:51.961] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:51.962] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:51.962] - globals: [1] ‘FUN’
[17:43:51.962] 
[17:43:51.962] getGlobalsAndPackages() ... DONE
[17:43:51.962]  - globals found/used: [n=1] ‘FUN’
[17:43:51.962]  - needed namespaces: [n=0] 
[17:43:51.962] Finding globals ... DONE
[17:43:51.962]  - use_args: TRUE
[17:43:51.962]  - Getting '...' globals ...
[17:43:51.963] resolve() on list ...
[17:43:51.963]  recursive: 0
[17:43:51.963]  length: 1
[17:43:51.963]  elements: ‘...’
[17:43:51.963]  length: 0 (resolved future 1)
[17:43:51.963] resolve() on list ... DONE
[17:43:51.963]    - '...' content: [n=1] ‘digits’
[17:43:51.963] List of 1
[17:43:51.963]  $ ...:List of 1
[17:43:51.963]   ..$ digits: int 2
[17:43:51.963]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.963]  - attr(*, "where")=List of 1
[17:43:51.963]   ..$ ...:<environment: 0x55d6baeba278> 
[17:43:51.963]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.963]  - attr(*, "resolved")= logi TRUE
[17:43:51.963]  - attr(*, "total_size")= num NA
[17:43:51.968]  - Getting '...' globals ... DONE
[17:43:51.968] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:51.968] List of 2
[17:43:51.968]  $ ...future.FUN:function (object, ...)  
[17:43:51.968]  $ ...          :List of 1
[17:43:51.968]   ..$ digits: int 2
[17:43:51.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.968]  - attr(*, "where")=List of 2
[17:43:51.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:51.968]   ..$ ...          :<environment: 0x55d6baeba278> 
[17:43:51.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.968]  - attr(*, "resolved")= logi FALSE
[17:43:51.968]  - attr(*, "total_size")= num 1296
[17:43:51.971] Packages to be attached in all futures: [n=0] 
[17:43:51.971] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.971] Number of futures (= number of chunks): 1
[17:43:51.971] Launching 1 futures (chunks) ...
[17:43:51.972] Chunk #1 of 1 ...
[17:43:51.972]  - Finding globals in 'X' for chunk #1 ...
[17:43:51.972] getGlobalsAndPackages() ...
[17:43:51.972] Searching for globals...
[17:43:51.972] 
[17:43:51.972] Searching for globals ... DONE
[17:43:51.972] - globals: [0] <none>
[17:43:51.972] getGlobalsAndPackages() ... DONE
[17:43:51.972]    + additional globals found: [n=0] 
[17:43:51.973]    + additional namespaces needed: [n=0] 
[17:43:51.973]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:51.973]  - seeds: <none>
[17:43:51.973]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.973] getGlobalsAndPackages() ...
[17:43:51.973] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.973] Resolving globals: FALSE
[17:43:51.973] Tweak future expression to call with '...' arguments ...
[17:43:51.973] {
[17:43:51.973]     do.call(function(...) {
[17:43:51.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.973]             on.exit(options(oopts), add = TRUE)
[17:43:51.973]         }
[17:43:51.973]         {
[17:43:51.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.973]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.973]             })
[17:43:51.973]         }
[17:43:51.973]     }, args = future.call.arguments)
[17:43:51.973] }
[17:43:51.974] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.974] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.974] 
[17:43:51.974] getGlobalsAndPackages() ... DONE
[17:43:51.974] run() for ‘Future’ ...
[17:43:51.975] - state: ‘created’
[17:43:51.975] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:51.975] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:51.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:51.975]   - Field: ‘label’
[17:43:51.975]   - Field: ‘local’
[17:43:51.975]   - Field: ‘owner’
[17:43:51.975]   - Field: ‘envir’
[17:43:51.976]   - Field: ‘packages’
[17:43:51.976]   - Field: ‘gc’
[17:43:51.976]   - Field: ‘conditions’
[17:43:51.976]   - Field: ‘expr’
[17:43:51.976]   - Field: ‘uuid’
[17:43:51.976]   - Field: ‘seed’
[17:43:51.976]   - Field: ‘version’
[17:43:51.976]   - Field: ‘result’
[17:43:51.976]   - Field: ‘asynchronous’
[17:43:51.976]   - Field: ‘calls’
[17:43:51.976]   - Field: ‘globals’
[17:43:51.977]   - Field: ‘stdout’
[17:43:51.977]   - Field: ‘earlySignal’
[17:43:51.977]   - Field: ‘lazy’
[17:43:51.977]   - Field: ‘state’
[17:43:51.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:51.977] - Launch lazy future ...
[17:43:51.977] Packages needed by the future expression (n = 0): <none>
[17:43:51.977] Packages needed by future strategies (n = 0): <none>
[17:43:51.978] {
[17:43:51.978]     {
[17:43:51.978]         {
[17:43:51.978]             ...future.startTime <- base::Sys.time()
[17:43:51.978]             {
[17:43:51.978]                 {
[17:43:51.978]                   {
[17:43:51.978]                     base::local({
[17:43:51.978]                       has_future <- base::requireNamespace("future", 
[17:43:51.978]                         quietly = TRUE)
[17:43:51.978]                       if (has_future) {
[17:43:51.978]                         ns <- base::getNamespace("future")
[17:43:51.978]                         version <- ns[[".package"]][["version"]]
[17:43:51.978]                         if (is.null(version)) 
[17:43:51.978]                           version <- utils::packageVersion("future")
[17:43:51.978]                       }
[17:43:51.978]                       else {
[17:43:51.978]                         version <- NULL
[17:43:51.978]                       }
[17:43:51.978]                       if (!has_future || version < "1.8.0") {
[17:43:51.978]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.978]                           "", base::R.version$version.string), 
[17:43:51.978]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:51.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.978]                             "release", "version")], collapse = " "), 
[17:43:51.978]                           hostname = base::Sys.info()[["nodename"]])
[17:43:51.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.978]                           info)
[17:43:51.978]                         info <- base::paste(info, collapse = "; ")
[17:43:51.978]                         if (!has_future) {
[17:43:51.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.978]                             info)
[17:43:51.978]                         }
[17:43:51.978]                         else {
[17:43:51.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.978]                             info, version)
[17:43:51.978]                         }
[17:43:51.978]                         base::stop(msg)
[17:43:51.978]                       }
[17:43:51.978]                     })
[17:43:51.978]                   }
[17:43:51.978]                   ...future.strategy.old <- future::plan("list")
[17:43:51.978]                   options(future.plan = NULL)
[17:43:51.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.978]                 }
[17:43:51.978]                 ...future.workdir <- getwd()
[17:43:51.978]             }
[17:43:51.978]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.978]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.978]         }
[17:43:51.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:51.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.978]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.978]             base::names(...future.oldOptions))
[17:43:51.978]     }
[17:43:51.978]     if (FALSE) {
[17:43:51.978]     }
[17:43:51.978]     else {
[17:43:51.978]         if (TRUE) {
[17:43:51.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.978]                 open = "w")
[17:43:51.978]         }
[17:43:51.978]         else {
[17:43:51.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.978]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.978]         }
[17:43:51.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.978]             base::sink(type = "output", split = FALSE)
[17:43:51.978]             base::close(...future.stdout)
[17:43:51.978]         }, add = TRUE)
[17:43:51.978]     }
[17:43:51.978]     ...future.frame <- base::sys.nframe()
[17:43:51.978]     ...future.conditions <- base::list()
[17:43:51.978]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.978]     if (FALSE) {
[17:43:51.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.978]     }
[17:43:51.978]     ...future.result <- base::tryCatch({
[17:43:51.978]         base::withCallingHandlers({
[17:43:51.978]             ...future.value <- base::withVisible(base::local({
[17:43:51.978]                 do.call(function(...) {
[17:43:51.978]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.978]                   if (!identical(...future.globals.maxSize.org, 
[17:43:51.978]                     ...future.globals.maxSize)) {
[17:43:51.978]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.978]                     on.exit(options(oopts), add = TRUE)
[17:43:51.978]                   }
[17:43:51.978]                   {
[17:43:51.978]                     lapply(seq_along(...future.elements_ii), 
[17:43:51.978]                       FUN = function(jj) {
[17:43:51.978]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.978]                         ...future.FUN(...future.X_jj, ...)
[17:43:51.978]                       })
[17:43:51.978]                   }
[17:43:51.978]                 }, args = future.call.arguments)
[17:43:51.978]             }))
[17:43:51.978]             future::FutureResult(value = ...future.value$value, 
[17:43:51.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.978]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.978]                     ...future.globalenv.names))
[17:43:51.978]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.978]         }, condition = base::local({
[17:43:51.978]             c <- base::c
[17:43:51.978]             inherits <- base::inherits
[17:43:51.978]             invokeRestart <- base::invokeRestart
[17:43:51.978]             length <- base::length
[17:43:51.978]             list <- base::list
[17:43:51.978]             seq.int <- base::seq.int
[17:43:51.978]             signalCondition <- base::signalCondition
[17:43:51.978]             sys.calls <- base::sys.calls
[17:43:51.978]             `[[` <- base::`[[`
[17:43:51.978]             `+` <- base::`+`
[17:43:51.978]             `<<-` <- base::`<<-`
[17:43:51.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.978]                   3L)]
[17:43:51.978]             }
[17:43:51.978]             function(cond) {
[17:43:51.978]                 is_error <- inherits(cond, "error")
[17:43:51.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.978]                   NULL)
[17:43:51.978]                 if (is_error) {
[17:43:51.978]                   sessionInformation <- function() {
[17:43:51.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.978]                       search = base::search(), system = base::Sys.info())
[17:43:51.978]                   }
[17:43:51.978]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.978]                     cond$call), session = sessionInformation(), 
[17:43:51.978]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.978]                   signalCondition(cond)
[17:43:51.978]                 }
[17:43:51.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.978]                 "immediateCondition"))) {
[17:43:51.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.978]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.978]                   if (TRUE && !signal) {
[17:43:51.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.978]                     {
[17:43:51.978]                       inherits <- base::inherits
[17:43:51.978]                       invokeRestart <- base::invokeRestart
[17:43:51.978]                       is.null <- base::is.null
[17:43:51.978]                       muffled <- FALSE
[17:43:51.978]                       if (inherits(cond, "message")) {
[17:43:51.978]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.978]                         if (muffled) 
[17:43:51.978]                           invokeRestart("muffleMessage")
[17:43:51.978]                       }
[17:43:51.978]                       else if (inherits(cond, "warning")) {
[17:43:51.978]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.978]                         if (muffled) 
[17:43:51.978]                           invokeRestart("muffleWarning")
[17:43:51.978]                       }
[17:43:51.978]                       else if (inherits(cond, "condition")) {
[17:43:51.978]                         if (!is.null(pattern)) {
[17:43:51.978]                           computeRestarts <- base::computeRestarts
[17:43:51.978]                           grepl <- base::grepl
[17:43:51.978]                           restarts <- computeRestarts(cond)
[17:43:51.978]                           for (restart in restarts) {
[17:43:51.978]                             name <- restart$name
[17:43:51.978]                             if (is.null(name)) 
[17:43:51.978]                               next
[17:43:51.978]                             if (!grepl(pattern, name)) 
[17:43:51.978]                               next
[17:43:51.978]                             invokeRestart(restart)
[17:43:51.978]                             muffled <- TRUE
[17:43:51.978]                             break
[17:43:51.978]                           }
[17:43:51.978]                         }
[17:43:51.978]                       }
[17:43:51.978]                       invisible(muffled)
[17:43:51.978]                     }
[17:43:51.978]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.978]                   }
[17:43:51.978]                 }
[17:43:51.978]                 else {
[17:43:51.978]                   if (TRUE) {
[17:43:51.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.978]                     {
[17:43:51.978]                       inherits <- base::inherits
[17:43:51.978]                       invokeRestart <- base::invokeRestart
[17:43:51.978]                       is.null <- base::is.null
[17:43:51.978]                       muffled <- FALSE
[17:43:51.978]                       if (inherits(cond, "message")) {
[17:43:51.978]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.978]                         if (muffled) 
[17:43:51.978]                           invokeRestart("muffleMessage")
[17:43:51.978]                       }
[17:43:51.978]                       else if (inherits(cond, "warning")) {
[17:43:51.978]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.978]                         if (muffled) 
[17:43:51.978]                           invokeRestart("muffleWarning")
[17:43:51.978]                       }
[17:43:51.978]                       else if (inherits(cond, "condition")) {
[17:43:51.978]                         if (!is.null(pattern)) {
[17:43:51.978]                           computeRestarts <- base::computeRestarts
[17:43:51.978]                           grepl <- base::grepl
[17:43:51.978]                           restarts <- computeRestarts(cond)
[17:43:51.978]                           for (restart in restarts) {
[17:43:51.978]                             name <- restart$name
[17:43:51.978]                             if (is.null(name)) 
[17:43:51.978]                               next
[17:43:51.978]                             if (!grepl(pattern, name)) 
[17:43:51.978]                               next
[17:43:51.978]                             invokeRestart(restart)
[17:43:51.978]                             muffled <- TRUE
[17:43:51.978]                             break
[17:43:51.978]                           }
[17:43:51.978]                         }
[17:43:51.978]                       }
[17:43:51.978]                       invisible(muffled)
[17:43:51.978]                     }
[17:43:51.978]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.978]                   }
[17:43:51.978]                 }
[17:43:51.978]             }
[17:43:51.978]         }))
[17:43:51.978]     }, error = function(ex) {
[17:43:51.978]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.978]                 ...future.rng), started = ...future.startTime, 
[17:43:51.978]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.978]             version = "1.8"), class = "FutureResult")
[17:43:51.978]     }, finally = {
[17:43:51.978]         if (!identical(...future.workdir, getwd())) 
[17:43:51.978]             setwd(...future.workdir)
[17:43:51.978]         {
[17:43:51.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.978]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.978]             }
[17:43:51.978]             base::options(...future.oldOptions)
[17:43:51.978]             if (.Platform$OS.type == "windows") {
[17:43:51.978]                 old_names <- names(...future.oldEnvVars)
[17:43:51.978]                 envs <- base::Sys.getenv()
[17:43:51.978]                 names <- names(envs)
[17:43:51.978]                 common <- intersect(names, old_names)
[17:43:51.978]                 added <- setdiff(names, old_names)
[17:43:51.978]                 removed <- setdiff(old_names, names)
[17:43:51.978]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.978]                   envs[common]]
[17:43:51.978]                 NAMES <- toupper(changed)
[17:43:51.978]                 args <- list()
[17:43:51.978]                 for (kk in seq_along(NAMES)) {
[17:43:51.978]                   name <- changed[[kk]]
[17:43:51.978]                   NAME <- NAMES[[kk]]
[17:43:51.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.978]                     next
[17:43:51.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.978]                 }
[17:43:51.978]                 NAMES <- toupper(added)
[17:43:51.978]                 for (kk in seq_along(NAMES)) {
[17:43:51.978]                   name <- added[[kk]]
[17:43:51.978]                   NAME <- NAMES[[kk]]
[17:43:51.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.978]                     next
[17:43:51.978]                   args[[name]] <- ""
[17:43:51.978]                 }
[17:43:51.978]                 NAMES <- toupper(removed)
[17:43:51.978]                 for (kk in seq_along(NAMES)) {
[17:43:51.978]                   name <- removed[[kk]]
[17:43:51.978]                   NAME <- NAMES[[kk]]
[17:43:51.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.978]                     next
[17:43:51.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.978]                 }
[17:43:51.978]                 if (length(args) > 0) 
[17:43:51.978]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.978]             }
[17:43:51.978]             else {
[17:43:51.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.978]             }
[17:43:51.978]             {
[17:43:51.978]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.978]                   0L) {
[17:43:51.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.978]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.978]                   base::options(opts)
[17:43:51.978]                 }
[17:43:51.978]                 {
[17:43:51.978]                   {
[17:43:51.978]                     NULL
[17:43:51.978]                     RNGkind("Mersenne-Twister")
[17:43:51.978]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:51.978]                       inherits = FALSE)
[17:43:51.978]                   }
[17:43:51.978]                   options(future.plan = NULL)
[17:43:51.978]                   if (is.na(NA_character_)) 
[17:43:51.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.978]                     .init = FALSE)
[17:43:51.978]                 }
[17:43:51.978]             }
[17:43:51.978]         }
[17:43:51.978]     })
[17:43:51.978]     if (TRUE) {
[17:43:51.978]         base::sink(type = "output", split = FALSE)
[17:43:51.978]         if (TRUE) {
[17:43:51.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.978]         }
[17:43:51.978]         else {
[17:43:51.978]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.978]         }
[17:43:51.978]         base::close(...future.stdout)
[17:43:51.978]         ...future.stdout <- NULL
[17:43:51.978]     }
[17:43:51.978]     ...future.result$conditions <- ...future.conditions
[17:43:51.978]     ...future.result$finished <- base::Sys.time()
[17:43:51.978]     ...future.result
[17:43:51.978] }
[17:43:51.979] assign_globals() ...
[17:43:51.979] List of 5
[17:43:51.979]  $ ...future.FUN            :function (object, ...)  
[17:43:51.979]  $ future.call.arguments    :List of 1
[17:43:51.979]   ..$ digits: int 2
[17:43:51.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.979]  $ ...future.elements_ii    :List of 6
[17:43:51.979]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:43:51.979]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:43:51.979]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:43:51.979]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:43:51.979]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:43:51.979]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:43:51.979]  $ ...future.seeds_ii       : NULL
[17:43:51.979]  $ ...future.globals.maxSize: NULL
[17:43:51.979]  - attr(*, "where")=List of 5
[17:43:51.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:51.979]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:51.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:51.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:51.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:51.979]  - attr(*, "resolved")= logi FALSE
[17:43:51.979]  - attr(*, "total_size")= num 1296
[17:43:51.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.979]  - attr(*, "already-done")= logi TRUE
[17:43:51.986] - copied ‘...future.FUN’ to environment
[17:43:51.986] - copied ‘future.call.arguments’ to environment
[17:43:51.986] - copied ‘...future.elements_ii’ to environment
[17:43:51.986] - copied ‘...future.seeds_ii’ to environment
[17:43:51.986] - copied ‘...future.globals.maxSize’ to environment
[17:43:51.986] assign_globals() ... done
[17:43:51.986] plan(): Setting new future strategy stack:
[17:43:51.986] List of future strategies:
[17:43:51.986] 1. sequential:
[17:43:51.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.986]    - tweaked: FALSE
[17:43:51.986]    - call: NULL
[17:43:51.987] plan(): nbrOfWorkers() = 1
[17:43:51.990] plan(): Setting new future strategy stack:
[17:43:51.990] List of future strategies:
[17:43:51.990] 1. sequential:
[17:43:51.990]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.990]    - tweaked: FALSE
[17:43:51.990]    - call: plan(strategy)
[17:43:51.990] plan(): nbrOfWorkers() = 1
[17:43:51.990] SequentialFuture started (and completed)
[17:43:51.990] - Launch lazy future ... done
[17:43:51.990] run() for ‘SequentialFuture’ ... done
[17:43:51.991] Created future:
[17:43:51.991] SequentialFuture:
[17:43:51.991] Label: ‘future_by-1’
[17:43:51.991] Expression:
[17:43:51.991] {
[17:43:51.991]     do.call(function(...) {
[17:43:51.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.991]             on.exit(options(oopts), add = TRUE)
[17:43:51.991]         }
[17:43:51.991]         {
[17:43:51.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.991]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.991]             })
[17:43:51.991]         }
[17:43:51.991]     }, args = future.call.arguments)
[17:43:51.991] }
[17:43:51.991] Lazy evaluation: FALSE
[17:43:51.991] Asynchronous evaluation: FALSE
[17:43:51.991] Local evaluation: TRUE
[17:43:51.991] Environment: R_GlobalEnv
[17:43:51.991] Capture standard output: TRUE
[17:43:51.991] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:51.991] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:51.991] Packages: <none>
[17:43:51.991] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:51.991] Resolved: TRUE
[17:43:51.991] Value: 5.48 KiB of class ‘list’
[17:43:51.991] Early signaling: FALSE
[17:43:51.991] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:51.991] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:51.992] Chunk #1 of 1 ... DONE
[17:43:51.992] Launching 1 futures (chunks) ... DONE
[17:43:51.992] Resolving 1 futures (chunks) ...
[17:43:51.992] resolve() on list ...
[17:43:51.992]  recursive: 0
[17:43:51.992]  length: 1
[17:43:51.992] 
[17:43:51.992] resolved() for ‘SequentialFuture’ ...
[17:43:51.992] - state: ‘finished’
[17:43:51.992] - run: TRUE
[17:43:51.993] - result: ‘FutureResult’
[17:43:51.993] resolved() for ‘SequentialFuture’ ... done
[17:43:51.993] Future #1
[17:43:51.993] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:51.993] - nx: 1
[17:43:51.993] - relay: TRUE
[17:43:51.993] - stdout: TRUE
[17:43:51.993] - signal: TRUE
[17:43:51.993] - resignal: FALSE
[17:43:51.993] - force: TRUE
[17:43:51.993] - relayed: [n=1] FALSE
[17:43:51.994] - queued futures: [n=1] FALSE
[17:43:51.994]  - until=1
[17:43:51.994]  - relaying element #1
[17:43:51.994] - relayed: [n=1] TRUE
[17:43:51.994] - queued futures: [n=1] TRUE
[17:43:51.994] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:51.994]  length: 0 (resolved future 1)
[17:43:51.994] Relaying remaining futures
[17:43:51.994] signalConditionsASAP(NULL, pos=0) ...
[17:43:51.994] - nx: 1
[17:43:51.995] - relay: TRUE
[17:43:51.995] - stdout: TRUE
[17:43:51.995] - signal: TRUE
[17:43:51.995] - resignal: FALSE
[17:43:51.995] - force: TRUE
[17:43:51.995] - relayed: [n=1] TRUE
[17:43:51.995] - queued futures: [n=1] TRUE
 - flush all
[17:43:51.995] - relayed: [n=1] TRUE
[17:43:51.995] - queued futures: [n=1] TRUE
[17:43:51.995] signalConditionsASAP(NULL, pos=0) ... done
[17:43:51.995] resolve() on list ... DONE
[17:43:51.996]  - Number of value chunks collected: 1
[17:43:51.996] Resolving 1 futures (chunks) ... DONE
[17:43:51.996] Reducing values from 1 chunks ...
[17:43:51.996]  - Number of values collected after concatenation: 6
[17:43:51.996]  - Number of values expected: 6
[17:43:51.996] Reducing values from 1 chunks ... DONE
[17:43:51.996] future_lapply() ... DONE
[17:43:51.996] future_by_internal() ... DONE
[17:43:51.999] future_by_internal() ...
[17:43:52.000] future_lapply() ...
[17:43:52.000] Number of chunks: 1
[17:43:52.001] getGlobalsAndPackagesXApply() ...
[17:43:52.001]  - future.globals: TRUE
[17:43:52.001] getGlobalsAndPackages() ...
[17:43:52.001] Searching for globals...
[17:43:52.002] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.002] Searching for globals ... DONE
[17:43:52.002] Resolving globals: FALSE
[17:43:52.003] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:43:52.003] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:43:52.003] - globals: [1] ‘FUN’
[17:43:52.004] - packages: [1] ‘stats’
[17:43:52.004] getGlobalsAndPackages() ... DONE
[17:43:52.004]  - globals found/used: [n=1] ‘FUN’
[17:43:52.004]  - needed namespaces: [n=1] ‘stats’
[17:43:52.004] Finding globals ... DONE
[17:43:52.004]  - use_args: TRUE
[17:43:52.004]  - Getting '...' globals ...
[17:43:52.004] resolve() on list ...
[17:43:52.004]  recursive: 0
[17:43:52.005]  length: 1
[17:43:52.005]  elements: ‘...’
[17:43:52.005]  length: 0 (resolved future 1)
[17:43:52.005] resolve() on list ... DONE
[17:43:52.005]    - '...' content: [n=1] ‘singular.ok’
[17:43:52.005] List of 1
[17:43:52.005]  $ ...:List of 1
[17:43:52.005]   ..$ singular.ok: logi FALSE
[17:43:52.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.005]  - attr(*, "where")=List of 1
[17:43:52.005]   ..$ ...:<environment: 0x55d6bab827d8> 
[17:43:52.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.005]  - attr(*, "resolved")= logi TRUE
[17:43:52.005]  - attr(*, "total_size")= num NA
[17:43:52.008]  - Getting '...' globals ... DONE
[17:43:52.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.008] List of 2
[17:43:52.008]  $ ...future.FUN:function (x, ...)  
[17:43:52.008]  $ ...          :List of 1
[17:43:52.008]   ..$ singular.ok: logi FALSE
[17:43:52.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.008]  - attr(*, "where")=List of 2
[17:43:52.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.008]   ..$ ...          :<environment: 0x55d6bab827d8> 
[17:43:52.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.008]  - attr(*, "resolved")= logi FALSE
[17:43:52.008]  - attr(*, "total_size")= num 5384
[17:43:52.012] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.012] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.012] Number of futures (= number of chunks): 1
[17:43:52.013] Launching 1 futures (chunks) ...
[17:43:52.013] Chunk #1 of 1 ...
[17:43:52.013]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.013] getGlobalsAndPackages() ...
[17:43:52.013] Searching for globals...
[17:43:52.013] 
[17:43:52.014] Searching for globals ... DONE
[17:43:52.014] - globals: [0] <none>
[17:43:52.014] getGlobalsAndPackages() ... DONE
[17:43:52.014]    + additional globals found: [n=0] 
[17:43:52.014]    + additional namespaces needed: [n=0] 
[17:43:52.014]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.014]  - seeds: <none>
[17:43:52.014]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.014] getGlobalsAndPackages() ...
[17:43:52.014] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.014] Resolving globals: FALSE
[17:43:52.015] Tweak future expression to call with '...' arguments ...
[17:43:52.015] {
[17:43:52.015]     do.call(function(...) {
[17:43:52.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.015]             on.exit(options(oopts), add = TRUE)
[17:43:52.015]         }
[17:43:52.015]         {
[17:43:52.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.015]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.015]             })
[17:43:52.015]         }
[17:43:52.015]     }, args = future.call.arguments)
[17:43:52.015] }
[17:43:52.015] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.015] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.015] 
[17:43:52.015] getGlobalsAndPackages() ... DONE
[17:43:52.016] run() for ‘Future’ ...
[17:43:52.016] - state: ‘created’
[17:43:52.016] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.016] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.016]   - Field: ‘label’
[17:43:52.017]   - Field: ‘local’
[17:43:52.017]   - Field: ‘owner’
[17:43:52.017]   - Field: ‘envir’
[17:43:52.017]   - Field: ‘packages’
[17:43:52.017]   - Field: ‘gc’
[17:43:52.017]   - Field: ‘conditions’
[17:43:52.017]   - Field: ‘expr’
[17:43:52.017]   - Field: ‘uuid’
[17:43:52.017]   - Field: ‘seed’
[17:43:52.017]   - Field: ‘version’
[17:43:52.017]   - Field: ‘result’
[17:43:52.017]   - Field: ‘asynchronous’
[17:43:52.018]   - Field: ‘calls’
[17:43:52.018]   - Field: ‘globals’
[17:43:52.018]   - Field: ‘stdout’
[17:43:52.018]   - Field: ‘earlySignal’
[17:43:52.018]   - Field: ‘lazy’
[17:43:52.018]   - Field: ‘state’
[17:43:52.018] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.018] - Launch lazy future ...
[17:43:52.018] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.018] Packages needed by future strategies (n = 0): <none>
[17:43:52.019] {
[17:43:52.019]     {
[17:43:52.019]         {
[17:43:52.019]             ...future.startTime <- base::Sys.time()
[17:43:52.019]             {
[17:43:52.019]                 {
[17:43:52.019]                   {
[17:43:52.019]                     {
[17:43:52.019]                       base::local({
[17:43:52.019]                         has_future <- base::requireNamespace("future", 
[17:43:52.019]                           quietly = TRUE)
[17:43:52.019]                         if (has_future) {
[17:43:52.019]                           ns <- base::getNamespace("future")
[17:43:52.019]                           version <- ns[[".package"]][["version"]]
[17:43:52.019]                           if (is.null(version)) 
[17:43:52.019]                             version <- utils::packageVersion("future")
[17:43:52.019]                         }
[17:43:52.019]                         else {
[17:43:52.019]                           version <- NULL
[17:43:52.019]                         }
[17:43:52.019]                         if (!has_future || version < "1.8.0") {
[17:43:52.019]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.019]                             "", base::R.version$version.string), 
[17:43:52.019]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.019]                               "release", "version")], collapse = " "), 
[17:43:52.019]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.019]                             info)
[17:43:52.019]                           info <- base::paste(info, collapse = "; ")
[17:43:52.019]                           if (!has_future) {
[17:43:52.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.019]                               info)
[17:43:52.019]                           }
[17:43:52.019]                           else {
[17:43:52.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.019]                               info, version)
[17:43:52.019]                           }
[17:43:52.019]                           base::stop(msg)
[17:43:52.019]                         }
[17:43:52.019]                       })
[17:43:52.019]                     }
[17:43:52.019]                     base::local({
[17:43:52.019]                       for (pkg in "stats") {
[17:43:52.019]                         base::loadNamespace(pkg)
[17:43:52.019]                         base::library(pkg, character.only = TRUE)
[17:43:52.019]                       }
[17:43:52.019]                     })
[17:43:52.019]                   }
[17:43:52.019]                   ...future.strategy.old <- future::plan("list")
[17:43:52.019]                   options(future.plan = NULL)
[17:43:52.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.019]                 }
[17:43:52.019]                 ...future.workdir <- getwd()
[17:43:52.019]             }
[17:43:52.019]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.019]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.019]         }
[17:43:52.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.019]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.019]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.019]             base::names(...future.oldOptions))
[17:43:52.019]     }
[17:43:52.019]     if (FALSE) {
[17:43:52.019]     }
[17:43:52.019]     else {
[17:43:52.019]         if (TRUE) {
[17:43:52.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.019]                 open = "w")
[17:43:52.019]         }
[17:43:52.019]         else {
[17:43:52.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.019]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.019]         }
[17:43:52.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.019]             base::sink(type = "output", split = FALSE)
[17:43:52.019]             base::close(...future.stdout)
[17:43:52.019]         }, add = TRUE)
[17:43:52.019]     }
[17:43:52.019]     ...future.frame <- base::sys.nframe()
[17:43:52.019]     ...future.conditions <- base::list()
[17:43:52.019]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.019]     if (FALSE) {
[17:43:52.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.019]     }
[17:43:52.019]     ...future.result <- base::tryCatch({
[17:43:52.019]         base::withCallingHandlers({
[17:43:52.019]             ...future.value <- base::withVisible(base::local({
[17:43:52.019]                 do.call(function(...) {
[17:43:52.019]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.019]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.019]                     ...future.globals.maxSize)) {
[17:43:52.019]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.019]                     on.exit(options(oopts), add = TRUE)
[17:43:52.019]                   }
[17:43:52.019]                   {
[17:43:52.019]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.019]                       FUN = function(jj) {
[17:43:52.019]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.019]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.019]                       })
[17:43:52.019]                   }
[17:43:52.019]                 }, args = future.call.arguments)
[17:43:52.019]             }))
[17:43:52.019]             future::FutureResult(value = ...future.value$value, 
[17:43:52.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.019]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.019]                     ...future.globalenv.names))
[17:43:52.019]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.019]         }, condition = base::local({
[17:43:52.019]             c <- base::c
[17:43:52.019]             inherits <- base::inherits
[17:43:52.019]             invokeRestart <- base::invokeRestart
[17:43:52.019]             length <- base::length
[17:43:52.019]             list <- base::list
[17:43:52.019]             seq.int <- base::seq.int
[17:43:52.019]             signalCondition <- base::signalCondition
[17:43:52.019]             sys.calls <- base::sys.calls
[17:43:52.019]             `[[` <- base::`[[`
[17:43:52.019]             `+` <- base::`+`
[17:43:52.019]             `<<-` <- base::`<<-`
[17:43:52.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.019]                   3L)]
[17:43:52.019]             }
[17:43:52.019]             function(cond) {
[17:43:52.019]                 is_error <- inherits(cond, "error")
[17:43:52.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.019]                   NULL)
[17:43:52.019]                 if (is_error) {
[17:43:52.019]                   sessionInformation <- function() {
[17:43:52.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.019]                       search = base::search(), system = base::Sys.info())
[17:43:52.019]                   }
[17:43:52.019]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.019]                     cond$call), session = sessionInformation(), 
[17:43:52.019]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.019]                   signalCondition(cond)
[17:43:52.019]                 }
[17:43:52.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.019]                 "immediateCondition"))) {
[17:43:52.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.019]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.019]                   if (TRUE && !signal) {
[17:43:52.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.019]                     {
[17:43:52.019]                       inherits <- base::inherits
[17:43:52.019]                       invokeRestart <- base::invokeRestart
[17:43:52.019]                       is.null <- base::is.null
[17:43:52.019]                       muffled <- FALSE
[17:43:52.019]                       if (inherits(cond, "message")) {
[17:43:52.019]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.019]                         if (muffled) 
[17:43:52.019]                           invokeRestart("muffleMessage")
[17:43:52.019]                       }
[17:43:52.019]                       else if (inherits(cond, "warning")) {
[17:43:52.019]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.019]                         if (muffled) 
[17:43:52.019]                           invokeRestart("muffleWarning")
[17:43:52.019]                       }
[17:43:52.019]                       else if (inherits(cond, "condition")) {
[17:43:52.019]                         if (!is.null(pattern)) {
[17:43:52.019]                           computeRestarts <- base::computeRestarts
[17:43:52.019]                           grepl <- base::grepl
[17:43:52.019]                           restarts <- computeRestarts(cond)
[17:43:52.019]                           for (restart in restarts) {
[17:43:52.019]                             name <- restart$name
[17:43:52.019]                             if (is.null(name)) 
[17:43:52.019]                               next
[17:43:52.019]                             if (!grepl(pattern, name)) 
[17:43:52.019]                               next
[17:43:52.019]                             invokeRestart(restart)
[17:43:52.019]                             muffled <- TRUE
[17:43:52.019]                             break
[17:43:52.019]                           }
[17:43:52.019]                         }
[17:43:52.019]                       }
[17:43:52.019]                       invisible(muffled)
[17:43:52.019]                     }
[17:43:52.019]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.019]                   }
[17:43:52.019]                 }
[17:43:52.019]                 else {
[17:43:52.019]                   if (TRUE) {
[17:43:52.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.019]                     {
[17:43:52.019]                       inherits <- base::inherits
[17:43:52.019]                       invokeRestart <- base::invokeRestart
[17:43:52.019]                       is.null <- base::is.null
[17:43:52.019]                       muffled <- FALSE
[17:43:52.019]                       if (inherits(cond, "message")) {
[17:43:52.019]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.019]                         if (muffled) 
[17:43:52.019]                           invokeRestart("muffleMessage")
[17:43:52.019]                       }
[17:43:52.019]                       else if (inherits(cond, "warning")) {
[17:43:52.019]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.019]                         if (muffled) 
[17:43:52.019]                           invokeRestart("muffleWarning")
[17:43:52.019]                       }
[17:43:52.019]                       else if (inherits(cond, "condition")) {
[17:43:52.019]                         if (!is.null(pattern)) {
[17:43:52.019]                           computeRestarts <- base::computeRestarts
[17:43:52.019]                           grepl <- base::grepl
[17:43:52.019]                           restarts <- computeRestarts(cond)
[17:43:52.019]                           for (restart in restarts) {
[17:43:52.019]                             name <- restart$name
[17:43:52.019]                             if (is.null(name)) 
[17:43:52.019]                               next
[17:43:52.019]                             if (!grepl(pattern, name)) 
[17:43:52.019]                               next
[17:43:52.019]                             invokeRestart(restart)
[17:43:52.019]                             muffled <- TRUE
[17:43:52.019]                             break
[17:43:52.019]                           }
[17:43:52.019]                         }
[17:43:52.019]                       }
[17:43:52.019]                       invisible(muffled)
[17:43:52.019]                     }
[17:43:52.019]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.019]                   }
[17:43:52.019]                 }
[17:43:52.019]             }
[17:43:52.019]         }))
[17:43:52.019]     }, error = function(ex) {
[17:43:52.019]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.019]                 ...future.rng), started = ...future.startTime, 
[17:43:52.019]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.019]             version = "1.8"), class = "FutureResult")
[17:43:52.019]     }, finally = {
[17:43:52.019]         if (!identical(...future.workdir, getwd())) 
[17:43:52.019]             setwd(...future.workdir)
[17:43:52.019]         {
[17:43:52.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.019]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.019]             }
[17:43:52.019]             base::options(...future.oldOptions)
[17:43:52.019]             if (.Platform$OS.type == "windows") {
[17:43:52.019]                 old_names <- names(...future.oldEnvVars)
[17:43:52.019]                 envs <- base::Sys.getenv()
[17:43:52.019]                 names <- names(envs)
[17:43:52.019]                 common <- intersect(names, old_names)
[17:43:52.019]                 added <- setdiff(names, old_names)
[17:43:52.019]                 removed <- setdiff(old_names, names)
[17:43:52.019]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.019]                   envs[common]]
[17:43:52.019]                 NAMES <- toupper(changed)
[17:43:52.019]                 args <- list()
[17:43:52.019]                 for (kk in seq_along(NAMES)) {
[17:43:52.019]                   name <- changed[[kk]]
[17:43:52.019]                   NAME <- NAMES[[kk]]
[17:43:52.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.019]                     next
[17:43:52.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.019]                 }
[17:43:52.019]                 NAMES <- toupper(added)
[17:43:52.019]                 for (kk in seq_along(NAMES)) {
[17:43:52.019]                   name <- added[[kk]]
[17:43:52.019]                   NAME <- NAMES[[kk]]
[17:43:52.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.019]                     next
[17:43:52.019]                   args[[name]] <- ""
[17:43:52.019]                 }
[17:43:52.019]                 NAMES <- toupper(removed)
[17:43:52.019]                 for (kk in seq_along(NAMES)) {
[17:43:52.019]                   name <- removed[[kk]]
[17:43:52.019]                   NAME <- NAMES[[kk]]
[17:43:52.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.019]                     next
[17:43:52.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.019]                 }
[17:43:52.019]                 if (length(args) > 0) 
[17:43:52.019]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.019]             }
[17:43:52.019]             else {
[17:43:52.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.019]             }
[17:43:52.019]             {
[17:43:52.019]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.019]                   0L) {
[17:43:52.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.019]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.019]                   base::options(opts)
[17:43:52.019]                 }
[17:43:52.019]                 {
[17:43:52.019]                   {
[17:43:52.019]                     NULL
[17:43:52.019]                     RNGkind("Mersenne-Twister")
[17:43:52.019]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.019]                       inherits = FALSE)
[17:43:52.019]                   }
[17:43:52.019]                   options(future.plan = NULL)
[17:43:52.019]                   if (is.na(NA_character_)) 
[17:43:52.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.019]                     .init = FALSE)
[17:43:52.019]                 }
[17:43:52.019]             }
[17:43:52.019]         }
[17:43:52.019]     })
[17:43:52.019]     if (TRUE) {
[17:43:52.019]         base::sink(type = "output", split = FALSE)
[17:43:52.019]         if (TRUE) {
[17:43:52.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.019]         }
[17:43:52.019]         else {
[17:43:52.019]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.019]         }
[17:43:52.019]         base::close(...future.stdout)
[17:43:52.019]         ...future.stdout <- NULL
[17:43:52.019]     }
[17:43:52.019]     ...future.result$conditions <- ...future.conditions
[17:43:52.019]     ...future.result$finished <- base::Sys.time()
[17:43:52.019]     ...future.result
[17:43:52.019] }
[17:43:52.021] assign_globals() ...
[17:43:52.021] List of 5
[17:43:52.021]  $ ...future.FUN            :function (x, ...)  
[17:43:52.021]  $ future.call.arguments    :List of 1
[17:43:52.021]   ..$ singular.ok: logi FALSE
[17:43:52.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.021]  $ ...future.elements_ii    :List of 3
[17:43:52.021]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.021]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.021]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.021]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.021]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.021]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.021]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.021]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.021]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.021]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.021]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.021]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.021]  $ ...future.seeds_ii       : NULL
[17:43:52.021]  $ ...future.globals.maxSize: NULL
[17:43:52.021]  - attr(*, "where")=List of 5
[17:43:52.021]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.021]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.021]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.021]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.021]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.021]  - attr(*, "resolved")= logi FALSE
[17:43:52.021]  - attr(*, "total_size")= num 5384
[17:43:52.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.021]  - attr(*, "already-done")= logi TRUE
[17:43:52.029] - reassign environment for ‘...future.FUN’
[17:43:52.029] - copied ‘...future.FUN’ to environment
[17:43:52.029] - copied ‘future.call.arguments’ to environment
[17:43:52.029] - copied ‘...future.elements_ii’ to environment
[17:43:52.029] - copied ‘...future.seeds_ii’ to environment
[17:43:52.029] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.029] assign_globals() ... done
[17:43:52.030] plan(): Setting new future strategy stack:
[17:43:52.030] List of future strategies:
[17:43:52.030] 1. sequential:
[17:43:52.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.030]    - tweaked: FALSE
[17:43:52.030]    - call: NULL
[17:43:52.030] plan(): nbrOfWorkers() = 1
[17:43:52.034] plan(): Setting new future strategy stack:
[17:43:52.034] List of future strategies:
[17:43:52.034] 1. sequential:
[17:43:52.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.034]    - tweaked: FALSE
[17:43:52.034]    - call: plan(strategy)
[17:43:52.035] plan(): nbrOfWorkers() = 1
[17:43:52.035] SequentialFuture started (and completed)
[17:43:52.035] - Launch lazy future ... done
[17:43:52.035] run() for ‘SequentialFuture’ ... done
[17:43:52.035] Created future:
[17:43:52.036] SequentialFuture:
[17:43:52.036] Label: ‘future_by-1’
[17:43:52.036] Expression:
[17:43:52.036] {
[17:43:52.036]     do.call(function(...) {
[17:43:52.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.036]             on.exit(options(oopts), add = TRUE)
[17:43:52.036]         }
[17:43:52.036]         {
[17:43:52.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.036]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.036]             })
[17:43:52.036]         }
[17:43:52.036]     }, args = future.call.arguments)
[17:43:52.036] }
[17:43:52.036] Lazy evaluation: FALSE
[17:43:52.036] Asynchronous evaluation: FALSE
[17:43:52.036] Local evaluation: TRUE
[17:43:52.036] Environment: R_GlobalEnv
[17:43:52.036] Capture standard output: TRUE
[17:43:52.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.036] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.036] Packages: 1 packages (‘stats’)
[17:43:52.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.036] Resolved: TRUE
[17:43:52.036] Value: 26.06 KiB of class ‘list’
[17:43:52.036] Early signaling: FALSE
[17:43:52.036] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.036] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.037] Chunk #1 of 1 ... DONE
[17:43:52.037] Launching 1 futures (chunks) ... DONE
[17:43:52.037] Resolving 1 futures (chunks) ...
[17:43:52.037] resolve() on list ...
[17:43:52.037]  recursive: 0
[17:43:52.037]  length: 1
[17:43:52.037] 
[17:43:52.038] resolved() for ‘SequentialFuture’ ...
[17:43:52.038] - state: ‘finished’
[17:43:52.038] - run: TRUE
[17:43:52.038] - result: ‘FutureResult’
[17:43:52.038] resolved() for ‘SequentialFuture’ ... done
[17:43:52.038] Future #1
[17:43:52.038] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.038] - nx: 1
[17:43:52.038] - relay: TRUE
[17:43:52.038] - stdout: TRUE
[17:43:52.039] - signal: TRUE
[17:43:52.039] - resignal: FALSE
[17:43:52.039] - force: TRUE
[17:43:52.039] - relayed: [n=1] FALSE
[17:43:52.039] - queued futures: [n=1] FALSE
[17:43:52.039]  - until=1
[17:43:52.039]  - relaying element #1
[17:43:52.039] - relayed: [n=1] TRUE
[17:43:52.039] - queued futures: [n=1] TRUE
[17:43:52.039] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.040]  length: 0 (resolved future 1)
[17:43:52.040] Relaying remaining futures
[17:43:52.040] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.040] - nx: 1
[17:43:52.040] - relay: TRUE
[17:43:52.040] - stdout: TRUE
[17:43:52.040] - signal: TRUE
[17:43:52.040] - resignal: FALSE
[17:43:52.040] - force: TRUE
[17:43:52.040] - relayed: [n=1] TRUE
[17:43:52.040] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.041] - relayed: [n=1] TRUE
[17:43:52.041] - queued futures: [n=1] TRUE
[17:43:52.041] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.041] resolve() on list ... DONE
[17:43:52.041]  - Number of value chunks collected: 1
[17:43:52.041] Resolving 1 futures (chunks) ... DONE
[17:43:52.041] Reducing values from 1 chunks ...
[17:43:52.041]  - Number of values collected after concatenation: 3
[17:43:52.041]  - Number of values expected: 3
[17:43:52.041] Reducing values from 1 chunks ... DONE
[17:43:52.041] future_lapply() ... DONE
[17:43:52.042] future_by_internal() ... DONE
[17:43:52.045] future_by_internal() ...
[17:43:52.046] future_lapply() ...
[17:43:52.047] Number of chunks: 1
[17:43:52.047] getGlobalsAndPackagesXApply() ...
[17:43:52.047]  - future.globals: TRUE
[17:43:52.047] getGlobalsAndPackages() ...
[17:43:52.047] Searching for globals...
[17:43:52.049] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.049] Searching for globals ... DONE
[17:43:52.049] Resolving globals: FALSE
[17:43:52.049] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:43:52.050] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:43:52.050] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.050] - packages: [1] ‘stats’
[17:43:52.050] getGlobalsAndPackages() ... DONE
[17:43:52.050]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.050]  - needed namespaces: [n=1] ‘stats’
[17:43:52.050] Finding globals ... DONE
[17:43:52.050]  - use_args: TRUE
[17:43:52.050]  - Getting '...' globals ...
[17:43:52.052] resolve() on list ...
[17:43:52.052]  recursive: 0
[17:43:52.052]  length: 1
[17:43:52.052]  elements: ‘...’
[17:43:52.053]  length: 0 (resolved future 1)
[17:43:52.053] resolve() on list ... DONE
[17:43:52.053]    - '...' content: [n=0] 
[17:43:52.053] List of 1
[17:43:52.053]  $ ...: list()
[17:43:52.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.053]  - attr(*, "where")=List of 1
[17:43:52.053]   ..$ ...:<environment: 0x55d6bae37300> 
[17:43:52.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.053]  - attr(*, "resolved")= logi TRUE
[17:43:52.053]  - attr(*, "total_size")= num NA
[17:43:52.055]  - Getting '...' globals ... DONE
[17:43:52.055] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:43:52.056] List of 4
[17:43:52.056]  $ ...future.FUN:function (x)  
[17:43:52.056]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.056]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.056]  $ ...          : list()
[17:43:52.056]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.056]  - attr(*, "where")=List of 4
[17:43:52.056]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.056]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:43:52.056]   ..$ wool         :<environment: R_EmptyEnv> 
[17:43:52.056]   ..$ ...          :<environment: 0x55d6bae37300> 
[17:43:52.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.056]  - attr(*, "resolved")= logi FALSE
[17:43:52.056]  - attr(*, "total_size")= num 2320
[17:43:52.059] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.059] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.059] Number of futures (= number of chunks): 1
[17:43:52.060] Launching 1 futures (chunks) ...
[17:43:52.060] Chunk #1 of 1 ...
[17:43:52.060]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.060] getGlobalsAndPackages() ...
[17:43:52.060] Searching for globals...
[17:43:52.060] 
[17:43:52.060] Searching for globals ... DONE
[17:43:52.061] - globals: [0] <none>
[17:43:52.061] getGlobalsAndPackages() ... DONE
[17:43:52.061]    + additional globals found: [n=0] 
[17:43:52.061]    + additional namespaces needed: [n=0] 
[17:43:52.061]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.061]  - seeds: <none>
[17:43:52.061]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.061] getGlobalsAndPackages() ...
[17:43:52.061] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.061] Resolving globals: FALSE
[17:43:52.061] Tweak future expression to call with '...' arguments ...
[17:43:52.062] {
[17:43:52.062]     do.call(function(...) {
[17:43:52.062]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.062]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.062]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.062]             on.exit(options(oopts), add = TRUE)
[17:43:52.062]         }
[17:43:52.062]         {
[17:43:52.062]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.062]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.062]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.062]             })
[17:43:52.062]         }
[17:43:52.062]     }, args = future.call.arguments)
[17:43:52.062] }
[17:43:52.062] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.062] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.062] 
[17:43:52.062] getGlobalsAndPackages() ... DONE
[17:43:52.063] run() for ‘Future’ ...
[17:43:52.063] - state: ‘created’
[17:43:52.063] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.063]   - Field: ‘label’
[17:43:52.064]   - Field: ‘local’
[17:43:52.064]   - Field: ‘owner’
[17:43:52.064]   - Field: ‘envir’
[17:43:52.064]   - Field: ‘packages’
[17:43:52.064]   - Field: ‘gc’
[17:43:52.064]   - Field: ‘conditions’
[17:43:52.064]   - Field: ‘expr’
[17:43:52.064]   - Field: ‘uuid’
[17:43:52.064]   - Field: ‘seed’
[17:43:52.064]   - Field: ‘version’
[17:43:52.064]   - Field: ‘result’
[17:43:52.064]   - Field: ‘asynchronous’
[17:43:52.065]   - Field: ‘calls’
[17:43:52.065]   - Field: ‘globals’
[17:43:52.065]   - Field: ‘stdout’
[17:43:52.065]   - Field: ‘earlySignal’
[17:43:52.065]   - Field: ‘lazy’
[17:43:52.065]   - Field: ‘state’
[17:43:52.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.065] - Launch lazy future ...
[17:43:52.065] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.065] Packages needed by future strategies (n = 0): <none>
[17:43:52.066] {
[17:43:52.066]     {
[17:43:52.066]         {
[17:43:52.066]             ...future.startTime <- base::Sys.time()
[17:43:52.066]             {
[17:43:52.066]                 {
[17:43:52.066]                   {
[17:43:52.066]                     {
[17:43:52.066]                       base::local({
[17:43:52.066]                         has_future <- base::requireNamespace("future", 
[17:43:52.066]                           quietly = TRUE)
[17:43:52.066]                         if (has_future) {
[17:43:52.066]                           ns <- base::getNamespace("future")
[17:43:52.066]                           version <- ns[[".package"]][["version"]]
[17:43:52.066]                           if (is.null(version)) 
[17:43:52.066]                             version <- utils::packageVersion("future")
[17:43:52.066]                         }
[17:43:52.066]                         else {
[17:43:52.066]                           version <- NULL
[17:43:52.066]                         }
[17:43:52.066]                         if (!has_future || version < "1.8.0") {
[17:43:52.066]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.066]                             "", base::R.version$version.string), 
[17:43:52.066]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.066]                               "release", "version")], collapse = " "), 
[17:43:52.066]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.066]                             info)
[17:43:52.066]                           info <- base::paste(info, collapse = "; ")
[17:43:52.066]                           if (!has_future) {
[17:43:52.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.066]                               info)
[17:43:52.066]                           }
[17:43:52.066]                           else {
[17:43:52.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.066]                               info, version)
[17:43:52.066]                           }
[17:43:52.066]                           base::stop(msg)
[17:43:52.066]                         }
[17:43:52.066]                       })
[17:43:52.066]                     }
[17:43:52.066]                     base::local({
[17:43:52.066]                       for (pkg in "stats") {
[17:43:52.066]                         base::loadNamespace(pkg)
[17:43:52.066]                         base::library(pkg, character.only = TRUE)
[17:43:52.066]                       }
[17:43:52.066]                     })
[17:43:52.066]                   }
[17:43:52.066]                   ...future.strategy.old <- future::plan("list")
[17:43:52.066]                   options(future.plan = NULL)
[17:43:52.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.066]                 }
[17:43:52.066]                 ...future.workdir <- getwd()
[17:43:52.066]             }
[17:43:52.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.066]         }
[17:43:52.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.066]             base::names(...future.oldOptions))
[17:43:52.066]     }
[17:43:52.066]     if (FALSE) {
[17:43:52.066]     }
[17:43:52.066]     else {
[17:43:52.066]         if (TRUE) {
[17:43:52.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.066]                 open = "w")
[17:43:52.066]         }
[17:43:52.066]         else {
[17:43:52.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.066]         }
[17:43:52.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.066]             base::sink(type = "output", split = FALSE)
[17:43:52.066]             base::close(...future.stdout)
[17:43:52.066]         }, add = TRUE)
[17:43:52.066]     }
[17:43:52.066]     ...future.frame <- base::sys.nframe()
[17:43:52.066]     ...future.conditions <- base::list()
[17:43:52.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.066]     if (FALSE) {
[17:43:52.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.066]     }
[17:43:52.066]     ...future.result <- base::tryCatch({
[17:43:52.066]         base::withCallingHandlers({
[17:43:52.066]             ...future.value <- base::withVisible(base::local({
[17:43:52.066]                 do.call(function(...) {
[17:43:52.066]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.066]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.066]                     ...future.globals.maxSize)) {
[17:43:52.066]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.066]                     on.exit(options(oopts), add = TRUE)
[17:43:52.066]                   }
[17:43:52.066]                   {
[17:43:52.066]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.066]                       FUN = function(jj) {
[17:43:52.066]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.066]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.066]                       })
[17:43:52.066]                   }
[17:43:52.066]                 }, args = future.call.arguments)
[17:43:52.066]             }))
[17:43:52.066]             future::FutureResult(value = ...future.value$value, 
[17:43:52.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.066]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.066]                     ...future.globalenv.names))
[17:43:52.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.066]         }, condition = base::local({
[17:43:52.066]             c <- base::c
[17:43:52.066]             inherits <- base::inherits
[17:43:52.066]             invokeRestart <- base::invokeRestart
[17:43:52.066]             length <- base::length
[17:43:52.066]             list <- base::list
[17:43:52.066]             seq.int <- base::seq.int
[17:43:52.066]             signalCondition <- base::signalCondition
[17:43:52.066]             sys.calls <- base::sys.calls
[17:43:52.066]             `[[` <- base::`[[`
[17:43:52.066]             `+` <- base::`+`
[17:43:52.066]             `<<-` <- base::`<<-`
[17:43:52.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.066]                   3L)]
[17:43:52.066]             }
[17:43:52.066]             function(cond) {
[17:43:52.066]                 is_error <- inherits(cond, "error")
[17:43:52.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.066]                   NULL)
[17:43:52.066]                 if (is_error) {
[17:43:52.066]                   sessionInformation <- function() {
[17:43:52.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.066]                       search = base::search(), system = base::Sys.info())
[17:43:52.066]                   }
[17:43:52.066]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.066]                     cond$call), session = sessionInformation(), 
[17:43:52.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.066]                   signalCondition(cond)
[17:43:52.066]                 }
[17:43:52.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.066]                 "immediateCondition"))) {
[17:43:52.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.066]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.066]                   if (TRUE && !signal) {
[17:43:52.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.066]                     {
[17:43:52.066]                       inherits <- base::inherits
[17:43:52.066]                       invokeRestart <- base::invokeRestart
[17:43:52.066]                       is.null <- base::is.null
[17:43:52.066]                       muffled <- FALSE
[17:43:52.066]                       if (inherits(cond, "message")) {
[17:43:52.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.066]                         if (muffled) 
[17:43:52.066]                           invokeRestart("muffleMessage")
[17:43:52.066]                       }
[17:43:52.066]                       else if (inherits(cond, "warning")) {
[17:43:52.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.066]                         if (muffled) 
[17:43:52.066]                           invokeRestart("muffleWarning")
[17:43:52.066]                       }
[17:43:52.066]                       else if (inherits(cond, "condition")) {
[17:43:52.066]                         if (!is.null(pattern)) {
[17:43:52.066]                           computeRestarts <- base::computeRestarts
[17:43:52.066]                           grepl <- base::grepl
[17:43:52.066]                           restarts <- computeRestarts(cond)
[17:43:52.066]                           for (restart in restarts) {
[17:43:52.066]                             name <- restart$name
[17:43:52.066]                             if (is.null(name)) 
[17:43:52.066]                               next
[17:43:52.066]                             if (!grepl(pattern, name)) 
[17:43:52.066]                               next
[17:43:52.066]                             invokeRestart(restart)
[17:43:52.066]                             muffled <- TRUE
[17:43:52.066]                             break
[17:43:52.066]                           }
[17:43:52.066]                         }
[17:43:52.066]                       }
[17:43:52.066]                       invisible(muffled)
[17:43:52.066]                     }
[17:43:52.066]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.066]                   }
[17:43:52.066]                 }
[17:43:52.066]                 else {
[17:43:52.066]                   if (TRUE) {
[17:43:52.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.066]                     {
[17:43:52.066]                       inherits <- base::inherits
[17:43:52.066]                       invokeRestart <- base::invokeRestart
[17:43:52.066]                       is.null <- base::is.null
[17:43:52.066]                       muffled <- FALSE
[17:43:52.066]                       if (inherits(cond, "message")) {
[17:43:52.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.066]                         if (muffled) 
[17:43:52.066]                           invokeRestart("muffleMessage")
[17:43:52.066]                       }
[17:43:52.066]                       else if (inherits(cond, "warning")) {
[17:43:52.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.066]                         if (muffled) 
[17:43:52.066]                           invokeRestart("muffleWarning")
[17:43:52.066]                       }
[17:43:52.066]                       else if (inherits(cond, "condition")) {
[17:43:52.066]                         if (!is.null(pattern)) {
[17:43:52.066]                           computeRestarts <- base::computeRestarts
[17:43:52.066]                           grepl <- base::grepl
[17:43:52.066]                           restarts <- computeRestarts(cond)
[17:43:52.066]                           for (restart in restarts) {
[17:43:52.066]                             name <- restart$name
[17:43:52.066]                             if (is.null(name)) 
[17:43:52.066]                               next
[17:43:52.066]                             if (!grepl(pattern, name)) 
[17:43:52.066]                               next
[17:43:52.066]                             invokeRestart(restart)
[17:43:52.066]                             muffled <- TRUE
[17:43:52.066]                             break
[17:43:52.066]                           }
[17:43:52.066]                         }
[17:43:52.066]                       }
[17:43:52.066]                       invisible(muffled)
[17:43:52.066]                     }
[17:43:52.066]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.066]                   }
[17:43:52.066]                 }
[17:43:52.066]             }
[17:43:52.066]         }))
[17:43:52.066]     }, error = function(ex) {
[17:43:52.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.066]                 ...future.rng), started = ...future.startTime, 
[17:43:52.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.066]             version = "1.8"), class = "FutureResult")
[17:43:52.066]     }, finally = {
[17:43:52.066]         if (!identical(...future.workdir, getwd())) 
[17:43:52.066]             setwd(...future.workdir)
[17:43:52.066]         {
[17:43:52.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.066]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.066]             }
[17:43:52.066]             base::options(...future.oldOptions)
[17:43:52.066]             if (.Platform$OS.type == "windows") {
[17:43:52.066]                 old_names <- names(...future.oldEnvVars)
[17:43:52.066]                 envs <- base::Sys.getenv()
[17:43:52.066]                 names <- names(envs)
[17:43:52.066]                 common <- intersect(names, old_names)
[17:43:52.066]                 added <- setdiff(names, old_names)
[17:43:52.066]                 removed <- setdiff(old_names, names)
[17:43:52.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.066]                   envs[common]]
[17:43:52.066]                 NAMES <- toupper(changed)
[17:43:52.066]                 args <- list()
[17:43:52.066]                 for (kk in seq_along(NAMES)) {
[17:43:52.066]                   name <- changed[[kk]]
[17:43:52.066]                   NAME <- NAMES[[kk]]
[17:43:52.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.066]                     next
[17:43:52.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.066]                 }
[17:43:52.066]                 NAMES <- toupper(added)
[17:43:52.066]                 for (kk in seq_along(NAMES)) {
[17:43:52.066]                   name <- added[[kk]]
[17:43:52.066]                   NAME <- NAMES[[kk]]
[17:43:52.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.066]                     next
[17:43:52.066]                   args[[name]] <- ""
[17:43:52.066]                 }
[17:43:52.066]                 NAMES <- toupper(removed)
[17:43:52.066]                 for (kk in seq_along(NAMES)) {
[17:43:52.066]                   name <- removed[[kk]]
[17:43:52.066]                   NAME <- NAMES[[kk]]
[17:43:52.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.066]                     next
[17:43:52.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.066]                 }
[17:43:52.066]                 if (length(args) > 0) 
[17:43:52.066]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.066]             }
[17:43:52.066]             else {
[17:43:52.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.066]             }
[17:43:52.066]             {
[17:43:52.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.066]                   0L) {
[17:43:52.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.066]                   base::options(opts)
[17:43:52.066]                 }
[17:43:52.066]                 {
[17:43:52.066]                   {
[17:43:52.066]                     NULL
[17:43:52.066]                     RNGkind("Mersenne-Twister")
[17:43:52.066]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.066]                       inherits = FALSE)
[17:43:52.066]                   }
[17:43:52.066]                   options(future.plan = NULL)
[17:43:52.066]                   if (is.na(NA_character_)) 
[17:43:52.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.066]                     .init = FALSE)
[17:43:52.066]                 }
[17:43:52.066]             }
[17:43:52.066]         }
[17:43:52.066]     })
[17:43:52.066]     if (TRUE) {
[17:43:52.066]         base::sink(type = "output", split = FALSE)
[17:43:52.066]         if (TRUE) {
[17:43:52.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.066]         }
[17:43:52.066]         else {
[17:43:52.066]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.066]         }
[17:43:52.066]         base::close(...future.stdout)
[17:43:52.066]         ...future.stdout <- NULL
[17:43:52.066]     }
[17:43:52.066]     ...future.result$conditions <- ...future.conditions
[17:43:52.066]     ...future.result$finished <- base::Sys.time()
[17:43:52.066]     ...future.result
[17:43:52.066] }
[17:43:52.068] assign_globals() ...
[17:43:52.068] List of 7
[17:43:52.068]  $ ...future.FUN            :function (x)  
[17:43:52.068]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.068]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.068]  $ future.call.arguments    : list()
[17:43:52.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.068]  $ ...future.elements_ii    :List of 3
[17:43:52.068]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.068]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.068]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.068]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.068]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.068]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.068]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.068]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.068]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.068]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.068]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.068]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.068]  $ ...future.seeds_ii       : NULL
[17:43:52.068]  $ ...future.globals.maxSize: NULL
[17:43:52.068]  - attr(*, "where")=List of 7
[17:43:52.068]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.068]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:43:52.068]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:43:52.068]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.068]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.068]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.068]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.068]  - attr(*, "resolved")= logi FALSE
[17:43:52.068]  - attr(*, "total_size")= num 2320
[17:43:52.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.068]  - attr(*, "already-done")= logi TRUE
[17:43:52.079] - reassign environment for ‘...future.FUN’
[17:43:52.079] - copied ‘...future.FUN’ to environment
[17:43:52.079] - copied ‘breaks’ to environment
[17:43:52.079] - copied ‘wool’ to environment
[17:43:52.079] - copied ‘future.call.arguments’ to environment
[17:43:52.079] - copied ‘...future.elements_ii’ to environment
[17:43:52.079] - copied ‘...future.seeds_ii’ to environment
[17:43:52.079] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.080] assign_globals() ... done
[17:43:52.080] plan(): Setting new future strategy stack:
[17:43:52.080] List of future strategies:
[17:43:52.080] 1. sequential:
[17:43:52.080]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.080]    - tweaked: FALSE
[17:43:52.080]    - call: NULL
[17:43:52.080] plan(): nbrOfWorkers() = 1
[17:43:52.083] plan(): Setting new future strategy stack:
[17:43:52.083] List of future strategies:
[17:43:52.083] 1. sequential:
[17:43:52.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.083]    - tweaked: FALSE
[17:43:52.083]    - call: plan(strategy)
[17:43:52.084] plan(): nbrOfWorkers() = 1
[17:43:52.084] SequentialFuture started (and completed)
[17:43:52.084] - Launch lazy future ... done
[17:43:52.084] run() for ‘SequentialFuture’ ... done
[17:43:52.084] Created future:
[17:43:52.084] SequentialFuture:
[17:43:52.084] Label: ‘future_by-1’
[17:43:52.084] Expression:
[17:43:52.084] {
[17:43:52.084]     do.call(function(...) {
[17:43:52.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.084]             on.exit(options(oopts), add = TRUE)
[17:43:52.084]         }
[17:43:52.084]         {
[17:43:52.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.084]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.084]             })
[17:43:52.084]         }
[17:43:52.084]     }, args = future.call.arguments)
[17:43:52.084] }
[17:43:52.084] Lazy evaluation: FALSE
[17:43:52.084] Asynchronous evaluation: FALSE
[17:43:52.084] Local evaluation: TRUE
[17:43:52.084] Environment: 0x55d6badf9240
[17:43:52.084] Capture standard output: TRUE
[17:43:52.084] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.084] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:43:52.084] Packages: 1 packages (‘stats’)
[17:43:52.084] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.084] Resolved: TRUE
[17:43:52.084] Value: 25.57 KiB of class ‘list’
[17:43:52.084] Early signaling: FALSE
[17:43:52.084] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.084] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.086] Chunk #1 of 1 ... DONE
[17:43:52.086] Launching 1 futures (chunks) ... DONE
[17:43:52.086] Resolving 1 futures (chunks) ...
[17:43:52.086] resolve() on list ...
[17:43:52.086]  recursive: 0
[17:43:52.086]  length: 1
[17:43:52.086] 
[17:43:52.087] resolved() for ‘SequentialFuture’ ...
[17:43:52.087] - state: ‘finished’
[17:43:52.087] - run: TRUE
[17:43:52.087] - result: ‘FutureResult’
[17:43:52.087] resolved() for ‘SequentialFuture’ ... done
[17:43:52.087] Future #1
[17:43:52.087] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.087] - nx: 1
[17:43:52.087] - relay: TRUE
[17:43:52.087] - stdout: TRUE
[17:43:52.087] - signal: TRUE
[17:43:52.088] - resignal: FALSE
[17:43:52.088] - force: TRUE
[17:43:52.088] - relayed: [n=1] FALSE
[17:43:52.088] - queued futures: [n=1] FALSE
[17:43:52.088]  - until=1
[17:43:52.088]  - relaying element #1
[17:43:52.088] - relayed: [n=1] TRUE
[17:43:52.088] - queued futures: [n=1] TRUE
[17:43:52.088] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.088]  length: 0 (resolved future 1)
[17:43:52.089] Relaying remaining futures
[17:43:52.089] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.089] - nx: 1
[17:43:52.089] - relay: TRUE
[17:43:52.089] - stdout: TRUE
[17:43:52.089] - signal: TRUE
[17:43:52.089] - resignal: FALSE
[17:43:52.089] - force: TRUE
[17:43:52.089] - relayed: [n=1] TRUE
[17:43:52.089] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.089] - relayed: [n=1] TRUE
[17:43:52.089] - queued futures: [n=1] TRUE
[17:43:52.090] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.090] resolve() on list ... DONE
[17:43:52.090]  - Number of value chunks collected: 1
[17:43:52.090] Resolving 1 futures (chunks) ... DONE
[17:43:52.090] Reducing values from 1 chunks ...
[17:43:52.090]  - Number of values collected after concatenation: 3
[17:43:52.090]  - Number of values expected: 3
[17:43:52.090] Reducing values from 1 chunks ... DONE
[17:43:52.090] future_lapply() ... DONE
[17:43:52.090] future_by_internal() ... DONE
[17:43:52.091] future_by_internal() ...
[17:43:52.091] future_lapply() ...
[17:43:52.092] Number of chunks: 1
[17:43:52.092] getGlobalsAndPackagesXApply() ...
[17:43:52.092]  - future.globals: TRUE
[17:43:52.092] getGlobalsAndPackages() ...
[17:43:52.092] Searching for globals...
[17:43:52.093] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.093] Searching for globals ... DONE
[17:43:52.093] Resolving globals: FALSE
[17:43:52.093] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.094] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.094] - globals: [1] ‘FUN’
[17:43:52.094] 
[17:43:52.095] getGlobalsAndPackages() ... DONE
[17:43:52.096]  - globals found/used: [n=1] ‘FUN’
[17:43:52.096]  - needed namespaces: [n=0] 
[17:43:52.096] Finding globals ... DONE
[17:43:52.096]  - use_args: TRUE
[17:43:52.096]  - Getting '...' globals ...
[17:43:52.096] resolve() on list ...
[17:43:52.096]  recursive: 0
[17:43:52.096]  length: 1
[17:43:52.096]  elements: ‘...’
[17:43:52.097]  length: 0 (resolved future 1)
[17:43:52.097] resolve() on list ... DONE
[17:43:52.097]    - '...' content: [n=0] 
[17:43:52.097] List of 1
[17:43:52.097]  $ ...: list()
[17:43:52.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.097]  - attr(*, "where")=List of 1
[17:43:52.097]   ..$ ...:<environment: 0x55d6bafda198> 
[17:43:52.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.097]  - attr(*, "resolved")= logi TRUE
[17:43:52.097]  - attr(*, "total_size")= num NA
[17:43:52.099]  - Getting '...' globals ... DONE
[17:43:52.099] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.100] List of 2
[17:43:52.100]  $ ...future.FUN:function (object, ...)  
[17:43:52.100]  $ ...          : list()
[17:43:52.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.100]  - attr(*, "where")=List of 2
[17:43:52.100]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.100]   ..$ ...          :<environment: 0x55d6bafda198> 
[17:43:52.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.100]  - attr(*, "resolved")= logi FALSE
[17:43:52.100]  - attr(*, "total_size")= num 1240
[17:43:52.102] Packages to be attached in all futures: [n=0] 
[17:43:52.102] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.102] Number of futures (= number of chunks): 1
[17:43:52.102] Launching 1 futures (chunks) ...
[17:43:52.103] Chunk #1 of 1 ...
[17:43:52.103]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.103] getGlobalsAndPackages() ...
[17:43:52.103] Searching for globals...
[17:43:52.103] 
[17:43:52.103] Searching for globals ... DONE
[17:43:52.104] - globals: [0] <none>
[17:43:52.104] getGlobalsAndPackages() ... DONE
[17:43:52.104]    + additional globals found: [n=0] 
[17:43:52.104]    + additional namespaces needed: [n=0] 
[17:43:52.104]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.104]  - seeds: <none>
[17:43:52.104]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.104] getGlobalsAndPackages() ...
[17:43:52.104] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.104] Resolving globals: FALSE
[17:43:52.104] Tweak future expression to call with '...' arguments ...
[17:43:52.105] {
[17:43:52.105]     do.call(function(...) {
[17:43:52.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.105]             on.exit(options(oopts), add = TRUE)
[17:43:52.105]         }
[17:43:52.105]         {
[17:43:52.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.105]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.105]             })
[17:43:52.105]         }
[17:43:52.105]     }, args = future.call.arguments)
[17:43:52.105] }
[17:43:52.105] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.105] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.105] 
[17:43:52.105] getGlobalsAndPackages() ... DONE
[17:43:52.106] run() for ‘Future’ ...
[17:43:52.106] - state: ‘created’
[17:43:52.106] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.106]   - Field: ‘label’
[17:43:52.106]   - Field: ‘local’
[17:43:52.106]   - Field: ‘owner’
[17:43:52.107]   - Field: ‘envir’
[17:43:52.107]   - Field: ‘packages’
[17:43:52.107]   - Field: ‘gc’
[17:43:52.107]   - Field: ‘conditions’
[17:43:52.107]   - Field: ‘expr’
[17:43:52.107]   - Field: ‘uuid’
[17:43:52.107]   - Field: ‘seed’
[17:43:52.107]   - Field: ‘version’
[17:43:52.107]   - Field: ‘result’
[17:43:52.107]   - Field: ‘asynchronous’
[17:43:52.107]   - Field: ‘calls’
[17:43:52.108]   - Field: ‘globals’
[17:43:52.108]   - Field: ‘stdout’
[17:43:52.108]   - Field: ‘earlySignal’
[17:43:52.108]   - Field: ‘lazy’
[17:43:52.108]   - Field: ‘state’
[17:43:52.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.108] - Launch lazy future ...
[17:43:52.108] Packages needed by the future expression (n = 0): <none>
[17:43:52.108] Packages needed by future strategies (n = 0): <none>
[17:43:52.109] {
[17:43:52.109]     {
[17:43:52.109]         {
[17:43:52.109]             ...future.startTime <- base::Sys.time()
[17:43:52.109]             {
[17:43:52.109]                 {
[17:43:52.109]                   {
[17:43:52.109]                     base::local({
[17:43:52.109]                       has_future <- base::requireNamespace("future", 
[17:43:52.109]                         quietly = TRUE)
[17:43:52.109]                       if (has_future) {
[17:43:52.109]                         ns <- base::getNamespace("future")
[17:43:52.109]                         version <- ns[[".package"]][["version"]]
[17:43:52.109]                         if (is.null(version)) 
[17:43:52.109]                           version <- utils::packageVersion("future")
[17:43:52.109]                       }
[17:43:52.109]                       else {
[17:43:52.109]                         version <- NULL
[17:43:52.109]                       }
[17:43:52.109]                       if (!has_future || version < "1.8.0") {
[17:43:52.109]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.109]                           "", base::R.version$version.string), 
[17:43:52.109]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.109]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.109]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.109]                             "release", "version")], collapse = " "), 
[17:43:52.109]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.109]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.109]                           info)
[17:43:52.109]                         info <- base::paste(info, collapse = "; ")
[17:43:52.109]                         if (!has_future) {
[17:43:52.109]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.109]                             info)
[17:43:52.109]                         }
[17:43:52.109]                         else {
[17:43:52.109]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.109]                             info, version)
[17:43:52.109]                         }
[17:43:52.109]                         base::stop(msg)
[17:43:52.109]                       }
[17:43:52.109]                     })
[17:43:52.109]                   }
[17:43:52.109]                   ...future.strategy.old <- future::plan("list")
[17:43:52.109]                   options(future.plan = NULL)
[17:43:52.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.109]                 }
[17:43:52.109]                 ...future.workdir <- getwd()
[17:43:52.109]             }
[17:43:52.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.109]         }
[17:43:52.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.109]             base::names(...future.oldOptions))
[17:43:52.109]     }
[17:43:52.109]     if (FALSE) {
[17:43:52.109]     }
[17:43:52.109]     else {
[17:43:52.109]         if (TRUE) {
[17:43:52.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.109]                 open = "w")
[17:43:52.109]         }
[17:43:52.109]         else {
[17:43:52.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.109]         }
[17:43:52.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.109]             base::sink(type = "output", split = FALSE)
[17:43:52.109]             base::close(...future.stdout)
[17:43:52.109]         }, add = TRUE)
[17:43:52.109]     }
[17:43:52.109]     ...future.frame <- base::sys.nframe()
[17:43:52.109]     ...future.conditions <- base::list()
[17:43:52.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.109]     if (FALSE) {
[17:43:52.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.109]     }
[17:43:52.109]     ...future.result <- base::tryCatch({
[17:43:52.109]         base::withCallingHandlers({
[17:43:52.109]             ...future.value <- base::withVisible(base::local({
[17:43:52.109]                 do.call(function(...) {
[17:43:52.109]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.109]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.109]                     ...future.globals.maxSize)) {
[17:43:52.109]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.109]                     on.exit(options(oopts), add = TRUE)
[17:43:52.109]                   }
[17:43:52.109]                   {
[17:43:52.109]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.109]                       FUN = function(jj) {
[17:43:52.109]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.109]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.109]                       })
[17:43:52.109]                   }
[17:43:52.109]                 }, args = future.call.arguments)
[17:43:52.109]             }))
[17:43:52.109]             future::FutureResult(value = ...future.value$value, 
[17:43:52.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.109]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.109]                     ...future.globalenv.names))
[17:43:52.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.109]         }, condition = base::local({
[17:43:52.109]             c <- base::c
[17:43:52.109]             inherits <- base::inherits
[17:43:52.109]             invokeRestart <- base::invokeRestart
[17:43:52.109]             length <- base::length
[17:43:52.109]             list <- base::list
[17:43:52.109]             seq.int <- base::seq.int
[17:43:52.109]             signalCondition <- base::signalCondition
[17:43:52.109]             sys.calls <- base::sys.calls
[17:43:52.109]             `[[` <- base::`[[`
[17:43:52.109]             `+` <- base::`+`
[17:43:52.109]             `<<-` <- base::`<<-`
[17:43:52.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.109]                   3L)]
[17:43:52.109]             }
[17:43:52.109]             function(cond) {
[17:43:52.109]                 is_error <- inherits(cond, "error")
[17:43:52.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.109]                   NULL)
[17:43:52.109]                 if (is_error) {
[17:43:52.109]                   sessionInformation <- function() {
[17:43:52.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.109]                       search = base::search(), system = base::Sys.info())
[17:43:52.109]                   }
[17:43:52.109]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.109]                     cond$call), session = sessionInformation(), 
[17:43:52.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.109]                   signalCondition(cond)
[17:43:52.109]                 }
[17:43:52.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.109]                 "immediateCondition"))) {
[17:43:52.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.109]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.109]                   if (TRUE && !signal) {
[17:43:52.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.109]                     {
[17:43:52.109]                       inherits <- base::inherits
[17:43:52.109]                       invokeRestart <- base::invokeRestart
[17:43:52.109]                       is.null <- base::is.null
[17:43:52.109]                       muffled <- FALSE
[17:43:52.109]                       if (inherits(cond, "message")) {
[17:43:52.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.109]                         if (muffled) 
[17:43:52.109]                           invokeRestart("muffleMessage")
[17:43:52.109]                       }
[17:43:52.109]                       else if (inherits(cond, "warning")) {
[17:43:52.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.109]                         if (muffled) 
[17:43:52.109]                           invokeRestart("muffleWarning")
[17:43:52.109]                       }
[17:43:52.109]                       else if (inherits(cond, "condition")) {
[17:43:52.109]                         if (!is.null(pattern)) {
[17:43:52.109]                           computeRestarts <- base::computeRestarts
[17:43:52.109]                           grepl <- base::grepl
[17:43:52.109]                           restarts <- computeRestarts(cond)
[17:43:52.109]                           for (restart in restarts) {
[17:43:52.109]                             name <- restart$name
[17:43:52.109]                             if (is.null(name)) 
[17:43:52.109]                               next
[17:43:52.109]                             if (!grepl(pattern, name)) 
[17:43:52.109]                               next
[17:43:52.109]                             invokeRestart(restart)
[17:43:52.109]                             muffled <- TRUE
[17:43:52.109]                             break
[17:43:52.109]                           }
[17:43:52.109]                         }
[17:43:52.109]                       }
[17:43:52.109]                       invisible(muffled)
[17:43:52.109]                     }
[17:43:52.109]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.109]                   }
[17:43:52.109]                 }
[17:43:52.109]                 else {
[17:43:52.109]                   if (TRUE) {
[17:43:52.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.109]                     {
[17:43:52.109]                       inherits <- base::inherits
[17:43:52.109]                       invokeRestart <- base::invokeRestart
[17:43:52.109]                       is.null <- base::is.null
[17:43:52.109]                       muffled <- FALSE
[17:43:52.109]                       if (inherits(cond, "message")) {
[17:43:52.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.109]                         if (muffled) 
[17:43:52.109]                           invokeRestart("muffleMessage")
[17:43:52.109]                       }
[17:43:52.109]                       else if (inherits(cond, "warning")) {
[17:43:52.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.109]                         if (muffled) 
[17:43:52.109]                           invokeRestart("muffleWarning")
[17:43:52.109]                       }
[17:43:52.109]                       else if (inherits(cond, "condition")) {
[17:43:52.109]                         if (!is.null(pattern)) {
[17:43:52.109]                           computeRestarts <- base::computeRestarts
[17:43:52.109]                           grepl <- base::grepl
[17:43:52.109]                           restarts <- computeRestarts(cond)
[17:43:52.109]                           for (restart in restarts) {
[17:43:52.109]                             name <- restart$name
[17:43:52.109]                             if (is.null(name)) 
[17:43:52.109]                               next
[17:43:52.109]                             if (!grepl(pattern, name)) 
[17:43:52.109]                               next
[17:43:52.109]                             invokeRestart(restart)
[17:43:52.109]                             muffled <- TRUE
[17:43:52.109]                             break
[17:43:52.109]                           }
[17:43:52.109]                         }
[17:43:52.109]                       }
[17:43:52.109]                       invisible(muffled)
[17:43:52.109]                     }
[17:43:52.109]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.109]                   }
[17:43:52.109]                 }
[17:43:52.109]             }
[17:43:52.109]         }))
[17:43:52.109]     }, error = function(ex) {
[17:43:52.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.109]                 ...future.rng), started = ...future.startTime, 
[17:43:52.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.109]             version = "1.8"), class = "FutureResult")
[17:43:52.109]     }, finally = {
[17:43:52.109]         if (!identical(...future.workdir, getwd())) 
[17:43:52.109]             setwd(...future.workdir)
[17:43:52.109]         {
[17:43:52.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.109]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.109]             }
[17:43:52.109]             base::options(...future.oldOptions)
[17:43:52.109]             if (.Platform$OS.type == "windows") {
[17:43:52.109]                 old_names <- names(...future.oldEnvVars)
[17:43:52.109]                 envs <- base::Sys.getenv()
[17:43:52.109]                 names <- names(envs)
[17:43:52.109]                 common <- intersect(names, old_names)
[17:43:52.109]                 added <- setdiff(names, old_names)
[17:43:52.109]                 removed <- setdiff(old_names, names)
[17:43:52.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.109]                   envs[common]]
[17:43:52.109]                 NAMES <- toupper(changed)
[17:43:52.109]                 args <- list()
[17:43:52.109]                 for (kk in seq_along(NAMES)) {
[17:43:52.109]                   name <- changed[[kk]]
[17:43:52.109]                   NAME <- NAMES[[kk]]
[17:43:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.109]                     next
[17:43:52.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.109]                 }
[17:43:52.109]                 NAMES <- toupper(added)
[17:43:52.109]                 for (kk in seq_along(NAMES)) {
[17:43:52.109]                   name <- added[[kk]]
[17:43:52.109]                   NAME <- NAMES[[kk]]
[17:43:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.109]                     next
[17:43:52.109]                   args[[name]] <- ""
[17:43:52.109]                 }
[17:43:52.109]                 NAMES <- toupper(removed)
[17:43:52.109]                 for (kk in seq_along(NAMES)) {
[17:43:52.109]                   name <- removed[[kk]]
[17:43:52.109]                   NAME <- NAMES[[kk]]
[17:43:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.109]                     next
[17:43:52.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.109]                 }
[17:43:52.109]                 if (length(args) > 0) 
[17:43:52.109]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.109]             }
[17:43:52.109]             else {
[17:43:52.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.109]             }
[17:43:52.109]             {
[17:43:52.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.109]                   0L) {
[17:43:52.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.109]                   base::options(opts)
[17:43:52.109]                 }
[17:43:52.109]                 {
[17:43:52.109]                   {
[17:43:52.109]                     NULL
[17:43:52.109]                     RNGkind("Mersenne-Twister")
[17:43:52.109]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.109]                       inherits = FALSE)
[17:43:52.109]                   }
[17:43:52.109]                   options(future.plan = NULL)
[17:43:52.109]                   if (is.na(NA_character_)) 
[17:43:52.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.109]                     .init = FALSE)
[17:43:52.109]                 }
[17:43:52.109]             }
[17:43:52.109]         }
[17:43:52.109]     })
[17:43:52.109]     if (TRUE) {
[17:43:52.109]         base::sink(type = "output", split = FALSE)
[17:43:52.109]         if (TRUE) {
[17:43:52.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.109]         }
[17:43:52.109]         else {
[17:43:52.109]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.109]         }
[17:43:52.109]         base::close(...future.stdout)
[17:43:52.109]         ...future.stdout <- NULL
[17:43:52.109]     }
[17:43:52.109]     ...future.result$conditions <- ...future.conditions
[17:43:52.109]     ...future.result$finished <- base::Sys.time()
[17:43:52.109]     ...future.result
[17:43:52.109] }
[17:43:52.110] assign_globals() ...
[17:43:52.110] List of 5
[17:43:52.110]  $ ...future.FUN            :function (object, ...)  
[17:43:52.110]  $ future.call.arguments    : list()
[17:43:52.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.110]  $ ...future.elements_ii    :List of 3
[17:43:52.110]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.110]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.110]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.110]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.110]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.110]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.110]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.110]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.110]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.110]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.110]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.110]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.110]  $ ...future.seeds_ii       : NULL
[17:43:52.110]  $ ...future.globals.maxSize: NULL
[17:43:52.110]  - attr(*, "where")=List of 5
[17:43:52.110]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.110]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.110]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.110]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.110]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.110]  - attr(*, "resolved")= logi FALSE
[17:43:52.110]  - attr(*, "total_size")= num 1240
[17:43:52.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.110]  - attr(*, "already-done")= logi TRUE
[17:43:52.120] - copied ‘...future.FUN’ to environment
[17:43:52.120] - copied ‘future.call.arguments’ to environment
[17:43:52.120] - copied ‘...future.elements_ii’ to environment
[17:43:52.120] - copied ‘...future.seeds_ii’ to environment
[17:43:52.120] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.120] assign_globals() ... done
[17:43:52.121] plan(): Setting new future strategy stack:
[17:43:52.121] List of future strategies:
[17:43:52.121] 1. sequential:
[17:43:52.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.121]    - tweaked: FALSE
[17:43:52.121]    - call: NULL
[17:43:52.121] plan(): nbrOfWorkers() = 1
[17:43:52.123] plan(): Setting new future strategy stack:
[17:43:52.123] List of future strategies:
[17:43:52.123] 1. sequential:
[17:43:52.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.123]    - tweaked: FALSE
[17:43:52.123]    - call: plan(strategy)
[17:43:52.124] plan(): nbrOfWorkers() = 1
[17:43:52.124] SequentialFuture started (and completed)
[17:43:52.124] - Launch lazy future ... done
[17:43:52.124] run() for ‘SequentialFuture’ ... done
[17:43:52.124] Created future:
[17:43:52.124] SequentialFuture:
[17:43:52.124] Label: ‘future_by-1’
[17:43:52.124] Expression:
[17:43:52.124] {
[17:43:52.124]     do.call(function(...) {
[17:43:52.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.124]             on.exit(options(oopts), add = TRUE)
[17:43:52.124]         }
[17:43:52.124]         {
[17:43:52.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.124]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.124]             })
[17:43:52.124]         }
[17:43:52.124]     }, args = future.call.arguments)
[17:43:52.124] }
[17:43:52.124] Lazy evaluation: FALSE
[17:43:52.124] Asynchronous evaluation: FALSE
[17:43:52.124] Local evaluation: TRUE
[17:43:52.124] Environment: 0x55d6baf73fa0
[17:43:52.124] Capture standard output: TRUE
[17:43:52.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.124] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.124] Packages: <none>
[17:43:52.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.124] Resolved: TRUE
[17:43:52.124] Value: 5.37 KiB of class ‘list’
[17:43:52.124] Early signaling: FALSE
[17:43:52.124] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.124] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.126] Chunk #1 of 1 ... DONE
[17:43:52.126] Launching 1 futures (chunks) ... DONE
[17:43:52.126] Resolving 1 futures (chunks) ...
[17:43:52.126] resolve() on list ...
[17:43:52.126]  recursive: 0
[17:43:52.126]  length: 1
[17:43:52.126] 
[17:43:52.126] resolved() for ‘SequentialFuture’ ...
[17:43:52.126] - state: ‘finished’
[17:43:52.126] - run: TRUE
[17:43:52.126] - result: ‘FutureResult’
[17:43:52.127] resolved() for ‘SequentialFuture’ ... done
[17:43:52.127] Future #1
[17:43:52.127] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.127] - nx: 1
[17:43:52.127] - relay: TRUE
[17:43:52.127] - stdout: TRUE
[17:43:52.127] - signal: TRUE
[17:43:52.127] - resignal: FALSE
[17:43:52.127] - force: TRUE
[17:43:52.127] - relayed: [n=1] FALSE
[17:43:52.127] - queued futures: [n=1] FALSE
[17:43:52.128]  - until=1
[17:43:52.128]  - relaying element #1
[17:43:52.128] - relayed: [n=1] TRUE
[17:43:52.128] - queued futures: [n=1] TRUE
[17:43:52.128] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.128]  length: 0 (resolved future 1)
[17:43:52.128] Relaying remaining futures
[17:43:52.128] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.128] - nx: 1
[17:43:52.128] - relay: TRUE
[17:43:52.128] - stdout: TRUE
[17:43:52.129] - signal: TRUE
[17:43:52.129] - resignal: FALSE
[17:43:52.129] - force: TRUE
[17:43:52.129] - relayed: [n=1] TRUE
[17:43:52.129] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.129] - relayed: [n=1] TRUE
[17:43:52.129] - queued futures: [n=1] TRUE
[17:43:52.129] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.129] resolve() on list ... DONE
[17:43:52.129]  - Number of value chunks collected: 1
[17:43:52.130] Resolving 1 futures (chunks) ... DONE
[17:43:52.130] Reducing values from 1 chunks ...
[17:43:52.130]  - Number of values collected after concatenation: 3
[17:43:52.130]  - Number of values expected: 3
[17:43:52.130] Reducing values from 1 chunks ... DONE
[17:43:52.130] future_lapply() ... DONE
[17:43:52.130] future_by_internal() ... DONE
[17:43:52.132] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:43:52.132] future_lapply() ...
[17:43:52.133] Number of chunks: 1
[17:43:52.133] getGlobalsAndPackagesXApply() ...
[17:43:52.133]  - future.globals: TRUE
[17:43:52.133] getGlobalsAndPackages() ...
[17:43:52.133] Searching for globals...
[17:43:52.134] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.134] Searching for globals ... DONE
[17:43:52.135] Resolving globals: FALSE
[17:43:52.135] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.135] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.135] - globals: [1] ‘FUN’
[17:43:52.135] 
[17:43:52.136] getGlobalsAndPackages() ... DONE
[17:43:52.136]  - globals found/used: [n=1] ‘FUN’
[17:43:52.136]  - needed namespaces: [n=0] 
[17:43:52.136] Finding globals ... DONE
[17:43:52.136]  - use_args: TRUE
[17:43:52.136]  - Getting '...' globals ...
[17:43:52.138] resolve() on list ...
[17:43:52.138]  recursive: 0
[17:43:52.138]  length: 1
[17:43:52.138]  elements: ‘...’
[17:43:52.138]  length: 0 (resolved future 1)
[17:43:52.138] resolve() on list ... DONE
[17:43:52.138]    - '...' content: [n=0] 
[17:43:52.139] List of 1
[17:43:52.139]  $ ...: list()
[17:43:52.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.139]  - attr(*, "where")=List of 1
[17:43:52.139]   ..$ ...:<environment: 0x55d6baf35ab0> 
[17:43:52.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.139]  - attr(*, "resolved")= logi TRUE
[17:43:52.139]  - attr(*, "total_size")= num NA
[17:43:52.141]  - Getting '...' globals ... DONE
[17:43:52.141] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.141] List of 2
[17:43:52.141]  $ ...future.FUN:function (object, ...)  
[17:43:52.141]  $ ...          : list()
[17:43:52.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.141]  - attr(*, "where")=List of 2
[17:43:52.141]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.141]   ..$ ...          :<environment: 0x55d6baf35ab0> 
[17:43:52.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.141]  - attr(*, "resolved")= logi FALSE
[17:43:52.141]  - attr(*, "total_size")= num 1240
[17:43:52.144] Packages to be attached in all futures: [n=0] 
[17:43:52.144] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.144] Number of futures (= number of chunks): 1
[17:43:52.144] Launching 1 futures (chunks) ...
[17:43:52.145] Chunk #1 of 1 ...
[17:43:52.145]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.145] getGlobalsAndPackages() ...
[17:43:52.145] Searching for globals...
[17:43:52.145] 
[17:43:52.145] Searching for globals ... DONE
[17:43:52.145] - globals: [0] <none>
[17:43:52.146] getGlobalsAndPackages() ... DONE
[17:43:52.146]    + additional globals found: [n=0] 
[17:43:52.146]    + additional namespaces needed: [n=0] 
[17:43:52.146]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.146]  - seeds: <none>
[17:43:52.146]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.146] getGlobalsAndPackages() ...
[17:43:52.146] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.146] Resolving globals: FALSE
[17:43:52.146] Tweak future expression to call with '...' arguments ...
[17:43:52.147] {
[17:43:52.147]     do.call(function(...) {
[17:43:52.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.147]             on.exit(options(oopts), add = TRUE)
[17:43:52.147]         }
[17:43:52.147]         {
[17:43:52.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.147]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.147]             })
[17:43:52.147]         }
[17:43:52.147]     }, args = future.call.arguments)
[17:43:52.147] }
[17:43:52.147] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.147] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.147] 
[17:43:52.147] getGlobalsAndPackages() ... DONE
[17:43:52.148] run() for ‘Future’ ...
[17:43:52.148] - state: ‘created’
[17:43:52.148] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.148] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.148]   - Field: ‘label’
[17:43:52.148]   - Field: ‘local’
[17:43:52.149]   - Field: ‘owner’
[17:43:52.149]   - Field: ‘envir’
[17:43:52.149]   - Field: ‘packages’
[17:43:52.149]   - Field: ‘gc’
[17:43:52.149]   - Field: ‘conditions’
[17:43:52.149]   - Field: ‘expr’
[17:43:52.149]   - Field: ‘uuid’
[17:43:52.149]   - Field: ‘seed’
[17:43:52.149]   - Field: ‘version’
[17:43:52.149]   - Field: ‘result’
[17:43:52.149]   - Field: ‘asynchronous’
[17:43:52.150]   - Field: ‘calls’
[17:43:52.150]   - Field: ‘globals’
[17:43:52.150]   - Field: ‘stdout’
[17:43:52.150]   - Field: ‘earlySignal’
[17:43:52.150]   - Field: ‘lazy’
[17:43:52.150]   - Field: ‘state’
[17:43:52.150] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.150] - Launch lazy future ...
[17:43:52.150] Packages needed by the future expression (n = 0): <none>
[17:43:52.150] Packages needed by future strategies (n = 0): <none>
[17:43:52.151] {
[17:43:52.151]     {
[17:43:52.151]         {
[17:43:52.151]             ...future.startTime <- base::Sys.time()
[17:43:52.151]             {
[17:43:52.151]                 {
[17:43:52.151]                   {
[17:43:52.151]                     base::local({
[17:43:52.151]                       has_future <- base::requireNamespace("future", 
[17:43:52.151]                         quietly = TRUE)
[17:43:52.151]                       if (has_future) {
[17:43:52.151]                         ns <- base::getNamespace("future")
[17:43:52.151]                         version <- ns[[".package"]][["version"]]
[17:43:52.151]                         if (is.null(version)) 
[17:43:52.151]                           version <- utils::packageVersion("future")
[17:43:52.151]                       }
[17:43:52.151]                       else {
[17:43:52.151]                         version <- NULL
[17:43:52.151]                       }
[17:43:52.151]                       if (!has_future || version < "1.8.0") {
[17:43:52.151]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.151]                           "", base::R.version$version.string), 
[17:43:52.151]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.151]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.151]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.151]                             "release", "version")], collapse = " "), 
[17:43:52.151]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.151]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.151]                           info)
[17:43:52.151]                         info <- base::paste(info, collapse = "; ")
[17:43:52.151]                         if (!has_future) {
[17:43:52.151]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.151]                             info)
[17:43:52.151]                         }
[17:43:52.151]                         else {
[17:43:52.151]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.151]                             info, version)
[17:43:52.151]                         }
[17:43:52.151]                         base::stop(msg)
[17:43:52.151]                       }
[17:43:52.151]                     })
[17:43:52.151]                   }
[17:43:52.151]                   ...future.strategy.old <- future::plan("list")
[17:43:52.151]                   options(future.plan = NULL)
[17:43:52.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.151]                 }
[17:43:52.151]                 ...future.workdir <- getwd()
[17:43:52.151]             }
[17:43:52.151]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.151]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.151]         }
[17:43:52.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.151]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.151]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.151]             base::names(...future.oldOptions))
[17:43:52.151]     }
[17:43:52.151]     if (FALSE) {
[17:43:52.151]     }
[17:43:52.151]     else {
[17:43:52.151]         if (TRUE) {
[17:43:52.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.151]                 open = "w")
[17:43:52.151]         }
[17:43:52.151]         else {
[17:43:52.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.151]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.151]         }
[17:43:52.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.151]             base::sink(type = "output", split = FALSE)
[17:43:52.151]             base::close(...future.stdout)
[17:43:52.151]         }, add = TRUE)
[17:43:52.151]     }
[17:43:52.151]     ...future.frame <- base::sys.nframe()
[17:43:52.151]     ...future.conditions <- base::list()
[17:43:52.151]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.151]     if (FALSE) {
[17:43:52.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.151]     }
[17:43:52.151]     ...future.result <- base::tryCatch({
[17:43:52.151]         base::withCallingHandlers({
[17:43:52.151]             ...future.value <- base::withVisible(base::local({
[17:43:52.151]                 do.call(function(...) {
[17:43:52.151]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.151]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.151]                     ...future.globals.maxSize)) {
[17:43:52.151]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.151]                     on.exit(options(oopts), add = TRUE)
[17:43:52.151]                   }
[17:43:52.151]                   {
[17:43:52.151]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.151]                       FUN = function(jj) {
[17:43:52.151]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.151]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.151]                       })
[17:43:52.151]                   }
[17:43:52.151]                 }, args = future.call.arguments)
[17:43:52.151]             }))
[17:43:52.151]             future::FutureResult(value = ...future.value$value, 
[17:43:52.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.151]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.151]                     ...future.globalenv.names))
[17:43:52.151]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.151]         }, condition = base::local({
[17:43:52.151]             c <- base::c
[17:43:52.151]             inherits <- base::inherits
[17:43:52.151]             invokeRestart <- base::invokeRestart
[17:43:52.151]             length <- base::length
[17:43:52.151]             list <- base::list
[17:43:52.151]             seq.int <- base::seq.int
[17:43:52.151]             signalCondition <- base::signalCondition
[17:43:52.151]             sys.calls <- base::sys.calls
[17:43:52.151]             `[[` <- base::`[[`
[17:43:52.151]             `+` <- base::`+`
[17:43:52.151]             `<<-` <- base::`<<-`
[17:43:52.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.151]                   3L)]
[17:43:52.151]             }
[17:43:52.151]             function(cond) {
[17:43:52.151]                 is_error <- inherits(cond, "error")
[17:43:52.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.151]                   NULL)
[17:43:52.151]                 if (is_error) {
[17:43:52.151]                   sessionInformation <- function() {
[17:43:52.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.151]                       search = base::search(), system = base::Sys.info())
[17:43:52.151]                   }
[17:43:52.151]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.151]                     cond$call), session = sessionInformation(), 
[17:43:52.151]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.151]                   signalCondition(cond)
[17:43:52.151]                 }
[17:43:52.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.151]                 "immediateCondition"))) {
[17:43:52.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.151]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.151]                   if (TRUE && !signal) {
[17:43:52.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.151]                     {
[17:43:52.151]                       inherits <- base::inherits
[17:43:52.151]                       invokeRestart <- base::invokeRestart
[17:43:52.151]                       is.null <- base::is.null
[17:43:52.151]                       muffled <- FALSE
[17:43:52.151]                       if (inherits(cond, "message")) {
[17:43:52.151]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.151]                         if (muffled) 
[17:43:52.151]                           invokeRestart("muffleMessage")
[17:43:52.151]                       }
[17:43:52.151]                       else if (inherits(cond, "warning")) {
[17:43:52.151]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.151]                         if (muffled) 
[17:43:52.151]                           invokeRestart("muffleWarning")
[17:43:52.151]                       }
[17:43:52.151]                       else if (inherits(cond, "condition")) {
[17:43:52.151]                         if (!is.null(pattern)) {
[17:43:52.151]                           computeRestarts <- base::computeRestarts
[17:43:52.151]                           grepl <- base::grepl
[17:43:52.151]                           restarts <- computeRestarts(cond)
[17:43:52.151]                           for (restart in restarts) {
[17:43:52.151]                             name <- restart$name
[17:43:52.151]                             if (is.null(name)) 
[17:43:52.151]                               next
[17:43:52.151]                             if (!grepl(pattern, name)) 
[17:43:52.151]                               next
[17:43:52.151]                             invokeRestart(restart)
[17:43:52.151]                             muffled <- TRUE
[17:43:52.151]                             break
[17:43:52.151]                           }
[17:43:52.151]                         }
[17:43:52.151]                       }
[17:43:52.151]                       invisible(muffled)
[17:43:52.151]                     }
[17:43:52.151]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.151]                   }
[17:43:52.151]                 }
[17:43:52.151]                 else {
[17:43:52.151]                   if (TRUE) {
[17:43:52.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.151]                     {
[17:43:52.151]                       inherits <- base::inherits
[17:43:52.151]                       invokeRestart <- base::invokeRestart
[17:43:52.151]                       is.null <- base::is.null
[17:43:52.151]                       muffled <- FALSE
[17:43:52.151]                       if (inherits(cond, "message")) {
[17:43:52.151]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.151]                         if (muffled) 
[17:43:52.151]                           invokeRestart("muffleMessage")
[17:43:52.151]                       }
[17:43:52.151]                       else if (inherits(cond, "warning")) {
[17:43:52.151]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.151]                         if (muffled) 
[17:43:52.151]                           invokeRestart("muffleWarning")
[17:43:52.151]                       }
[17:43:52.151]                       else if (inherits(cond, "condition")) {
[17:43:52.151]                         if (!is.null(pattern)) {
[17:43:52.151]                           computeRestarts <- base::computeRestarts
[17:43:52.151]                           grepl <- base::grepl
[17:43:52.151]                           restarts <- computeRestarts(cond)
[17:43:52.151]                           for (restart in restarts) {
[17:43:52.151]                             name <- restart$name
[17:43:52.151]                             if (is.null(name)) 
[17:43:52.151]                               next
[17:43:52.151]                             if (!grepl(pattern, name)) 
[17:43:52.151]                               next
[17:43:52.151]                             invokeRestart(restart)
[17:43:52.151]                             muffled <- TRUE
[17:43:52.151]                             break
[17:43:52.151]                           }
[17:43:52.151]                         }
[17:43:52.151]                       }
[17:43:52.151]                       invisible(muffled)
[17:43:52.151]                     }
[17:43:52.151]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.151]                   }
[17:43:52.151]                 }
[17:43:52.151]             }
[17:43:52.151]         }))
[17:43:52.151]     }, error = function(ex) {
[17:43:52.151]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.151]                 ...future.rng), started = ...future.startTime, 
[17:43:52.151]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.151]             version = "1.8"), class = "FutureResult")
[17:43:52.151]     }, finally = {
[17:43:52.151]         if (!identical(...future.workdir, getwd())) 
[17:43:52.151]             setwd(...future.workdir)
[17:43:52.151]         {
[17:43:52.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.151]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.151]             }
[17:43:52.151]             base::options(...future.oldOptions)
[17:43:52.151]             if (.Platform$OS.type == "windows") {
[17:43:52.151]                 old_names <- names(...future.oldEnvVars)
[17:43:52.151]                 envs <- base::Sys.getenv()
[17:43:52.151]                 names <- names(envs)
[17:43:52.151]                 common <- intersect(names, old_names)
[17:43:52.151]                 added <- setdiff(names, old_names)
[17:43:52.151]                 removed <- setdiff(old_names, names)
[17:43:52.151]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.151]                   envs[common]]
[17:43:52.151]                 NAMES <- toupper(changed)
[17:43:52.151]                 args <- list()
[17:43:52.151]                 for (kk in seq_along(NAMES)) {
[17:43:52.151]                   name <- changed[[kk]]
[17:43:52.151]                   NAME <- NAMES[[kk]]
[17:43:52.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.151]                     next
[17:43:52.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.151]                 }
[17:43:52.151]                 NAMES <- toupper(added)
[17:43:52.151]                 for (kk in seq_along(NAMES)) {
[17:43:52.151]                   name <- added[[kk]]
[17:43:52.151]                   NAME <- NAMES[[kk]]
[17:43:52.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.151]                     next
[17:43:52.151]                   args[[name]] <- ""
[17:43:52.151]                 }
[17:43:52.151]                 NAMES <- toupper(removed)
[17:43:52.151]                 for (kk in seq_along(NAMES)) {
[17:43:52.151]                   name <- removed[[kk]]
[17:43:52.151]                   NAME <- NAMES[[kk]]
[17:43:52.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.151]                     next
[17:43:52.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.151]                 }
[17:43:52.151]                 if (length(args) > 0) 
[17:43:52.151]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.151]             }
[17:43:52.151]             else {
[17:43:52.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.151]             }
[17:43:52.151]             {
[17:43:52.151]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.151]                   0L) {
[17:43:52.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.151]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.151]                   base::options(opts)
[17:43:52.151]                 }
[17:43:52.151]                 {
[17:43:52.151]                   {
[17:43:52.151]                     NULL
[17:43:52.151]                     RNGkind("Mersenne-Twister")
[17:43:52.151]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.151]                       inherits = FALSE)
[17:43:52.151]                   }
[17:43:52.151]                   options(future.plan = NULL)
[17:43:52.151]                   if (is.na(NA_character_)) 
[17:43:52.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.151]                     .init = FALSE)
[17:43:52.151]                 }
[17:43:52.151]             }
[17:43:52.151]         }
[17:43:52.151]     })
[17:43:52.151]     if (TRUE) {
[17:43:52.151]         base::sink(type = "output", split = FALSE)
[17:43:52.151]         if (TRUE) {
[17:43:52.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.151]         }
[17:43:52.151]         else {
[17:43:52.151]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.151]         }
[17:43:52.151]         base::close(...future.stdout)
[17:43:52.151]         ...future.stdout <- NULL
[17:43:52.151]     }
[17:43:52.151]     ...future.result$conditions <- ...future.conditions
[17:43:52.151]     ...future.result$finished <- base::Sys.time()
[17:43:52.151]     ...future.result
[17:43:52.151] }
[17:43:52.153] assign_globals() ...
[17:43:52.153] List of 5
[17:43:52.153]  $ ...future.FUN            :function (object, ...)  
[17:43:52.153]  $ future.call.arguments    : list()
[17:43:52.153]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.153]  $ ...future.elements_ii    :List of 3
[17:43:52.153]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.153]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.153]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.153]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.153]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.153]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.153]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.153]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.153]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.153]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.153]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.153]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.153]  $ ...future.seeds_ii       : NULL
[17:43:52.153]  $ ...future.globals.maxSize: NULL
[17:43:52.153]  - attr(*, "where")=List of 5
[17:43:52.153]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.153]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.153]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.153]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.153]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.153]  - attr(*, "resolved")= logi FALSE
[17:43:52.153]  - attr(*, "total_size")= num 1240
[17:43:52.153]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.153]  - attr(*, "already-done")= logi TRUE
[17:43:52.163] - copied ‘...future.FUN’ to environment
[17:43:52.163] - copied ‘future.call.arguments’ to environment
[17:43:52.163] - copied ‘...future.elements_ii’ to environment
[17:43:52.163] - copied ‘...future.seeds_ii’ to environment
[17:43:52.163] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.163] assign_globals() ... done
[17:43:52.164] plan(): Setting new future strategy stack:
[17:43:52.164] List of future strategies:
[17:43:52.164] 1. sequential:
[17:43:52.164]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.164]    - tweaked: FALSE
[17:43:52.164]    - call: NULL
[17:43:52.164] plan(): nbrOfWorkers() = 1
[17:43:52.166] plan(): Setting new future strategy stack:
[17:43:52.167] List of future strategies:
[17:43:52.167] 1. sequential:
[17:43:52.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.167]    - tweaked: FALSE
[17:43:52.167]    - call: plan(strategy)
[17:43:52.167] plan(): nbrOfWorkers() = 1
[17:43:52.167] SequentialFuture started (and completed)
[17:43:52.167] - Launch lazy future ... done
[17:43:52.167] run() for ‘SequentialFuture’ ... done
[17:43:52.168] Created future:
[17:43:52.168] SequentialFuture:
[17:43:52.168] Label: ‘future_by-1’
[17:43:52.168] Expression:
[17:43:52.168] {
[17:43:52.168]     do.call(function(...) {
[17:43:52.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.168]             on.exit(options(oopts), add = TRUE)
[17:43:52.168]         }
[17:43:52.168]         {
[17:43:52.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.168]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.168]             })
[17:43:52.168]         }
[17:43:52.168]     }, args = future.call.arguments)
[17:43:52.168] }
[17:43:52.168] Lazy evaluation: FALSE
[17:43:52.168] Asynchronous evaluation: FALSE
[17:43:52.168] Local evaluation: TRUE
[17:43:52.168] Environment: 0x55d6baddf7b8
[17:43:52.168] Capture standard output: TRUE
[17:43:52.168] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.168] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.168] Packages: <none>
[17:43:52.168] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.168] Resolved: TRUE
[17:43:52.168] Value: 5.37 KiB of class ‘list’
[17:43:52.168] Early signaling: FALSE
[17:43:52.168] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.168] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.169] Chunk #1 of 1 ... DONE
[17:43:52.169] Launching 1 futures (chunks) ... DONE
[17:43:52.169] Resolving 1 futures (chunks) ...
[17:43:52.169] resolve() on list ...
[17:43:52.169]  recursive: 0
[17:43:52.169]  length: 1
[17:43:52.169] 
[17:43:52.170] resolved() for ‘SequentialFuture’ ...
[17:43:52.170] - state: ‘finished’
[17:43:52.170] - run: TRUE
[17:43:52.170] - result: ‘FutureResult’
[17:43:52.170] resolved() for ‘SequentialFuture’ ... done
[17:43:52.170] Future #1
[17:43:52.170] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.170] - nx: 1
[17:43:52.170] - relay: TRUE
[17:43:52.170] - stdout: TRUE
[17:43:52.171] - signal: TRUE
[17:43:52.171] - resignal: FALSE
[17:43:52.171] - force: TRUE
[17:43:52.171] - relayed: [n=1] FALSE
[17:43:52.171] - queued futures: [n=1] FALSE
[17:43:52.171]  - until=1
[17:43:52.171]  - relaying element #1
[17:43:52.171] - relayed: [n=1] TRUE
[17:43:52.171] - queued futures: [n=1] TRUE
[17:43:52.171] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.172]  length: 0 (resolved future 1)
[17:43:52.172] Relaying remaining futures
[17:43:52.172] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.172] - nx: 1
[17:43:52.172] - relay: TRUE
[17:43:52.172] - stdout: TRUE
[17:43:52.172] - signal: TRUE
[17:43:52.172] - resignal: FALSE
[17:43:52.172] - force: TRUE
[17:43:52.172] - relayed: [n=1] TRUE
[17:43:52.172] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.173] - relayed: [n=1] TRUE
[17:43:52.173] - queued futures: [n=1] TRUE
[17:43:52.173] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.173] resolve() on list ... DONE
[17:43:52.173]  - Number of value chunks collected: 1
[17:43:52.173] Resolving 1 futures (chunks) ... DONE
[17:43:52.173] Reducing values from 1 chunks ...
[17:43:52.173]  - Number of values collected after concatenation: 3
[17:43:52.173]  - Number of values expected: 3
[17:43:52.173] Reducing values from 1 chunks ... DONE
[17:43:52.174] future_lapply() ... DONE
[17:43:52.174] future_by_internal() ... DONE
[17:43:52.174] future_by_internal() ...
- plan('multicore') ...
[17:43:52.175] plan(): Setting new future strategy stack:
[17:43:52.175] List of future strategies:
[17:43:52.175] 1. multicore:
[17:43:52.175]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.175]    - tweaked: FALSE
[17:43:52.175]    - call: plan(strategy)
[17:43:52.179] plan(): nbrOfWorkers() = 1
[17:43:52.179] future_by_internal() ...
[17:43:52.180] future_lapply() ...
[17:43:52.183] Number of chunks: 1
[17:43:52.183] getGlobalsAndPackagesXApply() ...
[17:43:52.183]  - future.globals: TRUE
[17:43:52.183] getGlobalsAndPackages() ...
[17:43:52.183] Searching for globals...
[17:43:52.185] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.185] Searching for globals ... DONE
[17:43:52.185] Resolving globals: FALSE
[17:43:52.187] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.187] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.187] - globals: [1] ‘FUN’
[17:43:52.187] 
[17:43:52.187] getGlobalsAndPackages() ... DONE
[17:43:52.188]  - globals found/used: [n=1] ‘FUN’
[17:43:52.188]  - needed namespaces: [n=0] 
[17:43:52.188] Finding globals ... DONE
[17:43:52.188]  - use_args: TRUE
[17:43:52.188]  - Getting '...' globals ...
[17:43:52.188] resolve() on list ...
[17:43:52.188]  recursive: 0
[17:43:52.188]  length: 1
[17:43:52.188]  elements: ‘...’
[17:43:52.189]  length: 0 (resolved future 1)
[17:43:52.189] resolve() on list ... DONE
[17:43:52.189]    - '...' content: [n=0] 
[17:43:52.189] List of 1
[17:43:52.189]  $ ...: list()
[17:43:52.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.189]  - attr(*, "where")=List of 1
[17:43:52.189]   ..$ ...:<environment: 0x55d6baf4f6f8> 
[17:43:52.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.189]  - attr(*, "resolved")= logi TRUE
[17:43:52.189]  - attr(*, "total_size")= num NA
[17:43:52.191]  - Getting '...' globals ... DONE
[17:43:52.192] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.192] List of 2
[17:43:52.192]  $ ...future.FUN:function (object, ...)  
[17:43:52.192]  $ ...          : list()
[17:43:52.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.192]  - attr(*, "where")=List of 2
[17:43:52.192]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.192]   ..$ ...          :<environment: 0x55d6baf4f6f8> 
[17:43:52.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.192]  - attr(*, "resolved")= logi FALSE
[17:43:52.192]  - attr(*, "total_size")= num 1240
[17:43:52.194] Packages to be attached in all futures: [n=0] 
[17:43:52.194] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.195] Number of futures (= number of chunks): 1
[17:43:52.195] Launching 1 futures (chunks) ...
[17:43:52.195] Chunk #1 of 1 ...
[17:43:52.195]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.195] getGlobalsAndPackages() ...
[17:43:52.195] Searching for globals...
[17:43:52.196] 
[17:43:52.196] Searching for globals ... DONE
[17:43:52.196] - globals: [0] <none>
[17:43:52.196] getGlobalsAndPackages() ... DONE
[17:43:52.196]    + additional globals found: [n=0] 
[17:43:52.196]    + additional namespaces needed: [n=0] 
[17:43:52.196]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.196]  - seeds: <none>
[17:43:52.196]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.197] getGlobalsAndPackages() ...
[17:43:52.197] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.197] Resolving globals: FALSE
[17:43:52.197] Tweak future expression to call with '...' arguments ...
[17:43:52.197] {
[17:43:52.197]     do.call(function(...) {
[17:43:52.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.197]             on.exit(options(oopts), add = TRUE)
[17:43:52.197]         }
[17:43:52.197]         {
[17:43:52.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.197]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.197]             })
[17:43:52.197]         }
[17:43:52.197]     }, args = future.call.arguments)
[17:43:52.197] }
[17:43:52.197] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.198] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.198] 
[17:43:52.198] getGlobalsAndPackages() ... DONE
[17:43:52.198] run() for ‘Future’ ...
[17:43:52.198] - state: ‘created’
[17:43:52.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.202] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.203]   - Field: ‘label’
[17:43:52.203]   - Field: ‘local’
[17:43:52.203]   - Field: ‘owner’
[17:43:52.203]   - Field: ‘envir’
[17:43:52.203]   - Field: ‘packages’
[17:43:52.203]   - Field: ‘gc’
[17:43:52.203]   - Field: ‘conditions’
[17:43:52.203]   - Field: ‘expr’
[17:43:52.203]   - Field: ‘uuid’
[17:43:52.203]   - Field: ‘seed’
[17:43:52.204]   - Field: ‘version’
[17:43:52.204]   - Field: ‘result’
[17:43:52.204]   - Field: ‘asynchronous’
[17:43:52.204]   - Field: ‘calls’
[17:43:52.204]   - Field: ‘globals’
[17:43:52.204]   - Field: ‘stdout’
[17:43:52.204]   - Field: ‘earlySignal’
[17:43:52.204]   - Field: ‘lazy’
[17:43:52.204]   - Field: ‘state’
[17:43:52.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.204] - Launch lazy future ...
[17:43:52.205] Packages needed by the future expression (n = 0): <none>
[17:43:52.205] Packages needed by future strategies (n = 0): <none>
[17:43:52.205] {
[17:43:52.205]     {
[17:43:52.205]         {
[17:43:52.205]             ...future.startTime <- base::Sys.time()
[17:43:52.205]             {
[17:43:52.205]                 {
[17:43:52.205]                   {
[17:43:52.205]                     base::local({
[17:43:52.205]                       has_future <- base::requireNamespace("future", 
[17:43:52.205]                         quietly = TRUE)
[17:43:52.205]                       if (has_future) {
[17:43:52.205]                         ns <- base::getNamespace("future")
[17:43:52.205]                         version <- ns[[".package"]][["version"]]
[17:43:52.205]                         if (is.null(version)) 
[17:43:52.205]                           version <- utils::packageVersion("future")
[17:43:52.205]                       }
[17:43:52.205]                       else {
[17:43:52.205]                         version <- NULL
[17:43:52.205]                       }
[17:43:52.205]                       if (!has_future || version < "1.8.0") {
[17:43:52.205]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.205]                           "", base::R.version$version.string), 
[17:43:52.205]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.205]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.205]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.205]                             "release", "version")], collapse = " "), 
[17:43:52.205]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.205]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.205]                           info)
[17:43:52.205]                         info <- base::paste(info, collapse = "; ")
[17:43:52.205]                         if (!has_future) {
[17:43:52.205]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.205]                             info)
[17:43:52.205]                         }
[17:43:52.205]                         else {
[17:43:52.205]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.205]                             info, version)
[17:43:52.205]                         }
[17:43:52.205]                         base::stop(msg)
[17:43:52.205]                       }
[17:43:52.205]                     })
[17:43:52.205]                   }
[17:43:52.205]                   ...future.strategy.old <- future::plan("list")
[17:43:52.205]                   options(future.plan = NULL)
[17:43:52.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.205]                 }
[17:43:52.205]                 ...future.workdir <- getwd()
[17:43:52.205]             }
[17:43:52.205]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.205]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.205]         }
[17:43:52.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.205]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.205]             base::names(...future.oldOptions))
[17:43:52.205]     }
[17:43:52.205]     if (FALSE) {
[17:43:52.205]     }
[17:43:52.205]     else {
[17:43:52.205]         if (TRUE) {
[17:43:52.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.205]                 open = "w")
[17:43:52.205]         }
[17:43:52.205]         else {
[17:43:52.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.205]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.205]         }
[17:43:52.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.205]             base::sink(type = "output", split = FALSE)
[17:43:52.205]             base::close(...future.stdout)
[17:43:52.205]         }, add = TRUE)
[17:43:52.205]     }
[17:43:52.205]     ...future.frame <- base::sys.nframe()
[17:43:52.205]     ...future.conditions <- base::list()
[17:43:52.205]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.205]     if (FALSE) {
[17:43:52.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.205]     }
[17:43:52.205]     ...future.result <- base::tryCatch({
[17:43:52.205]         base::withCallingHandlers({
[17:43:52.205]             ...future.value <- base::withVisible(base::local({
[17:43:52.205]                 do.call(function(...) {
[17:43:52.205]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.205]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.205]                     ...future.globals.maxSize)) {
[17:43:52.205]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.205]                     on.exit(options(oopts), add = TRUE)
[17:43:52.205]                   }
[17:43:52.205]                   {
[17:43:52.205]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.205]                       FUN = function(jj) {
[17:43:52.205]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.205]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.205]                       })
[17:43:52.205]                   }
[17:43:52.205]                 }, args = future.call.arguments)
[17:43:52.205]             }))
[17:43:52.205]             future::FutureResult(value = ...future.value$value, 
[17:43:52.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.205]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.205]                     ...future.globalenv.names))
[17:43:52.205]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.205]         }, condition = base::local({
[17:43:52.205]             c <- base::c
[17:43:52.205]             inherits <- base::inherits
[17:43:52.205]             invokeRestart <- base::invokeRestart
[17:43:52.205]             length <- base::length
[17:43:52.205]             list <- base::list
[17:43:52.205]             seq.int <- base::seq.int
[17:43:52.205]             signalCondition <- base::signalCondition
[17:43:52.205]             sys.calls <- base::sys.calls
[17:43:52.205]             `[[` <- base::`[[`
[17:43:52.205]             `+` <- base::`+`
[17:43:52.205]             `<<-` <- base::`<<-`
[17:43:52.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.205]                   3L)]
[17:43:52.205]             }
[17:43:52.205]             function(cond) {
[17:43:52.205]                 is_error <- inherits(cond, "error")
[17:43:52.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.205]                   NULL)
[17:43:52.205]                 if (is_error) {
[17:43:52.205]                   sessionInformation <- function() {
[17:43:52.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.205]                       search = base::search(), system = base::Sys.info())
[17:43:52.205]                   }
[17:43:52.205]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.205]                     cond$call), session = sessionInformation(), 
[17:43:52.205]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.205]                   signalCondition(cond)
[17:43:52.205]                 }
[17:43:52.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.205]                 "immediateCondition"))) {
[17:43:52.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.205]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.205]                   if (TRUE && !signal) {
[17:43:52.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.205]                     {
[17:43:52.205]                       inherits <- base::inherits
[17:43:52.205]                       invokeRestart <- base::invokeRestart
[17:43:52.205]                       is.null <- base::is.null
[17:43:52.205]                       muffled <- FALSE
[17:43:52.205]                       if (inherits(cond, "message")) {
[17:43:52.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.205]                         if (muffled) 
[17:43:52.205]                           invokeRestart("muffleMessage")
[17:43:52.205]                       }
[17:43:52.205]                       else if (inherits(cond, "warning")) {
[17:43:52.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.205]                         if (muffled) 
[17:43:52.205]                           invokeRestart("muffleWarning")
[17:43:52.205]                       }
[17:43:52.205]                       else if (inherits(cond, "condition")) {
[17:43:52.205]                         if (!is.null(pattern)) {
[17:43:52.205]                           computeRestarts <- base::computeRestarts
[17:43:52.205]                           grepl <- base::grepl
[17:43:52.205]                           restarts <- computeRestarts(cond)
[17:43:52.205]                           for (restart in restarts) {
[17:43:52.205]                             name <- restart$name
[17:43:52.205]                             if (is.null(name)) 
[17:43:52.205]                               next
[17:43:52.205]                             if (!grepl(pattern, name)) 
[17:43:52.205]                               next
[17:43:52.205]                             invokeRestart(restart)
[17:43:52.205]                             muffled <- TRUE
[17:43:52.205]                             break
[17:43:52.205]                           }
[17:43:52.205]                         }
[17:43:52.205]                       }
[17:43:52.205]                       invisible(muffled)
[17:43:52.205]                     }
[17:43:52.205]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.205]                   }
[17:43:52.205]                 }
[17:43:52.205]                 else {
[17:43:52.205]                   if (TRUE) {
[17:43:52.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.205]                     {
[17:43:52.205]                       inherits <- base::inherits
[17:43:52.205]                       invokeRestart <- base::invokeRestart
[17:43:52.205]                       is.null <- base::is.null
[17:43:52.205]                       muffled <- FALSE
[17:43:52.205]                       if (inherits(cond, "message")) {
[17:43:52.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.205]                         if (muffled) 
[17:43:52.205]                           invokeRestart("muffleMessage")
[17:43:52.205]                       }
[17:43:52.205]                       else if (inherits(cond, "warning")) {
[17:43:52.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.205]                         if (muffled) 
[17:43:52.205]                           invokeRestart("muffleWarning")
[17:43:52.205]                       }
[17:43:52.205]                       else if (inherits(cond, "condition")) {
[17:43:52.205]                         if (!is.null(pattern)) {
[17:43:52.205]                           computeRestarts <- base::computeRestarts
[17:43:52.205]                           grepl <- base::grepl
[17:43:52.205]                           restarts <- computeRestarts(cond)
[17:43:52.205]                           for (restart in restarts) {
[17:43:52.205]                             name <- restart$name
[17:43:52.205]                             if (is.null(name)) 
[17:43:52.205]                               next
[17:43:52.205]                             if (!grepl(pattern, name)) 
[17:43:52.205]                               next
[17:43:52.205]                             invokeRestart(restart)
[17:43:52.205]                             muffled <- TRUE
[17:43:52.205]                             break
[17:43:52.205]                           }
[17:43:52.205]                         }
[17:43:52.205]                       }
[17:43:52.205]                       invisible(muffled)
[17:43:52.205]                     }
[17:43:52.205]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.205]                   }
[17:43:52.205]                 }
[17:43:52.205]             }
[17:43:52.205]         }))
[17:43:52.205]     }, error = function(ex) {
[17:43:52.205]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.205]                 ...future.rng), started = ...future.startTime, 
[17:43:52.205]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.205]             version = "1.8"), class = "FutureResult")
[17:43:52.205]     }, finally = {
[17:43:52.205]         if (!identical(...future.workdir, getwd())) 
[17:43:52.205]             setwd(...future.workdir)
[17:43:52.205]         {
[17:43:52.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.205]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.205]             }
[17:43:52.205]             base::options(...future.oldOptions)
[17:43:52.205]             if (.Platform$OS.type == "windows") {
[17:43:52.205]                 old_names <- names(...future.oldEnvVars)
[17:43:52.205]                 envs <- base::Sys.getenv()
[17:43:52.205]                 names <- names(envs)
[17:43:52.205]                 common <- intersect(names, old_names)
[17:43:52.205]                 added <- setdiff(names, old_names)
[17:43:52.205]                 removed <- setdiff(old_names, names)
[17:43:52.205]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.205]                   envs[common]]
[17:43:52.205]                 NAMES <- toupper(changed)
[17:43:52.205]                 args <- list()
[17:43:52.205]                 for (kk in seq_along(NAMES)) {
[17:43:52.205]                   name <- changed[[kk]]
[17:43:52.205]                   NAME <- NAMES[[kk]]
[17:43:52.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.205]                     next
[17:43:52.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.205]                 }
[17:43:52.205]                 NAMES <- toupper(added)
[17:43:52.205]                 for (kk in seq_along(NAMES)) {
[17:43:52.205]                   name <- added[[kk]]
[17:43:52.205]                   NAME <- NAMES[[kk]]
[17:43:52.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.205]                     next
[17:43:52.205]                   args[[name]] <- ""
[17:43:52.205]                 }
[17:43:52.205]                 NAMES <- toupper(removed)
[17:43:52.205]                 for (kk in seq_along(NAMES)) {
[17:43:52.205]                   name <- removed[[kk]]
[17:43:52.205]                   NAME <- NAMES[[kk]]
[17:43:52.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.205]                     next
[17:43:52.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.205]                 }
[17:43:52.205]                 if (length(args) > 0) 
[17:43:52.205]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.205]             }
[17:43:52.205]             else {
[17:43:52.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.205]             }
[17:43:52.205]             {
[17:43:52.205]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.205]                   0L) {
[17:43:52.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.205]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.205]                   base::options(opts)
[17:43:52.205]                 }
[17:43:52.205]                 {
[17:43:52.205]                   {
[17:43:52.205]                     NULL
[17:43:52.205]                     RNGkind("Mersenne-Twister")
[17:43:52.205]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.205]                       inherits = FALSE)
[17:43:52.205]                   }
[17:43:52.205]                   options(future.plan = NULL)
[17:43:52.205]                   if (is.na(NA_character_)) 
[17:43:52.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.205]                     .init = FALSE)
[17:43:52.205]                 }
[17:43:52.205]             }
[17:43:52.205]         }
[17:43:52.205]     })
[17:43:52.205]     if (TRUE) {
[17:43:52.205]         base::sink(type = "output", split = FALSE)
[17:43:52.205]         if (TRUE) {
[17:43:52.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.205]         }
[17:43:52.205]         else {
[17:43:52.205]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.205]         }
[17:43:52.205]         base::close(...future.stdout)
[17:43:52.205]         ...future.stdout <- NULL
[17:43:52.205]     }
[17:43:52.205]     ...future.result$conditions <- ...future.conditions
[17:43:52.205]     ...future.result$finished <- base::Sys.time()
[17:43:52.205]     ...future.result
[17:43:52.205] }
[17:43:52.207] assign_globals() ...
[17:43:52.207] List of 5
[17:43:52.207]  $ ...future.FUN            :function (object, ...)  
[17:43:52.207]  $ future.call.arguments    : list()
[17:43:52.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.207]  $ ...future.elements_ii    :List of 3
[17:43:52.207]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.207]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.207]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.207]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.207]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.207]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.207]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.207]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.207]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.207]  $ ...future.seeds_ii       : NULL
[17:43:52.207]  $ ...future.globals.maxSize: NULL
[17:43:52.207]  - attr(*, "where")=List of 5
[17:43:52.207]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.207]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.207]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.207]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.207]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.207]  - attr(*, "resolved")= logi FALSE
[17:43:52.207]  - attr(*, "total_size")= num 1240
[17:43:52.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.207]  - attr(*, "already-done")= logi TRUE
[17:43:52.217] - copied ‘...future.FUN’ to environment
[17:43:52.217] - copied ‘future.call.arguments’ to environment
[17:43:52.218] - copied ‘...future.elements_ii’ to environment
[17:43:52.218] - copied ‘...future.seeds_ii’ to environment
[17:43:52.218] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.218] assign_globals() ... done
[17:43:52.218] plan(): Setting new future strategy stack:
[17:43:52.218] List of future strategies:
[17:43:52.218] 1. sequential:
[17:43:52.218]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.218]    - tweaked: FALSE
[17:43:52.218]    - call: NULL
[17:43:52.219] plan(): nbrOfWorkers() = 1
[17:43:52.221] plan(): Setting new future strategy stack:
[17:43:52.221] List of future strategies:
[17:43:52.221] 1. multicore:
[17:43:52.221]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.221]    - tweaked: FALSE
[17:43:52.221]    - call: plan(strategy)
[17:43:52.225] plan(): nbrOfWorkers() = 1
[17:43:52.225] SequentialFuture started (and completed)
[17:43:52.225] - Launch lazy future ... done
[17:43:52.225] run() for ‘SequentialFuture’ ... done
[17:43:52.225] Created future:
[17:43:52.226] SequentialFuture:
[17:43:52.226] Label: ‘future_by-1’
[17:43:52.226] Expression:
[17:43:52.226] {
[17:43:52.226]     do.call(function(...) {
[17:43:52.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.226]             on.exit(options(oopts), add = TRUE)
[17:43:52.226]         }
[17:43:52.226]         {
[17:43:52.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.226]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.226]             })
[17:43:52.226]         }
[17:43:52.226]     }, args = future.call.arguments)
[17:43:52.226] }
[17:43:52.226] Lazy evaluation: FALSE
[17:43:52.226] Asynchronous evaluation: FALSE
[17:43:52.226] Local evaluation: TRUE
[17:43:52.226] Environment: R_GlobalEnv
[17:43:52.226] Capture standard output: TRUE
[17:43:52.226] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.226] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.226] Packages: <none>
[17:43:52.226] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.226] Resolved: TRUE
[17:43:52.226] Value: 4.62 KiB of class ‘list’
[17:43:52.226] Early signaling: FALSE
[17:43:52.226] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.226] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.227] Chunk #1 of 1 ... DONE
[17:43:52.227] Launching 1 futures (chunks) ... DONE
[17:43:52.227] Resolving 1 futures (chunks) ...
[17:43:52.227] resolve() on list ...
[17:43:52.227]  recursive: 0
[17:43:52.227]  length: 1
[17:43:52.227] 
[17:43:52.227] resolved() for ‘SequentialFuture’ ...
[17:43:52.228] - state: ‘finished’
[17:43:52.228] - run: TRUE
[17:43:52.228] - result: ‘FutureResult’
[17:43:52.228] resolved() for ‘SequentialFuture’ ... done
[17:43:52.228] Future #1
[17:43:52.228] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.228] - nx: 1
[17:43:52.228] - relay: TRUE
[17:43:52.228] - stdout: TRUE
[17:43:52.228] - signal: TRUE
[17:43:52.229] - resignal: FALSE
[17:43:52.229] - force: TRUE
[17:43:52.229] - relayed: [n=1] FALSE
[17:43:52.229] - queued futures: [n=1] FALSE
[17:43:52.229]  - until=1
[17:43:52.229]  - relaying element #1
[17:43:52.229] - relayed: [n=1] TRUE
[17:43:52.229] - queued futures: [n=1] TRUE
[17:43:52.229] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.229]  length: 0 (resolved future 1)
[17:43:52.230] Relaying remaining futures
[17:43:52.230] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.230] - nx: 1
[17:43:52.230] - relay: TRUE
[17:43:52.230] - stdout: TRUE
[17:43:52.230] - signal: TRUE
[17:43:52.230] - resignal: FALSE
[17:43:52.230] - force: TRUE
[17:43:52.230] - relayed: [n=1] TRUE
[17:43:52.230] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.230] - relayed: [n=1] TRUE
[17:43:52.231] - queued futures: [n=1] TRUE
[17:43:52.231] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.231] resolve() on list ... DONE
[17:43:52.231]  - Number of value chunks collected: 1
[17:43:52.231] Resolving 1 futures (chunks) ... DONE
[17:43:52.231] Reducing values from 1 chunks ...
[17:43:52.231]  - Number of values collected after concatenation: 3
[17:43:52.231]  - Number of values expected: 3
[17:43:52.231] Reducing values from 1 chunks ... DONE
[17:43:52.231] future_lapply() ... DONE
[17:43:52.232] future_by_internal() ... DONE
[17:43:52.232] future_by_internal() ...
[17:43:52.232] future_lapply() ...
[17:43:52.236] Number of chunks: 1
[17:43:52.236] getGlobalsAndPackagesXApply() ...
[17:43:52.236]  - future.globals: TRUE
[17:43:52.236] getGlobalsAndPackages() ...
[17:43:52.236] Searching for globals...
[17:43:52.237] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.238] Searching for globals ... DONE
[17:43:52.238] Resolving globals: FALSE
[17:43:52.238] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.238] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.238] - globals: [1] ‘FUN’
[17:43:52.239] 
[17:43:52.241] getGlobalsAndPackages() ... DONE
[17:43:52.241]  - globals found/used: [n=1] ‘FUN’
[17:43:52.241]  - needed namespaces: [n=0] 
[17:43:52.241] Finding globals ... DONE
[17:43:52.241]  - use_args: TRUE
[17:43:52.241]  - Getting '...' globals ...
[17:43:52.241] resolve() on list ...
[17:43:52.242]  recursive: 0
[17:43:52.242]  length: 1
[17:43:52.242]  elements: ‘...’
[17:43:52.242]  length: 0 (resolved future 1)
[17:43:52.242] resolve() on list ... DONE
[17:43:52.242]    - '...' content: [n=1] ‘digits’
[17:43:52.242] List of 1
[17:43:52.242]  $ ...:List of 1
[17:43:52.242]   ..$ digits: int 2
[17:43:52.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.242]  - attr(*, "where")=List of 1
[17:43:52.242]   ..$ ...:<environment: 0x55d6baee4990> 
[17:43:52.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.242]  - attr(*, "resolved")= logi TRUE
[17:43:52.242]  - attr(*, "total_size")= num NA
[17:43:52.245]  - Getting '...' globals ... DONE
[17:43:52.245] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.246] List of 2
[17:43:52.246]  $ ...future.FUN:function (object, ...)  
[17:43:52.246]  $ ...          :List of 1
[17:43:52.246]   ..$ digits: int 2
[17:43:52.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.246]  - attr(*, "where")=List of 2
[17:43:52.246]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.246]   ..$ ...          :<environment: 0x55d6baee4990> 
[17:43:52.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.246]  - attr(*, "resolved")= logi FALSE
[17:43:52.246]  - attr(*, "total_size")= num 1296
[17:43:52.249] Packages to be attached in all futures: [n=0] 
[17:43:52.249] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.249] Number of futures (= number of chunks): 1
[17:43:52.249] Launching 1 futures (chunks) ...
[17:43:52.249] Chunk #1 of 1 ...
[17:43:52.249]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.249] getGlobalsAndPackages() ...
[17:43:52.250] Searching for globals...
[17:43:52.250] 
[17:43:52.250] Searching for globals ... DONE
[17:43:52.250] - globals: [0] <none>
[17:43:52.250] getGlobalsAndPackages() ... DONE
[17:43:52.250]    + additional globals found: [n=0] 
[17:43:52.250]    + additional namespaces needed: [n=0] 
[17:43:52.250]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.250]  - seeds: <none>
[17:43:52.250]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.251] getGlobalsAndPackages() ...
[17:43:52.251] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.251] Resolving globals: FALSE
[17:43:52.251] Tweak future expression to call with '...' arguments ...
[17:43:52.251] {
[17:43:52.251]     do.call(function(...) {
[17:43:52.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.251]             on.exit(options(oopts), add = TRUE)
[17:43:52.251]         }
[17:43:52.251]         {
[17:43:52.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.251]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.251]             })
[17:43:52.251]         }
[17:43:52.251]     }, args = future.call.arguments)
[17:43:52.251] }
[17:43:52.251] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.252] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.252] 
[17:43:52.252] getGlobalsAndPackages() ... DONE
[17:43:52.252] run() for ‘Future’ ...
[17:43:52.252] - state: ‘created’
[17:43:52.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.256]   - Field: ‘label’
[17:43:52.256]   - Field: ‘local’
[17:43:52.256]   - Field: ‘owner’
[17:43:52.257]   - Field: ‘envir’
[17:43:52.257]   - Field: ‘packages’
[17:43:52.257]   - Field: ‘gc’
[17:43:52.257]   - Field: ‘conditions’
[17:43:52.257]   - Field: ‘expr’
[17:43:52.257]   - Field: ‘uuid’
[17:43:52.257]   - Field: ‘seed’
[17:43:52.257]   - Field: ‘version’
[17:43:52.257]   - Field: ‘result’
[17:43:52.257]   - Field: ‘asynchronous’
[17:43:52.257]   - Field: ‘calls’
[17:43:52.258]   - Field: ‘globals’
[17:43:52.258]   - Field: ‘stdout’
[17:43:52.258]   - Field: ‘earlySignal’
[17:43:52.258]   - Field: ‘lazy’
[17:43:52.258]   - Field: ‘state’
[17:43:52.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.258] - Launch lazy future ...
[17:43:52.258] Packages needed by the future expression (n = 0): <none>
[17:43:52.258] Packages needed by future strategies (n = 0): <none>
[17:43:52.259] {
[17:43:52.259]     {
[17:43:52.259]         {
[17:43:52.259]             ...future.startTime <- base::Sys.time()
[17:43:52.259]             {
[17:43:52.259]                 {
[17:43:52.259]                   {
[17:43:52.259]                     base::local({
[17:43:52.259]                       has_future <- base::requireNamespace("future", 
[17:43:52.259]                         quietly = TRUE)
[17:43:52.259]                       if (has_future) {
[17:43:52.259]                         ns <- base::getNamespace("future")
[17:43:52.259]                         version <- ns[[".package"]][["version"]]
[17:43:52.259]                         if (is.null(version)) 
[17:43:52.259]                           version <- utils::packageVersion("future")
[17:43:52.259]                       }
[17:43:52.259]                       else {
[17:43:52.259]                         version <- NULL
[17:43:52.259]                       }
[17:43:52.259]                       if (!has_future || version < "1.8.0") {
[17:43:52.259]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.259]                           "", base::R.version$version.string), 
[17:43:52.259]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.259]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.259]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.259]                             "release", "version")], collapse = " "), 
[17:43:52.259]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.259]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.259]                           info)
[17:43:52.259]                         info <- base::paste(info, collapse = "; ")
[17:43:52.259]                         if (!has_future) {
[17:43:52.259]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.259]                             info)
[17:43:52.259]                         }
[17:43:52.259]                         else {
[17:43:52.259]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.259]                             info, version)
[17:43:52.259]                         }
[17:43:52.259]                         base::stop(msg)
[17:43:52.259]                       }
[17:43:52.259]                     })
[17:43:52.259]                   }
[17:43:52.259]                   ...future.strategy.old <- future::plan("list")
[17:43:52.259]                   options(future.plan = NULL)
[17:43:52.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.259]                 }
[17:43:52.259]                 ...future.workdir <- getwd()
[17:43:52.259]             }
[17:43:52.259]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.259]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.259]         }
[17:43:52.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.259]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.259]             base::names(...future.oldOptions))
[17:43:52.259]     }
[17:43:52.259]     if (FALSE) {
[17:43:52.259]     }
[17:43:52.259]     else {
[17:43:52.259]         if (TRUE) {
[17:43:52.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.259]                 open = "w")
[17:43:52.259]         }
[17:43:52.259]         else {
[17:43:52.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.259]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.259]         }
[17:43:52.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.259]             base::sink(type = "output", split = FALSE)
[17:43:52.259]             base::close(...future.stdout)
[17:43:52.259]         }, add = TRUE)
[17:43:52.259]     }
[17:43:52.259]     ...future.frame <- base::sys.nframe()
[17:43:52.259]     ...future.conditions <- base::list()
[17:43:52.259]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.259]     if (FALSE) {
[17:43:52.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.259]     }
[17:43:52.259]     ...future.result <- base::tryCatch({
[17:43:52.259]         base::withCallingHandlers({
[17:43:52.259]             ...future.value <- base::withVisible(base::local({
[17:43:52.259]                 do.call(function(...) {
[17:43:52.259]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.259]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.259]                     ...future.globals.maxSize)) {
[17:43:52.259]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.259]                     on.exit(options(oopts), add = TRUE)
[17:43:52.259]                   }
[17:43:52.259]                   {
[17:43:52.259]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.259]                       FUN = function(jj) {
[17:43:52.259]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.259]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.259]                       })
[17:43:52.259]                   }
[17:43:52.259]                 }, args = future.call.arguments)
[17:43:52.259]             }))
[17:43:52.259]             future::FutureResult(value = ...future.value$value, 
[17:43:52.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.259]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.259]                     ...future.globalenv.names))
[17:43:52.259]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.259]         }, condition = base::local({
[17:43:52.259]             c <- base::c
[17:43:52.259]             inherits <- base::inherits
[17:43:52.259]             invokeRestart <- base::invokeRestart
[17:43:52.259]             length <- base::length
[17:43:52.259]             list <- base::list
[17:43:52.259]             seq.int <- base::seq.int
[17:43:52.259]             signalCondition <- base::signalCondition
[17:43:52.259]             sys.calls <- base::sys.calls
[17:43:52.259]             `[[` <- base::`[[`
[17:43:52.259]             `+` <- base::`+`
[17:43:52.259]             `<<-` <- base::`<<-`
[17:43:52.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.259]                   3L)]
[17:43:52.259]             }
[17:43:52.259]             function(cond) {
[17:43:52.259]                 is_error <- inherits(cond, "error")
[17:43:52.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.259]                   NULL)
[17:43:52.259]                 if (is_error) {
[17:43:52.259]                   sessionInformation <- function() {
[17:43:52.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.259]                       search = base::search(), system = base::Sys.info())
[17:43:52.259]                   }
[17:43:52.259]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.259]                     cond$call), session = sessionInformation(), 
[17:43:52.259]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.259]                   signalCondition(cond)
[17:43:52.259]                 }
[17:43:52.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.259]                 "immediateCondition"))) {
[17:43:52.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.259]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.259]                   if (TRUE && !signal) {
[17:43:52.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.259]                     {
[17:43:52.259]                       inherits <- base::inherits
[17:43:52.259]                       invokeRestart <- base::invokeRestart
[17:43:52.259]                       is.null <- base::is.null
[17:43:52.259]                       muffled <- FALSE
[17:43:52.259]                       if (inherits(cond, "message")) {
[17:43:52.259]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.259]                         if (muffled) 
[17:43:52.259]                           invokeRestart("muffleMessage")
[17:43:52.259]                       }
[17:43:52.259]                       else if (inherits(cond, "warning")) {
[17:43:52.259]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.259]                         if (muffled) 
[17:43:52.259]                           invokeRestart("muffleWarning")
[17:43:52.259]                       }
[17:43:52.259]                       else if (inherits(cond, "condition")) {
[17:43:52.259]                         if (!is.null(pattern)) {
[17:43:52.259]                           computeRestarts <- base::computeRestarts
[17:43:52.259]                           grepl <- base::grepl
[17:43:52.259]                           restarts <- computeRestarts(cond)
[17:43:52.259]                           for (restart in restarts) {
[17:43:52.259]                             name <- restart$name
[17:43:52.259]                             if (is.null(name)) 
[17:43:52.259]                               next
[17:43:52.259]                             if (!grepl(pattern, name)) 
[17:43:52.259]                               next
[17:43:52.259]                             invokeRestart(restart)
[17:43:52.259]                             muffled <- TRUE
[17:43:52.259]                             break
[17:43:52.259]                           }
[17:43:52.259]                         }
[17:43:52.259]                       }
[17:43:52.259]                       invisible(muffled)
[17:43:52.259]                     }
[17:43:52.259]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.259]                   }
[17:43:52.259]                 }
[17:43:52.259]                 else {
[17:43:52.259]                   if (TRUE) {
[17:43:52.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.259]                     {
[17:43:52.259]                       inherits <- base::inherits
[17:43:52.259]                       invokeRestart <- base::invokeRestart
[17:43:52.259]                       is.null <- base::is.null
[17:43:52.259]                       muffled <- FALSE
[17:43:52.259]                       if (inherits(cond, "message")) {
[17:43:52.259]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.259]                         if (muffled) 
[17:43:52.259]                           invokeRestart("muffleMessage")
[17:43:52.259]                       }
[17:43:52.259]                       else if (inherits(cond, "warning")) {
[17:43:52.259]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.259]                         if (muffled) 
[17:43:52.259]                           invokeRestart("muffleWarning")
[17:43:52.259]                       }
[17:43:52.259]                       else if (inherits(cond, "condition")) {
[17:43:52.259]                         if (!is.null(pattern)) {
[17:43:52.259]                           computeRestarts <- base::computeRestarts
[17:43:52.259]                           grepl <- base::grepl
[17:43:52.259]                           restarts <- computeRestarts(cond)
[17:43:52.259]                           for (restart in restarts) {
[17:43:52.259]                             name <- restart$name
[17:43:52.259]                             if (is.null(name)) 
[17:43:52.259]                               next
[17:43:52.259]                             if (!grepl(pattern, name)) 
[17:43:52.259]                               next
[17:43:52.259]                             invokeRestart(restart)
[17:43:52.259]                             muffled <- TRUE
[17:43:52.259]                             break
[17:43:52.259]                           }
[17:43:52.259]                         }
[17:43:52.259]                       }
[17:43:52.259]                       invisible(muffled)
[17:43:52.259]                     }
[17:43:52.259]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.259]                   }
[17:43:52.259]                 }
[17:43:52.259]             }
[17:43:52.259]         }))
[17:43:52.259]     }, error = function(ex) {
[17:43:52.259]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.259]                 ...future.rng), started = ...future.startTime, 
[17:43:52.259]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.259]             version = "1.8"), class = "FutureResult")
[17:43:52.259]     }, finally = {
[17:43:52.259]         if (!identical(...future.workdir, getwd())) 
[17:43:52.259]             setwd(...future.workdir)
[17:43:52.259]         {
[17:43:52.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.259]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.259]             }
[17:43:52.259]             base::options(...future.oldOptions)
[17:43:52.259]             if (.Platform$OS.type == "windows") {
[17:43:52.259]                 old_names <- names(...future.oldEnvVars)
[17:43:52.259]                 envs <- base::Sys.getenv()
[17:43:52.259]                 names <- names(envs)
[17:43:52.259]                 common <- intersect(names, old_names)
[17:43:52.259]                 added <- setdiff(names, old_names)
[17:43:52.259]                 removed <- setdiff(old_names, names)
[17:43:52.259]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.259]                   envs[common]]
[17:43:52.259]                 NAMES <- toupper(changed)
[17:43:52.259]                 args <- list()
[17:43:52.259]                 for (kk in seq_along(NAMES)) {
[17:43:52.259]                   name <- changed[[kk]]
[17:43:52.259]                   NAME <- NAMES[[kk]]
[17:43:52.259]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.259]                     next
[17:43:52.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.259]                 }
[17:43:52.259]                 NAMES <- toupper(added)
[17:43:52.259]                 for (kk in seq_along(NAMES)) {
[17:43:52.259]                   name <- added[[kk]]
[17:43:52.259]                   NAME <- NAMES[[kk]]
[17:43:52.259]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.259]                     next
[17:43:52.259]                   args[[name]] <- ""
[17:43:52.259]                 }
[17:43:52.259]                 NAMES <- toupper(removed)
[17:43:52.259]                 for (kk in seq_along(NAMES)) {
[17:43:52.259]                   name <- removed[[kk]]
[17:43:52.259]                   NAME <- NAMES[[kk]]
[17:43:52.259]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.259]                     next
[17:43:52.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.259]                 }
[17:43:52.259]                 if (length(args) > 0) 
[17:43:52.259]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.259]             }
[17:43:52.259]             else {
[17:43:52.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.259]             }
[17:43:52.259]             {
[17:43:52.259]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.259]                   0L) {
[17:43:52.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.259]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.259]                   base::options(opts)
[17:43:52.259]                 }
[17:43:52.259]                 {
[17:43:52.259]                   {
[17:43:52.259]                     NULL
[17:43:52.259]                     RNGkind("Mersenne-Twister")
[17:43:52.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.259]                       inherits = FALSE)
[17:43:52.259]                   }
[17:43:52.259]                   options(future.plan = NULL)
[17:43:52.259]                   if (is.na(NA_character_)) 
[17:43:52.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.259]                     .init = FALSE)
[17:43:52.259]                 }
[17:43:52.259]             }
[17:43:52.259]         }
[17:43:52.259]     })
[17:43:52.259]     if (TRUE) {
[17:43:52.259]         base::sink(type = "output", split = FALSE)
[17:43:52.259]         if (TRUE) {
[17:43:52.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.259]         }
[17:43:52.259]         else {
[17:43:52.259]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.259]         }
[17:43:52.259]         base::close(...future.stdout)
[17:43:52.259]         ...future.stdout <- NULL
[17:43:52.259]     }
[17:43:52.259]     ...future.result$conditions <- ...future.conditions
[17:43:52.259]     ...future.result$finished <- base::Sys.time()
[17:43:52.259]     ...future.result
[17:43:52.259] }
[17:43:52.261] assign_globals() ...
[17:43:52.261] List of 5
[17:43:52.261]  $ ...future.FUN            :function (object, ...)  
[17:43:52.261]  $ future.call.arguments    :List of 1
[17:43:52.261]   ..$ digits: int 2
[17:43:52.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.261]  $ ...future.elements_ii    :List of 6
[17:43:52.261]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:43:52.261]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:43:52.261]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:43:52.261]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:43:52.261]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:43:52.261]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:43:52.261]  $ ...future.seeds_ii       : NULL
[17:43:52.261]  $ ...future.globals.maxSize: NULL
[17:43:52.261]  - attr(*, "where")=List of 5
[17:43:52.261]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.261]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.261]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.261]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.261]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.261]  - attr(*, "resolved")= logi FALSE
[17:43:52.261]  - attr(*, "total_size")= num 1296
[17:43:52.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.261]  - attr(*, "already-done")= logi TRUE
[17:43:52.270] - copied ‘...future.FUN’ to environment
[17:43:52.270] - copied ‘future.call.arguments’ to environment
[17:43:52.270] - copied ‘...future.elements_ii’ to environment
[17:43:52.270] - copied ‘...future.seeds_ii’ to environment
[17:43:52.270] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.270] assign_globals() ... done
[17:43:52.270] plan(): Setting new future strategy stack:
[17:43:52.270] List of future strategies:
[17:43:52.270] 1. sequential:
[17:43:52.270]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.270]    - tweaked: FALSE
[17:43:52.270]    - call: NULL
[17:43:52.271] plan(): nbrOfWorkers() = 1
[17:43:52.272] plan(): Setting new future strategy stack:
[17:43:52.272] List of future strategies:
[17:43:52.272] 1. multicore:
[17:43:52.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.272]    - tweaked: FALSE
[17:43:52.272]    - call: plan(strategy)
[17:43:52.276] plan(): nbrOfWorkers() = 1
[17:43:52.276] SequentialFuture started (and completed)
[17:43:52.276] - Launch lazy future ... done
[17:43:52.277] run() for ‘SequentialFuture’ ... done
[17:43:52.277] Created future:
[17:43:52.277] SequentialFuture:
[17:43:52.277] Label: ‘future_by-1’
[17:43:52.277] Expression:
[17:43:52.277] {
[17:43:52.277]     do.call(function(...) {
[17:43:52.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.277]             on.exit(options(oopts), add = TRUE)
[17:43:52.277]         }
[17:43:52.277]         {
[17:43:52.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.277]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.277]             })
[17:43:52.277]         }
[17:43:52.277]     }, args = future.call.arguments)
[17:43:52.277] }
[17:43:52.277] Lazy evaluation: FALSE
[17:43:52.277] Asynchronous evaluation: FALSE
[17:43:52.277] Local evaluation: TRUE
[17:43:52.277] Environment: R_GlobalEnv
[17:43:52.277] Capture standard output: TRUE
[17:43:52.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.277] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.277] Packages: <none>
[17:43:52.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.277] Resolved: TRUE
[17:43:52.277] Value: 5.48 KiB of class ‘list’
[17:43:52.277] Early signaling: FALSE
[17:43:52.277] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.277] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.278] Chunk #1 of 1 ... DONE
[17:43:52.278] Launching 1 futures (chunks) ... DONE
[17:43:52.278] Resolving 1 futures (chunks) ...
[17:43:52.278] resolve() on list ...
[17:43:52.278]  recursive: 0
[17:43:52.278]  length: 1
[17:43:52.278] 
[17:43:52.279] resolved() for ‘SequentialFuture’ ...
[17:43:52.279] - state: ‘finished’
[17:43:52.279] - run: TRUE
[17:43:52.279] - result: ‘FutureResult’
[17:43:52.279] resolved() for ‘SequentialFuture’ ... done
[17:43:52.279] Future #1
[17:43:52.279] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.279] - nx: 1
[17:43:52.279] - relay: TRUE
[17:43:52.279] - stdout: TRUE
[17:43:52.280] - signal: TRUE
[17:43:52.280] - resignal: FALSE
[17:43:52.280] - force: TRUE
[17:43:52.280] - relayed: [n=1] FALSE
[17:43:52.280] - queued futures: [n=1] FALSE
[17:43:52.280]  - until=1
[17:43:52.280]  - relaying element #1
[17:43:52.280] - relayed: [n=1] TRUE
[17:43:52.280] - queued futures: [n=1] TRUE
[17:43:52.280] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.281]  length: 0 (resolved future 1)
[17:43:52.281] Relaying remaining futures
[17:43:52.281] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.281] - nx: 1
[17:43:52.281] - relay: TRUE
[17:43:52.281] - stdout: TRUE
[17:43:52.281] - signal: TRUE
[17:43:52.281] - resignal: FALSE
[17:43:52.281] - force: TRUE
[17:43:52.281] - relayed: [n=1] TRUE
[17:43:52.281] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.281] - relayed: [n=1] TRUE
[17:43:52.282] - queued futures: [n=1] TRUE
[17:43:52.282] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.282] resolve() on list ... DONE
[17:43:52.282]  - Number of value chunks collected: 1
[17:43:52.282] Resolving 1 futures (chunks) ... DONE
[17:43:52.282] Reducing values from 1 chunks ...
[17:43:52.282]  - Number of values collected after concatenation: 6
[17:43:52.282]  - Number of values expected: 6
[17:43:52.282] Reducing values from 1 chunks ... DONE
[17:43:52.282] future_lapply() ... DONE
[17:43:52.282] future_by_internal() ... DONE
[17:43:52.284] future_by_internal() ...
[17:43:52.284] future_lapply() ...
[17:43:52.288] Number of chunks: 1
[17:43:52.288] getGlobalsAndPackagesXApply() ...
[17:43:52.288]  - future.globals: TRUE
[17:43:52.288] getGlobalsAndPackages() ...
[17:43:52.288] Searching for globals...
[17:43:52.292] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.292] Searching for globals ... DONE
[17:43:52.292] Resolving globals: FALSE
[17:43:52.292] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:43:52.293] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:43:52.293] - globals: [1] ‘FUN’
[17:43:52.293] - packages: [1] ‘stats’
[17:43:52.293] getGlobalsAndPackages() ... DONE
[17:43:52.293]  - globals found/used: [n=1] ‘FUN’
[17:43:52.293]  - needed namespaces: [n=1] ‘stats’
[17:43:52.293] Finding globals ... DONE
[17:43:52.294]  - use_args: TRUE
[17:43:52.294]  - Getting '...' globals ...
[17:43:52.294] resolve() on list ...
[17:43:52.294]  recursive: 0
[17:43:52.294]  length: 1
[17:43:52.294]  elements: ‘...’
[17:43:52.294]  length: 0 (resolved future 1)
[17:43:52.294] resolve() on list ... DONE
[17:43:52.295]    - '...' content: [n=1] ‘singular.ok’
[17:43:52.295] List of 1
[17:43:52.295]  $ ...:List of 1
[17:43:52.295]   ..$ singular.ok: logi FALSE
[17:43:52.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.295]  - attr(*, "where")=List of 1
[17:43:52.295]   ..$ ...:<environment: 0x55d6baf16e60> 
[17:43:52.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.295]  - attr(*, "resolved")= logi TRUE
[17:43:52.295]  - attr(*, "total_size")= num NA
[17:43:52.298]  - Getting '...' globals ... DONE
[17:43:52.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.298] List of 2
[17:43:52.298]  $ ...future.FUN:function (x, ...)  
[17:43:52.298]  $ ...          :List of 1
[17:43:52.298]   ..$ singular.ok: logi FALSE
[17:43:52.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.298]  - attr(*, "where")=List of 2
[17:43:52.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.298]   ..$ ...          :<environment: 0x55d6baf16e60> 
[17:43:52.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.298]  - attr(*, "resolved")= logi FALSE
[17:43:52.298]  - attr(*, "total_size")= num 5384
[17:43:52.301] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.301] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.301] Number of futures (= number of chunks): 1
[17:43:52.301] Launching 1 futures (chunks) ...
[17:43:52.301] Chunk #1 of 1 ...
[17:43:52.302]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.302] getGlobalsAndPackages() ...
[17:43:52.302] Searching for globals...
[17:43:52.302] 
[17:43:52.302] Searching for globals ... DONE
[17:43:52.302] - globals: [0] <none>
[17:43:52.303] getGlobalsAndPackages() ... DONE
[17:43:52.303]    + additional globals found: [n=0] 
[17:43:52.303]    + additional namespaces needed: [n=0] 
[17:43:52.303]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.303]  - seeds: <none>
[17:43:52.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.303] getGlobalsAndPackages() ...
[17:43:52.303] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.303] Resolving globals: FALSE
[17:43:52.303] Tweak future expression to call with '...' arguments ...
[17:43:52.304] {
[17:43:52.304]     do.call(function(...) {
[17:43:52.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.304]             on.exit(options(oopts), add = TRUE)
[17:43:52.304]         }
[17:43:52.304]         {
[17:43:52.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.304]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.304]             })
[17:43:52.304]         }
[17:43:52.304]     }, args = future.call.arguments)
[17:43:52.304] }
[17:43:52.304] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.304] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.304] 
[17:43:52.304] getGlobalsAndPackages() ... DONE
[17:43:52.305] run() for ‘Future’ ...
[17:43:52.305] - state: ‘created’
[17:43:52.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.308] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.309]   - Field: ‘label’
[17:43:52.309]   - Field: ‘local’
[17:43:52.309]   - Field: ‘owner’
[17:43:52.309]   - Field: ‘envir’
[17:43:52.309]   - Field: ‘packages’
[17:43:52.309]   - Field: ‘gc’
[17:43:52.309]   - Field: ‘conditions’
[17:43:52.309]   - Field: ‘expr’
[17:43:52.309]   - Field: ‘uuid’
[17:43:52.310]   - Field: ‘seed’
[17:43:52.310]   - Field: ‘version’
[17:43:52.310]   - Field: ‘result’
[17:43:52.310]   - Field: ‘asynchronous’
[17:43:52.310]   - Field: ‘calls’
[17:43:52.310]   - Field: ‘globals’
[17:43:52.310]   - Field: ‘stdout’
[17:43:52.310]   - Field: ‘earlySignal’
[17:43:52.310]   - Field: ‘lazy’
[17:43:52.310]   - Field: ‘state’
[17:43:52.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.311] - Launch lazy future ...
[17:43:52.311] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.311] Packages needed by future strategies (n = 0): <none>
[17:43:52.311] {
[17:43:52.311]     {
[17:43:52.311]         {
[17:43:52.311]             ...future.startTime <- base::Sys.time()
[17:43:52.311]             {
[17:43:52.311]                 {
[17:43:52.311]                   {
[17:43:52.311]                     {
[17:43:52.311]                       base::local({
[17:43:52.311]                         has_future <- base::requireNamespace("future", 
[17:43:52.311]                           quietly = TRUE)
[17:43:52.311]                         if (has_future) {
[17:43:52.311]                           ns <- base::getNamespace("future")
[17:43:52.311]                           version <- ns[[".package"]][["version"]]
[17:43:52.311]                           if (is.null(version)) 
[17:43:52.311]                             version <- utils::packageVersion("future")
[17:43:52.311]                         }
[17:43:52.311]                         else {
[17:43:52.311]                           version <- NULL
[17:43:52.311]                         }
[17:43:52.311]                         if (!has_future || version < "1.8.0") {
[17:43:52.311]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.311]                             "", base::R.version$version.string), 
[17:43:52.311]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.311]                               "release", "version")], collapse = " "), 
[17:43:52.311]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.311]                             info)
[17:43:52.311]                           info <- base::paste(info, collapse = "; ")
[17:43:52.311]                           if (!has_future) {
[17:43:52.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.311]                               info)
[17:43:52.311]                           }
[17:43:52.311]                           else {
[17:43:52.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.311]                               info, version)
[17:43:52.311]                           }
[17:43:52.311]                           base::stop(msg)
[17:43:52.311]                         }
[17:43:52.311]                       })
[17:43:52.311]                     }
[17:43:52.311]                     base::local({
[17:43:52.311]                       for (pkg in "stats") {
[17:43:52.311]                         base::loadNamespace(pkg)
[17:43:52.311]                         base::library(pkg, character.only = TRUE)
[17:43:52.311]                       }
[17:43:52.311]                     })
[17:43:52.311]                   }
[17:43:52.311]                   ...future.strategy.old <- future::plan("list")
[17:43:52.311]                   options(future.plan = NULL)
[17:43:52.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.311]                 }
[17:43:52.311]                 ...future.workdir <- getwd()
[17:43:52.311]             }
[17:43:52.311]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.311]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.311]         }
[17:43:52.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.311]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.311]             base::names(...future.oldOptions))
[17:43:52.311]     }
[17:43:52.311]     if (FALSE) {
[17:43:52.311]     }
[17:43:52.311]     else {
[17:43:52.311]         if (TRUE) {
[17:43:52.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.311]                 open = "w")
[17:43:52.311]         }
[17:43:52.311]         else {
[17:43:52.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.311]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.311]         }
[17:43:52.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.311]             base::sink(type = "output", split = FALSE)
[17:43:52.311]             base::close(...future.stdout)
[17:43:52.311]         }, add = TRUE)
[17:43:52.311]     }
[17:43:52.311]     ...future.frame <- base::sys.nframe()
[17:43:52.311]     ...future.conditions <- base::list()
[17:43:52.311]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.311]     if (FALSE) {
[17:43:52.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.311]     }
[17:43:52.311]     ...future.result <- base::tryCatch({
[17:43:52.311]         base::withCallingHandlers({
[17:43:52.311]             ...future.value <- base::withVisible(base::local({
[17:43:52.311]                 do.call(function(...) {
[17:43:52.311]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.311]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.311]                     ...future.globals.maxSize)) {
[17:43:52.311]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.311]                     on.exit(options(oopts), add = TRUE)
[17:43:52.311]                   }
[17:43:52.311]                   {
[17:43:52.311]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.311]                       FUN = function(jj) {
[17:43:52.311]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.311]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.311]                       })
[17:43:52.311]                   }
[17:43:52.311]                 }, args = future.call.arguments)
[17:43:52.311]             }))
[17:43:52.311]             future::FutureResult(value = ...future.value$value, 
[17:43:52.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.311]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.311]                     ...future.globalenv.names))
[17:43:52.311]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.311]         }, condition = base::local({
[17:43:52.311]             c <- base::c
[17:43:52.311]             inherits <- base::inherits
[17:43:52.311]             invokeRestart <- base::invokeRestart
[17:43:52.311]             length <- base::length
[17:43:52.311]             list <- base::list
[17:43:52.311]             seq.int <- base::seq.int
[17:43:52.311]             signalCondition <- base::signalCondition
[17:43:52.311]             sys.calls <- base::sys.calls
[17:43:52.311]             `[[` <- base::`[[`
[17:43:52.311]             `+` <- base::`+`
[17:43:52.311]             `<<-` <- base::`<<-`
[17:43:52.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.311]                   3L)]
[17:43:52.311]             }
[17:43:52.311]             function(cond) {
[17:43:52.311]                 is_error <- inherits(cond, "error")
[17:43:52.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.311]                   NULL)
[17:43:52.311]                 if (is_error) {
[17:43:52.311]                   sessionInformation <- function() {
[17:43:52.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.311]                       search = base::search(), system = base::Sys.info())
[17:43:52.311]                   }
[17:43:52.311]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.311]                     cond$call), session = sessionInformation(), 
[17:43:52.311]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.311]                   signalCondition(cond)
[17:43:52.311]                 }
[17:43:52.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.311]                 "immediateCondition"))) {
[17:43:52.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.311]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.311]                   if (TRUE && !signal) {
[17:43:52.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.311]                     {
[17:43:52.311]                       inherits <- base::inherits
[17:43:52.311]                       invokeRestart <- base::invokeRestart
[17:43:52.311]                       is.null <- base::is.null
[17:43:52.311]                       muffled <- FALSE
[17:43:52.311]                       if (inherits(cond, "message")) {
[17:43:52.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.311]                         if (muffled) 
[17:43:52.311]                           invokeRestart("muffleMessage")
[17:43:52.311]                       }
[17:43:52.311]                       else if (inherits(cond, "warning")) {
[17:43:52.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.311]                         if (muffled) 
[17:43:52.311]                           invokeRestart("muffleWarning")
[17:43:52.311]                       }
[17:43:52.311]                       else if (inherits(cond, "condition")) {
[17:43:52.311]                         if (!is.null(pattern)) {
[17:43:52.311]                           computeRestarts <- base::computeRestarts
[17:43:52.311]                           grepl <- base::grepl
[17:43:52.311]                           restarts <- computeRestarts(cond)
[17:43:52.311]                           for (restart in restarts) {
[17:43:52.311]                             name <- restart$name
[17:43:52.311]                             if (is.null(name)) 
[17:43:52.311]                               next
[17:43:52.311]                             if (!grepl(pattern, name)) 
[17:43:52.311]                               next
[17:43:52.311]                             invokeRestart(restart)
[17:43:52.311]                             muffled <- TRUE
[17:43:52.311]                             break
[17:43:52.311]                           }
[17:43:52.311]                         }
[17:43:52.311]                       }
[17:43:52.311]                       invisible(muffled)
[17:43:52.311]                     }
[17:43:52.311]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.311]                   }
[17:43:52.311]                 }
[17:43:52.311]                 else {
[17:43:52.311]                   if (TRUE) {
[17:43:52.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.311]                     {
[17:43:52.311]                       inherits <- base::inherits
[17:43:52.311]                       invokeRestart <- base::invokeRestart
[17:43:52.311]                       is.null <- base::is.null
[17:43:52.311]                       muffled <- FALSE
[17:43:52.311]                       if (inherits(cond, "message")) {
[17:43:52.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.311]                         if (muffled) 
[17:43:52.311]                           invokeRestart("muffleMessage")
[17:43:52.311]                       }
[17:43:52.311]                       else if (inherits(cond, "warning")) {
[17:43:52.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.311]                         if (muffled) 
[17:43:52.311]                           invokeRestart("muffleWarning")
[17:43:52.311]                       }
[17:43:52.311]                       else if (inherits(cond, "condition")) {
[17:43:52.311]                         if (!is.null(pattern)) {
[17:43:52.311]                           computeRestarts <- base::computeRestarts
[17:43:52.311]                           grepl <- base::grepl
[17:43:52.311]                           restarts <- computeRestarts(cond)
[17:43:52.311]                           for (restart in restarts) {
[17:43:52.311]                             name <- restart$name
[17:43:52.311]                             if (is.null(name)) 
[17:43:52.311]                               next
[17:43:52.311]                             if (!grepl(pattern, name)) 
[17:43:52.311]                               next
[17:43:52.311]                             invokeRestart(restart)
[17:43:52.311]                             muffled <- TRUE
[17:43:52.311]                             break
[17:43:52.311]                           }
[17:43:52.311]                         }
[17:43:52.311]                       }
[17:43:52.311]                       invisible(muffled)
[17:43:52.311]                     }
[17:43:52.311]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.311]                   }
[17:43:52.311]                 }
[17:43:52.311]             }
[17:43:52.311]         }))
[17:43:52.311]     }, error = function(ex) {
[17:43:52.311]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.311]                 ...future.rng), started = ...future.startTime, 
[17:43:52.311]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.311]             version = "1.8"), class = "FutureResult")
[17:43:52.311]     }, finally = {
[17:43:52.311]         if (!identical(...future.workdir, getwd())) 
[17:43:52.311]             setwd(...future.workdir)
[17:43:52.311]         {
[17:43:52.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.311]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.311]             }
[17:43:52.311]             base::options(...future.oldOptions)
[17:43:52.311]             if (.Platform$OS.type == "windows") {
[17:43:52.311]                 old_names <- names(...future.oldEnvVars)
[17:43:52.311]                 envs <- base::Sys.getenv()
[17:43:52.311]                 names <- names(envs)
[17:43:52.311]                 common <- intersect(names, old_names)
[17:43:52.311]                 added <- setdiff(names, old_names)
[17:43:52.311]                 removed <- setdiff(old_names, names)
[17:43:52.311]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.311]                   envs[common]]
[17:43:52.311]                 NAMES <- toupper(changed)
[17:43:52.311]                 args <- list()
[17:43:52.311]                 for (kk in seq_along(NAMES)) {
[17:43:52.311]                   name <- changed[[kk]]
[17:43:52.311]                   NAME <- NAMES[[kk]]
[17:43:52.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.311]                     next
[17:43:52.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.311]                 }
[17:43:52.311]                 NAMES <- toupper(added)
[17:43:52.311]                 for (kk in seq_along(NAMES)) {
[17:43:52.311]                   name <- added[[kk]]
[17:43:52.311]                   NAME <- NAMES[[kk]]
[17:43:52.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.311]                     next
[17:43:52.311]                   args[[name]] <- ""
[17:43:52.311]                 }
[17:43:52.311]                 NAMES <- toupper(removed)
[17:43:52.311]                 for (kk in seq_along(NAMES)) {
[17:43:52.311]                   name <- removed[[kk]]
[17:43:52.311]                   NAME <- NAMES[[kk]]
[17:43:52.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.311]                     next
[17:43:52.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.311]                 }
[17:43:52.311]                 if (length(args) > 0) 
[17:43:52.311]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.311]             }
[17:43:52.311]             else {
[17:43:52.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.311]             }
[17:43:52.311]             {
[17:43:52.311]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.311]                   0L) {
[17:43:52.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.311]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.311]                   base::options(opts)
[17:43:52.311]                 }
[17:43:52.311]                 {
[17:43:52.311]                   {
[17:43:52.311]                     NULL
[17:43:52.311]                     RNGkind("Mersenne-Twister")
[17:43:52.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.311]                       inherits = FALSE)
[17:43:52.311]                   }
[17:43:52.311]                   options(future.plan = NULL)
[17:43:52.311]                   if (is.na(NA_character_)) 
[17:43:52.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.311]                     .init = FALSE)
[17:43:52.311]                 }
[17:43:52.311]             }
[17:43:52.311]         }
[17:43:52.311]     })
[17:43:52.311]     if (TRUE) {
[17:43:52.311]         base::sink(type = "output", split = FALSE)
[17:43:52.311]         if (TRUE) {
[17:43:52.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.311]         }
[17:43:52.311]         else {
[17:43:52.311]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.311]         }
[17:43:52.311]         base::close(...future.stdout)
[17:43:52.311]         ...future.stdout <- NULL
[17:43:52.311]     }
[17:43:52.311]     ...future.result$conditions <- ...future.conditions
[17:43:52.311]     ...future.result$finished <- base::Sys.time()
[17:43:52.311]     ...future.result
[17:43:52.311] }
[17:43:52.313] assign_globals() ...
[17:43:52.313] List of 5
[17:43:52.313]  $ ...future.FUN            :function (x, ...)  
[17:43:52.313]  $ future.call.arguments    :List of 1
[17:43:52.313]   ..$ singular.ok: logi FALSE
[17:43:52.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.313]  $ ...future.elements_ii    :List of 3
[17:43:52.313]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.313]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.313]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.313]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.313]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.313]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.313]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.313]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.313]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.313]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.313]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.313]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.313]  $ ...future.seeds_ii       : NULL
[17:43:52.313]  $ ...future.globals.maxSize: NULL
[17:43:52.313]  - attr(*, "where")=List of 5
[17:43:52.313]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.313]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.313]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.313]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.313]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.313]  - attr(*, "resolved")= logi FALSE
[17:43:52.313]  - attr(*, "total_size")= num 5384
[17:43:52.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.313]  - attr(*, "already-done")= logi TRUE
[17:43:52.351] - reassign environment for ‘...future.FUN’
[17:43:52.351] - copied ‘...future.FUN’ to environment
[17:43:52.351] - copied ‘future.call.arguments’ to environment
[17:43:52.352] - copied ‘...future.elements_ii’ to environment
[17:43:52.352] - copied ‘...future.seeds_ii’ to environment
[17:43:52.352] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.352] assign_globals() ... done
[17:43:52.352] plan(): Setting new future strategy stack:
[17:43:52.352] List of future strategies:
[17:43:52.352] 1. sequential:
[17:43:52.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.352]    - tweaked: FALSE
[17:43:52.352]    - call: NULL
[17:43:52.353] plan(): nbrOfWorkers() = 1
[17:43:52.355] plan(): Setting new future strategy stack:
[17:43:52.356] List of future strategies:
[17:43:52.356] 1. multicore:
[17:43:52.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.356]    - tweaked: FALSE
[17:43:52.356]    - call: plan(strategy)
[17:43:52.359] plan(): nbrOfWorkers() = 1
[17:43:52.359] SequentialFuture started (and completed)
[17:43:52.360] - Launch lazy future ... done
[17:43:52.360] run() for ‘SequentialFuture’ ... done
[17:43:52.360] Created future:
[17:43:52.360] SequentialFuture:
[17:43:52.360] Label: ‘future_by-1’
[17:43:52.360] Expression:
[17:43:52.360] {
[17:43:52.360]     do.call(function(...) {
[17:43:52.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.360]             on.exit(options(oopts), add = TRUE)
[17:43:52.360]         }
[17:43:52.360]         {
[17:43:52.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.360]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.360]             })
[17:43:52.360]         }
[17:43:52.360]     }, args = future.call.arguments)
[17:43:52.360] }
[17:43:52.360] Lazy evaluation: FALSE
[17:43:52.360] Asynchronous evaluation: FALSE
[17:43:52.360] Local evaluation: TRUE
[17:43:52.360] Environment: R_GlobalEnv
[17:43:52.360] Capture standard output: TRUE
[17:43:52.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.360] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.360] Packages: 1 packages (‘stats’)
[17:43:52.360] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.360] Resolved: TRUE
[17:43:52.360] Value: 26.06 KiB of class ‘list’
[17:43:52.360] Early signaling: FALSE
[17:43:52.360] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.360] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.361] Chunk #1 of 1 ... DONE
[17:43:52.361] Launching 1 futures (chunks) ... DONE
[17:43:52.361] Resolving 1 futures (chunks) ...
[17:43:52.362] resolve() on list ...
[17:43:52.362]  recursive: 0
[17:43:52.362]  length: 1
[17:43:52.362] 
[17:43:52.362] resolved() for ‘SequentialFuture’ ...
[17:43:52.362] - state: ‘finished’
[17:43:52.362] - run: TRUE
[17:43:52.362] - result: ‘FutureResult’
[17:43:52.362] resolved() for ‘SequentialFuture’ ... done
[17:43:52.362] Future #1
[17:43:52.363] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.363] - nx: 1
[17:43:52.363] - relay: TRUE
[17:43:52.363] - stdout: TRUE
[17:43:52.363] - signal: TRUE
[17:43:52.363] - resignal: FALSE
[17:43:52.363] - force: TRUE
[17:43:52.363] - relayed: [n=1] FALSE
[17:43:52.363] - queued futures: [n=1] FALSE
[17:43:52.363]  - until=1
[17:43:52.363]  - relaying element #1
[17:43:52.364] - relayed: [n=1] TRUE
[17:43:52.364] - queued futures: [n=1] TRUE
[17:43:52.364] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.364]  length: 0 (resolved future 1)
[17:43:52.364] Relaying remaining futures
[17:43:52.364] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.364] - nx: 1
[17:43:52.364] - relay: TRUE
[17:43:52.364] - stdout: TRUE
[17:43:52.364] - signal: TRUE
[17:43:52.365] - resignal: FALSE
[17:43:52.365] - force: TRUE
[17:43:52.365] - relayed: [n=1] TRUE
[17:43:52.365] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.365] - relayed: [n=1] TRUE
[17:43:52.365] - queued futures: [n=1] TRUE
[17:43:52.365] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.365] resolve() on list ... DONE
[17:43:52.365]  - Number of value chunks collected: 1
[17:43:52.365] Resolving 1 futures (chunks) ... DONE
[17:43:52.366] Reducing values from 1 chunks ...
[17:43:52.366]  - Number of values collected after concatenation: 3
[17:43:52.366]  - Number of values expected: 3
[17:43:52.366] Reducing values from 1 chunks ... DONE
[17:43:52.366] future_lapply() ... DONE
[17:43:52.366] future_by_internal() ... DONE
[17:43:52.371] future_by_internal() ...
[17:43:52.372] future_lapply() ...
[17:43:52.376] Number of chunks: 1
[17:43:52.376] getGlobalsAndPackagesXApply() ...
[17:43:52.376]  - future.globals: TRUE
[17:43:52.376] getGlobalsAndPackages() ...
[17:43:52.376] Searching for globals...
[17:43:52.378] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.378] Searching for globals ... DONE
[17:43:52.378] Resolving globals: FALSE
[17:43:52.378] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:43:52.379] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:43:52.379] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.379] - packages: [1] ‘stats’
[17:43:52.379] getGlobalsAndPackages() ... DONE
[17:43:52.379]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.379]  - needed namespaces: [n=1] ‘stats’
[17:43:52.379] Finding globals ... DONE
[17:43:52.380]  - use_args: TRUE
[17:43:52.380]  - Getting '...' globals ...
[17:43:52.380] resolve() on list ...
[17:43:52.380]  recursive: 0
[17:43:52.380]  length: 1
[17:43:52.380]  elements: ‘...’
[17:43:52.380]  length: 0 (resolved future 1)
[17:43:52.380] resolve() on list ... DONE
[17:43:52.381]    - '...' content: [n=0] 
[17:43:52.381] List of 1
[17:43:52.381]  $ ...: list()
[17:43:52.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.381]  - attr(*, "where")=List of 1
[17:43:52.381]   ..$ ...:<environment: 0x55d6b971f650> 
[17:43:52.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.381]  - attr(*, "resolved")= logi TRUE
[17:43:52.381]  - attr(*, "total_size")= num NA
[17:43:52.383]  - Getting '...' globals ... DONE
[17:43:52.383] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:43:52.383] List of 4
[17:43:52.383]  $ ...future.FUN:function (x)  
[17:43:52.383]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.383]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.383]  $ ...          : list()
[17:43:52.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.383]  - attr(*, "where")=List of 4
[17:43:52.383]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.383]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:43:52.383]   ..$ wool         :<environment: R_EmptyEnv> 
[17:43:52.383]   ..$ ...          :<environment: 0x55d6b971f650> 
[17:43:52.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.383]  - attr(*, "resolved")= logi FALSE
[17:43:52.383]  - attr(*, "total_size")= num 2320
[17:43:52.387] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.387] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.387] Number of futures (= number of chunks): 1
[17:43:52.387] Launching 1 futures (chunks) ...
[17:43:52.387] Chunk #1 of 1 ...
[17:43:52.388]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.388] getGlobalsAndPackages() ...
[17:43:52.388] Searching for globals...
[17:43:52.388] 
[17:43:52.388] Searching for globals ... DONE
[17:43:52.388] - globals: [0] <none>
[17:43:52.388] getGlobalsAndPackages() ... DONE
[17:43:52.389]    + additional globals found: [n=0] 
[17:43:52.389]    + additional namespaces needed: [n=0] 
[17:43:52.389]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.389]  - seeds: <none>
[17:43:52.389]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.389] getGlobalsAndPackages() ...
[17:43:52.389] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.389] Resolving globals: FALSE
[17:43:52.389] Tweak future expression to call with '...' arguments ...
[17:43:52.390] {
[17:43:52.390]     do.call(function(...) {
[17:43:52.390]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.390]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.390]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.390]             on.exit(options(oopts), add = TRUE)
[17:43:52.390]         }
[17:43:52.390]         {
[17:43:52.390]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.390]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.390]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.390]             })
[17:43:52.390]         }
[17:43:52.390]     }, args = future.call.arguments)
[17:43:52.390] }
[17:43:52.390] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.390] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.390] 
[17:43:52.390] getGlobalsAndPackages() ... DONE
[17:43:52.392] run() for ‘Future’ ...
[17:43:52.392] - state: ‘created’
[17:43:52.392] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.395] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.396]   - Field: ‘label’
[17:43:52.396]   - Field: ‘local’
[17:43:52.396]   - Field: ‘owner’
[17:43:52.396]   - Field: ‘envir’
[17:43:52.396]   - Field: ‘packages’
[17:43:52.396]   - Field: ‘gc’
[17:43:52.396]   - Field: ‘conditions’
[17:43:52.396]   - Field: ‘expr’
[17:43:52.396]   - Field: ‘uuid’
[17:43:52.397]   - Field: ‘seed’
[17:43:52.397]   - Field: ‘version’
[17:43:52.397]   - Field: ‘result’
[17:43:52.397]   - Field: ‘asynchronous’
[17:43:52.397]   - Field: ‘calls’
[17:43:52.397]   - Field: ‘globals’
[17:43:52.397]   - Field: ‘stdout’
[17:43:52.397]   - Field: ‘earlySignal’
[17:43:52.397]   - Field: ‘lazy’
[17:43:52.397]   - Field: ‘state’
[17:43:52.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.398] - Launch lazy future ...
[17:43:52.398] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.398] Packages needed by future strategies (n = 0): <none>
[17:43:52.398] {
[17:43:52.398]     {
[17:43:52.398]         {
[17:43:52.398]             ...future.startTime <- base::Sys.time()
[17:43:52.398]             {
[17:43:52.398]                 {
[17:43:52.398]                   {
[17:43:52.398]                     {
[17:43:52.398]                       base::local({
[17:43:52.398]                         has_future <- base::requireNamespace("future", 
[17:43:52.398]                           quietly = TRUE)
[17:43:52.398]                         if (has_future) {
[17:43:52.398]                           ns <- base::getNamespace("future")
[17:43:52.398]                           version <- ns[[".package"]][["version"]]
[17:43:52.398]                           if (is.null(version)) 
[17:43:52.398]                             version <- utils::packageVersion("future")
[17:43:52.398]                         }
[17:43:52.398]                         else {
[17:43:52.398]                           version <- NULL
[17:43:52.398]                         }
[17:43:52.398]                         if (!has_future || version < "1.8.0") {
[17:43:52.398]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.398]                             "", base::R.version$version.string), 
[17:43:52.398]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.398]                               "release", "version")], collapse = " "), 
[17:43:52.398]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.398]                             info)
[17:43:52.398]                           info <- base::paste(info, collapse = "; ")
[17:43:52.398]                           if (!has_future) {
[17:43:52.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.398]                               info)
[17:43:52.398]                           }
[17:43:52.398]                           else {
[17:43:52.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.398]                               info, version)
[17:43:52.398]                           }
[17:43:52.398]                           base::stop(msg)
[17:43:52.398]                         }
[17:43:52.398]                       })
[17:43:52.398]                     }
[17:43:52.398]                     base::local({
[17:43:52.398]                       for (pkg in "stats") {
[17:43:52.398]                         base::loadNamespace(pkg)
[17:43:52.398]                         base::library(pkg, character.only = TRUE)
[17:43:52.398]                       }
[17:43:52.398]                     })
[17:43:52.398]                   }
[17:43:52.398]                   ...future.strategy.old <- future::plan("list")
[17:43:52.398]                   options(future.plan = NULL)
[17:43:52.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.398]                 }
[17:43:52.398]                 ...future.workdir <- getwd()
[17:43:52.398]             }
[17:43:52.398]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.398]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.398]         }
[17:43:52.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.398]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.398]             base::names(...future.oldOptions))
[17:43:52.398]     }
[17:43:52.398]     if (FALSE) {
[17:43:52.398]     }
[17:43:52.398]     else {
[17:43:52.398]         if (TRUE) {
[17:43:52.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.398]                 open = "w")
[17:43:52.398]         }
[17:43:52.398]         else {
[17:43:52.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.398]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.398]         }
[17:43:52.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.398]             base::sink(type = "output", split = FALSE)
[17:43:52.398]             base::close(...future.stdout)
[17:43:52.398]         }, add = TRUE)
[17:43:52.398]     }
[17:43:52.398]     ...future.frame <- base::sys.nframe()
[17:43:52.398]     ...future.conditions <- base::list()
[17:43:52.398]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.398]     if (FALSE) {
[17:43:52.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.398]     }
[17:43:52.398]     ...future.result <- base::tryCatch({
[17:43:52.398]         base::withCallingHandlers({
[17:43:52.398]             ...future.value <- base::withVisible(base::local({
[17:43:52.398]                 do.call(function(...) {
[17:43:52.398]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.398]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.398]                     ...future.globals.maxSize)) {
[17:43:52.398]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.398]                     on.exit(options(oopts), add = TRUE)
[17:43:52.398]                   }
[17:43:52.398]                   {
[17:43:52.398]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.398]                       FUN = function(jj) {
[17:43:52.398]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.398]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.398]                       })
[17:43:52.398]                   }
[17:43:52.398]                 }, args = future.call.arguments)
[17:43:52.398]             }))
[17:43:52.398]             future::FutureResult(value = ...future.value$value, 
[17:43:52.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.398]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.398]                     ...future.globalenv.names))
[17:43:52.398]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.398]         }, condition = base::local({
[17:43:52.398]             c <- base::c
[17:43:52.398]             inherits <- base::inherits
[17:43:52.398]             invokeRestart <- base::invokeRestart
[17:43:52.398]             length <- base::length
[17:43:52.398]             list <- base::list
[17:43:52.398]             seq.int <- base::seq.int
[17:43:52.398]             signalCondition <- base::signalCondition
[17:43:52.398]             sys.calls <- base::sys.calls
[17:43:52.398]             `[[` <- base::`[[`
[17:43:52.398]             `+` <- base::`+`
[17:43:52.398]             `<<-` <- base::`<<-`
[17:43:52.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.398]                   3L)]
[17:43:52.398]             }
[17:43:52.398]             function(cond) {
[17:43:52.398]                 is_error <- inherits(cond, "error")
[17:43:52.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.398]                   NULL)
[17:43:52.398]                 if (is_error) {
[17:43:52.398]                   sessionInformation <- function() {
[17:43:52.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.398]                       search = base::search(), system = base::Sys.info())
[17:43:52.398]                   }
[17:43:52.398]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.398]                     cond$call), session = sessionInformation(), 
[17:43:52.398]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.398]                   signalCondition(cond)
[17:43:52.398]                 }
[17:43:52.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.398]                 "immediateCondition"))) {
[17:43:52.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.398]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.398]                   if (TRUE && !signal) {
[17:43:52.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.398]                     {
[17:43:52.398]                       inherits <- base::inherits
[17:43:52.398]                       invokeRestart <- base::invokeRestart
[17:43:52.398]                       is.null <- base::is.null
[17:43:52.398]                       muffled <- FALSE
[17:43:52.398]                       if (inherits(cond, "message")) {
[17:43:52.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.398]                         if (muffled) 
[17:43:52.398]                           invokeRestart("muffleMessage")
[17:43:52.398]                       }
[17:43:52.398]                       else if (inherits(cond, "warning")) {
[17:43:52.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.398]                         if (muffled) 
[17:43:52.398]                           invokeRestart("muffleWarning")
[17:43:52.398]                       }
[17:43:52.398]                       else if (inherits(cond, "condition")) {
[17:43:52.398]                         if (!is.null(pattern)) {
[17:43:52.398]                           computeRestarts <- base::computeRestarts
[17:43:52.398]                           grepl <- base::grepl
[17:43:52.398]                           restarts <- computeRestarts(cond)
[17:43:52.398]                           for (restart in restarts) {
[17:43:52.398]                             name <- restart$name
[17:43:52.398]                             if (is.null(name)) 
[17:43:52.398]                               next
[17:43:52.398]                             if (!grepl(pattern, name)) 
[17:43:52.398]                               next
[17:43:52.398]                             invokeRestart(restart)
[17:43:52.398]                             muffled <- TRUE
[17:43:52.398]                             break
[17:43:52.398]                           }
[17:43:52.398]                         }
[17:43:52.398]                       }
[17:43:52.398]                       invisible(muffled)
[17:43:52.398]                     }
[17:43:52.398]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.398]                   }
[17:43:52.398]                 }
[17:43:52.398]                 else {
[17:43:52.398]                   if (TRUE) {
[17:43:52.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.398]                     {
[17:43:52.398]                       inherits <- base::inherits
[17:43:52.398]                       invokeRestart <- base::invokeRestart
[17:43:52.398]                       is.null <- base::is.null
[17:43:52.398]                       muffled <- FALSE
[17:43:52.398]                       if (inherits(cond, "message")) {
[17:43:52.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.398]                         if (muffled) 
[17:43:52.398]                           invokeRestart("muffleMessage")
[17:43:52.398]                       }
[17:43:52.398]                       else if (inherits(cond, "warning")) {
[17:43:52.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.398]                         if (muffled) 
[17:43:52.398]                           invokeRestart("muffleWarning")
[17:43:52.398]                       }
[17:43:52.398]                       else if (inherits(cond, "condition")) {
[17:43:52.398]                         if (!is.null(pattern)) {
[17:43:52.398]                           computeRestarts <- base::computeRestarts
[17:43:52.398]                           grepl <- base::grepl
[17:43:52.398]                           restarts <- computeRestarts(cond)
[17:43:52.398]                           for (restart in restarts) {
[17:43:52.398]                             name <- restart$name
[17:43:52.398]                             if (is.null(name)) 
[17:43:52.398]                               next
[17:43:52.398]                             if (!grepl(pattern, name)) 
[17:43:52.398]                               next
[17:43:52.398]                             invokeRestart(restart)
[17:43:52.398]                             muffled <- TRUE
[17:43:52.398]                             break
[17:43:52.398]                           }
[17:43:52.398]                         }
[17:43:52.398]                       }
[17:43:52.398]                       invisible(muffled)
[17:43:52.398]                     }
[17:43:52.398]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.398]                   }
[17:43:52.398]                 }
[17:43:52.398]             }
[17:43:52.398]         }))
[17:43:52.398]     }, error = function(ex) {
[17:43:52.398]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.398]                 ...future.rng), started = ...future.startTime, 
[17:43:52.398]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.398]             version = "1.8"), class = "FutureResult")
[17:43:52.398]     }, finally = {
[17:43:52.398]         if (!identical(...future.workdir, getwd())) 
[17:43:52.398]             setwd(...future.workdir)
[17:43:52.398]         {
[17:43:52.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.398]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.398]             }
[17:43:52.398]             base::options(...future.oldOptions)
[17:43:52.398]             if (.Platform$OS.type == "windows") {
[17:43:52.398]                 old_names <- names(...future.oldEnvVars)
[17:43:52.398]                 envs <- base::Sys.getenv()
[17:43:52.398]                 names <- names(envs)
[17:43:52.398]                 common <- intersect(names, old_names)
[17:43:52.398]                 added <- setdiff(names, old_names)
[17:43:52.398]                 removed <- setdiff(old_names, names)
[17:43:52.398]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.398]                   envs[common]]
[17:43:52.398]                 NAMES <- toupper(changed)
[17:43:52.398]                 args <- list()
[17:43:52.398]                 for (kk in seq_along(NAMES)) {
[17:43:52.398]                   name <- changed[[kk]]
[17:43:52.398]                   NAME <- NAMES[[kk]]
[17:43:52.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.398]                     next
[17:43:52.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.398]                 }
[17:43:52.398]                 NAMES <- toupper(added)
[17:43:52.398]                 for (kk in seq_along(NAMES)) {
[17:43:52.398]                   name <- added[[kk]]
[17:43:52.398]                   NAME <- NAMES[[kk]]
[17:43:52.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.398]                     next
[17:43:52.398]                   args[[name]] <- ""
[17:43:52.398]                 }
[17:43:52.398]                 NAMES <- toupper(removed)
[17:43:52.398]                 for (kk in seq_along(NAMES)) {
[17:43:52.398]                   name <- removed[[kk]]
[17:43:52.398]                   NAME <- NAMES[[kk]]
[17:43:52.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.398]                     next
[17:43:52.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.398]                 }
[17:43:52.398]                 if (length(args) > 0) 
[17:43:52.398]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.398]             }
[17:43:52.398]             else {
[17:43:52.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.398]             }
[17:43:52.398]             {
[17:43:52.398]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.398]                   0L) {
[17:43:52.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.398]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.398]                   base::options(opts)
[17:43:52.398]                 }
[17:43:52.398]                 {
[17:43:52.398]                   {
[17:43:52.398]                     NULL
[17:43:52.398]                     RNGkind("Mersenne-Twister")
[17:43:52.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.398]                       inherits = FALSE)
[17:43:52.398]                   }
[17:43:52.398]                   options(future.plan = NULL)
[17:43:52.398]                   if (is.na(NA_character_)) 
[17:43:52.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.398]                     .init = FALSE)
[17:43:52.398]                 }
[17:43:52.398]             }
[17:43:52.398]         }
[17:43:52.398]     })
[17:43:52.398]     if (TRUE) {
[17:43:52.398]         base::sink(type = "output", split = FALSE)
[17:43:52.398]         if (TRUE) {
[17:43:52.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.398]         }
[17:43:52.398]         else {
[17:43:52.398]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.398]         }
[17:43:52.398]         base::close(...future.stdout)
[17:43:52.398]         ...future.stdout <- NULL
[17:43:52.398]     }
[17:43:52.398]     ...future.result$conditions <- ...future.conditions
[17:43:52.398]     ...future.result$finished <- base::Sys.time()
[17:43:52.398]     ...future.result
[17:43:52.398] }
[17:43:52.400] assign_globals() ...
[17:43:52.400] List of 7
[17:43:52.400]  $ ...future.FUN            :function (x)  
[17:43:52.400]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.400]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.400]  $ future.call.arguments    : list()
[17:43:52.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.400]  $ ...future.elements_ii    :List of 3
[17:43:52.400]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.400]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.400]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.400]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.400]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.400]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.400]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.400]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.400]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.400]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.400]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.400]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.400]  $ ...future.seeds_ii       : NULL
[17:43:52.400]  $ ...future.globals.maxSize: NULL
[17:43:52.400]  - attr(*, "where")=List of 7
[17:43:52.400]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.400]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:43:52.400]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:43:52.400]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.400]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.400]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.400]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.400]  - attr(*, "resolved")= logi FALSE
[17:43:52.400]  - attr(*, "total_size")= num 2320
[17:43:52.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.400]  - attr(*, "already-done")= logi TRUE
[17:43:52.409] - reassign environment for ‘...future.FUN’
[17:43:52.409] - copied ‘...future.FUN’ to environment
[17:43:52.409] - copied ‘breaks’ to environment
[17:43:52.410] - copied ‘wool’ to environment
[17:43:52.410] - copied ‘future.call.arguments’ to environment
[17:43:52.410] - copied ‘...future.elements_ii’ to environment
[17:43:52.410] - copied ‘...future.seeds_ii’ to environment
[17:43:52.410] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.410] assign_globals() ... done
[17:43:52.410] plan(): Setting new future strategy stack:
[17:43:52.410] List of future strategies:
[17:43:52.410] 1. sequential:
[17:43:52.410]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.410]    - tweaked: FALSE
[17:43:52.410]    - call: NULL
[17:43:52.411] plan(): nbrOfWorkers() = 1
[17:43:52.414] plan(): Setting new future strategy stack:
[17:43:52.414] List of future strategies:
[17:43:52.414] 1. multicore:
[17:43:52.414]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.414]    - tweaked: FALSE
[17:43:52.414]    - call: plan(strategy)
[17:43:52.417] plan(): nbrOfWorkers() = 1
[17:43:52.417] SequentialFuture started (and completed)
[17:43:52.417] - Launch lazy future ... done
[17:43:52.417] run() for ‘SequentialFuture’ ... done
[17:43:52.418] Created future:
[17:43:52.418] SequentialFuture:
[17:43:52.418] Label: ‘future_by-1’
[17:43:52.418] Expression:
[17:43:52.418] {
[17:43:52.418]     do.call(function(...) {
[17:43:52.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.418]             on.exit(options(oopts), add = TRUE)
[17:43:52.418]         }
[17:43:52.418]         {
[17:43:52.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.418]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.418]             })
[17:43:52.418]         }
[17:43:52.418]     }, args = future.call.arguments)
[17:43:52.418] }
[17:43:52.418] Lazy evaluation: FALSE
[17:43:52.418] Asynchronous evaluation: FALSE
[17:43:52.418] Local evaluation: TRUE
[17:43:52.418] Environment: 0x55d6b98f6620
[17:43:52.418] Capture standard output: TRUE
[17:43:52.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.418] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:43:52.418] Packages: 1 packages (‘stats’)
[17:43:52.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.418] Resolved: TRUE
[17:43:52.418] Value: 25.57 KiB of class ‘list’
[17:43:52.418] Early signaling: FALSE
[17:43:52.418] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.418] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.420] Chunk #1 of 1 ... DONE
[17:43:52.420] Launching 1 futures (chunks) ... DONE
[17:43:52.420] Resolving 1 futures (chunks) ...
[17:43:52.421] resolve() on list ...
[17:43:52.421]  recursive: 0
[17:43:52.421]  length: 1
[17:43:52.421] 
[17:43:52.421] resolved() for ‘SequentialFuture’ ...
[17:43:52.421] - state: ‘finished’
[17:43:52.421] - run: TRUE
[17:43:52.421] - result: ‘FutureResult’
[17:43:52.421] resolved() for ‘SequentialFuture’ ... done
[17:43:52.421] Future #1
[17:43:52.422] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.422] - nx: 1
[17:43:52.422] - relay: TRUE
[17:43:52.422] - stdout: TRUE
[17:43:52.422] - signal: TRUE
[17:43:52.422] - resignal: FALSE
[17:43:52.422] - force: TRUE
[17:43:52.422] - relayed: [n=1] FALSE
[17:43:52.422] - queued futures: [n=1] FALSE
[17:43:52.422]  - until=1
[17:43:52.422]  - relaying element #1
[17:43:52.423] - relayed: [n=1] TRUE
[17:43:52.423] - queued futures: [n=1] TRUE
[17:43:52.423] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.423]  length: 0 (resolved future 1)
[17:43:52.423] Relaying remaining futures
[17:43:52.423] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.423] - nx: 1
[17:43:52.423] - relay: TRUE
[17:43:52.423] - stdout: TRUE
[17:43:52.423] - signal: TRUE
[17:43:52.423] - resignal: FALSE
[17:43:52.424] - force: TRUE
[17:43:52.424] - relayed: [n=1] TRUE
[17:43:52.424] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.424] - relayed: [n=1] TRUE
[17:43:52.424] - queued futures: [n=1] TRUE
[17:43:52.424] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.424] resolve() on list ... DONE
[17:43:52.424]  - Number of value chunks collected: 1
[17:43:52.424] Resolving 1 futures (chunks) ... DONE
[17:43:52.424] Reducing values from 1 chunks ...
[17:43:52.424]  - Number of values collected after concatenation: 3
[17:43:52.425]  - Number of values expected: 3
[17:43:52.425] Reducing values from 1 chunks ... DONE
[17:43:52.425] future_lapply() ... DONE
[17:43:52.425] future_by_internal() ... DONE
[17:43:52.425] future_by_internal() ...
[17:43:52.426] future_lapply() ...
[17:43:52.429] Number of chunks: 1
[17:43:52.429] getGlobalsAndPackagesXApply() ...
[17:43:52.429]  - future.globals: TRUE
[17:43:52.429] getGlobalsAndPackages() ...
[17:43:52.429] Searching for globals...
[17:43:52.430] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.430] Searching for globals ... DONE
[17:43:52.430] Resolving globals: FALSE
[17:43:52.431] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.431] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.431] - globals: [1] ‘FUN’
[17:43:52.431] 
[17:43:52.431] getGlobalsAndPackages() ... DONE
[17:43:52.432]  - globals found/used: [n=1] ‘FUN’
[17:43:52.432]  - needed namespaces: [n=0] 
[17:43:52.432] Finding globals ... DONE
[17:43:52.432]  - use_args: TRUE
[17:43:52.432]  - Getting '...' globals ...
[17:43:52.432] resolve() on list ...
[17:43:52.432]  recursive: 0
[17:43:52.432]  length: 1
[17:43:52.432]  elements: ‘...’
[17:43:52.433]  length: 0 (resolved future 1)
[17:43:52.433] resolve() on list ... DONE
[17:43:52.433]    - '...' content: [n=0] 
[17:43:52.433] List of 1
[17:43:52.433]  $ ...: list()
[17:43:52.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.433]  - attr(*, "where")=List of 1
[17:43:52.433]   ..$ ...:<environment: 0x55d6b87af4e0> 
[17:43:52.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.433]  - attr(*, "resolved")= logi TRUE
[17:43:52.433]  - attr(*, "total_size")= num NA
[17:43:52.435]  - Getting '...' globals ... DONE
[17:43:52.435] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.435] List of 2
[17:43:52.435]  $ ...future.FUN:function (object, ...)  
[17:43:52.435]  $ ...          : list()
[17:43:52.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.435]  - attr(*, "where")=List of 2
[17:43:52.435]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.435]   ..$ ...          :<environment: 0x55d6b87af4e0> 
[17:43:52.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.435]  - attr(*, "resolved")= logi FALSE
[17:43:52.435]  - attr(*, "total_size")= num 1240
[17:43:52.438] Packages to be attached in all futures: [n=0] 
[17:43:52.438] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.438] Number of futures (= number of chunks): 1
[17:43:52.438] Launching 1 futures (chunks) ...
[17:43:52.438] Chunk #1 of 1 ...
[17:43:52.439]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.439] getGlobalsAndPackages() ...
[17:43:52.439] Searching for globals...
[17:43:52.439] 
[17:43:52.439] Searching for globals ... DONE
[17:43:52.439] - globals: [0] <none>
[17:43:52.439] getGlobalsAndPackages() ... DONE
[17:43:52.440]    + additional globals found: [n=0] 
[17:43:52.440]    + additional namespaces needed: [n=0] 
[17:43:52.440]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.440]  - seeds: <none>
[17:43:52.440]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.440] getGlobalsAndPackages() ...
[17:43:52.440] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.440] Resolving globals: FALSE
[17:43:52.440] Tweak future expression to call with '...' arguments ...
[17:43:52.440] {
[17:43:52.440]     do.call(function(...) {
[17:43:52.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.440]             on.exit(options(oopts), add = TRUE)
[17:43:52.440]         }
[17:43:52.440]         {
[17:43:52.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.440]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.440]             })
[17:43:52.440]         }
[17:43:52.440]     }, args = future.call.arguments)
[17:43:52.440] }
[17:43:52.441] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.441] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.441] 
[17:43:52.441] getGlobalsAndPackages() ... DONE
[17:43:52.441] run() for ‘Future’ ...
[17:43:52.442] - state: ‘created’
[17:43:52.442] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.446]   - Field: ‘label’
[17:43:52.446]   - Field: ‘local’
[17:43:52.447]   - Field: ‘owner’
[17:43:52.447]   - Field: ‘envir’
[17:43:52.447]   - Field: ‘packages’
[17:43:52.447]   - Field: ‘gc’
[17:43:52.447]   - Field: ‘conditions’
[17:43:52.447]   - Field: ‘expr’
[17:43:52.447]   - Field: ‘uuid’
[17:43:52.447]   - Field: ‘seed’
[17:43:52.447]   - Field: ‘version’
[17:43:52.448]   - Field: ‘result’
[17:43:52.448]   - Field: ‘asynchronous’
[17:43:52.448]   - Field: ‘calls’
[17:43:52.448]   - Field: ‘globals’
[17:43:52.448]   - Field: ‘stdout’
[17:43:52.448]   - Field: ‘earlySignal’
[17:43:52.448]   - Field: ‘lazy’
[17:43:52.448]   - Field: ‘state’
[17:43:52.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.448] - Launch lazy future ...
[17:43:52.449] Packages needed by the future expression (n = 0): <none>
[17:43:52.449] Packages needed by future strategies (n = 0): <none>
[17:43:52.449] {
[17:43:52.449]     {
[17:43:52.449]         {
[17:43:52.449]             ...future.startTime <- base::Sys.time()
[17:43:52.449]             {
[17:43:52.449]                 {
[17:43:52.449]                   {
[17:43:52.449]                     base::local({
[17:43:52.449]                       has_future <- base::requireNamespace("future", 
[17:43:52.449]                         quietly = TRUE)
[17:43:52.449]                       if (has_future) {
[17:43:52.449]                         ns <- base::getNamespace("future")
[17:43:52.449]                         version <- ns[[".package"]][["version"]]
[17:43:52.449]                         if (is.null(version)) 
[17:43:52.449]                           version <- utils::packageVersion("future")
[17:43:52.449]                       }
[17:43:52.449]                       else {
[17:43:52.449]                         version <- NULL
[17:43:52.449]                       }
[17:43:52.449]                       if (!has_future || version < "1.8.0") {
[17:43:52.449]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.449]                           "", base::R.version$version.string), 
[17:43:52.449]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.449]                             "release", "version")], collapse = " "), 
[17:43:52.449]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.449]                           info)
[17:43:52.449]                         info <- base::paste(info, collapse = "; ")
[17:43:52.449]                         if (!has_future) {
[17:43:52.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.449]                             info)
[17:43:52.449]                         }
[17:43:52.449]                         else {
[17:43:52.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.449]                             info, version)
[17:43:52.449]                         }
[17:43:52.449]                         base::stop(msg)
[17:43:52.449]                       }
[17:43:52.449]                     })
[17:43:52.449]                   }
[17:43:52.449]                   ...future.strategy.old <- future::plan("list")
[17:43:52.449]                   options(future.plan = NULL)
[17:43:52.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.449]                 }
[17:43:52.449]                 ...future.workdir <- getwd()
[17:43:52.449]             }
[17:43:52.449]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.449]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.449]         }
[17:43:52.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.449]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.449]             base::names(...future.oldOptions))
[17:43:52.449]     }
[17:43:52.449]     if (FALSE) {
[17:43:52.449]     }
[17:43:52.449]     else {
[17:43:52.449]         if (TRUE) {
[17:43:52.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.449]                 open = "w")
[17:43:52.449]         }
[17:43:52.449]         else {
[17:43:52.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.449]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.449]         }
[17:43:52.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.449]             base::sink(type = "output", split = FALSE)
[17:43:52.449]             base::close(...future.stdout)
[17:43:52.449]         }, add = TRUE)
[17:43:52.449]     }
[17:43:52.449]     ...future.frame <- base::sys.nframe()
[17:43:52.449]     ...future.conditions <- base::list()
[17:43:52.449]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.449]     if (FALSE) {
[17:43:52.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.449]     }
[17:43:52.449]     ...future.result <- base::tryCatch({
[17:43:52.449]         base::withCallingHandlers({
[17:43:52.449]             ...future.value <- base::withVisible(base::local({
[17:43:52.449]                 do.call(function(...) {
[17:43:52.449]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.449]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.449]                     ...future.globals.maxSize)) {
[17:43:52.449]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.449]                     on.exit(options(oopts), add = TRUE)
[17:43:52.449]                   }
[17:43:52.449]                   {
[17:43:52.449]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.449]                       FUN = function(jj) {
[17:43:52.449]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.449]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.449]                       })
[17:43:52.449]                   }
[17:43:52.449]                 }, args = future.call.arguments)
[17:43:52.449]             }))
[17:43:52.449]             future::FutureResult(value = ...future.value$value, 
[17:43:52.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.449]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.449]                     ...future.globalenv.names))
[17:43:52.449]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.449]         }, condition = base::local({
[17:43:52.449]             c <- base::c
[17:43:52.449]             inherits <- base::inherits
[17:43:52.449]             invokeRestart <- base::invokeRestart
[17:43:52.449]             length <- base::length
[17:43:52.449]             list <- base::list
[17:43:52.449]             seq.int <- base::seq.int
[17:43:52.449]             signalCondition <- base::signalCondition
[17:43:52.449]             sys.calls <- base::sys.calls
[17:43:52.449]             `[[` <- base::`[[`
[17:43:52.449]             `+` <- base::`+`
[17:43:52.449]             `<<-` <- base::`<<-`
[17:43:52.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.449]                   3L)]
[17:43:52.449]             }
[17:43:52.449]             function(cond) {
[17:43:52.449]                 is_error <- inherits(cond, "error")
[17:43:52.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.449]                   NULL)
[17:43:52.449]                 if (is_error) {
[17:43:52.449]                   sessionInformation <- function() {
[17:43:52.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.449]                       search = base::search(), system = base::Sys.info())
[17:43:52.449]                   }
[17:43:52.449]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.449]                     cond$call), session = sessionInformation(), 
[17:43:52.449]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.449]                   signalCondition(cond)
[17:43:52.449]                 }
[17:43:52.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.449]                 "immediateCondition"))) {
[17:43:52.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.449]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.449]                   if (TRUE && !signal) {
[17:43:52.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.449]                     {
[17:43:52.449]                       inherits <- base::inherits
[17:43:52.449]                       invokeRestart <- base::invokeRestart
[17:43:52.449]                       is.null <- base::is.null
[17:43:52.449]                       muffled <- FALSE
[17:43:52.449]                       if (inherits(cond, "message")) {
[17:43:52.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.449]                         if (muffled) 
[17:43:52.449]                           invokeRestart("muffleMessage")
[17:43:52.449]                       }
[17:43:52.449]                       else if (inherits(cond, "warning")) {
[17:43:52.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.449]                         if (muffled) 
[17:43:52.449]                           invokeRestart("muffleWarning")
[17:43:52.449]                       }
[17:43:52.449]                       else if (inherits(cond, "condition")) {
[17:43:52.449]                         if (!is.null(pattern)) {
[17:43:52.449]                           computeRestarts <- base::computeRestarts
[17:43:52.449]                           grepl <- base::grepl
[17:43:52.449]                           restarts <- computeRestarts(cond)
[17:43:52.449]                           for (restart in restarts) {
[17:43:52.449]                             name <- restart$name
[17:43:52.449]                             if (is.null(name)) 
[17:43:52.449]                               next
[17:43:52.449]                             if (!grepl(pattern, name)) 
[17:43:52.449]                               next
[17:43:52.449]                             invokeRestart(restart)
[17:43:52.449]                             muffled <- TRUE
[17:43:52.449]                             break
[17:43:52.449]                           }
[17:43:52.449]                         }
[17:43:52.449]                       }
[17:43:52.449]                       invisible(muffled)
[17:43:52.449]                     }
[17:43:52.449]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.449]                   }
[17:43:52.449]                 }
[17:43:52.449]                 else {
[17:43:52.449]                   if (TRUE) {
[17:43:52.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.449]                     {
[17:43:52.449]                       inherits <- base::inherits
[17:43:52.449]                       invokeRestart <- base::invokeRestart
[17:43:52.449]                       is.null <- base::is.null
[17:43:52.449]                       muffled <- FALSE
[17:43:52.449]                       if (inherits(cond, "message")) {
[17:43:52.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.449]                         if (muffled) 
[17:43:52.449]                           invokeRestart("muffleMessage")
[17:43:52.449]                       }
[17:43:52.449]                       else if (inherits(cond, "warning")) {
[17:43:52.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.449]                         if (muffled) 
[17:43:52.449]                           invokeRestart("muffleWarning")
[17:43:52.449]                       }
[17:43:52.449]                       else if (inherits(cond, "condition")) {
[17:43:52.449]                         if (!is.null(pattern)) {
[17:43:52.449]                           computeRestarts <- base::computeRestarts
[17:43:52.449]                           grepl <- base::grepl
[17:43:52.449]                           restarts <- computeRestarts(cond)
[17:43:52.449]                           for (restart in restarts) {
[17:43:52.449]                             name <- restart$name
[17:43:52.449]                             if (is.null(name)) 
[17:43:52.449]                               next
[17:43:52.449]                             if (!grepl(pattern, name)) 
[17:43:52.449]                               next
[17:43:52.449]                             invokeRestart(restart)
[17:43:52.449]                             muffled <- TRUE
[17:43:52.449]                             break
[17:43:52.449]                           }
[17:43:52.449]                         }
[17:43:52.449]                       }
[17:43:52.449]                       invisible(muffled)
[17:43:52.449]                     }
[17:43:52.449]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.449]                   }
[17:43:52.449]                 }
[17:43:52.449]             }
[17:43:52.449]         }))
[17:43:52.449]     }, error = function(ex) {
[17:43:52.449]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.449]                 ...future.rng), started = ...future.startTime, 
[17:43:52.449]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.449]             version = "1.8"), class = "FutureResult")
[17:43:52.449]     }, finally = {
[17:43:52.449]         if (!identical(...future.workdir, getwd())) 
[17:43:52.449]             setwd(...future.workdir)
[17:43:52.449]         {
[17:43:52.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.449]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.449]             }
[17:43:52.449]             base::options(...future.oldOptions)
[17:43:52.449]             if (.Platform$OS.type == "windows") {
[17:43:52.449]                 old_names <- names(...future.oldEnvVars)
[17:43:52.449]                 envs <- base::Sys.getenv()
[17:43:52.449]                 names <- names(envs)
[17:43:52.449]                 common <- intersect(names, old_names)
[17:43:52.449]                 added <- setdiff(names, old_names)
[17:43:52.449]                 removed <- setdiff(old_names, names)
[17:43:52.449]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.449]                   envs[common]]
[17:43:52.449]                 NAMES <- toupper(changed)
[17:43:52.449]                 args <- list()
[17:43:52.449]                 for (kk in seq_along(NAMES)) {
[17:43:52.449]                   name <- changed[[kk]]
[17:43:52.449]                   NAME <- NAMES[[kk]]
[17:43:52.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.449]                     next
[17:43:52.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.449]                 }
[17:43:52.449]                 NAMES <- toupper(added)
[17:43:52.449]                 for (kk in seq_along(NAMES)) {
[17:43:52.449]                   name <- added[[kk]]
[17:43:52.449]                   NAME <- NAMES[[kk]]
[17:43:52.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.449]                     next
[17:43:52.449]                   args[[name]] <- ""
[17:43:52.449]                 }
[17:43:52.449]                 NAMES <- toupper(removed)
[17:43:52.449]                 for (kk in seq_along(NAMES)) {
[17:43:52.449]                   name <- removed[[kk]]
[17:43:52.449]                   NAME <- NAMES[[kk]]
[17:43:52.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.449]                     next
[17:43:52.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.449]                 }
[17:43:52.449]                 if (length(args) > 0) 
[17:43:52.449]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.449]             }
[17:43:52.449]             else {
[17:43:52.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.449]             }
[17:43:52.449]             {
[17:43:52.449]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.449]                   0L) {
[17:43:52.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.449]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.449]                   base::options(opts)
[17:43:52.449]                 }
[17:43:52.449]                 {
[17:43:52.449]                   {
[17:43:52.449]                     NULL
[17:43:52.449]                     RNGkind("Mersenne-Twister")
[17:43:52.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.449]                       inherits = FALSE)
[17:43:52.449]                   }
[17:43:52.449]                   options(future.plan = NULL)
[17:43:52.449]                   if (is.na(NA_character_)) 
[17:43:52.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.449]                     .init = FALSE)
[17:43:52.449]                 }
[17:43:52.449]             }
[17:43:52.449]         }
[17:43:52.449]     })
[17:43:52.449]     if (TRUE) {
[17:43:52.449]         base::sink(type = "output", split = FALSE)
[17:43:52.449]         if (TRUE) {
[17:43:52.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.449]         }
[17:43:52.449]         else {
[17:43:52.449]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.449]         }
[17:43:52.449]         base::close(...future.stdout)
[17:43:52.449]         ...future.stdout <- NULL
[17:43:52.449]     }
[17:43:52.449]     ...future.result$conditions <- ...future.conditions
[17:43:52.449]     ...future.result$finished <- base::Sys.time()
[17:43:52.449]     ...future.result
[17:43:52.449] }
[17:43:52.451] assign_globals() ...
[17:43:52.451] List of 5
[17:43:52.451]  $ ...future.FUN            :function (object, ...)  
[17:43:52.451]  $ future.call.arguments    : list()
[17:43:52.451]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.451]  $ ...future.elements_ii    :List of 3
[17:43:52.451]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.451]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.451]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.451]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.451]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.451]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.451]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.451]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.451]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.451]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.451]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.451]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.451]  $ ...future.seeds_ii       : NULL
[17:43:52.451]  $ ...future.globals.maxSize: NULL
[17:43:52.451]  - attr(*, "where")=List of 5
[17:43:52.451]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.451]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.451]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.451]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.451]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.451]  - attr(*, "resolved")= logi FALSE
[17:43:52.451]  - attr(*, "total_size")= num 1240
[17:43:52.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.451]  - attr(*, "already-done")= logi TRUE
[17:43:52.459] - copied ‘...future.FUN’ to environment
[17:43:52.459] - copied ‘future.call.arguments’ to environment
[17:43:52.459] - copied ‘...future.elements_ii’ to environment
[17:43:52.459] - copied ‘...future.seeds_ii’ to environment
[17:43:52.459] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.459] assign_globals() ... done
[17:43:52.459] plan(): Setting new future strategy stack:
[17:43:52.459] List of future strategies:
[17:43:52.459] 1. sequential:
[17:43:52.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.459]    - tweaked: FALSE
[17:43:52.459]    - call: NULL
[17:43:52.460] plan(): nbrOfWorkers() = 1
[17:43:52.462] plan(): Setting new future strategy stack:
[17:43:52.462] List of future strategies:
[17:43:52.462] 1. multicore:
[17:43:52.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.462]    - tweaked: FALSE
[17:43:52.462]    - call: plan(strategy)
[17:43:52.465] plan(): nbrOfWorkers() = 1
[17:43:52.466] SequentialFuture started (and completed)
[17:43:52.466] - Launch lazy future ... done
[17:43:52.466] run() for ‘SequentialFuture’ ... done
[17:43:52.466] Created future:
[17:43:52.466] SequentialFuture:
[17:43:52.466] Label: ‘future_by-1’
[17:43:52.466] Expression:
[17:43:52.466] {
[17:43:52.466]     do.call(function(...) {
[17:43:52.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.466]             on.exit(options(oopts), add = TRUE)
[17:43:52.466]         }
[17:43:52.466]         {
[17:43:52.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.466]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.466]             })
[17:43:52.466]         }
[17:43:52.466]     }, args = future.call.arguments)
[17:43:52.466] }
[17:43:52.466] Lazy evaluation: FALSE
[17:43:52.466] Asynchronous evaluation: FALSE
[17:43:52.466] Local evaluation: TRUE
[17:43:52.466] Environment: 0x55d6b8af0858
[17:43:52.466] Capture standard output: TRUE
[17:43:52.466] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.466] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.466] Packages: <none>
[17:43:52.466] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.466] Resolved: TRUE
[17:43:52.466] Value: 5.37 KiB of class ‘list’
[17:43:52.466] Early signaling: FALSE
[17:43:52.466] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.466] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.467] Chunk #1 of 1 ... DONE
[17:43:52.467] Launching 1 futures (chunks) ... DONE
[17:43:52.467] Resolving 1 futures (chunks) ...
[17:43:52.468] resolve() on list ...
[17:43:52.468]  recursive: 0
[17:43:52.468]  length: 1
[17:43:52.468] 
[17:43:52.468] resolved() for ‘SequentialFuture’ ...
[17:43:52.468] - state: ‘finished’
[17:43:52.468] - run: TRUE
[17:43:52.468] - result: ‘FutureResult’
[17:43:52.468] resolved() for ‘SequentialFuture’ ... done
[17:43:52.468] Future #1
[17:43:52.468] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.469] - nx: 1
[17:43:52.469] - relay: TRUE
[17:43:52.469] - stdout: TRUE
[17:43:52.469] - signal: TRUE
[17:43:52.469] - resignal: FALSE
[17:43:52.469] - force: TRUE
[17:43:52.469] - relayed: [n=1] FALSE
[17:43:52.469] - queued futures: [n=1] FALSE
[17:43:52.469]  - until=1
[17:43:52.469]  - relaying element #1
[17:43:52.469] - relayed: [n=1] TRUE
[17:43:52.470] - queued futures: [n=1] TRUE
[17:43:52.470] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.470]  length: 0 (resolved future 1)
[17:43:52.471] Relaying remaining futures
[17:43:52.471] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.471] - nx: 1
[17:43:52.471] - relay: TRUE
[17:43:52.471] - stdout: TRUE
[17:43:52.471] - signal: TRUE
[17:43:52.471] - resignal: FALSE
[17:43:52.472] - force: TRUE
[17:43:52.472] - relayed: [n=1] TRUE
[17:43:52.472] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.472] - relayed: [n=1] TRUE
[17:43:52.472] - queued futures: [n=1] TRUE
[17:43:52.472] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.472] resolve() on list ... DONE
[17:43:52.472]  - Number of value chunks collected: 1
[17:43:52.472] Resolving 1 futures (chunks) ... DONE
[17:43:52.472] Reducing values from 1 chunks ...
[17:43:52.473]  - Number of values collected after concatenation: 3
[17:43:52.473]  - Number of values expected: 3
[17:43:52.473] Reducing values from 1 chunks ... DONE
[17:43:52.473] future_lapply() ... DONE
[17:43:52.473] future_by_internal() ... DONE
[17:43:52.474] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:43:52.474] future_lapply() ...
[17:43:52.478] Number of chunks: 1
[17:43:52.478] getGlobalsAndPackagesXApply() ...
[17:43:52.478]  - future.globals: TRUE
[17:43:52.478] getGlobalsAndPackages() ...
[17:43:52.478] Searching for globals...
[17:43:52.479] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.479] Searching for globals ... DONE
[17:43:52.479] Resolving globals: FALSE
[17:43:52.480] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.480] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.480] - globals: [1] ‘FUN’
[17:43:52.480] 
[17:43:52.480] getGlobalsAndPackages() ... DONE
[17:43:52.480]  - globals found/used: [n=1] ‘FUN’
[17:43:52.480]  - needed namespaces: [n=0] 
[17:43:52.480] Finding globals ... DONE
[17:43:52.481]  - use_args: TRUE
[17:43:52.481]  - Getting '...' globals ...
[17:43:52.481] resolve() on list ...
[17:43:52.481]  recursive: 0
[17:43:52.481]  length: 1
[17:43:52.481]  elements: ‘...’
[17:43:52.481]  length: 0 (resolved future 1)
[17:43:52.481] resolve() on list ... DONE
[17:43:52.481]    - '...' content: [n=0] 
[17:43:52.482] List of 1
[17:43:52.482]  $ ...: list()
[17:43:52.482]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.482]  - attr(*, "where")=List of 1
[17:43:52.482]   ..$ ...:<environment: 0x55d6ba056c10> 
[17:43:52.482]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.482]  - attr(*, "resolved")= logi TRUE
[17:43:52.482]  - attr(*, "total_size")= num NA
[17:43:52.484]  - Getting '...' globals ... DONE
[17:43:52.484] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.484] List of 2
[17:43:52.484]  $ ...future.FUN:function (object, ...)  
[17:43:52.484]  $ ...          : list()
[17:43:52.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.484]  - attr(*, "where")=List of 2
[17:43:52.484]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.484]   ..$ ...          :<environment: 0x55d6ba056c10> 
[17:43:52.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.484]  - attr(*, "resolved")= logi FALSE
[17:43:52.484]  - attr(*, "total_size")= num 1240
[17:43:52.487] Packages to be attached in all futures: [n=0] 
[17:43:52.487] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.487] Number of futures (= number of chunks): 1
[17:43:52.487] Launching 1 futures (chunks) ...
[17:43:52.487] Chunk #1 of 1 ...
[17:43:52.487]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.487] getGlobalsAndPackages() ...
[17:43:52.487] Searching for globals...
[17:43:52.488] 
[17:43:52.488] Searching for globals ... DONE
[17:43:52.488] - globals: [0] <none>
[17:43:52.488] getGlobalsAndPackages() ... DONE
[17:43:52.488]    + additional globals found: [n=0] 
[17:43:52.488]    + additional namespaces needed: [n=0] 
[17:43:52.488]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.488]  - seeds: <none>
[17:43:52.489]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.489] getGlobalsAndPackages() ...
[17:43:52.489] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.489] Resolving globals: FALSE
[17:43:52.489] Tweak future expression to call with '...' arguments ...
[17:43:52.489] {
[17:43:52.489]     do.call(function(...) {
[17:43:52.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.489]             on.exit(options(oopts), add = TRUE)
[17:43:52.489]         }
[17:43:52.489]         {
[17:43:52.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.489]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.489]             })
[17:43:52.489]         }
[17:43:52.489]     }, args = future.call.arguments)
[17:43:52.489] }
[17:43:52.489] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.490] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.490] 
[17:43:52.490] getGlobalsAndPackages() ... DONE
[17:43:52.490] run() for ‘Future’ ...
[17:43:52.490] - state: ‘created’
[17:43:52.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.494] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.494]   - Field: ‘label’
[17:43:52.494]   - Field: ‘local’
[17:43:52.494]   - Field: ‘owner’
[17:43:52.494]   - Field: ‘envir’
[17:43:52.494]   - Field: ‘packages’
[17:43:52.494]   - Field: ‘gc’
[17:43:52.495]   - Field: ‘conditions’
[17:43:52.495]   - Field: ‘expr’
[17:43:52.495]   - Field: ‘uuid’
[17:43:52.495]   - Field: ‘seed’
[17:43:52.495]   - Field: ‘version’
[17:43:52.495]   - Field: ‘result’
[17:43:52.495]   - Field: ‘asynchronous’
[17:43:52.495]   - Field: ‘calls’
[17:43:52.495]   - Field: ‘globals’
[17:43:52.495]   - Field: ‘stdout’
[17:43:52.496]   - Field: ‘earlySignal’
[17:43:52.496]   - Field: ‘lazy’
[17:43:52.496]   - Field: ‘state’
[17:43:52.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.497] - Launch lazy future ...
[17:43:52.497] Packages needed by the future expression (n = 0): <none>
[17:43:52.497] Packages needed by future strategies (n = 0): <none>
[17:43:52.498] {
[17:43:52.498]     {
[17:43:52.498]         {
[17:43:52.498]             ...future.startTime <- base::Sys.time()
[17:43:52.498]             {
[17:43:52.498]                 {
[17:43:52.498]                   {
[17:43:52.498]                     base::local({
[17:43:52.498]                       has_future <- base::requireNamespace("future", 
[17:43:52.498]                         quietly = TRUE)
[17:43:52.498]                       if (has_future) {
[17:43:52.498]                         ns <- base::getNamespace("future")
[17:43:52.498]                         version <- ns[[".package"]][["version"]]
[17:43:52.498]                         if (is.null(version)) 
[17:43:52.498]                           version <- utils::packageVersion("future")
[17:43:52.498]                       }
[17:43:52.498]                       else {
[17:43:52.498]                         version <- NULL
[17:43:52.498]                       }
[17:43:52.498]                       if (!has_future || version < "1.8.0") {
[17:43:52.498]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.498]                           "", base::R.version$version.string), 
[17:43:52.498]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.498]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.498]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.498]                             "release", "version")], collapse = " "), 
[17:43:52.498]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.498]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.498]                           info)
[17:43:52.498]                         info <- base::paste(info, collapse = "; ")
[17:43:52.498]                         if (!has_future) {
[17:43:52.498]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.498]                             info)
[17:43:52.498]                         }
[17:43:52.498]                         else {
[17:43:52.498]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.498]                             info, version)
[17:43:52.498]                         }
[17:43:52.498]                         base::stop(msg)
[17:43:52.498]                       }
[17:43:52.498]                     })
[17:43:52.498]                   }
[17:43:52.498]                   ...future.strategy.old <- future::plan("list")
[17:43:52.498]                   options(future.plan = NULL)
[17:43:52.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.498]                 }
[17:43:52.498]                 ...future.workdir <- getwd()
[17:43:52.498]             }
[17:43:52.498]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.498]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.498]         }
[17:43:52.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.498]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.498]             base::names(...future.oldOptions))
[17:43:52.498]     }
[17:43:52.498]     if (FALSE) {
[17:43:52.498]     }
[17:43:52.498]     else {
[17:43:52.498]         if (TRUE) {
[17:43:52.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.498]                 open = "w")
[17:43:52.498]         }
[17:43:52.498]         else {
[17:43:52.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.498]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.498]         }
[17:43:52.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.498]             base::sink(type = "output", split = FALSE)
[17:43:52.498]             base::close(...future.stdout)
[17:43:52.498]         }, add = TRUE)
[17:43:52.498]     }
[17:43:52.498]     ...future.frame <- base::sys.nframe()
[17:43:52.498]     ...future.conditions <- base::list()
[17:43:52.498]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.498]     if (FALSE) {
[17:43:52.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.498]     }
[17:43:52.498]     ...future.result <- base::tryCatch({
[17:43:52.498]         base::withCallingHandlers({
[17:43:52.498]             ...future.value <- base::withVisible(base::local({
[17:43:52.498]                 do.call(function(...) {
[17:43:52.498]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.498]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.498]                     ...future.globals.maxSize)) {
[17:43:52.498]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.498]                     on.exit(options(oopts), add = TRUE)
[17:43:52.498]                   }
[17:43:52.498]                   {
[17:43:52.498]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.498]                       FUN = function(jj) {
[17:43:52.498]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.498]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.498]                       })
[17:43:52.498]                   }
[17:43:52.498]                 }, args = future.call.arguments)
[17:43:52.498]             }))
[17:43:52.498]             future::FutureResult(value = ...future.value$value, 
[17:43:52.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.498]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.498]                     ...future.globalenv.names))
[17:43:52.498]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.498]         }, condition = base::local({
[17:43:52.498]             c <- base::c
[17:43:52.498]             inherits <- base::inherits
[17:43:52.498]             invokeRestart <- base::invokeRestart
[17:43:52.498]             length <- base::length
[17:43:52.498]             list <- base::list
[17:43:52.498]             seq.int <- base::seq.int
[17:43:52.498]             signalCondition <- base::signalCondition
[17:43:52.498]             sys.calls <- base::sys.calls
[17:43:52.498]             `[[` <- base::`[[`
[17:43:52.498]             `+` <- base::`+`
[17:43:52.498]             `<<-` <- base::`<<-`
[17:43:52.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.498]                   3L)]
[17:43:52.498]             }
[17:43:52.498]             function(cond) {
[17:43:52.498]                 is_error <- inherits(cond, "error")
[17:43:52.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.498]                   NULL)
[17:43:52.498]                 if (is_error) {
[17:43:52.498]                   sessionInformation <- function() {
[17:43:52.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.498]                       search = base::search(), system = base::Sys.info())
[17:43:52.498]                   }
[17:43:52.498]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.498]                     cond$call), session = sessionInformation(), 
[17:43:52.498]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.498]                   signalCondition(cond)
[17:43:52.498]                 }
[17:43:52.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.498]                 "immediateCondition"))) {
[17:43:52.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.498]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.498]                   if (TRUE && !signal) {
[17:43:52.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.498]                     {
[17:43:52.498]                       inherits <- base::inherits
[17:43:52.498]                       invokeRestart <- base::invokeRestart
[17:43:52.498]                       is.null <- base::is.null
[17:43:52.498]                       muffled <- FALSE
[17:43:52.498]                       if (inherits(cond, "message")) {
[17:43:52.498]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.498]                         if (muffled) 
[17:43:52.498]                           invokeRestart("muffleMessage")
[17:43:52.498]                       }
[17:43:52.498]                       else if (inherits(cond, "warning")) {
[17:43:52.498]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.498]                         if (muffled) 
[17:43:52.498]                           invokeRestart("muffleWarning")
[17:43:52.498]                       }
[17:43:52.498]                       else if (inherits(cond, "condition")) {
[17:43:52.498]                         if (!is.null(pattern)) {
[17:43:52.498]                           computeRestarts <- base::computeRestarts
[17:43:52.498]                           grepl <- base::grepl
[17:43:52.498]                           restarts <- computeRestarts(cond)
[17:43:52.498]                           for (restart in restarts) {
[17:43:52.498]                             name <- restart$name
[17:43:52.498]                             if (is.null(name)) 
[17:43:52.498]                               next
[17:43:52.498]                             if (!grepl(pattern, name)) 
[17:43:52.498]                               next
[17:43:52.498]                             invokeRestart(restart)
[17:43:52.498]                             muffled <- TRUE
[17:43:52.498]                             break
[17:43:52.498]                           }
[17:43:52.498]                         }
[17:43:52.498]                       }
[17:43:52.498]                       invisible(muffled)
[17:43:52.498]                     }
[17:43:52.498]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.498]                   }
[17:43:52.498]                 }
[17:43:52.498]                 else {
[17:43:52.498]                   if (TRUE) {
[17:43:52.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.498]                     {
[17:43:52.498]                       inherits <- base::inherits
[17:43:52.498]                       invokeRestart <- base::invokeRestart
[17:43:52.498]                       is.null <- base::is.null
[17:43:52.498]                       muffled <- FALSE
[17:43:52.498]                       if (inherits(cond, "message")) {
[17:43:52.498]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.498]                         if (muffled) 
[17:43:52.498]                           invokeRestart("muffleMessage")
[17:43:52.498]                       }
[17:43:52.498]                       else if (inherits(cond, "warning")) {
[17:43:52.498]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.498]                         if (muffled) 
[17:43:52.498]                           invokeRestart("muffleWarning")
[17:43:52.498]                       }
[17:43:52.498]                       else if (inherits(cond, "condition")) {
[17:43:52.498]                         if (!is.null(pattern)) {
[17:43:52.498]                           computeRestarts <- base::computeRestarts
[17:43:52.498]                           grepl <- base::grepl
[17:43:52.498]                           restarts <- computeRestarts(cond)
[17:43:52.498]                           for (restart in restarts) {
[17:43:52.498]                             name <- restart$name
[17:43:52.498]                             if (is.null(name)) 
[17:43:52.498]                               next
[17:43:52.498]                             if (!grepl(pattern, name)) 
[17:43:52.498]                               next
[17:43:52.498]                             invokeRestart(restart)
[17:43:52.498]                             muffled <- TRUE
[17:43:52.498]                             break
[17:43:52.498]                           }
[17:43:52.498]                         }
[17:43:52.498]                       }
[17:43:52.498]                       invisible(muffled)
[17:43:52.498]                     }
[17:43:52.498]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.498]                   }
[17:43:52.498]                 }
[17:43:52.498]             }
[17:43:52.498]         }))
[17:43:52.498]     }, error = function(ex) {
[17:43:52.498]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.498]                 ...future.rng), started = ...future.startTime, 
[17:43:52.498]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.498]             version = "1.8"), class = "FutureResult")
[17:43:52.498]     }, finally = {
[17:43:52.498]         if (!identical(...future.workdir, getwd())) 
[17:43:52.498]             setwd(...future.workdir)
[17:43:52.498]         {
[17:43:52.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.498]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.498]             }
[17:43:52.498]             base::options(...future.oldOptions)
[17:43:52.498]             if (.Platform$OS.type == "windows") {
[17:43:52.498]                 old_names <- names(...future.oldEnvVars)
[17:43:52.498]                 envs <- base::Sys.getenv()
[17:43:52.498]                 names <- names(envs)
[17:43:52.498]                 common <- intersect(names, old_names)
[17:43:52.498]                 added <- setdiff(names, old_names)
[17:43:52.498]                 removed <- setdiff(old_names, names)
[17:43:52.498]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.498]                   envs[common]]
[17:43:52.498]                 NAMES <- toupper(changed)
[17:43:52.498]                 args <- list()
[17:43:52.498]                 for (kk in seq_along(NAMES)) {
[17:43:52.498]                   name <- changed[[kk]]
[17:43:52.498]                   NAME <- NAMES[[kk]]
[17:43:52.498]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.498]                     next
[17:43:52.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.498]                 }
[17:43:52.498]                 NAMES <- toupper(added)
[17:43:52.498]                 for (kk in seq_along(NAMES)) {
[17:43:52.498]                   name <- added[[kk]]
[17:43:52.498]                   NAME <- NAMES[[kk]]
[17:43:52.498]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.498]                     next
[17:43:52.498]                   args[[name]] <- ""
[17:43:52.498]                 }
[17:43:52.498]                 NAMES <- toupper(removed)
[17:43:52.498]                 for (kk in seq_along(NAMES)) {
[17:43:52.498]                   name <- removed[[kk]]
[17:43:52.498]                   NAME <- NAMES[[kk]]
[17:43:52.498]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.498]                     next
[17:43:52.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.498]                 }
[17:43:52.498]                 if (length(args) > 0) 
[17:43:52.498]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.498]             }
[17:43:52.498]             else {
[17:43:52.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.498]             }
[17:43:52.498]             {
[17:43:52.498]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.498]                   0L) {
[17:43:52.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.498]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.498]                   base::options(opts)
[17:43:52.498]                 }
[17:43:52.498]                 {
[17:43:52.498]                   {
[17:43:52.498]                     NULL
[17:43:52.498]                     RNGkind("Mersenne-Twister")
[17:43:52.498]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.498]                       inherits = FALSE)
[17:43:52.498]                   }
[17:43:52.498]                   options(future.plan = NULL)
[17:43:52.498]                   if (is.na(NA_character_)) 
[17:43:52.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.498]                     .init = FALSE)
[17:43:52.498]                 }
[17:43:52.498]             }
[17:43:52.498]         }
[17:43:52.498]     })
[17:43:52.498]     if (TRUE) {
[17:43:52.498]         base::sink(type = "output", split = FALSE)
[17:43:52.498]         if (TRUE) {
[17:43:52.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.498]         }
[17:43:52.498]         else {
[17:43:52.498]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.498]         }
[17:43:52.498]         base::close(...future.stdout)
[17:43:52.498]         ...future.stdout <- NULL
[17:43:52.498]     }
[17:43:52.498]     ...future.result$conditions <- ...future.conditions
[17:43:52.498]     ...future.result$finished <- base::Sys.time()
[17:43:52.498]     ...future.result
[17:43:52.498] }
[17:43:52.499] assign_globals() ...
[17:43:52.499] List of 5
[17:43:52.499]  $ ...future.FUN            :function (object, ...)  
[17:43:52.499]  $ future.call.arguments    : list()
[17:43:52.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.499]  $ ...future.elements_ii    :List of 3
[17:43:52.499]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.499]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.499]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.499]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.499]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.499]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.499]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.499]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.499]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.499]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.499]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.499]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.499]  $ ...future.seeds_ii       : NULL
[17:43:52.499]  $ ...future.globals.maxSize: NULL
[17:43:52.499]  - attr(*, "where")=List of 5
[17:43:52.499]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.499]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.499]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.499]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.499]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.499]  - attr(*, "resolved")= logi FALSE
[17:43:52.499]  - attr(*, "total_size")= num 1240
[17:43:52.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.499]  - attr(*, "already-done")= logi TRUE
[17:43:52.508] - copied ‘...future.FUN’ to environment
[17:43:52.508] - copied ‘future.call.arguments’ to environment
[17:43:52.508] - copied ‘...future.elements_ii’ to environment
[17:43:52.508] - copied ‘...future.seeds_ii’ to environment
[17:43:52.508] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.508] assign_globals() ... done
[17:43:52.508] plan(): Setting new future strategy stack:
[17:43:52.508] List of future strategies:
[17:43:52.508] 1. sequential:
[17:43:52.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.508]    - tweaked: FALSE
[17:43:52.508]    - call: NULL
[17:43:52.509] plan(): nbrOfWorkers() = 1
[17:43:52.511] plan(): Setting new future strategy stack:
[17:43:52.511] List of future strategies:
[17:43:52.511] 1. multicore:
[17:43:52.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:52.511]    - tweaked: FALSE
[17:43:52.511]    - call: plan(strategy)
[17:43:52.514] plan(): nbrOfWorkers() = 1
[17:43:52.514] SequentialFuture started (and completed)
[17:43:52.514] - Launch lazy future ... done
[17:43:52.515] run() for ‘SequentialFuture’ ... done
[17:43:52.515] Created future:
[17:43:52.515] SequentialFuture:
[17:43:52.515] Label: ‘future_by-1’
[17:43:52.515] Expression:
[17:43:52.515] {
[17:43:52.515]     do.call(function(...) {
[17:43:52.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.515]             on.exit(options(oopts), add = TRUE)
[17:43:52.515]         }
[17:43:52.515]         {
[17:43:52.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.515]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.515]             })
[17:43:52.515]         }
[17:43:52.515]     }, args = future.call.arguments)
[17:43:52.515] }
[17:43:52.515] Lazy evaluation: FALSE
[17:43:52.515] Asynchronous evaluation: FALSE
[17:43:52.515] Local evaluation: TRUE
[17:43:52.515] Environment: 0x55d6ba0b22f0
[17:43:52.515] Capture standard output: TRUE
[17:43:52.515] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.515] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.515] Packages: <none>
[17:43:52.515] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.515] Resolved: TRUE
[17:43:52.515] Value: 5.37 KiB of class ‘list’
[17:43:52.515] Early signaling: FALSE
[17:43:52.515] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.515] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.516] Chunk #1 of 1 ... DONE
[17:43:52.516] Launching 1 futures (chunks) ... DONE
[17:43:52.516] Resolving 1 futures (chunks) ...
[17:43:52.516] resolve() on list ...
[17:43:52.516]  recursive: 0
[17:43:52.517]  length: 1
[17:43:52.517] 
[17:43:52.517] resolved() for ‘SequentialFuture’ ...
[17:43:52.517] - state: ‘finished’
[17:43:52.517] - run: TRUE
[17:43:52.517] - result: ‘FutureResult’
[17:43:52.517] resolved() for ‘SequentialFuture’ ... done
[17:43:52.517] Future #1
[17:43:52.517] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.517] - nx: 1
[17:43:52.517] - relay: TRUE
[17:43:52.518] - stdout: TRUE
[17:43:52.518] - signal: TRUE
[17:43:52.518] - resignal: FALSE
[17:43:52.518] - force: TRUE
[17:43:52.518] - relayed: [n=1] FALSE
[17:43:52.518] - queued futures: [n=1] FALSE
[17:43:52.518]  - until=1
[17:43:52.518]  - relaying element #1
[17:43:52.518] - relayed: [n=1] TRUE
[17:43:52.518] - queued futures: [n=1] TRUE
[17:43:52.518] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.519]  length: 0 (resolved future 1)
[17:43:52.519] Relaying remaining futures
[17:43:52.519] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.519] - nx: 1
[17:43:52.519] - relay: TRUE
[17:43:52.519] - stdout: TRUE
[17:43:52.519] - signal: TRUE
[17:43:52.519] - resignal: FALSE
[17:43:52.519] - force: TRUE
[17:43:52.519] - relayed: [n=1] TRUE
[17:43:52.519] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.520] - relayed: [n=1] TRUE
[17:43:52.520] - queued futures: [n=1] TRUE
[17:43:52.520] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.520] resolve() on list ... DONE
[17:43:52.520]  - Number of value chunks collected: 1
[17:43:52.520] Resolving 1 futures (chunks) ... DONE
[17:43:52.520] Reducing values from 1 chunks ...
[17:43:52.520]  - Number of values collected after concatenation: 3
[17:43:52.520]  - Number of values expected: 3
[17:43:52.520] Reducing values from 1 chunks ... DONE
[17:43:52.520] future_lapply() ... DONE
[17:43:52.521] future_by_internal() ... DONE
[17:43:52.523] future_by_internal() ...
- plan('multisession') ...
[17:43:52.523] plan(): Setting new future strategy stack:
[17:43:52.523] List of future strategies:
[17:43:52.523] 1. multisession:
[17:43:52.523]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.523]    - tweaked: FALSE
[17:43:52.523]    - call: plan(strategy)
[17:43:52.524] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:52.524] multisession:
[17:43:52.524] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.524] - tweaked: FALSE
[17:43:52.524] - call: plan(strategy)
[17:43:52.527] getGlobalsAndPackages() ...
[17:43:52.527] Not searching for globals
[17:43:52.527] - globals: [0] <none>
[17:43:52.527] getGlobalsAndPackages() ... DONE
[17:43:52.528] Packages needed by the future expression (n = 0): <none>
[17:43:52.528] Packages needed by future strategies (n = 0): <none>
[17:43:52.528] {
[17:43:52.528]     {
[17:43:52.528]         {
[17:43:52.528]             ...future.startTime <- base::Sys.time()
[17:43:52.528]             {
[17:43:52.528]                 {
[17:43:52.528]                   {
[17:43:52.528]                     base::local({
[17:43:52.528]                       has_future <- base::requireNamespace("future", 
[17:43:52.528]                         quietly = TRUE)
[17:43:52.528]                       if (has_future) {
[17:43:52.528]                         ns <- base::getNamespace("future")
[17:43:52.528]                         version <- ns[[".package"]][["version"]]
[17:43:52.528]                         if (is.null(version)) 
[17:43:52.528]                           version <- utils::packageVersion("future")
[17:43:52.528]                       }
[17:43:52.528]                       else {
[17:43:52.528]                         version <- NULL
[17:43:52.528]                       }
[17:43:52.528]                       if (!has_future || version < "1.8.0") {
[17:43:52.528]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.528]                           "", base::R.version$version.string), 
[17:43:52.528]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.528]                             "release", "version")], collapse = " "), 
[17:43:52.528]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.528]                           info)
[17:43:52.528]                         info <- base::paste(info, collapse = "; ")
[17:43:52.528]                         if (!has_future) {
[17:43:52.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.528]                             info)
[17:43:52.528]                         }
[17:43:52.528]                         else {
[17:43:52.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.528]                             info, version)
[17:43:52.528]                         }
[17:43:52.528]                         base::stop(msg)
[17:43:52.528]                       }
[17:43:52.528]                     })
[17:43:52.528]                   }
[17:43:52.528]                   ...future.strategy.old <- future::plan("list")
[17:43:52.528]                   options(future.plan = NULL)
[17:43:52.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.528]                 }
[17:43:52.528]                 ...future.workdir <- getwd()
[17:43:52.528]             }
[17:43:52.528]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.528]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.528]         }
[17:43:52.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.528]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.528]             base::names(...future.oldOptions))
[17:43:52.528]     }
[17:43:52.528]     if (FALSE) {
[17:43:52.528]     }
[17:43:52.528]     else {
[17:43:52.528]         if (TRUE) {
[17:43:52.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.528]                 open = "w")
[17:43:52.528]         }
[17:43:52.528]         else {
[17:43:52.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.528]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.528]         }
[17:43:52.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.528]             base::sink(type = "output", split = FALSE)
[17:43:52.528]             base::close(...future.stdout)
[17:43:52.528]         }, add = TRUE)
[17:43:52.528]     }
[17:43:52.528]     ...future.frame <- base::sys.nframe()
[17:43:52.528]     ...future.conditions <- base::list()
[17:43:52.528]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.528]     if (FALSE) {
[17:43:52.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.528]     }
[17:43:52.528]     ...future.result <- base::tryCatch({
[17:43:52.528]         base::withCallingHandlers({
[17:43:52.528]             ...future.value <- base::withVisible(base::local(NA))
[17:43:52.528]             future::FutureResult(value = ...future.value$value, 
[17:43:52.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.528]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.528]                     ...future.globalenv.names))
[17:43:52.528]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.528]         }, condition = base::local({
[17:43:52.528]             c <- base::c
[17:43:52.528]             inherits <- base::inherits
[17:43:52.528]             invokeRestart <- base::invokeRestart
[17:43:52.528]             length <- base::length
[17:43:52.528]             list <- base::list
[17:43:52.528]             seq.int <- base::seq.int
[17:43:52.528]             signalCondition <- base::signalCondition
[17:43:52.528]             sys.calls <- base::sys.calls
[17:43:52.528]             `[[` <- base::`[[`
[17:43:52.528]             `+` <- base::`+`
[17:43:52.528]             `<<-` <- base::`<<-`
[17:43:52.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.528]                   3L)]
[17:43:52.528]             }
[17:43:52.528]             function(cond) {
[17:43:52.528]                 is_error <- inherits(cond, "error")
[17:43:52.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.528]                   NULL)
[17:43:52.528]                 if (is_error) {
[17:43:52.528]                   sessionInformation <- function() {
[17:43:52.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.528]                       search = base::search(), system = base::Sys.info())
[17:43:52.528]                   }
[17:43:52.528]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.528]                     cond$call), session = sessionInformation(), 
[17:43:52.528]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.528]                   signalCondition(cond)
[17:43:52.528]                 }
[17:43:52.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.528]                 "immediateCondition"))) {
[17:43:52.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.528]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.528]                   if (TRUE && !signal) {
[17:43:52.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.528]                     {
[17:43:52.528]                       inherits <- base::inherits
[17:43:52.528]                       invokeRestart <- base::invokeRestart
[17:43:52.528]                       is.null <- base::is.null
[17:43:52.528]                       muffled <- FALSE
[17:43:52.528]                       if (inherits(cond, "message")) {
[17:43:52.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.528]                         if (muffled) 
[17:43:52.528]                           invokeRestart("muffleMessage")
[17:43:52.528]                       }
[17:43:52.528]                       else if (inherits(cond, "warning")) {
[17:43:52.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.528]                         if (muffled) 
[17:43:52.528]                           invokeRestart("muffleWarning")
[17:43:52.528]                       }
[17:43:52.528]                       else if (inherits(cond, "condition")) {
[17:43:52.528]                         if (!is.null(pattern)) {
[17:43:52.528]                           computeRestarts <- base::computeRestarts
[17:43:52.528]                           grepl <- base::grepl
[17:43:52.528]                           restarts <- computeRestarts(cond)
[17:43:52.528]                           for (restart in restarts) {
[17:43:52.528]                             name <- restart$name
[17:43:52.528]                             if (is.null(name)) 
[17:43:52.528]                               next
[17:43:52.528]                             if (!grepl(pattern, name)) 
[17:43:52.528]                               next
[17:43:52.528]                             invokeRestart(restart)
[17:43:52.528]                             muffled <- TRUE
[17:43:52.528]                             break
[17:43:52.528]                           }
[17:43:52.528]                         }
[17:43:52.528]                       }
[17:43:52.528]                       invisible(muffled)
[17:43:52.528]                     }
[17:43:52.528]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.528]                   }
[17:43:52.528]                 }
[17:43:52.528]                 else {
[17:43:52.528]                   if (TRUE) {
[17:43:52.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.528]                     {
[17:43:52.528]                       inherits <- base::inherits
[17:43:52.528]                       invokeRestart <- base::invokeRestart
[17:43:52.528]                       is.null <- base::is.null
[17:43:52.528]                       muffled <- FALSE
[17:43:52.528]                       if (inherits(cond, "message")) {
[17:43:52.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.528]                         if (muffled) 
[17:43:52.528]                           invokeRestart("muffleMessage")
[17:43:52.528]                       }
[17:43:52.528]                       else if (inherits(cond, "warning")) {
[17:43:52.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.528]                         if (muffled) 
[17:43:52.528]                           invokeRestart("muffleWarning")
[17:43:52.528]                       }
[17:43:52.528]                       else if (inherits(cond, "condition")) {
[17:43:52.528]                         if (!is.null(pattern)) {
[17:43:52.528]                           computeRestarts <- base::computeRestarts
[17:43:52.528]                           grepl <- base::grepl
[17:43:52.528]                           restarts <- computeRestarts(cond)
[17:43:52.528]                           for (restart in restarts) {
[17:43:52.528]                             name <- restart$name
[17:43:52.528]                             if (is.null(name)) 
[17:43:52.528]                               next
[17:43:52.528]                             if (!grepl(pattern, name)) 
[17:43:52.528]                               next
[17:43:52.528]                             invokeRestart(restart)
[17:43:52.528]                             muffled <- TRUE
[17:43:52.528]                             break
[17:43:52.528]                           }
[17:43:52.528]                         }
[17:43:52.528]                       }
[17:43:52.528]                       invisible(muffled)
[17:43:52.528]                     }
[17:43:52.528]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.528]                   }
[17:43:52.528]                 }
[17:43:52.528]             }
[17:43:52.528]         }))
[17:43:52.528]     }, error = function(ex) {
[17:43:52.528]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.528]                 ...future.rng), started = ...future.startTime, 
[17:43:52.528]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.528]             version = "1.8"), class = "FutureResult")
[17:43:52.528]     }, finally = {
[17:43:52.528]         if (!identical(...future.workdir, getwd())) 
[17:43:52.528]             setwd(...future.workdir)
[17:43:52.528]         {
[17:43:52.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.528]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.528]             }
[17:43:52.528]             base::options(...future.oldOptions)
[17:43:52.528]             if (.Platform$OS.type == "windows") {
[17:43:52.528]                 old_names <- names(...future.oldEnvVars)
[17:43:52.528]                 envs <- base::Sys.getenv()
[17:43:52.528]                 names <- names(envs)
[17:43:52.528]                 common <- intersect(names, old_names)
[17:43:52.528]                 added <- setdiff(names, old_names)
[17:43:52.528]                 removed <- setdiff(old_names, names)
[17:43:52.528]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.528]                   envs[common]]
[17:43:52.528]                 NAMES <- toupper(changed)
[17:43:52.528]                 args <- list()
[17:43:52.528]                 for (kk in seq_along(NAMES)) {
[17:43:52.528]                   name <- changed[[kk]]
[17:43:52.528]                   NAME <- NAMES[[kk]]
[17:43:52.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.528]                     next
[17:43:52.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.528]                 }
[17:43:52.528]                 NAMES <- toupper(added)
[17:43:52.528]                 for (kk in seq_along(NAMES)) {
[17:43:52.528]                   name <- added[[kk]]
[17:43:52.528]                   NAME <- NAMES[[kk]]
[17:43:52.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.528]                     next
[17:43:52.528]                   args[[name]] <- ""
[17:43:52.528]                 }
[17:43:52.528]                 NAMES <- toupper(removed)
[17:43:52.528]                 for (kk in seq_along(NAMES)) {
[17:43:52.528]                   name <- removed[[kk]]
[17:43:52.528]                   NAME <- NAMES[[kk]]
[17:43:52.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.528]                     next
[17:43:52.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.528]                 }
[17:43:52.528]                 if (length(args) > 0) 
[17:43:52.528]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.528]             }
[17:43:52.528]             else {
[17:43:52.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.528]             }
[17:43:52.528]             {
[17:43:52.528]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.528]                   0L) {
[17:43:52.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.528]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.528]                   base::options(opts)
[17:43:52.528]                 }
[17:43:52.528]                 {
[17:43:52.528]                   {
[17:43:52.528]                     NULL
[17:43:52.528]                     RNGkind("Mersenne-Twister")
[17:43:52.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.528]                       inherits = FALSE)
[17:43:52.528]                   }
[17:43:52.528]                   options(future.plan = NULL)
[17:43:52.528]                   if (is.na(NA_character_)) 
[17:43:52.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.528]                     .init = FALSE)
[17:43:52.528]                 }
[17:43:52.528]             }
[17:43:52.528]         }
[17:43:52.528]     })
[17:43:52.528]     if (TRUE) {
[17:43:52.528]         base::sink(type = "output", split = FALSE)
[17:43:52.528]         if (TRUE) {
[17:43:52.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.528]         }
[17:43:52.528]         else {
[17:43:52.528]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.528]         }
[17:43:52.528]         base::close(...future.stdout)
[17:43:52.528]         ...future.stdout <- NULL
[17:43:52.528]     }
[17:43:52.528]     ...future.result$conditions <- ...future.conditions
[17:43:52.528]     ...future.result$finished <- base::Sys.time()
[17:43:52.528]     ...future.result
[17:43:52.528] }
[17:43:52.530] plan(): Setting new future strategy stack:
[17:43:52.530] List of future strategies:
[17:43:52.530] 1. sequential:
[17:43:52.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.530]    - tweaked: FALSE
[17:43:52.530]    - call: NULL
[17:43:52.530] plan(): nbrOfWorkers() = 1
[17:43:52.531] plan(): Setting new future strategy stack:
[17:43:52.531] List of future strategies:
[17:43:52.531] 1. multisession:
[17:43:52.531]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.531]    - tweaked: FALSE
[17:43:52.531]    - call: plan(strategy)
[17:43:52.534] plan(): nbrOfWorkers() = 1
[17:43:52.535] SequentialFuture started (and completed)
[17:43:52.535] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:52.538] plan(): nbrOfWorkers() = 1
[17:43:52.538] future_by_internal() ...
[17:43:52.538] future_lapply() ...
[17:43:52.542] Number of chunks: 1
[17:43:52.542] getGlobalsAndPackagesXApply() ...
[17:43:52.542]  - future.globals: TRUE
[17:43:52.542] getGlobalsAndPackages() ...
[17:43:52.542] Searching for globals...
[17:43:52.543] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.543] Searching for globals ... DONE
[17:43:52.543] Resolving globals: FALSE
[17:43:52.544] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.544] - globals: [1] ‘FUN’
[17:43:52.544] 
[17:43:52.544] getGlobalsAndPackages() ... DONE
[17:43:52.544]  - globals found/used: [n=1] ‘FUN’
[17:43:52.544]  - needed namespaces: [n=0] 
[17:43:52.545] Finding globals ... DONE
[17:43:52.545]  - use_args: TRUE
[17:43:52.545]  - Getting '...' globals ...
[17:43:52.545] resolve() on list ...
[17:43:52.545]  recursive: 0
[17:43:52.545]  length: 1
[17:43:52.545]  elements: ‘...’
[17:43:52.545]  length: 0 (resolved future 1)
[17:43:52.545] resolve() on list ... DONE
[17:43:52.546]    - '...' content: [n=0] 
[17:43:52.546] List of 1
[17:43:52.546]  $ ...: list()
[17:43:52.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.546]  - attr(*, "where")=List of 1
[17:43:52.546]   ..$ ...:<environment: 0x55d6ba321c38> 
[17:43:52.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.546]  - attr(*, "resolved")= logi TRUE
[17:43:52.546]  - attr(*, "total_size")= num NA
[17:43:52.548]  - Getting '...' globals ... DONE
[17:43:52.548] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.548] List of 2
[17:43:52.548]  $ ...future.FUN:function (object, ...)  
[17:43:52.548]  $ ...          : list()
[17:43:52.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.548]  - attr(*, "where")=List of 2
[17:43:52.548]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.548]   ..$ ...          :<environment: 0x55d6ba321c38> 
[17:43:52.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.548]  - attr(*, "resolved")= logi FALSE
[17:43:52.548]  - attr(*, "total_size")= num 1240
[17:43:52.551] Packages to be attached in all futures: [n=0] 
[17:43:52.551] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.551] Number of futures (= number of chunks): 1
[17:43:52.551] Launching 1 futures (chunks) ...
[17:43:52.551] Chunk #1 of 1 ...
[17:43:52.551]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.551] getGlobalsAndPackages() ...
[17:43:52.552] Searching for globals...
[17:43:52.552] 
[17:43:52.552] Searching for globals ... DONE
[17:43:52.552] - globals: [0] <none>
[17:43:52.552] getGlobalsAndPackages() ... DONE
[17:43:52.552]    + additional globals found: [n=0] 
[17:43:52.552]    + additional namespaces needed: [n=0] 
[17:43:52.553]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.553]  - seeds: <none>
[17:43:52.554]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.554] getGlobalsAndPackages() ...
[17:43:52.554] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.554] Resolving globals: FALSE
[17:43:52.554] Tweak future expression to call with '...' arguments ...
[17:43:52.554] {
[17:43:52.554]     do.call(function(...) {
[17:43:52.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.554]             on.exit(options(oopts), add = TRUE)
[17:43:52.554]         }
[17:43:52.554]         {
[17:43:52.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.554]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.554]             })
[17:43:52.554]         }
[17:43:52.554]     }, args = future.call.arguments)
[17:43:52.554] }
[17:43:52.555] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.555] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.555] 
[17:43:52.555] getGlobalsAndPackages() ... DONE
[17:43:52.556] run() for ‘Future’ ...
[17:43:52.556] - state: ‘created’
[17:43:52.556] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.559]   - Field: ‘label’
[17:43:52.559]   - Field: ‘local’
[17:43:52.559]   - Field: ‘owner’
[17:43:52.559]   - Field: ‘envir’
[17:43:52.560]   - Field: ‘packages’
[17:43:52.560]   - Field: ‘gc’
[17:43:52.560]   - Field: ‘conditions’
[17:43:52.560]   - Field: ‘expr’
[17:43:52.560]   - Field: ‘uuid’
[17:43:52.560]   - Field: ‘seed’
[17:43:52.560]   - Field: ‘version’
[17:43:52.560]   - Field: ‘result’
[17:43:52.560]   - Field: ‘asynchronous’
[17:43:52.560]   - Field: ‘calls’
[17:43:52.560]   - Field: ‘globals’
[17:43:52.561]   - Field: ‘stdout’
[17:43:52.561]   - Field: ‘earlySignal’
[17:43:52.561]   - Field: ‘lazy’
[17:43:52.561]   - Field: ‘state’
[17:43:52.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.561] - Launch lazy future ...
[17:43:52.561] Packages needed by the future expression (n = 0): <none>
[17:43:52.561] Packages needed by future strategies (n = 0): <none>
[17:43:52.562] {
[17:43:52.562]     {
[17:43:52.562]         {
[17:43:52.562]             ...future.startTime <- base::Sys.time()
[17:43:52.562]             {
[17:43:52.562]                 {
[17:43:52.562]                   {
[17:43:52.562]                     base::local({
[17:43:52.562]                       has_future <- base::requireNamespace("future", 
[17:43:52.562]                         quietly = TRUE)
[17:43:52.562]                       if (has_future) {
[17:43:52.562]                         ns <- base::getNamespace("future")
[17:43:52.562]                         version <- ns[[".package"]][["version"]]
[17:43:52.562]                         if (is.null(version)) 
[17:43:52.562]                           version <- utils::packageVersion("future")
[17:43:52.562]                       }
[17:43:52.562]                       else {
[17:43:52.562]                         version <- NULL
[17:43:52.562]                       }
[17:43:52.562]                       if (!has_future || version < "1.8.0") {
[17:43:52.562]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.562]                           "", base::R.version$version.string), 
[17:43:52.562]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.562]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.562]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.562]                             "release", "version")], collapse = " "), 
[17:43:52.562]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.562]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.562]                           info)
[17:43:52.562]                         info <- base::paste(info, collapse = "; ")
[17:43:52.562]                         if (!has_future) {
[17:43:52.562]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.562]                             info)
[17:43:52.562]                         }
[17:43:52.562]                         else {
[17:43:52.562]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.562]                             info, version)
[17:43:52.562]                         }
[17:43:52.562]                         base::stop(msg)
[17:43:52.562]                       }
[17:43:52.562]                     })
[17:43:52.562]                   }
[17:43:52.562]                   ...future.strategy.old <- future::plan("list")
[17:43:52.562]                   options(future.plan = NULL)
[17:43:52.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.562]                 }
[17:43:52.562]                 ...future.workdir <- getwd()
[17:43:52.562]             }
[17:43:52.562]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.562]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.562]         }
[17:43:52.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.562]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.562]             base::names(...future.oldOptions))
[17:43:52.562]     }
[17:43:52.562]     if (FALSE) {
[17:43:52.562]     }
[17:43:52.562]     else {
[17:43:52.562]         if (TRUE) {
[17:43:52.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.562]                 open = "w")
[17:43:52.562]         }
[17:43:52.562]         else {
[17:43:52.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.562]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.562]         }
[17:43:52.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.562]             base::sink(type = "output", split = FALSE)
[17:43:52.562]             base::close(...future.stdout)
[17:43:52.562]         }, add = TRUE)
[17:43:52.562]     }
[17:43:52.562]     ...future.frame <- base::sys.nframe()
[17:43:52.562]     ...future.conditions <- base::list()
[17:43:52.562]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.562]     if (FALSE) {
[17:43:52.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.562]     }
[17:43:52.562]     ...future.result <- base::tryCatch({
[17:43:52.562]         base::withCallingHandlers({
[17:43:52.562]             ...future.value <- base::withVisible(base::local({
[17:43:52.562]                 do.call(function(...) {
[17:43:52.562]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.562]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.562]                     ...future.globals.maxSize)) {
[17:43:52.562]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.562]                     on.exit(options(oopts), add = TRUE)
[17:43:52.562]                   }
[17:43:52.562]                   {
[17:43:52.562]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.562]                       FUN = function(jj) {
[17:43:52.562]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.562]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.562]                       })
[17:43:52.562]                   }
[17:43:52.562]                 }, args = future.call.arguments)
[17:43:52.562]             }))
[17:43:52.562]             future::FutureResult(value = ...future.value$value, 
[17:43:52.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.562]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.562]                     ...future.globalenv.names))
[17:43:52.562]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.562]         }, condition = base::local({
[17:43:52.562]             c <- base::c
[17:43:52.562]             inherits <- base::inherits
[17:43:52.562]             invokeRestart <- base::invokeRestart
[17:43:52.562]             length <- base::length
[17:43:52.562]             list <- base::list
[17:43:52.562]             seq.int <- base::seq.int
[17:43:52.562]             signalCondition <- base::signalCondition
[17:43:52.562]             sys.calls <- base::sys.calls
[17:43:52.562]             `[[` <- base::`[[`
[17:43:52.562]             `+` <- base::`+`
[17:43:52.562]             `<<-` <- base::`<<-`
[17:43:52.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.562]                   3L)]
[17:43:52.562]             }
[17:43:52.562]             function(cond) {
[17:43:52.562]                 is_error <- inherits(cond, "error")
[17:43:52.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.562]                   NULL)
[17:43:52.562]                 if (is_error) {
[17:43:52.562]                   sessionInformation <- function() {
[17:43:52.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.562]                       search = base::search(), system = base::Sys.info())
[17:43:52.562]                   }
[17:43:52.562]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.562]                     cond$call), session = sessionInformation(), 
[17:43:52.562]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.562]                   signalCondition(cond)
[17:43:52.562]                 }
[17:43:52.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.562]                 "immediateCondition"))) {
[17:43:52.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.562]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.562]                   if (TRUE && !signal) {
[17:43:52.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.562]                     {
[17:43:52.562]                       inherits <- base::inherits
[17:43:52.562]                       invokeRestart <- base::invokeRestart
[17:43:52.562]                       is.null <- base::is.null
[17:43:52.562]                       muffled <- FALSE
[17:43:52.562]                       if (inherits(cond, "message")) {
[17:43:52.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.562]                         if (muffled) 
[17:43:52.562]                           invokeRestart("muffleMessage")
[17:43:52.562]                       }
[17:43:52.562]                       else if (inherits(cond, "warning")) {
[17:43:52.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.562]                         if (muffled) 
[17:43:52.562]                           invokeRestart("muffleWarning")
[17:43:52.562]                       }
[17:43:52.562]                       else if (inherits(cond, "condition")) {
[17:43:52.562]                         if (!is.null(pattern)) {
[17:43:52.562]                           computeRestarts <- base::computeRestarts
[17:43:52.562]                           grepl <- base::grepl
[17:43:52.562]                           restarts <- computeRestarts(cond)
[17:43:52.562]                           for (restart in restarts) {
[17:43:52.562]                             name <- restart$name
[17:43:52.562]                             if (is.null(name)) 
[17:43:52.562]                               next
[17:43:52.562]                             if (!grepl(pattern, name)) 
[17:43:52.562]                               next
[17:43:52.562]                             invokeRestart(restart)
[17:43:52.562]                             muffled <- TRUE
[17:43:52.562]                             break
[17:43:52.562]                           }
[17:43:52.562]                         }
[17:43:52.562]                       }
[17:43:52.562]                       invisible(muffled)
[17:43:52.562]                     }
[17:43:52.562]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.562]                   }
[17:43:52.562]                 }
[17:43:52.562]                 else {
[17:43:52.562]                   if (TRUE) {
[17:43:52.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.562]                     {
[17:43:52.562]                       inherits <- base::inherits
[17:43:52.562]                       invokeRestart <- base::invokeRestart
[17:43:52.562]                       is.null <- base::is.null
[17:43:52.562]                       muffled <- FALSE
[17:43:52.562]                       if (inherits(cond, "message")) {
[17:43:52.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.562]                         if (muffled) 
[17:43:52.562]                           invokeRestart("muffleMessage")
[17:43:52.562]                       }
[17:43:52.562]                       else if (inherits(cond, "warning")) {
[17:43:52.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.562]                         if (muffled) 
[17:43:52.562]                           invokeRestart("muffleWarning")
[17:43:52.562]                       }
[17:43:52.562]                       else if (inherits(cond, "condition")) {
[17:43:52.562]                         if (!is.null(pattern)) {
[17:43:52.562]                           computeRestarts <- base::computeRestarts
[17:43:52.562]                           grepl <- base::grepl
[17:43:52.562]                           restarts <- computeRestarts(cond)
[17:43:52.562]                           for (restart in restarts) {
[17:43:52.562]                             name <- restart$name
[17:43:52.562]                             if (is.null(name)) 
[17:43:52.562]                               next
[17:43:52.562]                             if (!grepl(pattern, name)) 
[17:43:52.562]                               next
[17:43:52.562]                             invokeRestart(restart)
[17:43:52.562]                             muffled <- TRUE
[17:43:52.562]                             break
[17:43:52.562]                           }
[17:43:52.562]                         }
[17:43:52.562]                       }
[17:43:52.562]                       invisible(muffled)
[17:43:52.562]                     }
[17:43:52.562]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.562]                   }
[17:43:52.562]                 }
[17:43:52.562]             }
[17:43:52.562]         }))
[17:43:52.562]     }, error = function(ex) {
[17:43:52.562]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.562]                 ...future.rng), started = ...future.startTime, 
[17:43:52.562]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.562]             version = "1.8"), class = "FutureResult")
[17:43:52.562]     }, finally = {
[17:43:52.562]         if (!identical(...future.workdir, getwd())) 
[17:43:52.562]             setwd(...future.workdir)
[17:43:52.562]         {
[17:43:52.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.562]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.562]             }
[17:43:52.562]             base::options(...future.oldOptions)
[17:43:52.562]             if (.Platform$OS.type == "windows") {
[17:43:52.562]                 old_names <- names(...future.oldEnvVars)
[17:43:52.562]                 envs <- base::Sys.getenv()
[17:43:52.562]                 names <- names(envs)
[17:43:52.562]                 common <- intersect(names, old_names)
[17:43:52.562]                 added <- setdiff(names, old_names)
[17:43:52.562]                 removed <- setdiff(old_names, names)
[17:43:52.562]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.562]                   envs[common]]
[17:43:52.562]                 NAMES <- toupper(changed)
[17:43:52.562]                 args <- list()
[17:43:52.562]                 for (kk in seq_along(NAMES)) {
[17:43:52.562]                   name <- changed[[kk]]
[17:43:52.562]                   NAME <- NAMES[[kk]]
[17:43:52.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.562]                     next
[17:43:52.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.562]                 }
[17:43:52.562]                 NAMES <- toupper(added)
[17:43:52.562]                 for (kk in seq_along(NAMES)) {
[17:43:52.562]                   name <- added[[kk]]
[17:43:52.562]                   NAME <- NAMES[[kk]]
[17:43:52.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.562]                     next
[17:43:52.562]                   args[[name]] <- ""
[17:43:52.562]                 }
[17:43:52.562]                 NAMES <- toupper(removed)
[17:43:52.562]                 for (kk in seq_along(NAMES)) {
[17:43:52.562]                   name <- removed[[kk]]
[17:43:52.562]                   NAME <- NAMES[[kk]]
[17:43:52.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.562]                     next
[17:43:52.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.562]                 }
[17:43:52.562]                 if (length(args) > 0) 
[17:43:52.562]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.562]             }
[17:43:52.562]             else {
[17:43:52.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.562]             }
[17:43:52.562]             {
[17:43:52.562]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.562]                   0L) {
[17:43:52.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.562]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.562]                   base::options(opts)
[17:43:52.562]                 }
[17:43:52.562]                 {
[17:43:52.562]                   {
[17:43:52.562]                     NULL
[17:43:52.562]                     RNGkind("Mersenne-Twister")
[17:43:52.562]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.562]                       inherits = FALSE)
[17:43:52.562]                   }
[17:43:52.562]                   options(future.plan = NULL)
[17:43:52.562]                   if (is.na(NA_character_)) 
[17:43:52.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.562]                     .init = FALSE)
[17:43:52.562]                 }
[17:43:52.562]             }
[17:43:52.562]         }
[17:43:52.562]     })
[17:43:52.562]     if (TRUE) {
[17:43:52.562]         base::sink(type = "output", split = FALSE)
[17:43:52.562]         if (TRUE) {
[17:43:52.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.562]         }
[17:43:52.562]         else {
[17:43:52.562]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.562]         }
[17:43:52.562]         base::close(...future.stdout)
[17:43:52.562]         ...future.stdout <- NULL
[17:43:52.562]     }
[17:43:52.562]     ...future.result$conditions <- ...future.conditions
[17:43:52.562]     ...future.result$finished <- base::Sys.time()
[17:43:52.562]     ...future.result
[17:43:52.562] }
[17:43:52.563] assign_globals() ...
[17:43:52.564] List of 5
[17:43:52.564]  $ ...future.FUN            :function (object, ...)  
[17:43:52.564]  $ future.call.arguments    : list()
[17:43:52.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.564]  $ ...future.elements_ii    :List of 3
[17:43:52.564]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.564]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.564]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.564]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.564]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.564]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.564]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.564]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.564]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.564]  $ ...future.seeds_ii       : NULL
[17:43:52.564]  $ ...future.globals.maxSize: NULL
[17:43:52.564]  - attr(*, "where")=List of 5
[17:43:52.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.564]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.564]  - attr(*, "resolved")= logi FALSE
[17:43:52.564]  - attr(*, "total_size")= num 1240
[17:43:52.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.564]  - attr(*, "already-done")= logi TRUE
[17:43:52.571] - copied ‘...future.FUN’ to environment
[17:43:52.571] - copied ‘future.call.arguments’ to environment
[17:43:52.571] - copied ‘...future.elements_ii’ to environment
[17:43:52.571] - copied ‘...future.seeds_ii’ to environment
[17:43:52.571] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.571] assign_globals() ... done
[17:43:52.571] plan(): Setting new future strategy stack:
[17:43:52.571] List of future strategies:
[17:43:52.571] 1. sequential:
[17:43:52.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.571]    - tweaked: FALSE
[17:43:52.571]    - call: NULL
[17:43:52.572] plan(): nbrOfWorkers() = 1
[17:43:52.574] plan(): Setting new future strategy stack:
[17:43:52.574] List of future strategies:
[17:43:52.574] 1. multisession:
[17:43:52.574]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.574]    - tweaked: FALSE
[17:43:52.574]    - call: plan(strategy)
[17:43:52.577] plan(): nbrOfWorkers() = 1
[17:43:52.577] SequentialFuture started (and completed)
[17:43:52.577] - Launch lazy future ... done
[17:43:52.577] run() for ‘SequentialFuture’ ... done
[17:43:52.577] Created future:
[17:43:52.578] SequentialFuture:
[17:43:52.578] Label: ‘future_by-1’
[17:43:52.578] Expression:
[17:43:52.578] {
[17:43:52.578]     do.call(function(...) {
[17:43:52.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.578]             on.exit(options(oopts), add = TRUE)
[17:43:52.578]         }
[17:43:52.578]         {
[17:43:52.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.578]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.578]             })
[17:43:52.578]         }
[17:43:52.578]     }, args = future.call.arguments)
[17:43:52.578] }
[17:43:52.578] Lazy evaluation: FALSE
[17:43:52.578] Asynchronous evaluation: FALSE
[17:43:52.578] Local evaluation: TRUE
[17:43:52.578] Environment: R_GlobalEnv
[17:43:52.578] Capture standard output: TRUE
[17:43:52.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.578] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.578] Packages: <none>
[17:43:52.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.578] Resolved: TRUE
[17:43:52.578] Value: 4.62 KiB of class ‘list’
[17:43:52.578] Early signaling: FALSE
[17:43:52.578] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.578] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.579] Chunk #1 of 1 ... DONE
[17:43:52.579] Launching 1 futures (chunks) ... DONE
[17:43:52.579] Resolving 1 futures (chunks) ...
[17:43:52.579] resolve() on list ...
[17:43:52.579]  recursive: 0
[17:43:52.579]  length: 1
[17:43:52.579] 
[17:43:52.579] resolved() for ‘SequentialFuture’ ...
[17:43:52.579] - state: ‘finished’
[17:43:52.580] - run: TRUE
[17:43:52.580] - result: ‘FutureResult’
[17:43:52.580] resolved() for ‘SequentialFuture’ ... done
[17:43:52.580] Future #1
[17:43:52.580] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.580] - nx: 1
[17:43:52.580] - relay: TRUE
[17:43:52.581] - stdout: TRUE
[17:43:52.582] - signal: TRUE
[17:43:52.582] - resignal: FALSE
[17:43:52.582] - force: TRUE
[17:43:52.582] - relayed: [n=1] FALSE
[17:43:52.582] - queued futures: [n=1] FALSE
[17:43:52.582]  - until=1
[17:43:52.582]  - relaying element #1
[17:43:52.582] - relayed: [n=1] TRUE
[17:43:52.582] - queued futures: [n=1] TRUE
[17:43:52.582] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.583]  length: 0 (resolved future 1)
[17:43:52.583] Relaying remaining futures
[17:43:52.583] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.583] - nx: 1
[17:43:52.583] - relay: TRUE
[17:43:52.583] - stdout: TRUE
[17:43:52.583] - signal: TRUE
[17:43:52.583] - resignal: FALSE
[17:43:52.583] - force: TRUE
[17:43:52.583] - relayed: [n=1] TRUE
[17:43:52.584] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.584] - relayed: [n=1] TRUE
[17:43:52.584] - queued futures: [n=1] TRUE
[17:43:52.584] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.584] resolve() on list ... DONE
[17:43:52.584]  - Number of value chunks collected: 1
[17:43:52.584] Resolving 1 futures (chunks) ... DONE
[17:43:52.584] Reducing values from 1 chunks ...
[17:43:52.584]  - Number of values collected after concatenation: 3
[17:43:52.584]  - Number of values expected: 3
[17:43:52.585] Reducing values from 1 chunks ... DONE
[17:43:52.585] future_lapply() ... DONE
[17:43:52.585] future_by_internal() ... DONE
[17:43:52.585] future_by_internal() ...
[17:43:52.585] future_lapply() ...
[17:43:52.589] Number of chunks: 1
[17:43:52.589] getGlobalsAndPackagesXApply() ...
[17:43:52.589]  - future.globals: TRUE
[17:43:52.589] getGlobalsAndPackages() ...
[17:43:52.589] Searching for globals...
[17:43:52.590] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.590] Searching for globals ... DONE
[17:43:52.590] Resolving globals: FALSE
[17:43:52.591] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.591] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.591] - globals: [1] ‘FUN’
[17:43:52.591] 
[17:43:52.591] getGlobalsAndPackages() ... DONE
[17:43:52.591]  - globals found/used: [n=1] ‘FUN’
[17:43:52.592]  - needed namespaces: [n=0] 
[17:43:52.592] Finding globals ... DONE
[17:43:52.592]  - use_args: TRUE
[17:43:52.592]  - Getting '...' globals ...
[17:43:52.592] resolve() on list ...
[17:43:52.592]  recursive: 0
[17:43:52.592]  length: 1
[17:43:52.592]  elements: ‘...’
[17:43:52.593]  length: 0 (resolved future 1)
[17:43:52.593] resolve() on list ... DONE
[17:43:52.593]    - '...' content: [n=1] ‘digits’
[17:43:52.593] List of 1
[17:43:52.593]  $ ...:List of 1
[17:43:52.593]   ..$ digits: int 2
[17:43:52.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.593]  - attr(*, "where")=List of 1
[17:43:52.593]   ..$ ...:<environment: 0x55d6ba013e38> 
[17:43:52.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.593]  - attr(*, "resolved")= logi TRUE
[17:43:52.593]  - attr(*, "total_size")= num NA
[17:43:52.596]  - Getting '...' globals ... DONE
[17:43:52.596] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.596] List of 2
[17:43:52.596]  $ ...future.FUN:function (object, ...)  
[17:43:52.596]  $ ...          :List of 1
[17:43:52.596]   ..$ digits: int 2
[17:43:52.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.596]  - attr(*, "where")=List of 2
[17:43:52.596]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.596]   ..$ ...          :<environment: 0x55d6ba013e38> 
[17:43:52.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.596]  - attr(*, "resolved")= logi FALSE
[17:43:52.596]  - attr(*, "total_size")= num 1296
[17:43:52.599] Packages to be attached in all futures: [n=0] 
[17:43:52.599] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.599] Number of futures (= number of chunks): 1
[17:43:52.599] Launching 1 futures (chunks) ...
[17:43:52.599] Chunk #1 of 1 ...
[17:43:52.599]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.599] getGlobalsAndPackages() ...
[17:43:52.599] Searching for globals...
[17:43:52.600] 
[17:43:52.600] Searching for globals ... DONE
[17:43:52.600] - globals: [0] <none>
[17:43:52.600] getGlobalsAndPackages() ... DONE
[17:43:52.600]    + additional globals found: [n=0] 
[17:43:52.600]    + additional namespaces needed: [n=0] 
[17:43:52.600]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.600]  - seeds: <none>
[17:43:52.600]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.601] getGlobalsAndPackages() ...
[17:43:52.601] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.601] Resolving globals: FALSE
[17:43:52.601] Tweak future expression to call with '...' arguments ...
[17:43:52.601] {
[17:43:52.601]     do.call(function(...) {
[17:43:52.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.601]             on.exit(options(oopts), add = TRUE)
[17:43:52.601]         }
[17:43:52.601]         {
[17:43:52.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.601]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.601]             })
[17:43:52.601]         }
[17:43:52.601]     }, args = future.call.arguments)
[17:43:52.601] }
[17:43:52.601] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.601] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.602] 
[17:43:52.602] getGlobalsAndPackages() ... DONE
[17:43:52.602] run() for ‘Future’ ...
[17:43:52.602] - state: ‘created’
[17:43:52.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.605] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.606]   - Field: ‘label’
[17:43:52.606]   - Field: ‘local’
[17:43:52.606]   - Field: ‘owner’
[17:43:52.606]   - Field: ‘envir’
[17:43:52.606]   - Field: ‘packages’
[17:43:52.606]   - Field: ‘gc’
[17:43:52.607]   - Field: ‘conditions’
[17:43:52.607]   - Field: ‘expr’
[17:43:52.608]   - Field: ‘uuid’
[17:43:52.608]   - Field: ‘seed’
[17:43:52.608]   - Field: ‘version’
[17:43:52.608]   - Field: ‘result’
[17:43:52.608]   - Field: ‘asynchronous’
[17:43:52.608]   - Field: ‘calls’
[17:43:52.608]   - Field: ‘globals’
[17:43:52.608]   - Field: ‘stdout’
[17:43:52.608]   - Field: ‘earlySignal’
[17:43:52.608]   - Field: ‘lazy’
[17:43:52.608]   - Field: ‘state’
[17:43:52.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.609] - Launch lazy future ...
[17:43:52.609] Packages needed by the future expression (n = 0): <none>
[17:43:52.609] Packages needed by future strategies (n = 0): <none>
[17:43:52.609] {
[17:43:52.609]     {
[17:43:52.609]         {
[17:43:52.609]             ...future.startTime <- base::Sys.time()
[17:43:52.609]             {
[17:43:52.609]                 {
[17:43:52.609]                   {
[17:43:52.609]                     base::local({
[17:43:52.609]                       has_future <- base::requireNamespace("future", 
[17:43:52.609]                         quietly = TRUE)
[17:43:52.609]                       if (has_future) {
[17:43:52.609]                         ns <- base::getNamespace("future")
[17:43:52.609]                         version <- ns[[".package"]][["version"]]
[17:43:52.609]                         if (is.null(version)) 
[17:43:52.609]                           version <- utils::packageVersion("future")
[17:43:52.609]                       }
[17:43:52.609]                       else {
[17:43:52.609]                         version <- NULL
[17:43:52.609]                       }
[17:43:52.609]                       if (!has_future || version < "1.8.0") {
[17:43:52.609]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.609]                           "", base::R.version$version.string), 
[17:43:52.609]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.609]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.609]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.609]                             "release", "version")], collapse = " "), 
[17:43:52.609]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.609]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.609]                           info)
[17:43:52.609]                         info <- base::paste(info, collapse = "; ")
[17:43:52.609]                         if (!has_future) {
[17:43:52.609]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.609]                             info)
[17:43:52.609]                         }
[17:43:52.609]                         else {
[17:43:52.609]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.609]                             info, version)
[17:43:52.609]                         }
[17:43:52.609]                         base::stop(msg)
[17:43:52.609]                       }
[17:43:52.609]                     })
[17:43:52.609]                   }
[17:43:52.609]                   ...future.strategy.old <- future::plan("list")
[17:43:52.609]                   options(future.plan = NULL)
[17:43:52.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.609]                 }
[17:43:52.609]                 ...future.workdir <- getwd()
[17:43:52.609]             }
[17:43:52.609]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.609]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.609]         }
[17:43:52.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.609]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.609]             base::names(...future.oldOptions))
[17:43:52.609]     }
[17:43:52.609]     if (FALSE) {
[17:43:52.609]     }
[17:43:52.609]     else {
[17:43:52.609]         if (TRUE) {
[17:43:52.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.609]                 open = "w")
[17:43:52.609]         }
[17:43:52.609]         else {
[17:43:52.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.609]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.609]         }
[17:43:52.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.609]             base::sink(type = "output", split = FALSE)
[17:43:52.609]             base::close(...future.stdout)
[17:43:52.609]         }, add = TRUE)
[17:43:52.609]     }
[17:43:52.609]     ...future.frame <- base::sys.nframe()
[17:43:52.609]     ...future.conditions <- base::list()
[17:43:52.609]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.609]     if (FALSE) {
[17:43:52.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.609]     }
[17:43:52.609]     ...future.result <- base::tryCatch({
[17:43:52.609]         base::withCallingHandlers({
[17:43:52.609]             ...future.value <- base::withVisible(base::local({
[17:43:52.609]                 do.call(function(...) {
[17:43:52.609]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.609]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.609]                     ...future.globals.maxSize)) {
[17:43:52.609]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.609]                     on.exit(options(oopts), add = TRUE)
[17:43:52.609]                   }
[17:43:52.609]                   {
[17:43:52.609]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.609]                       FUN = function(jj) {
[17:43:52.609]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.609]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.609]                       })
[17:43:52.609]                   }
[17:43:52.609]                 }, args = future.call.arguments)
[17:43:52.609]             }))
[17:43:52.609]             future::FutureResult(value = ...future.value$value, 
[17:43:52.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.609]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.609]                     ...future.globalenv.names))
[17:43:52.609]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.609]         }, condition = base::local({
[17:43:52.609]             c <- base::c
[17:43:52.609]             inherits <- base::inherits
[17:43:52.609]             invokeRestart <- base::invokeRestart
[17:43:52.609]             length <- base::length
[17:43:52.609]             list <- base::list
[17:43:52.609]             seq.int <- base::seq.int
[17:43:52.609]             signalCondition <- base::signalCondition
[17:43:52.609]             sys.calls <- base::sys.calls
[17:43:52.609]             `[[` <- base::`[[`
[17:43:52.609]             `+` <- base::`+`
[17:43:52.609]             `<<-` <- base::`<<-`
[17:43:52.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.609]                   3L)]
[17:43:52.609]             }
[17:43:52.609]             function(cond) {
[17:43:52.609]                 is_error <- inherits(cond, "error")
[17:43:52.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.609]                   NULL)
[17:43:52.609]                 if (is_error) {
[17:43:52.609]                   sessionInformation <- function() {
[17:43:52.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.609]                       search = base::search(), system = base::Sys.info())
[17:43:52.609]                   }
[17:43:52.609]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.609]                     cond$call), session = sessionInformation(), 
[17:43:52.609]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.609]                   signalCondition(cond)
[17:43:52.609]                 }
[17:43:52.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.609]                 "immediateCondition"))) {
[17:43:52.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.609]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.609]                   if (TRUE && !signal) {
[17:43:52.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.609]                     {
[17:43:52.609]                       inherits <- base::inherits
[17:43:52.609]                       invokeRestart <- base::invokeRestart
[17:43:52.609]                       is.null <- base::is.null
[17:43:52.609]                       muffled <- FALSE
[17:43:52.609]                       if (inherits(cond, "message")) {
[17:43:52.609]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.609]                         if (muffled) 
[17:43:52.609]                           invokeRestart("muffleMessage")
[17:43:52.609]                       }
[17:43:52.609]                       else if (inherits(cond, "warning")) {
[17:43:52.609]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.609]                         if (muffled) 
[17:43:52.609]                           invokeRestart("muffleWarning")
[17:43:52.609]                       }
[17:43:52.609]                       else if (inherits(cond, "condition")) {
[17:43:52.609]                         if (!is.null(pattern)) {
[17:43:52.609]                           computeRestarts <- base::computeRestarts
[17:43:52.609]                           grepl <- base::grepl
[17:43:52.609]                           restarts <- computeRestarts(cond)
[17:43:52.609]                           for (restart in restarts) {
[17:43:52.609]                             name <- restart$name
[17:43:52.609]                             if (is.null(name)) 
[17:43:52.609]                               next
[17:43:52.609]                             if (!grepl(pattern, name)) 
[17:43:52.609]                               next
[17:43:52.609]                             invokeRestart(restart)
[17:43:52.609]                             muffled <- TRUE
[17:43:52.609]                             break
[17:43:52.609]                           }
[17:43:52.609]                         }
[17:43:52.609]                       }
[17:43:52.609]                       invisible(muffled)
[17:43:52.609]                     }
[17:43:52.609]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.609]                   }
[17:43:52.609]                 }
[17:43:52.609]                 else {
[17:43:52.609]                   if (TRUE) {
[17:43:52.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.609]                     {
[17:43:52.609]                       inherits <- base::inherits
[17:43:52.609]                       invokeRestart <- base::invokeRestart
[17:43:52.609]                       is.null <- base::is.null
[17:43:52.609]                       muffled <- FALSE
[17:43:52.609]                       if (inherits(cond, "message")) {
[17:43:52.609]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.609]                         if (muffled) 
[17:43:52.609]                           invokeRestart("muffleMessage")
[17:43:52.609]                       }
[17:43:52.609]                       else if (inherits(cond, "warning")) {
[17:43:52.609]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.609]                         if (muffled) 
[17:43:52.609]                           invokeRestart("muffleWarning")
[17:43:52.609]                       }
[17:43:52.609]                       else if (inherits(cond, "condition")) {
[17:43:52.609]                         if (!is.null(pattern)) {
[17:43:52.609]                           computeRestarts <- base::computeRestarts
[17:43:52.609]                           grepl <- base::grepl
[17:43:52.609]                           restarts <- computeRestarts(cond)
[17:43:52.609]                           for (restart in restarts) {
[17:43:52.609]                             name <- restart$name
[17:43:52.609]                             if (is.null(name)) 
[17:43:52.609]                               next
[17:43:52.609]                             if (!grepl(pattern, name)) 
[17:43:52.609]                               next
[17:43:52.609]                             invokeRestart(restart)
[17:43:52.609]                             muffled <- TRUE
[17:43:52.609]                             break
[17:43:52.609]                           }
[17:43:52.609]                         }
[17:43:52.609]                       }
[17:43:52.609]                       invisible(muffled)
[17:43:52.609]                     }
[17:43:52.609]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.609]                   }
[17:43:52.609]                 }
[17:43:52.609]             }
[17:43:52.609]         }))
[17:43:52.609]     }, error = function(ex) {
[17:43:52.609]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.609]                 ...future.rng), started = ...future.startTime, 
[17:43:52.609]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.609]             version = "1.8"), class = "FutureResult")
[17:43:52.609]     }, finally = {
[17:43:52.609]         if (!identical(...future.workdir, getwd())) 
[17:43:52.609]             setwd(...future.workdir)
[17:43:52.609]         {
[17:43:52.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.609]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.609]             }
[17:43:52.609]             base::options(...future.oldOptions)
[17:43:52.609]             if (.Platform$OS.type == "windows") {
[17:43:52.609]                 old_names <- names(...future.oldEnvVars)
[17:43:52.609]                 envs <- base::Sys.getenv()
[17:43:52.609]                 names <- names(envs)
[17:43:52.609]                 common <- intersect(names, old_names)
[17:43:52.609]                 added <- setdiff(names, old_names)
[17:43:52.609]                 removed <- setdiff(old_names, names)
[17:43:52.609]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.609]                   envs[common]]
[17:43:52.609]                 NAMES <- toupper(changed)
[17:43:52.609]                 args <- list()
[17:43:52.609]                 for (kk in seq_along(NAMES)) {
[17:43:52.609]                   name <- changed[[kk]]
[17:43:52.609]                   NAME <- NAMES[[kk]]
[17:43:52.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.609]                     next
[17:43:52.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.609]                 }
[17:43:52.609]                 NAMES <- toupper(added)
[17:43:52.609]                 for (kk in seq_along(NAMES)) {
[17:43:52.609]                   name <- added[[kk]]
[17:43:52.609]                   NAME <- NAMES[[kk]]
[17:43:52.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.609]                     next
[17:43:52.609]                   args[[name]] <- ""
[17:43:52.609]                 }
[17:43:52.609]                 NAMES <- toupper(removed)
[17:43:52.609]                 for (kk in seq_along(NAMES)) {
[17:43:52.609]                   name <- removed[[kk]]
[17:43:52.609]                   NAME <- NAMES[[kk]]
[17:43:52.609]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.609]                     next
[17:43:52.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.609]                 }
[17:43:52.609]                 if (length(args) > 0) 
[17:43:52.609]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.609]             }
[17:43:52.609]             else {
[17:43:52.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.609]             }
[17:43:52.609]             {
[17:43:52.609]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.609]                   0L) {
[17:43:52.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.609]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.609]                   base::options(opts)
[17:43:52.609]                 }
[17:43:52.609]                 {
[17:43:52.609]                   {
[17:43:52.609]                     NULL
[17:43:52.609]                     RNGkind("Mersenne-Twister")
[17:43:52.609]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.609]                       inherits = FALSE)
[17:43:52.609]                   }
[17:43:52.609]                   options(future.plan = NULL)
[17:43:52.609]                   if (is.na(NA_character_)) 
[17:43:52.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.609]                     .init = FALSE)
[17:43:52.609]                 }
[17:43:52.609]             }
[17:43:52.609]         }
[17:43:52.609]     })
[17:43:52.609]     if (TRUE) {
[17:43:52.609]         base::sink(type = "output", split = FALSE)
[17:43:52.609]         if (TRUE) {
[17:43:52.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.609]         }
[17:43:52.609]         else {
[17:43:52.609]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.609]         }
[17:43:52.609]         base::close(...future.stdout)
[17:43:52.609]         ...future.stdout <- NULL
[17:43:52.609]     }
[17:43:52.609]     ...future.result$conditions <- ...future.conditions
[17:43:52.609]     ...future.result$finished <- base::Sys.time()
[17:43:52.609]     ...future.result
[17:43:52.609] }
[17:43:52.611] assign_globals() ...
[17:43:52.611] List of 5
[17:43:52.611]  $ ...future.FUN            :function (object, ...)  
[17:43:52.611]  $ future.call.arguments    :List of 1
[17:43:52.611]   ..$ digits: int 2
[17:43:52.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.611]  $ ...future.elements_ii    :List of 6
[17:43:52.611]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:43:52.611]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:43:52.611]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:43:52.611]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:43:52.611]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:43:52.611]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:43:52.611]  $ ...future.seeds_ii       : NULL
[17:43:52.611]  $ ...future.globals.maxSize: NULL
[17:43:52.611]  - attr(*, "where")=List of 5
[17:43:52.611]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.611]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.611]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.611]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.611]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.611]  - attr(*, "resolved")= logi FALSE
[17:43:52.611]  - attr(*, "total_size")= num 1296
[17:43:52.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.611]  - attr(*, "already-done")= logi TRUE
[17:43:52.617] - copied ‘...future.FUN’ to environment
[17:43:52.618] - copied ‘future.call.arguments’ to environment
[17:43:52.618] - copied ‘...future.elements_ii’ to environment
[17:43:52.618] - copied ‘...future.seeds_ii’ to environment
[17:43:52.618] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.618] assign_globals() ... done
[17:43:52.618] plan(): Setting new future strategy stack:
[17:43:52.618] List of future strategies:
[17:43:52.618] 1. sequential:
[17:43:52.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.618]    - tweaked: FALSE
[17:43:52.618]    - call: NULL
[17:43:52.619] plan(): nbrOfWorkers() = 1
[17:43:52.620] plan(): Setting new future strategy stack:
[17:43:52.620] List of future strategies:
[17:43:52.620] 1. multisession:
[17:43:52.620]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.620]    - tweaked: FALSE
[17:43:52.620]    - call: plan(strategy)
[17:43:52.623] plan(): nbrOfWorkers() = 1
[17:43:52.624] SequentialFuture started (and completed)
[17:43:52.624] - Launch lazy future ... done
[17:43:52.624] run() for ‘SequentialFuture’ ... done
[17:43:52.624] Created future:
[17:43:52.624] SequentialFuture:
[17:43:52.624] Label: ‘future_by-1’
[17:43:52.624] Expression:
[17:43:52.624] {
[17:43:52.624]     do.call(function(...) {
[17:43:52.624]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.624]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.624]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.624]             on.exit(options(oopts), add = TRUE)
[17:43:52.624]         }
[17:43:52.624]         {
[17:43:52.624]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.624]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.624]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.624]             })
[17:43:52.624]         }
[17:43:52.624]     }, args = future.call.arguments)
[17:43:52.624] }
[17:43:52.624] Lazy evaluation: FALSE
[17:43:52.624] Asynchronous evaluation: FALSE
[17:43:52.624] Local evaluation: TRUE
[17:43:52.624] Environment: R_GlobalEnv
[17:43:52.624] Capture standard output: TRUE
[17:43:52.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.624] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.624] Packages: <none>
[17:43:52.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.624] Resolved: TRUE
[17:43:52.624] Value: 5.48 KiB of class ‘list’
[17:43:52.624] Early signaling: FALSE
[17:43:52.624] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.624] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.625] Chunk #1 of 1 ... DONE
[17:43:52.625] Launching 1 futures (chunks) ... DONE
[17:43:52.625] Resolving 1 futures (chunks) ...
[17:43:52.625] resolve() on list ...
[17:43:52.625]  recursive: 0
[17:43:52.625]  length: 1
[17:43:52.626] 
[17:43:52.626] resolved() for ‘SequentialFuture’ ...
[17:43:52.626] - state: ‘finished’
[17:43:52.626] - run: TRUE
[17:43:52.626] - result: ‘FutureResult’
[17:43:52.626] resolved() for ‘SequentialFuture’ ... done
[17:43:52.626] Future #1
[17:43:52.626] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.626] - nx: 1
[17:43:52.626] - relay: TRUE
[17:43:52.626] - stdout: TRUE
[17:43:52.627] - signal: TRUE
[17:43:52.627] - resignal: FALSE
[17:43:52.627] - force: TRUE
[17:43:52.627] - relayed: [n=1] FALSE
[17:43:52.627] - queued futures: [n=1] FALSE
[17:43:52.627]  - until=1
[17:43:52.627]  - relaying element #1
[17:43:52.627] - relayed: [n=1] TRUE
[17:43:52.627] - queued futures: [n=1] TRUE
[17:43:52.627] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.628]  length: 0 (resolved future 1)
[17:43:52.628] Relaying remaining futures
[17:43:52.628] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.628] - nx: 1
[17:43:52.628] - relay: TRUE
[17:43:52.628] - stdout: TRUE
[17:43:52.628] - signal: TRUE
[17:43:52.628] - resignal: FALSE
[17:43:52.628] - force: TRUE
[17:43:52.628] - relayed: [n=1] TRUE
[17:43:52.628] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.628] - relayed: [n=1] TRUE
[17:43:52.629] - queued futures: [n=1] TRUE
[17:43:52.629] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.629] resolve() on list ... DONE
[17:43:52.629]  - Number of value chunks collected: 1
[17:43:52.629] Resolving 1 futures (chunks) ... DONE
[17:43:52.629] Reducing values from 1 chunks ...
[17:43:52.629]  - Number of values collected after concatenation: 6
[17:43:52.629]  - Number of values expected: 6
[17:43:52.629] Reducing values from 1 chunks ... DONE
[17:43:52.629] future_lapply() ... DONE
[17:43:52.629] future_by_internal() ... DONE
[17:43:52.630] future_by_internal() ...
[17:43:52.632] future_lapply() ...
[17:43:52.636] Number of chunks: 1
[17:43:52.636] getGlobalsAndPackagesXApply() ...
[17:43:52.636]  - future.globals: TRUE
[17:43:52.636] getGlobalsAndPackages() ...
[17:43:52.636] Searching for globals...
[17:43:52.638] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.638] Searching for globals ... DONE
[17:43:52.638] Resolving globals: FALSE
[17:43:52.638] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:43:52.639] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:43:52.639] - globals: [1] ‘FUN’
[17:43:52.639] - packages: [1] ‘stats’
[17:43:52.639] getGlobalsAndPackages() ... DONE
[17:43:52.639]  - globals found/used: [n=1] ‘FUN’
[17:43:52.639]  - needed namespaces: [n=1] ‘stats’
[17:43:52.640] Finding globals ... DONE
[17:43:52.640]  - use_args: TRUE
[17:43:52.640]  - Getting '...' globals ...
[17:43:52.640] resolve() on list ...
[17:43:52.640]  recursive: 0
[17:43:52.640]  length: 1
[17:43:52.640]  elements: ‘...’
[17:43:52.640]  length: 0 (resolved future 1)
[17:43:52.640] resolve() on list ... DONE
[17:43:52.641]    - '...' content: [n=1] ‘singular.ok’
[17:43:52.641] List of 1
[17:43:52.641]  $ ...:List of 1
[17:43:52.641]   ..$ singular.ok: logi FALSE
[17:43:52.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.641]  - attr(*, "where")=List of 1
[17:43:52.641]   ..$ ...:<environment: 0x55d6bae1b280> 
[17:43:52.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.641]  - attr(*, "resolved")= logi TRUE
[17:43:52.641]  - attr(*, "total_size")= num NA
[17:43:52.643]  - Getting '...' globals ... DONE
[17:43:52.644] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.644] List of 2
[17:43:52.644]  $ ...future.FUN:function (x, ...)  
[17:43:52.644]  $ ...          :List of 1
[17:43:52.644]   ..$ singular.ok: logi FALSE
[17:43:52.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.644]  - attr(*, "where")=List of 2
[17:43:52.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.644]   ..$ ...          :<environment: 0x55d6bae1b280> 
[17:43:52.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.644]  - attr(*, "resolved")= logi FALSE
[17:43:52.644]  - attr(*, "total_size")= num 5384
[17:43:52.646] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.647] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.647] Number of futures (= number of chunks): 1
[17:43:52.647] Launching 1 futures (chunks) ...
[17:43:52.647] Chunk #1 of 1 ...
[17:43:52.647]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.647] getGlobalsAndPackages() ...
[17:43:52.647] Searching for globals...
[17:43:52.648] 
[17:43:52.648] Searching for globals ... DONE
[17:43:52.648] - globals: [0] <none>
[17:43:52.648] getGlobalsAndPackages() ... DONE
[17:43:52.648]    + additional globals found: [n=0] 
[17:43:52.648]    + additional namespaces needed: [n=0] 
[17:43:52.648]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.648]  - seeds: <none>
[17:43:52.649]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.649] getGlobalsAndPackages() ...
[17:43:52.649] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.649] Resolving globals: FALSE
[17:43:52.649] Tweak future expression to call with '...' arguments ...
[17:43:52.649] {
[17:43:52.649]     do.call(function(...) {
[17:43:52.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.649]             on.exit(options(oopts), add = TRUE)
[17:43:52.649]         }
[17:43:52.649]         {
[17:43:52.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.649]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.649]             })
[17:43:52.649]         }
[17:43:52.649]     }, args = future.call.arguments)
[17:43:52.649] }
[17:43:52.649] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.650] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.650] 
[17:43:52.650] getGlobalsAndPackages() ... DONE
[17:43:52.650] run() for ‘Future’ ...
[17:43:52.650] - state: ‘created’
[17:43:52.650] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.654] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.654]   - Field: ‘label’
[17:43:52.654]   - Field: ‘local’
[17:43:52.654]   - Field: ‘owner’
[17:43:52.654]   - Field: ‘envir’
[17:43:52.654]   - Field: ‘packages’
[17:43:52.654]   - Field: ‘gc’
[17:43:52.654]   - Field: ‘conditions’
[17:43:52.654]   - Field: ‘expr’
[17:43:52.655]   - Field: ‘uuid’
[17:43:52.655]   - Field: ‘seed’
[17:43:52.655]   - Field: ‘version’
[17:43:52.655]   - Field: ‘result’
[17:43:52.655]   - Field: ‘asynchronous’
[17:43:52.655]   - Field: ‘calls’
[17:43:52.655]   - Field: ‘globals’
[17:43:52.655]   - Field: ‘stdout’
[17:43:52.655]   - Field: ‘earlySignal’
[17:43:52.655]   - Field: ‘lazy’
[17:43:52.655]   - Field: ‘state’
[17:43:52.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.656] - Launch lazy future ...
[17:43:52.656] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.656] Packages needed by future strategies (n = 0): <none>
[17:43:52.658] {
[17:43:52.658]     {
[17:43:52.658]         {
[17:43:52.658]             ...future.startTime <- base::Sys.time()
[17:43:52.658]             {
[17:43:52.658]                 {
[17:43:52.658]                   {
[17:43:52.658]                     {
[17:43:52.658]                       base::local({
[17:43:52.658]                         has_future <- base::requireNamespace("future", 
[17:43:52.658]                           quietly = TRUE)
[17:43:52.658]                         if (has_future) {
[17:43:52.658]                           ns <- base::getNamespace("future")
[17:43:52.658]                           version <- ns[[".package"]][["version"]]
[17:43:52.658]                           if (is.null(version)) 
[17:43:52.658]                             version <- utils::packageVersion("future")
[17:43:52.658]                         }
[17:43:52.658]                         else {
[17:43:52.658]                           version <- NULL
[17:43:52.658]                         }
[17:43:52.658]                         if (!has_future || version < "1.8.0") {
[17:43:52.658]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.658]                             "", base::R.version$version.string), 
[17:43:52.658]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.658]                               "release", "version")], collapse = " "), 
[17:43:52.658]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.658]                             info)
[17:43:52.658]                           info <- base::paste(info, collapse = "; ")
[17:43:52.658]                           if (!has_future) {
[17:43:52.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.658]                               info)
[17:43:52.658]                           }
[17:43:52.658]                           else {
[17:43:52.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.658]                               info, version)
[17:43:52.658]                           }
[17:43:52.658]                           base::stop(msg)
[17:43:52.658]                         }
[17:43:52.658]                       })
[17:43:52.658]                     }
[17:43:52.658]                     base::local({
[17:43:52.658]                       for (pkg in "stats") {
[17:43:52.658]                         base::loadNamespace(pkg)
[17:43:52.658]                         base::library(pkg, character.only = TRUE)
[17:43:52.658]                       }
[17:43:52.658]                     })
[17:43:52.658]                   }
[17:43:52.658]                   ...future.strategy.old <- future::plan("list")
[17:43:52.658]                   options(future.plan = NULL)
[17:43:52.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.658]                 }
[17:43:52.658]                 ...future.workdir <- getwd()
[17:43:52.658]             }
[17:43:52.658]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.658]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.658]         }
[17:43:52.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.658]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.658]             base::names(...future.oldOptions))
[17:43:52.658]     }
[17:43:52.658]     if (FALSE) {
[17:43:52.658]     }
[17:43:52.658]     else {
[17:43:52.658]         if (TRUE) {
[17:43:52.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.658]                 open = "w")
[17:43:52.658]         }
[17:43:52.658]         else {
[17:43:52.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.658]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.658]         }
[17:43:52.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.658]             base::sink(type = "output", split = FALSE)
[17:43:52.658]             base::close(...future.stdout)
[17:43:52.658]         }, add = TRUE)
[17:43:52.658]     }
[17:43:52.658]     ...future.frame <- base::sys.nframe()
[17:43:52.658]     ...future.conditions <- base::list()
[17:43:52.658]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.658]     if (FALSE) {
[17:43:52.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.658]     }
[17:43:52.658]     ...future.result <- base::tryCatch({
[17:43:52.658]         base::withCallingHandlers({
[17:43:52.658]             ...future.value <- base::withVisible(base::local({
[17:43:52.658]                 do.call(function(...) {
[17:43:52.658]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.658]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.658]                     ...future.globals.maxSize)) {
[17:43:52.658]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.658]                     on.exit(options(oopts), add = TRUE)
[17:43:52.658]                   }
[17:43:52.658]                   {
[17:43:52.658]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.658]                       FUN = function(jj) {
[17:43:52.658]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.658]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.658]                       })
[17:43:52.658]                   }
[17:43:52.658]                 }, args = future.call.arguments)
[17:43:52.658]             }))
[17:43:52.658]             future::FutureResult(value = ...future.value$value, 
[17:43:52.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.658]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.658]                     ...future.globalenv.names))
[17:43:52.658]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.658]         }, condition = base::local({
[17:43:52.658]             c <- base::c
[17:43:52.658]             inherits <- base::inherits
[17:43:52.658]             invokeRestart <- base::invokeRestart
[17:43:52.658]             length <- base::length
[17:43:52.658]             list <- base::list
[17:43:52.658]             seq.int <- base::seq.int
[17:43:52.658]             signalCondition <- base::signalCondition
[17:43:52.658]             sys.calls <- base::sys.calls
[17:43:52.658]             `[[` <- base::`[[`
[17:43:52.658]             `+` <- base::`+`
[17:43:52.658]             `<<-` <- base::`<<-`
[17:43:52.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.658]                   3L)]
[17:43:52.658]             }
[17:43:52.658]             function(cond) {
[17:43:52.658]                 is_error <- inherits(cond, "error")
[17:43:52.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.658]                   NULL)
[17:43:52.658]                 if (is_error) {
[17:43:52.658]                   sessionInformation <- function() {
[17:43:52.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.658]                       search = base::search(), system = base::Sys.info())
[17:43:52.658]                   }
[17:43:52.658]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.658]                     cond$call), session = sessionInformation(), 
[17:43:52.658]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.658]                   signalCondition(cond)
[17:43:52.658]                 }
[17:43:52.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.658]                 "immediateCondition"))) {
[17:43:52.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.658]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.658]                   if (TRUE && !signal) {
[17:43:52.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.658]                     {
[17:43:52.658]                       inherits <- base::inherits
[17:43:52.658]                       invokeRestart <- base::invokeRestart
[17:43:52.658]                       is.null <- base::is.null
[17:43:52.658]                       muffled <- FALSE
[17:43:52.658]                       if (inherits(cond, "message")) {
[17:43:52.658]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.658]                         if (muffled) 
[17:43:52.658]                           invokeRestart("muffleMessage")
[17:43:52.658]                       }
[17:43:52.658]                       else if (inherits(cond, "warning")) {
[17:43:52.658]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.658]                         if (muffled) 
[17:43:52.658]                           invokeRestart("muffleWarning")
[17:43:52.658]                       }
[17:43:52.658]                       else if (inherits(cond, "condition")) {
[17:43:52.658]                         if (!is.null(pattern)) {
[17:43:52.658]                           computeRestarts <- base::computeRestarts
[17:43:52.658]                           grepl <- base::grepl
[17:43:52.658]                           restarts <- computeRestarts(cond)
[17:43:52.658]                           for (restart in restarts) {
[17:43:52.658]                             name <- restart$name
[17:43:52.658]                             if (is.null(name)) 
[17:43:52.658]                               next
[17:43:52.658]                             if (!grepl(pattern, name)) 
[17:43:52.658]                               next
[17:43:52.658]                             invokeRestart(restart)
[17:43:52.658]                             muffled <- TRUE
[17:43:52.658]                             break
[17:43:52.658]                           }
[17:43:52.658]                         }
[17:43:52.658]                       }
[17:43:52.658]                       invisible(muffled)
[17:43:52.658]                     }
[17:43:52.658]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.658]                   }
[17:43:52.658]                 }
[17:43:52.658]                 else {
[17:43:52.658]                   if (TRUE) {
[17:43:52.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.658]                     {
[17:43:52.658]                       inherits <- base::inherits
[17:43:52.658]                       invokeRestart <- base::invokeRestart
[17:43:52.658]                       is.null <- base::is.null
[17:43:52.658]                       muffled <- FALSE
[17:43:52.658]                       if (inherits(cond, "message")) {
[17:43:52.658]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.658]                         if (muffled) 
[17:43:52.658]                           invokeRestart("muffleMessage")
[17:43:52.658]                       }
[17:43:52.658]                       else if (inherits(cond, "warning")) {
[17:43:52.658]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.658]                         if (muffled) 
[17:43:52.658]                           invokeRestart("muffleWarning")
[17:43:52.658]                       }
[17:43:52.658]                       else if (inherits(cond, "condition")) {
[17:43:52.658]                         if (!is.null(pattern)) {
[17:43:52.658]                           computeRestarts <- base::computeRestarts
[17:43:52.658]                           grepl <- base::grepl
[17:43:52.658]                           restarts <- computeRestarts(cond)
[17:43:52.658]                           for (restart in restarts) {
[17:43:52.658]                             name <- restart$name
[17:43:52.658]                             if (is.null(name)) 
[17:43:52.658]                               next
[17:43:52.658]                             if (!grepl(pattern, name)) 
[17:43:52.658]                               next
[17:43:52.658]                             invokeRestart(restart)
[17:43:52.658]                             muffled <- TRUE
[17:43:52.658]                             break
[17:43:52.658]                           }
[17:43:52.658]                         }
[17:43:52.658]                       }
[17:43:52.658]                       invisible(muffled)
[17:43:52.658]                     }
[17:43:52.658]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.658]                   }
[17:43:52.658]                 }
[17:43:52.658]             }
[17:43:52.658]         }))
[17:43:52.658]     }, error = function(ex) {
[17:43:52.658]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.658]                 ...future.rng), started = ...future.startTime, 
[17:43:52.658]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.658]             version = "1.8"), class = "FutureResult")
[17:43:52.658]     }, finally = {
[17:43:52.658]         if (!identical(...future.workdir, getwd())) 
[17:43:52.658]             setwd(...future.workdir)
[17:43:52.658]         {
[17:43:52.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.658]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.658]             }
[17:43:52.658]             base::options(...future.oldOptions)
[17:43:52.658]             if (.Platform$OS.type == "windows") {
[17:43:52.658]                 old_names <- names(...future.oldEnvVars)
[17:43:52.658]                 envs <- base::Sys.getenv()
[17:43:52.658]                 names <- names(envs)
[17:43:52.658]                 common <- intersect(names, old_names)
[17:43:52.658]                 added <- setdiff(names, old_names)
[17:43:52.658]                 removed <- setdiff(old_names, names)
[17:43:52.658]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.658]                   envs[common]]
[17:43:52.658]                 NAMES <- toupper(changed)
[17:43:52.658]                 args <- list()
[17:43:52.658]                 for (kk in seq_along(NAMES)) {
[17:43:52.658]                   name <- changed[[kk]]
[17:43:52.658]                   NAME <- NAMES[[kk]]
[17:43:52.658]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.658]                     next
[17:43:52.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.658]                 }
[17:43:52.658]                 NAMES <- toupper(added)
[17:43:52.658]                 for (kk in seq_along(NAMES)) {
[17:43:52.658]                   name <- added[[kk]]
[17:43:52.658]                   NAME <- NAMES[[kk]]
[17:43:52.658]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.658]                     next
[17:43:52.658]                   args[[name]] <- ""
[17:43:52.658]                 }
[17:43:52.658]                 NAMES <- toupper(removed)
[17:43:52.658]                 for (kk in seq_along(NAMES)) {
[17:43:52.658]                   name <- removed[[kk]]
[17:43:52.658]                   NAME <- NAMES[[kk]]
[17:43:52.658]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.658]                     next
[17:43:52.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.658]                 }
[17:43:52.658]                 if (length(args) > 0) 
[17:43:52.658]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.658]             }
[17:43:52.658]             else {
[17:43:52.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.658]             }
[17:43:52.658]             {
[17:43:52.658]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.658]                   0L) {
[17:43:52.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.658]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.658]                   base::options(opts)
[17:43:52.658]                 }
[17:43:52.658]                 {
[17:43:52.658]                   {
[17:43:52.658]                     NULL
[17:43:52.658]                     RNGkind("Mersenne-Twister")
[17:43:52.658]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.658]                       inherits = FALSE)
[17:43:52.658]                   }
[17:43:52.658]                   options(future.plan = NULL)
[17:43:52.658]                   if (is.na(NA_character_)) 
[17:43:52.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.658]                     .init = FALSE)
[17:43:52.658]                 }
[17:43:52.658]             }
[17:43:52.658]         }
[17:43:52.658]     })
[17:43:52.658]     if (TRUE) {
[17:43:52.658]         base::sink(type = "output", split = FALSE)
[17:43:52.658]         if (TRUE) {
[17:43:52.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.658]         }
[17:43:52.658]         else {
[17:43:52.658]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.658]         }
[17:43:52.658]         base::close(...future.stdout)
[17:43:52.658]         ...future.stdout <- NULL
[17:43:52.658]     }
[17:43:52.658]     ...future.result$conditions <- ...future.conditions
[17:43:52.658]     ...future.result$finished <- base::Sys.time()
[17:43:52.658]     ...future.result
[17:43:52.658] }
[17:43:52.659] assign_globals() ...
[17:43:52.659] List of 5
[17:43:52.659]  $ ...future.FUN            :function (x, ...)  
[17:43:52.659]  $ future.call.arguments    :List of 1
[17:43:52.659]   ..$ singular.ok: logi FALSE
[17:43:52.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.659]  $ ...future.elements_ii    :List of 3
[17:43:52.659]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.659]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.659]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.659]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.659]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.659]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.659]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.659]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.659]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.659]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.659]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.659]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.659]  $ ...future.seeds_ii       : NULL
[17:43:52.659]  $ ...future.globals.maxSize: NULL
[17:43:52.659]  - attr(*, "where")=List of 5
[17:43:52.659]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.659]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.659]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.659]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.659]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.659]  - attr(*, "resolved")= logi FALSE
[17:43:52.659]  - attr(*, "total_size")= num 5384
[17:43:52.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.659]  - attr(*, "already-done")= logi TRUE
[17:43:52.668] - reassign environment for ‘...future.FUN’
[17:43:52.668] - copied ‘...future.FUN’ to environment
[17:43:52.668] - copied ‘future.call.arguments’ to environment
[17:43:52.668] - copied ‘...future.elements_ii’ to environment
[17:43:52.668] - copied ‘...future.seeds_ii’ to environment
[17:43:52.668] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.668] assign_globals() ... done
[17:43:52.669] plan(): Setting new future strategy stack:
[17:43:52.669] List of future strategies:
[17:43:52.669] 1. sequential:
[17:43:52.669]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.669]    - tweaked: FALSE
[17:43:52.669]    - call: NULL
[17:43:52.669] plan(): nbrOfWorkers() = 1
[17:43:52.672] plan(): Setting new future strategy stack:
[17:43:52.672] List of future strategies:
[17:43:52.672] 1. multisession:
[17:43:52.672]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.672]    - tweaked: FALSE
[17:43:52.672]    - call: plan(strategy)
[17:43:52.676] plan(): nbrOfWorkers() = 1
[17:43:52.676] SequentialFuture started (and completed)
[17:43:52.676] - Launch lazy future ... done
[17:43:52.676] run() for ‘SequentialFuture’ ... done
[17:43:52.677] Created future:
[17:43:52.677] SequentialFuture:
[17:43:52.677] Label: ‘future_by-1’
[17:43:52.677] Expression:
[17:43:52.677] {
[17:43:52.677]     do.call(function(...) {
[17:43:52.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.677]             on.exit(options(oopts), add = TRUE)
[17:43:52.677]         }
[17:43:52.677]         {
[17:43:52.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.677]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.677]             })
[17:43:52.677]         }
[17:43:52.677]     }, args = future.call.arguments)
[17:43:52.677] }
[17:43:52.677] Lazy evaluation: FALSE
[17:43:52.677] Asynchronous evaluation: FALSE
[17:43:52.677] Local evaluation: TRUE
[17:43:52.677] Environment: R_GlobalEnv
[17:43:52.677] Capture standard output: TRUE
[17:43:52.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.677] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.677] Packages: 1 packages (‘stats’)
[17:43:52.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.677] Resolved: TRUE
[17:43:52.677] Value: 26.06 KiB of class ‘list’
[17:43:52.677] Early signaling: FALSE
[17:43:52.677] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.677] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.678] Chunk #1 of 1 ... DONE
[17:43:52.678] Launching 1 futures (chunks) ... DONE
[17:43:52.679] Resolving 1 futures (chunks) ...
[17:43:52.679] resolve() on list ...
[17:43:52.679]  recursive: 0
[17:43:52.679]  length: 1
[17:43:52.679] 
[17:43:52.679] resolved() for ‘SequentialFuture’ ...
[17:43:52.679] - state: ‘finished’
[17:43:52.679] - run: TRUE
[17:43:52.679] - result: ‘FutureResult’
[17:43:52.679] resolved() for ‘SequentialFuture’ ... done
[17:43:52.680] Future #1
[17:43:52.680] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.680] - nx: 1
[17:43:52.680] - relay: TRUE
[17:43:52.680] - stdout: TRUE
[17:43:52.680] - signal: TRUE
[17:43:52.680] - resignal: FALSE
[17:43:52.680] - force: TRUE
[17:43:52.680] - relayed: [n=1] FALSE
[17:43:52.680] - queued futures: [n=1] FALSE
[17:43:52.680]  - until=1
[17:43:52.681]  - relaying element #1
[17:43:52.681] - relayed: [n=1] TRUE
[17:43:52.681] - queued futures: [n=1] TRUE
[17:43:52.681] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.681]  length: 0 (resolved future 1)
[17:43:52.681] Relaying remaining futures
[17:43:52.681] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.681] - nx: 1
[17:43:52.681] - relay: TRUE
[17:43:52.683] - stdout: TRUE
[17:43:52.683] - signal: TRUE
[17:43:52.683] - resignal: FALSE
[17:43:52.683] - force: TRUE
[17:43:52.684] - relayed: [n=1] TRUE
[17:43:52.684] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.684] - relayed: [n=1] TRUE
[17:43:52.684] - queued futures: [n=1] TRUE
[17:43:52.684] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.684] resolve() on list ... DONE
[17:43:52.684]  - Number of value chunks collected: 1
[17:43:52.684] Resolving 1 futures (chunks) ... DONE
[17:43:52.685] Reducing values from 1 chunks ...
[17:43:52.685]  - Number of values collected after concatenation: 3
[17:43:52.685]  - Number of values expected: 3
[17:43:52.685] Reducing values from 1 chunks ... DONE
[17:43:52.685] future_lapply() ... DONE
[17:43:52.685] future_by_internal() ... DONE
[17:43:52.689] future_by_internal() ...
[17:43:52.690] future_lapply() ...
[17:43:52.693] Number of chunks: 1
[17:43:52.694] getGlobalsAndPackagesXApply() ...
[17:43:52.694]  - future.globals: TRUE
[17:43:52.694] getGlobalsAndPackages() ...
[17:43:52.694] Searching for globals...
[17:43:52.696] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.696] Searching for globals ... DONE
[17:43:52.696] Resolving globals: FALSE
[17:43:52.696] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:43:52.697] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:43:52.697] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.697] - packages: [1] ‘stats’
[17:43:52.697] getGlobalsAndPackages() ... DONE
[17:43:52.697]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.697]  - needed namespaces: [n=1] ‘stats’
[17:43:52.697] Finding globals ... DONE
[17:43:52.697]  - use_args: TRUE
[17:43:52.697]  - Getting '...' globals ...
[17:43:52.698] resolve() on list ...
[17:43:52.698]  recursive: 0
[17:43:52.698]  length: 1
[17:43:52.698]  elements: ‘...’
[17:43:52.698]  length: 0 (resolved future 1)
[17:43:52.698] resolve() on list ... DONE
[17:43:52.698]    - '...' content: [n=0] 
[17:43:52.698] List of 1
[17:43:52.698]  $ ...: list()
[17:43:52.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.698]  - attr(*, "where")=List of 1
[17:43:52.698]   ..$ ...:<environment: 0x55d6b94274f8> 
[17:43:52.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.698]  - attr(*, "resolved")= logi TRUE
[17:43:52.698]  - attr(*, "total_size")= num NA
[17:43:52.701]  - Getting '...' globals ... DONE
[17:43:52.701] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:43:52.701] List of 4
[17:43:52.701]  $ ...future.FUN:function (x)  
[17:43:52.701]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.701]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.701]  $ ...          : list()
[17:43:52.701]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.701]  - attr(*, "where")=List of 4
[17:43:52.701]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.701]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:43:52.701]   ..$ wool         :<environment: R_EmptyEnv> 
[17:43:52.701]   ..$ ...          :<environment: 0x55d6b94274f8> 
[17:43:52.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.701]  - attr(*, "resolved")= logi FALSE
[17:43:52.701]  - attr(*, "total_size")= num 2320
[17:43:52.706] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.706] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.707] Number of futures (= number of chunks): 1
[17:43:52.707] Launching 1 futures (chunks) ...
[17:43:52.707] Chunk #1 of 1 ...
[17:43:52.707]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.707] getGlobalsAndPackages() ...
[17:43:52.707] Searching for globals...
[17:43:52.708] 
[17:43:52.708] Searching for globals ... DONE
[17:43:52.708] - globals: [0] <none>
[17:43:52.708] getGlobalsAndPackages() ... DONE
[17:43:52.708]    + additional globals found: [n=0] 
[17:43:52.708]    + additional namespaces needed: [n=0] 
[17:43:52.708]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.708]  - seeds: <none>
[17:43:52.708]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.709] getGlobalsAndPackages() ...
[17:43:52.709] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.709] Resolving globals: FALSE
[17:43:52.709] Tweak future expression to call with '...' arguments ...
[17:43:52.709] {
[17:43:52.709]     do.call(function(...) {
[17:43:52.709]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.709]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.709]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.709]             on.exit(options(oopts), add = TRUE)
[17:43:52.709]         }
[17:43:52.709]         {
[17:43:52.709]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.709]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.709]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.709]             })
[17:43:52.709]         }
[17:43:52.709]     }, args = future.call.arguments)
[17:43:52.709] }
[17:43:52.709] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.710] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.710] 
[17:43:52.710] getGlobalsAndPackages() ... DONE
[17:43:52.710] run() for ‘Future’ ...
[17:43:52.710] - state: ‘created’
[17:43:52.710] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.714] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.714]   - Field: ‘label’
[17:43:52.714]   - Field: ‘local’
[17:43:52.714]   - Field: ‘owner’
[17:43:52.714]   - Field: ‘envir’
[17:43:52.714]   - Field: ‘packages’
[17:43:52.714]   - Field: ‘gc’
[17:43:52.714]   - Field: ‘conditions’
[17:43:52.714]   - Field: ‘expr’
[17:43:52.715]   - Field: ‘uuid’
[17:43:52.715]   - Field: ‘seed’
[17:43:52.715]   - Field: ‘version’
[17:43:52.715]   - Field: ‘result’
[17:43:52.715]   - Field: ‘asynchronous’
[17:43:52.715]   - Field: ‘calls’
[17:43:52.715]   - Field: ‘globals’
[17:43:52.715]   - Field: ‘stdout’
[17:43:52.715]   - Field: ‘earlySignal’
[17:43:52.715]   - Field: ‘lazy’
[17:43:52.716]   - Field: ‘state’
[17:43:52.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.716] - Launch lazy future ...
[17:43:52.716] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.716] Packages needed by future strategies (n = 0): <none>
[17:43:52.716] {
[17:43:52.716]     {
[17:43:52.716]         {
[17:43:52.716]             ...future.startTime <- base::Sys.time()
[17:43:52.716]             {
[17:43:52.716]                 {
[17:43:52.716]                   {
[17:43:52.716]                     {
[17:43:52.716]                       base::local({
[17:43:52.716]                         has_future <- base::requireNamespace("future", 
[17:43:52.716]                           quietly = TRUE)
[17:43:52.716]                         if (has_future) {
[17:43:52.716]                           ns <- base::getNamespace("future")
[17:43:52.716]                           version <- ns[[".package"]][["version"]]
[17:43:52.716]                           if (is.null(version)) 
[17:43:52.716]                             version <- utils::packageVersion("future")
[17:43:52.716]                         }
[17:43:52.716]                         else {
[17:43:52.716]                           version <- NULL
[17:43:52.716]                         }
[17:43:52.716]                         if (!has_future || version < "1.8.0") {
[17:43:52.716]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.716]                             "", base::R.version$version.string), 
[17:43:52.716]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.716]                               "release", "version")], collapse = " "), 
[17:43:52.716]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.716]                             info)
[17:43:52.716]                           info <- base::paste(info, collapse = "; ")
[17:43:52.716]                           if (!has_future) {
[17:43:52.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.716]                               info)
[17:43:52.716]                           }
[17:43:52.716]                           else {
[17:43:52.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.716]                               info, version)
[17:43:52.716]                           }
[17:43:52.716]                           base::stop(msg)
[17:43:52.716]                         }
[17:43:52.716]                       })
[17:43:52.716]                     }
[17:43:52.716]                     base::local({
[17:43:52.716]                       for (pkg in "stats") {
[17:43:52.716]                         base::loadNamespace(pkg)
[17:43:52.716]                         base::library(pkg, character.only = TRUE)
[17:43:52.716]                       }
[17:43:52.716]                     })
[17:43:52.716]                   }
[17:43:52.716]                   ...future.strategy.old <- future::plan("list")
[17:43:52.716]                   options(future.plan = NULL)
[17:43:52.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.716]                 }
[17:43:52.716]                 ...future.workdir <- getwd()
[17:43:52.716]             }
[17:43:52.716]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.716]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.716]         }
[17:43:52.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.716]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.716]             base::names(...future.oldOptions))
[17:43:52.716]     }
[17:43:52.716]     if (FALSE) {
[17:43:52.716]     }
[17:43:52.716]     else {
[17:43:52.716]         if (TRUE) {
[17:43:52.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.716]                 open = "w")
[17:43:52.716]         }
[17:43:52.716]         else {
[17:43:52.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.716]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.716]         }
[17:43:52.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.716]             base::sink(type = "output", split = FALSE)
[17:43:52.716]             base::close(...future.stdout)
[17:43:52.716]         }, add = TRUE)
[17:43:52.716]     }
[17:43:52.716]     ...future.frame <- base::sys.nframe()
[17:43:52.716]     ...future.conditions <- base::list()
[17:43:52.716]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.716]     if (FALSE) {
[17:43:52.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.716]     }
[17:43:52.716]     ...future.result <- base::tryCatch({
[17:43:52.716]         base::withCallingHandlers({
[17:43:52.716]             ...future.value <- base::withVisible(base::local({
[17:43:52.716]                 do.call(function(...) {
[17:43:52.716]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.716]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.716]                     ...future.globals.maxSize)) {
[17:43:52.716]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.716]                     on.exit(options(oopts), add = TRUE)
[17:43:52.716]                   }
[17:43:52.716]                   {
[17:43:52.716]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.716]                       FUN = function(jj) {
[17:43:52.716]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.716]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.716]                       })
[17:43:52.716]                   }
[17:43:52.716]                 }, args = future.call.arguments)
[17:43:52.716]             }))
[17:43:52.716]             future::FutureResult(value = ...future.value$value, 
[17:43:52.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.716]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.716]                     ...future.globalenv.names))
[17:43:52.716]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.716]         }, condition = base::local({
[17:43:52.716]             c <- base::c
[17:43:52.716]             inherits <- base::inherits
[17:43:52.716]             invokeRestart <- base::invokeRestart
[17:43:52.716]             length <- base::length
[17:43:52.716]             list <- base::list
[17:43:52.716]             seq.int <- base::seq.int
[17:43:52.716]             signalCondition <- base::signalCondition
[17:43:52.716]             sys.calls <- base::sys.calls
[17:43:52.716]             `[[` <- base::`[[`
[17:43:52.716]             `+` <- base::`+`
[17:43:52.716]             `<<-` <- base::`<<-`
[17:43:52.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.716]                   3L)]
[17:43:52.716]             }
[17:43:52.716]             function(cond) {
[17:43:52.716]                 is_error <- inherits(cond, "error")
[17:43:52.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.716]                   NULL)
[17:43:52.716]                 if (is_error) {
[17:43:52.716]                   sessionInformation <- function() {
[17:43:52.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.716]                       search = base::search(), system = base::Sys.info())
[17:43:52.716]                   }
[17:43:52.716]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.716]                     cond$call), session = sessionInformation(), 
[17:43:52.716]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.716]                   signalCondition(cond)
[17:43:52.716]                 }
[17:43:52.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.716]                 "immediateCondition"))) {
[17:43:52.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.716]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.716]                   if (TRUE && !signal) {
[17:43:52.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.716]                     {
[17:43:52.716]                       inherits <- base::inherits
[17:43:52.716]                       invokeRestart <- base::invokeRestart
[17:43:52.716]                       is.null <- base::is.null
[17:43:52.716]                       muffled <- FALSE
[17:43:52.716]                       if (inherits(cond, "message")) {
[17:43:52.716]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.716]                         if (muffled) 
[17:43:52.716]                           invokeRestart("muffleMessage")
[17:43:52.716]                       }
[17:43:52.716]                       else if (inherits(cond, "warning")) {
[17:43:52.716]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.716]                         if (muffled) 
[17:43:52.716]                           invokeRestart("muffleWarning")
[17:43:52.716]                       }
[17:43:52.716]                       else if (inherits(cond, "condition")) {
[17:43:52.716]                         if (!is.null(pattern)) {
[17:43:52.716]                           computeRestarts <- base::computeRestarts
[17:43:52.716]                           grepl <- base::grepl
[17:43:52.716]                           restarts <- computeRestarts(cond)
[17:43:52.716]                           for (restart in restarts) {
[17:43:52.716]                             name <- restart$name
[17:43:52.716]                             if (is.null(name)) 
[17:43:52.716]                               next
[17:43:52.716]                             if (!grepl(pattern, name)) 
[17:43:52.716]                               next
[17:43:52.716]                             invokeRestart(restart)
[17:43:52.716]                             muffled <- TRUE
[17:43:52.716]                             break
[17:43:52.716]                           }
[17:43:52.716]                         }
[17:43:52.716]                       }
[17:43:52.716]                       invisible(muffled)
[17:43:52.716]                     }
[17:43:52.716]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.716]                   }
[17:43:52.716]                 }
[17:43:52.716]                 else {
[17:43:52.716]                   if (TRUE) {
[17:43:52.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.716]                     {
[17:43:52.716]                       inherits <- base::inherits
[17:43:52.716]                       invokeRestart <- base::invokeRestart
[17:43:52.716]                       is.null <- base::is.null
[17:43:52.716]                       muffled <- FALSE
[17:43:52.716]                       if (inherits(cond, "message")) {
[17:43:52.716]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.716]                         if (muffled) 
[17:43:52.716]                           invokeRestart("muffleMessage")
[17:43:52.716]                       }
[17:43:52.716]                       else if (inherits(cond, "warning")) {
[17:43:52.716]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.716]                         if (muffled) 
[17:43:52.716]                           invokeRestart("muffleWarning")
[17:43:52.716]                       }
[17:43:52.716]                       else if (inherits(cond, "condition")) {
[17:43:52.716]                         if (!is.null(pattern)) {
[17:43:52.716]                           computeRestarts <- base::computeRestarts
[17:43:52.716]                           grepl <- base::grepl
[17:43:52.716]                           restarts <- computeRestarts(cond)
[17:43:52.716]                           for (restart in restarts) {
[17:43:52.716]                             name <- restart$name
[17:43:52.716]                             if (is.null(name)) 
[17:43:52.716]                               next
[17:43:52.716]                             if (!grepl(pattern, name)) 
[17:43:52.716]                               next
[17:43:52.716]                             invokeRestart(restart)
[17:43:52.716]                             muffled <- TRUE
[17:43:52.716]                             break
[17:43:52.716]                           }
[17:43:52.716]                         }
[17:43:52.716]                       }
[17:43:52.716]                       invisible(muffled)
[17:43:52.716]                     }
[17:43:52.716]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.716]                   }
[17:43:52.716]                 }
[17:43:52.716]             }
[17:43:52.716]         }))
[17:43:52.716]     }, error = function(ex) {
[17:43:52.716]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.716]                 ...future.rng), started = ...future.startTime, 
[17:43:52.716]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.716]             version = "1.8"), class = "FutureResult")
[17:43:52.716]     }, finally = {
[17:43:52.716]         if (!identical(...future.workdir, getwd())) 
[17:43:52.716]             setwd(...future.workdir)
[17:43:52.716]         {
[17:43:52.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.716]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.716]             }
[17:43:52.716]             base::options(...future.oldOptions)
[17:43:52.716]             if (.Platform$OS.type == "windows") {
[17:43:52.716]                 old_names <- names(...future.oldEnvVars)
[17:43:52.716]                 envs <- base::Sys.getenv()
[17:43:52.716]                 names <- names(envs)
[17:43:52.716]                 common <- intersect(names, old_names)
[17:43:52.716]                 added <- setdiff(names, old_names)
[17:43:52.716]                 removed <- setdiff(old_names, names)
[17:43:52.716]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.716]                   envs[common]]
[17:43:52.716]                 NAMES <- toupper(changed)
[17:43:52.716]                 args <- list()
[17:43:52.716]                 for (kk in seq_along(NAMES)) {
[17:43:52.716]                   name <- changed[[kk]]
[17:43:52.716]                   NAME <- NAMES[[kk]]
[17:43:52.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.716]                     next
[17:43:52.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.716]                 }
[17:43:52.716]                 NAMES <- toupper(added)
[17:43:52.716]                 for (kk in seq_along(NAMES)) {
[17:43:52.716]                   name <- added[[kk]]
[17:43:52.716]                   NAME <- NAMES[[kk]]
[17:43:52.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.716]                     next
[17:43:52.716]                   args[[name]] <- ""
[17:43:52.716]                 }
[17:43:52.716]                 NAMES <- toupper(removed)
[17:43:52.716]                 for (kk in seq_along(NAMES)) {
[17:43:52.716]                   name <- removed[[kk]]
[17:43:52.716]                   NAME <- NAMES[[kk]]
[17:43:52.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.716]                     next
[17:43:52.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.716]                 }
[17:43:52.716]                 if (length(args) > 0) 
[17:43:52.716]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.716]             }
[17:43:52.716]             else {
[17:43:52.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.716]             }
[17:43:52.716]             {
[17:43:52.716]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.716]                   0L) {
[17:43:52.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.716]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.716]                   base::options(opts)
[17:43:52.716]                 }
[17:43:52.716]                 {
[17:43:52.716]                   {
[17:43:52.716]                     NULL
[17:43:52.716]                     RNGkind("Mersenne-Twister")
[17:43:52.716]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.716]                       inherits = FALSE)
[17:43:52.716]                   }
[17:43:52.716]                   options(future.plan = NULL)
[17:43:52.716]                   if (is.na(NA_character_)) 
[17:43:52.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.716]                     .init = FALSE)
[17:43:52.716]                 }
[17:43:52.716]             }
[17:43:52.716]         }
[17:43:52.716]     })
[17:43:52.716]     if (TRUE) {
[17:43:52.716]         base::sink(type = "output", split = FALSE)
[17:43:52.716]         if (TRUE) {
[17:43:52.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.716]         }
[17:43:52.716]         else {
[17:43:52.716]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.716]         }
[17:43:52.716]         base::close(...future.stdout)
[17:43:52.716]         ...future.stdout <- NULL
[17:43:52.716]     }
[17:43:52.716]     ...future.result$conditions <- ...future.conditions
[17:43:52.716]     ...future.result$finished <- base::Sys.time()
[17:43:52.716]     ...future.result
[17:43:52.716] }
[17:43:52.718] assign_globals() ...
[17:43:52.718] List of 7
[17:43:52.718]  $ ...future.FUN            :function (x)  
[17:43:52.718]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.718]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.718]  $ future.call.arguments    : list()
[17:43:52.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.718]  $ ...future.elements_ii    :List of 3
[17:43:52.718]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.718]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.718]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.718]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.718]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.718]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.718]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.718]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.718]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.718]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.718]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.718]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.718]  $ ...future.seeds_ii       : NULL
[17:43:52.718]  $ ...future.globals.maxSize: NULL
[17:43:52.718]  - attr(*, "where")=List of 7
[17:43:52.718]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.718]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:43:52.718]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:43:52.718]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.718]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.718]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.718]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.718]  - attr(*, "resolved")= logi FALSE
[17:43:52.718]  - attr(*, "total_size")= num 2320
[17:43:52.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.718]  - attr(*, "already-done")= logi TRUE
[17:43:52.727] - reassign environment for ‘...future.FUN’
[17:43:52.728] - copied ‘...future.FUN’ to environment
[17:43:52.728] - copied ‘breaks’ to environment
[17:43:52.728] - copied ‘wool’ to environment
[17:43:52.728] - copied ‘future.call.arguments’ to environment
[17:43:52.728] - copied ‘...future.elements_ii’ to environment
[17:43:52.728] - copied ‘...future.seeds_ii’ to environment
[17:43:52.729] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.729] assign_globals() ... done
[17:43:52.730] plan(): Setting new future strategy stack:
[17:43:52.730] List of future strategies:
[17:43:52.730] 1. sequential:
[17:43:52.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.730]    - tweaked: FALSE
[17:43:52.730]    - call: NULL
[17:43:52.730] plan(): nbrOfWorkers() = 1
[17:43:52.733] plan(): Setting new future strategy stack:
[17:43:52.733] List of future strategies:
[17:43:52.733] 1. multisession:
[17:43:52.733]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.733]    - tweaked: FALSE
[17:43:52.733]    - call: plan(strategy)
[17:43:52.737] plan(): nbrOfWorkers() = 1
[17:43:52.737] SequentialFuture started (and completed)
[17:43:52.737] - Launch lazy future ... done
[17:43:52.737] run() for ‘SequentialFuture’ ... done
[17:43:52.737] Created future:
[17:43:52.738] SequentialFuture:
[17:43:52.738] Label: ‘future_by-1’
[17:43:52.738] Expression:
[17:43:52.738] {
[17:43:52.738]     do.call(function(...) {
[17:43:52.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.738]             on.exit(options(oopts), add = TRUE)
[17:43:52.738]         }
[17:43:52.738]         {
[17:43:52.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.738]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.738]             })
[17:43:52.738]         }
[17:43:52.738]     }, args = future.call.arguments)
[17:43:52.738] }
[17:43:52.738] Lazy evaluation: FALSE
[17:43:52.738] Asynchronous evaluation: FALSE
[17:43:52.738] Local evaluation: TRUE
[17:43:52.738] Environment: 0x55d6b8ed4eb8
[17:43:52.738] Capture standard output: TRUE
[17:43:52.738] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.738] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:43:52.738] Packages: 1 packages (‘stats’)
[17:43:52.738] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.738] Resolved: TRUE
[17:43:52.738] Value: 25.57 KiB of class ‘list’
[17:43:52.738] Early signaling: FALSE
[17:43:52.738] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.738] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.739] Chunk #1 of 1 ... DONE
[17:43:52.739] Launching 1 futures (chunks) ... DONE
[17:43:52.739] Resolving 1 futures (chunks) ...
[17:43:52.740] resolve() on list ...
[17:43:52.740]  recursive: 0
[17:43:52.740]  length: 1
[17:43:52.740] 
[17:43:52.740] resolved() for ‘SequentialFuture’ ...
[17:43:52.740] - state: ‘finished’
[17:43:52.740] - run: TRUE
[17:43:52.740] - result: ‘FutureResult’
[17:43:52.740] resolved() for ‘SequentialFuture’ ... done
[17:43:52.740] Future #1
[17:43:52.741] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.741] - nx: 1
[17:43:52.741] - relay: TRUE
[17:43:52.741] - stdout: TRUE
[17:43:52.741] - signal: TRUE
[17:43:52.741] - resignal: FALSE
[17:43:52.741] - force: TRUE
[17:43:52.741] - relayed: [n=1] FALSE
[17:43:52.741] - queued futures: [n=1] FALSE
[17:43:52.741]  - until=1
[17:43:52.741]  - relaying element #1
[17:43:52.742] - relayed: [n=1] TRUE
[17:43:52.742] - queued futures: [n=1] TRUE
[17:43:52.742] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.742]  length: 0 (resolved future 1)
[17:43:52.742] Relaying remaining futures
[17:43:52.742] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.742] - nx: 1
[17:43:52.742] - relay: TRUE
[17:43:52.742] - stdout: TRUE
[17:43:52.742] - signal: TRUE
[17:43:52.742] - resignal: FALSE
[17:43:52.743] - force: TRUE
[17:43:52.743] - relayed: [n=1] TRUE
[17:43:52.743] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.743] - relayed: [n=1] TRUE
[17:43:52.743] - queued futures: [n=1] TRUE
[17:43:52.743] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.743] resolve() on list ... DONE
[17:43:52.743]  - Number of value chunks collected: 1
[17:43:52.743] Resolving 1 futures (chunks) ... DONE
[17:43:52.743] Reducing values from 1 chunks ...
[17:43:52.744]  - Number of values collected after concatenation: 3
[17:43:52.744]  - Number of values expected: 3
[17:43:52.744] Reducing values from 1 chunks ... DONE
[17:43:52.744] future_lapply() ... DONE
[17:43:52.744] future_by_internal() ... DONE
[17:43:52.744] future_by_internal() ...
[17:43:52.745] future_lapply() ...
[17:43:52.748] Number of chunks: 1
[17:43:52.748] getGlobalsAndPackagesXApply() ...
[17:43:52.748]  - future.globals: TRUE
[17:43:52.749] getGlobalsAndPackages() ...
[17:43:52.749] Searching for globals...
[17:43:52.750] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.750] Searching for globals ... DONE
[17:43:52.750] Resolving globals: FALSE
[17:43:52.750] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.751] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.751] - globals: [1] ‘FUN’
[17:43:52.751] 
[17:43:52.751] getGlobalsAndPackages() ... DONE
[17:43:52.751]  - globals found/used: [n=1] ‘FUN’
[17:43:52.751]  - needed namespaces: [n=0] 
[17:43:52.751] Finding globals ... DONE
[17:43:52.751]  - use_args: TRUE
[17:43:52.751]  - Getting '...' globals ...
[17:43:52.752] resolve() on list ...
[17:43:52.752]  recursive: 0
[17:43:52.752]  length: 1
[17:43:52.752]  elements: ‘...’
[17:43:52.752]  length: 0 (resolved future 1)
[17:43:52.752] resolve() on list ... DONE
[17:43:52.752]    - '...' content: [n=0] 
[17:43:52.752] List of 1
[17:43:52.752]  $ ...: list()
[17:43:52.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.752]  - attr(*, "where")=List of 1
[17:43:52.752]   ..$ ...:<environment: 0x55d6bab57d48> 
[17:43:52.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.752]  - attr(*, "resolved")= logi TRUE
[17:43:52.752]  - attr(*, "total_size")= num NA
[17:43:52.757]  - Getting '...' globals ... DONE
[17:43:52.757] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.757] List of 2
[17:43:52.757]  $ ...future.FUN:function (object, ...)  
[17:43:52.757]  $ ...          : list()
[17:43:52.757]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.757]  - attr(*, "where")=List of 2
[17:43:52.757]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.757]   ..$ ...          :<environment: 0x55d6bab57d48> 
[17:43:52.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.757]  - attr(*, "resolved")= logi FALSE
[17:43:52.757]  - attr(*, "total_size")= num 1240
[17:43:52.760] Packages to be attached in all futures: [n=0] 
[17:43:52.760] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.760] Number of futures (= number of chunks): 1
[17:43:52.760] Launching 1 futures (chunks) ...
[17:43:52.760] Chunk #1 of 1 ...
[17:43:52.760]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.761] getGlobalsAndPackages() ...
[17:43:52.761] Searching for globals...
[17:43:52.761] 
[17:43:52.761] Searching for globals ... DONE
[17:43:52.761] - globals: [0] <none>
[17:43:52.761] getGlobalsAndPackages() ... DONE
[17:43:52.761]    + additional globals found: [n=0] 
[17:43:52.762]    + additional namespaces needed: [n=0] 
[17:43:52.762]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.762]  - seeds: <none>
[17:43:52.762]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.762] getGlobalsAndPackages() ...
[17:43:52.762] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.762] Resolving globals: FALSE
[17:43:52.762] Tweak future expression to call with '...' arguments ...
[17:43:52.762] {
[17:43:52.762]     do.call(function(...) {
[17:43:52.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.762]             on.exit(options(oopts), add = TRUE)
[17:43:52.762]         }
[17:43:52.762]         {
[17:43:52.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.762]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.762]             })
[17:43:52.762]         }
[17:43:52.762]     }, args = future.call.arguments)
[17:43:52.762] }
[17:43:52.763] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.763] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.763] 
[17:43:52.763] getGlobalsAndPackages() ... DONE
[17:43:52.764] run() for ‘Future’ ...
[17:43:52.764] - state: ‘created’
[17:43:52.764] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.767] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.767]   - Field: ‘label’
[17:43:52.768]   - Field: ‘local’
[17:43:52.768]   - Field: ‘owner’
[17:43:52.768]   - Field: ‘envir’
[17:43:52.768]   - Field: ‘packages’
[17:43:52.768]   - Field: ‘gc’
[17:43:52.768]   - Field: ‘conditions’
[17:43:52.768]   - Field: ‘expr’
[17:43:52.768]   - Field: ‘uuid’
[17:43:52.768]   - Field: ‘seed’
[17:43:52.768]   - Field: ‘version’
[17:43:52.768]   - Field: ‘result’
[17:43:52.768]   - Field: ‘asynchronous’
[17:43:52.769]   - Field: ‘calls’
[17:43:52.769]   - Field: ‘globals’
[17:43:52.769]   - Field: ‘stdout’
[17:43:52.769]   - Field: ‘earlySignal’
[17:43:52.769]   - Field: ‘lazy’
[17:43:52.769]   - Field: ‘state’
[17:43:52.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.769] - Launch lazy future ...
[17:43:52.769] Packages needed by the future expression (n = 0): <none>
[17:43:52.770] Packages needed by future strategies (n = 0): <none>
[17:43:52.770] {
[17:43:52.770]     {
[17:43:52.770]         {
[17:43:52.770]             ...future.startTime <- base::Sys.time()
[17:43:52.770]             {
[17:43:52.770]                 {
[17:43:52.770]                   {
[17:43:52.770]                     base::local({
[17:43:52.770]                       has_future <- base::requireNamespace("future", 
[17:43:52.770]                         quietly = TRUE)
[17:43:52.770]                       if (has_future) {
[17:43:52.770]                         ns <- base::getNamespace("future")
[17:43:52.770]                         version <- ns[[".package"]][["version"]]
[17:43:52.770]                         if (is.null(version)) 
[17:43:52.770]                           version <- utils::packageVersion("future")
[17:43:52.770]                       }
[17:43:52.770]                       else {
[17:43:52.770]                         version <- NULL
[17:43:52.770]                       }
[17:43:52.770]                       if (!has_future || version < "1.8.0") {
[17:43:52.770]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.770]                           "", base::R.version$version.string), 
[17:43:52.770]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.770]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.770]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.770]                             "release", "version")], collapse = " "), 
[17:43:52.770]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.770]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.770]                           info)
[17:43:52.770]                         info <- base::paste(info, collapse = "; ")
[17:43:52.770]                         if (!has_future) {
[17:43:52.770]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.770]                             info)
[17:43:52.770]                         }
[17:43:52.770]                         else {
[17:43:52.770]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.770]                             info, version)
[17:43:52.770]                         }
[17:43:52.770]                         base::stop(msg)
[17:43:52.770]                       }
[17:43:52.770]                     })
[17:43:52.770]                   }
[17:43:52.770]                   ...future.strategy.old <- future::plan("list")
[17:43:52.770]                   options(future.plan = NULL)
[17:43:52.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.770]                 }
[17:43:52.770]                 ...future.workdir <- getwd()
[17:43:52.770]             }
[17:43:52.770]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.770]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.770]         }
[17:43:52.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.770]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.770]             base::names(...future.oldOptions))
[17:43:52.770]     }
[17:43:52.770]     if (FALSE) {
[17:43:52.770]     }
[17:43:52.770]     else {
[17:43:52.770]         if (TRUE) {
[17:43:52.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.770]                 open = "w")
[17:43:52.770]         }
[17:43:52.770]         else {
[17:43:52.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.770]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.770]         }
[17:43:52.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.770]             base::sink(type = "output", split = FALSE)
[17:43:52.770]             base::close(...future.stdout)
[17:43:52.770]         }, add = TRUE)
[17:43:52.770]     }
[17:43:52.770]     ...future.frame <- base::sys.nframe()
[17:43:52.770]     ...future.conditions <- base::list()
[17:43:52.770]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.770]     if (FALSE) {
[17:43:52.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.770]     }
[17:43:52.770]     ...future.result <- base::tryCatch({
[17:43:52.770]         base::withCallingHandlers({
[17:43:52.770]             ...future.value <- base::withVisible(base::local({
[17:43:52.770]                 do.call(function(...) {
[17:43:52.770]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.770]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.770]                     ...future.globals.maxSize)) {
[17:43:52.770]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.770]                     on.exit(options(oopts), add = TRUE)
[17:43:52.770]                   }
[17:43:52.770]                   {
[17:43:52.770]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.770]                       FUN = function(jj) {
[17:43:52.770]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.770]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.770]                       })
[17:43:52.770]                   }
[17:43:52.770]                 }, args = future.call.arguments)
[17:43:52.770]             }))
[17:43:52.770]             future::FutureResult(value = ...future.value$value, 
[17:43:52.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.770]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.770]                     ...future.globalenv.names))
[17:43:52.770]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.770]         }, condition = base::local({
[17:43:52.770]             c <- base::c
[17:43:52.770]             inherits <- base::inherits
[17:43:52.770]             invokeRestart <- base::invokeRestart
[17:43:52.770]             length <- base::length
[17:43:52.770]             list <- base::list
[17:43:52.770]             seq.int <- base::seq.int
[17:43:52.770]             signalCondition <- base::signalCondition
[17:43:52.770]             sys.calls <- base::sys.calls
[17:43:52.770]             `[[` <- base::`[[`
[17:43:52.770]             `+` <- base::`+`
[17:43:52.770]             `<<-` <- base::`<<-`
[17:43:52.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.770]                   3L)]
[17:43:52.770]             }
[17:43:52.770]             function(cond) {
[17:43:52.770]                 is_error <- inherits(cond, "error")
[17:43:52.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.770]                   NULL)
[17:43:52.770]                 if (is_error) {
[17:43:52.770]                   sessionInformation <- function() {
[17:43:52.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.770]                       search = base::search(), system = base::Sys.info())
[17:43:52.770]                   }
[17:43:52.770]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.770]                     cond$call), session = sessionInformation(), 
[17:43:52.770]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.770]                   signalCondition(cond)
[17:43:52.770]                 }
[17:43:52.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.770]                 "immediateCondition"))) {
[17:43:52.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.770]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.770]                   if (TRUE && !signal) {
[17:43:52.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.770]                     {
[17:43:52.770]                       inherits <- base::inherits
[17:43:52.770]                       invokeRestart <- base::invokeRestart
[17:43:52.770]                       is.null <- base::is.null
[17:43:52.770]                       muffled <- FALSE
[17:43:52.770]                       if (inherits(cond, "message")) {
[17:43:52.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.770]                         if (muffled) 
[17:43:52.770]                           invokeRestart("muffleMessage")
[17:43:52.770]                       }
[17:43:52.770]                       else if (inherits(cond, "warning")) {
[17:43:52.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.770]                         if (muffled) 
[17:43:52.770]                           invokeRestart("muffleWarning")
[17:43:52.770]                       }
[17:43:52.770]                       else if (inherits(cond, "condition")) {
[17:43:52.770]                         if (!is.null(pattern)) {
[17:43:52.770]                           computeRestarts <- base::computeRestarts
[17:43:52.770]                           grepl <- base::grepl
[17:43:52.770]                           restarts <- computeRestarts(cond)
[17:43:52.770]                           for (restart in restarts) {
[17:43:52.770]                             name <- restart$name
[17:43:52.770]                             if (is.null(name)) 
[17:43:52.770]                               next
[17:43:52.770]                             if (!grepl(pattern, name)) 
[17:43:52.770]                               next
[17:43:52.770]                             invokeRestart(restart)
[17:43:52.770]                             muffled <- TRUE
[17:43:52.770]                             break
[17:43:52.770]                           }
[17:43:52.770]                         }
[17:43:52.770]                       }
[17:43:52.770]                       invisible(muffled)
[17:43:52.770]                     }
[17:43:52.770]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.770]                   }
[17:43:52.770]                 }
[17:43:52.770]                 else {
[17:43:52.770]                   if (TRUE) {
[17:43:52.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.770]                     {
[17:43:52.770]                       inherits <- base::inherits
[17:43:52.770]                       invokeRestart <- base::invokeRestart
[17:43:52.770]                       is.null <- base::is.null
[17:43:52.770]                       muffled <- FALSE
[17:43:52.770]                       if (inherits(cond, "message")) {
[17:43:52.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.770]                         if (muffled) 
[17:43:52.770]                           invokeRestart("muffleMessage")
[17:43:52.770]                       }
[17:43:52.770]                       else if (inherits(cond, "warning")) {
[17:43:52.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.770]                         if (muffled) 
[17:43:52.770]                           invokeRestart("muffleWarning")
[17:43:52.770]                       }
[17:43:52.770]                       else if (inherits(cond, "condition")) {
[17:43:52.770]                         if (!is.null(pattern)) {
[17:43:52.770]                           computeRestarts <- base::computeRestarts
[17:43:52.770]                           grepl <- base::grepl
[17:43:52.770]                           restarts <- computeRestarts(cond)
[17:43:52.770]                           for (restart in restarts) {
[17:43:52.770]                             name <- restart$name
[17:43:52.770]                             if (is.null(name)) 
[17:43:52.770]                               next
[17:43:52.770]                             if (!grepl(pattern, name)) 
[17:43:52.770]                               next
[17:43:52.770]                             invokeRestart(restart)
[17:43:52.770]                             muffled <- TRUE
[17:43:52.770]                             break
[17:43:52.770]                           }
[17:43:52.770]                         }
[17:43:52.770]                       }
[17:43:52.770]                       invisible(muffled)
[17:43:52.770]                     }
[17:43:52.770]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.770]                   }
[17:43:52.770]                 }
[17:43:52.770]             }
[17:43:52.770]         }))
[17:43:52.770]     }, error = function(ex) {
[17:43:52.770]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.770]                 ...future.rng), started = ...future.startTime, 
[17:43:52.770]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.770]             version = "1.8"), class = "FutureResult")
[17:43:52.770]     }, finally = {
[17:43:52.770]         if (!identical(...future.workdir, getwd())) 
[17:43:52.770]             setwd(...future.workdir)
[17:43:52.770]         {
[17:43:52.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.770]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.770]             }
[17:43:52.770]             base::options(...future.oldOptions)
[17:43:52.770]             if (.Platform$OS.type == "windows") {
[17:43:52.770]                 old_names <- names(...future.oldEnvVars)
[17:43:52.770]                 envs <- base::Sys.getenv()
[17:43:52.770]                 names <- names(envs)
[17:43:52.770]                 common <- intersect(names, old_names)
[17:43:52.770]                 added <- setdiff(names, old_names)
[17:43:52.770]                 removed <- setdiff(old_names, names)
[17:43:52.770]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.770]                   envs[common]]
[17:43:52.770]                 NAMES <- toupper(changed)
[17:43:52.770]                 args <- list()
[17:43:52.770]                 for (kk in seq_along(NAMES)) {
[17:43:52.770]                   name <- changed[[kk]]
[17:43:52.770]                   NAME <- NAMES[[kk]]
[17:43:52.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.770]                     next
[17:43:52.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.770]                 }
[17:43:52.770]                 NAMES <- toupper(added)
[17:43:52.770]                 for (kk in seq_along(NAMES)) {
[17:43:52.770]                   name <- added[[kk]]
[17:43:52.770]                   NAME <- NAMES[[kk]]
[17:43:52.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.770]                     next
[17:43:52.770]                   args[[name]] <- ""
[17:43:52.770]                 }
[17:43:52.770]                 NAMES <- toupper(removed)
[17:43:52.770]                 for (kk in seq_along(NAMES)) {
[17:43:52.770]                   name <- removed[[kk]]
[17:43:52.770]                   NAME <- NAMES[[kk]]
[17:43:52.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.770]                     next
[17:43:52.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.770]                 }
[17:43:52.770]                 if (length(args) > 0) 
[17:43:52.770]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.770]             }
[17:43:52.770]             else {
[17:43:52.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.770]             }
[17:43:52.770]             {
[17:43:52.770]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.770]                   0L) {
[17:43:52.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.770]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.770]                   base::options(opts)
[17:43:52.770]                 }
[17:43:52.770]                 {
[17:43:52.770]                   {
[17:43:52.770]                     NULL
[17:43:52.770]                     RNGkind("Mersenne-Twister")
[17:43:52.770]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.770]                       inherits = FALSE)
[17:43:52.770]                   }
[17:43:52.770]                   options(future.plan = NULL)
[17:43:52.770]                   if (is.na(NA_character_)) 
[17:43:52.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.770]                     .init = FALSE)
[17:43:52.770]                 }
[17:43:52.770]             }
[17:43:52.770]         }
[17:43:52.770]     })
[17:43:52.770]     if (TRUE) {
[17:43:52.770]         base::sink(type = "output", split = FALSE)
[17:43:52.770]         if (TRUE) {
[17:43:52.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.770]         }
[17:43:52.770]         else {
[17:43:52.770]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.770]         }
[17:43:52.770]         base::close(...future.stdout)
[17:43:52.770]         ...future.stdout <- NULL
[17:43:52.770]     }
[17:43:52.770]     ...future.result$conditions <- ...future.conditions
[17:43:52.770]     ...future.result$finished <- base::Sys.time()
[17:43:52.770]     ...future.result
[17:43:52.770] }
[17:43:52.772] assign_globals() ...
[17:43:52.772] List of 5
[17:43:52.772]  $ ...future.FUN            :function (object, ...)  
[17:43:52.772]  $ future.call.arguments    : list()
[17:43:52.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.772]  $ ...future.elements_ii    :List of 3
[17:43:52.772]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.772]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.772]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.772]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.772]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.772]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.772]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.772]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.772]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.772]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.772]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.772]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.772]  $ ...future.seeds_ii       : NULL
[17:43:52.772]  $ ...future.globals.maxSize: NULL
[17:43:52.772]  - attr(*, "where")=List of 5
[17:43:52.772]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.772]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.772]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.772]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.772]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.772]  - attr(*, "resolved")= logi FALSE
[17:43:52.772]  - attr(*, "total_size")= num 1240
[17:43:52.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.772]  - attr(*, "already-done")= logi TRUE
[17:43:52.782] - copied ‘...future.FUN’ to environment
[17:43:52.782] - copied ‘future.call.arguments’ to environment
[17:43:52.782] - copied ‘...future.elements_ii’ to environment
[17:43:52.782] - copied ‘...future.seeds_ii’ to environment
[17:43:52.782] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.782] assign_globals() ... done
[17:43:52.783] plan(): Setting new future strategy stack:
[17:43:52.783] List of future strategies:
[17:43:52.783] 1. sequential:
[17:43:52.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.783]    - tweaked: FALSE
[17:43:52.783]    - call: NULL
[17:43:52.783] plan(): nbrOfWorkers() = 1
[17:43:52.785] plan(): Setting new future strategy stack:
[17:43:52.786] List of future strategies:
[17:43:52.786] 1. multisession:
[17:43:52.786]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.786]    - tweaked: FALSE
[17:43:52.786]    - call: plan(strategy)
[17:43:52.789] plan(): nbrOfWorkers() = 1
[17:43:52.789] SequentialFuture started (and completed)
[17:43:52.789] - Launch lazy future ... done
[17:43:52.790] run() for ‘SequentialFuture’ ... done
[17:43:52.790] Created future:
[17:43:52.790] SequentialFuture:
[17:43:52.790] Label: ‘future_by-1’
[17:43:52.790] Expression:
[17:43:52.790] {
[17:43:52.790]     do.call(function(...) {
[17:43:52.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.790]             on.exit(options(oopts), add = TRUE)
[17:43:52.790]         }
[17:43:52.790]         {
[17:43:52.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.790]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.790]             })
[17:43:52.790]         }
[17:43:52.790]     }, args = future.call.arguments)
[17:43:52.790] }
[17:43:52.790] Lazy evaluation: FALSE
[17:43:52.790] Asynchronous evaluation: FALSE
[17:43:52.790] Local evaluation: TRUE
[17:43:52.790] Environment: 0x55d6bab18990
[17:43:52.790] Capture standard output: TRUE
[17:43:52.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.790] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.790] Packages: <none>
[17:43:52.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.790] Resolved: TRUE
[17:43:52.790] Value: 5.37 KiB of class ‘list’
[17:43:52.790] Early signaling: FALSE
[17:43:52.790] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.790] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.791] Chunk #1 of 1 ... DONE
[17:43:52.791] Launching 1 futures (chunks) ... DONE
[17:43:52.791] Resolving 1 futures (chunks) ...
[17:43:52.791] resolve() on list ...
[17:43:52.791]  recursive: 0
[17:43:52.792]  length: 1
[17:43:52.792] 
[17:43:52.792] resolved() for ‘SequentialFuture’ ...
[17:43:52.792] - state: ‘finished’
[17:43:52.792] - run: TRUE
[17:43:52.792] - result: ‘FutureResult’
[17:43:52.792] resolved() for ‘SequentialFuture’ ... done
[17:43:52.792] Future #1
[17:43:52.792] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.792] - nx: 1
[17:43:52.793] - relay: TRUE
[17:43:52.793] - stdout: TRUE
[17:43:52.793] - signal: TRUE
[17:43:52.793] - resignal: FALSE
[17:43:52.793] - force: TRUE
[17:43:52.793] - relayed: [n=1] FALSE
[17:43:52.793] - queued futures: [n=1] FALSE
[17:43:52.793]  - until=1
[17:43:52.793]  - relaying element #1
[17:43:52.793] - relayed: [n=1] TRUE
[17:43:52.794] - queued futures: [n=1] TRUE
[17:43:52.794] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.794]  length: 0 (resolved future 1)
[17:43:52.794] Relaying remaining futures
[17:43:52.794] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.794] - nx: 1
[17:43:52.794] - relay: TRUE
[17:43:52.794] - stdout: TRUE
[17:43:52.794] - signal: TRUE
[17:43:52.794] - resignal: FALSE
[17:43:52.794] - force: TRUE
[17:43:52.794] - relayed: [n=1] TRUE
[17:43:52.795] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.795] - relayed: [n=1] TRUE
[17:43:52.795] - queued futures: [n=1] TRUE
[17:43:52.795] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.795] resolve() on list ... DONE
[17:43:52.795]  - Number of value chunks collected: 1
[17:43:52.795] Resolving 1 futures (chunks) ... DONE
[17:43:52.795] Reducing values from 1 chunks ...
[17:43:52.795]  - Number of values collected after concatenation: 3
[17:43:52.795]  - Number of values expected: 3
[17:43:52.796] Reducing values from 1 chunks ... DONE
[17:43:52.796] future_lapply() ... DONE
[17:43:52.796] future_by_internal() ... DONE
[17:43:52.797] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:43:52.797] future_lapply() ...
[17:43:52.801] Number of chunks: 1
[17:43:52.801] getGlobalsAndPackagesXApply() ...
[17:43:52.801]  - future.globals: TRUE
[17:43:52.801] getGlobalsAndPackages() ...
[17:43:52.801] Searching for globals...
[17:43:52.802] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.802] Searching for globals ... DONE
[17:43:52.802] Resolving globals: FALSE
[17:43:52.802] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.803] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.803] - globals: [1] ‘FUN’
[17:43:52.803] 
[17:43:52.803] getGlobalsAndPackages() ... DONE
[17:43:52.803]  - globals found/used: [n=1] ‘FUN’
[17:43:52.803]  - needed namespaces: [n=0] 
[17:43:52.803] Finding globals ... DONE
[17:43:52.804]  - use_args: TRUE
[17:43:52.804]  - Getting '...' globals ...
[17:43:52.804] resolve() on list ...
[17:43:52.804]  recursive: 0
[17:43:52.804]  length: 1
[17:43:52.804]  elements: ‘...’
[17:43:52.804]  length: 0 (resolved future 1)
[17:43:52.804] resolve() on list ... DONE
[17:43:52.805]    - '...' content: [n=0] 
[17:43:52.805] List of 1
[17:43:52.805]  $ ...: list()
[17:43:52.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.805]  - attr(*, "where")=List of 1
[17:43:52.805]   ..$ ...:<environment: 0x55d6bab8c508> 
[17:43:52.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.805]  - attr(*, "resolved")= logi TRUE
[17:43:52.805]  - attr(*, "total_size")= num NA
[17:43:52.809]  - Getting '...' globals ... DONE
[17:43:52.809] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.809] List of 2
[17:43:52.809]  $ ...future.FUN:function (object, ...)  
[17:43:52.809]  $ ...          : list()
[17:43:52.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.809]  - attr(*, "where")=List of 2
[17:43:52.809]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.809]   ..$ ...          :<environment: 0x55d6bab8c508> 
[17:43:52.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.809]  - attr(*, "resolved")= logi FALSE
[17:43:52.809]  - attr(*, "total_size")= num 1240
[17:43:52.812] Packages to be attached in all futures: [n=0] 
[17:43:52.812] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.812] Number of futures (= number of chunks): 1
[17:43:52.812] Launching 1 futures (chunks) ...
[17:43:52.812] Chunk #1 of 1 ...
[17:43:52.812]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.813] getGlobalsAndPackages() ...
[17:43:52.813] Searching for globals...
[17:43:52.813] 
[17:43:52.813] Searching for globals ... DONE
[17:43:52.813] - globals: [0] <none>
[17:43:52.813] getGlobalsAndPackages() ... DONE
[17:43:52.813]    + additional globals found: [n=0] 
[17:43:52.814]    + additional namespaces needed: [n=0] 
[17:43:52.814]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.814]  - seeds: <none>
[17:43:52.814]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.814] getGlobalsAndPackages() ...
[17:43:52.814] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.814] Resolving globals: FALSE
[17:43:52.814] Tweak future expression to call with '...' arguments ...
[17:43:52.814] {
[17:43:52.814]     do.call(function(...) {
[17:43:52.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.814]             on.exit(options(oopts), add = TRUE)
[17:43:52.814]         }
[17:43:52.814]         {
[17:43:52.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.814]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.814]             })
[17:43:52.814]         }
[17:43:52.814]     }, args = future.call.arguments)
[17:43:52.814] }
[17:43:52.815] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.815] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.815] 
[17:43:52.815] getGlobalsAndPackages() ... DONE
[17:43:52.815] run() for ‘Future’ ...
[17:43:52.816] - state: ‘created’
[17:43:52.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.819]   - Field: ‘label’
[17:43:52.819]   - Field: ‘local’
[17:43:52.819]   - Field: ‘owner’
[17:43:52.820]   - Field: ‘envir’
[17:43:52.820]   - Field: ‘packages’
[17:43:52.820]   - Field: ‘gc’
[17:43:52.820]   - Field: ‘conditions’
[17:43:52.820]   - Field: ‘expr’
[17:43:52.820]   - Field: ‘uuid’
[17:43:52.820]   - Field: ‘seed’
[17:43:52.820]   - Field: ‘version’
[17:43:52.820]   - Field: ‘result’
[17:43:52.820]   - Field: ‘asynchronous’
[17:43:52.820]   - Field: ‘calls’
[17:43:52.820]   - Field: ‘globals’
[17:43:52.821]   - Field: ‘stdout’
[17:43:52.821]   - Field: ‘earlySignal’
[17:43:52.821]   - Field: ‘lazy’
[17:43:52.821]   - Field: ‘state’
[17:43:52.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.821] - Launch lazy future ...
[17:43:52.821] Packages needed by the future expression (n = 0): <none>
[17:43:52.821] Packages needed by future strategies (n = 0): <none>
[17:43:52.822] {
[17:43:52.822]     {
[17:43:52.822]         {
[17:43:52.822]             ...future.startTime <- base::Sys.time()
[17:43:52.822]             {
[17:43:52.822]                 {
[17:43:52.822]                   {
[17:43:52.822]                     base::local({
[17:43:52.822]                       has_future <- base::requireNamespace("future", 
[17:43:52.822]                         quietly = TRUE)
[17:43:52.822]                       if (has_future) {
[17:43:52.822]                         ns <- base::getNamespace("future")
[17:43:52.822]                         version <- ns[[".package"]][["version"]]
[17:43:52.822]                         if (is.null(version)) 
[17:43:52.822]                           version <- utils::packageVersion("future")
[17:43:52.822]                       }
[17:43:52.822]                       else {
[17:43:52.822]                         version <- NULL
[17:43:52.822]                       }
[17:43:52.822]                       if (!has_future || version < "1.8.0") {
[17:43:52.822]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.822]                           "", base::R.version$version.string), 
[17:43:52.822]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.822]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.822]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.822]                             "release", "version")], collapse = " "), 
[17:43:52.822]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.822]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.822]                           info)
[17:43:52.822]                         info <- base::paste(info, collapse = "; ")
[17:43:52.822]                         if (!has_future) {
[17:43:52.822]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.822]                             info)
[17:43:52.822]                         }
[17:43:52.822]                         else {
[17:43:52.822]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.822]                             info, version)
[17:43:52.822]                         }
[17:43:52.822]                         base::stop(msg)
[17:43:52.822]                       }
[17:43:52.822]                     })
[17:43:52.822]                   }
[17:43:52.822]                   ...future.strategy.old <- future::plan("list")
[17:43:52.822]                   options(future.plan = NULL)
[17:43:52.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.822]                 }
[17:43:52.822]                 ...future.workdir <- getwd()
[17:43:52.822]             }
[17:43:52.822]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.822]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.822]         }
[17:43:52.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.822]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.822]             base::names(...future.oldOptions))
[17:43:52.822]     }
[17:43:52.822]     if (FALSE) {
[17:43:52.822]     }
[17:43:52.822]     else {
[17:43:52.822]         if (TRUE) {
[17:43:52.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.822]                 open = "w")
[17:43:52.822]         }
[17:43:52.822]         else {
[17:43:52.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.822]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.822]         }
[17:43:52.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.822]             base::sink(type = "output", split = FALSE)
[17:43:52.822]             base::close(...future.stdout)
[17:43:52.822]         }, add = TRUE)
[17:43:52.822]     }
[17:43:52.822]     ...future.frame <- base::sys.nframe()
[17:43:52.822]     ...future.conditions <- base::list()
[17:43:52.822]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.822]     if (FALSE) {
[17:43:52.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.822]     }
[17:43:52.822]     ...future.result <- base::tryCatch({
[17:43:52.822]         base::withCallingHandlers({
[17:43:52.822]             ...future.value <- base::withVisible(base::local({
[17:43:52.822]                 do.call(function(...) {
[17:43:52.822]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.822]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.822]                     ...future.globals.maxSize)) {
[17:43:52.822]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.822]                     on.exit(options(oopts), add = TRUE)
[17:43:52.822]                   }
[17:43:52.822]                   {
[17:43:52.822]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.822]                       FUN = function(jj) {
[17:43:52.822]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.822]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.822]                       })
[17:43:52.822]                   }
[17:43:52.822]                 }, args = future.call.arguments)
[17:43:52.822]             }))
[17:43:52.822]             future::FutureResult(value = ...future.value$value, 
[17:43:52.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.822]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.822]                     ...future.globalenv.names))
[17:43:52.822]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.822]         }, condition = base::local({
[17:43:52.822]             c <- base::c
[17:43:52.822]             inherits <- base::inherits
[17:43:52.822]             invokeRestart <- base::invokeRestart
[17:43:52.822]             length <- base::length
[17:43:52.822]             list <- base::list
[17:43:52.822]             seq.int <- base::seq.int
[17:43:52.822]             signalCondition <- base::signalCondition
[17:43:52.822]             sys.calls <- base::sys.calls
[17:43:52.822]             `[[` <- base::`[[`
[17:43:52.822]             `+` <- base::`+`
[17:43:52.822]             `<<-` <- base::`<<-`
[17:43:52.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.822]                   3L)]
[17:43:52.822]             }
[17:43:52.822]             function(cond) {
[17:43:52.822]                 is_error <- inherits(cond, "error")
[17:43:52.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.822]                   NULL)
[17:43:52.822]                 if (is_error) {
[17:43:52.822]                   sessionInformation <- function() {
[17:43:52.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.822]                       search = base::search(), system = base::Sys.info())
[17:43:52.822]                   }
[17:43:52.822]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.822]                     cond$call), session = sessionInformation(), 
[17:43:52.822]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.822]                   signalCondition(cond)
[17:43:52.822]                 }
[17:43:52.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.822]                 "immediateCondition"))) {
[17:43:52.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.822]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.822]                   if (TRUE && !signal) {
[17:43:52.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.822]                     {
[17:43:52.822]                       inherits <- base::inherits
[17:43:52.822]                       invokeRestart <- base::invokeRestart
[17:43:52.822]                       is.null <- base::is.null
[17:43:52.822]                       muffled <- FALSE
[17:43:52.822]                       if (inherits(cond, "message")) {
[17:43:52.822]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.822]                         if (muffled) 
[17:43:52.822]                           invokeRestart("muffleMessage")
[17:43:52.822]                       }
[17:43:52.822]                       else if (inherits(cond, "warning")) {
[17:43:52.822]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.822]                         if (muffled) 
[17:43:52.822]                           invokeRestart("muffleWarning")
[17:43:52.822]                       }
[17:43:52.822]                       else if (inherits(cond, "condition")) {
[17:43:52.822]                         if (!is.null(pattern)) {
[17:43:52.822]                           computeRestarts <- base::computeRestarts
[17:43:52.822]                           grepl <- base::grepl
[17:43:52.822]                           restarts <- computeRestarts(cond)
[17:43:52.822]                           for (restart in restarts) {
[17:43:52.822]                             name <- restart$name
[17:43:52.822]                             if (is.null(name)) 
[17:43:52.822]                               next
[17:43:52.822]                             if (!grepl(pattern, name)) 
[17:43:52.822]                               next
[17:43:52.822]                             invokeRestart(restart)
[17:43:52.822]                             muffled <- TRUE
[17:43:52.822]                             break
[17:43:52.822]                           }
[17:43:52.822]                         }
[17:43:52.822]                       }
[17:43:52.822]                       invisible(muffled)
[17:43:52.822]                     }
[17:43:52.822]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.822]                   }
[17:43:52.822]                 }
[17:43:52.822]                 else {
[17:43:52.822]                   if (TRUE) {
[17:43:52.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.822]                     {
[17:43:52.822]                       inherits <- base::inherits
[17:43:52.822]                       invokeRestart <- base::invokeRestart
[17:43:52.822]                       is.null <- base::is.null
[17:43:52.822]                       muffled <- FALSE
[17:43:52.822]                       if (inherits(cond, "message")) {
[17:43:52.822]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.822]                         if (muffled) 
[17:43:52.822]                           invokeRestart("muffleMessage")
[17:43:52.822]                       }
[17:43:52.822]                       else if (inherits(cond, "warning")) {
[17:43:52.822]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.822]                         if (muffled) 
[17:43:52.822]                           invokeRestart("muffleWarning")
[17:43:52.822]                       }
[17:43:52.822]                       else if (inherits(cond, "condition")) {
[17:43:52.822]                         if (!is.null(pattern)) {
[17:43:52.822]                           computeRestarts <- base::computeRestarts
[17:43:52.822]                           grepl <- base::grepl
[17:43:52.822]                           restarts <- computeRestarts(cond)
[17:43:52.822]                           for (restart in restarts) {
[17:43:52.822]                             name <- restart$name
[17:43:52.822]                             if (is.null(name)) 
[17:43:52.822]                               next
[17:43:52.822]                             if (!grepl(pattern, name)) 
[17:43:52.822]                               next
[17:43:52.822]                             invokeRestart(restart)
[17:43:52.822]                             muffled <- TRUE
[17:43:52.822]                             break
[17:43:52.822]                           }
[17:43:52.822]                         }
[17:43:52.822]                       }
[17:43:52.822]                       invisible(muffled)
[17:43:52.822]                     }
[17:43:52.822]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.822]                   }
[17:43:52.822]                 }
[17:43:52.822]             }
[17:43:52.822]         }))
[17:43:52.822]     }, error = function(ex) {
[17:43:52.822]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.822]                 ...future.rng), started = ...future.startTime, 
[17:43:52.822]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.822]             version = "1.8"), class = "FutureResult")
[17:43:52.822]     }, finally = {
[17:43:52.822]         if (!identical(...future.workdir, getwd())) 
[17:43:52.822]             setwd(...future.workdir)
[17:43:52.822]         {
[17:43:52.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.822]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.822]             }
[17:43:52.822]             base::options(...future.oldOptions)
[17:43:52.822]             if (.Platform$OS.type == "windows") {
[17:43:52.822]                 old_names <- names(...future.oldEnvVars)
[17:43:52.822]                 envs <- base::Sys.getenv()
[17:43:52.822]                 names <- names(envs)
[17:43:52.822]                 common <- intersect(names, old_names)
[17:43:52.822]                 added <- setdiff(names, old_names)
[17:43:52.822]                 removed <- setdiff(old_names, names)
[17:43:52.822]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.822]                   envs[common]]
[17:43:52.822]                 NAMES <- toupper(changed)
[17:43:52.822]                 args <- list()
[17:43:52.822]                 for (kk in seq_along(NAMES)) {
[17:43:52.822]                   name <- changed[[kk]]
[17:43:52.822]                   NAME <- NAMES[[kk]]
[17:43:52.822]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.822]                     next
[17:43:52.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.822]                 }
[17:43:52.822]                 NAMES <- toupper(added)
[17:43:52.822]                 for (kk in seq_along(NAMES)) {
[17:43:52.822]                   name <- added[[kk]]
[17:43:52.822]                   NAME <- NAMES[[kk]]
[17:43:52.822]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.822]                     next
[17:43:52.822]                   args[[name]] <- ""
[17:43:52.822]                 }
[17:43:52.822]                 NAMES <- toupper(removed)
[17:43:52.822]                 for (kk in seq_along(NAMES)) {
[17:43:52.822]                   name <- removed[[kk]]
[17:43:52.822]                   NAME <- NAMES[[kk]]
[17:43:52.822]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.822]                     next
[17:43:52.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.822]                 }
[17:43:52.822]                 if (length(args) > 0) 
[17:43:52.822]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.822]             }
[17:43:52.822]             else {
[17:43:52.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.822]             }
[17:43:52.822]             {
[17:43:52.822]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.822]                   0L) {
[17:43:52.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.822]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.822]                   base::options(opts)
[17:43:52.822]                 }
[17:43:52.822]                 {
[17:43:52.822]                   {
[17:43:52.822]                     NULL
[17:43:52.822]                     RNGkind("Mersenne-Twister")
[17:43:52.822]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.822]                       inherits = FALSE)
[17:43:52.822]                   }
[17:43:52.822]                   options(future.plan = NULL)
[17:43:52.822]                   if (is.na(NA_character_)) 
[17:43:52.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.822]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.822]                     .init = FALSE)
[17:43:52.822]                 }
[17:43:52.822]             }
[17:43:52.822]         }
[17:43:52.822]     })
[17:43:52.822]     if (TRUE) {
[17:43:52.822]         base::sink(type = "output", split = FALSE)
[17:43:52.822]         if (TRUE) {
[17:43:52.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.822]         }
[17:43:52.822]         else {
[17:43:52.822]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.822]         }
[17:43:52.822]         base::close(...future.stdout)
[17:43:52.822]         ...future.stdout <- NULL
[17:43:52.822]     }
[17:43:52.822]     ...future.result$conditions <- ...future.conditions
[17:43:52.822]     ...future.result$finished <- base::Sys.time()
[17:43:52.822]     ...future.result
[17:43:52.822] }
[17:43:52.823] assign_globals() ...
[17:43:52.824] List of 5
[17:43:52.824]  $ ...future.FUN            :function (object, ...)  
[17:43:52.824]  $ future.call.arguments    : list()
[17:43:52.824]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.824]  $ ...future.elements_ii    :List of 3
[17:43:52.824]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.824]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.824]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.824]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.824]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.824]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.824]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.824]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.824]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.824]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.824]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.824]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.824]  $ ...future.seeds_ii       : NULL
[17:43:52.824]  $ ...future.globals.maxSize: NULL
[17:43:52.824]  - attr(*, "where")=List of 5
[17:43:52.824]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.824]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.824]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.824]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.824]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.824]  - attr(*, "resolved")= logi FALSE
[17:43:52.824]  - attr(*, "total_size")= num 1240
[17:43:52.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.824]  - attr(*, "already-done")= logi TRUE
[17:43:52.833] - copied ‘...future.FUN’ to environment
[17:43:52.833] - copied ‘future.call.arguments’ to environment
[17:43:52.833] - copied ‘...future.elements_ii’ to environment
[17:43:52.834] - copied ‘...future.seeds_ii’ to environment
[17:43:52.834] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.834] assign_globals() ... done
[17:43:52.834] plan(): Setting new future strategy stack:
[17:43:52.834] List of future strategies:
[17:43:52.834] 1. sequential:
[17:43:52.834]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.834]    - tweaked: FALSE
[17:43:52.834]    - call: NULL
[17:43:52.835] plan(): nbrOfWorkers() = 1
[17:43:52.837] plan(): Setting new future strategy stack:
[17:43:52.837] List of future strategies:
[17:43:52.837] 1. multisession:
[17:43:52.837]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:52.837]    - tweaked: FALSE
[17:43:52.837]    - call: plan(strategy)
[17:43:52.840] plan(): nbrOfWorkers() = 1
[17:43:52.840] SequentialFuture started (and completed)
[17:43:52.840] - Launch lazy future ... done
[17:43:52.841] run() for ‘SequentialFuture’ ... done
[17:43:52.841] Created future:
[17:43:52.841] SequentialFuture:
[17:43:52.841] Label: ‘future_by-1’
[17:43:52.841] Expression:
[17:43:52.841] {
[17:43:52.841]     do.call(function(...) {
[17:43:52.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.841]             on.exit(options(oopts), add = TRUE)
[17:43:52.841]         }
[17:43:52.841]         {
[17:43:52.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.841]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.841]             })
[17:43:52.841]         }
[17:43:52.841]     }, args = future.call.arguments)
[17:43:52.841] }
[17:43:52.841] Lazy evaluation: FALSE
[17:43:52.841] Asynchronous evaluation: FALSE
[17:43:52.841] Local evaluation: TRUE
[17:43:52.841] Environment: 0x55d6bab40b18
[17:43:52.841] Capture standard output: TRUE
[17:43:52.841] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.841] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.841] Packages: <none>
[17:43:52.841] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.841] Resolved: TRUE
[17:43:52.841] Value: 5.37 KiB of class ‘list’
[17:43:52.841] Early signaling: FALSE
[17:43:52.841] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.841] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.842] Chunk #1 of 1 ... DONE
[17:43:52.842] Launching 1 futures (chunks) ... DONE
[17:43:52.842] Resolving 1 futures (chunks) ...
[17:43:52.842] resolve() on list ...
[17:43:52.842]  recursive: 0
[17:43:52.842]  length: 1
[17:43:52.843] 
[17:43:52.843] resolved() for ‘SequentialFuture’ ...
[17:43:52.843] - state: ‘finished’
[17:43:52.843] - run: TRUE
[17:43:52.843] - result: ‘FutureResult’
[17:43:52.843] resolved() for ‘SequentialFuture’ ... done
[17:43:52.843] Future #1
[17:43:52.843] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.843] - nx: 1
[17:43:52.843] - relay: TRUE
[17:43:52.844] - stdout: TRUE
[17:43:52.844] - signal: TRUE
[17:43:52.844] - resignal: FALSE
[17:43:52.844] - force: TRUE
[17:43:52.844] - relayed: [n=1] FALSE
[17:43:52.844] - queued futures: [n=1] FALSE
[17:43:52.844]  - until=1
[17:43:52.844]  - relaying element #1
[17:43:52.844] - relayed: [n=1] TRUE
[17:43:52.844] - queued futures: [n=1] TRUE
[17:43:52.844] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.845]  length: 0 (resolved future 1)
[17:43:52.845] Relaying remaining futures
[17:43:52.845] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.845] - nx: 1
[17:43:52.845] - relay: TRUE
[17:43:52.845] - stdout: TRUE
[17:43:52.845] - signal: TRUE
[17:43:52.845] - resignal: FALSE
[17:43:52.845] - force: TRUE
[17:43:52.845] - relayed: [n=1] TRUE
[17:43:52.845] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.846] - relayed: [n=1] TRUE
[17:43:52.846] - queued futures: [n=1] TRUE
[17:43:52.846] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.846] resolve() on list ... DONE
[17:43:52.846]  - Number of value chunks collected: 1
[17:43:52.846] Resolving 1 futures (chunks) ... DONE
[17:43:52.846] Reducing values from 1 chunks ...
[17:43:52.846]  - Number of values collected after concatenation: 3
[17:43:52.846]  - Number of values expected: 3
[17:43:52.846] Reducing values from 1 chunks ... DONE
[17:43:52.846] future_lapply() ... DONE
[17:43:52.847] future_by_internal() ... DONE
[17:43:52.847] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[17:43:52.848] plan(): Setting new future strategy stack:
[17:43:52.848] List of future strategies:
[17:43:52.848] 1. sequential:
[17:43:52.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.848]    - tweaked: FALSE
[17:43:52.848]    - call: plan(strategy)
[17:43:52.849] plan(): nbrOfWorkers() = 1
[17:43:52.849] future_by_internal() ...
[17:43:52.849] future_lapply() ...
[17:43:52.850] Number of chunks: 1
[17:43:52.850] getGlobalsAndPackagesXApply() ...
[17:43:52.850]  - future.globals: TRUE
[17:43:52.850] getGlobalsAndPackages() ...
[17:43:52.850] Searching for globals...
[17:43:52.851] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.851] Searching for globals ... DONE
[17:43:52.851] Resolving globals: FALSE
[17:43:52.851] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.852] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.852] - globals: [1] ‘FUN’
[17:43:52.852] 
[17:43:52.852] getGlobalsAndPackages() ... DONE
[17:43:52.852]  - globals found/used: [n=1] ‘FUN’
[17:43:52.852]  - needed namespaces: [n=0] 
[17:43:52.852] Finding globals ... DONE
[17:43:52.852]  - use_args: TRUE
[17:43:52.852]  - Getting '...' globals ...
[17:43:52.853] resolve() on list ...
[17:43:52.853]  recursive: 0
[17:43:52.853]  length: 1
[17:43:52.853]  elements: ‘...’
[17:43:52.853]  length: 0 (resolved future 1)
[17:43:52.853] resolve() on list ... DONE
[17:43:52.853]    - '...' content: [n=0] 
[17:43:52.853] List of 1
[17:43:52.853]  $ ...: list()
[17:43:52.853]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.853]  - attr(*, "where")=List of 1
[17:43:52.853]   ..$ ...:<environment: 0x55d6bad3a3b8> 
[17:43:52.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.853]  - attr(*, "resolved")= logi TRUE
[17:43:52.853]  - attr(*, "total_size")= num NA
[17:43:52.857]  - Getting '...' globals ... DONE
[17:43:52.857] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.857] List of 2
[17:43:52.857]  $ ...future.FUN:function (object, ...)  
[17:43:52.857]  $ ...          : list()
[17:43:52.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.857]  - attr(*, "where")=List of 2
[17:43:52.857]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.857]   ..$ ...          :<environment: 0x55d6bad3a3b8> 
[17:43:52.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.857]  - attr(*, "resolved")= logi FALSE
[17:43:52.857]  - attr(*, "total_size")= num 1240
[17:43:52.860] Packages to be attached in all futures: [n=0] 
[17:43:52.860] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.860] Number of futures (= number of chunks): 1
[17:43:52.860] Launching 1 futures (chunks) ...
[17:43:52.860] Chunk #1 of 1 ...
[17:43:52.860]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.861] getGlobalsAndPackages() ...
[17:43:52.861] Searching for globals...
[17:43:52.861] 
[17:43:52.861] Searching for globals ... DONE
[17:43:52.861] - globals: [0] <none>
[17:43:52.861] getGlobalsAndPackages() ... DONE
[17:43:52.861]    + additional globals found: [n=0] 
[17:43:52.861]    + additional namespaces needed: [n=0] 
[17:43:52.862]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.862]  - seeds: <none>
[17:43:52.862]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.862] getGlobalsAndPackages() ...
[17:43:52.862] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.862] Resolving globals: FALSE
[17:43:52.862] Tweak future expression to call with '...' arguments ...
[17:43:52.862] {
[17:43:52.862]     do.call(function(...) {
[17:43:52.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.862]             on.exit(options(oopts), add = TRUE)
[17:43:52.862]         }
[17:43:52.862]         {
[17:43:52.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.862]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.862]             })
[17:43:52.862]         }
[17:43:52.862]     }, args = future.call.arguments)
[17:43:52.862] }
[17:43:52.862] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.863] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.863] 
[17:43:52.863] getGlobalsAndPackages() ... DONE
[17:43:52.863] run() for ‘Future’ ...
[17:43:52.863] - state: ‘created’
[17:43:52.863] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.864] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.864]   - Field: ‘label’
[17:43:52.864]   - Field: ‘local’
[17:43:52.864]   - Field: ‘owner’
[17:43:52.864]   - Field: ‘envir’
[17:43:52.864]   - Field: ‘packages’
[17:43:52.864]   - Field: ‘gc’
[17:43:52.864]   - Field: ‘conditions’
[17:43:52.865]   - Field: ‘expr’
[17:43:52.865]   - Field: ‘uuid’
[17:43:52.865]   - Field: ‘seed’
[17:43:52.865]   - Field: ‘version’
[17:43:52.865]   - Field: ‘result’
[17:43:52.865]   - Field: ‘asynchronous’
[17:43:52.865]   - Field: ‘calls’
[17:43:52.865]   - Field: ‘globals’
[17:43:52.865]   - Field: ‘stdout’
[17:43:52.865]   - Field: ‘earlySignal’
[17:43:52.865]   - Field: ‘lazy’
[17:43:52.866]   - Field: ‘state’
[17:43:52.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.866] - Launch lazy future ...
[17:43:52.866] Packages needed by the future expression (n = 0): <none>
[17:43:52.866] Packages needed by future strategies (n = 0): <none>
[17:43:52.866] {
[17:43:52.866]     {
[17:43:52.866]         {
[17:43:52.866]             ...future.startTime <- base::Sys.time()
[17:43:52.866]             {
[17:43:52.866]                 {
[17:43:52.866]                   {
[17:43:52.866]                     base::local({
[17:43:52.866]                       has_future <- base::requireNamespace("future", 
[17:43:52.866]                         quietly = TRUE)
[17:43:52.866]                       if (has_future) {
[17:43:52.866]                         ns <- base::getNamespace("future")
[17:43:52.866]                         version <- ns[[".package"]][["version"]]
[17:43:52.866]                         if (is.null(version)) 
[17:43:52.866]                           version <- utils::packageVersion("future")
[17:43:52.866]                       }
[17:43:52.866]                       else {
[17:43:52.866]                         version <- NULL
[17:43:52.866]                       }
[17:43:52.866]                       if (!has_future || version < "1.8.0") {
[17:43:52.866]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.866]                           "", base::R.version$version.string), 
[17:43:52.866]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.866]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.866]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.866]                             "release", "version")], collapse = " "), 
[17:43:52.866]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.866]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.866]                           info)
[17:43:52.866]                         info <- base::paste(info, collapse = "; ")
[17:43:52.866]                         if (!has_future) {
[17:43:52.866]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.866]                             info)
[17:43:52.866]                         }
[17:43:52.866]                         else {
[17:43:52.866]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.866]                             info, version)
[17:43:52.866]                         }
[17:43:52.866]                         base::stop(msg)
[17:43:52.866]                       }
[17:43:52.866]                     })
[17:43:52.866]                   }
[17:43:52.866]                   ...future.strategy.old <- future::plan("list")
[17:43:52.866]                   options(future.plan = NULL)
[17:43:52.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.866]                 }
[17:43:52.866]                 ...future.workdir <- getwd()
[17:43:52.866]             }
[17:43:52.866]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.866]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.866]         }
[17:43:52.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.866]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.866]             base::names(...future.oldOptions))
[17:43:52.866]     }
[17:43:52.866]     if (FALSE) {
[17:43:52.866]     }
[17:43:52.866]     else {
[17:43:52.866]         if (TRUE) {
[17:43:52.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.866]                 open = "w")
[17:43:52.866]         }
[17:43:52.866]         else {
[17:43:52.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.866]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.866]         }
[17:43:52.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.866]             base::sink(type = "output", split = FALSE)
[17:43:52.866]             base::close(...future.stdout)
[17:43:52.866]         }, add = TRUE)
[17:43:52.866]     }
[17:43:52.866]     ...future.frame <- base::sys.nframe()
[17:43:52.866]     ...future.conditions <- base::list()
[17:43:52.866]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.866]     if (FALSE) {
[17:43:52.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.866]     }
[17:43:52.866]     ...future.result <- base::tryCatch({
[17:43:52.866]         base::withCallingHandlers({
[17:43:52.866]             ...future.value <- base::withVisible(base::local({
[17:43:52.866]                 do.call(function(...) {
[17:43:52.866]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.866]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.866]                     ...future.globals.maxSize)) {
[17:43:52.866]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.866]                     on.exit(options(oopts), add = TRUE)
[17:43:52.866]                   }
[17:43:52.866]                   {
[17:43:52.866]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.866]                       FUN = function(jj) {
[17:43:52.866]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.866]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.866]                       })
[17:43:52.866]                   }
[17:43:52.866]                 }, args = future.call.arguments)
[17:43:52.866]             }))
[17:43:52.866]             future::FutureResult(value = ...future.value$value, 
[17:43:52.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.866]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.866]                     ...future.globalenv.names))
[17:43:52.866]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.866]         }, condition = base::local({
[17:43:52.866]             c <- base::c
[17:43:52.866]             inherits <- base::inherits
[17:43:52.866]             invokeRestart <- base::invokeRestart
[17:43:52.866]             length <- base::length
[17:43:52.866]             list <- base::list
[17:43:52.866]             seq.int <- base::seq.int
[17:43:52.866]             signalCondition <- base::signalCondition
[17:43:52.866]             sys.calls <- base::sys.calls
[17:43:52.866]             `[[` <- base::`[[`
[17:43:52.866]             `+` <- base::`+`
[17:43:52.866]             `<<-` <- base::`<<-`
[17:43:52.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.866]                   3L)]
[17:43:52.866]             }
[17:43:52.866]             function(cond) {
[17:43:52.866]                 is_error <- inherits(cond, "error")
[17:43:52.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.866]                   NULL)
[17:43:52.866]                 if (is_error) {
[17:43:52.866]                   sessionInformation <- function() {
[17:43:52.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.866]                       search = base::search(), system = base::Sys.info())
[17:43:52.866]                   }
[17:43:52.866]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.866]                     cond$call), session = sessionInformation(), 
[17:43:52.866]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.866]                   signalCondition(cond)
[17:43:52.866]                 }
[17:43:52.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.866]                 "immediateCondition"))) {
[17:43:52.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.866]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.866]                   if (TRUE && !signal) {
[17:43:52.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.866]                     {
[17:43:52.866]                       inherits <- base::inherits
[17:43:52.866]                       invokeRestart <- base::invokeRestart
[17:43:52.866]                       is.null <- base::is.null
[17:43:52.866]                       muffled <- FALSE
[17:43:52.866]                       if (inherits(cond, "message")) {
[17:43:52.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.866]                         if (muffled) 
[17:43:52.866]                           invokeRestart("muffleMessage")
[17:43:52.866]                       }
[17:43:52.866]                       else if (inherits(cond, "warning")) {
[17:43:52.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.866]                         if (muffled) 
[17:43:52.866]                           invokeRestart("muffleWarning")
[17:43:52.866]                       }
[17:43:52.866]                       else if (inherits(cond, "condition")) {
[17:43:52.866]                         if (!is.null(pattern)) {
[17:43:52.866]                           computeRestarts <- base::computeRestarts
[17:43:52.866]                           grepl <- base::grepl
[17:43:52.866]                           restarts <- computeRestarts(cond)
[17:43:52.866]                           for (restart in restarts) {
[17:43:52.866]                             name <- restart$name
[17:43:52.866]                             if (is.null(name)) 
[17:43:52.866]                               next
[17:43:52.866]                             if (!grepl(pattern, name)) 
[17:43:52.866]                               next
[17:43:52.866]                             invokeRestart(restart)
[17:43:52.866]                             muffled <- TRUE
[17:43:52.866]                             break
[17:43:52.866]                           }
[17:43:52.866]                         }
[17:43:52.866]                       }
[17:43:52.866]                       invisible(muffled)
[17:43:52.866]                     }
[17:43:52.866]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.866]                   }
[17:43:52.866]                 }
[17:43:52.866]                 else {
[17:43:52.866]                   if (TRUE) {
[17:43:52.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.866]                     {
[17:43:52.866]                       inherits <- base::inherits
[17:43:52.866]                       invokeRestart <- base::invokeRestart
[17:43:52.866]                       is.null <- base::is.null
[17:43:52.866]                       muffled <- FALSE
[17:43:52.866]                       if (inherits(cond, "message")) {
[17:43:52.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.866]                         if (muffled) 
[17:43:52.866]                           invokeRestart("muffleMessage")
[17:43:52.866]                       }
[17:43:52.866]                       else if (inherits(cond, "warning")) {
[17:43:52.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.866]                         if (muffled) 
[17:43:52.866]                           invokeRestart("muffleWarning")
[17:43:52.866]                       }
[17:43:52.866]                       else if (inherits(cond, "condition")) {
[17:43:52.866]                         if (!is.null(pattern)) {
[17:43:52.866]                           computeRestarts <- base::computeRestarts
[17:43:52.866]                           grepl <- base::grepl
[17:43:52.866]                           restarts <- computeRestarts(cond)
[17:43:52.866]                           for (restart in restarts) {
[17:43:52.866]                             name <- restart$name
[17:43:52.866]                             if (is.null(name)) 
[17:43:52.866]                               next
[17:43:52.866]                             if (!grepl(pattern, name)) 
[17:43:52.866]                               next
[17:43:52.866]                             invokeRestart(restart)
[17:43:52.866]                             muffled <- TRUE
[17:43:52.866]                             break
[17:43:52.866]                           }
[17:43:52.866]                         }
[17:43:52.866]                       }
[17:43:52.866]                       invisible(muffled)
[17:43:52.866]                     }
[17:43:52.866]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.866]                   }
[17:43:52.866]                 }
[17:43:52.866]             }
[17:43:52.866]         }))
[17:43:52.866]     }, error = function(ex) {
[17:43:52.866]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.866]                 ...future.rng), started = ...future.startTime, 
[17:43:52.866]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.866]             version = "1.8"), class = "FutureResult")
[17:43:52.866]     }, finally = {
[17:43:52.866]         if (!identical(...future.workdir, getwd())) 
[17:43:52.866]             setwd(...future.workdir)
[17:43:52.866]         {
[17:43:52.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.866]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.866]             }
[17:43:52.866]             base::options(...future.oldOptions)
[17:43:52.866]             if (.Platform$OS.type == "windows") {
[17:43:52.866]                 old_names <- names(...future.oldEnvVars)
[17:43:52.866]                 envs <- base::Sys.getenv()
[17:43:52.866]                 names <- names(envs)
[17:43:52.866]                 common <- intersect(names, old_names)
[17:43:52.866]                 added <- setdiff(names, old_names)
[17:43:52.866]                 removed <- setdiff(old_names, names)
[17:43:52.866]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.866]                   envs[common]]
[17:43:52.866]                 NAMES <- toupper(changed)
[17:43:52.866]                 args <- list()
[17:43:52.866]                 for (kk in seq_along(NAMES)) {
[17:43:52.866]                   name <- changed[[kk]]
[17:43:52.866]                   NAME <- NAMES[[kk]]
[17:43:52.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.866]                     next
[17:43:52.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.866]                 }
[17:43:52.866]                 NAMES <- toupper(added)
[17:43:52.866]                 for (kk in seq_along(NAMES)) {
[17:43:52.866]                   name <- added[[kk]]
[17:43:52.866]                   NAME <- NAMES[[kk]]
[17:43:52.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.866]                     next
[17:43:52.866]                   args[[name]] <- ""
[17:43:52.866]                 }
[17:43:52.866]                 NAMES <- toupper(removed)
[17:43:52.866]                 for (kk in seq_along(NAMES)) {
[17:43:52.866]                   name <- removed[[kk]]
[17:43:52.866]                   NAME <- NAMES[[kk]]
[17:43:52.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.866]                     next
[17:43:52.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.866]                 }
[17:43:52.866]                 if (length(args) > 0) 
[17:43:52.866]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.866]             }
[17:43:52.866]             else {
[17:43:52.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.866]             }
[17:43:52.866]             {
[17:43:52.866]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.866]                   0L) {
[17:43:52.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.866]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.866]                   base::options(opts)
[17:43:52.866]                 }
[17:43:52.866]                 {
[17:43:52.866]                   {
[17:43:52.866]                     NULL
[17:43:52.866]                     RNGkind("Mersenne-Twister")
[17:43:52.866]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.866]                       inherits = FALSE)
[17:43:52.866]                   }
[17:43:52.866]                   options(future.plan = NULL)
[17:43:52.866]                   if (is.na(NA_character_)) 
[17:43:52.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.866]                     .init = FALSE)
[17:43:52.866]                 }
[17:43:52.866]             }
[17:43:52.866]         }
[17:43:52.866]     })
[17:43:52.866]     if (TRUE) {
[17:43:52.866]         base::sink(type = "output", split = FALSE)
[17:43:52.866]         if (TRUE) {
[17:43:52.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.866]         }
[17:43:52.866]         else {
[17:43:52.866]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.866]         }
[17:43:52.866]         base::close(...future.stdout)
[17:43:52.866]         ...future.stdout <- NULL
[17:43:52.866]     }
[17:43:52.866]     ...future.result$conditions <- ...future.conditions
[17:43:52.866]     ...future.result$finished <- base::Sys.time()
[17:43:52.866]     ...future.result
[17:43:52.866] }
[17:43:52.868] assign_globals() ...
[17:43:52.868] List of 5
[17:43:52.868]  $ ...future.FUN            :function (object, ...)  
[17:43:52.868]  $ future.call.arguments    : list()
[17:43:52.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.868]  $ ...future.elements_ii    :List of 3
[17:43:52.868]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.868]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.868]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.868]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.868]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.868]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.868]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:52.868]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.868]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.868]  $ ...future.seeds_ii       : NULL
[17:43:52.868]  $ ...future.globals.maxSize: NULL
[17:43:52.868]  - attr(*, "where")=List of 5
[17:43:52.868]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.868]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.868]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.868]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.868]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.868]  - attr(*, "resolved")= logi FALSE
[17:43:52.868]  - attr(*, "total_size")= num 1240
[17:43:52.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.868]  - attr(*, "already-done")= logi TRUE
[17:43:52.877] - copied ‘...future.FUN’ to environment
[17:43:52.877] - copied ‘future.call.arguments’ to environment
[17:43:52.877] - copied ‘...future.elements_ii’ to environment
[17:43:52.877] - copied ‘...future.seeds_ii’ to environment
[17:43:52.877] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.878] assign_globals() ... done
[17:43:52.878] plan(): Setting new future strategy stack:
[17:43:52.878] List of future strategies:
[17:43:52.878] 1. sequential:
[17:43:52.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.878]    - tweaked: FALSE
[17:43:52.878]    - call: NULL
[17:43:52.878] plan(): nbrOfWorkers() = 1
[17:43:52.880] plan(): Setting new future strategy stack:
[17:43:52.880] List of future strategies:
[17:43:52.880] 1. sequential:
[17:43:52.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.880]    - tweaked: FALSE
[17:43:52.880]    - call: plan(strategy)
[17:43:52.881] plan(): nbrOfWorkers() = 1
[17:43:52.881] SequentialFuture started (and completed)
[17:43:52.881] - Launch lazy future ... done
[17:43:52.881] run() for ‘SequentialFuture’ ... done
[17:43:52.881] Created future:
[17:43:52.881] SequentialFuture:
[17:43:52.881] Label: ‘future_by-1’
[17:43:52.881] Expression:
[17:43:52.881] {
[17:43:52.881]     do.call(function(...) {
[17:43:52.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.881]             on.exit(options(oopts), add = TRUE)
[17:43:52.881]         }
[17:43:52.881]         {
[17:43:52.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.881]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.881]             })
[17:43:52.881]         }
[17:43:52.881]     }, args = future.call.arguments)
[17:43:52.881] }
[17:43:52.881] Lazy evaluation: FALSE
[17:43:52.881] Asynchronous evaluation: FALSE
[17:43:52.881] Local evaluation: TRUE
[17:43:52.881] Environment: R_GlobalEnv
[17:43:52.881] Capture standard output: TRUE
[17:43:52.881] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.881] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.881] Packages: <none>
[17:43:52.881] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.881] Resolved: TRUE
[17:43:52.881] Value: 4.62 KiB of class ‘list’
[17:43:52.881] Early signaling: FALSE
[17:43:52.881] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.881] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.882] Chunk #1 of 1 ... DONE
[17:43:52.883] Launching 1 futures (chunks) ... DONE
[17:43:52.883] Resolving 1 futures (chunks) ...
[17:43:52.883] resolve() on list ...
[17:43:52.883]  recursive: 0
[17:43:52.883]  length: 1
[17:43:52.883] 
[17:43:52.883] resolved() for ‘SequentialFuture’ ...
[17:43:52.883] - state: ‘finished’
[17:43:52.883] - run: TRUE
[17:43:52.883] - result: ‘FutureResult’
[17:43:52.883] resolved() for ‘SequentialFuture’ ... done
[17:43:52.884] Future #1
[17:43:52.884] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.884] - nx: 1
[17:43:52.884] - relay: TRUE
[17:43:52.884] - stdout: TRUE
[17:43:52.884] - signal: TRUE
[17:43:52.884] - resignal: FALSE
[17:43:52.884] - force: TRUE
[17:43:52.884] - relayed: [n=1] FALSE
[17:43:52.884] - queued futures: [n=1] FALSE
[17:43:52.884]  - until=1
[17:43:52.885]  - relaying element #1
[17:43:52.885] - relayed: [n=1] TRUE
[17:43:52.885] - queued futures: [n=1] TRUE
[17:43:52.885] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.885]  length: 0 (resolved future 1)
[17:43:52.885] Relaying remaining futures
[17:43:52.885] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.885] - nx: 1
[17:43:52.885] - relay: TRUE
[17:43:52.885] - stdout: TRUE
[17:43:52.885] - signal: TRUE
[17:43:52.886] - resignal: FALSE
[17:43:52.886] - force: TRUE
[17:43:52.886] - relayed: [n=1] TRUE
[17:43:52.886] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.886] - relayed: [n=1] TRUE
[17:43:52.886] - queued futures: [n=1] TRUE
[17:43:52.886] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.886] resolve() on list ... DONE
[17:43:52.886]  - Number of value chunks collected: 1
[17:43:52.886] Resolving 1 futures (chunks) ... DONE
[17:43:52.886] Reducing values from 1 chunks ...
[17:43:52.887]  - Number of values collected after concatenation: 3
[17:43:52.887]  - Number of values expected: 3
[17:43:52.887] Reducing values from 1 chunks ... DONE
[17:43:52.887] future_lapply() ... DONE
[17:43:52.887] future_by_internal() ... DONE
[17:43:52.887] future_by_internal() ...
[17:43:52.887] future_lapply() ...
[17:43:52.888] Number of chunks: 1
[17:43:52.888] getGlobalsAndPackagesXApply() ...
[17:43:52.888]  - future.globals: TRUE
[17:43:52.888] getGlobalsAndPackages() ...
[17:43:52.888] Searching for globals...
[17:43:52.889] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:52.889] Searching for globals ... DONE
[17:43:52.889] Resolving globals: FALSE
[17:43:52.890] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:52.890] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:52.890] - globals: [1] ‘FUN’
[17:43:52.890] 
[17:43:52.890] getGlobalsAndPackages() ... DONE
[17:43:52.890]  - globals found/used: [n=1] ‘FUN’
[17:43:52.890]  - needed namespaces: [n=0] 
[17:43:52.891] Finding globals ... DONE
[17:43:52.891]  - use_args: TRUE
[17:43:52.891]  - Getting '...' globals ...
[17:43:52.891] resolve() on list ...
[17:43:52.891]  recursive: 0
[17:43:52.891]  length: 1
[17:43:52.891]  elements: ‘...’
[17:43:52.891]  length: 0 (resolved future 1)
[17:43:52.892] resolve() on list ... DONE
[17:43:52.892]    - '...' content: [n=1] ‘digits’
[17:43:52.892] List of 1
[17:43:52.892]  $ ...:List of 1
[17:43:52.892]   ..$ digits: int 2
[17:43:52.892]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.892]  - attr(*, "where")=List of 1
[17:43:52.892]   ..$ ...:<environment: 0x55d6ba4f8950> 
[17:43:52.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.892]  - attr(*, "resolved")= logi TRUE
[17:43:52.892]  - attr(*, "total_size")= num NA
[17:43:52.894]  - Getting '...' globals ... DONE
[17:43:52.895] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.895] List of 2
[17:43:52.895]  $ ...future.FUN:function (object, ...)  
[17:43:52.895]  $ ...          :List of 1
[17:43:52.895]   ..$ digits: int 2
[17:43:52.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.895]  - attr(*, "where")=List of 2
[17:43:52.895]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.895]   ..$ ...          :<environment: 0x55d6ba4f8950> 
[17:43:52.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.895]  - attr(*, "resolved")= logi FALSE
[17:43:52.895]  - attr(*, "total_size")= num 1296
[17:43:52.899] Packages to be attached in all futures: [n=0] 
[17:43:52.899] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.899] Number of futures (= number of chunks): 1
[17:43:52.899] Launching 1 futures (chunks) ...
[17:43:52.899] Chunk #1 of 1 ...
[17:43:52.899]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.900] getGlobalsAndPackages() ...
[17:43:52.900] Searching for globals...
[17:43:52.900] 
[17:43:52.900] Searching for globals ... DONE
[17:43:52.900] - globals: [0] <none>
[17:43:52.900] getGlobalsAndPackages() ... DONE
[17:43:52.900]    + additional globals found: [n=0] 
[17:43:52.900]    + additional namespaces needed: [n=0] 
[17:43:52.900]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.901]  - seeds: <none>
[17:43:52.901]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.901] getGlobalsAndPackages() ...
[17:43:52.901] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.901] Resolving globals: FALSE
[17:43:52.901] Tweak future expression to call with '...' arguments ...
[17:43:52.901] {
[17:43:52.901]     do.call(function(...) {
[17:43:52.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.901]             on.exit(options(oopts), add = TRUE)
[17:43:52.901]         }
[17:43:52.901]         {
[17:43:52.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.901]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.901]             })
[17:43:52.901]         }
[17:43:52.901]     }, args = future.call.arguments)
[17:43:52.901] }
[17:43:52.901] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.902] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.902] 
[17:43:52.902] getGlobalsAndPackages() ... DONE
[17:43:52.902] run() for ‘Future’ ...
[17:43:52.902] - state: ‘created’
[17:43:52.902] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.903] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.903]   - Field: ‘label’
[17:43:52.903]   - Field: ‘local’
[17:43:52.903]   - Field: ‘owner’
[17:43:52.903]   - Field: ‘envir’
[17:43:52.903]   - Field: ‘packages’
[17:43:52.903]   - Field: ‘gc’
[17:43:52.903]   - Field: ‘conditions’
[17:43:52.903]   - Field: ‘expr’
[17:43:52.904]   - Field: ‘uuid’
[17:43:52.904]   - Field: ‘seed’
[17:43:52.904]   - Field: ‘version’
[17:43:52.904]   - Field: ‘result’
[17:43:52.904]   - Field: ‘asynchronous’
[17:43:52.904]   - Field: ‘calls’
[17:43:52.904]   - Field: ‘globals’
[17:43:52.904]   - Field: ‘stdout’
[17:43:52.904]   - Field: ‘earlySignal’
[17:43:52.904]   - Field: ‘lazy’
[17:43:52.904]   - Field: ‘state’
[17:43:52.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.905] - Launch lazy future ...
[17:43:52.905] Packages needed by the future expression (n = 0): <none>
[17:43:52.905] Packages needed by future strategies (n = 0): <none>
[17:43:52.905] {
[17:43:52.905]     {
[17:43:52.905]         {
[17:43:52.905]             ...future.startTime <- base::Sys.time()
[17:43:52.905]             {
[17:43:52.905]                 {
[17:43:52.905]                   {
[17:43:52.905]                     base::local({
[17:43:52.905]                       has_future <- base::requireNamespace("future", 
[17:43:52.905]                         quietly = TRUE)
[17:43:52.905]                       if (has_future) {
[17:43:52.905]                         ns <- base::getNamespace("future")
[17:43:52.905]                         version <- ns[[".package"]][["version"]]
[17:43:52.905]                         if (is.null(version)) 
[17:43:52.905]                           version <- utils::packageVersion("future")
[17:43:52.905]                       }
[17:43:52.905]                       else {
[17:43:52.905]                         version <- NULL
[17:43:52.905]                       }
[17:43:52.905]                       if (!has_future || version < "1.8.0") {
[17:43:52.905]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.905]                           "", base::R.version$version.string), 
[17:43:52.905]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:52.905]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.905]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.905]                             "release", "version")], collapse = " "), 
[17:43:52.905]                           hostname = base::Sys.info()[["nodename"]])
[17:43:52.905]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.905]                           info)
[17:43:52.905]                         info <- base::paste(info, collapse = "; ")
[17:43:52.905]                         if (!has_future) {
[17:43:52.905]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.905]                             info)
[17:43:52.905]                         }
[17:43:52.905]                         else {
[17:43:52.905]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.905]                             info, version)
[17:43:52.905]                         }
[17:43:52.905]                         base::stop(msg)
[17:43:52.905]                       }
[17:43:52.905]                     })
[17:43:52.905]                   }
[17:43:52.905]                   ...future.strategy.old <- future::plan("list")
[17:43:52.905]                   options(future.plan = NULL)
[17:43:52.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.905]                 }
[17:43:52.905]                 ...future.workdir <- getwd()
[17:43:52.905]             }
[17:43:52.905]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.905]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.905]         }
[17:43:52.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.905]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.905]             base::names(...future.oldOptions))
[17:43:52.905]     }
[17:43:52.905]     if (FALSE) {
[17:43:52.905]     }
[17:43:52.905]     else {
[17:43:52.905]         if (TRUE) {
[17:43:52.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.905]                 open = "w")
[17:43:52.905]         }
[17:43:52.905]         else {
[17:43:52.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.905]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.905]         }
[17:43:52.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.905]             base::sink(type = "output", split = FALSE)
[17:43:52.905]             base::close(...future.stdout)
[17:43:52.905]         }, add = TRUE)
[17:43:52.905]     }
[17:43:52.905]     ...future.frame <- base::sys.nframe()
[17:43:52.905]     ...future.conditions <- base::list()
[17:43:52.905]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.905]     if (FALSE) {
[17:43:52.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.905]     }
[17:43:52.905]     ...future.result <- base::tryCatch({
[17:43:52.905]         base::withCallingHandlers({
[17:43:52.905]             ...future.value <- base::withVisible(base::local({
[17:43:52.905]                 do.call(function(...) {
[17:43:52.905]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.905]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.905]                     ...future.globals.maxSize)) {
[17:43:52.905]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.905]                     on.exit(options(oopts), add = TRUE)
[17:43:52.905]                   }
[17:43:52.905]                   {
[17:43:52.905]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.905]                       FUN = function(jj) {
[17:43:52.905]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.905]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.905]                       })
[17:43:52.905]                   }
[17:43:52.905]                 }, args = future.call.arguments)
[17:43:52.905]             }))
[17:43:52.905]             future::FutureResult(value = ...future.value$value, 
[17:43:52.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.905]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.905]                     ...future.globalenv.names))
[17:43:52.905]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.905]         }, condition = base::local({
[17:43:52.905]             c <- base::c
[17:43:52.905]             inherits <- base::inherits
[17:43:52.905]             invokeRestart <- base::invokeRestart
[17:43:52.905]             length <- base::length
[17:43:52.905]             list <- base::list
[17:43:52.905]             seq.int <- base::seq.int
[17:43:52.905]             signalCondition <- base::signalCondition
[17:43:52.905]             sys.calls <- base::sys.calls
[17:43:52.905]             `[[` <- base::`[[`
[17:43:52.905]             `+` <- base::`+`
[17:43:52.905]             `<<-` <- base::`<<-`
[17:43:52.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.905]                   3L)]
[17:43:52.905]             }
[17:43:52.905]             function(cond) {
[17:43:52.905]                 is_error <- inherits(cond, "error")
[17:43:52.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.905]                   NULL)
[17:43:52.905]                 if (is_error) {
[17:43:52.905]                   sessionInformation <- function() {
[17:43:52.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.905]                       search = base::search(), system = base::Sys.info())
[17:43:52.905]                   }
[17:43:52.905]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.905]                     cond$call), session = sessionInformation(), 
[17:43:52.905]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.905]                   signalCondition(cond)
[17:43:52.905]                 }
[17:43:52.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.905]                 "immediateCondition"))) {
[17:43:52.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.905]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.905]                   if (TRUE && !signal) {
[17:43:52.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.905]                     {
[17:43:52.905]                       inherits <- base::inherits
[17:43:52.905]                       invokeRestart <- base::invokeRestart
[17:43:52.905]                       is.null <- base::is.null
[17:43:52.905]                       muffled <- FALSE
[17:43:52.905]                       if (inherits(cond, "message")) {
[17:43:52.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.905]                         if (muffled) 
[17:43:52.905]                           invokeRestart("muffleMessage")
[17:43:52.905]                       }
[17:43:52.905]                       else if (inherits(cond, "warning")) {
[17:43:52.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.905]                         if (muffled) 
[17:43:52.905]                           invokeRestart("muffleWarning")
[17:43:52.905]                       }
[17:43:52.905]                       else if (inherits(cond, "condition")) {
[17:43:52.905]                         if (!is.null(pattern)) {
[17:43:52.905]                           computeRestarts <- base::computeRestarts
[17:43:52.905]                           grepl <- base::grepl
[17:43:52.905]                           restarts <- computeRestarts(cond)
[17:43:52.905]                           for (restart in restarts) {
[17:43:52.905]                             name <- restart$name
[17:43:52.905]                             if (is.null(name)) 
[17:43:52.905]                               next
[17:43:52.905]                             if (!grepl(pattern, name)) 
[17:43:52.905]                               next
[17:43:52.905]                             invokeRestart(restart)
[17:43:52.905]                             muffled <- TRUE
[17:43:52.905]                             break
[17:43:52.905]                           }
[17:43:52.905]                         }
[17:43:52.905]                       }
[17:43:52.905]                       invisible(muffled)
[17:43:52.905]                     }
[17:43:52.905]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.905]                   }
[17:43:52.905]                 }
[17:43:52.905]                 else {
[17:43:52.905]                   if (TRUE) {
[17:43:52.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.905]                     {
[17:43:52.905]                       inherits <- base::inherits
[17:43:52.905]                       invokeRestart <- base::invokeRestart
[17:43:52.905]                       is.null <- base::is.null
[17:43:52.905]                       muffled <- FALSE
[17:43:52.905]                       if (inherits(cond, "message")) {
[17:43:52.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.905]                         if (muffled) 
[17:43:52.905]                           invokeRestart("muffleMessage")
[17:43:52.905]                       }
[17:43:52.905]                       else if (inherits(cond, "warning")) {
[17:43:52.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.905]                         if (muffled) 
[17:43:52.905]                           invokeRestart("muffleWarning")
[17:43:52.905]                       }
[17:43:52.905]                       else if (inherits(cond, "condition")) {
[17:43:52.905]                         if (!is.null(pattern)) {
[17:43:52.905]                           computeRestarts <- base::computeRestarts
[17:43:52.905]                           grepl <- base::grepl
[17:43:52.905]                           restarts <- computeRestarts(cond)
[17:43:52.905]                           for (restart in restarts) {
[17:43:52.905]                             name <- restart$name
[17:43:52.905]                             if (is.null(name)) 
[17:43:52.905]                               next
[17:43:52.905]                             if (!grepl(pattern, name)) 
[17:43:52.905]                               next
[17:43:52.905]                             invokeRestart(restart)
[17:43:52.905]                             muffled <- TRUE
[17:43:52.905]                             break
[17:43:52.905]                           }
[17:43:52.905]                         }
[17:43:52.905]                       }
[17:43:52.905]                       invisible(muffled)
[17:43:52.905]                     }
[17:43:52.905]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.905]                   }
[17:43:52.905]                 }
[17:43:52.905]             }
[17:43:52.905]         }))
[17:43:52.905]     }, error = function(ex) {
[17:43:52.905]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.905]                 ...future.rng), started = ...future.startTime, 
[17:43:52.905]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.905]             version = "1.8"), class = "FutureResult")
[17:43:52.905]     }, finally = {
[17:43:52.905]         if (!identical(...future.workdir, getwd())) 
[17:43:52.905]             setwd(...future.workdir)
[17:43:52.905]         {
[17:43:52.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.905]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.905]             }
[17:43:52.905]             base::options(...future.oldOptions)
[17:43:52.905]             if (.Platform$OS.type == "windows") {
[17:43:52.905]                 old_names <- names(...future.oldEnvVars)
[17:43:52.905]                 envs <- base::Sys.getenv()
[17:43:52.905]                 names <- names(envs)
[17:43:52.905]                 common <- intersect(names, old_names)
[17:43:52.905]                 added <- setdiff(names, old_names)
[17:43:52.905]                 removed <- setdiff(old_names, names)
[17:43:52.905]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.905]                   envs[common]]
[17:43:52.905]                 NAMES <- toupper(changed)
[17:43:52.905]                 args <- list()
[17:43:52.905]                 for (kk in seq_along(NAMES)) {
[17:43:52.905]                   name <- changed[[kk]]
[17:43:52.905]                   NAME <- NAMES[[kk]]
[17:43:52.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.905]                     next
[17:43:52.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.905]                 }
[17:43:52.905]                 NAMES <- toupper(added)
[17:43:52.905]                 for (kk in seq_along(NAMES)) {
[17:43:52.905]                   name <- added[[kk]]
[17:43:52.905]                   NAME <- NAMES[[kk]]
[17:43:52.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.905]                     next
[17:43:52.905]                   args[[name]] <- ""
[17:43:52.905]                 }
[17:43:52.905]                 NAMES <- toupper(removed)
[17:43:52.905]                 for (kk in seq_along(NAMES)) {
[17:43:52.905]                   name <- removed[[kk]]
[17:43:52.905]                   NAME <- NAMES[[kk]]
[17:43:52.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.905]                     next
[17:43:52.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.905]                 }
[17:43:52.905]                 if (length(args) > 0) 
[17:43:52.905]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.905]             }
[17:43:52.905]             else {
[17:43:52.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.905]             }
[17:43:52.905]             {
[17:43:52.905]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.905]                   0L) {
[17:43:52.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.905]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.905]                   base::options(opts)
[17:43:52.905]                 }
[17:43:52.905]                 {
[17:43:52.905]                   {
[17:43:52.905]                     NULL
[17:43:52.905]                     RNGkind("Mersenne-Twister")
[17:43:52.905]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.905]                       inherits = FALSE)
[17:43:52.905]                   }
[17:43:52.905]                   options(future.plan = NULL)
[17:43:52.905]                   if (is.na(NA_character_)) 
[17:43:52.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.905]                     .init = FALSE)
[17:43:52.905]                 }
[17:43:52.905]             }
[17:43:52.905]         }
[17:43:52.905]     })
[17:43:52.905]     if (TRUE) {
[17:43:52.905]         base::sink(type = "output", split = FALSE)
[17:43:52.905]         if (TRUE) {
[17:43:52.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.905]         }
[17:43:52.905]         else {
[17:43:52.905]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.905]         }
[17:43:52.905]         base::close(...future.stdout)
[17:43:52.905]         ...future.stdout <- NULL
[17:43:52.905]     }
[17:43:52.905]     ...future.result$conditions <- ...future.conditions
[17:43:52.905]     ...future.result$finished <- base::Sys.time()
[17:43:52.905]     ...future.result
[17:43:52.905] }
[17:43:52.907] assign_globals() ...
[17:43:52.907] List of 5
[17:43:52.907]  $ ...future.FUN            :function (object, ...)  
[17:43:52.907]  $ future.call.arguments    :List of 1
[17:43:52.907]   ..$ digits: int 2
[17:43:52.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.907]  $ ...future.elements_ii    :List of 6
[17:43:52.907]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:43:52.907]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:43:52.907]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:43:52.907]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:43:52.907]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:43:52.907]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:43:52.907]  $ ...future.seeds_ii       : NULL
[17:43:52.907]  $ ...future.globals.maxSize: NULL
[17:43:52.907]  - attr(*, "where")=List of 5
[17:43:52.907]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.907]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.907]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.907]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.907]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.907]  - attr(*, "resolved")= logi FALSE
[17:43:52.907]  - attr(*, "total_size")= num 1296
[17:43:52.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.907]  - attr(*, "already-done")= logi TRUE
[17:43:52.913] - copied ‘...future.FUN’ to environment
[17:43:52.913] - copied ‘future.call.arguments’ to environment
[17:43:52.913] - copied ‘...future.elements_ii’ to environment
[17:43:52.913] - copied ‘...future.seeds_ii’ to environment
[17:43:52.913] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.913] assign_globals() ... done
[17:43:52.914] plan(): Setting new future strategy stack:
[17:43:52.914] List of future strategies:
[17:43:52.914] 1. sequential:
[17:43:52.914]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.914]    - tweaked: FALSE
[17:43:52.914]    - call: NULL
[17:43:52.914] plan(): nbrOfWorkers() = 1
[17:43:52.915] plan(): Setting new future strategy stack:
[17:43:52.916] List of future strategies:
[17:43:52.916] 1. sequential:
[17:43:52.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.916]    - tweaked: FALSE
[17:43:52.916]    - call: plan(strategy)
[17:43:52.916] plan(): nbrOfWorkers() = 1
[17:43:52.916] SequentialFuture started (and completed)
[17:43:52.916] - Launch lazy future ... done
[17:43:52.916] run() for ‘SequentialFuture’ ... done
[17:43:52.916] Created future:
[17:43:52.916] SequentialFuture:
[17:43:52.916] Label: ‘future_by-1’
[17:43:52.916] Expression:
[17:43:52.916] {
[17:43:52.916]     do.call(function(...) {
[17:43:52.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.916]             on.exit(options(oopts), add = TRUE)
[17:43:52.916]         }
[17:43:52.916]         {
[17:43:52.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.916]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.916]             })
[17:43:52.916]         }
[17:43:52.916]     }, args = future.call.arguments)
[17:43:52.916] }
[17:43:52.916] Lazy evaluation: FALSE
[17:43:52.916] Asynchronous evaluation: FALSE
[17:43:52.916] Local evaluation: TRUE
[17:43:52.916] Environment: R_GlobalEnv
[17:43:52.916] Capture standard output: TRUE
[17:43:52.916] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.916] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.916] Packages: <none>
[17:43:52.916] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.916] Resolved: TRUE
[17:43:52.916] Value: 5.48 KiB of class ‘list’
[17:43:52.916] Early signaling: FALSE
[17:43:52.916] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.916] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.917] Chunk #1 of 1 ... DONE
[17:43:52.918] Launching 1 futures (chunks) ... DONE
[17:43:52.918] Resolving 1 futures (chunks) ...
[17:43:52.918] resolve() on list ...
[17:43:52.918]  recursive: 0
[17:43:52.918]  length: 1
[17:43:52.918] 
[17:43:52.918] resolved() for ‘SequentialFuture’ ...
[17:43:52.918] - state: ‘finished’
[17:43:52.918] - run: TRUE
[17:43:52.918] - result: ‘FutureResult’
[17:43:52.918] resolved() for ‘SequentialFuture’ ... done
[17:43:52.918] Future #1
[17:43:52.919] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.920] - nx: 1
[17:43:52.920] - relay: TRUE
[17:43:52.920] - stdout: TRUE
[17:43:52.920] - signal: TRUE
[17:43:52.920] - resignal: FALSE
[17:43:52.920] - force: TRUE
[17:43:52.920] - relayed: [n=1] FALSE
[17:43:52.920] - queued futures: [n=1] FALSE
[17:43:52.920]  - until=1
[17:43:52.920]  - relaying element #1
[17:43:52.921] - relayed: [n=1] TRUE
[17:43:52.921] - queued futures: [n=1] TRUE
[17:43:52.921] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.921]  length: 0 (resolved future 1)
[17:43:52.921] Relaying remaining futures
[17:43:52.921] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.921] - nx: 1
[17:43:52.921] - relay: TRUE
[17:43:52.921] - stdout: TRUE
[17:43:52.921] - signal: TRUE
[17:43:52.922] - resignal: FALSE
[17:43:52.922] - force: TRUE
[17:43:52.922] - relayed: [n=1] TRUE
[17:43:52.922] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.922] - relayed: [n=1] TRUE
[17:43:52.922] - queued futures: [n=1] TRUE
[17:43:52.922] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.922] resolve() on list ... DONE
[17:43:52.922]  - Number of value chunks collected: 1
[17:43:52.922] Resolving 1 futures (chunks) ... DONE
[17:43:52.922] Reducing values from 1 chunks ...
[17:43:52.923]  - Number of values collected after concatenation: 6
[17:43:52.923]  - Number of values expected: 6
[17:43:52.923] Reducing values from 1 chunks ... DONE
[17:43:52.923] future_lapply() ... DONE
[17:43:52.923] future_by_internal() ... DONE
[17:43:52.924] future_by_internal() ...
[17:43:52.924] future_lapply() ...
[17:43:52.925] Number of chunks: 1
[17:43:52.925] getGlobalsAndPackagesXApply() ...
[17:43:52.925]  - future.globals: TRUE
[17:43:52.925] getGlobalsAndPackages() ...
[17:43:52.925] Searching for globals...
[17:43:52.927] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.927] Searching for globals ... DONE
[17:43:52.927] Resolving globals: FALSE
[17:43:52.927] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:43:52.928] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:43:52.928] - globals: [1] ‘FUN’
[17:43:52.928] - packages: [1] ‘stats’
[17:43:52.928] getGlobalsAndPackages() ... DONE
[17:43:52.928]  - globals found/used: [n=1] ‘FUN’
[17:43:52.928]  - needed namespaces: [n=1] ‘stats’
[17:43:52.928] Finding globals ... DONE
[17:43:52.928]  - use_args: TRUE
[17:43:52.929]  - Getting '...' globals ...
[17:43:52.929] resolve() on list ...
[17:43:52.929]  recursive: 0
[17:43:52.929]  length: 1
[17:43:52.929]  elements: ‘...’
[17:43:52.929]  length: 0 (resolved future 1)
[17:43:52.929] resolve() on list ... DONE
[17:43:52.929]    - '...' content: [n=1] ‘singular.ok’
[17:43:52.929] List of 1
[17:43:52.929]  $ ...:List of 1
[17:43:52.929]   ..$ singular.ok: logi FALSE
[17:43:52.929]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.929]  - attr(*, "where")=List of 1
[17:43:52.929]   ..$ ...:<environment: 0x55d6ba00c710> 
[17:43:52.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.929]  - attr(*, "resolved")= logi TRUE
[17:43:52.929]  - attr(*, "total_size")= num NA
[17:43:52.932]  - Getting '...' globals ... DONE
[17:43:52.932] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:52.932] List of 2
[17:43:52.932]  $ ...future.FUN:function (x, ...)  
[17:43:52.932]  $ ...          :List of 1
[17:43:52.932]   ..$ singular.ok: logi FALSE
[17:43:52.932]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.932]  - attr(*, "where")=List of 2
[17:43:52.932]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.932]   ..$ ...          :<environment: 0x55d6ba00c710> 
[17:43:52.932]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.932]  - attr(*, "resolved")= logi FALSE
[17:43:52.932]  - attr(*, "total_size")= num 5384
[17:43:52.935] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.935] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.935] Number of futures (= number of chunks): 1
[17:43:52.936] Launching 1 futures (chunks) ...
[17:43:52.936] Chunk #1 of 1 ...
[17:43:52.936]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.936] getGlobalsAndPackages() ...
[17:43:52.936] Searching for globals...
[17:43:52.936] 
[17:43:52.936] Searching for globals ... DONE
[17:43:52.937] - globals: [0] <none>
[17:43:52.937] getGlobalsAndPackages() ... DONE
[17:43:52.937]    + additional globals found: [n=0] 
[17:43:52.937]    + additional namespaces needed: [n=0] 
[17:43:52.937]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.937]  - seeds: <none>
[17:43:52.937]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.937] getGlobalsAndPackages() ...
[17:43:52.937] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.937] Resolving globals: FALSE
[17:43:52.937] Tweak future expression to call with '...' arguments ...
[17:43:52.938] {
[17:43:52.938]     do.call(function(...) {
[17:43:52.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.938]             on.exit(options(oopts), add = TRUE)
[17:43:52.938]         }
[17:43:52.938]         {
[17:43:52.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.938]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.938]             })
[17:43:52.938]         }
[17:43:52.938]     }, args = future.call.arguments)
[17:43:52.938] }
[17:43:52.938] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.938] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.939] 
[17:43:52.939] getGlobalsAndPackages() ... DONE
[17:43:52.940] run() for ‘Future’ ...
[17:43:52.940] - state: ‘created’
[17:43:52.940] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.940] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.940]   - Field: ‘label’
[17:43:52.940]   - Field: ‘local’
[17:43:52.941]   - Field: ‘owner’
[17:43:52.941]   - Field: ‘envir’
[17:43:52.941]   - Field: ‘packages’
[17:43:52.941]   - Field: ‘gc’
[17:43:52.941]   - Field: ‘conditions’
[17:43:52.941]   - Field: ‘expr’
[17:43:52.941]   - Field: ‘uuid’
[17:43:52.941]   - Field: ‘seed’
[17:43:52.941]   - Field: ‘version’
[17:43:52.941]   - Field: ‘result’
[17:43:52.941]   - Field: ‘asynchronous’
[17:43:52.942]   - Field: ‘calls’
[17:43:52.942]   - Field: ‘globals’
[17:43:52.942]   - Field: ‘stdout’
[17:43:52.942]   - Field: ‘earlySignal’
[17:43:52.942]   - Field: ‘lazy’
[17:43:52.942]   - Field: ‘state’
[17:43:52.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.942] - Launch lazy future ...
[17:43:52.942] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.943] Packages needed by future strategies (n = 0): <none>
[17:43:52.943] {
[17:43:52.943]     {
[17:43:52.943]         {
[17:43:52.943]             ...future.startTime <- base::Sys.time()
[17:43:52.943]             {
[17:43:52.943]                 {
[17:43:52.943]                   {
[17:43:52.943]                     {
[17:43:52.943]                       base::local({
[17:43:52.943]                         has_future <- base::requireNamespace("future", 
[17:43:52.943]                           quietly = TRUE)
[17:43:52.943]                         if (has_future) {
[17:43:52.943]                           ns <- base::getNamespace("future")
[17:43:52.943]                           version <- ns[[".package"]][["version"]]
[17:43:52.943]                           if (is.null(version)) 
[17:43:52.943]                             version <- utils::packageVersion("future")
[17:43:52.943]                         }
[17:43:52.943]                         else {
[17:43:52.943]                           version <- NULL
[17:43:52.943]                         }
[17:43:52.943]                         if (!has_future || version < "1.8.0") {
[17:43:52.943]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.943]                             "", base::R.version$version.string), 
[17:43:52.943]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.943]                               "release", "version")], collapse = " "), 
[17:43:52.943]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.943]                             info)
[17:43:52.943]                           info <- base::paste(info, collapse = "; ")
[17:43:52.943]                           if (!has_future) {
[17:43:52.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.943]                               info)
[17:43:52.943]                           }
[17:43:52.943]                           else {
[17:43:52.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.943]                               info, version)
[17:43:52.943]                           }
[17:43:52.943]                           base::stop(msg)
[17:43:52.943]                         }
[17:43:52.943]                       })
[17:43:52.943]                     }
[17:43:52.943]                     base::local({
[17:43:52.943]                       for (pkg in "stats") {
[17:43:52.943]                         base::loadNamespace(pkg)
[17:43:52.943]                         base::library(pkg, character.only = TRUE)
[17:43:52.943]                       }
[17:43:52.943]                     })
[17:43:52.943]                   }
[17:43:52.943]                   ...future.strategy.old <- future::plan("list")
[17:43:52.943]                   options(future.plan = NULL)
[17:43:52.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.943]                 }
[17:43:52.943]                 ...future.workdir <- getwd()
[17:43:52.943]             }
[17:43:52.943]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.943]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.943]         }
[17:43:52.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.943]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.943]             base::names(...future.oldOptions))
[17:43:52.943]     }
[17:43:52.943]     if (FALSE) {
[17:43:52.943]     }
[17:43:52.943]     else {
[17:43:52.943]         if (TRUE) {
[17:43:52.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.943]                 open = "w")
[17:43:52.943]         }
[17:43:52.943]         else {
[17:43:52.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.943]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.943]         }
[17:43:52.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.943]             base::sink(type = "output", split = FALSE)
[17:43:52.943]             base::close(...future.stdout)
[17:43:52.943]         }, add = TRUE)
[17:43:52.943]     }
[17:43:52.943]     ...future.frame <- base::sys.nframe()
[17:43:52.943]     ...future.conditions <- base::list()
[17:43:52.943]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.943]     if (FALSE) {
[17:43:52.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.943]     }
[17:43:52.943]     ...future.result <- base::tryCatch({
[17:43:52.943]         base::withCallingHandlers({
[17:43:52.943]             ...future.value <- base::withVisible(base::local({
[17:43:52.943]                 do.call(function(...) {
[17:43:52.943]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.943]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.943]                     ...future.globals.maxSize)) {
[17:43:52.943]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.943]                     on.exit(options(oopts), add = TRUE)
[17:43:52.943]                   }
[17:43:52.943]                   {
[17:43:52.943]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.943]                       FUN = function(jj) {
[17:43:52.943]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.943]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.943]                       })
[17:43:52.943]                   }
[17:43:52.943]                 }, args = future.call.arguments)
[17:43:52.943]             }))
[17:43:52.943]             future::FutureResult(value = ...future.value$value, 
[17:43:52.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.943]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.943]                     ...future.globalenv.names))
[17:43:52.943]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.943]         }, condition = base::local({
[17:43:52.943]             c <- base::c
[17:43:52.943]             inherits <- base::inherits
[17:43:52.943]             invokeRestart <- base::invokeRestart
[17:43:52.943]             length <- base::length
[17:43:52.943]             list <- base::list
[17:43:52.943]             seq.int <- base::seq.int
[17:43:52.943]             signalCondition <- base::signalCondition
[17:43:52.943]             sys.calls <- base::sys.calls
[17:43:52.943]             `[[` <- base::`[[`
[17:43:52.943]             `+` <- base::`+`
[17:43:52.943]             `<<-` <- base::`<<-`
[17:43:52.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.943]                   3L)]
[17:43:52.943]             }
[17:43:52.943]             function(cond) {
[17:43:52.943]                 is_error <- inherits(cond, "error")
[17:43:52.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.943]                   NULL)
[17:43:52.943]                 if (is_error) {
[17:43:52.943]                   sessionInformation <- function() {
[17:43:52.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.943]                       search = base::search(), system = base::Sys.info())
[17:43:52.943]                   }
[17:43:52.943]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.943]                     cond$call), session = sessionInformation(), 
[17:43:52.943]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.943]                   signalCondition(cond)
[17:43:52.943]                 }
[17:43:52.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.943]                 "immediateCondition"))) {
[17:43:52.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.943]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.943]                   if (TRUE && !signal) {
[17:43:52.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.943]                     {
[17:43:52.943]                       inherits <- base::inherits
[17:43:52.943]                       invokeRestart <- base::invokeRestart
[17:43:52.943]                       is.null <- base::is.null
[17:43:52.943]                       muffled <- FALSE
[17:43:52.943]                       if (inherits(cond, "message")) {
[17:43:52.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.943]                         if (muffled) 
[17:43:52.943]                           invokeRestart("muffleMessage")
[17:43:52.943]                       }
[17:43:52.943]                       else if (inherits(cond, "warning")) {
[17:43:52.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.943]                         if (muffled) 
[17:43:52.943]                           invokeRestart("muffleWarning")
[17:43:52.943]                       }
[17:43:52.943]                       else if (inherits(cond, "condition")) {
[17:43:52.943]                         if (!is.null(pattern)) {
[17:43:52.943]                           computeRestarts <- base::computeRestarts
[17:43:52.943]                           grepl <- base::grepl
[17:43:52.943]                           restarts <- computeRestarts(cond)
[17:43:52.943]                           for (restart in restarts) {
[17:43:52.943]                             name <- restart$name
[17:43:52.943]                             if (is.null(name)) 
[17:43:52.943]                               next
[17:43:52.943]                             if (!grepl(pattern, name)) 
[17:43:52.943]                               next
[17:43:52.943]                             invokeRestart(restart)
[17:43:52.943]                             muffled <- TRUE
[17:43:52.943]                             break
[17:43:52.943]                           }
[17:43:52.943]                         }
[17:43:52.943]                       }
[17:43:52.943]                       invisible(muffled)
[17:43:52.943]                     }
[17:43:52.943]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.943]                   }
[17:43:52.943]                 }
[17:43:52.943]                 else {
[17:43:52.943]                   if (TRUE) {
[17:43:52.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.943]                     {
[17:43:52.943]                       inherits <- base::inherits
[17:43:52.943]                       invokeRestart <- base::invokeRestart
[17:43:52.943]                       is.null <- base::is.null
[17:43:52.943]                       muffled <- FALSE
[17:43:52.943]                       if (inherits(cond, "message")) {
[17:43:52.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.943]                         if (muffled) 
[17:43:52.943]                           invokeRestart("muffleMessage")
[17:43:52.943]                       }
[17:43:52.943]                       else if (inherits(cond, "warning")) {
[17:43:52.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.943]                         if (muffled) 
[17:43:52.943]                           invokeRestart("muffleWarning")
[17:43:52.943]                       }
[17:43:52.943]                       else if (inherits(cond, "condition")) {
[17:43:52.943]                         if (!is.null(pattern)) {
[17:43:52.943]                           computeRestarts <- base::computeRestarts
[17:43:52.943]                           grepl <- base::grepl
[17:43:52.943]                           restarts <- computeRestarts(cond)
[17:43:52.943]                           for (restart in restarts) {
[17:43:52.943]                             name <- restart$name
[17:43:52.943]                             if (is.null(name)) 
[17:43:52.943]                               next
[17:43:52.943]                             if (!grepl(pattern, name)) 
[17:43:52.943]                               next
[17:43:52.943]                             invokeRestart(restart)
[17:43:52.943]                             muffled <- TRUE
[17:43:52.943]                             break
[17:43:52.943]                           }
[17:43:52.943]                         }
[17:43:52.943]                       }
[17:43:52.943]                       invisible(muffled)
[17:43:52.943]                     }
[17:43:52.943]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.943]                   }
[17:43:52.943]                 }
[17:43:52.943]             }
[17:43:52.943]         }))
[17:43:52.943]     }, error = function(ex) {
[17:43:52.943]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.943]                 ...future.rng), started = ...future.startTime, 
[17:43:52.943]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.943]             version = "1.8"), class = "FutureResult")
[17:43:52.943]     }, finally = {
[17:43:52.943]         if (!identical(...future.workdir, getwd())) 
[17:43:52.943]             setwd(...future.workdir)
[17:43:52.943]         {
[17:43:52.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.943]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.943]             }
[17:43:52.943]             base::options(...future.oldOptions)
[17:43:52.943]             if (.Platform$OS.type == "windows") {
[17:43:52.943]                 old_names <- names(...future.oldEnvVars)
[17:43:52.943]                 envs <- base::Sys.getenv()
[17:43:52.943]                 names <- names(envs)
[17:43:52.943]                 common <- intersect(names, old_names)
[17:43:52.943]                 added <- setdiff(names, old_names)
[17:43:52.943]                 removed <- setdiff(old_names, names)
[17:43:52.943]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.943]                   envs[common]]
[17:43:52.943]                 NAMES <- toupper(changed)
[17:43:52.943]                 args <- list()
[17:43:52.943]                 for (kk in seq_along(NAMES)) {
[17:43:52.943]                   name <- changed[[kk]]
[17:43:52.943]                   NAME <- NAMES[[kk]]
[17:43:52.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.943]                     next
[17:43:52.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.943]                 }
[17:43:52.943]                 NAMES <- toupper(added)
[17:43:52.943]                 for (kk in seq_along(NAMES)) {
[17:43:52.943]                   name <- added[[kk]]
[17:43:52.943]                   NAME <- NAMES[[kk]]
[17:43:52.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.943]                     next
[17:43:52.943]                   args[[name]] <- ""
[17:43:52.943]                 }
[17:43:52.943]                 NAMES <- toupper(removed)
[17:43:52.943]                 for (kk in seq_along(NAMES)) {
[17:43:52.943]                   name <- removed[[kk]]
[17:43:52.943]                   NAME <- NAMES[[kk]]
[17:43:52.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.943]                     next
[17:43:52.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.943]                 }
[17:43:52.943]                 if (length(args) > 0) 
[17:43:52.943]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.943]             }
[17:43:52.943]             else {
[17:43:52.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.943]             }
[17:43:52.943]             {
[17:43:52.943]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.943]                   0L) {
[17:43:52.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.943]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.943]                   base::options(opts)
[17:43:52.943]                 }
[17:43:52.943]                 {
[17:43:52.943]                   {
[17:43:52.943]                     NULL
[17:43:52.943]                     RNGkind("Mersenne-Twister")
[17:43:52.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.943]                       inherits = FALSE)
[17:43:52.943]                   }
[17:43:52.943]                   options(future.plan = NULL)
[17:43:52.943]                   if (is.na(NA_character_)) 
[17:43:52.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.943]                     .init = FALSE)
[17:43:52.943]                 }
[17:43:52.943]             }
[17:43:52.943]         }
[17:43:52.943]     })
[17:43:52.943]     if (TRUE) {
[17:43:52.943]         base::sink(type = "output", split = FALSE)
[17:43:52.943]         if (TRUE) {
[17:43:52.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.943]         }
[17:43:52.943]         else {
[17:43:52.943]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.943]         }
[17:43:52.943]         base::close(...future.stdout)
[17:43:52.943]         ...future.stdout <- NULL
[17:43:52.943]     }
[17:43:52.943]     ...future.result$conditions <- ...future.conditions
[17:43:52.943]     ...future.result$finished <- base::Sys.time()
[17:43:52.943]     ...future.result
[17:43:52.943] }
[17:43:52.945] assign_globals() ...
[17:43:52.945] List of 5
[17:43:52.945]  $ ...future.FUN            :function (x, ...)  
[17:43:52.945]  $ future.call.arguments    :List of 1
[17:43:52.945]   ..$ singular.ok: logi FALSE
[17:43:52.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.945]  $ ...future.elements_ii    :List of 3
[17:43:52.945]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.945]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.945]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.945]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.945]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.945]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.945]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.945]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.945]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.945]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.945]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.945]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.945]  $ ...future.seeds_ii       : NULL
[17:43:52.945]  $ ...future.globals.maxSize: NULL
[17:43:52.945]  - attr(*, "where")=List of 5
[17:43:52.945]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.945]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.945]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.945]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.945]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.945]  - attr(*, "resolved")= logi FALSE
[17:43:52.945]  - attr(*, "total_size")= num 5384
[17:43:52.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.945]  - attr(*, "already-done")= logi TRUE
[17:43:52.953] - reassign environment for ‘...future.FUN’
[17:43:52.953] - copied ‘...future.FUN’ to environment
[17:43:52.953] - copied ‘future.call.arguments’ to environment
[17:43:52.953] - copied ‘...future.elements_ii’ to environment
[17:43:52.953] - copied ‘...future.seeds_ii’ to environment
[17:43:52.954] - copied ‘...future.globals.maxSize’ to environment
[17:43:52.954] assign_globals() ... done
[17:43:52.954] plan(): Setting new future strategy stack:
[17:43:52.954] List of future strategies:
[17:43:52.954] 1. sequential:
[17:43:52.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.954]    - tweaked: FALSE
[17:43:52.954]    - call: NULL
[17:43:52.954] plan(): nbrOfWorkers() = 1
[17:43:52.957] plan(): Setting new future strategy stack:
[17:43:52.957] List of future strategies:
[17:43:52.957] 1. sequential:
[17:43:52.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:52.957]    - tweaked: FALSE
[17:43:52.957]    - call: plan(strategy)
[17:43:52.958] plan(): nbrOfWorkers() = 1
[17:43:52.958] SequentialFuture started (and completed)
[17:43:52.958] - Launch lazy future ... done
[17:43:52.958] run() for ‘SequentialFuture’ ... done
[17:43:52.958] Created future:
[17:43:52.958] SequentialFuture:
[17:43:52.958] Label: ‘future_by-1’
[17:43:52.958] Expression:
[17:43:52.958] {
[17:43:52.958]     do.call(function(...) {
[17:43:52.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.958]             on.exit(options(oopts), add = TRUE)
[17:43:52.958]         }
[17:43:52.958]         {
[17:43:52.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.958]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.958]             })
[17:43:52.958]         }
[17:43:52.958]     }, args = future.call.arguments)
[17:43:52.958] }
[17:43:52.958] Lazy evaluation: FALSE
[17:43:52.958] Asynchronous evaluation: FALSE
[17:43:52.958] Local evaluation: TRUE
[17:43:52.958] Environment: R_GlobalEnv
[17:43:52.958] Capture standard output: TRUE
[17:43:52.958] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:52.958] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:52.958] Packages: 1 packages (‘stats’)
[17:43:52.958] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:52.958] Resolved: TRUE
[17:43:52.958] Value: 26.06 KiB of class ‘list’
[17:43:52.958] Early signaling: FALSE
[17:43:52.958] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:52.958] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.960] Chunk #1 of 1 ... DONE
[17:43:52.960] Launching 1 futures (chunks) ... DONE
[17:43:52.960] Resolving 1 futures (chunks) ...
[17:43:52.960] resolve() on list ...
[17:43:52.960]  recursive: 0
[17:43:52.961]  length: 1
[17:43:52.961] 
[17:43:52.961] resolved() for ‘SequentialFuture’ ...
[17:43:52.961] - state: ‘finished’
[17:43:52.962] - run: TRUE
[17:43:52.962] - result: ‘FutureResult’
[17:43:52.962] resolved() for ‘SequentialFuture’ ... done
[17:43:52.962] Future #1
[17:43:52.962] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:52.962] - nx: 1
[17:43:52.962] - relay: TRUE
[17:43:52.962] - stdout: TRUE
[17:43:52.962] - signal: TRUE
[17:43:52.962] - resignal: FALSE
[17:43:52.962] - force: TRUE
[17:43:52.963] - relayed: [n=1] FALSE
[17:43:52.963] - queued futures: [n=1] FALSE
[17:43:52.963]  - until=1
[17:43:52.963]  - relaying element #1
[17:43:52.963] - relayed: [n=1] TRUE
[17:43:52.963] - queued futures: [n=1] TRUE
[17:43:52.963] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:52.963]  length: 0 (resolved future 1)
[17:43:52.963] Relaying remaining futures
[17:43:52.964] signalConditionsASAP(NULL, pos=0) ...
[17:43:52.964] - nx: 1
[17:43:52.964] - relay: TRUE
[17:43:52.964] - stdout: TRUE
[17:43:52.964] - signal: TRUE
[17:43:52.964] - resignal: FALSE
[17:43:52.964] - force: TRUE
[17:43:52.964] - relayed: [n=1] TRUE
[17:43:52.964] - queued futures: [n=1] TRUE
 - flush all
[17:43:52.964] - relayed: [n=1] TRUE
[17:43:52.964] - queued futures: [n=1] TRUE
[17:43:52.964] signalConditionsASAP(NULL, pos=0) ... done
[17:43:52.965] resolve() on list ... DONE
[17:43:52.965]  - Number of value chunks collected: 1
[17:43:52.965] Resolving 1 futures (chunks) ... DONE
[17:43:52.965] Reducing values from 1 chunks ...
[17:43:52.965]  - Number of values collected after concatenation: 3
[17:43:52.965]  - Number of values expected: 3
[17:43:52.965] Reducing values from 1 chunks ... DONE
[17:43:52.965] future_lapply() ... DONE
[17:43:52.965] future_by_internal() ... DONE
[17:43:52.969] future_by_internal() ...
[17:43:52.969] future_lapply() ...
[17:43:52.970] Number of chunks: 1
[17:43:52.970] getGlobalsAndPackagesXApply() ...
[17:43:52.970]  - future.globals: TRUE
[17:43:52.970] getGlobalsAndPackages() ...
[17:43:52.970] Searching for globals...
[17:43:52.972] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:52.972] Searching for globals ... DONE
[17:43:52.972] Resolving globals: FALSE
[17:43:52.973] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:43:52.973] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:43:52.973] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.973] - packages: [1] ‘stats’
[17:43:52.973] getGlobalsAndPackages() ... DONE
[17:43:52.973]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:52.973]  - needed namespaces: [n=1] ‘stats’
[17:43:52.973] Finding globals ... DONE
[17:43:52.974]  - use_args: TRUE
[17:43:52.974]  - Getting '...' globals ...
[17:43:52.974] resolve() on list ...
[17:43:52.974]  recursive: 0
[17:43:52.974]  length: 1
[17:43:52.974]  elements: ‘...’
[17:43:52.974]  length: 0 (resolved future 1)
[17:43:52.974] resolve() on list ... DONE
[17:43:52.974]    - '...' content: [n=0] 
[17:43:52.975] List of 1
[17:43:52.975]  $ ...: list()
[17:43:52.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.975]  - attr(*, "where")=List of 1
[17:43:52.975]   ..$ ...:<environment: 0x55d6ba44dff0> 
[17:43:52.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.975]  - attr(*, "resolved")= logi TRUE
[17:43:52.975]  - attr(*, "total_size")= num NA
[17:43:52.977]  - Getting '...' globals ... DONE
[17:43:52.977] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:43:52.977] List of 4
[17:43:52.977]  $ ...future.FUN:function (x)  
[17:43:52.977]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.977]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.977]  $ ...          : list()
[17:43:52.977]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.977]  - attr(*, "where")=List of 4
[17:43:52.977]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:52.977]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:43:52.977]   ..$ wool         :<environment: R_EmptyEnv> 
[17:43:52.977]   ..$ ...          :<environment: 0x55d6ba44dff0> 
[17:43:52.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.977]  - attr(*, "resolved")= logi FALSE
[17:43:52.977]  - attr(*, "total_size")= num 2320
[17:43:52.982] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:52.983] getGlobalsAndPackagesXApply() ... DONE
[17:43:52.983] Number of futures (= number of chunks): 1
[17:43:52.983] Launching 1 futures (chunks) ...
[17:43:52.983] Chunk #1 of 1 ...
[17:43:52.983]  - Finding globals in 'X' for chunk #1 ...
[17:43:52.983] getGlobalsAndPackages() ...
[17:43:52.983] Searching for globals...
[17:43:52.984] 
[17:43:52.984] Searching for globals ... DONE
[17:43:52.984] - globals: [0] <none>
[17:43:52.984] getGlobalsAndPackages() ... DONE
[17:43:52.984]    + additional globals found: [n=0] 
[17:43:52.984]    + additional namespaces needed: [n=0] 
[17:43:52.984]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:52.985]  - seeds: <none>
[17:43:52.985]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.985] getGlobalsAndPackages() ...
[17:43:52.985] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.985] Resolving globals: FALSE
[17:43:52.985] Tweak future expression to call with '...' arguments ...
[17:43:52.985] {
[17:43:52.985]     do.call(function(...) {
[17:43:52.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:52.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.985]             on.exit(options(oopts), add = TRUE)
[17:43:52.985]         }
[17:43:52.985]         {
[17:43:52.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:52.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.985]                 ...future.FUN(...future.X_jj, ...)
[17:43:52.985]             })
[17:43:52.985]         }
[17:43:52.985]     }, args = future.call.arguments)
[17:43:52.985] }
[17:43:52.985] Tweak future expression to call with '...' arguments ... DONE
[17:43:52.986] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:52.986] 
[17:43:52.986] getGlobalsAndPackages() ... DONE
[17:43:52.986] run() for ‘Future’ ...
[17:43:52.986] - state: ‘created’
[17:43:52.986] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:52.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:52.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:52.987]   - Field: ‘label’
[17:43:52.987]   - Field: ‘local’
[17:43:52.987]   - Field: ‘owner’
[17:43:52.987]   - Field: ‘envir’
[17:43:52.987]   - Field: ‘packages’
[17:43:52.987]   - Field: ‘gc’
[17:43:52.988]   - Field: ‘conditions’
[17:43:52.988]   - Field: ‘expr’
[17:43:52.988]   - Field: ‘uuid’
[17:43:52.988]   - Field: ‘seed’
[17:43:52.988]   - Field: ‘version’
[17:43:52.988]   - Field: ‘result’
[17:43:52.988]   - Field: ‘asynchronous’
[17:43:52.988]   - Field: ‘calls’
[17:43:52.988]   - Field: ‘globals’
[17:43:52.988]   - Field: ‘stdout’
[17:43:52.988]   - Field: ‘earlySignal’
[17:43:52.989]   - Field: ‘lazy’
[17:43:52.989]   - Field: ‘state’
[17:43:52.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:52.989] - Launch lazy future ...
[17:43:52.989] Packages needed by the future expression (n = 1): ‘stats’
[17:43:52.989] Packages needed by future strategies (n = 0): <none>
[17:43:52.990] {
[17:43:52.990]     {
[17:43:52.990]         {
[17:43:52.990]             ...future.startTime <- base::Sys.time()
[17:43:52.990]             {
[17:43:52.990]                 {
[17:43:52.990]                   {
[17:43:52.990]                     {
[17:43:52.990]                       base::local({
[17:43:52.990]                         has_future <- base::requireNamespace("future", 
[17:43:52.990]                           quietly = TRUE)
[17:43:52.990]                         if (has_future) {
[17:43:52.990]                           ns <- base::getNamespace("future")
[17:43:52.990]                           version <- ns[[".package"]][["version"]]
[17:43:52.990]                           if (is.null(version)) 
[17:43:52.990]                             version <- utils::packageVersion("future")
[17:43:52.990]                         }
[17:43:52.990]                         else {
[17:43:52.990]                           version <- NULL
[17:43:52.990]                         }
[17:43:52.990]                         if (!has_future || version < "1.8.0") {
[17:43:52.990]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.990]                             "", base::R.version$version.string), 
[17:43:52.990]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.990]                               "release", "version")], collapse = " "), 
[17:43:52.990]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.990]                             info)
[17:43:52.990]                           info <- base::paste(info, collapse = "; ")
[17:43:52.990]                           if (!has_future) {
[17:43:52.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.990]                               info)
[17:43:52.990]                           }
[17:43:52.990]                           else {
[17:43:52.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.990]                               info, version)
[17:43:52.990]                           }
[17:43:52.990]                           base::stop(msg)
[17:43:52.990]                         }
[17:43:52.990]                       })
[17:43:52.990]                     }
[17:43:52.990]                     base::local({
[17:43:52.990]                       for (pkg in "stats") {
[17:43:52.990]                         base::loadNamespace(pkg)
[17:43:52.990]                         base::library(pkg, character.only = TRUE)
[17:43:52.990]                       }
[17:43:52.990]                     })
[17:43:52.990]                   }
[17:43:52.990]                   ...future.strategy.old <- future::plan("list")
[17:43:52.990]                   options(future.plan = NULL)
[17:43:52.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.990]                 }
[17:43:52.990]                 ...future.workdir <- getwd()
[17:43:52.990]             }
[17:43:52.990]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.990]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.990]         }
[17:43:52.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.990]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.990]             base::names(...future.oldOptions))
[17:43:52.990]     }
[17:43:52.990]     if (FALSE) {
[17:43:52.990]     }
[17:43:52.990]     else {
[17:43:52.990]         if (TRUE) {
[17:43:52.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.990]                 open = "w")
[17:43:52.990]         }
[17:43:52.990]         else {
[17:43:52.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.990]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.990]         }
[17:43:52.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.990]             base::sink(type = "output", split = FALSE)
[17:43:52.990]             base::close(...future.stdout)
[17:43:52.990]         }, add = TRUE)
[17:43:52.990]     }
[17:43:52.990]     ...future.frame <- base::sys.nframe()
[17:43:52.990]     ...future.conditions <- base::list()
[17:43:52.990]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.990]     if (FALSE) {
[17:43:52.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.990]     }
[17:43:52.990]     ...future.result <- base::tryCatch({
[17:43:52.990]         base::withCallingHandlers({
[17:43:52.990]             ...future.value <- base::withVisible(base::local({
[17:43:52.990]                 do.call(function(...) {
[17:43:52.990]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:52.990]                   if (!identical(...future.globals.maxSize.org, 
[17:43:52.990]                     ...future.globals.maxSize)) {
[17:43:52.990]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:52.990]                     on.exit(options(oopts), add = TRUE)
[17:43:52.990]                   }
[17:43:52.990]                   {
[17:43:52.990]                     lapply(seq_along(...future.elements_ii), 
[17:43:52.990]                       FUN = function(jj) {
[17:43:52.990]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:52.990]                         ...future.FUN(...future.X_jj, ...)
[17:43:52.990]                       })
[17:43:52.990]                   }
[17:43:52.990]                 }, args = future.call.arguments)
[17:43:52.990]             }))
[17:43:52.990]             future::FutureResult(value = ...future.value$value, 
[17:43:52.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.990]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.990]                     ...future.globalenv.names))
[17:43:52.990]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.990]         }, condition = base::local({
[17:43:52.990]             c <- base::c
[17:43:52.990]             inherits <- base::inherits
[17:43:52.990]             invokeRestart <- base::invokeRestart
[17:43:52.990]             length <- base::length
[17:43:52.990]             list <- base::list
[17:43:52.990]             seq.int <- base::seq.int
[17:43:52.990]             signalCondition <- base::signalCondition
[17:43:52.990]             sys.calls <- base::sys.calls
[17:43:52.990]             `[[` <- base::`[[`
[17:43:52.990]             `+` <- base::`+`
[17:43:52.990]             `<<-` <- base::`<<-`
[17:43:52.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.990]                   3L)]
[17:43:52.990]             }
[17:43:52.990]             function(cond) {
[17:43:52.990]                 is_error <- inherits(cond, "error")
[17:43:52.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.990]                   NULL)
[17:43:52.990]                 if (is_error) {
[17:43:52.990]                   sessionInformation <- function() {
[17:43:52.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.990]                       search = base::search(), system = base::Sys.info())
[17:43:52.990]                   }
[17:43:52.990]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.990]                     cond$call), session = sessionInformation(), 
[17:43:52.990]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.990]                   signalCondition(cond)
[17:43:52.990]                 }
[17:43:52.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.990]                 "immediateCondition"))) {
[17:43:52.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.990]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.990]                   if (TRUE && !signal) {
[17:43:52.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.990]                     {
[17:43:52.990]                       inherits <- base::inherits
[17:43:52.990]                       invokeRestart <- base::invokeRestart
[17:43:52.990]                       is.null <- base::is.null
[17:43:52.990]                       muffled <- FALSE
[17:43:52.990]                       if (inherits(cond, "message")) {
[17:43:52.990]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.990]                         if (muffled) 
[17:43:52.990]                           invokeRestart("muffleMessage")
[17:43:52.990]                       }
[17:43:52.990]                       else if (inherits(cond, "warning")) {
[17:43:52.990]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.990]                         if (muffled) 
[17:43:52.990]                           invokeRestart("muffleWarning")
[17:43:52.990]                       }
[17:43:52.990]                       else if (inherits(cond, "condition")) {
[17:43:52.990]                         if (!is.null(pattern)) {
[17:43:52.990]                           computeRestarts <- base::computeRestarts
[17:43:52.990]                           grepl <- base::grepl
[17:43:52.990]                           restarts <- computeRestarts(cond)
[17:43:52.990]                           for (restart in restarts) {
[17:43:52.990]                             name <- restart$name
[17:43:52.990]                             if (is.null(name)) 
[17:43:52.990]                               next
[17:43:52.990]                             if (!grepl(pattern, name)) 
[17:43:52.990]                               next
[17:43:52.990]                             invokeRestart(restart)
[17:43:52.990]                             muffled <- TRUE
[17:43:52.990]                             break
[17:43:52.990]                           }
[17:43:52.990]                         }
[17:43:52.990]                       }
[17:43:52.990]                       invisible(muffled)
[17:43:52.990]                     }
[17:43:52.990]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.990]                   }
[17:43:52.990]                 }
[17:43:52.990]                 else {
[17:43:52.990]                   if (TRUE) {
[17:43:52.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.990]                     {
[17:43:52.990]                       inherits <- base::inherits
[17:43:52.990]                       invokeRestart <- base::invokeRestart
[17:43:52.990]                       is.null <- base::is.null
[17:43:52.990]                       muffled <- FALSE
[17:43:52.990]                       if (inherits(cond, "message")) {
[17:43:52.990]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.990]                         if (muffled) 
[17:43:52.990]                           invokeRestart("muffleMessage")
[17:43:52.990]                       }
[17:43:52.990]                       else if (inherits(cond, "warning")) {
[17:43:52.990]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.990]                         if (muffled) 
[17:43:52.990]                           invokeRestart("muffleWarning")
[17:43:52.990]                       }
[17:43:52.990]                       else if (inherits(cond, "condition")) {
[17:43:52.990]                         if (!is.null(pattern)) {
[17:43:52.990]                           computeRestarts <- base::computeRestarts
[17:43:52.990]                           grepl <- base::grepl
[17:43:52.990]                           restarts <- computeRestarts(cond)
[17:43:52.990]                           for (restart in restarts) {
[17:43:52.990]                             name <- restart$name
[17:43:52.990]                             if (is.null(name)) 
[17:43:52.990]                               next
[17:43:52.990]                             if (!grepl(pattern, name)) 
[17:43:52.990]                               next
[17:43:52.990]                             invokeRestart(restart)
[17:43:52.990]                             muffled <- TRUE
[17:43:52.990]                             break
[17:43:52.990]                           }
[17:43:52.990]                         }
[17:43:52.990]                       }
[17:43:52.990]                       invisible(muffled)
[17:43:52.990]                     }
[17:43:52.990]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.990]                   }
[17:43:52.990]                 }
[17:43:52.990]             }
[17:43:52.990]         }))
[17:43:52.990]     }, error = function(ex) {
[17:43:52.990]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.990]                 ...future.rng), started = ...future.startTime, 
[17:43:52.990]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.990]             version = "1.8"), class = "FutureResult")
[17:43:52.990]     }, finally = {
[17:43:52.990]         if (!identical(...future.workdir, getwd())) 
[17:43:52.990]             setwd(...future.workdir)
[17:43:52.990]         {
[17:43:52.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.990]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.990]             }
[17:43:52.990]             base::options(...future.oldOptions)
[17:43:52.990]             if (.Platform$OS.type == "windows") {
[17:43:52.990]                 old_names <- names(...future.oldEnvVars)
[17:43:52.990]                 envs <- base::Sys.getenv()
[17:43:52.990]                 names <- names(envs)
[17:43:52.990]                 common <- intersect(names, old_names)
[17:43:52.990]                 added <- setdiff(names, old_names)
[17:43:52.990]                 removed <- setdiff(old_names, names)
[17:43:52.990]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.990]                   envs[common]]
[17:43:52.990]                 NAMES <- toupper(changed)
[17:43:52.990]                 args <- list()
[17:43:52.990]                 for (kk in seq_along(NAMES)) {
[17:43:52.990]                   name <- changed[[kk]]
[17:43:52.990]                   NAME <- NAMES[[kk]]
[17:43:52.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.990]                     next
[17:43:52.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.990]                 }
[17:43:52.990]                 NAMES <- toupper(added)
[17:43:52.990]                 for (kk in seq_along(NAMES)) {
[17:43:52.990]                   name <- added[[kk]]
[17:43:52.990]                   NAME <- NAMES[[kk]]
[17:43:52.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.990]                     next
[17:43:52.990]                   args[[name]] <- ""
[17:43:52.990]                 }
[17:43:52.990]                 NAMES <- toupper(removed)
[17:43:52.990]                 for (kk in seq_along(NAMES)) {
[17:43:52.990]                   name <- removed[[kk]]
[17:43:52.990]                   NAME <- NAMES[[kk]]
[17:43:52.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.990]                     next
[17:43:52.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.990]                 }
[17:43:52.990]                 if (length(args) > 0) 
[17:43:52.990]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.990]             }
[17:43:52.990]             else {
[17:43:52.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.990]             }
[17:43:52.990]             {
[17:43:52.990]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.990]                   0L) {
[17:43:52.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.990]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.990]                   base::options(opts)
[17:43:52.990]                 }
[17:43:52.990]                 {
[17:43:52.990]                   {
[17:43:52.990]                     NULL
[17:43:52.990]                     RNGkind("Mersenne-Twister")
[17:43:52.990]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:52.990]                       inherits = FALSE)
[17:43:52.990]                   }
[17:43:52.990]                   options(future.plan = NULL)
[17:43:52.990]                   if (is.na(NA_character_)) 
[17:43:52.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:52.990]                     .init = FALSE)
[17:43:52.990]                 }
[17:43:52.990]             }
[17:43:52.990]         }
[17:43:52.990]     })
[17:43:52.990]     if (TRUE) {
[17:43:52.990]         base::sink(type = "output", split = FALSE)
[17:43:52.990]         if (TRUE) {
[17:43:52.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.990]         }
[17:43:52.990]         else {
[17:43:52.990]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.990]         }
[17:43:52.990]         base::close(...future.stdout)
[17:43:52.990]         ...future.stdout <- NULL
[17:43:52.990]     }
[17:43:52.990]     ...future.result$conditions <- ...future.conditions
[17:43:52.990]     ...future.result$finished <- base::Sys.time()
[17:43:52.990]     ...future.result
[17:43:52.990] }
[17:43:52.991] assign_globals() ...
[17:43:52.991] List of 7
[17:43:52.991]  $ ...future.FUN            :function (x)  
[17:43:52.991]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:52.991]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.991]  $ future.call.arguments    : list()
[17:43:52.991]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:52.991]  $ ...future.elements_ii    :List of 3
[17:43:52.991]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.991]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:52.991]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.991]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:52.991]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.991]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:52.991]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.991]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:52.991]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:52.991]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:52.991]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:52.991]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:52.991]  $ ...future.seeds_ii       : NULL
[17:43:52.991]  $ ...future.globals.maxSize: NULL
[17:43:52.991]  - attr(*, "where")=List of 7
[17:43:52.991]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:52.991]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:43:52.991]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:43:52.991]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:52.991]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:52.991]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:52.991]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:52.991]  - attr(*, "resolved")= logi FALSE
[17:43:52.991]  - attr(*, "total_size")= num 2320
[17:43:52.991]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:52.991]  - attr(*, "already-done")= logi TRUE
[17:43:53.002] - reassign environment for ‘...future.FUN’
[17:43:53.002] - copied ‘...future.FUN’ to environment
[17:43:53.002] - copied ‘breaks’ to environment
[17:43:53.002] - copied ‘wool’ to environment
[17:43:53.003] - copied ‘future.call.arguments’ to environment
[17:43:53.003] - copied ‘...future.elements_ii’ to environment
[17:43:53.003] - copied ‘...future.seeds_ii’ to environment
[17:43:53.003] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.003] assign_globals() ... done
[17:43:53.003] plan(): Setting new future strategy stack:
[17:43:53.004] List of future strategies:
[17:43:53.004] 1. sequential:
[17:43:53.004]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.004]    - tweaked: FALSE
[17:43:53.004]    - call: NULL
[17:43:53.004] plan(): nbrOfWorkers() = 1
[17:43:53.007] plan(): Setting new future strategy stack:
[17:43:53.007] List of future strategies:
[17:43:53.007] 1. sequential:
[17:43:53.007]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.007]    - tweaked: FALSE
[17:43:53.007]    - call: plan(strategy)
[17:43:53.007] plan(): nbrOfWorkers() = 1
[17:43:53.008] SequentialFuture started (and completed)
[17:43:53.008] - Launch lazy future ... done
[17:43:53.008] run() for ‘SequentialFuture’ ... done
[17:43:53.008] Created future:
[17:43:53.008] SequentialFuture:
[17:43:53.008] Label: ‘future_by-1’
[17:43:53.008] Expression:
[17:43:53.008] {
[17:43:53.008]     do.call(function(...) {
[17:43:53.008]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.008]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.008]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.008]             on.exit(options(oopts), add = TRUE)
[17:43:53.008]         }
[17:43:53.008]         {
[17:43:53.008]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.008]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.008]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.008]             })
[17:43:53.008]         }
[17:43:53.008]     }, args = future.call.arguments)
[17:43:53.008] }
[17:43:53.008] Lazy evaluation: FALSE
[17:43:53.008] Asynchronous evaluation: FALSE
[17:43:53.008] Local evaluation: TRUE
[17:43:53.008] Environment: 0x55d6ba4037d0
[17:43:53.008] Capture standard output: TRUE
[17:43:53.008] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.008] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:43:53.008] Packages: 1 packages (‘stats’)
[17:43:53.008] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.008] Resolved: TRUE
[17:43:53.008] Value: 25.57 KiB of class ‘list’
[17:43:53.008] Early signaling: FALSE
[17:43:53.008] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.008] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:53.009] Chunk #1 of 1 ... DONE
[17:43:53.010] Launching 1 futures (chunks) ... DONE
[17:43:53.010] Resolving 1 futures (chunks) ...
[17:43:53.010] resolve() on list ...
[17:43:53.010]  recursive: 0
[17:43:53.010]  length: 1
[17:43:53.010] 
[17:43:53.010] resolved() for ‘SequentialFuture’ ...
[17:43:53.010] - state: ‘finished’
[17:43:53.010] - run: TRUE
[17:43:53.010] - result: ‘FutureResult’
[17:43:53.011] resolved() for ‘SequentialFuture’ ... done
[17:43:53.011] Future #1
[17:43:53.011] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:53.011] - nx: 1
[17:43:53.011] - relay: TRUE
[17:43:53.011] - stdout: TRUE
[17:43:53.011] - signal: TRUE
[17:43:53.011] - resignal: FALSE
[17:43:53.011] - force: TRUE
[17:43:53.011] - relayed: [n=1] FALSE
[17:43:53.011] - queued futures: [n=1] FALSE
[17:43:53.012]  - until=1
[17:43:53.012]  - relaying element #1
[17:43:53.012] - relayed: [n=1] TRUE
[17:43:53.012] - queued futures: [n=1] TRUE
[17:43:53.012] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:53.012]  length: 0 (resolved future 1)
[17:43:53.012] Relaying remaining futures
[17:43:53.012] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.012] - nx: 1
[17:43:53.012] - relay: TRUE
[17:43:53.013] - stdout: TRUE
[17:43:53.013] - signal: TRUE
[17:43:53.013] - resignal: FALSE
[17:43:53.013] - force: TRUE
[17:43:53.013] - relayed: [n=1] TRUE
[17:43:53.013] - queued futures: [n=1] TRUE
 - flush all
[17:43:53.013] - relayed: [n=1] TRUE
[17:43:53.013] - queued futures: [n=1] TRUE
[17:43:53.013] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.013] resolve() on list ... DONE
[17:43:53.013]  - Number of value chunks collected: 1
[17:43:53.014] Resolving 1 futures (chunks) ... DONE
[17:43:53.014] Reducing values from 1 chunks ...
[17:43:53.014]  - Number of values collected after concatenation: 3
[17:43:53.014]  - Number of values expected: 3
[17:43:53.014] Reducing values from 1 chunks ... DONE
[17:43:53.014] future_lapply() ... DONE
[17:43:53.014] future_by_internal() ... DONE
[17:43:53.014] future_by_internal() ...
[17:43:53.015] future_lapply() ...
[17:43:53.015] Number of chunks: 1
[17:43:53.015] getGlobalsAndPackagesXApply() ...
[17:43:53.016]  - future.globals: TRUE
[17:43:53.016] getGlobalsAndPackages() ...
[17:43:53.016] Searching for globals...
[17:43:53.017] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:53.017] Searching for globals ... DONE
[17:43:53.017] Resolving globals: FALSE
[17:43:53.017] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:53.018] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:53.018] - globals: [1] ‘FUN’
[17:43:53.018] 
[17:43:53.018] getGlobalsAndPackages() ... DONE
[17:43:53.018]  - globals found/used: [n=1] ‘FUN’
[17:43:53.018]  - needed namespaces: [n=0] 
[17:43:53.018] Finding globals ... DONE
[17:43:53.018]  - use_args: TRUE
[17:43:53.018]  - Getting '...' globals ...
[17:43:53.019] resolve() on list ...
[17:43:53.019]  recursive: 0
[17:43:53.019]  length: 1
[17:43:53.019]  elements: ‘...’
[17:43:53.019]  length: 0 (resolved future 1)
[17:43:53.019] resolve() on list ... DONE
[17:43:53.019]    - '...' content: [n=0] 
[17:43:53.019] List of 1
[17:43:53.019]  $ ...: list()
[17:43:53.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.019]  - attr(*, "where")=List of 1
[17:43:53.019]   ..$ ...:<environment: 0x55d6baac3e30> 
[17:43:53.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.019]  - attr(*, "resolved")= logi TRUE
[17:43:53.019]  - attr(*, "total_size")= num NA
[17:43:53.022]  - Getting '...' globals ... DONE
[17:43:53.022] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.022] List of 2
[17:43:53.022]  $ ...future.FUN:function (object, ...)  
[17:43:53.022]  $ ...          : list()
[17:43:53.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.022]  - attr(*, "where")=List of 2
[17:43:53.022]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.022]   ..$ ...          :<environment: 0x55d6baac3e30> 
[17:43:53.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.022]  - attr(*, "resolved")= logi FALSE
[17:43:53.022]  - attr(*, "total_size")= num 1240
[17:43:53.026] Packages to be attached in all futures: [n=0] 
[17:43:53.026] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.027] Number of futures (= number of chunks): 1
[17:43:53.027] Launching 1 futures (chunks) ...
[17:43:53.027] Chunk #1 of 1 ...
[17:43:53.027]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.027] getGlobalsAndPackages() ...
[17:43:53.027] Searching for globals...
[17:43:53.028] 
[17:43:53.028] Searching for globals ... DONE
[17:43:53.028] - globals: [0] <none>
[17:43:53.028] getGlobalsAndPackages() ... DONE
[17:43:53.028]    + additional globals found: [n=0] 
[17:43:53.028]    + additional namespaces needed: [n=0] 
[17:43:53.028]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.028]  - seeds: <none>
[17:43:53.028]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.028] getGlobalsAndPackages() ...
[17:43:53.028] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.029] Resolving globals: FALSE
[17:43:53.029] Tweak future expression to call with '...' arguments ...
[17:43:53.029] {
[17:43:53.029]     do.call(function(...) {
[17:43:53.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.029]             on.exit(options(oopts), add = TRUE)
[17:43:53.029]         }
[17:43:53.029]         {
[17:43:53.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.029]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.029]             })
[17:43:53.029]         }
[17:43:53.029]     }, args = future.call.arguments)
[17:43:53.029] }
[17:43:53.029] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.029] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.029] 
[17:43:53.030] getGlobalsAndPackages() ... DONE
[17:43:53.030] run() for ‘Future’ ...
[17:43:53.030] - state: ‘created’
[17:43:53.030] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:53.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:53.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:53.031]   - Field: ‘label’
[17:43:53.031]   - Field: ‘local’
[17:43:53.031]   - Field: ‘owner’
[17:43:53.031]   - Field: ‘envir’
[17:43:53.031]   - Field: ‘packages’
[17:43:53.031]   - Field: ‘gc’
[17:43:53.031]   - Field: ‘conditions’
[17:43:53.031]   - Field: ‘expr’
[17:43:53.031]   - Field: ‘uuid’
[17:43:53.031]   - Field: ‘seed’
[17:43:53.031]   - Field: ‘version’
[17:43:53.032]   - Field: ‘result’
[17:43:53.032]   - Field: ‘asynchronous’
[17:43:53.032]   - Field: ‘calls’
[17:43:53.032]   - Field: ‘globals’
[17:43:53.032]   - Field: ‘stdout’
[17:43:53.032]   - Field: ‘earlySignal’
[17:43:53.032]   - Field: ‘lazy’
[17:43:53.032]   - Field: ‘state’
[17:43:53.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:53.032] - Launch lazy future ...
[17:43:53.033] Packages needed by the future expression (n = 0): <none>
[17:43:53.033] Packages needed by future strategies (n = 0): <none>
[17:43:53.033] {
[17:43:53.033]     {
[17:43:53.033]         {
[17:43:53.033]             ...future.startTime <- base::Sys.time()
[17:43:53.033]             {
[17:43:53.033]                 {
[17:43:53.033]                   {
[17:43:53.033]                     base::local({
[17:43:53.033]                       has_future <- base::requireNamespace("future", 
[17:43:53.033]                         quietly = TRUE)
[17:43:53.033]                       if (has_future) {
[17:43:53.033]                         ns <- base::getNamespace("future")
[17:43:53.033]                         version <- ns[[".package"]][["version"]]
[17:43:53.033]                         if (is.null(version)) 
[17:43:53.033]                           version <- utils::packageVersion("future")
[17:43:53.033]                       }
[17:43:53.033]                       else {
[17:43:53.033]                         version <- NULL
[17:43:53.033]                       }
[17:43:53.033]                       if (!has_future || version < "1.8.0") {
[17:43:53.033]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.033]                           "", base::R.version$version.string), 
[17:43:53.033]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:53.033]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.033]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.033]                             "release", "version")], collapse = " "), 
[17:43:53.033]                           hostname = base::Sys.info()[["nodename"]])
[17:43:53.033]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.033]                           info)
[17:43:53.033]                         info <- base::paste(info, collapse = "; ")
[17:43:53.033]                         if (!has_future) {
[17:43:53.033]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.033]                             info)
[17:43:53.033]                         }
[17:43:53.033]                         else {
[17:43:53.033]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.033]                             info, version)
[17:43:53.033]                         }
[17:43:53.033]                         base::stop(msg)
[17:43:53.033]                       }
[17:43:53.033]                     })
[17:43:53.033]                   }
[17:43:53.033]                   ...future.strategy.old <- future::plan("list")
[17:43:53.033]                   options(future.plan = NULL)
[17:43:53.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.033]                 }
[17:43:53.033]                 ...future.workdir <- getwd()
[17:43:53.033]             }
[17:43:53.033]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.033]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.033]         }
[17:43:53.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.033]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.033]             base::names(...future.oldOptions))
[17:43:53.033]     }
[17:43:53.033]     if (FALSE) {
[17:43:53.033]     }
[17:43:53.033]     else {
[17:43:53.033]         if (TRUE) {
[17:43:53.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.033]                 open = "w")
[17:43:53.033]         }
[17:43:53.033]         else {
[17:43:53.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.033]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.033]         }
[17:43:53.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.033]             base::sink(type = "output", split = FALSE)
[17:43:53.033]             base::close(...future.stdout)
[17:43:53.033]         }, add = TRUE)
[17:43:53.033]     }
[17:43:53.033]     ...future.frame <- base::sys.nframe()
[17:43:53.033]     ...future.conditions <- base::list()
[17:43:53.033]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.033]     if (FALSE) {
[17:43:53.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.033]     }
[17:43:53.033]     ...future.result <- base::tryCatch({
[17:43:53.033]         base::withCallingHandlers({
[17:43:53.033]             ...future.value <- base::withVisible(base::local({
[17:43:53.033]                 do.call(function(...) {
[17:43:53.033]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.033]                   if (!identical(...future.globals.maxSize.org, 
[17:43:53.033]                     ...future.globals.maxSize)) {
[17:43:53.033]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.033]                     on.exit(options(oopts), add = TRUE)
[17:43:53.033]                   }
[17:43:53.033]                   {
[17:43:53.033]                     lapply(seq_along(...future.elements_ii), 
[17:43:53.033]                       FUN = function(jj) {
[17:43:53.033]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.033]                         ...future.FUN(...future.X_jj, ...)
[17:43:53.033]                       })
[17:43:53.033]                   }
[17:43:53.033]                 }, args = future.call.arguments)
[17:43:53.033]             }))
[17:43:53.033]             future::FutureResult(value = ...future.value$value, 
[17:43:53.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.033]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.033]                     ...future.globalenv.names))
[17:43:53.033]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.033]         }, condition = base::local({
[17:43:53.033]             c <- base::c
[17:43:53.033]             inherits <- base::inherits
[17:43:53.033]             invokeRestart <- base::invokeRestart
[17:43:53.033]             length <- base::length
[17:43:53.033]             list <- base::list
[17:43:53.033]             seq.int <- base::seq.int
[17:43:53.033]             signalCondition <- base::signalCondition
[17:43:53.033]             sys.calls <- base::sys.calls
[17:43:53.033]             `[[` <- base::`[[`
[17:43:53.033]             `+` <- base::`+`
[17:43:53.033]             `<<-` <- base::`<<-`
[17:43:53.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.033]                   3L)]
[17:43:53.033]             }
[17:43:53.033]             function(cond) {
[17:43:53.033]                 is_error <- inherits(cond, "error")
[17:43:53.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.033]                   NULL)
[17:43:53.033]                 if (is_error) {
[17:43:53.033]                   sessionInformation <- function() {
[17:43:53.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.033]                       search = base::search(), system = base::Sys.info())
[17:43:53.033]                   }
[17:43:53.033]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.033]                     cond$call), session = sessionInformation(), 
[17:43:53.033]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.033]                   signalCondition(cond)
[17:43:53.033]                 }
[17:43:53.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.033]                 "immediateCondition"))) {
[17:43:53.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.033]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.033]                   if (TRUE && !signal) {
[17:43:53.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.033]                     {
[17:43:53.033]                       inherits <- base::inherits
[17:43:53.033]                       invokeRestart <- base::invokeRestart
[17:43:53.033]                       is.null <- base::is.null
[17:43:53.033]                       muffled <- FALSE
[17:43:53.033]                       if (inherits(cond, "message")) {
[17:43:53.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.033]                         if (muffled) 
[17:43:53.033]                           invokeRestart("muffleMessage")
[17:43:53.033]                       }
[17:43:53.033]                       else if (inherits(cond, "warning")) {
[17:43:53.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.033]                         if (muffled) 
[17:43:53.033]                           invokeRestart("muffleWarning")
[17:43:53.033]                       }
[17:43:53.033]                       else if (inherits(cond, "condition")) {
[17:43:53.033]                         if (!is.null(pattern)) {
[17:43:53.033]                           computeRestarts <- base::computeRestarts
[17:43:53.033]                           grepl <- base::grepl
[17:43:53.033]                           restarts <- computeRestarts(cond)
[17:43:53.033]                           for (restart in restarts) {
[17:43:53.033]                             name <- restart$name
[17:43:53.033]                             if (is.null(name)) 
[17:43:53.033]                               next
[17:43:53.033]                             if (!grepl(pattern, name)) 
[17:43:53.033]                               next
[17:43:53.033]                             invokeRestart(restart)
[17:43:53.033]                             muffled <- TRUE
[17:43:53.033]                             break
[17:43:53.033]                           }
[17:43:53.033]                         }
[17:43:53.033]                       }
[17:43:53.033]                       invisible(muffled)
[17:43:53.033]                     }
[17:43:53.033]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.033]                   }
[17:43:53.033]                 }
[17:43:53.033]                 else {
[17:43:53.033]                   if (TRUE) {
[17:43:53.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.033]                     {
[17:43:53.033]                       inherits <- base::inherits
[17:43:53.033]                       invokeRestart <- base::invokeRestart
[17:43:53.033]                       is.null <- base::is.null
[17:43:53.033]                       muffled <- FALSE
[17:43:53.033]                       if (inherits(cond, "message")) {
[17:43:53.033]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.033]                         if (muffled) 
[17:43:53.033]                           invokeRestart("muffleMessage")
[17:43:53.033]                       }
[17:43:53.033]                       else if (inherits(cond, "warning")) {
[17:43:53.033]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.033]                         if (muffled) 
[17:43:53.033]                           invokeRestart("muffleWarning")
[17:43:53.033]                       }
[17:43:53.033]                       else if (inherits(cond, "condition")) {
[17:43:53.033]                         if (!is.null(pattern)) {
[17:43:53.033]                           computeRestarts <- base::computeRestarts
[17:43:53.033]                           grepl <- base::grepl
[17:43:53.033]                           restarts <- computeRestarts(cond)
[17:43:53.033]                           for (restart in restarts) {
[17:43:53.033]                             name <- restart$name
[17:43:53.033]                             if (is.null(name)) 
[17:43:53.033]                               next
[17:43:53.033]                             if (!grepl(pattern, name)) 
[17:43:53.033]                               next
[17:43:53.033]                             invokeRestart(restart)
[17:43:53.033]                             muffled <- TRUE
[17:43:53.033]                             break
[17:43:53.033]                           }
[17:43:53.033]                         }
[17:43:53.033]                       }
[17:43:53.033]                       invisible(muffled)
[17:43:53.033]                     }
[17:43:53.033]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.033]                   }
[17:43:53.033]                 }
[17:43:53.033]             }
[17:43:53.033]         }))
[17:43:53.033]     }, error = function(ex) {
[17:43:53.033]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.033]                 ...future.rng), started = ...future.startTime, 
[17:43:53.033]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.033]             version = "1.8"), class = "FutureResult")
[17:43:53.033]     }, finally = {
[17:43:53.033]         if (!identical(...future.workdir, getwd())) 
[17:43:53.033]             setwd(...future.workdir)
[17:43:53.033]         {
[17:43:53.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.033]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.033]             }
[17:43:53.033]             base::options(...future.oldOptions)
[17:43:53.033]             if (.Platform$OS.type == "windows") {
[17:43:53.033]                 old_names <- names(...future.oldEnvVars)
[17:43:53.033]                 envs <- base::Sys.getenv()
[17:43:53.033]                 names <- names(envs)
[17:43:53.033]                 common <- intersect(names, old_names)
[17:43:53.033]                 added <- setdiff(names, old_names)
[17:43:53.033]                 removed <- setdiff(old_names, names)
[17:43:53.033]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.033]                   envs[common]]
[17:43:53.033]                 NAMES <- toupper(changed)
[17:43:53.033]                 args <- list()
[17:43:53.033]                 for (kk in seq_along(NAMES)) {
[17:43:53.033]                   name <- changed[[kk]]
[17:43:53.033]                   NAME <- NAMES[[kk]]
[17:43:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.033]                     next
[17:43:53.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.033]                 }
[17:43:53.033]                 NAMES <- toupper(added)
[17:43:53.033]                 for (kk in seq_along(NAMES)) {
[17:43:53.033]                   name <- added[[kk]]
[17:43:53.033]                   NAME <- NAMES[[kk]]
[17:43:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.033]                     next
[17:43:53.033]                   args[[name]] <- ""
[17:43:53.033]                 }
[17:43:53.033]                 NAMES <- toupper(removed)
[17:43:53.033]                 for (kk in seq_along(NAMES)) {
[17:43:53.033]                   name <- removed[[kk]]
[17:43:53.033]                   NAME <- NAMES[[kk]]
[17:43:53.033]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.033]                     next
[17:43:53.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.033]                 }
[17:43:53.033]                 if (length(args) > 0) 
[17:43:53.033]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.033]             }
[17:43:53.033]             else {
[17:43:53.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.033]             }
[17:43:53.033]             {
[17:43:53.033]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.033]                   0L) {
[17:43:53.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.033]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.033]                   base::options(opts)
[17:43:53.033]                 }
[17:43:53.033]                 {
[17:43:53.033]                   {
[17:43:53.033]                     NULL
[17:43:53.033]                     RNGkind("Mersenne-Twister")
[17:43:53.033]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:53.033]                       inherits = FALSE)
[17:43:53.033]                   }
[17:43:53.033]                   options(future.plan = NULL)
[17:43:53.033]                   if (is.na(NA_character_)) 
[17:43:53.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.033]                     .init = FALSE)
[17:43:53.033]                 }
[17:43:53.033]             }
[17:43:53.033]         }
[17:43:53.033]     })
[17:43:53.033]     if (TRUE) {
[17:43:53.033]         base::sink(type = "output", split = FALSE)
[17:43:53.033]         if (TRUE) {
[17:43:53.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.033]         }
[17:43:53.033]         else {
[17:43:53.033]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.033]         }
[17:43:53.033]         base::close(...future.stdout)
[17:43:53.033]         ...future.stdout <- NULL
[17:43:53.033]     }
[17:43:53.033]     ...future.result$conditions <- ...future.conditions
[17:43:53.033]     ...future.result$finished <- base::Sys.time()
[17:43:53.033]     ...future.result
[17:43:53.033] }
[17:43:53.035] assign_globals() ...
[17:43:53.035] List of 5
[17:43:53.035]  $ ...future.FUN            :function (object, ...)  
[17:43:53.035]  $ future.call.arguments    : list()
[17:43:53.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.035]  $ ...future.elements_ii    :List of 3
[17:43:53.035]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.035]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.035]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.035]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.035]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.035]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.035]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.035]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:53.035]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.035]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.035]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.035]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:53.035]  $ ...future.seeds_ii       : NULL
[17:43:53.035]  $ ...future.globals.maxSize: NULL
[17:43:53.035]  - attr(*, "where")=List of 5
[17:43:53.035]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.035]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.035]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.035]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.035]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.035]  - attr(*, "resolved")= logi FALSE
[17:43:53.035]  - attr(*, "total_size")= num 1240
[17:43:53.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.035]  - attr(*, "already-done")= logi TRUE
[17:43:53.043] - copied ‘...future.FUN’ to environment
[17:43:53.043] - copied ‘future.call.arguments’ to environment
[17:43:53.044] - copied ‘...future.elements_ii’ to environment
[17:43:53.044] - copied ‘...future.seeds_ii’ to environment
[17:43:53.044] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.044] assign_globals() ... done
[17:43:53.044] plan(): Setting new future strategy stack:
[17:43:53.044] List of future strategies:
[17:43:53.044] 1. sequential:
[17:43:53.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.044]    - tweaked: FALSE
[17:43:53.044]    - call: NULL
[17:43:53.047] plan(): nbrOfWorkers() = 1
[17:43:53.049] plan(): Setting new future strategy stack:
[17:43:53.049] List of future strategies:
[17:43:53.049] 1. sequential:
[17:43:53.049]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.049]    - tweaked: FALSE
[17:43:53.049]    - call: plan(strategy)
[17:43:53.050] plan(): nbrOfWorkers() = 1
[17:43:53.050] SequentialFuture started (and completed)
[17:43:53.050] - Launch lazy future ... done
[17:43:53.050] run() for ‘SequentialFuture’ ... done
[17:43:53.050] Created future:
[17:43:53.051] SequentialFuture:
[17:43:53.051] Label: ‘future_by-1’
[17:43:53.051] Expression:
[17:43:53.051] {
[17:43:53.051]     do.call(function(...) {
[17:43:53.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.051]             on.exit(options(oopts), add = TRUE)
[17:43:53.051]         }
[17:43:53.051]         {
[17:43:53.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.051]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.051]             })
[17:43:53.051]         }
[17:43:53.051]     }, args = future.call.arguments)
[17:43:53.051] }
[17:43:53.051] Lazy evaluation: FALSE
[17:43:53.051] Asynchronous evaluation: FALSE
[17:43:53.051] Local evaluation: TRUE
[17:43:53.051] Environment: 0x55d6baa3b430
[17:43:53.051] Capture standard output: TRUE
[17:43:53.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.051] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.051] Packages: <none>
[17:43:53.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.051] Resolved: TRUE
[17:43:53.051] Value: 5.37 KiB of class ‘list’
[17:43:53.051] Early signaling: FALSE
[17:43:53.051] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.051] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:53.052] Chunk #1 of 1 ... DONE
[17:43:53.052] Launching 1 futures (chunks) ... DONE
[17:43:53.052] Resolving 1 futures (chunks) ...
[17:43:53.052] resolve() on list ...
[17:43:53.052]  recursive: 0
[17:43:53.052]  length: 1
[17:43:53.053] 
[17:43:53.053] resolved() for ‘SequentialFuture’ ...
[17:43:53.053] - state: ‘finished’
[17:43:53.053] - run: TRUE
[17:43:53.053] - result: ‘FutureResult’
[17:43:53.053] resolved() for ‘SequentialFuture’ ... done
[17:43:53.053] Future #1
[17:43:53.053] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:53.053] - nx: 1
[17:43:53.053] - relay: TRUE
[17:43:53.054] - stdout: TRUE
[17:43:53.054] - signal: TRUE
[17:43:53.054] - resignal: FALSE
[17:43:53.054] - force: TRUE
[17:43:53.054] - relayed: [n=1] FALSE
[17:43:53.054] - queued futures: [n=1] FALSE
[17:43:53.054]  - until=1
[17:43:53.054]  - relaying element #1
[17:43:53.054] - relayed: [n=1] TRUE
[17:43:53.054] - queued futures: [n=1] TRUE
[17:43:53.055] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:53.055]  length: 0 (resolved future 1)
[17:43:53.055] Relaying remaining futures
[17:43:53.055] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.055] - nx: 1
[17:43:53.055] - relay: TRUE
[17:43:53.055] - stdout: TRUE
[17:43:53.055] - signal: TRUE
[17:43:53.055] - resignal: FALSE
[17:43:53.055] - force: TRUE
[17:43:53.055] - relayed: [n=1] TRUE
[17:43:53.056] - queued futures: [n=1] TRUE
 - flush all
[17:43:53.056] - relayed: [n=1] TRUE
[17:43:53.056] - queued futures: [n=1] TRUE
[17:43:53.056] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.056] resolve() on list ... DONE
[17:43:53.056]  - Number of value chunks collected: 1
[17:43:53.056] Resolving 1 futures (chunks) ... DONE
[17:43:53.056] Reducing values from 1 chunks ...
[17:43:53.056]  - Number of values collected after concatenation: 3
[17:43:53.056]  - Number of values expected: 3
[17:43:53.057] Reducing values from 1 chunks ... DONE
[17:43:53.057] future_lapply() ... DONE
[17:43:53.057] future_by_internal() ... DONE
[17:43:53.058] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:43:53.058] future_lapply() ...
[17:43:53.058] Number of chunks: 1
[17:43:53.059] getGlobalsAndPackagesXApply() ...
[17:43:53.059]  - future.globals: TRUE
[17:43:53.059] getGlobalsAndPackages() ...
[17:43:53.059] Searching for globals...
[17:43:53.060] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:53.060] Searching for globals ... DONE
[17:43:53.060] Resolving globals: FALSE
[17:43:53.060] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:53.061] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:53.061] - globals: [1] ‘FUN’
[17:43:53.061] 
[17:43:53.061] getGlobalsAndPackages() ... DONE
[17:43:53.061]  - globals found/used: [n=1] ‘FUN’
[17:43:53.061]  - needed namespaces: [n=0] 
[17:43:53.061] Finding globals ... DONE
[17:43:53.061]  - use_args: TRUE
[17:43:53.061]  - Getting '...' globals ...
[17:43:53.062] resolve() on list ...
[17:43:53.062]  recursive: 0
[17:43:53.062]  length: 1
[17:43:53.062]  elements: ‘...’
[17:43:53.062]  length: 0 (resolved future 1)
[17:43:53.062] resolve() on list ... DONE
[17:43:53.062]    - '...' content: [n=0] 
[17:43:53.062] List of 1
[17:43:53.062]  $ ...: list()
[17:43:53.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.062]  - attr(*, "where")=List of 1
[17:43:53.062]   ..$ ...:<environment: 0x55d6ba4e8b48> 
[17:43:53.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.062]  - attr(*, "resolved")= logi TRUE
[17:43:53.062]  - attr(*, "total_size")= num NA
[17:43:53.065]  - Getting '...' globals ... DONE
[17:43:53.065] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.065] List of 2
[17:43:53.065]  $ ...future.FUN:function (object, ...)  
[17:43:53.065]  $ ...          : list()
[17:43:53.065]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.065]  - attr(*, "where")=List of 2
[17:43:53.065]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.065]   ..$ ...          :<environment: 0x55d6ba4e8b48> 
[17:43:53.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.065]  - attr(*, "resolved")= logi FALSE
[17:43:53.065]  - attr(*, "total_size")= num 1240
[17:43:53.069] Packages to be attached in all futures: [n=0] 
[17:43:53.069] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.070] Number of futures (= number of chunks): 1
[17:43:53.070] Launching 1 futures (chunks) ...
[17:43:53.070] Chunk #1 of 1 ...
[17:43:53.070]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.070] getGlobalsAndPackages() ...
[17:43:53.070] Searching for globals...
[17:43:53.071] 
[17:43:53.071] Searching for globals ... DONE
[17:43:53.071] - globals: [0] <none>
[17:43:53.071] getGlobalsAndPackages() ... DONE
[17:43:53.071]    + additional globals found: [n=0] 
[17:43:53.071]    + additional namespaces needed: [n=0] 
[17:43:53.071]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.072]  - seeds: <none>
[17:43:53.072]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.072] getGlobalsAndPackages() ...
[17:43:53.072] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.072] Resolving globals: FALSE
[17:43:53.072] Tweak future expression to call with '...' arguments ...
[17:43:53.072] {
[17:43:53.072]     do.call(function(...) {
[17:43:53.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.072]             on.exit(options(oopts), add = TRUE)
[17:43:53.072]         }
[17:43:53.072]         {
[17:43:53.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.072]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.072]             })
[17:43:53.072]         }
[17:43:53.072]     }, args = future.call.arguments)
[17:43:53.072] }
[17:43:53.072] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.073] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.073] 
[17:43:53.073] getGlobalsAndPackages() ... DONE
[17:43:53.073] run() for ‘Future’ ...
[17:43:53.073] - state: ‘created’
[17:43:53.074] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:53.074] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:53.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:53.074]   - Field: ‘label’
[17:43:53.074]   - Field: ‘local’
[17:43:53.074]   - Field: ‘owner’
[17:43:53.074]   - Field: ‘envir’
[17:43:53.074]   - Field: ‘packages’
[17:43:53.074]   - Field: ‘gc’
[17:43:53.075]   - Field: ‘conditions’
[17:43:53.075]   - Field: ‘expr’
[17:43:53.075]   - Field: ‘uuid’
[17:43:53.075]   - Field: ‘seed’
[17:43:53.075]   - Field: ‘version’
[17:43:53.075]   - Field: ‘result’
[17:43:53.075]   - Field: ‘asynchronous’
[17:43:53.075]   - Field: ‘calls’
[17:43:53.075]   - Field: ‘globals’
[17:43:53.075]   - Field: ‘stdout’
[17:43:53.075]   - Field: ‘earlySignal’
[17:43:53.076]   - Field: ‘lazy’
[17:43:53.076]   - Field: ‘state’
[17:43:53.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:53.076] - Launch lazy future ...
[17:43:53.076] Packages needed by the future expression (n = 0): <none>
[17:43:53.076] Packages needed by future strategies (n = 0): <none>
[17:43:53.077] {
[17:43:53.077]     {
[17:43:53.077]         {
[17:43:53.077]             ...future.startTime <- base::Sys.time()
[17:43:53.077]             {
[17:43:53.077]                 {
[17:43:53.077]                   {
[17:43:53.077]                     base::local({
[17:43:53.077]                       has_future <- base::requireNamespace("future", 
[17:43:53.077]                         quietly = TRUE)
[17:43:53.077]                       if (has_future) {
[17:43:53.077]                         ns <- base::getNamespace("future")
[17:43:53.077]                         version <- ns[[".package"]][["version"]]
[17:43:53.077]                         if (is.null(version)) 
[17:43:53.077]                           version <- utils::packageVersion("future")
[17:43:53.077]                       }
[17:43:53.077]                       else {
[17:43:53.077]                         version <- NULL
[17:43:53.077]                       }
[17:43:53.077]                       if (!has_future || version < "1.8.0") {
[17:43:53.077]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.077]                           "", base::R.version$version.string), 
[17:43:53.077]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:53.077]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.077]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.077]                             "release", "version")], collapse = " "), 
[17:43:53.077]                           hostname = base::Sys.info()[["nodename"]])
[17:43:53.077]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.077]                           info)
[17:43:53.077]                         info <- base::paste(info, collapse = "; ")
[17:43:53.077]                         if (!has_future) {
[17:43:53.077]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.077]                             info)
[17:43:53.077]                         }
[17:43:53.077]                         else {
[17:43:53.077]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.077]                             info, version)
[17:43:53.077]                         }
[17:43:53.077]                         base::stop(msg)
[17:43:53.077]                       }
[17:43:53.077]                     })
[17:43:53.077]                   }
[17:43:53.077]                   ...future.strategy.old <- future::plan("list")
[17:43:53.077]                   options(future.plan = NULL)
[17:43:53.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.077]                 }
[17:43:53.077]                 ...future.workdir <- getwd()
[17:43:53.077]             }
[17:43:53.077]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.077]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.077]         }
[17:43:53.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.077]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.077]             base::names(...future.oldOptions))
[17:43:53.077]     }
[17:43:53.077]     if (FALSE) {
[17:43:53.077]     }
[17:43:53.077]     else {
[17:43:53.077]         if (TRUE) {
[17:43:53.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.077]                 open = "w")
[17:43:53.077]         }
[17:43:53.077]         else {
[17:43:53.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.077]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.077]         }
[17:43:53.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.077]             base::sink(type = "output", split = FALSE)
[17:43:53.077]             base::close(...future.stdout)
[17:43:53.077]         }, add = TRUE)
[17:43:53.077]     }
[17:43:53.077]     ...future.frame <- base::sys.nframe()
[17:43:53.077]     ...future.conditions <- base::list()
[17:43:53.077]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.077]     if (FALSE) {
[17:43:53.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.077]     }
[17:43:53.077]     ...future.result <- base::tryCatch({
[17:43:53.077]         base::withCallingHandlers({
[17:43:53.077]             ...future.value <- base::withVisible(base::local({
[17:43:53.077]                 do.call(function(...) {
[17:43:53.077]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.077]                   if (!identical(...future.globals.maxSize.org, 
[17:43:53.077]                     ...future.globals.maxSize)) {
[17:43:53.077]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.077]                     on.exit(options(oopts), add = TRUE)
[17:43:53.077]                   }
[17:43:53.077]                   {
[17:43:53.077]                     lapply(seq_along(...future.elements_ii), 
[17:43:53.077]                       FUN = function(jj) {
[17:43:53.077]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.077]                         ...future.FUN(...future.X_jj, ...)
[17:43:53.077]                       })
[17:43:53.077]                   }
[17:43:53.077]                 }, args = future.call.arguments)
[17:43:53.077]             }))
[17:43:53.077]             future::FutureResult(value = ...future.value$value, 
[17:43:53.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.077]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.077]                     ...future.globalenv.names))
[17:43:53.077]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.077]         }, condition = base::local({
[17:43:53.077]             c <- base::c
[17:43:53.077]             inherits <- base::inherits
[17:43:53.077]             invokeRestart <- base::invokeRestart
[17:43:53.077]             length <- base::length
[17:43:53.077]             list <- base::list
[17:43:53.077]             seq.int <- base::seq.int
[17:43:53.077]             signalCondition <- base::signalCondition
[17:43:53.077]             sys.calls <- base::sys.calls
[17:43:53.077]             `[[` <- base::`[[`
[17:43:53.077]             `+` <- base::`+`
[17:43:53.077]             `<<-` <- base::`<<-`
[17:43:53.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.077]                   3L)]
[17:43:53.077]             }
[17:43:53.077]             function(cond) {
[17:43:53.077]                 is_error <- inherits(cond, "error")
[17:43:53.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.077]                   NULL)
[17:43:53.077]                 if (is_error) {
[17:43:53.077]                   sessionInformation <- function() {
[17:43:53.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.077]                       search = base::search(), system = base::Sys.info())
[17:43:53.077]                   }
[17:43:53.077]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.077]                     cond$call), session = sessionInformation(), 
[17:43:53.077]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.077]                   signalCondition(cond)
[17:43:53.077]                 }
[17:43:53.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.077]                 "immediateCondition"))) {
[17:43:53.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.077]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.077]                   if (TRUE && !signal) {
[17:43:53.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.077]                     {
[17:43:53.077]                       inherits <- base::inherits
[17:43:53.077]                       invokeRestart <- base::invokeRestart
[17:43:53.077]                       is.null <- base::is.null
[17:43:53.077]                       muffled <- FALSE
[17:43:53.077]                       if (inherits(cond, "message")) {
[17:43:53.077]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.077]                         if (muffled) 
[17:43:53.077]                           invokeRestart("muffleMessage")
[17:43:53.077]                       }
[17:43:53.077]                       else if (inherits(cond, "warning")) {
[17:43:53.077]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.077]                         if (muffled) 
[17:43:53.077]                           invokeRestart("muffleWarning")
[17:43:53.077]                       }
[17:43:53.077]                       else if (inherits(cond, "condition")) {
[17:43:53.077]                         if (!is.null(pattern)) {
[17:43:53.077]                           computeRestarts <- base::computeRestarts
[17:43:53.077]                           grepl <- base::grepl
[17:43:53.077]                           restarts <- computeRestarts(cond)
[17:43:53.077]                           for (restart in restarts) {
[17:43:53.077]                             name <- restart$name
[17:43:53.077]                             if (is.null(name)) 
[17:43:53.077]                               next
[17:43:53.077]                             if (!grepl(pattern, name)) 
[17:43:53.077]                               next
[17:43:53.077]                             invokeRestart(restart)
[17:43:53.077]                             muffled <- TRUE
[17:43:53.077]                             break
[17:43:53.077]                           }
[17:43:53.077]                         }
[17:43:53.077]                       }
[17:43:53.077]                       invisible(muffled)
[17:43:53.077]                     }
[17:43:53.077]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.077]                   }
[17:43:53.077]                 }
[17:43:53.077]                 else {
[17:43:53.077]                   if (TRUE) {
[17:43:53.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.077]                     {
[17:43:53.077]                       inherits <- base::inherits
[17:43:53.077]                       invokeRestart <- base::invokeRestart
[17:43:53.077]                       is.null <- base::is.null
[17:43:53.077]                       muffled <- FALSE
[17:43:53.077]                       if (inherits(cond, "message")) {
[17:43:53.077]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.077]                         if (muffled) 
[17:43:53.077]                           invokeRestart("muffleMessage")
[17:43:53.077]                       }
[17:43:53.077]                       else if (inherits(cond, "warning")) {
[17:43:53.077]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.077]                         if (muffled) 
[17:43:53.077]                           invokeRestart("muffleWarning")
[17:43:53.077]                       }
[17:43:53.077]                       else if (inherits(cond, "condition")) {
[17:43:53.077]                         if (!is.null(pattern)) {
[17:43:53.077]                           computeRestarts <- base::computeRestarts
[17:43:53.077]                           grepl <- base::grepl
[17:43:53.077]                           restarts <- computeRestarts(cond)
[17:43:53.077]                           for (restart in restarts) {
[17:43:53.077]                             name <- restart$name
[17:43:53.077]                             if (is.null(name)) 
[17:43:53.077]                               next
[17:43:53.077]                             if (!grepl(pattern, name)) 
[17:43:53.077]                               next
[17:43:53.077]                             invokeRestart(restart)
[17:43:53.077]                             muffled <- TRUE
[17:43:53.077]                             break
[17:43:53.077]                           }
[17:43:53.077]                         }
[17:43:53.077]                       }
[17:43:53.077]                       invisible(muffled)
[17:43:53.077]                     }
[17:43:53.077]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.077]                   }
[17:43:53.077]                 }
[17:43:53.077]             }
[17:43:53.077]         }))
[17:43:53.077]     }, error = function(ex) {
[17:43:53.077]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.077]                 ...future.rng), started = ...future.startTime, 
[17:43:53.077]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.077]             version = "1.8"), class = "FutureResult")
[17:43:53.077]     }, finally = {
[17:43:53.077]         if (!identical(...future.workdir, getwd())) 
[17:43:53.077]             setwd(...future.workdir)
[17:43:53.077]         {
[17:43:53.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.077]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.077]             }
[17:43:53.077]             base::options(...future.oldOptions)
[17:43:53.077]             if (.Platform$OS.type == "windows") {
[17:43:53.077]                 old_names <- names(...future.oldEnvVars)
[17:43:53.077]                 envs <- base::Sys.getenv()
[17:43:53.077]                 names <- names(envs)
[17:43:53.077]                 common <- intersect(names, old_names)
[17:43:53.077]                 added <- setdiff(names, old_names)
[17:43:53.077]                 removed <- setdiff(old_names, names)
[17:43:53.077]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.077]                   envs[common]]
[17:43:53.077]                 NAMES <- toupper(changed)
[17:43:53.077]                 args <- list()
[17:43:53.077]                 for (kk in seq_along(NAMES)) {
[17:43:53.077]                   name <- changed[[kk]]
[17:43:53.077]                   NAME <- NAMES[[kk]]
[17:43:53.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.077]                     next
[17:43:53.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.077]                 }
[17:43:53.077]                 NAMES <- toupper(added)
[17:43:53.077]                 for (kk in seq_along(NAMES)) {
[17:43:53.077]                   name <- added[[kk]]
[17:43:53.077]                   NAME <- NAMES[[kk]]
[17:43:53.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.077]                     next
[17:43:53.077]                   args[[name]] <- ""
[17:43:53.077]                 }
[17:43:53.077]                 NAMES <- toupper(removed)
[17:43:53.077]                 for (kk in seq_along(NAMES)) {
[17:43:53.077]                   name <- removed[[kk]]
[17:43:53.077]                   NAME <- NAMES[[kk]]
[17:43:53.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.077]                     next
[17:43:53.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.077]                 }
[17:43:53.077]                 if (length(args) > 0) 
[17:43:53.077]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.077]             }
[17:43:53.077]             else {
[17:43:53.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.077]             }
[17:43:53.077]             {
[17:43:53.077]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.077]                   0L) {
[17:43:53.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.077]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.077]                   base::options(opts)
[17:43:53.077]                 }
[17:43:53.077]                 {
[17:43:53.077]                   {
[17:43:53.077]                     NULL
[17:43:53.077]                     RNGkind("Mersenne-Twister")
[17:43:53.077]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:53.077]                       inherits = FALSE)
[17:43:53.077]                   }
[17:43:53.077]                   options(future.plan = NULL)
[17:43:53.077]                   if (is.na(NA_character_)) 
[17:43:53.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.077]                     .init = FALSE)
[17:43:53.077]                 }
[17:43:53.077]             }
[17:43:53.077]         }
[17:43:53.077]     })
[17:43:53.077]     if (TRUE) {
[17:43:53.077]         base::sink(type = "output", split = FALSE)
[17:43:53.077]         if (TRUE) {
[17:43:53.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.077]         }
[17:43:53.077]         else {
[17:43:53.077]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.077]         }
[17:43:53.077]         base::close(...future.stdout)
[17:43:53.077]         ...future.stdout <- NULL
[17:43:53.077]     }
[17:43:53.077]     ...future.result$conditions <- ...future.conditions
[17:43:53.077]     ...future.result$finished <- base::Sys.time()
[17:43:53.077]     ...future.result
[17:43:53.077] }
[17:43:53.078] assign_globals() ...
[17:43:53.078] List of 5
[17:43:53.078]  $ ...future.FUN            :function (object, ...)  
[17:43:53.078]  $ future.call.arguments    : list()
[17:43:53.078]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.078]  $ ...future.elements_ii    :List of 3
[17:43:53.078]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.078]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.078]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.078]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.078]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.078]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.078]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.078]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:53.078]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.078]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.078]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.078]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:53.078]  $ ...future.seeds_ii       : NULL
[17:43:53.078]  $ ...future.globals.maxSize: NULL
[17:43:53.078]  - attr(*, "where")=List of 5
[17:43:53.078]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.078]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.078]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.078]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.078]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.078]  - attr(*, "resolved")= logi FALSE
[17:43:53.078]  - attr(*, "total_size")= num 1240
[17:43:53.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.078]  - attr(*, "already-done")= logi TRUE
[17:43:53.086] - copied ‘...future.FUN’ to environment
[17:43:53.086] - copied ‘future.call.arguments’ to environment
[17:43:53.087] - copied ‘...future.elements_ii’ to environment
[17:43:53.087] - copied ‘...future.seeds_ii’ to environment
[17:43:53.087] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.087] assign_globals() ... done
[17:43:53.087] plan(): Setting new future strategy stack:
[17:43:53.087] List of future strategies:
[17:43:53.087] 1. sequential:
[17:43:53.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.087]    - tweaked: FALSE
[17:43:53.087]    - call: NULL
[17:43:53.088] plan(): nbrOfWorkers() = 1
[17:43:53.091] plan(): Setting new future strategy stack:
[17:43:53.091] List of future strategies:
[17:43:53.091] 1. sequential:
[17:43:53.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.091]    - tweaked: FALSE
[17:43:53.091]    - call: plan(strategy)
[17:43:53.092] plan(): nbrOfWorkers() = 1
[17:43:53.092] SequentialFuture started (and completed)
[17:43:53.092] - Launch lazy future ... done
[17:43:53.092] run() for ‘SequentialFuture’ ... done
[17:43:53.092] Created future:
[17:43:53.092] SequentialFuture:
[17:43:53.092] Label: ‘future_by-1’
[17:43:53.092] Expression:
[17:43:53.092] {
[17:43:53.092]     do.call(function(...) {
[17:43:53.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.092]             on.exit(options(oopts), add = TRUE)
[17:43:53.092]         }
[17:43:53.092]         {
[17:43:53.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.092]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.092]             })
[17:43:53.092]         }
[17:43:53.092]     }, args = future.call.arguments)
[17:43:53.092] }
[17:43:53.092] Lazy evaluation: FALSE
[17:43:53.092] Asynchronous evaluation: FALSE
[17:43:53.092] Local evaluation: TRUE
[17:43:53.092] Environment: 0x55d6ba449ab0
[17:43:53.092] Capture standard output: TRUE
[17:43:53.092] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.092] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.092] Packages: <none>
[17:43:53.092] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.092] Resolved: TRUE
[17:43:53.092] Value: 5.37 KiB of class ‘list’
[17:43:53.092] Early signaling: FALSE
[17:43:53.092] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.092] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:53.094] Chunk #1 of 1 ... DONE
[17:43:53.094] Launching 1 futures (chunks) ... DONE
[17:43:53.094] Resolving 1 futures (chunks) ...
[17:43:53.094] resolve() on list ...
[17:43:53.094]  recursive: 0
[17:43:53.094]  length: 1
[17:43:53.094] 
[17:43:53.094] resolved() for ‘SequentialFuture’ ...
[17:43:53.094] - state: ‘finished’
[17:43:53.095] - run: TRUE
[17:43:53.095] - result: ‘FutureResult’
[17:43:53.095] resolved() for ‘SequentialFuture’ ... done
[17:43:53.095] Future #1
[17:43:53.095] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:53.095] - nx: 1
[17:43:53.095] - relay: TRUE
[17:43:53.095] - stdout: TRUE
[17:43:53.095] - signal: TRUE
[17:43:53.095] - resignal: FALSE
[17:43:53.096] - force: TRUE
[17:43:53.096] - relayed: [n=1] FALSE
[17:43:53.096] - queued futures: [n=1] FALSE
[17:43:53.096]  - until=1
[17:43:53.096]  - relaying element #1
[17:43:53.096] - relayed: [n=1] TRUE
[17:43:53.096] - queued futures: [n=1] TRUE
[17:43:53.096] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:53.096]  length: 0 (resolved future 1)
[17:43:53.096] Relaying remaining futures
[17:43:53.097] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.097] - nx: 1
[17:43:53.097] - relay: TRUE
[17:43:53.097] - stdout: TRUE
[17:43:53.097] - signal: TRUE
[17:43:53.097] - resignal: FALSE
[17:43:53.097] - force: TRUE
[17:43:53.097] - relayed: [n=1] TRUE
[17:43:53.097] - queued futures: [n=1] TRUE
 - flush all
[17:43:53.097] - relayed: [n=1] TRUE
[17:43:53.097] - queued futures: [n=1] TRUE
[17:43:53.097] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.098] resolve() on list ... DONE
[17:43:53.098]  - Number of value chunks collected: 1
[17:43:53.098] Resolving 1 futures (chunks) ... DONE
[17:43:53.098] Reducing values from 1 chunks ...
[17:43:53.098]  - Number of values collected after concatenation: 3
[17:43:53.098]  - Number of values expected: 3
[17:43:53.098] Reducing values from 1 chunks ... DONE
[17:43:53.098] future_lapply() ... DONE
[17:43:53.098] future_by_internal() ... DONE
[17:43:53.099] future_by_internal() ...
- plan('multicore') ...
[17:43:53.100] plan(): Setting new future strategy stack:
[17:43:53.100] List of future strategies:
[17:43:53.100] 1. multicore:
[17:43:53.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.100]    - tweaked: FALSE
[17:43:53.100]    - call: plan(strategy)
[17:43:53.104] plan(): nbrOfWorkers() = 2
[17:43:53.104] future_by_internal() ...
[17:43:53.104] future_lapply() ...
[17:43:53.109] Number of chunks: 2
[17:43:53.109] getGlobalsAndPackagesXApply() ...
[17:43:53.109]  - future.globals: TRUE
[17:43:53.109] getGlobalsAndPackages() ...
[17:43:53.109] Searching for globals...
[17:43:53.110] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:53.110] Searching for globals ... DONE
[17:43:53.110] Resolving globals: FALSE
[17:43:53.110] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:53.111] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:53.111] - globals: [1] ‘FUN’
[17:43:53.111] 
[17:43:53.111] getGlobalsAndPackages() ... DONE
[17:43:53.111]  - globals found/used: [n=1] ‘FUN’
[17:43:53.111]  - needed namespaces: [n=0] 
[17:43:53.111] Finding globals ... DONE
[17:43:53.111]  - use_args: TRUE
[17:43:53.112]  - Getting '...' globals ...
[17:43:53.112] resolve() on list ...
[17:43:53.112]  recursive: 0
[17:43:53.112]  length: 1
[17:43:53.112]  elements: ‘...’
[17:43:53.112]  length: 0 (resolved future 1)
[17:43:53.112] resolve() on list ... DONE
[17:43:53.112]    - '...' content: [n=0] 
[17:43:53.113] List of 1
[17:43:53.113]  $ ...: list()
[17:43:53.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.113]  - attr(*, "where")=List of 1
[17:43:53.113]   ..$ ...:<environment: 0x55d6ba533e28> 
[17:43:53.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.113]  - attr(*, "resolved")= logi TRUE
[17:43:53.113]  - attr(*, "total_size")= num NA
[17:43:53.115]  - Getting '...' globals ... DONE
[17:43:53.115] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.115] List of 2
[17:43:53.115]  $ ...future.FUN:function (object, ...)  
[17:43:53.115]  $ ...          : list()
[17:43:53.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.115]  - attr(*, "where")=List of 2
[17:43:53.115]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.115]   ..$ ...          :<environment: 0x55d6ba533e28> 
[17:43:53.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.115]  - attr(*, "resolved")= logi FALSE
[17:43:53.115]  - attr(*, "total_size")= num 1240
[17:43:53.119] Packages to be attached in all futures: [n=0] 
[17:43:53.120] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.120] Number of futures (= number of chunks): 2
[17:43:53.120] Launching 2 futures (chunks) ...
[17:43:53.120] Chunk #1 of 2 ...
[17:43:53.120]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.120] getGlobalsAndPackages() ...
[17:43:53.120] Searching for globals...
[17:43:53.121] 
[17:43:53.121] Searching for globals ... DONE
[17:43:53.121] - globals: [0] <none>
[17:43:53.121] getGlobalsAndPackages() ... DONE
[17:43:53.121]    + additional globals found: [n=0] 
[17:43:53.121]    + additional namespaces needed: [n=0] 
[17:43:53.121]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.121]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.121]  - seeds: <none>
[17:43:53.121]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.122] getGlobalsAndPackages() ...
[17:43:53.122] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.122] Resolving globals: FALSE
[17:43:53.122] Tweak future expression to call with '...' arguments ...
[17:43:53.122] {
[17:43:53.122]     do.call(function(...) {
[17:43:53.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.122]             on.exit(options(oopts), add = TRUE)
[17:43:53.122]         }
[17:43:53.122]         {
[17:43:53.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.122]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.122]             })
[17:43:53.122]         }
[17:43:53.122]     }, args = future.call.arguments)
[17:43:53.122] }
[17:43:53.122] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.122] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.123] 
[17:43:53.123] getGlobalsAndPackages() ... DONE
[17:43:53.123] run() for ‘Future’ ...
[17:43:53.123] - state: ‘created’
[17:43:53.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.127]   - Field: ‘label’
[17:43:53.127]   - Field: ‘local’
[17:43:53.127]   - Field: ‘owner’
[17:43:53.127]   - Field: ‘envir’
[17:43:53.127]   - Field: ‘workers’
[17:43:53.127]   - Field: ‘packages’
[17:43:53.127]   - Field: ‘gc’
[17:43:53.128]   - Field: ‘job’
[17:43:53.128]   - Field: ‘conditions’
[17:43:53.128]   - Field: ‘expr’
[17:43:53.128]   - Field: ‘uuid’
[17:43:53.128]   - Field: ‘seed’
[17:43:53.128]   - Field: ‘version’
[17:43:53.128]   - Field: ‘result’
[17:43:53.128]   - Field: ‘asynchronous’
[17:43:53.128]   - Field: ‘calls’
[17:43:53.128]   - Field: ‘globals’
[17:43:53.128]   - Field: ‘stdout’
[17:43:53.129]   - Field: ‘earlySignal’
[17:43:53.129]   - Field: ‘lazy’
[17:43:53.129]   - Field: ‘state’
[17:43:53.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.129] - Launch lazy future ...
[17:43:53.130] Packages needed by the future expression (n = 0): <none>
[17:43:53.130] Packages needed by future strategies (n = 0): <none>
[17:43:53.130] {
[17:43:53.130]     {
[17:43:53.130]         {
[17:43:53.130]             ...future.startTime <- base::Sys.time()
[17:43:53.130]             {
[17:43:53.130]                 {
[17:43:53.130]                   {
[17:43:53.130]                     {
[17:43:53.130]                       base::local({
[17:43:53.130]                         has_future <- base::requireNamespace("future", 
[17:43:53.130]                           quietly = TRUE)
[17:43:53.130]                         if (has_future) {
[17:43:53.130]                           ns <- base::getNamespace("future")
[17:43:53.130]                           version <- ns[[".package"]][["version"]]
[17:43:53.130]                           if (is.null(version)) 
[17:43:53.130]                             version <- utils::packageVersion("future")
[17:43:53.130]                         }
[17:43:53.130]                         else {
[17:43:53.130]                           version <- NULL
[17:43:53.130]                         }
[17:43:53.130]                         if (!has_future || version < "1.8.0") {
[17:43:53.130]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.130]                             "", base::R.version$version.string), 
[17:43:53.130]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.130]                               "release", "version")], collapse = " "), 
[17:43:53.130]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.130]                             info)
[17:43:53.130]                           info <- base::paste(info, collapse = "; ")
[17:43:53.130]                           if (!has_future) {
[17:43:53.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.130]                               info)
[17:43:53.130]                           }
[17:43:53.130]                           else {
[17:43:53.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.130]                               info, version)
[17:43:53.130]                           }
[17:43:53.130]                           base::stop(msg)
[17:43:53.130]                         }
[17:43:53.130]                       })
[17:43:53.130]                     }
[17:43:53.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.130]                     base::options(mc.cores = 1L)
[17:43:53.130]                   }
[17:43:53.130]                   ...future.strategy.old <- future::plan("list")
[17:43:53.130]                   options(future.plan = NULL)
[17:43:53.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.130]                 }
[17:43:53.130]                 ...future.workdir <- getwd()
[17:43:53.130]             }
[17:43:53.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.130]         }
[17:43:53.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.130]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.130]             base::names(...future.oldOptions))
[17:43:53.130]     }
[17:43:53.130]     if (FALSE) {
[17:43:53.130]     }
[17:43:53.130]     else {
[17:43:53.130]         if (TRUE) {
[17:43:53.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.130]                 open = "w")
[17:43:53.130]         }
[17:43:53.130]         else {
[17:43:53.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.130]         }
[17:43:53.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.130]             base::sink(type = "output", split = FALSE)
[17:43:53.130]             base::close(...future.stdout)
[17:43:53.130]         }, add = TRUE)
[17:43:53.130]     }
[17:43:53.130]     ...future.frame <- base::sys.nframe()
[17:43:53.130]     ...future.conditions <- base::list()
[17:43:53.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.130]     if (FALSE) {
[17:43:53.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.130]     }
[17:43:53.130]     ...future.result <- base::tryCatch({
[17:43:53.130]         base::withCallingHandlers({
[17:43:53.130]             ...future.value <- base::withVisible(base::local({
[17:43:53.130]                 withCallingHandlers({
[17:43:53.130]                   {
[17:43:53.130]                     do.call(function(...) {
[17:43:53.130]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.130]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.130]                         ...future.globals.maxSize)) {
[17:43:53.130]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.130]                         on.exit(options(oopts), add = TRUE)
[17:43:53.130]                       }
[17:43:53.130]                       {
[17:43:53.130]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.130]                           FUN = function(jj) {
[17:43:53.130]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.130]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.130]                           })
[17:43:53.130]                       }
[17:43:53.130]                     }, args = future.call.arguments)
[17:43:53.130]                   }
[17:43:53.130]                 }, immediateCondition = function(cond) {
[17:43:53.130]                   save_rds <- function (object, pathname, ...) 
[17:43:53.130]                   {
[17:43:53.130]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.130]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.130]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.130]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.130]                         fi_tmp[["mtime"]])
[17:43:53.130]                     }
[17:43:53.130]                     tryCatch({
[17:43:53.130]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.130]                     }, error = function(ex) {
[17:43:53.130]                       msg <- conditionMessage(ex)
[17:43:53.130]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.130]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.130]                         fi_tmp[["mtime"]], msg)
[17:43:53.130]                       ex$message <- msg
[17:43:53.130]                       stop(ex)
[17:43:53.130]                     })
[17:43:53.130]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.130]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.130]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.130]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.130]                       fi <- file.info(pathname)
[17:43:53.130]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.130]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.130]                         fi[["size"]], fi[["mtime"]])
[17:43:53.130]                       stop(msg)
[17:43:53.130]                     }
[17:43:53.130]                     invisible(pathname)
[17:43:53.130]                   }
[17:43:53.130]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.130]                     rootPath = tempdir()) 
[17:43:53.130]                   {
[17:43:53.130]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.130]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.130]                       tmpdir = path, fileext = ".rds")
[17:43:53.130]                     save_rds(obj, file)
[17:43:53.130]                   }
[17:43:53.130]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.130]                   {
[17:43:53.130]                     inherits <- base::inherits
[17:43:53.130]                     invokeRestart <- base::invokeRestart
[17:43:53.130]                     is.null <- base::is.null
[17:43:53.130]                     muffled <- FALSE
[17:43:53.130]                     if (inherits(cond, "message")) {
[17:43:53.130]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.130]                       if (muffled) 
[17:43:53.130]                         invokeRestart("muffleMessage")
[17:43:53.130]                     }
[17:43:53.130]                     else if (inherits(cond, "warning")) {
[17:43:53.130]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.130]                       if (muffled) 
[17:43:53.130]                         invokeRestart("muffleWarning")
[17:43:53.130]                     }
[17:43:53.130]                     else if (inherits(cond, "condition")) {
[17:43:53.130]                       if (!is.null(pattern)) {
[17:43:53.130]                         computeRestarts <- base::computeRestarts
[17:43:53.130]                         grepl <- base::grepl
[17:43:53.130]                         restarts <- computeRestarts(cond)
[17:43:53.130]                         for (restart in restarts) {
[17:43:53.130]                           name <- restart$name
[17:43:53.130]                           if (is.null(name)) 
[17:43:53.130]                             next
[17:43:53.130]                           if (!grepl(pattern, name)) 
[17:43:53.130]                             next
[17:43:53.130]                           invokeRestart(restart)
[17:43:53.130]                           muffled <- TRUE
[17:43:53.130]                           break
[17:43:53.130]                         }
[17:43:53.130]                       }
[17:43:53.130]                     }
[17:43:53.130]                     invisible(muffled)
[17:43:53.130]                   }
[17:43:53.130]                   muffleCondition(cond)
[17:43:53.130]                 })
[17:43:53.130]             }))
[17:43:53.130]             future::FutureResult(value = ...future.value$value, 
[17:43:53.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.130]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.130]                     ...future.globalenv.names))
[17:43:53.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.130]         }, condition = base::local({
[17:43:53.130]             c <- base::c
[17:43:53.130]             inherits <- base::inherits
[17:43:53.130]             invokeRestart <- base::invokeRestart
[17:43:53.130]             length <- base::length
[17:43:53.130]             list <- base::list
[17:43:53.130]             seq.int <- base::seq.int
[17:43:53.130]             signalCondition <- base::signalCondition
[17:43:53.130]             sys.calls <- base::sys.calls
[17:43:53.130]             `[[` <- base::`[[`
[17:43:53.130]             `+` <- base::`+`
[17:43:53.130]             `<<-` <- base::`<<-`
[17:43:53.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.130]                   3L)]
[17:43:53.130]             }
[17:43:53.130]             function(cond) {
[17:43:53.130]                 is_error <- inherits(cond, "error")
[17:43:53.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.130]                   NULL)
[17:43:53.130]                 if (is_error) {
[17:43:53.130]                   sessionInformation <- function() {
[17:43:53.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.130]                       search = base::search(), system = base::Sys.info())
[17:43:53.130]                   }
[17:43:53.130]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.130]                     cond$call), session = sessionInformation(), 
[17:43:53.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.130]                   signalCondition(cond)
[17:43:53.130]                 }
[17:43:53.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.130]                 "immediateCondition"))) {
[17:43:53.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.130]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.130]                   if (TRUE && !signal) {
[17:43:53.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.130]                     {
[17:43:53.130]                       inherits <- base::inherits
[17:43:53.130]                       invokeRestart <- base::invokeRestart
[17:43:53.130]                       is.null <- base::is.null
[17:43:53.130]                       muffled <- FALSE
[17:43:53.130]                       if (inherits(cond, "message")) {
[17:43:53.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.130]                         if (muffled) 
[17:43:53.130]                           invokeRestart("muffleMessage")
[17:43:53.130]                       }
[17:43:53.130]                       else if (inherits(cond, "warning")) {
[17:43:53.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.130]                         if (muffled) 
[17:43:53.130]                           invokeRestart("muffleWarning")
[17:43:53.130]                       }
[17:43:53.130]                       else if (inherits(cond, "condition")) {
[17:43:53.130]                         if (!is.null(pattern)) {
[17:43:53.130]                           computeRestarts <- base::computeRestarts
[17:43:53.130]                           grepl <- base::grepl
[17:43:53.130]                           restarts <- computeRestarts(cond)
[17:43:53.130]                           for (restart in restarts) {
[17:43:53.130]                             name <- restart$name
[17:43:53.130]                             if (is.null(name)) 
[17:43:53.130]                               next
[17:43:53.130]                             if (!grepl(pattern, name)) 
[17:43:53.130]                               next
[17:43:53.130]                             invokeRestart(restart)
[17:43:53.130]                             muffled <- TRUE
[17:43:53.130]                             break
[17:43:53.130]                           }
[17:43:53.130]                         }
[17:43:53.130]                       }
[17:43:53.130]                       invisible(muffled)
[17:43:53.130]                     }
[17:43:53.130]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.130]                   }
[17:43:53.130]                 }
[17:43:53.130]                 else {
[17:43:53.130]                   if (TRUE) {
[17:43:53.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.130]                     {
[17:43:53.130]                       inherits <- base::inherits
[17:43:53.130]                       invokeRestart <- base::invokeRestart
[17:43:53.130]                       is.null <- base::is.null
[17:43:53.130]                       muffled <- FALSE
[17:43:53.130]                       if (inherits(cond, "message")) {
[17:43:53.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.130]                         if (muffled) 
[17:43:53.130]                           invokeRestart("muffleMessage")
[17:43:53.130]                       }
[17:43:53.130]                       else if (inherits(cond, "warning")) {
[17:43:53.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.130]                         if (muffled) 
[17:43:53.130]                           invokeRestart("muffleWarning")
[17:43:53.130]                       }
[17:43:53.130]                       else if (inherits(cond, "condition")) {
[17:43:53.130]                         if (!is.null(pattern)) {
[17:43:53.130]                           computeRestarts <- base::computeRestarts
[17:43:53.130]                           grepl <- base::grepl
[17:43:53.130]                           restarts <- computeRestarts(cond)
[17:43:53.130]                           for (restart in restarts) {
[17:43:53.130]                             name <- restart$name
[17:43:53.130]                             if (is.null(name)) 
[17:43:53.130]                               next
[17:43:53.130]                             if (!grepl(pattern, name)) 
[17:43:53.130]                               next
[17:43:53.130]                             invokeRestart(restart)
[17:43:53.130]                             muffled <- TRUE
[17:43:53.130]                             break
[17:43:53.130]                           }
[17:43:53.130]                         }
[17:43:53.130]                       }
[17:43:53.130]                       invisible(muffled)
[17:43:53.130]                     }
[17:43:53.130]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.130]                   }
[17:43:53.130]                 }
[17:43:53.130]             }
[17:43:53.130]         }))
[17:43:53.130]     }, error = function(ex) {
[17:43:53.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.130]                 ...future.rng), started = ...future.startTime, 
[17:43:53.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.130]             version = "1.8"), class = "FutureResult")
[17:43:53.130]     }, finally = {
[17:43:53.130]         if (!identical(...future.workdir, getwd())) 
[17:43:53.130]             setwd(...future.workdir)
[17:43:53.130]         {
[17:43:53.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.130]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.130]             }
[17:43:53.130]             base::options(...future.oldOptions)
[17:43:53.130]             if (.Platform$OS.type == "windows") {
[17:43:53.130]                 old_names <- names(...future.oldEnvVars)
[17:43:53.130]                 envs <- base::Sys.getenv()
[17:43:53.130]                 names <- names(envs)
[17:43:53.130]                 common <- intersect(names, old_names)
[17:43:53.130]                 added <- setdiff(names, old_names)
[17:43:53.130]                 removed <- setdiff(old_names, names)
[17:43:53.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.130]                   envs[common]]
[17:43:53.130]                 NAMES <- toupper(changed)
[17:43:53.130]                 args <- list()
[17:43:53.130]                 for (kk in seq_along(NAMES)) {
[17:43:53.130]                   name <- changed[[kk]]
[17:43:53.130]                   NAME <- NAMES[[kk]]
[17:43:53.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.130]                     next
[17:43:53.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.130]                 }
[17:43:53.130]                 NAMES <- toupper(added)
[17:43:53.130]                 for (kk in seq_along(NAMES)) {
[17:43:53.130]                   name <- added[[kk]]
[17:43:53.130]                   NAME <- NAMES[[kk]]
[17:43:53.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.130]                     next
[17:43:53.130]                   args[[name]] <- ""
[17:43:53.130]                 }
[17:43:53.130]                 NAMES <- toupper(removed)
[17:43:53.130]                 for (kk in seq_along(NAMES)) {
[17:43:53.130]                   name <- removed[[kk]]
[17:43:53.130]                   NAME <- NAMES[[kk]]
[17:43:53.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.130]                     next
[17:43:53.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.130]                 }
[17:43:53.130]                 if (length(args) > 0) 
[17:43:53.130]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.130]             }
[17:43:53.130]             else {
[17:43:53.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.130]             }
[17:43:53.130]             {
[17:43:53.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.130]                   0L) {
[17:43:53.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.130]                   base::options(opts)
[17:43:53.130]                 }
[17:43:53.130]                 {
[17:43:53.130]                   {
[17:43:53.130]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.130]                     NULL
[17:43:53.130]                   }
[17:43:53.130]                   options(future.plan = NULL)
[17:43:53.130]                   if (is.na(NA_character_)) 
[17:43:53.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.130]                     .init = FALSE)
[17:43:53.130]                 }
[17:43:53.130]             }
[17:43:53.130]         }
[17:43:53.130]     })
[17:43:53.130]     if (TRUE) {
[17:43:53.130]         base::sink(type = "output", split = FALSE)
[17:43:53.130]         if (TRUE) {
[17:43:53.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.130]         }
[17:43:53.130]         else {
[17:43:53.130]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.130]         }
[17:43:53.130]         base::close(...future.stdout)
[17:43:53.130]         ...future.stdout <- NULL
[17:43:53.130]     }
[17:43:53.130]     ...future.result$conditions <- ...future.conditions
[17:43:53.130]     ...future.result$finished <- base::Sys.time()
[17:43:53.130]     ...future.result
[17:43:53.130] }
[17:43:53.133] assign_globals() ...
[17:43:53.133] List of 5
[17:43:53.133]  $ ...future.FUN            :function (object, ...)  
[17:43:53.133]  $ future.call.arguments    : list()
[17:43:53.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.133]  $ ...future.elements_ii    :List of 1
[17:43:53.133]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:53.133]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.133]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.133]  $ ...future.seeds_ii       : NULL
[17:43:53.133]  $ ...future.globals.maxSize: NULL
[17:43:53.133]  - attr(*, "where")=List of 5
[17:43:53.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.133]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.133]  - attr(*, "resolved")= logi FALSE
[17:43:53.133]  - attr(*, "total_size")= num 1240
[17:43:53.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.133]  - attr(*, "already-done")= logi TRUE
[17:43:53.138] - copied ‘...future.FUN’ to environment
[17:43:53.138] - copied ‘future.call.arguments’ to environment
[17:43:53.138] - copied ‘...future.elements_ii’ to environment
[17:43:53.138] - copied ‘...future.seeds_ii’ to environment
[17:43:53.138] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.138] assign_globals() ... done
[17:43:53.138] requestCore(): workers = 2
[17:43:53.141] MulticoreFuture started
[17:43:53.142] - Launch lazy future ... done
[17:43:53.142] plan(): Setting new future strategy stack:
[17:43:53.142] run() for ‘MulticoreFuture’ ... done
[17:43:53.142] Created future:
[17:43:53.142] List of future strategies:
[17:43:53.142] 1. sequential:
[17:43:53.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.142]    - tweaked: FALSE
[17:43:53.142]    - call: NULL
[17:43:53.143] plan(): nbrOfWorkers() = 1
[17:43:53.152] plan(): Setting new future strategy stack:
[17:43:53.152] List of future strategies:
[17:43:53.152] 1. multicore:
[17:43:53.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.152]    - tweaked: FALSE
[17:43:53.152]    - call: plan(strategy)
[17:43:53.158] plan(): nbrOfWorkers() = 2
[17:43:53.142] MulticoreFuture:
[17:43:53.142] Label: ‘future_by-1’
[17:43:53.142] Expression:
[17:43:53.142] {
[17:43:53.142]     do.call(function(...) {
[17:43:53.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.142]             on.exit(options(oopts), add = TRUE)
[17:43:53.142]         }
[17:43:53.142]         {
[17:43:53.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.142]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.142]             })
[17:43:53.142]         }
[17:43:53.142]     }, args = future.call.arguments)
[17:43:53.142] }
[17:43:53.142] Lazy evaluation: FALSE
[17:43:53.142] Asynchronous evaluation: TRUE
[17:43:53.142] Local evaluation: TRUE
[17:43:53.142] Environment: R_GlobalEnv
[17:43:53.142] Capture standard output: TRUE
[17:43:53.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.142] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.142] Packages: <none>
[17:43:53.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.142] Resolved: TRUE
[17:43:53.142] Value: <not collected>
[17:43:53.142] Conditions captured: <none>
[17:43:53.142] Early signaling: FALSE
[17:43:53.142] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.142] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.160] Chunk #1 of 2 ... DONE
[17:43:53.160] Chunk #2 of 2 ...
[17:43:53.160]  - Finding globals in 'X' for chunk #2 ...
[17:43:53.160] getGlobalsAndPackages() ...
[17:43:53.161] Searching for globals...
[17:43:53.162] 
[17:43:53.162] Searching for globals ... DONE
[17:43:53.162] - globals: [0] <none>
[17:43:53.162] getGlobalsAndPackages() ... DONE
[17:43:53.162]    + additional globals found: [n=0] 
[17:43:53.162]    + additional namespaces needed: [n=0] 
[17:43:53.163]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:53.163]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.163]  - seeds: <none>
[17:43:53.163]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.164] getGlobalsAndPackages() ...
[17:43:53.164] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.164] Resolving globals: FALSE
[17:43:53.164] Tweak future expression to call with '...' arguments ...
[17:43:53.164] {
[17:43:53.164]     do.call(function(...) {
[17:43:53.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.164]             on.exit(options(oopts), add = TRUE)
[17:43:53.164]         }
[17:43:53.164]         {
[17:43:53.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.164]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.164]             })
[17:43:53.164]         }
[17:43:53.164]     }, args = future.call.arguments)
[17:43:53.164] }
[17:43:53.165] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.166] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.166] 
[17:43:53.166] getGlobalsAndPackages() ... DONE
[17:43:53.167] run() for ‘Future’ ...
[17:43:53.167] - state: ‘created’
[17:43:53.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.171] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.172]   - Field: ‘label’
[17:43:53.172]   - Field: ‘local’
[17:43:53.172]   - Field: ‘owner’
[17:43:53.172]   - Field: ‘envir’
[17:43:53.172]   - Field: ‘workers’
[17:43:53.172]   - Field: ‘packages’
[17:43:53.173]   - Field: ‘gc’
[17:43:53.173]   - Field: ‘job’
[17:43:53.173]   - Field: ‘conditions’
[17:43:53.173]   - Field: ‘expr’
[17:43:53.173]   - Field: ‘uuid’
[17:43:53.173]   - Field: ‘seed’
[17:43:53.173]   - Field: ‘version’
[17:43:53.174]   - Field: ‘result’
[17:43:53.174]   - Field: ‘asynchronous’
[17:43:53.174]   - Field: ‘calls’
[17:43:53.174]   - Field: ‘globals’
[17:43:53.174]   - Field: ‘stdout’
[17:43:53.174]   - Field: ‘earlySignal’
[17:43:53.174]   - Field: ‘lazy’
[17:43:53.174]   - Field: ‘state’
[17:43:53.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.175] - Launch lazy future ...
[17:43:53.175] Packages needed by the future expression (n = 0): <none>
[17:43:53.175] Packages needed by future strategies (n = 0): <none>
[17:43:53.176] {
[17:43:53.176]     {
[17:43:53.176]         {
[17:43:53.176]             ...future.startTime <- base::Sys.time()
[17:43:53.176]             {
[17:43:53.176]                 {
[17:43:53.176]                   {
[17:43:53.176]                     {
[17:43:53.176]                       base::local({
[17:43:53.176]                         has_future <- base::requireNamespace("future", 
[17:43:53.176]                           quietly = TRUE)
[17:43:53.176]                         if (has_future) {
[17:43:53.176]                           ns <- base::getNamespace("future")
[17:43:53.176]                           version <- ns[[".package"]][["version"]]
[17:43:53.176]                           if (is.null(version)) 
[17:43:53.176]                             version <- utils::packageVersion("future")
[17:43:53.176]                         }
[17:43:53.176]                         else {
[17:43:53.176]                           version <- NULL
[17:43:53.176]                         }
[17:43:53.176]                         if (!has_future || version < "1.8.0") {
[17:43:53.176]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.176]                             "", base::R.version$version.string), 
[17:43:53.176]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.176]                               "release", "version")], collapse = " "), 
[17:43:53.176]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.176]                             info)
[17:43:53.176]                           info <- base::paste(info, collapse = "; ")
[17:43:53.176]                           if (!has_future) {
[17:43:53.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.176]                               info)
[17:43:53.176]                           }
[17:43:53.176]                           else {
[17:43:53.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.176]                               info, version)
[17:43:53.176]                           }
[17:43:53.176]                           base::stop(msg)
[17:43:53.176]                         }
[17:43:53.176]                       })
[17:43:53.176]                     }
[17:43:53.176]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.176]                     base::options(mc.cores = 1L)
[17:43:53.176]                   }
[17:43:53.176]                   ...future.strategy.old <- future::plan("list")
[17:43:53.176]                   options(future.plan = NULL)
[17:43:53.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.176]                 }
[17:43:53.176]                 ...future.workdir <- getwd()
[17:43:53.176]             }
[17:43:53.176]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.176]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.176]         }
[17:43:53.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.176]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.176]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.176]             base::names(...future.oldOptions))
[17:43:53.176]     }
[17:43:53.176]     if (FALSE) {
[17:43:53.176]     }
[17:43:53.176]     else {
[17:43:53.176]         if (TRUE) {
[17:43:53.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.176]                 open = "w")
[17:43:53.176]         }
[17:43:53.176]         else {
[17:43:53.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.176]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.176]         }
[17:43:53.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.176]             base::sink(type = "output", split = FALSE)
[17:43:53.176]             base::close(...future.stdout)
[17:43:53.176]         }, add = TRUE)
[17:43:53.176]     }
[17:43:53.176]     ...future.frame <- base::sys.nframe()
[17:43:53.176]     ...future.conditions <- base::list()
[17:43:53.176]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.176]     if (FALSE) {
[17:43:53.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.176]     }
[17:43:53.176]     ...future.result <- base::tryCatch({
[17:43:53.176]         base::withCallingHandlers({
[17:43:53.176]             ...future.value <- base::withVisible(base::local({
[17:43:53.176]                 withCallingHandlers({
[17:43:53.176]                   {
[17:43:53.176]                     do.call(function(...) {
[17:43:53.176]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.176]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.176]                         ...future.globals.maxSize)) {
[17:43:53.176]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.176]                         on.exit(options(oopts), add = TRUE)
[17:43:53.176]                       }
[17:43:53.176]                       {
[17:43:53.176]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.176]                           FUN = function(jj) {
[17:43:53.176]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.176]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.176]                           })
[17:43:53.176]                       }
[17:43:53.176]                     }, args = future.call.arguments)
[17:43:53.176]                   }
[17:43:53.176]                 }, immediateCondition = function(cond) {
[17:43:53.176]                   save_rds <- function (object, pathname, ...) 
[17:43:53.176]                   {
[17:43:53.176]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.176]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.176]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.176]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.176]                         fi_tmp[["mtime"]])
[17:43:53.176]                     }
[17:43:53.176]                     tryCatch({
[17:43:53.176]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.176]                     }, error = function(ex) {
[17:43:53.176]                       msg <- conditionMessage(ex)
[17:43:53.176]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.176]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.176]                         fi_tmp[["mtime"]], msg)
[17:43:53.176]                       ex$message <- msg
[17:43:53.176]                       stop(ex)
[17:43:53.176]                     })
[17:43:53.176]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.176]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.176]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.176]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.176]                       fi <- file.info(pathname)
[17:43:53.176]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.176]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.176]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.176]                         fi[["size"]], fi[["mtime"]])
[17:43:53.176]                       stop(msg)
[17:43:53.176]                     }
[17:43:53.176]                     invisible(pathname)
[17:43:53.176]                   }
[17:43:53.176]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.176]                     rootPath = tempdir()) 
[17:43:53.176]                   {
[17:43:53.176]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.176]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.176]                       tmpdir = path, fileext = ".rds")
[17:43:53.176]                     save_rds(obj, file)
[17:43:53.176]                   }
[17:43:53.176]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.176]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.176]                   {
[17:43:53.176]                     inherits <- base::inherits
[17:43:53.176]                     invokeRestart <- base::invokeRestart
[17:43:53.176]                     is.null <- base::is.null
[17:43:53.176]                     muffled <- FALSE
[17:43:53.176]                     if (inherits(cond, "message")) {
[17:43:53.176]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.176]                       if (muffled) 
[17:43:53.176]                         invokeRestart("muffleMessage")
[17:43:53.176]                     }
[17:43:53.176]                     else if (inherits(cond, "warning")) {
[17:43:53.176]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.176]                       if (muffled) 
[17:43:53.176]                         invokeRestart("muffleWarning")
[17:43:53.176]                     }
[17:43:53.176]                     else if (inherits(cond, "condition")) {
[17:43:53.176]                       if (!is.null(pattern)) {
[17:43:53.176]                         computeRestarts <- base::computeRestarts
[17:43:53.176]                         grepl <- base::grepl
[17:43:53.176]                         restarts <- computeRestarts(cond)
[17:43:53.176]                         for (restart in restarts) {
[17:43:53.176]                           name <- restart$name
[17:43:53.176]                           if (is.null(name)) 
[17:43:53.176]                             next
[17:43:53.176]                           if (!grepl(pattern, name)) 
[17:43:53.176]                             next
[17:43:53.176]                           invokeRestart(restart)
[17:43:53.176]                           muffled <- TRUE
[17:43:53.176]                           break
[17:43:53.176]                         }
[17:43:53.176]                       }
[17:43:53.176]                     }
[17:43:53.176]                     invisible(muffled)
[17:43:53.176]                   }
[17:43:53.176]                   muffleCondition(cond)
[17:43:53.176]                 })
[17:43:53.176]             }))
[17:43:53.176]             future::FutureResult(value = ...future.value$value, 
[17:43:53.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.176]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.176]                     ...future.globalenv.names))
[17:43:53.176]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.176]         }, condition = base::local({
[17:43:53.176]             c <- base::c
[17:43:53.176]             inherits <- base::inherits
[17:43:53.176]             invokeRestart <- base::invokeRestart
[17:43:53.176]             length <- base::length
[17:43:53.176]             list <- base::list
[17:43:53.176]             seq.int <- base::seq.int
[17:43:53.176]             signalCondition <- base::signalCondition
[17:43:53.176]             sys.calls <- base::sys.calls
[17:43:53.176]             `[[` <- base::`[[`
[17:43:53.176]             `+` <- base::`+`
[17:43:53.176]             `<<-` <- base::`<<-`
[17:43:53.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.176]                   3L)]
[17:43:53.176]             }
[17:43:53.176]             function(cond) {
[17:43:53.176]                 is_error <- inherits(cond, "error")
[17:43:53.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.176]                   NULL)
[17:43:53.176]                 if (is_error) {
[17:43:53.176]                   sessionInformation <- function() {
[17:43:53.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.176]                       search = base::search(), system = base::Sys.info())
[17:43:53.176]                   }
[17:43:53.176]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.176]                     cond$call), session = sessionInformation(), 
[17:43:53.176]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.176]                   signalCondition(cond)
[17:43:53.176]                 }
[17:43:53.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.176]                 "immediateCondition"))) {
[17:43:53.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.176]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.176]                   if (TRUE && !signal) {
[17:43:53.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.176]                     {
[17:43:53.176]                       inherits <- base::inherits
[17:43:53.176]                       invokeRestart <- base::invokeRestart
[17:43:53.176]                       is.null <- base::is.null
[17:43:53.176]                       muffled <- FALSE
[17:43:53.176]                       if (inherits(cond, "message")) {
[17:43:53.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.176]                         if (muffled) 
[17:43:53.176]                           invokeRestart("muffleMessage")
[17:43:53.176]                       }
[17:43:53.176]                       else if (inherits(cond, "warning")) {
[17:43:53.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.176]                         if (muffled) 
[17:43:53.176]                           invokeRestart("muffleWarning")
[17:43:53.176]                       }
[17:43:53.176]                       else if (inherits(cond, "condition")) {
[17:43:53.176]                         if (!is.null(pattern)) {
[17:43:53.176]                           computeRestarts <- base::computeRestarts
[17:43:53.176]                           grepl <- base::grepl
[17:43:53.176]                           restarts <- computeRestarts(cond)
[17:43:53.176]                           for (restart in restarts) {
[17:43:53.176]                             name <- restart$name
[17:43:53.176]                             if (is.null(name)) 
[17:43:53.176]                               next
[17:43:53.176]                             if (!grepl(pattern, name)) 
[17:43:53.176]                               next
[17:43:53.176]                             invokeRestart(restart)
[17:43:53.176]                             muffled <- TRUE
[17:43:53.176]                             break
[17:43:53.176]                           }
[17:43:53.176]                         }
[17:43:53.176]                       }
[17:43:53.176]                       invisible(muffled)
[17:43:53.176]                     }
[17:43:53.176]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.176]                   }
[17:43:53.176]                 }
[17:43:53.176]                 else {
[17:43:53.176]                   if (TRUE) {
[17:43:53.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.176]                     {
[17:43:53.176]                       inherits <- base::inherits
[17:43:53.176]                       invokeRestart <- base::invokeRestart
[17:43:53.176]                       is.null <- base::is.null
[17:43:53.176]                       muffled <- FALSE
[17:43:53.176]                       if (inherits(cond, "message")) {
[17:43:53.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.176]                         if (muffled) 
[17:43:53.176]                           invokeRestart("muffleMessage")
[17:43:53.176]                       }
[17:43:53.176]                       else if (inherits(cond, "warning")) {
[17:43:53.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.176]                         if (muffled) 
[17:43:53.176]                           invokeRestart("muffleWarning")
[17:43:53.176]                       }
[17:43:53.176]                       else if (inherits(cond, "condition")) {
[17:43:53.176]                         if (!is.null(pattern)) {
[17:43:53.176]                           computeRestarts <- base::computeRestarts
[17:43:53.176]                           grepl <- base::grepl
[17:43:53.176]                           restarts <- computeRestarts(cond)
[17:43:53.176]                           for (restart in restarts) {
[17:43:53.176]                             name <- restart$name
[17:43:53.176]                             if (is.null(name)) 
[17:43:53.176]                               next
[17:43:53.176]                             if (!grepl(pattern, name)) 
[17:43:53.176]                               next
[17:43:53.176]                             invokeRestart(restart)
[17:43:53.176]                             muffled <- TRUE
[17:43:53.176]                             break
[17:43:53.176]                           }
[17:43:53.176]                         }
[17:43:53.176]                       }
[17:43:53.176]                       invisible(muffled)
[17:43:53.176]                     }
[17:43:53.176]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.176]                   }
[17:43:53.176]                 }
[17:43:53.176]             }
[17:43:53.176]         }))
[17:43:53.176]     }, error = function(ex) {
[17:43:53.176]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.176]                 ...future.rng), started = ...future.startTime, 
[17:43:53.176]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.176]             version = "1.8"), class = "FutureResult")
[17:43:53.176]     }, finally = {
[17:43:53.176]         if (!identical(...future.workdir, getwd())) 
[17:43:53.176]             setwd(...future.workdir)
[17:43:53.176]         {
[17:43:53.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.176]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.176]             }
[17:43:53.176]             base::options(...future.oldOptions)
[17:43:53.176]             if (.Platform$OS.type == "windows") {
[17:43:53.176]                 old_names <- names(...future.oldEnvVars)
[17:43:53.176]                 envs <- base::Sys.getenv()
[17:43:53.176]                 names <- names(envs)
[17:43:53.176]                 common <- intersect(names, old_names)
[17:43:53.176]                 added <- setdiff(names, old_names)
[17:43:53.176]                 removed <- setdiff(old_names, names)
[17:43:53.176]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.176]                   envs[common]]
[17:43:53.176]                 NAMES <- toupper(changed)
[17:43:53.176]                 args <- list()
[17:43:53.176]                 for (kk in seq_along(NAMES)) {
[17:43:53.176]                   name <- changed[[kk]]
[17:43:53.176]                   NAME <- NAMES[[kk]]
[17:43:53.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.176]                     next
[17:43:53.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.176]                 }
[17:43:53.176]                 NAMES <- toupper(added)
[17:43:53.176]                 for (kk in seq_along(NAMES)) {
[17:43:53.176]                   name <- added[[kk]]
[17:43:53.176]                   NAME <- NAMES[[kk]]
[17:43:53.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.176]                     next
[17:43:53.176]                   args[[name]] <- ""
[17:43:53.176]                 }
[17:43:53.176]                 NAMES <- toupper(removed)
[17:43:53.176]                 for (kk in seq_along(NAMES)) {
[17:43:53.176]                   name <- removed[[kk]]
[17:43:53.176]                   NAME <- NAMES[[kk]]
[17:43:53.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.176]                     next
[17:43:53.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.176]                 }
[17:43:53.176]                 if (length(args) > 0) 
[17:43:53.176]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.176]             }
[17:43:53.176]             else {
[17:43:53.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.176]             }
[17:43:53.176]             {
[17:43:53.176]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.176]                   0L) {
[17:43:53.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.176]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.176]                   base::options(opts)
[17:43:53.176]                 }
[17:43:53.176]                 {
[17:43:53.176]                   {
[17:43:53.176]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.176]                     NULL
[17:43:53.176]                   }
[17:43:53.176]                   options(future.plan = NULL)
[17:43:53.176]                   if (is.na(NA_character_)) 
[17:43:53.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.176]                     .init = FALSE)
[17:43:53.176]                 }
[17:43:53.176]             }
[17:43:53.176]         }
[17:43:53.176]     })
[17:43:53.176]     if (TRUE) {
[17:43:53.176]         base::sink(type = "output", split = FALSE)
[17:43:53.176]         if (TRUE) {
[17:43:53.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.176]         }
[17:43:53.176]         else {
[17:43:53.176]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.176]         }
[17:43:53.176]         base::close(...future.stdout)
[17:43:53.176]         ...future.stdout <- NULL
[17:43:53.176]     }
[17:43:53.176]     ...future.result$conditions <- ...future.conditions
[17:43:53.176]     ...future.result$finished <- base::Sys.time()
[17:43:53.176]     ...future.result
[17:43:53.176] }
[17:43:53.178] assign_globals() ...
[17:43:53.178] List of 5
[17:43:53.178]  $ ...future.FUN            :function (object, ...)  
[17:43:53.178]  $ future.call.arguments    : list()
[17:43:53.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.178]  $ ...future.elements_ii    :List of 2
[17:43:53.178]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:53.178]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.178]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.178]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:43:53.178]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.178]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.178]  $ ...future.seeds_ii       : NULL
[17:43:53.178]  $ ...future.globals.maxSize: NULL
[17:43:53.178]  - attr(*, "where")=List of 5
[17:43:53.178]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.178]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.178]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.178]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.178]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.178]  - attr(*, "resolved")= logi FALSE
[17:43:53.178]  - attr(*, "total_size")= num 1240
[17:43:53.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.178]  - attr(*, "already-done")= logi TRUE
[17:43:53.186] - copied ‘...future.FUN’ to environment
[17:43:53.186] - copied ‘future.call.arguments’ to environment
[17:43:53.186] - copied ‘...future.elements_ii’ to environment
[17:43:53.186] - copied ‘...future.seeds_ii’ to environment
[17:43:53.186] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.187] assign_globals() ... done
[17:43:53.187] requestCore(): workers = 2
[17:43:53.194] MulticoreFuture started
[17:43:53.194] - Launch lazy future ... done
[17:43:53.195] plan(): Setting new future strategy stack:
[17:43:53.195] run() for ‘MulticoreFuture’ ... done
[17:43:53.195] Created future:
[17:43:53.195] List of future strategies:
[17:43:53.195] 1. sequential:
[17:43:53.195]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.195]    - tweaked: FALSE
[17:43:53.195]    - call: NULL
[17:43:53.197] plan(): nbrOfWorkers() = 1
[17:43:53.202] plan(): Setting new future strategy stack:
[17:43:53.203] List of future strategies:
[17:43:53.203] 1. multicore:
[17:43:53.203]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.203]    - tweaked: FALSE
[17:43:53.203]    - call: plan(strategy)
[17:43:53.209] plan(): nbrOfWorkers() = 2
[17:43:53.196] MulticoreFuture:
[17:43:53.196] Label: ‘future_by-2’
[17:43:53.196] Expression:
[17:43:53.196] {
[17:43:53.196]     do.call(function(...) {
[17:43:53.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.196]             on.exit(options(oopts), add = TRUE)
[17:43:53.196]         }
[17:43:53.196]         {
[17:43:53.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.196]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.196]             })
[17:43:53.196]         }
[17:43:53.196]     }, args = future.call.arguments)
[17:43:53.196] }
[17:43:53.196] Lazy evaluation: FALSE
[17:43:53.196] Asynchronous evaluation: TRUE
[17:43:53.196] Local evaluation: TRUE
[17:43:53.196] Environment: R_GlobalEnv
[17:43:53.196] Capture standard output: TRUE
[17:43:53.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.196] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.196] Packages: <none>
[17:43:53.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.196] Resolved: TRUE
[17:43:53.196] Value: <not collected>
[17:43:53.196] Conditions captured: <none>
[17:43:53.196] Early signaling: FALSE
[17:43:53.196] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.196] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.210] Chunk #2 of 2 ... DONE
[17:43:53.210] Launching 2 futures (chunks) ... DONE
[17:43:53.210] Resolving 2 futures (chunks) ...
[17:43:53.211] resolve() on list ...
[17:43:53.211]  recursive: 0
[17:43:53.211]  length: 2
[17:43:53.211] 
[17:43:53.211] Future #1
[17:43:53.212] result() for MulticoreFuture ...
[17:43:53.214] result() for MulticoreFuture ...
[17:43:53.214] result() for MulticoreFuture ... done
[17:43:53.214] result() for MulticoreFuture ... done
[17:43:53.215] result() for MulticoreFuture ...
[17:43:53.215] result() for MulticoreFuture ... done
[17:43:53.215] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:53.215] - nx: 2
[17:43:53.215] - relay: TRUE
[17:43:53.215] - stdout: TRUE
[17:43:53.215] - signal: TRUE
[17:43:53.216] - resignal: FALSE
[17:43:53.216] - force: TRUE
[17:43:53.216] - relayed: [n=2] FALSE, FALSE
[17:43:53.216] - queued futures: [n=2] FALSE, FALSE
[17:43:53.216]  - until=1
[17:43:53.216]  - relaying element #1
[17:43:53.217] result() for MulticoreFuture ...
[17:43:53.217] result() for MulticoreFuture ... done
[17:43:53.217] result() for MulticoreFuture ...
[17:43:53.217] result() for MulticoreFuture ... done
[17:43:53.217] result() for MulticoreFuture ...
[17:43:53.218] result() for MulticoreFuture ... done
[17:43:53.218] result() for MulticoreFuture ...
[17:43:53.218] result() for MulticoreFuture ... done
[17:43:53.218] - relayed: [n=2] TRUE, FALSE
[17:43:53.218] - queued futures: [n=2] TRUE, FALSE
[17:43:53.218] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:53.218]  length: 1 (resolved future 1)
[17:43:53.219] Future #2
[17:43:53.219] result() for MulticoreFuture ...
[17:43:53.220] result() for MulticoreFuture ...
[17:43:53.220] result() for MulticoreFuture ... done
[17:43:53.220] result() for MulticoreFuture ... done
[17:43:53.220] result() for MulticoreFuture ...
[17:43:53.220] result() for MulticoreFuture ... done
[17:43:53.220] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:53.221] - nx: 2
[17:43:53.221] - relay: TRUE
[17:43:53.221] - stdout: TRUE
[17:43:53.221] - signal: TRUE
[17:43:53.221] - resignal: FALSE
[17:43:53.221] - force: TRUE
[17:43:53.221] - relayed: [n=2] TRUE, FALSE
[17:43:53.221] - queued futures: [n=2] TRUE, FALSE
[17:43:53.221]  - until=2
[17:43:53.221]  - relaying element #2
[17:43:53.222] result() for MulticoreFuture ...
[17:43:53.222] result() for MulticoreFuture ... done
[17:43:53.222] result() for MulticoreFuture ...
[17:43:53.222] result() for MulticoreFuture ... done
[17:43:53.222] result() for MulticoreFuture ...
[17:43:53.222] result() for MulticoreFuture ... done
[17:43:53.222] result() for MulticoreFuture ...
[17:43:53.222] result() for MulticoreFuture ... done
[17:43:53.222] - relayed: [n=2] TRUE, TRUE
[17:43:53.223] - queued futures: [n=2] TRUE, TRUE
[17:43:53.223] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:53.223]  length: 0 (resolved future 2)
[17:43:53.223] Relaying remaining futures
[17:43:53.223] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.223] - nx: 2
[17:43:53.223] - relay: TRUE
[17:43:53.223] - stdout: TRUE
[17:43:53.223] - signal: TRUE
[17:43:53.224] - resignal: FALSE
[17:43:53.224] - force: TRUE
[17:43:53.224] - relayed: [n=2] TRUE, TRUE
[17:43:53.224] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:53.224] - relayed: [n=2] TRUE, TRUE
[17:43:53.224] - queued futures: [n=2] TRUE, TRUE
[17:43:53.224] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.224] resolve() on list ... DONE
[17:43:53.224] result() for MulticoreFuture ...
[17:43:53.225] result() for MulticoreFuture ... done
[17:43:53.225] result() for MulticoreFuture ...
[17:43:53.225] result() for MulticoreFuture ... done
[17:43:53.225] result() for MulticoreFuture ...
[17:43:53.225] result() for MulticoreFuture ... done
[17:43:53.225] result() for MulticoreFuture ...
[17:43:53.225] result() for MulticoreFuture ... done
[17:43:53.225]  - Number of value chunks collected: 2
[17:43:53.225] Resolving 2 futures (chunks) ... DONE
[17:43:53.225] Reducing values from 2 chunks ...
[17:43:53.226]  - Number of values collected after concatenation: 3
[17:43:53.226]  - Number of values expected: 3
[17:43:53.226] Reducing values from 2 chunks ... DONE
[17:43:53.226] future_lapply() ... DONE
[17:43:53.226] future_by_internal() ... DONE
[17:43:53.226] future_by_internal() ...
[17:43:53.227] future_lapply() ...
[17:43:53.231] Number of chunks: 2
[17:43:53.231] getGlobalsAndPackagesXApply() ...
[17:43:53.231]  - future.globals: TRUE
[17:43:53.231] getGlobalsAndPackages() ...
[17:43:53.232] Searching for globals...
[17:43:53.233] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:53.233] Searching for globals ... DONE
[17:43:53.233] Resolving globals: FALSE
[17:43:53.233] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:53.234] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:53.234] - globals: [1] ‘FUN’
[17:43:53.234] 
[17:43:53.234] getGlobalsAndPackages() ... DONE
[17:43:53.234]  - globals found/used: [n=1] ‘FUN’
[17:43:53.234]  - needed namespaces: [n=0] 
[17:43:53.234] Finding globals ... DONE
[17:43:53.234]  - use_args: TRUE
[17:43:53.235]  - Getting '...' globals ...
[17:43:53.235] resolve() on list ...
[17:43:53.235]  recursive: 0
[17:43:53.235]  length: 1
[17:43:53.235]  elements: ‘...’
[17:43:53.235]  length: 0 (resolved future 1)
[17:43:53.237] resolve() on list ... DONE
[17:43:53.237]    - '...' content: [n=1] ‘digits’
[17:43:53.238] List of 1
[17:43:53.238]  $ ...:List of 1
[17:43:53.238]   ..$ digits: int 2
[17:43:53.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.238]  - attr(*, "where")=List of 1
[17:43:53.238]   ..$ ...:<environment: 0x55d6bab959b0> 
[17:43:53.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.238]  - attr(*, "resolved")= logi TRUE
[17:43:53.238]  - attr(*, "total_size")= num NA
[17:43:53.241]  - Getting '...' globals ... DONE
[17:43:53.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.242] List of 2
[17:43:53.242]  $ ...future.FUN:function (object, ...)  
[17:43:53.242]  $ ...          :List of 1
[17:43:53.242]   ..$ digits: int 2
[17:43:53.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.242]  - attr(*, "where")=List of 2
[17:43:53.242]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.242]   ..$ ...          :<environment: 0x55d6bab959b0> 
[17:43:53.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.242]  - attr(*, "resolved")= logi FALSE
[17:43:53.242]  - attr(*, "total_size")= num 1296
[17:43:53.245] Packages to be attached in all futures: [n=0] 
[17:43:53.245] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.245] Number of futures (= number of chunks): 2
[17:43:53.245] Launching 2 futures (chunks) ...
[17:43:53.245] Chunk #1 of 2 ...
[17:43:53.245]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.245] getGlobalsAndPackages() ...
[17:43:53.245] Searching for globals...
[17:43:53.246] 
[17:43:53.246] Searching for globals ... DONE
[17:43:53.246] - globals: [0] <none>
[17:43:53.246] getGlobalsAndPackages() ... DONE
[17:43:53.246]    + additional globals found: [n=0] 
[17:43:53.246]    + additional namespaces needed: [n=0] 
[17:43:53.246]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.246]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.246]  - seeds: <none>
[17:43:53.246]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.247] getGlobalsAndPackages() ...
[17:43:53.247] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.247] Resolving globals: FALSE
[17:43:53.247] Tweak future expression to call with '...' arguments ...
[17:43:53.247] {
[17:43:53.247]     do.call(function(...) {
[17:43:53.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.247]             on.exit(options(oopts), add = TRUE)
[17:43:53.247]         }
[17:43:53.247]         {
[17:43:53.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.247]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.247]             })
[17:43:53.247]         }
[17:43:53.247]     }, args = future.call.arguments)
[17:43:53.247] }
[17:43:53.247] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.248] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.248] 
[17:43:53.248] getGlobalsAndPackages() ... DONE
[17:43:53.248] run() for ‘Future’ ...
[17:43:53.248] - state: ‘created’
[17:43:53.249] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.252] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.252] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.252]   - Field: ‘label’
[17:43:53.252]   - Field: ‘local’
[17:43:53.253]   - Field: ‘owner’
[17:43:53.253]   - Field: ‘envir’
[17:43:53.253]   - Field: ‘workers’
[17:43:53.253]   - Field: ‘packages’
[17:43:53.253]   - Field: ‘gc’
[17:43:53.253]   - Field: ‘job’
[17:43:53.253]   - Field: ‘conditions’
[17:43:53.253]   - Field: ‘expr’
[17:43:53.253]   - Field: ‘uuid’
[17:43:53.253]   - Field: ‘seed’
[17:43:53.253]   - Field: ‘version’
[17:43:53.254]   - Field: ‘result’
[17:43:53.254]   - Field: ‘asynchronous’
[17:43:53.254]   - Field: ‘calls’
[17:43:53.254]   - Field: ‘globals’
[17:43:53.254]   - Field: ‘stdout’
[17:43:53.254]   - Field: ‘earlySignal’
[17:43:53.254]   - Field: ‘lazy’
[17:43:53.254]   - Field: ‘state’
[17:43:53.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.254] - Launch lazy future ...
[17:43:53.255] Packages needed by the future expression (n = 0): <none>
[17:43:53.255] Packages needed by future strategies (n = 0): <none>
[17:43:53.255] {
[17:43:53.255]     {
[17:43:53.255]         {
[17:43:53.255]             ...future.startTime <- base::Sys.time()
[17:43:53.255]             {
[17:43:53.255]                 {
[17:43:53.255]                   {
[17:43:53.255]                     {
[17:43:53.255]                       base::local({
[17:43:53.255]                         has_future <- base::requireNamespace("future", 
[17:43:53.255]                           quietly = TRUE)
[17:43:53.255]                         if (has_future) {
[17:43:53.255]                           ns <- base::getNamespace("future")
[17:43:53.255]                           version <- ns[[".package"]][["version"]]
[17:43:53.255]                           if (is.null(version)) 
[17:43:53.255]                             version <- utils::packageVersion("future")
[17:43:53.255]                         }
[17:43:53.255]                         else {
[17:43:53.255]                           version <- NULL
[17:43:53.255]                         }
[17:43:53.255]                         if (!has_future || version < "1.8.0") {
[17:43:53.255]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.255]                             "", base::R.version$version.string), 
[17:43:53.255]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.255]                               "release", "version")], collapse = " "), 
[17:43:53.255]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.255]                             info)
[17:43:53.255]                           info <- base::paste(info, collapse = "; ")
[17:43:53.255]                           if (!has_future) {
[17:43:53.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.255]                               info)
[17:43:53.255]                           }
[17:43:53.255]                           else {
[17:43:53.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.255]                               info, version)
[17:43:53.255]                           }
[17:43:53.255]                           base::stop(msg)
[17:43:53.255]                         }
[17:43:53.255]                       })
[17:43:53.255]                     }
[17:43:53.255]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.255]                     base::options(mc.cores = 1L)
[17:43:53.255]                   }
[17:43:53.255]                   ...future.strategy.old <- future::plan("list")
[17:43:53.255]                   options(future.plan = NULL)
[17:43:53.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.255]                 }
[17:43:53.255]                 ...future.workdir <- getwd()
[17:43:53.255]             }
[17:43:53.255]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.255]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.255]         }
[17:43:53.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.255]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.255]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.255]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.255]             base::names(...future.oldOptions))
[17:43:53.255]     }
[17:43:53.255]     if (FALSE) {
[17:43:53.255]     }
[17:43:53.255]     else {
[17:43:53.255]         if (TRUE) {
[17:43:53.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.255]                 open = "w")
[17:43:53.255]         }
[17:43:53.255]         else {
[17:43:53.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.255]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.255]         }
[17:43:53.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.255]             base::sink(type = "output", split = FALSE)
[17:43:53.255]             base::close(...future.stdout)
[17:43:53.255]         }, add = TRUE)
[17:43:53.255]     }
[17:43:53.255]     ...future.frame <- base::sys.nframe()
[17:43:53.255]     ...future.conditions <- base::list()
[17:43:53.255]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.255]     if (FALSE) {
[17:43:53.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.255]     }
[17:43:53.255]     ...future.result <- base::tryCatch({
[17:43:53.255]         base::withCallingHandlers({
[17:43:53.255]             ...future.value <- base::withVisible(base::local({
[17:43:53.255]                 withCallingHandlers({
[17:43:53.255]                   {
[17:43:53.255]                     do.call(function(...) {
[17:43:53.255]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.255]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.255]                         ...future.globals.maxSize)) {
[17:43:53.255]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.255]                         on.exit(options(oopts), add = TRUE)
[17:43:53.255]                       }
[17:43:53.255]                       {
[17:43:53.255]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.255]                           FUN = function(jj) {
[17:43:53.255]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.255]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.255]                           })
[17:43:53.255]                       }
[17:43:53.255]                     }, args = future.call.arguments)
[17:43:53.255]                   }
[17:43:53.255]                 }, immediateCondition = function(cond) {
[17:43:53.255]                   save_rds <- function (object, pathname, ...) 
[17:43:53.255]                   {
[17:43:53.255]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.255]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.255]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.255]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.255]                         fi_tmp[["mtime"]])
[17:43:53.255]                     }
[17:43:53.255]                     tryCatch({
[17:43:53.255]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.255]                     }, error = function(ex) {
[17:43:53.255]                       msg <- conditionMessage(ex)
[17:43:53.255]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.255]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.255]                         fi_tmp[["mtime"]], msg)
[17:43:53.255]                       ex$message <- msg
[17:43:53.255]                       stop(ex)
[17:43:53.255]                     })
[17:43:53.255]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.255]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.255]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.255]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.255]                       fi <- file.info(pathname)
[17:43:53.255]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.255]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.255]                         fi[["size"]], fi[["mtime"]])
[17:43:53.255]                       stop(msg)
[17:43:53.255]                     }
[17:43:53.255]                     invisible(pathname)
[17:43:53.255]                   }
[17:43:53.255]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.255]                     rootPath = tempdir()) 
[17:43:53.255]                   {
[17:43:53.255]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.255]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.255]                       tmpdir = path, fileext = ".rds")
[17:43:53.255]                     save_rds(obj, file)
[17:43:53.255]                   }
[17:43:53.255]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.255]                   {
[17:43:53.255]                     inherits <- base::inherits
[17:43:53.255]                     invokeRestart <- base::invokeRestart
[17:43:53.255]                     is.null <- base::is.null
[17:43:53.255]                     muffled <- FALSE
[17:43:53.255]                     if (inherits(cond, "message")) {
[17:43:53.255]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.255]                       if (muffled) 
[17:43:53.255]                         invokeRestart("muffleMessage")
[17:43:53.255]                     }
[17:43:53.255]                     else if (inherits(cond, "warning")) {
[17:43:53.255]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.255]                       if (muffled) 
[17:43:53.255]                         invokeRestart("muffleWarning")
[17:43:53.255]                     }
[17:43:53.255]                     else if (inherits(cond, "condition")) {
[17:43:53.255]                       if (!is.null(pattern)) {
[17:43:53.255]                         computeRestarts <- base::computeRestarts
[17:43:53.255]                         grepl <- base::grepl
[17:43:53.255]                         restarts <- computeRestarts(cond)
[17:43:53.255]                         for (restart in restarts) {
[17:43:53.255]                           name <- restart$name
[17:43:53.255]                           if (is.null(name)) 
[17:43:53.255]                             next
[17:43:53.255]                           if (!grepl(pattern, name)) 
[17:43:53.255]                             next
[17:43:53.255]                           invokeRestart(restart)
[17:43:53.255]                           muffled <- TRUE
[17:43:53.255]                           break
[17:43:53.255]                         }
[17:43:53.255]                       }
[17:43:53.255]                     }
[17:43:53.255]                     invisible(muffled)
[17:43:53.255]                   }
[17:43:53.255]                   muffleCondition(cond)
[17:43:53.255]                 })
[17:43:53.255]             }))
[17:43:53.255]             future::FutureResult(value = ...future.value$value, 
[17:43:53.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.255]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.255]                     ...future.globalenv.names))
[17:43:53.255]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.255]         }, condition = base::local({
[17:43:53.255]             c <- base::c
[17:43:53.255]             inherits <- base::inherits
[17:43:53.255]             invokeRestart <- base::invokeRestart
[17:43:53.255]             length <- base::length
[17:43:53.255]             list <- base::list
[17:43:53.255]             seq.int <- base::seq.int
[17:43:53.255]             signalCondition <- base::signalCondition
[17:43:53.255]             sys.calls <- base::sys.calls
[17:43:53.255]             `[[` <- base::`[[`
[17:43:53.255]             `+` <- base::`+`
[17:43:53.255]             `<<-` <- base::`<<-`
[17:43:53.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.255]                   3L)]
[17:43:53.255]             }
[17:43:53.255]             function(cond) {
[17:43:53.255]                 is_error <- inherits(cond, "error")
[17:43:53.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.255]                   NULL)
[17:43:53.255]                 if (is_error) {
[17:43:53.255]                   sessionInformation <- function() {
[17:43:53.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.255]                       search = base::search(), system = base::Sys.info())
[17:43:53.255]                   }
[17:43:53.255]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.255]                     cond$call), session = sessionInformation(), 
[17:43:53.255]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.255]                   signalCondition(cond)
[17:43:53.255]                 }
[17:43:53.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.255]                 "immediateCondition"))) {
[17:43:53.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.255]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.255]                   if (TRUE && !signal) {
[17:43:53.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.255]                     {
[17:43:53.255]                       inherits <- base::inherits
[17:43:53.255]                       invokeRestart <- base::invokeRestart
[17:43:53.255]                       is.null <- base::is.null
[17:43:53.255]                       muffled <- FALSE
[17:43:53.255]                       if (inherits(cond, "message")) {
[17:43:53.255]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.255]                         if (muffled) 
[17:43:53.255]                           invokeRestart("muffleMessage")
[17:43:53.255]                       }
[17:43:53.255]                       else if (inherits(cond, "warning")) {
[17:43:53.255]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.255]                         if (muffled) 
[17:43:53.255]                           invokeRestart("muffleWarning")
[17:43:53.255]                       }
[17:43:53.255]                       else if (inherits(cond, "condition")) {
[17:43:53.255]                         if (!is.null(pattern)) {
[17:43:53.255]                           computeRestarts <- base::computeRestarts
[17:43:53.255]                           grepl <- base::grepl
[17:43:53.255]                           restarts <- computeRestarts(cond)
[17:43:53.255]                           for (restart in restarts) {
[17:43:53.255]                             name <- restart$name
[17:43:53.255]                             if (is.null(name)) 
[17:43:53.255]                               next
[17:43:53.255]                             if (!grepl(pattern, name)) 
[17:43:53.255]                               next
[17:43:53.255]                             invokeRestart(restart)
[17:43:53.255]                             muffled <- TRUE
[17:43:53.255]                             break
[17:43:53.255]                           }
[17:43:53.255]                         }
[17:43:53.255]                       }
[17:43:53.255]                       invisible(muffled)
[17:43:53.255]                     }
[17:43:53.255]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.255]                   }
[17:43:53.255]                 }
[17:43:53.255]                 else {
[17:43:53.255]                   if (TRUE) {
[17:43:53.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.255]                     {
[17:43:53.255]                       inherits <- base::inherits
[17:43:53.255]                       invokeRestart <- base::invokeRestart
[17:43:53.255]                       is.null <- base::is.null
[17:43:53.255]                       muffled <- FALSE
[17:43:53.255]                       if (inherits(cond, "message")) {
[17:43:53.255]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.255]                         if (muffled) 
[17:43:53.255]                           invokeRestart("muffleMessage")
[17:43:53.255]                       }
[17:43:53.255]                       else if (inherits(cond, "warning")) {
[17:43:53.255]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.255]                         if (muffled) 
[17:43:53.255]                           invokeRestart("muffleWarning")
[17:43:53.255]                       }
[17:43:53.255]                       else if (inherits(cond, "condition")) {
[17:43:53.255]                         if (!is.null(pattern)) {
[17:43:53.255]                           computeRestarts <- base::computeRestarts
[17:43:53.255]                           grepl <- base::grepl
[17:43:53.255]                           restarts <- computeRestarts(cond)
[17:43:53.255]                           for (restart in restarts) {
[17:43:53.255]                             name <- restart$name
[17:43:53.255]                             if (is.null(name)) 
[17:43:53.255]                               next
[17:43:53.255]                             if (!grepl(pattern, name)) 
[17:43:53.255]                               next
[17:43:53.255]                             invokeRestart(restart)
[17:43:53.255]                             muffled <- TRUE
[17:43:53.255]                             break
[17:43:53.255]                           }
[17:43:53.255]                         }
[17:43:53.255]                       }
[17:43:53.255]                       invisible(muffled)
[17:43:53.255]                     }
[17:43:53.255]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.255]                   }
[17:43:53.255]                 }
[17:43:53.255]             }
[17:43:53.255]         }))
[17:43:53.255]     }, error = function(ex) {
[17:43:53.255]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.255]                 ...future.rng), started = ...future.startTime, 
[17:43:53.255]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.255]             version = "1.8"), class = "FutureResult")
[17:43:53.255]     }, finally = {
[17:43:53.255]         if (!identical(...future.workdir, getwd())) 
[17:43:53.255]             setwd(...future.workdir)
[17:43:53.255]         {
[17:43:53.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.255]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.255]             }
[17:43:53.255]             base::options(...future.oldOptions)
[17:43:53.255]             if (.Platform$OS.type == "windows") {
[17:43:53.255]                 old_names <- names(...future.oldEnvVars)
[17:43:53.255]                 envs <- base::Sys.getenv()
[17:43:53.255]                 names <- names(envs)
[17:43:53.255]                 common <- intersect(names, old_names)
[17:43:53.255]                 added <- setdiff(names, old_names)
[17:43:53.255]                 removed <- setdiff(old_names, names)
[17:43:53.255]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.255]                   envs[common]]
[17:43:53.255]                 NAMES <- toupper(changed)
[17:43:53.255]                 args <- list()
[17:43:53.255]                 for (kk in seq_along(NAMES)) {
[17:43:53.255]                   name <- changed[[kk]]
[17:43:53.255]                   NAME <- NAMES[[kk]]
[17:43:53.255]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.255]                     next
[17:43:53.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.255]                 }
[17:43:53.255]                 NAMES <- toupper(added)
[17:43:53.255]                 for (kk in seq_along(NAMES)) {
[17:43:53.255]                   name <- added[[kk]]
[17:43:53.255]                   NAME <- NAMES[[kk]]
[17:43:53.255]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.255]                     next
[17:43:53.255]                   args[[name]] <- ""
[17:43:53.255]                 }
[17:43:53.255]                 NAMES <- toupper(removed)
[17:43:53.255]                 for (kk in seq_along(NAMES)) {
[17:43:53.255]                   name <- removed[[kk]]
[17:43:53.255]                   NAME <- NAMES[[kk]]
[17:43:53.255]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.255]                     next
[17:43:53.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.255]                 }
[17:43:53.255]                 if (length(args) > 0) 
[17:43:53.255]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.255]             }
[17:43:53.255]             else {
[17:43:53.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.255]             }
[17:43:53.255]             {
[17:43:53.255]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.255]                   0L) {
[17:43:53.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.255]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.255]                   base::options(opts)
[17:43:53.255]                 }
[17:43:53.255]                 {
[17:43:53.255]                   {
[17:43:53.255]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.255]                     NULL
[17:43:53.255]                   }
[17:43:53.255]                   options(future.plan = NULL)
[17:43:53.255]                   if (is.na(NA_character_)) 
[17:43:53.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.255]                     .init = FALSE)
[17:43:53.255]                 }
[17:43:53.255]             }
[17:43:53.255]         }
[17:43:53.255]     })
[17:43:53.255]     if (TRUE) {
[17:43:53.255]         base::sink(type = "output", split = FALSE)
[17:43:53.255]         if (TRUE) {
[17:43:53.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.255]         }
[17:43:53.255]         else {
[17:43:53.255]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.255]         }
[17:43:53.255]         base::close(...future.stdout)
[17:43:53.255]         ...future.stdout <- NULL
[17:43:53.255]     }
[17:43:53.255]     ...future.result$conditions <- ...future.conditions
[17:43:53.255]     ...future.result$finished <- base::Sys.time()
[17:43:53.255]     ...future.result
[17:43:53.255] }
[17:43:53.258] assign_globals() ...
[17:43:53.258] List of 5
[17:43:53.258]  $ ...future.FUN            :function (object, ...)  
[17:43:53.258]  $ future.call.arguments    :List of 1
[17:43:53.258]   ..$ digits: int 2
[17:43:53.258]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.258]  $ ...future.elements_ii    :List of 3
[17:43:53.258]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:43:53.258]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:43:53.258]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:43:53.258]  $ ...future.seeds_ii       : NULL
[17:43:53.258]  $ ...future.globals.maxSize: NULL
[17:43:53.258]  - attr(*, "where")=List of 5
[17:43:53.258]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.258]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.258]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.258]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.258]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.258]  - attr(*, "resolved")= logi FALSE
[17:43:53.258]  - attr(*, "total_size")= num 1296
[17:43:53.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.258]  - attr(*, "already-done")= logi TRUE
[17:43:53.265] - copied ‘...future.FUN’ to environment
[17:43:53.265] - copied ‘future.call.arguments’ to environment
[17:43:53.265] - copied ‘...future.elements_ii’ to environment
[17:43:53.265] - copied ‘...future.seeds_ii’ to environment
[17:43:53.266] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.266] assign_globals() ... done
[17:43:53.266] requestCore(): workers = 2
[17:43:53.268] MulticoreFuture started
[17:43:53.268] - Launch lazy future ... done
[17:43:53.269] run() for ‘MulticoreFuture’ ... done
[17:43:53.269] Created future:
[17:43:53.269] plan(): Setting new future strategy stack:
[17:43:53.269] List of future strategies:
[17:43:53.269] 1. sequential:
[17:43:53.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.269]    - tweaked: FALSE
[17:43:53.269]    - call: NULL
[17:43:53.270] plan(): nbrOfWorkers() = 1
[17:43:53.274] plan(): Setting new future strategy stack:
[17:43:53.274] List of future strategies:
[17:43:53.274] 1. multicore:
[17:43:53.274]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.274]    - tweaked: FALSE
[17:43:53.274]    - call: plan(strategy)
[17:43:53.279] plan(): nbrOfWorkers() = 2
[17:43:53.269] MulticoreFuture:
[17:43:53.269] Label: ‘future_by-1’
[17:43:53.269] Expression:
[17:43:53.269] {
[17:43:53.269]     do.call(function(...) {
[17:43:53.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.269]             on.exit(options(oopts), add = TRUE)
[17:43:53.269]         }
[17:43:53.269]         {
[17:43:53.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.269]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.269]             })
[17:43:53.269]         }
[17:43:53.269]     }, args = future.call.arguments)
[17:43:53.269] }
[17:43:53.269] Lazy evaluation: FALSE
[17:43:53.269] Asynchronous evaluation: TRUE
[17:43:53.269] Local evaluation: TRUE
[17:43:53.269] Environment: R_GlobalEnv
[17:43:53.269] Capture standard output: TRUE
[17:43:53.269] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.269] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.269] Packages: <none>
[17:43:53.269] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.269] Resolved: TRUE
[17:43:53.269] Value: <not collected>
[17:43:53.269] Conditions captured: <none>
[17:43:53.269] Early signaling: FALSE
[17:43:53.269] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.269] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.280] Chunk #1 of 2 ... DONE
[17:43:53.280] Chunk #2 of 2 ...
[17:43:53.281]  - Finding globals in 'X' for chunk #2 ...
[17:43:53.281] getGlobalsAndPackages() ...
[17:43:53.281] Searching for globals...
[17:43:53.281] 
[17:43:53.282] Searching for globals ... DONE
[17:43:53.282] - globals: [0] <none>
[17:43:53.282] getGlobalsAndPackages() ... DONE
[17:43:53.282]    + additional globals found: [n=0] 
[17:43:53.282]    + additional namespaces needed: [n=0] 
[17:43:53.282]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:53.282]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.283]  - seeds: <none>
[17:43:53.283]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.283] getGlobalsAndPackages() ...
[17:43:53.283] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.283] Resolving globals: FALSE
[17:43:53.283] Tweak future expression to call with '...' arguments ...
[17:43:53.284] {
[17:43:53.284]     do.call(function(...) {
[17:43:53.284]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.284]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.284]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.284]             on.exit(options(oopts), add = TRUE)
[17:43:53.284]         }
[17:43:53.284]         {
[17:43:53.284]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.284]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.284]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.284]             })
[17:43:53.284]         }
[17:43:53.284]     }, args = future.call.arguments)
[17:43:53.284] }
[17:43:53.284] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.285] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.285] 
[17:43:53.285] getGlobalsAndPackages() ... DONE
[17:43:53.285] run() for ‘Future’ ...
[17:43:53.286] - state: ‘created’
[17:43:53.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.291]   - Field: ‘label’
[17:43:53.291]   - Field: ‘local’
[17:43:53.291]   - Field: ‘owner’
[17:43:53.291]   - Field: ‘envir’
[17:43:53.291]   - Field: ‘workers’
[17:43:53.292]   - Field: ‘packages’
[17:43:53.292]   - Field: ‘gc’
[17:43:53.292]   - Field: ‘job’
[17:43:53.292]   - Field: ‘conditions’
[17:43:53.292]   - Field: ‘expr’
[17:43:53.292]   - Field: ‘uuid’
[17:43:53.292]   - Field: ‘seed’
[17:43:53.293]   - Field: ‘version’
[17:43:53.293]   - Field: ‘result’
[17:43:53.293]   - Field: ‘asynchronous’
[17:43:53.293]   - Field: ‘calls’
[17:43:53.293]   - Field: ‘globals’
[17:43:53.293]   - Field: ‘stdout’
[17:43:53.293]   - Field: ‘earlySignal’
[17:43:53.294]   - Field: ‘lazy’
[17:43:53.294]   - Field: ‘state’
[17:43:53.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.294] - Launch lazy future ...
[17:43:53.294] Packages needed by the future expression (n = 0): <none>
[17:43:53.295] Packages needed by future strategies (n = 0): <none>
[17:43:53.295] {
[17:43:53.295]     {
[17:43:53.295]         {
[17:43:53.295]             ...future.startTime <- base::Sys.time()
[17:43:53.295]             {
[17:43:53.295]                 {
[17:43:53.295]                   {
[17:43:53.295]                     {
[17:43:53.295]                       base::local({
[17:43:53.295]                         has_future <- base::requireNamespace("future", 
[17:43:53.295]                           quietly = TRUE)
[17:43:53.295]                         if (has_future) {
[17:43:53.295]                           ns <- base::getNamespace("future")
[17:43:53.295]                           version <- ns[[".package"]][["version"]]
[17:43:53.295]                           if (is.null(version)) 
[17:43:53.295]                             version <- utils::packageVersion("future")
[17:43:53.295]                         }
[17:43:53.295]                         else {
[17:43:53.295]                           version <- NULL
[17:43:53.295]                         }
[17:43:53.295]                         if (!has_future || version < "1.8.0") {
[17:43:53.295]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.295]                             "", base::R.version$version.string), 
[17:43:53.295]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.295]                               "release", "version")], collapse = " "), 
[17:43:53.295]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.295]                             info)
[17:43:53.295]                           info <- base::paste(info, collapse = "; ")
[17:43:53.295]                           if (!has_future) {
[17:43:53.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.295]                               info)
[17:43:53.295]                           }
[17:43:53.295]                           else {
[17:43:53.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.295]                               info, version)
[17:43:53.295]                           }
[17:43:53.295]                           base::stop(msg)
[17:43:53.295]                         }
[17:43:53.295]                       })
[17:43:53.295]                     }
[17:43:53.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.295]                     base::options(mc.cores = 1L)
[17:43:53.295]                   }
[17:43:53.295]                   ...future.strategy.old <- future::plan("list")
[17:43:53.295]                   options(future.plan = NULL)
[17:43:53.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.295]                 }
[17:43:53.295]                 ...future.workdir <- getwd()
[17:43:53.295]             }
[17:43:53.295]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.295]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.295]         }
[17:43:53.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.295]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.295]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.295]             base::names(...future.oldOptions))
[17:43:53.295]     }
[17:43:53.295]     if (FALSE) {
[17:43:53.295]     }
[17:43:53.295]     else {
[17:43:53.295]         if (TRUE) {
[17:43:53.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.295]                 open = "w")
[17:43:53.295]         }
[17:43:53.295]         else {
[17:43:53.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.295]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.295]         }
[17:43:53.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.295]             base::sink(type = "output", split = FALSE)
[17:43:53.295]             base::close(...future.stdout)
[17:43:53.295]         }, add = TRUE)
[17:43:53.295]     }
[17:43:53.295]     ...future.frame <- base::sys.nframe()
[17:43:53.295]     ...future.conditions <- base::list()
[17:43:53.295]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.295]     if (FALSE) {
[17:43:53.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.295]     }
[17:43:53.295]     ...future.result <- base::tryCatch({
[17:43:53.295]         base::withCallingHandlers({
[17:43:53.295]             ...future.value <- base::withVisible(base::local({
[17:43:53.295]                 withCallingHandlers({
[17:43:53.295]                   {
[17:43:53.295]                     do.call(function(...) {
[17:43:53.295]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.295]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.295]                         ...future.globals.maxSize)) {
[17:43:53.295]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.295]                         on.exit(options(oopts), add = TRUE)
[17:43:53.295]                       }
[17:43:53.295]                       {
[17:43:53.295]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.295]                           FUN = function(jj) {
[17:43:53.295]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.295]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.295]                           })
[17:43:53.295]                       }
[17:43:53.295]                     }, args = future.call.arguments)
[17:43:53.295]                   }
[17:43:53.295]                 }, immediateCondition = function(cond) {
[17:43:53.295]                   save_rds <- function (object, pathname, ...) 
[17:43:53.295]                   {
[17:43:53.295]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.295]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.295]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.295]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.295]                         fi_tmp[["mtime"]])
[17:43:53.295]                     }
[17:43:53.295]                     tryCatch({
[17:43:53.295]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.295]                     }, error = function(ex) {
[17:43:53.295]                       msg <- conditionMessage(ex)
[17:43:53.295]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.295]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.295]                         fi_tmp[["mtime"]], msg)
[17:43:53.295]                       ex$message <- msg
[17:43:53.295]                       stop(ex)
[17:43:53.295]                     })
[17:43:53.295]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.295]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.295]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.295]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.295]                       fi <- file.info(pathname)
[17:43:53.295]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.295]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.295]                         fi[["size"]], fi[["mtime"]])
[17:43:53.295]                       stop(msg)
[17:43:53.295]                     }
[17:43:53.295]                     invisible(pathname)
[17:43:53.295]                   }
[17:43:53.295]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.295]                     rootPath = tempdir()) 
[17:43:53.295]                   {
[17:43:53.295]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.295]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.295]                       tmpdir = path, fileext = ".rds")
[17:43:53.295]                     save_rds(obj, file)
[17:43:53.295]                   }
[17:43:53.295]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.295]                   {
[17:43:53.295]                     inherits <- base::inherits
[17:43:53.295]                     invokeRestart <- base::invokeRestart
[17:43:53.295]                     is.null <- base::is.null
[17:43:53.295]                     muffled <- FALSE
[17:43:53.295]                     if (inherits(cond, "message")) {
[17:43:53.295]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.295]                       if (muffled) 
[17:43:53.295]                         invokeRestart("muffleMessage")
[17:43:53.295]                     }
[17:43:53.295]                     else if (inherits(cond, "warning")) {
[17:43:53.295]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.295]                       if (muffled) 
[17:43:53.295]                         invokeRestart("muffleWarning")
[17:43:53.295]                     }
[17:43:53.295]                     else if (inherits(cond, "condition")) {
[17:43:53.295]                       if (!is.null(pattern)) {
[17:43:53.295]                         computeRestarts <- base::computeRestarts
[17:43:53.295]                         grepl <- base::grepl
[17:43:53.295]                         restarts <- computeRestarts(cond)
[17:43:53.295]                         for (restart in restarts) {
[17:43:53.295]                           name <- restart$name
[17:43:53.295]                           if (is.null(name)) 
[17:43:53.295]                             next
[17:43:53.295]                           if (!grepl(pattern, name)) 
[17:43:53.295]                             next
[17:43:53.295]                           invokeRestart(restart)
[17:43:53.295]                           muffled <- TRUE
[17:43:53.295]                           break
[17:43:53.295]                         }
[17:43:53.295]                       }
[17:43:53.295]                     }
[17:43:53.295]                     invisible(muffled)
[17:43:53.295]                   }
[17:43:53.295]                   muffleCondition(cond)
[17:43:53.295]                 })
[17:43:53.295]             }))
[17:43:53.295]             future::FutureResult(value = ...future.value$value, 
[17:43:53.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.295]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.295]                     ...future.globalenv.names))
[17:43:53.295]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.295]         }, condition = base::local({
[17:43:53.295]             c <- base::c
[17:43:53.295]             inherits <- base::inherits
[17:43:53.295]             invokeRestart <- base::invokeRestart
[17:43:53.295]             length <- base::length
[17:43:53.295]             list <- base::list
[17:43:53.295]             seq.int <- base::seq.int
[17:43:53.295]             signalCondition <- base::signalCondition
[17:43:53.295]             sys.calls <- base::sys.calls
[17:43:53.295]             `[[` <- base::`[[`
[17:43:53.295]             `+` <- base::`+`
[17:43:53.295]             `<<-` <- base::`<<-`
[17:43:53.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.295]                   3L)]
[17:43:53.295]             }
[17:43:53.295]             function(cond) {
[17:43:53.295]                 is_error <- inherits(cond, "error")
[17:43:53.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.295]                   NULL)
[17:43:53.295]                 if (is_error) {
[17:43:53.295]                   sessionInformation <- function() {
[17:43:53.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.295]                       search = base::search(), system = base::Sys.info())
[17:43:53.295]                   }
[17:43:53.295]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.295]                     cond$call), session = sessionInformation(), 
[17:43:53.295]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.295]                   signalCondition(cond)
[17:43:53.295]                 }
[17:43:53.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.295]                 "immediateCondition"))) {
[17:43:53.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.295]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.295]                   if (TRUE && !signal) {
[17:43:53.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.295]                     {
[17:43:53.295]                       inherits <- base::inherits
[17:43:53.295]                       invokeRestart <- base::invokeRestart
[17:43:53.295]                       is.null <- base::is.null
[17:43:53.295]                       muffled <- FALSE
[17:43:53.295]                       if (inherits(cond, "message")) {
[17:43:53.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.295]                         if (muffled) 
[17:43:53.295]                           invokeRestart("muffleMessage")
[17:43:53.295]                       }
[17:43:53.295]                       else if (inherits(cond, "warning")) {
[17:43:53.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.295]                         if (muffled) 
[17:43:53.295]                           invokeRestart("muffleWarning")
[17:43:53.295]                       }
[17:43:53.295]                       else if (inherits(cond, "condition")) {
[17:43:53.295]                         if (!is.null(pattern)) {
[17:43:53.295]                           computeRestarts <- base::computeRestarts
[17:43:53.295]                           grepl <- base::grepl
[17:43:53.295]                           restarts <- computeRestarts(cond)
[17:43:53.295]                           for (restart in restarts) {
[17:43:53.295]                             name <- restart$name
[17:43:53.295]                             if (is.null(name)) 
[17:43:53.295]                               next
[17:43:53.295]                             if (!grepl(pattern, name)) 
[17:43:53.295]                               next
[17:43:53.295]                             invokeRestart(restart)
[17:43:53.295]                             muffled <- TRUE
[17:43:53.295]                             break
[17:43:53.295]                           }
[17:43:53.295]                         }
[17:43:53.295]                       }
[17:43:53.295]                       invisible(muffled)
[17:43:53.295]                     }
[17:43:53.295]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.295]                   }
[17:43:53.295]                 }
[17:43:53.295]                 else {
[17:43:53.295]                   if (TRUE) {
[17:43:53.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.295]                     {
[17:43:53.295]                       inherits <- base::inherits
[17:43:53.295]                       invokeRestart <- base::invokeRestart
[17:43:53.295]                       is.null <- base::is.null
[17:43:53.295]                       muffled <- FALSE
[17:43:53.295]                       if (inherits(cond, "message")) {
[17:43:53.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.295]                         if (muffled) 
[17:43:53.295]                           invokeRestart("muffleMessage")
[17:43:53.295]                       }
[17:43:53.295]                       else if (inherits(cond, "warning")) {
[17:43:53.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.295]                         if (muffled) 
[17:43:53.295]                           invokeRestart("muffleWarning")
[17:43:53.295]                       }
[17:43:53.295]                       else if (inherits(cond, "condition")) {
[17:43:53.295]                         if (!is.null(pattern)) {
[17:43:53.295]                           computeRestarts <- base::computeRestarts
[17:43:53.295]                           grepl <- base::grepl
[17:43:53.295]                           restarts <- computeRestarts(cond)
[17:43:53.295]                           for (restart in restarts) {
[17:43:53.295]                             name <- restart$name
[17:43:53.295]                             if (is.null(name)) 
[17:43:53.295]                               next
[17:43:53.295]                             if (!grepl(pattern, name)) 
[17:43:53.295]                               next
[17:43:53.295]                             invokeRestart(restart)
[17:43:53.295]                             muffled <- TRUE
[17:43:53.295]                             break
[17:43:53.295]                           }
[17:43:53.295]                         }
[17:43:53.295]                       }
[17:43:53.295]                       invisible(muffled)
[17:43:53.295]                     }
[17:43:53.295]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.295]                   }
[17:43:53.295]                 }
[17:43:53.295]             }
[17:43:53.295]         }))
[17:43:53.295]     }, error = function(ex) {
[17:43:53.295]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.295]                 ...future.rng), started = ...future.startTime, 
[17:43:53.295]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.295]             version = "1.8"), class = "FutureResult")
[17:43:53.295]     }, finally = {
[17:43:53.295]         if (!identical(...future.workdir, getwd())) 
[17:43:53.295]             setwd(...future.workdir)
[17:43:53.295]         {
[17:43:53.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.295]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.295]             }
[17:43:53.295]             base::options(...future.oldOptions)
[17:43:53.295]             if (.Platform$OS.type == "windows") {
[17:43:53.295]                 old_names <- names(...future.oldEnvVars)
[17:43:53.295]                 envs <- base::Sys.getenv()
[17:43:53.295]                 names <- names(envs)
[17:43:53.295]                 common <- intersect(names, old_names)
[17:43:53.295]                 added <- setdiff(names, old_names)
[17:43:53.295]                 removed <- setdiff(old_names, names)
[17:43:53.295]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.295]                   envs[common]]
[17:43:53.295]                 NAMES <- toupper(changed)
[17:43:53.295]                 args <- list()
[17:43:53.295]                 for (kk in seq_along(NAMES)) {
[17:43:53.295]                   name <- changed[[kk]]
[17:43:53.295]                   NAME <- NAMES[[kk]]
[17:43:53.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.295]                     next
[17:43:53.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.295]                 }
[17:43:53.295]                 NAMES <- toupper(added)
[17:43:53.295]                 for (kk in seq_along(NAMES)) {
[17:43:53.295]                   name <- added[[kk]]
[17:43:53.295]                   NAME <- NAMES[[kk]]
[17:43:53.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.295]                     next
[17:43:53.295]                   args[[name]] <- ""
[17:43:53.295]                 }
[17:43:53.295]                 NAMES <- toupper(removed)
[17:43:53.295]                 for (kk in seq_along(NAMES)) {
[17:43:53.295]                   name <- removed[[kk]]
[17:43:53.295]                   NAME <- NAMES[[kk]]
[17:43:53.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.295]                     next
[17:43:53.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.295]                 }
[17:43:53.295]                 if (length(args) > 0) 
[17:43:53.295]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.295]             }
[17:43:53.295]             else {
[17:43:53.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.295]             }
[17:43:53.295]             {
[17:43:53.295]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.295]                   0L) {
[17:43:53.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.295]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.295]                   base::options(opts)
[17:43:53.295]                 }
[17:43:53.295]                 {
[17:43:53.295]                   {
[17:43:53.295]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.295]                     NULL
[17:43:53.295]                   }
[17:43:53.295]                   options(future.plan = NULL)
[17:43:53.295]                   if (is.na(NA_character_)) 
[17:43:53.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.295]                     .init = FALSE)
[17:43:53.295]                 }
[17:43:53.295]             }
[17:43:53.295]         }
[17:43:53.295]     })
[17:43:53.295]     if (TRUE) {
[17:43:53.295]         base::sink(type = "output", split = FALSE)
[17:43:53.295]         if (TRUE) {
[17:43:53.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.295]         }
[17:43:53.295]         else {
[17:43:53.295]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.295]         }
[17:43:53.295]         base::close(...future.stdout)
[17:43:53.295]         ...future.stdout <- NULL
[17:43:53.295]     }
[17:43:53.295]     ...future.result$conditions <- ...future.conditions
[17:43:53.295]     ...future.result$finished <- base::Sys.time()
[17:43:53.295]     ...future.result
[17:43:53.295] }
[17:43:53.299] assign_globals() ...
[17:43:53.299] List of 5
[17:43:53.299]  $ ...future.FUN            :function (object, ...)  
[17:43:53.299]  $ future.call.arguments    :List of 1
[17:43:53.299]   ..$ digits: int 2
[17:43:53.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.299]  $ ...future.elements_ii    :List of 3
[17:43:53.299]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:43:53.299]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:43:53.299]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:43:53.299]  $ ...future.seeds_ii       : NULL
[17:43:53.299]  $ ...future.globals.maxSize: NULL
[17:43:53.299]  - attr(*, "where")=List of 5
[17:43:53.299]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.299]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.299]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.299]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.299]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.299]  - attr(*, "resolved")= logi FALSE
[17:43:53.299]  - attr(*, "total_size")= num 1296
[17:43:53.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.299]  - attr(*, "already-done")= logi TRUE
[17:43:53.310] - copied ‘...future.FUN’ to environment
[17:43:53.311] - copied ‘future.call.arguments’ to environment
[17:43:53.311] - copied ‘...future.elements_ii’ to environment
[17:43:53.311] - copied ‘...future.seeds_ii’ to environment
[17:43:53.311] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.311] assign_globals() ... done
[17:43:53.311] requestCore(): workers = 2
[17:43:53.314] MulticoreFuture started
[17:43:53.314] - Launch lazy future ... done
[17:43:53.315] run() for ‘MulticoreFuture’ ... done
[17:43:53.315] plan(): Setting new future strategy stack:
[17:43:53.315] Created future:
[17:43:53.315] List of future strategies:
[17:43:53.315] 1. sequential:
[17:43:53.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.315]    - tweaked: FALSE
[17:43:53.315]    - call: NULL
[17:43:53.317] plan(): nbrOfWorkers() = 1
[17:43:53.320] plan(): Setting new future strategy stack:
[17:43:53.320] List of future strategies:
[17:43:53.320] 1. multicore:
[17:43:53.320]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.320]    - tweaked: FALSE
[17:43:53.320]    - call: plan(strategy)
[17:43:53.326] plan(): nbrOfWorkers() = 2
[17:43:53.316] MulticoreFuture:
[17:43:53.316] Label: ‘future_by-2’
[17:43:53.316] Expression:
[17:43:53.316] {
[17:43:53.316]     do.call(function(...) {
[17:43:53.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.316]             on.exit(options(oopts), add = TRUE)
[17:43:53.316]         }
[17:43:53.316]         {
[17:43:53.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.316]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.316]             })
[17:43:53.316]         }
[17:43:53.316]     }, args = future.call.arguments)
[17:43:53.316] }
[17:43:53.316] Lazy evaluation: FALSE
[17:43:53.316] Asynchronous evaluation: TRUE
[17:43:53.316] Local evaluation: TRUE
[17:43:53.316] Environment: R_GlobalEnv
[17:43:53.316] Capture standard output: TRUE
[17:43:53.316] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.316] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.316] Packages: <none>
[17:43:53.316] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.316] Resolved: TRUE
[17:43:53.316] Value: <not collected>
[17:43:53.316] Conditions captured: <none>
[17:43:53.316] Early signaling: FALSE
[17:43:53.316] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.316] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.327] Chunk #2 of 2 ... DONE
[17:43:53.328] Launching 2 futures (chunks) ... DONE
[17:43:53.328] Resolving 2 futures (chunks) ...
[17:43:53.328] resolve() on list ...
[17:43:53.328]  recursive: 0
[17:43:53.328]  length: 2
[17:43:53.328] 
[17:43:53.329] Future #1
[17:43:53.329] result() for MulticoreFuture ...
[17:43:53.330] result() for MulticoreFuture ...
[17:43:53.330] result() for MulticoreFuture ... done
[17:43:53.330] result() for MulticoreFuture ... done
[17:43:53.330] result() for MulticoreFuture ...
[17:43:53.330] result() for MulticoreFuture ... done
[17:43:53.330] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:53.331] - nx: 2
[17:43:53.331] - relay: TRUE
[17:43:53.331] - stdout: TRUE
[17:43:53.331] - signal: TRUE
[17:43:53.331] - resignal: FALSE
[17:43:53.331] - force: TRUE
[17:43:53.332] - relayed: [n=2] FALSE, FALSE
[17:43:53.332] - queued futures: [n=2] FALSE, FALSE
[17:43:53.332]  - until=1
[17:43:53.332]  - relaying element #1
[17:43:53.332] result() for MulticoreFuture ...
[17:43:53.332] result() for MulticoreFuture ... done
[17:43:53.333] result() for MulticoreFuture ...
[17:43:53.333] result() for MulticoreFuture ... done
[17:43:53.333] result() for MulticoreFuture ...
[17:43:53.333] result() for MulticoreFuture ... done
[17:43:53.333] result() for MulticoreFuture ...
[17:43:53.333] result() for MulticoreFuture ... done
[17:43:53.333] - relayed: [n=2] TRUE, FALSE
[17:43:53.334] - queued futures: [n=2] TRUE, FALSE
[17:43:53.334] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:53.334]  length: 1 (resolved future 1)
[17:43:53.334] Future #2
[17:43:53.334] result() for MulticoreFuture ...
[17:43:53.335] result() for MulticoreFuture ...
[17:43:53.335] result() for MulticoreFuture ... done
[17:43:53.335] result() for MulticoreFuture ... done
[17:43:53.335] result() for MulticoreFuture ...
[17:43:53.336] result() for MulticoreFuture ... done
[17:43:53.336] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:53.336] - nx: 2
[17:43:53.336] - relay: TRUE
[17:43:53.336] - stdout: TRUE
[17:43:53.336] - signal: TRUE
[17:43:53.336] - resignal: FALSE
[17:43:53.336] - force: TRUE
[17:43:53.337] - relayed: [n=2] TRUE, FALSE
[17:43:53.337] - queued futures: [n=2] TRUE, FALSE
[17:43:53.337]  - until=2
[17:43:53.337]  - relaying element #2
[17:43:53.337] result() for MulticoreFuture ...
[17:43:53.337] result() for MulticoreFuture ... done
[17:43:53.337] result() for MulticoreFuture ...
[17:43:53.337] result() for MulticoreFuture ... done
[17:43:53.338] result() for MulticoreFuture ...
[17:43:53.338] result() for MulticoreFuture ... done
[17:43:53.338] result() for MulticoreFuture ...
[17:43:53.338] result() for MulticoreFuture ... done
[17:43:53.338] - relayed: [n=2] TRUE, TRUE
[17:43:53.338] - queued futures: [n=2] TRUE, TRUE
[17:43:53.338] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:53.338]  length: 0 (resolved future 2)
[17:43:53.338] Relaying remaining futures
[17:43:53.339] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.339] - nx: 2
[17:43:53.339] - relay: TRUE
[17:43:53.339] - stdout: TRUE
[17:43:53.339] - signal: TRUE
[17:43:53.339] - resignal: FALSE
[17:43:53.339] - force: TRUE
[17:43:53.339] - relayed: [n=2] TRUE, TRUE
[17:43:53.339] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:53.340] - relayed: [n=2] TRUE, TRUE
[17:43:53.340] - queued futures: [n=2] TRUE, TRUE
[17:43:53.340] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.340] resolve() on list ... DONE
[17:43:53.340] result() for MulticoreFuture ...
[17:43:53.340] result() for MulticoreFuture ... done
[17:43:53.340] result() for MulticoreFuture ...
[17:43:53.340] result() for MulticoreFuture ... done
[17:43:53.340] result() for MulticoreFuture ...
[17:43:53.341] result() for MulticoreFuture ... done
[17:43:53.341] result() for MulticoreFuture ...
[17:43:53.341] result() for MulticoreFuture ... done
[17:43:53.341]  - Number of value chunks collected: 2
[17:43:53.341] Resolving 2 futures (chunks) ... DONE
[17:43:53.341] Reducing values from 2 chunks ...
[17:43:53.341]  - Number of values collected after concatenation: 6
[17:43:53.341]  - Number of values expected: 6
[17:43:53.341] Reducing values from 2 chunks ... DONE
[17:43:53.342] future_lapply() ... DONE
[17:43:53.342] future_by_internal() ... DONE
[17:43:53.343] future_by_internal() ...
[17:43:53.343] future_lapply() ...
[17:43:53.351] Number of chunks: 2
[17:43:53.351] getGlobalsAndPackagesXApply() ...
[17:43:53.351]  - future.globals: TRUE
[17:43:53.351] getGlobalsAndPackages() ...
[17:43:53.351] Searching for globals...
[17:43:53.354] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:53.354] Searching for globals ... DONE
[17:43:53.354] Resolving globals: FALSE
[17:43:53.355] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:43:53.355] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:43:53.355] - globals: [1] ‘FUN’
[17:43:53.355] - packages: [1] ‘stats’
[17:43:53.355] getGlobalsAndPackages() ... DONE
[17:43:53.356]  - globals found/used: [n=1] ‘FUN’
[17:43:53.356]  - needed namespaces: [n=1] ‘stats’
[17:43:53.356] Finding globals ... DONE
[17:43:53.356]  - use_args: TRUE
[17:43:53.356]  - Getting '...' globals ...
[17:43:53.356] resolve() on list ...
[17:43:53.356]  recursive: 0
[17:43:53.356]  length: 1
[17:43:53.357]  elements: ‘...’
[17:43:53.357]  length: 0 (resolved future 1)
[17:43:53.357] resolve() on list ... DONE
[17:43:53.357]    - '...' content: [n=1] ‘singular.ok’
[17:43:53.357] List of 1
[17:43:53.357]  $ ...:List of 1
[17:43:53.357]   ..$ singular.ok: logi FALSE
[17:43:53.357]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.357]  - attr(*, "where")=List of 1
[17:43:53.357]   ..$ ...:<environment: 0x55d6badd22e0> 
[17:43:53.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.357]  - attr(*, "resolved")= logi TRUE
[17:43:53.357]  - attr(*, "total_size")= num NA
[17:43:53.360]  - Getting '...' globals ... DONE
[17:43:53.360] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.360] List of 2
[17:43:53.360]  $ ...future.FUN:function (x, ...)  
[17:43:53.360]  $ ...          :List of 1
[17:43:53.360]   ..$ singular.ok: logi FALSE
[17:43:53.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.360]  - attr(*, "where")=List of 2
[17:43:53.360]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.360]   ..$ ...          :<environment: 0x55d6badd22e0> 
[17:43:53.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.360]  - attr(*, "resolved")= logi FALSE
[17:43:53.360]  - attr(*, "total_size")= num 5384
[17:43:53.363] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:53.363] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.364] Number of futures (= number of chunks): 2
[17:43:53.364] Launching 2 futures (chunks) ...
[17:43:53.364] Chunk #1 of 2 ...
[17:43:53.364]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.364] getGlobalsAndPackages() ...
[17:43:53.364] Searching for globals...
[17:43:53.364] 
[17:43:53.365] Searching for globals ... DONE
[17:43:53.365] - globals: [0] <none>
[17:43:53.365] getGlobalsAndPackages() ... DONE
[17:43:53.365]    + additional globals found: [n=0] 
[17:43:53.365]    + additional namespaces needed: [n=0] 
[17:43:53.365]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.365]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.365]  - seeds: <none>
[17:43:53.365]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.365] getGlobalsAndPackages() ...
[17:43:53.366] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.366] Resolving globals: FALSE
[17:43:53.366] Tweak future expression to call with '...' arguments ...
[17:43:53.366] {
[17:43:53.366]     do.call(function(...) {
[17:43:53.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.366]             on.exit(options(oopts), add = TRUE)
[17:43:53.366]         }
[17:43:53.366]         {
[17:43:53.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.366]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.366]             })
[17:43:53.366]         }
[17:43:53.366]     }, args = future.call.arguments)
[17:43:53.366] }
[17:43:53.366] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.366] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.367] 
[17:43:53.367] getGlobalsAndPackages() ... DONE
[17:43:53.367] run() for ‘Future’ ...
[17:43:53.367] - state: ‘created’
[17:43:53.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.371]   - Field: ‘label’
[17:43:53.371]   - Field: ‘local’
[17:43:53.371]   - Field: ‘owner’
[17:43:53.371]   - Field: ‘envir’
[17:43:53.372]   - Field: ‘workers’
[17:43:53.372]   - Field: ‘packages’
[17:43:53.372]   - Field: ‘gc’
[17:43:53.372]   - Field: ‘job’
[17:43:53.374]   - Field: ‘conditions’
[17:43:53.374]   - Field: ‘expr’
[17:43:53.374]   - Field: ‘uuid’
[17:43:53.374]   - Field: ‘seed’
[17:43:53.374]   - Field: ‘version’
[17:43:53.374]   - Field: ‘result’
[17:43:53.374]   - Field: ‘asynchronous’
[17:43:53.375]   - Field: ‘calls’
[17:43:53.375]   - Field: ‘globals’
[17:43:53.375]   - Field: ‘stdout’
[17:43:53.375]   - Field: ‘earlySignal’
[17:43:53.375]   - Field: ‘lazy’
[17:43:53.375]   - Field: ‘state’
[17:43:53.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.375] - Launch lazy future ...
[17:43:53.376] Packages needed by the future expression (n = 1): ‘stats’
[17:43:53.376] Packages needed by future strategies (n = 0): <none>
[17:43:53.376] {
[17:43:53.376]     {
[17:43:53.376]         {
[17:43:53.376]             ...future.startTime <- base::Sys.time()
[17:43:53.376]             {
[17:43:53.376]                 {
[17:43:53.376]                   {
[17:43:53.376]                     {
[17:43:53.376]                       {
[17:43:53.376]                         base::local({
[17:43:53.376]                           has_future <- base::requireNamespace("future", 
[17:43:53.376]                             quietly = TRUE)
[17:43:53.376]                           if (has_future) {
[17:43:53.376]                             ns <- base::getNamespace("future")
[17:43:53.376]                             version <- ns[[".package"]][["version"]]
[17:43:53.376]                             if (is.null(version)) 
[17:43:53.376]                               version <- utils::packageVersion("future")
[17:43:53.376]                           }
[17:43:53.376]                           else {
[17:43:53.376]                             version <- NULL
[17:43:53.376]                           }
[17:43:53.376]                           if (!has_future || version < "1.8.0") {
[17:43:53.376]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.376]                               "", base::R.version$version.string), 
[17:43:53.376]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:53.376]                                 base::R.version$platform, 8 * 
[17:43:53.376]                                   base::.Machine$sizeof.pointer), 
[17:43:53.376]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.376]                                 "release", "version")], collapse = " "), 
[17:43:53.376]                               hostname = base::Sys.info()[["nodename"]])
[17:43:53.376]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.376]                               info)
[17:43:53.376]                             info <- base::paste(info, collapse = "; ")
[17:43:53.376]                             if (!has_future) {
[17:43:53.376]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.376]                                 info)
[17:43:53.376]                             }
[17:43:53.376]                             else {
[17:43:53.376]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.376]                                 info, version)
[17:43:53.376]                             }
[17:43:53.376]                             base::stop(msg)
[17:43:53.376]                           }
[17:43:53.376]                         })
[17:43:53.376]                       }
[17:43:53.376]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.376]                       base::options(mc.cores = 1L)
[17:43:53.376]                     }
[17:43:53.376]                     base::local({
[17:43:53.376]                       for (pkg in "stats") {
[17:43:53.376]                         base::loadNamespace(pkg)
[17:43:53.376]                         base::library(pkg, character.only = TRUE)
[17:43:53.376]                       }
[17:43:53.376]                     })
[17:43:53.376]                   }
[17:43:53.376]                   ...future.strategy.old <- future::plan("list")
[17:43:53.376]                   options(future.plan = NULL)
[17:43:53.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.376]                 }
[17:43:53.376]                 ...future.workdir <- getwd()
[17:43:53.376]             }
[17:43:53.376]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.376]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.376]         }
[17:43:53.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.376]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.376]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.376]             base::names(...future.oldOptions))
[17:43:53.376]     }
[17:43:53.376]     if (FALSE) {
[17:43:53.376]     }
[17:43:53.376]     else {
[17:43:53.376]         if (TRUE) {
[17:43:53.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.376]                 open = "w")
[17:43:53.376]         }
[17:43:53.376]         else {
[17:43:53.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.376]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.376]         }
[17:43:53.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.376]             base::sink(type = "output", split = FALSE)
[17:43:53.376]             base::close(...future.stdout)
[17:43:53.376]         }, add = TRUE)
[17:43:53.376]     }
[17:43:53.376]     ...future.frame <- base::sys.nframe()
[17:43:53.376]     ...future.conditions <- base::list()
[17:43:53.376]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.376]     if (FALSE) {
[17:43:53.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.376]     }
[17:43:53.376]     ...future.result <- base::tryCatch({
[17:43:53.376]         base::withCallingHandlers({
[17:43:53.376]             ...future.value <- base::withVisible(base::local({
[17:43:53.376]                 withCallingHandlers({
[17:43:53.376]                   {
[17:43:53.376]                     do.call(function(...) {
[17:43:53.376]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.376]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.376]                         ...future.globals.maxSize)) {
[17:43:53.376]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.376]                         on.exit(options(oopts), add = TRUE)
[17:43:53.376]                       }
[17:43:53.376]                       {
[17:43:53.376]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.376]                           FUN = function(jj) {
[17:43:53.376]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.376]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.376]                           })
[17:43:53.376]                       }
[17:43:53.376]                     }, args = future.call.arguments)
[17:43:53.376]                   }
[17:43:53.376]                 }, immediateCondition = function(cond) {
[17:43:53.376]                   save_rds <- function (object, pathname, ...) 
[17:43:53.376]                   {
[17:43:53.376]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.376]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.376]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.376]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.376]                         fi_tmp[["mtime"]])
[17:43:53.376]                     }
[17:43:53.376]                     tryCatch({
[17:43:53.376]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.376]                     }, error = function(ex) {
[17:43:53.376]                       msg <- conditionMessage(ex)
[17:43:53.376]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.376]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.376]                         fi_tmp[["mtime"]], msg)
[17:43:53.376]                       ex$message <- msg
[17:43:53.376]                       stop(ex)
[17:43:53.376]                     })
[17:43:53.376]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.376]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.376]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.376]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.376]                       fi <- file.info(pathname)
[17:43:53.376]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.376]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.376]                         fi[["size"]], fi[["mtime"]])
[17:43:53.376]                       stop(msg)
[17:43:53.376]                     }
[17:43:53.376]                     invisible(pathname)
[17:43:53.376]                   }
[17:43:53.376]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.376]                     rootPath = tempdir()) 
[17:43:53.376]                   {
[17:43:53.376]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.376]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.376]                       tmpdir = path, fileext = ".rds")
[17:43:53.376]                     save_rds(obj, file)
[17:43:53.376]                   }
[17:43:53.376]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.376]                   {
[17:43:53.376]                     inherits <- base::inherits
[17:43:53.376]                     invokeRestart <- base::invokeRestart
[17:43:53.376]                     is.null <- base::is.null
[17:43:53.376]                     muffled <- FALSE
[17:43:53.376]                     if (inherits(cond, "message")) {
[17:43:53.376]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.376]                       if (muffled) 
[17:43:53.376]                         invokeRestart("muffleMessage")
[17:43:53.376]                     }
[17:43:53.376]                     else if (inherits(cond, "warning")) {
[17:43:53.376]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.376]                       if (muffled) 
[17:43:53.376]                         invokeRestart("muffleWarning")
[17:43:53.376]                     }
[17:43:53.376]                     else if (inherits(cond, "condition")) {
[17:43:53.376]                       if (!is.null(pattern)) {
[17:43:53.376]                         computeRestarts <- base::computeRestarts
[17:43:53.376]                         grepl <- base::grepl
[17:43:53.376]                         restarts <- computeRestarts(cond)
[17:43:53.376]                         for (restart in restarts) {
[17:43:53.376]                           name <- restart$name
[17:43:53.376]                           if (is.null(name)) 
[17:43:53.376]                             next
[17:43:53.376]                           if (!grepl(pattern, name)) 
[17:43:53.376]                             next
[17:43:53.376]                           invokeRestart(restart)
[17:43:53.376]                           muffled <- TRUE
[17:43:53.376]                           break
[17:43:53.376]                         }
[17:43:53.376]                       }
[17:43:53.376]                     }
[17:43:53.376]                     invisible(muffled)
[17:43:53.376]                   }
[17:43:53.376]                   muffleCondition(cond)
[17:43:53.376]                 })
[17:43:53.376]             }))
[17:43:53.376]             future::FutureResult(value = ...future.value$value, 
[17:43:53.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.376]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.376]                     ...future.globalenv.names))
[17:43:53.376]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.376]         }, condition = base::local({
[17:43:53.376]             c <- base::c
[17:43:53.376]             inherits <- base::inherits
[17:43:53.376]             invokeRestart <- base::invokeRestart
[17:43:53.376]             length <- base::length
[17:43:53.376]             list <- base::list
[17:43:53.376]             seq.int <- base::seq.int
[17:43:53.376]             signalCondition <- base::signalCondition
[17:43:53.376]             sys.calls <- base::sys.calls
[17:43:53.376]             `[[` <- base::`[[`
[17:43:53.376]             `+` <- base::`+`
[17:43:53.376]             `<<-` <- base::`<<-`
[17:43:53.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.376]                   3L)]
[17:43:53.376]             }
[17:43:53.376]             function(cond) {
[17:43:53.376]                 is_error <- inherits(cond, "error")
[17:43:53.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.376]                   NULL)
[17:43:53.376]                 if (is_error) {
[17:43:53.376]                   sessionInformation <- function() {
[17:43:53.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.376]                       search = base::search(), system = base::Sys.info())
[17:43:53.376]                   }
[17:43:53.376]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.376]                     cond$call), session = sessionInformation(), 
[17:43:53.376]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.376]                   signalCondition(cond)
[17:43:53.376]                 }
[17:43:53.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.376]                 "immediateCondition"))) {
[17:43:53.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.376]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.376]                   if (TRUE && !signal) {
[17:43:53.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.376]                     {
[17:43:53.376]                       inherits <- base::inherits
[17:43:53.376]                       invokeRestart <- base::invokeRestart
[17:43:53.376]                       is.null <- base::is.null
[17:43:53.376]                       muffled <- FALSE
[17:43:53.376]                       if (inherits(cond, "message")) {
[17:43:53.376]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.376]                         if (muffled) 
[17:43:53.376]                           invokeRestart("muffleMessage")
[17:43:53.376]                       }
[17:43:53.376]                       else if (inherits(cond, "warning")) {
[17:43:53.376]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.376]                         if (muffled) 
[17:43:53.376]                           invokeRestart("muffleWarning")
[17:43:53.376]                       }
[17:43:53.376]                       else if (inherits(cond, "condition")) {
[17:43:53.376]                         if (!is.null(pattern)) {
[17:43:53.376]                           computeRestarts <- base::computeRestarts
[17:43:53.376]                           grepl <- base::grepl
[17:43:53.376]                           restarts <- computeRestarts(cond)
[17:43:53.376]                           for (restart in restarts) {
[17:43:53.376]                             name <- restart$name
[17:43:53.376]                             if (is.null(name)) 
[17:43:53.376]                               next
[17:43:53.376]                             if (!grepl(pattern, name)) 
[17:43:53.376]                               next
[17:43:53.376]                             invokeRestart(restart)
[17:43:53.376]                             muffled <- TRUE
[17:43:53.376]                             break
[17:43:53.376]                           }
[17:43:53.376]                         }
[17:43:53.376]                       }
[17:43:53.376]                       invisible(muffled)
[17:43:53.376]                     }
[17:43:53.376]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.376]                   }
[17:43:53.376]                 }
[17:43:53.376]                 else {
[17:43:53.376]                   if (TRUE) {
[17:43:53.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.376]                     {
[17:43:53.376]                       inherits <- base::inherits
[17:43:53.376]                       invokeRestart <- base::invokeRestart
[17:43:53.376]                       is.null <- base::is.null
[17:43:53.376]                       muffled <- FALSE
[17:43:53.376]                       if (inherits(cond, "message")) {
[17:43:53.376]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.376]                         if (muffled) 
[17:43:53.376]                           invokeRestart("muffleMessage")
[17:43:53.376]                       }
[17:43:53.376]                       else if (inherits(cond, "warning")) {
[17:43:53.376]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.376]                         if (muffled) 
[17:43:53.376]                           invokeRestart("muffleWarning")
[17:43:53.376]                       }
[17:43:53.376]                       else if (inherits(cond, "condition")) {
[17:43:53.376]                         if (!is.null(pattern)) {
[17:43:53.376]                           computeRestarts <- base::computeRestarts
[17:43:53.376]                           grepl <- base::grepl
[17:43:53.376]                           restarts <- computeRestarts(cond)
[17:43:53.376]                           for (restart in restarts) {
[17:43:53.376]                             name <- restart$name
[17:43:53.376]                             if (is.null(name)) 
[17:43:53.376]                               next
[17:43:53.376]                             if (!grepl(pattern, name)) 
[17:43:53.376]                               next
[17:43:53.376]                             invokeRestart(restart)
[17:43:53.376]                             muffled <- TRUE
[17:43:53.376]                             break
[17:43:53.376]                           }
[17:43:53.376]                         }
[17:43:53.376]                       }
[17:43:53.376]                       invisible(muffled)
[17:43:53.376]                     }
[17:43:53.376]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.376]                   }
[17:43:53.376]                 }
[17:43:53.376]             }
[17:43:53.376]         }))
[17:43:53.376]     }, error = function(ex) {
[17:43:53.376]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.376]                 ...future.rng), started = ...future.startTime, 
[17:43:53.376]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.376]             version = "1.8"), class = "FutureResult")
[17:43:53.376]     }, finally = {
[17:43:53.376]         if (!identical(...future.workdir, getwd())) 
[17:43:53.376]             setwd(...future.workdir)
[17:43:53.376]         {
[17:43:53.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.376]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.376]             }
[17:43:53.376]             base::options(...future.oldOptions)
[17:43:53.376]             if (.Platform$OS.type == "windows") {
[17:43:53.376]                 old_names <- names(...future.oldEnvVars)
[17:43:53.376]                 envs <- base::Sys.getenv()
[17:43:53.376]                 names <- names(envs)
[17:43:53.376]                 common <- intersect(names, old_names)
[17:43:53.376]                 added <- setdiff(names, old_names)
[17:43:53.376]                 removed <- setdiff(old_names, names)
[17:43:53.376]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.376]                   envs[common]]
[17:43:53.376]                 NAMES <- toupper(changed)
[17:43:53.376]                 args <- list()
[17:43:53.376]                 for (kk in seq_along(NAMES)) {
[17:43:53.376]                   name <- changed[[kk]]
[17:43:53.376]                   NAME <- NAMES[[kk]]
[17:43:53.376]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.376]                     next
[17:43:53.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.376]                 }
[17:43:53.376]                 NAMES <- toupper(added)
[17:43:53.376]                 for (kk in seq_along(NAMES)) {
[17:43:53.376]                   name <- added[[kk]]
[17:43:53.376]                   NAME <- NAMES[[kk]]
[17:43:53.376]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.376]                     next
[17:43:53.376]                   args[[name]] <- ""
[17:43:53.376]                 }
[17:43:53.376]                 NAMES <- toupper(removed)
[17:43:53.376]                 for (kk in seq_along(NAMES)) {
[17:43:53.376]                   name <- removed[[kk]]
[17:43:53.376]                   NAME <- NAMES[[kk]]
[17:43:53.376]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.376]                     next
[17:43:53.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.376]                 }
[17:43:53.376]                 if (length(args) > 0) 
[17:43:53.376]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.376]             }
[17:43:53.376]             else {
[17:43:53.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.376]             }
[17:43:53.376]             {
[17:43:53.376]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.376]                   0L) {
[17:43:53.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.376]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.376]                   base::options(opts)
[17:43:53.376]                 }
[17:43:53.376]                 {
[17:43:53.376]                   {
[17:43:53.376]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.376]                     NULL
[17:43:53.376]                   }
[17:43:53.376]                   options(future.plan = NULL)
[17:43:53.376]                   if (is.na(NA_character_)) 
[17:43:53.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.376]                     .init = FALSE)
[17:43:53.376]                 }
[17:43:53.376]             }
[17:43:53.376]         }
[17:43:53.376]     })
[17:43:53.376]     if (TRUE) {
[17:43:53.376]         base::sink(type = "output", split = FALSE)
[17:43:53.376]         if (TRUE) {
[17:43:53.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.376]         }
[17:43:53.376]         else {
[17:43:53.376]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.376]         }
[17:43:53.376]         base::close(...future.stdout)
[17:43:53.376]         ...future.stdout <- NULL
[17:43:53.376]     }
[17:43:53.376]     ...future.result$conditions <- ...future.conditions
[17:43:53.376]     ...future.result$finished <- base::Sys.time()
[17:43:53.376]     ...future.result
[17:43:53.376] }
[17:43:53.379] assign_globals() ...
[17:43:53.379] List of 5
[17:43:53.379]  $ ...future.FUN            :function (x, ...)  
[17:43:53.379]  $ future.call.arguments    :List of 1
[17:43:53.379]   ..$ singular.ok: logi FALSE
[17:43:53.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.379]  $ ...future.elements_ii    :List of 1
[17:43:53.379]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.379]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.379]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.379]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.379]  $ ...future.seeds_ii       : NULL
[17:43:53.379]  $ ...future.globals.maxSize: NULL
[17:43:53.379]  - attr(*, "where")=List of 5
[17:43:53.379]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.379]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.379]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.379]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.379]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.379]  - attr(*, "resolved")= logi FALSE
[17:43:53.379]  - attr(*, "total_size")= num 5384
[17:43:53.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.379]  - attr(*, "already-done")= logi TRUE
[17:43:53.385] - reassign environment for ‘...future.FUN’
[17:43:53.385] - copied ‘...future.FUN’ to environment
[17:43:53.385] - copied ‘future.call.arguments’ to environment
[17:43:53.385] - copied ‘...future.elements_ii’ to environment
[17:43:53.386] - copied ‘...future.seeds_ii’ to environment
[17:43:53.386] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.386] assign_globals() ... done
[17:43:53.386] requestCore(): workers = 2
[17:43:53.388] MulticoreFuture started
[17:43:53.388] - Launch lazy future ... done
[17:43:53.389] run() for ‘MulticoreFuture’ ... done
[17:43:53.389] Created future:
[17:43:53.389] plan(): Setting new future strategy stack:
[17:43:53.390] List of future strategies:
[17:43:53.390] 1. sequential:
[17:43:53.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.390]    - tweaked: FALSE
[17:43:53.390]    - call: NULL
[17:43:53.391] plan(): nbrOfWorkers() = 1
[17:43:53.395] plan(): Setting new future strategy stack:
[17:43:53.395] List of future strategies:
[17:43:53.395] 1. multicore:
[17:43:53.395]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.395]    - tweaked: FALSE
[17:43:53.395]    - call: plan(strategy)
[17:43:53.400] plan(): nbrOfWorkers() = 2
[17:43:53.389] MulticoreFuture:
[17:43:53.389] Label: ‘future_by-1’
[17:43:53.389] Expression:
[17:43:53.389] {
[17:43:53.389]     do.call(function(...) {
[17:43:53.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.389]             on.exit(options(oopts), add = TRUE)
[17:43:53.389]         }
[17:43:53.389]         {
[17:43:53.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.389]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.389]             })
[17:43:53.389]         }
[17:43:53.389]     }, args = future.call.arguments)
[17:43:53.389] }
[17:43:53.389] Lazy evaluation: FALSE
[17:43:53.389] Asynchronous evaluation: TRUE
[17:43:53.389] Local evaluation: TRUE
[17:43:53.389] Environment: R_GlobalEnv
[17:43:53.389] Capture standard output: TRUE
[17:43:53.389] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.389] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.389] Packages: 1 packages (‘stats’)
[17:43:53.389] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.389] Resolved: TRUE
[17:43:53.389] Value: <not collected>
[17:43:53.389] Conditions captured: <none>
[17:43:53.389] Early signaling: FALSE
[17:43:53.389] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.389] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.402] Chunk #1 of 2 ... DONE
[17:43:53.402] Chunk #2 of 2 ...
[17:43:53.402]  - Finding globals in 'X' for chunk #2 ...
[17:43:53.402] getGlobalsAndPackages() ...
[17:43:53.402] Searching for globals...
[17:43:53.403] 
[17:43:53.403] Searching for globals ... DONE
[17:43:53.403] - globals: [0] <none>
[17:43:53.404] getGlobalsAndPackages() ... DONE
[17:43:53.404]    + additional globals found: [n=0] 
[17:43:53.404]    + additional namespaces needed: [n=0] 
[17:43:53.404]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:53.404]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.404]  - seeds: <none>
[17:43:53.404]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.404] getGlobalsAndPackages() ...
[17:43:53.405] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.405] Resolving globals: FALSE
[17:43:53.405] Tweak future expression to call with '...' arguments ...
[17:43:53.405] {
[17:43:53.405]     do.call(function(...) {
[17:43:53.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.405]             on.exit(options(oopts), add = TRUE)
[17:43:53.405]         }
[17:43:53.405]         {
[17:43:53.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.405]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.405]             })
[17:43:53.405]         }
[17:43:53.405]     }, args = future.call.arguments)
[17:43:53.405] }
[17:43:53.405] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.406] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.406] 
[17:43:53.406] getGlobalsAndPackages() ... DONE
[17:43:53.407] run() for ‘Future’ ...
[17:43:53.407] - state: ‘created’
[17:43:53.407] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.412] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.412]   - Field: ‘label’
[17:43:53.412]   - Field: ‘local’
[17:43:53.412]   - Field: ‘owner’
[17:43:53.412]   - Field: ‘envir’
[17:43:53.413]   - Field: ‘workers’
[17:43:53.413]   - Field: ‘packages’
[17:43:53.413]   - Field: ‘gc’
[17:43:53.413]   - Field: ‘job’
[17:43:53.413]   - Field: ‘conditions’
[17:43:53.413]   - Field: ‘expr’
[17:43:53.416]   - Field: ‘uuid’
[17:43:53.417]   - Field: ‘seed’
[17:43:53.417]   - Field: ‘version’
[17:43:53.418]   - Field: ‘result’
[17:43:53.418]   - Field: ‘asynchronous’
[17:43:53.418]   - Field: ‘calls’
[17:43:53.418]   - Field: ‘globals’
[17:43:53.419]   - Field: ‘stdout’
[17:43:53.419]   - Field: ‘earlySignal’
[17:43:53.419]   - Field: ‘lazy’
[17:43:53.420]   - Field: ‘state’
[17:43:53.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.420] - Launch lazy future ...
[17:43:53.421] Packages needed by the future expression (n = 1): ‘stats’
[17:43:53.421] Packages needed by future strategies (n = 0): <none>
[17:43:53.422] {
[17:43:53.422]     {
[17:43:53.422]         {
[17:43:53.422]             ...future.startTime <- base::Sys.time()
[17:43:53.422]             {
[17:43:53.422]                 {
[17:43:53.422]                   {
[17:43:53.422]                     {
[17:43:53.422]                       {
[17:43:53.422]                         base::local({
[17:43:53.422]                           has_future <- base::requireNamespace("future", 
[17:43:53.422]                             quietly = TRUE)
[17:43:53.422]                           if (has_future) {
[17:43:53.422]                             ns <- base::getNamespace("future")
[17:43:53.422]                             version <- ns[[".package"]][["version"]]
[17:43:53.422]                             if (is.null(version)) 
[17:43:53.422]                               version <- utils::packageVersion("future")
[17:43:53.422]                           }
[17:43:53.422]                           else {
[17:43:53.422]                             version <- NULL
[17:43:53.422]                           }
[17:43:53.422]                           if (!has_future || version < "1.8.0") {
[17:43:53.422]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.422]                               "", base::R.version$version.string), 
[17:43:53.422]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:53.422]                                 base::R.version$platform, 8 * 
[17:43:53.422]                                   base::.Machine$sizeof.pointer), 
[17:43:53.422]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.422]                                 "release", "version")], collapse = " "), 
[17:43:53.422]                               hostname = base::Sys.info()[["nodename"]])
[17:43:53.422]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.422]                               info)
[17:43:53.422]                             info <- base::paste(info, collapse = "; ")
[17:43:53.422]                             if (!has_future) {
[17:43:53.422]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.422]                                 info)
[17:43:53.422]                             }
[17:43:53.422]                             else {
[17:43:53.422]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.422]                                 info, version)
[17:43:53.422]                             }
[17:43:53.422]                             base::stop(msg)
[17:43:53.422]                           }
[17:43:53.422]                         })
[17:43:53.422]                       }
[17:43:53.422]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.422]                       base::options(mc.cores = 1L)
[17:43:53.422]                     }
[17:43:53.422]                     base::local({
[17:43:53.422]                       for (pkg in "stats") {
[17:43:53.422]                         base::loadNamespace(pkg)
[17:43:53.422]                         base::library(pkg, character.only = TRUE)
[17:43:53.422]                       }
[17:43:53.422]                     })
[17:43:53.422]                   }
[17:43:53.422]                   ...future.strategy.old <- future::plan("list")
[17:43:53.422]                   options(future.plan = NULL)
[17:43:53.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.422]                 }
[17:43:53.422]                 ...future.workdir <- getwd()
[17:43:53.422]             }
[17:43:53.422]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.422]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.422]         }
[17:43:53.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.422]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.422]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.422]             base::names(...future.oldOptions))
[17:43:53.422]     }
[17:43:53.422]     if (FALSE) {
[17:43:53.422]     }
[17:43:53.422]     else {
[17:43:53.422]         if (TRUE) {
[17:43:53.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.422]                 open = "w")
[17:43:53.422]         }
[17:43:53.422]         else {
[17:43:53.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.422]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.422]         }
[17:43:53.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.422]             base::sink(type = "output", split = FALSE)
[17:43:53.422]             base::close(...future.stdout)
[17:43:53.422]         }, add = TRUE)
[17:43:53.422]     }
[17:43:53.422]     ...future.frame <- base::sys.nframe()
[17:43:53.422]     ...future.conditions <- base::list()
[17:43:53.422]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.422]     if (FALSE) {
[17:43:53.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.422]     }
[17:43:53.422]     ...future.result <- base::tryCatch({
[17:43:53.422]         base::withCallingHandlers({
[17:43:53.422]             ...future.value <- base::withVisible(base::local({
[17:43:53.422]                 withCallingHandlers({
[17:43:53.422]                   {
[17:43:53.422]                     do.call(function(...) {
[17:43:53.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.422]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.422]                         ...future.globals.maxSize)) {
[17:43:53.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.422]                         on.exit(options(oopts), add = TRUE)
[17:43:53.422]                       }
[17:43:53.422]                       {
[17:43:53.422]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.422]                           FUN = function(jj) {
[17:43:53.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.422]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.422]                           })
[17:43:53.422]                       }
[17:43:53.422]                     }, args = future.call.arguments)
[17:43:53.422]                   }
[17:43:53.422]                 }, immediateCondition = function(cond) {
[17:43:53.422]                   save_rds <- function (object, pathname, ...) 
[17:43:53.422]                   {
[17:43:53.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.422]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.422]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.422]                         fi_tmp[["mtime"]])
[17:43:53.422]                     }
[17:43:53.422]                     tryCatch({
[17:43:53.422]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.422]                     }, error = function(ex) {
[17:43:53.422]                       msg <- conditionMessage(ex)
[17:43:53.422]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.422]                         fi_tmp[["mtime"]], msg)
[17:43:53.422]                       ex$message <- msg
[17:43:53.422]                       stop(ex)
[17:43:53.422]                     })
[17:43:53.422]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.422]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.422]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.422]                       fi <- file.info(pathname)
[17:43:53.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.422]                         fi[["size"]], fi[["mtime"]])
[17:43:53.422]                       stop(msg)
[17:43:53.422]                     }
[17:43:53.422]                     invisible(pathname)
[17:43:53.422]                   }
[17:43:53.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.422]                     rootPath = tempdir()) 
[17:43:53.422]                   {
[17:43:53.422]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.422]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.422]                       tmpdir = path, fileext = ".rds")
[17:43:53.422]                     save_rds(obj, file)
[17:43:53.422]                   }
[17:43:53.422]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.422]                   {
[17:43:53.422]                     inherits <- base::inherits
[17:43:53.422]                     invokeRestart <- base::invokeRestart
[17:43:53.422]                     is.null <- base::is.null
[17:43:53.422]                     muffled <- FALSE
[17:43:53.422]                     if (inherits(cond, "message")) {
[17:43:53.422]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.422]                       if (muffled) 
[17:43:53.422]                         invokeRestart("muffleMessage")
[17:43:53.422]                     }
[17:43:53.422]                     else if (inherits(cond, "warning")) {
[17:43:53.422]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.422]                       if (muffled) 
[17:43:53.422]                         invokeRestart("muffleWarning")
[17:43:53.422]                     }
[17:43:53.422]                     else if (inherits(cond, "condition")) {
[17:43:53.422]                       if (!is.null(pattern)) {
[17:43:53.422]                         computeRestarts <- base::computeRestarts
[17:43:53.422]                         grepl <- base::grepl
[17:43:53.422]                         restarts <- computeRestarts(cond)
[17:43:53.422]                         for (restart in restarts) {
[17:43:53.422]                           name <- restart$name
[17:43:53.422]                           if (is.null(name)) 
[17:43:53.422]                             next
[17:43:53.422]                           if (!grepl(pattern, name)) 
[17:43:53.422]                             next
[17:43:53.422]                           invokeRestart(restart)
[17:43:53.422]                           muffled <- TRUE
[17:43:53.422]                           break
[17:43:53.422]                         }
[17:43:53.422]                       }
[17:43:53.422]                     }
[17:43:53.422]                     invisible(muffled)
[17:43:53.422]                   }
[17:43:53.422]                   muffleCondition(cond)
[17:43:53.422]                 })
[17:43:53.422]             }))
[17:43:53.422]             future::FutureResult(value = ...future.value$value, 
[17:43:53.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.422]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.422]                     ...future.globalenv.names))
[17:43:53.422]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.422]         }, condition = base::local({
[17:43:53.422]             c <- base::c
[17:43:53.422]             inherits <- base::inherits
[17:43:53.422]             invokeRestart <- base::invokeRestart
[17:43:53.422]             length <- base::length
[17:43:53.422]             list <- base::list
[17:43:53.422]             seq.int <- base::seq.int
[17:43:53.422]             signalCondition <- base::signalCondition
[17:43:53.422]             sys.calls <- base::sys.calls
[17:43:53.422]             `[[` <- base::`[[`
[17:43:53.422]             `+` <- base::`+`
[17:43:53.422]             `<<-` <- base::`<<-`
[17:43:53.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.422]                   3L)]
[17:43:53.422]             }
[17:43:53.422]             function(cond) {
[17:43:53.422]                 is_error <- inherits(cond, "error")
[17:43:53.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.422]                   NULL)
[17:43:53.422]                 if (is_error) {
[17:43:53.422]                   sessionInformation <- function() {
[17:43:53.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.422]                       search = base::search(), system = base::Sys.info())
[17:43:53.422]                   }
[17:43:53.422]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.422]                     cond$call), session = sessionInformation(), 
[17:43:53.422]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.422]                   signalCondition(cond)
[17:43:53.422]                 }
[17:43:53.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.422]                 "immediateCondition"))) {
[17:43:53.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.422]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.422]                   if (TRUE && !signal) {
[17:43:53.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.422]                     {
[17:43:53.422]                       inherits <- base::inherits
[17:43:53.422]                       invokeRestart <- base::invokeRestart
[17:43:53.422]                       is.null <- base::is.null
[17:43:53.422]                       muffled <- FALSE
[17:43:53.422]                       if (inherits(cond, "message")) {
[17:43:53.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.422]                         if (muffled) 
[17:43:53.422]                           invokeRestart("muffleMessage")
[17:43:53.422]                       }
[17:43:53.422]                       else if (inherits(cond, "warning")) {
[17:43:53.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.422]                         if (muffled) 
[17:43:53.422]                           invokeRestart("muffleWarning")
[17:43:53.422]                       }
[17:43:53.422]                       else if (inherits(cond, "condition")) {
[17:43:53.422]                         if (!is.null(pattern)) {
[17:43:53.422]                           computeRestarts <- base::computeRestarts
[17:43:53.422]                           grepl <- base::grepl
[17:43:53.422]                           restarts <- computeRestarts(cond)
[17:43:53.422]                           for (restart in restarts) {
[17:43:53.422]                             name <- restart$name
[17:43:53.422]                             if (is.null(name)) 
[17:43:53.422]                               next
[17:43:53.422]                             if (!grepl(pattern, name)) 
[17:43:53.422]                               next
[17:43:53.422]                             invokeRestart(restart)
[17:43:53.422]                             muffled <- TRUE
[17:43:53.422]                             break
[17:43:53.422]                           }
[17:43:53.422]                         }
[17:43:53.422]                       }
[17:43:53.422]                       invisible(muffled)
[17:43:53.422]                     }
[17:43:53.422]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.422]                   }
[17:43:53.422]                 }
[17:43:53.422]                 else {
[17:43:53.422]                   if (TRUE) {
[17:43:53.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.422]                     {
[17:43:53.422]                       inherits <- base::inherits
[17:43:53.422]                       invokeRestart <- base::invokeRestart
[17:43:53.422]                       is.null <- base::is.null
[17:43:53.422]                       muffled <- FALSE
[17:43:53.422]                       if (inherits(cond, "message")) {
[17:43:53.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.422]                         if (muffled) 
[17:43:53.422]                           invokeRestart("muffleMessage")
[17:43:53.422]                       }
[17:43:53.422]                       else if (inherits(cond, "warning")) {
[17:43:53.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.422]                         if (muffled) 
[17:43:53.422]                           invokeRestart("muffleWarning")
[17:43:53.422]                       }
[17:43:53.422]                       else if (inherits(cond, "condition")) {
[17:43:53.422]                         if (!is.null(pattern)) {
[17:43:53.422]                           computeRestarts <- base::computeRestarts
[17:43:53.422]                           grepl <- base::grepl
[17:43:53.422]                           restarts <- computeRestarts(cond)
[17:43:53.422]                           for (restart in restarts) {
[17:43:53.422]                             name <- restart$name
[17:43:53.422]                             if (is.null(name)) 
[17:43:53.422]                               next
[17:43:53.422]                             if (!grepl(pattern, name)) 
[17:43:53.422]                               next
[17:43:53.422]                             invokeRestart(restart)
[17:43:53.422]                             muffled <- TRUE
[17:43:53.422]                             break
[17:43:53.422]                           }
[17:43:53.422]                         }
[17:43:53.422]                       }
[17:43:53.422]                       invisible(muffled)
[17:43:53.422]                     }
[17:43:53.422]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.422]                   }
[17:43:53.422]                 }
[17:43:53.422]             }
[17:43:53.422]         }))
[17:43:53.422]     }, error = function(ex) {
[17:43:53.422]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.422]                 ...future.rng), started = ...future.startTime, 
[17:43:53.422]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.422]             version = "1.8"), class = "FutureResult")
[17:43:53.422]     }, finally = {
[17:43:53.422]         if (!identical(...future.workdir, getwd())) 
[17:43:53.422]             setwd(...future.workdir)
[17:43:53.422]         {
[17:43:53.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.422]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.422]             }
[17:43:53.422]             base::options(...future.oldOptions)
[17:43:53.422]             if (.Platform$OS.type == "windows") {
[17:43:53.422]                 old_names <- names(...future.oldEnvVars)
[17:43:53.422]                 envs <- base::Sys.getenv()
[17:43:53.422]                 names <- names(envs)
[17:43:53.422]                 common <- intersect(names, old_names)
[17:43:53.422]                 added <- setdiff(names, old_names)
[17:43:53.422]                 removed <- setdiff(old_names, names)
[17:43:53.422]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.422]                   envs[common]]
[17:43:53.422]                 NAMES <- toupper(changed)
[17:43:53.422]                 args <- list()
[17:43:53.422]                 for (kk in seq_along(NAMES)) {
[17:43:53.422]                   name <- changed[[kk]]
[17:43:53.422]                   NAME <- NAMES[[kk]]
[17:43:53.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.422]                     next
[17:43:53.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.422]                 }
[17:43:53.422]                 NAMES <- toupper(added)
[17:43:53.422]                 for (kk in seq_along(NAMES)) {
[17:43:53.422]                   name <- added[[kk]]
[17:43:53.422]                   NAME <- NAMES[[kk]]
[17:43:53.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.422]                     next
[17:43:53.422]                   args[[name]] <- ""
[17:43:53.422]                 }
[17:43:53.422]                 NAMES <- toupper(removed)
[17:43:53.422]                 for (kk in seq_along(NAMES)) {
[17:43:53.422]                   name <- removed[[kk]]
[17:43:53.422]                   NAME <- NAMES[[kk]]
[17:43:53.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.422]                     next
[17:43:53.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.422]                 }
[17:43:53.422]                 if (length(args) > 0) 
[17:43:53.422]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.422]             }
[17:43:53.422]             else {
[17:43:53.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.422]             }
[17:43:53.422]             {
[17:43:53.422]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.422]                   0L) {
[17:43:53.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.422]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.422]                   base::options(opts)
[17:43:53.422]                 }
[17:43:53.422]                 {
[17:43:53.422]                   {
[17:43:53.422]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.422]                     NULL
[17:43:53.422]                   }
[17:43:53.422]                   options(future.plan = NULL)
[17:43:53.422]                   if (is.na(NA_character_)) 
[17:43:53.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.422]                     .init = FALSE)
[17:43:53.422]                 }
[17:43:53.422]             }
[17:43:53.422]         }
[17:43:53.422]     })
[17:43:53.422]     if (TRUE) {
[17:43:53.422]         base::sink(type = "output", split = FALSE)
[17:43:53.422]         if (TRUE) {
[17:43:53.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.422]         }
[17:43:53.422]         else {
[17:43:53.422]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.422]         }
[17:43:53.422]         base::close(...future.stdout)
[17:43:53.422]         ...future.stdout <- NULL
[17:43:53.422]     }
[17:43:53.422]     ...future.result$conditions <- ...future.conditions
[17:43:53.422]     ...future.result$finished <- base::Sys.time()
[17:43:53.422]     ...future.result
[17:43:53.422] }
[17:43:53.425] assign_globals() ...
[17:43:53.425] List of 5
[17:43:53.425]  $ ...future.FUN            :function (x, ...)  
[17:43:53.425]  $ future.call.arguments    :List of 1
[17:43:53.425]   ..$ singular.ok: logi FALSE
[17:43:53.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.425]  $ ...future.elements_ii    :List of 2
[17:43:53.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.425]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:53.425]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.425]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.425]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.425]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:53.425]  $ ...future.seeds_ii       : NULL
[17:43:53.425]  $ ...future.globals.maxSize: NULL
[17:43:53.425]  - attr(*, "where")=List of 5
[17:43:53.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.425]  - attr(*, "resolved")= logi FALSE
[17:43:53.425]  - attr(*, "total_size")= num 5384
[17:43:53.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.425]  - attr(*, "already-done")= logi TRUE
[17:43:53.436] - reassign environment for ‘...future.FUN’
[17:43:53.436] - copied ‘...future.FUN’ to environment
[17:43:53.436] - copied ‘future.call.arguments’ to environment
[17:43:53.436] - copied ‘...future.elements_ii’ to environment
[17:43:53.437] - copied ‘...future.seeds_ii’ to environment
[17:43:53.437] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.437] assign_globals() ... done
[17:43:53.437] requestCore(): workers = 2
[17:43:53.439] MulticoreFuture started
[17:43:53.439] - Launch lazy future ... done
[17:43:53.440] run() for ‘MulticoreFuture’ ... done
[17:43:53.440] Created future:
[17:43:53.441] plan(): Setting new future strategy stack:
[17:43:53.441] List of future strategies:
[17:43:53.441] 1. sequential:
[17:43:53.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.441]    - tweaked: FALSE
[17:43:53.441]    - call: NULL
[17:43:53.442] plan(): nbrOfWorkers() = 1
[17:43:53.447] plan(): Setting new future strategy stack:
[17:43:53.447] List of future strategies:
[17:43:53.447] 1. multicore:
[17:43:53.447]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.447]    - tweaked: FALSE
[17:43:53.447]    - call: plan(strategy)
[17:43:53.452] plan(): nbrOfWorkers() = 2
[17:43:53.440] MulticoreFuture:
[17:43:53.440] Label: ‘future_by-2’
[17:43:53.440] Expression:
[17:43:53.440] {
[17:43:53.440]     do.call(function(...) {
[17:43:53.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.440]             on.exit(options(oopts), add = TRUE)
[17:43:53.440]         }
[17:43:53.440]         {
[17:43:53.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.440]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.440]             })
[17:43:53.440]         }
[17:43:53.440]     }, args = future.call.arguments)
[17:43:53.440] }
[17:43:53.440] Lazy evaluation: FALSE
[17:43:53.440] Asynchronous evaluation: TRUE
[17:43:53.440] Local evaluation: TRUE
[17:43:53.440] Environment: R_GlobalEnv
[17:43:53.440] Capture standard output: TRUE
[17:43:53.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.440] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.440] Packages: 1 packages (‘stats’)
[17:43:53.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.440] Resolved: FALSE
[17:43:53.440] Value: <not collected>
[17:43:53.440] Conditions captured: <none>
[17:43:53.440] Early signaling: FALSE
[17:43:53.440] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.453] Chunk #2 of 2 ... DONE
[17:43:53.453] Launching 2 futures (chunks) ... DONE
[17:43:53.453] Resolving 2 futures (chunks) ...
[17:43:53.453] resolve() on list ...
[17:43:53.454]  recursive: 0
[17:43:53.454]  length: 2
[17:43:53.454] 
[17:43:53.454] Future #1
[17:43:53.454] result() for MulticoreFuture ...
[17:43:53.456] result() for MulticoreFuture ...
[17:43:53.456] result() for MulticoreFuture ... done
[17:43:53.456] result() for MulticoreFuture ... done
[17:43:53.456] result() for MulticoreFuture ...
[17:43:53.456] result() for MulticoreFuture ... done
[17:43:53.457] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:53.457] - nx: 2
[17:43:53.457] - relay: TRUE
[17:43:53.457] - stdout: TRUE
[17:43:53.457] - signal: TRUE
[17:43:53.457] - resignal: FALSE
[17:43:53.457] - force: TRUE
[17:43:53.457] - relayed: [n=2] FALSE, FALSE
[17:43:53.457] - queued futures: [n=2] FALSE, FALSE
[17:43:53.458]  - until=1
[17:43:53.458]  - relaying element #1
[17:43:53.458] result() for MulticoreFuture ...
[17:43:53.458] result() for MulticoreFuture ... done
[17:43:53.458] result() for MulticoreFuture ...
[17:43:53.458] result() for MulticoreFuture ... done
[17:43:53.458] result() for MulticoreFuture ...
[17:43:53.459] result() for MulticoreFuture ... done
[17:43:53.459] result() for MulticoreFuture ...
[17:43:53.459] result() for MulticoreFuture ... done
[17:43:53.459] - relayed: [n=2] TRUE, FALSE
[17:43:53.459] - queued futures: [n=2] TRUE, FALSE
[17:43:53.459] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:53.460]  length: 1 (resolved future 1)
[17:43:53.460] Future #2
[17:43:53.460] result() for MulticoreFuture ...
[17:43:53.466] result() for MulticoreFuture ...
[17:43:53.466] result() for MulticoreFuture ... done
[17:43:53.466] result() for MulticoreFuture ... done
[17:43:53.467] result() for MulticoreFuture ...
[17:43:53.467] result() for MulticoreFuture ... done
[17:43:53.467] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:53.467] - nx: 2
[17:43:53.467] - relay: TRUE
[17:43:53.468] - stdout: TRUE
[17:43:53.468] - signal: TRUE
[17:43:53.468] - resignal: FALSE
[17:43:53.468] - force: TRUE
[17:43:53.468] - relayed: [n=2] TRUE, FALSE
[17:43:53.468] - queued futures: [n=2] TRUE, FALSE
[17:43:53.469]  - until=2
[17:43:53.469]  - relaying element #2
[17:43:53.469] result() for MulticoreFuture ...
[17:43:53.469] result() for MulticoreFuture ... done
[17:43:53.469] result() for MulticoreFuture ...
[17:43:53.469] result() for MulticoreFuture ... done
[17:43:53.470] result() for MulticoreFuture ...
[17:43:53.470] result() for MulticoreFuture ... done
[17:43:53.470] result() for MulticoreFuture ...
[17:43:53.470] result() for MulticoreFuture ... done
[17:43:53.470] - relayed: [n=2] TRUE, TRUE
[17:43:53.470] - queued futures: [n=2] TRUE, TRUE
[17:43:53.470] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:53.470]  length: 0 (resolved future 2)
[17:43:53.471] Relaying remaining futures
[17:43:53.471] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.471] - nx: 2
[17:43:53.471] - relay: TRUE
[17:43:53.471] - stdout: TRUE
[17:43:53.471] - signal: TRUE
[17:43:53.471] - resignal: FALSE
[17:43:53.471] - force: TRUE
[17:43:53.472] - relayed: [n=2] TRUE, TRUE
[17:43:53.472] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:53.472] - relayed: [n=2] TRUE, TRUE
[17:43:53.472] - queued futures: [n=2] TRUE, TRUE
[17:43:53.472] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.472] resolve() on list ... DONE
[17:43:53.472] result() for MulticoreFuture ...
[17:43:53.472] result() for MulticoreFuture ... done
[17:43:53.473] result() for MulticoreFuture ...
[17:43:53.473] result() for MulticoreFuture ... done
[17:43:53.473] result() for MulticoreFuture ...
[17:43:53.473] result() for MulticoreFuture ... done
[17:43:53.473] result() for MulticoreFuture ...
[17:43:53.473] result() for MulticoreFuture ... done
[17:43:53.473]  - Number of value chunks collected: 2
[17:43:53.473] Resolving 2 futures (chunks) ... DONE
[17:43:53.473] Reducing values from 2 chunks ...
[17:43:53.474]  - Number of values collected after concatenation: 3
[17:43:53.474]  - Number of values expected: 3
[17:43:53.474] Reducing values from 2 chunks ... DONE
[17:43:53.474] future_lapply() ... DONE
[17:43:53.474] future_by_internal() ... DONE
[17:43:53.479] future_by_internal() ...
[17:43:53.479] future_lapply() ...
[17:43:53.484] Number of chunks: 2
[17:43:53.484] getGlobalsAndPackagesXApply() ...
[17:43:53.484]  - future.globals: TRUE
[17:43:53.484] getGlobalsAndPackages() ...
[17:43:53.484] Searching for globals...
[17:43:53.486] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:53.487] Searching for globals ... DONE
[17:43:53.487] Resolving globals: FALSE
[17:43:53.492] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:43:53.492] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:43:53.492] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:53.493] - packages: [1] ‘stats’
[17:43:53.493] getGlobalsAndPackages() ... DONE
[17:43:53.493]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:53.493]  - needed namespaces: [n=1] ‘stats’
[17:43:53.493] Finding globals ... DONE
[17:43:53.493]  - use_args: TRUE
[17:43:53.493]  - Getting '...' globals ...
[17:43:53.494] resolve() on list ...
[17:43:53.494]  recursive: 0
[17:43:53.494]  length: 1
[17:43:53.494]  elements: ‘...’
[17:43:53.494]  length: 0 (resolved future 1)
[17:43:53.494] resolve() on list ... DONE
[17:43:53.494]    - '...' content: [n=0] 
[17:43:53.494] List of 1
[17:43:53.494]  $ ...: list()
[17:43:53.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.494]  - attr(*, "where")=List of 1
[17:43:53.494]   ..$ ...:<environment: 0x55d6bab49110> 
[17:43:53.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.494]  - attr(*, "resolved")= logi TRUE
[17:43:53.494]  - attr(*, "total_size")= num NA
[17:43:53.497]  - Getting '...' globals ... DONE
[17:43:53.498] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:43:53.498] List of 4
[17:43:53.498]  $ ...future.FUN:function (x)  
[17:43:53.498]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:53.498]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.498]  $ ...          : list()
[17:43:53.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.498]  - attr(*, "where")=List of 4
[17:43:53.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.498]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:43:53.498]   ..$ wool         :<environment: R_EmptyEnv> 
[17:43:53.498]   ..$ ...          :<environment: 0x55d6bab49110> 
[17:43:53.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.498]  - attr(*, "resolved")= logi FALSE
[17:43:53.498]  - attr(*, "total_size")= num 2320
[17:43:53.502] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:53.502] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.502] Number of futures (= number of chunks): 2
[17:43:53.502] Launching 2 futures (chunks) ...
[17:43:53.502] Chunk #1 of 2 ...
[17:43:53.502]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.502] getGlobalsAndPackages() ...
[17:43:53.502] Searching for globals...
[17:43:53.503] 
[17:43:53.503] Searching for globals ... DONE
[17:43:53.503] - globals: [0] <none>
[17:43:53.503] getGlobalsAndPackages() ... DONE
[17:43:53.503]    + additional globals found: [n=0] 
[17:43:53.503]    + additional namespaces needed: [n=0] 
[17:43:53.503]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.503]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.504]  - seeds: <none>
[17:43:53.504]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.504] getGlobalsAndPackages() ...
[17:43:53.504] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.504] Resolving globals: FALSE
[17:43:53.504] Tweak future expression to call with '...' arguments ...
[17:43:53.504] {
[17:43:53.504]     do.call(function(...) {
[17:43:53.504]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.504]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.504]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.504]             on.exit(options(oopts), add = TRUE)
[17:43:53.504]         }
[17:43:53.504]         {
[17:43:53.504]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.504]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.504]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.504]             })
[17:43:53.504]         }
[17:43:53.504]     }, args = future.call.arguments)
[17:43:53.504] }
[17:43:53.504] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.505] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.505] 
[17:43:53.505] getGlobalsAndPackages() ... DONE
[17:43:53.505] run() for ‘Future’ ...
[17:43:53.505] - state: ‘created’
[17:43:53.506] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.509] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.509]   - Field: ‘label’
[17:43:53.509]   - Field: ‘local’
[17:43:53.510]   - Field: ‘owner’
[17:43:53.510]   - Field: ‘envir’
[17:43:53.510]   - Field: ‘workers’
[17:43:53.510]   - Field: ‘packages’
[17:43:53.510]   - Field: ‘gc’
[17:43:53.510]   - Field: ‘job’
[17:43:53.510]   - Field: ‘conditions’
[17:43:53.510]   - Field: ‘expr’
[17:43:53.510]   - Field: ‘uuid’
[17:43:53.510]   - Field: ‘seed’
[17:43:53.510]   - Field: ‘version’
[17:43:53.511]   - Field: ‘result’
[17:43:53.511]   - Field: ‘asynchronous’
[17:43:53.511]   - Field: ‘calls’
[17:43:53.511]   - Field: ‘globals’
[17:43:53.511]   - Field: ‘stdout’
[17:43:53.511]   - Field: ‘earlySignal’
[17:43:53.511]   - Field: ‘lazy’
[17:43:53.511]   - Field: ‘state’
[17:43:53.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.511] - Launch lazy future ...
[17:43:53.512] Packages needed by the future expression (n = 1): ‘stats’
[17:43:53.512] Packages needed by future strategies (n = 0): <none>
[17:43:53.512] {
[17:43:53.512]     {
[17:43:53.512]         {
[17:43:53.512]             ...future.startTime <- base::Sys.time()
[17:43:53.512]             {
[17:43:53.512]                 {
[17:43:53.512]                   {
[17:43:53.512]                     {
[17:43:53.512]                       {
[17:43:53.512]                         base::local({
[17:43:53.512]                           has_future <- base::requireNamespace("future", 
[17:43:53.512]                             quietly = TRUE)
[17:43:53.512]                           if (has_future) {
[17:43:53.512]                             ns <- base::getNamespace("future")
[17:43:53.512]                             version <- ns[[".package"]][["version"]]
[17:43:53.512]                             if (is.null(version)) 
[17:43:53.512]                               version <- utils::packageVersion("future")
[17:43:53.512]                           }
[17:43:53.512]                           else {
[17:43:53.512]                             version <- NULL
[17:43:53.512]                           }
[17:43:53.512]                           if (!has_future || version < "1.8.0") {
[17:43:53.512]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.512]                               "", base::R.version$version.string), 
[17:43:53.512]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:53.512]                                 base::R.version$platform, 8 * 
[17:43:53.512]                                   base::.Machine$sizeof.pointer), 
[17:43:53.512]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.512]                                 "release", "version")], collapse = " "), 
[17:43:53.512]                               hostname = base::Sys.info()[["nodename"]])
[17:43:53.512]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.512]                               info)
[17:43:53.512]                             info <- base::paste(info, collapse = "; ")
[17:43:53.512]                             if (!has_future) {
[17:43:53.512]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.512]                                 info)
[17:43:53.512]                             }
[17:43:53.512]                             else {
[17:43:53.512]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.512]                                 info, version)
[17:43:53.512]                             }
[17:43:53.512]                             base::stop(msg)
[17:43:53.512]                           }
[17:43:53.512]                         })
[17:43:53.512]                       }
[17:43:53.512]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.512]                       base::options(mc.cores = 1L)
[17:43:53.512]                     }
[17:43:53.512]                     base::local({
[17:43:53.512]                       for (pkg in "stats") {
[17:43:53.512]                         base::loadNamespace(pkg)
[17:43:53.512]                         base::library(pkg, character.only = TRUE)
[17:43:53.512]                       }
[17:43:53.512]                     })
[17:43:53.512]                   }
[17:43:53.512]                   ...future.strategy.old <- future::plan("list")
[17:43:53.512]                   options(future.plan = NULL)
[17:43:53.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.512]                 }
[17:43:53.512]                 ...future.workdir <- getwd()
[17:43:53.512]             }
[17:43:53.512]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.512]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.512]         }
[17:43:53.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.512]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.512]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.512]             base::names(...future.oldOptions))
[17:43:53.512]     }
[17:43:53.512]     if (FALSE) {
[17:43:53.512]     }
[17:43:53.512]     else {
[17:43:53.512]         if (TRUE) {
[17:43:53.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.512]                 open = "w")
[17:43:53.512]         }
[17:43:53.512]         else {
[17:43:53.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.512]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.512]         }
[17:43:53.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.512]             base::sink(type = "output", split = FALSE)
[17:43:53.512]             base::close(...future.stdout)
[17:43:53.512]         }, add = TRUE)
[17:43:53.512]     }
[17:43:53.512]     ...future.frame <- base::sys.nframe()
[17:43:53.512]     ...future.conditions <- base::list()
[17:43:53.512]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.512]     if (FALSE) {
[17:43:53.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.512]     }
[17:43:53.512]     ...future.result <- base::tryCatch({
[17:43:53.512]         base::withCallingHandlers({
[17:43:53.512]             ...future.value <- base::withVisible(base::local({
[17:43:53.512]                 withCallingHandlers({
[17:43:53.512]                   {
[17:43:53.512]                     do.call(function(...) {
[17:43:53.512]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.512]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.512]                         ...future.globals.maxSize)) {
[17:43:53.512]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.512]                         on.exit(options(oopts), add = TRUE)
[17:43:53.512]                       }
[17:43:53.512]                       {
[17:43:53.512]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.512]                           FUN = function(jj) {
[17:43:53.512]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.512]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.512]                           })
[17:43:53.512]                       }
[17:43:53.512]                     }, args = future.call.arguments)
[17:43:53.512]                   }
[17:43:53.512]                 }, immediateCondition = function(cond) {
[17:43:53.512]                   save_rds <- function (object, pathname, ...) 
[17:43:53.512]                   {
[17:43:53.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.512]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.512]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.512]                         fi_tmp[["mtime"]])
[17:43:53.512]                     }
[17:43:53.512]                     tryCatch({
[17:43:53.512]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.512]                     }, error = function(ex) {
[17:43:53.512]                       msg <- conditionMessage(ex)
[17:43:53.512]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.512]                         fi_tmp[["mtime"]], msg)
[17:43:53.512]                       ex$message <- msg
[17:43:53.512]                       stop(ex)
[17:43:53.512]                     })
[17:43:53.512]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.512]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.512]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.512]                       fi <- file.info(pathname)
[17:43:53.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.512]                         fi[["size"]], fi[["mtime"]])
[17:43:53.512]                       stop(msg)
[17:43:53.512]                     }
[17:43:53.512]                     invisible(pathname)
[17:43:53.512]                   }
[17:43:53.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.512]                     rootPath = tempdir()) 
[17:43:53.512]                   {
[17:43:53.512]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.512]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.512]                       tmpdir = path, fileext = ".rds")
[17:43:53.512]                     save_rds(obj, file)
[17:43:53.512]                   }
[17:43:53.512]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.512]                   {
[17:43:53.512]                     inherits <- base::inherits
[17:43:53.512]                     invokeRestart <- base::invokeRestart
[17:43:53.512]                     is.null <- base::is.null
[17:43:53.512]                     muffled <- FALSE
[17:43:53.512]                     if (inherits(cond, "message")) {
[17:43:53.512]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.512]                       if (muffled) 
[17:43:53.512]                         invokeRestart("muffleMessage")
[17:43:53.512]                     }
[17:43:53.512]                     else if (inherits(cond, "warning")) {
[17:43:53.512]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.512]                       if (muffled) 
[17:43:53.512]                         invokeRestart("muffleWarning")
[17:43:53.512]                     }
[17:43:53.512]                     else if (inherits(cond, "condition")) {
[17:43:53.512]                       if (!is.null(pattern)) {
[17:43:53.512]                         computeRestarts <- base::computeRestarts
[17:43:53.512]                         grepl <- base::grepl
[17:43:53.512]                         restarts <- computeRestarts(cond)
[17:43:53.512]                         for (restart in restarts) {
[17:43:53.512]                           name <- restart$name
[17:43:53.512]                           if (is.null(name)) 
[17:43:53.512]                             next
[17:43:53.512]                           if (!grepl(pattern, name)) 
[17:43:53.512]                             next
[17:43:53.512]                           invokeRestart(restart)
[17:43:53.512]                           muffled <- TRUE
[17:43:53.512]                           break
[17:43:53.512]                         }
[17:43:53.512]                       }
[17:43:53.512]                     }
[17:43:53.512]                     invisible(muffled)
[17:43:53.512]                   }
[17:43:53.512]                   muffleCondition(cond)
[17:43:53.512]                 })
[17:43:53.512]             }))
[17:43:53.512]             future::FutureResult(value = ...future.value$value, 
[17:43:53.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.512]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.512]                     ...future.globalenv.names))
[17:43:53.512]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.512]         }, condition = base::local({
[17:43:53.512]             c <- base::c
[17:43:53.512]             inherits <- base::inherits
[17:43:53.512]             invokeRestart <- base::invokeRestart
[17:43:53.512]             length <- base::length
[17:43:53.512]             list <- base::list
[17:43:53.512]             seq.int <- base::seq.int
[17:43:53.512]             signalCondition <- base::signalCondition
[17:43:53.512]             sys.calls <- base::sys.calls
[17:43:53.512]             `[[` <- base::`[[`
[17:43:53.512]             `+` <- base::`+`
[17:43:53.512]             `<<-` <- base::`<<-`
[17:43:53.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.512]                   3L)]
[17:43:53.512]             }
[17:43:53.512]             function(cond) {
[17:43:53.512]                 is_error <- inherits(cond, "error")
[17:43:53.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.512]                   NULL)
[17:43:53.512]                 if (is_error) {
[17:43:53.512]                   sessionInformation <- function() {
[17:43:53.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.512]                       search = base::search(), system = base::Sys.info())
[17:43:53.512]                   }
[17:43:53.512]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.512]                     cond$call), session = sessionInformation(), 
[17:43:53.512]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.512]                   signalCondition(cond)
[17:43:53.512]                 }
[17:43:53.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.512]                 "immediateCondition"))) {
[17:43:53.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.512]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.512]                   if (TRUE && !signal) {
[17:43:53.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.512]                     {
[17:43:53.512]                       inherits <- base::inherits
[17:43:53.512]                       invokeRestart <- base::invokeRestart
[17:43:53.512]                       is.null <- base::is.null
[17:43:53.512]                       muffled <- FALSE
[17:43:53.512]                       if (inherits(cond, "message")) {
[17:43:53.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.512]                         if (muffled) 
[17:43:53.512]                           invokeRestart("muffleMessage")
[17:43:53.512]                       }
[17:43:53.512]                       else if (inherits(cond, "warning")) {
[17:43:53.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.512]                         if (muffled) 
[17:43:53.512]                           invokeRestart("muffleWarning")
[17:43:53.512]                       }
[17:43:53.512]                       else if (inherits(cond, "condition")) {
[17:43:53.512]                         if (!is.null(pattern)) {
[17:43:53.512]                           computeRestarts <- base::computeRestarts
[17:43:53.512]                           grepl <- base::grepl
[17:43:53.512]                           restarts <- computeRestarts(cond)
[17:43:53.512]                           for (restart in restarts) {
[17:43:53.512]                             name <- restart$name
[17:43:53.512]                             if (is.null(name)) 
[17:43:53.512]                               next
[17:43:53.512]                             if (!grepl(pattern, name)) 
[17:43:53.512]                               next
[17:43:53.512]                             invokeRestart(restart)
[17:43:53.512]                             muffled <- TRUE
[17:43:53.512]                             break
[17:43:53.512]                           }
[17:43:53.512]                         }
[17:43:53.512]                       }
[17:43:53.512]                       invisible(muffled)
[17:43:53.512]                     }
[17:43:53.512]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.512]                   }
[17:43:53.512]                 }
[17:43:53.512]                 else {
[17:43:53.512]                   if (TRUE) {
[17:43:53.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.512]                     {
[17:43:53.512]                       inherits <- base::inherits
[17:43:53.512]                       invokeRestart <- base::invokeRestart
[17:43:53.512]                       is.null <- base::is.null
[17:43:53.512]                       muffled <- FALSE
[17:43:53.512]                       if (inherits(cond, "message")) {
[17:43:53.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.512]                         if (muffled) 
[17:43:53.512]                           invokeRestart("muffleMessage")
[17:43:53.512]                       }
[17:43:53.512]                       else if (inherits(cond, "warning")) {
[17:43:53.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.512]                         if (muffled) 
[17:43:53.512]                           invokeRestart("muffleWarning")
[17:43:53.512]                       }
[17:43:53.512]                       else if (inherits(cond, "condition")) {
[17:43:53.512]                         if (!is.null(pattern)) {
[17:43:53.512]                           computeRestarts <- base::computeRestarts
[17:43:53.512]                           grepl <- base::grepl
[17:43:53.512]                           restarts <- computeRestarts(cond)
[17:43:53.512]                           for (restart in restarts) {
[17:43:53.512]                             name <- restart$name
[17:43:53.512]                             if (is.null(name)) 
[17:43:53.512]                               next
[17:43:53.512]                             if (!grepl(pattern, name)) 
[17:43:53.512]                               next
[17:43:53.512]                             invokeRestart(restart)
[17:43:53.512]                             muffled <- TRUE
[17:43:53.512]                             break
[17:43:53.512]                           }
[17:43:53.512]                         }
[17:43:53.512]                       }
[17:43:53.512]                       invisible(muffled)
[17:43:53.512]                     }
[17:43:53.512]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.512]                   }
[17:43:53.512]                 }
[17:43:53.512]             }
[17:43:53.512]         }))
[17:43:53.512]     }, error = function(ex) {
[17:43:53.512]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.512]                 ...future.rng), started = ...future.startTime, 
[17:43:53.512]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.512]             version = "1.8"), class = "FutureResult")
[17:43:53.512]     }, finally = {
[17:43:53.512]         if (!identical(...future.workdir, getwd())) 
[17:43:53.512]             setwd(...future.workdir)
[17:43:53.512]         {
[17:43:53.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.512]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.512]             }
[17:43:53.512]             base::options(...future.oldOptions)
[17:43:53.512]             if (.Platform$OS.type == "windows") {
[17:43:53.512]                 old_names <- names(...future.oldEnvVars)
[17:43:53.512]                 envs <- base::Sys.getenv()
[17:43:53.512]                 names <- names(envs)
[17:43:53.512]                 common <- intersect(names, old_names)
[17:43:53.512]                 added <- setdiff(names, old_names)
[17:43:53.512]                 removed <- setdiff(old_names, names)
[17:43:53.512]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.512]                   envs[common]]
[17:43:53.512]                 NAMES <- toupper(changed)
[17:43:53.512]                 args <- list()
[17:43:53.512]                 for (kk in seq_along(NAMES)) {
[17:43:53.512]                   name <- changed[[kk]]
[17:43:53.512]                   NAME <- NAMES[[kk]]
[17:43:53.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.512]                     next
[17:43:53.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.512]                 }
[17:43:53.512]                 NAMES <- toupper(added)
[17:43:53.512]                 for (kk in seq_along(NAMES)) {
[17:43:53.512]                   name <- added[[kk]]
[17:43:53.512]                   NAME <- NAMES[[kk]]
[17:43:53.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.512]                     next
[17:43:53.512]                   args[[name]] <- ""
[17:43:53.512]                 }
[17:43:53.512]                 NAMES <- toupper(removed)
[17:43:53.512]                 for (kk in seq_along(NAMES)) {
[17:43:53.512]                   name <- removed[[kk]]
[17:43:53.512]                   NAME <- NAMES[[kk]]
[17:43:53.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.512]                     next
[17:43:53.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.512]                 }
[17:43:53.512]                 if (length(args) > 0) 
[17:43:53.512]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.512]             }
[17:43:53.512]             else {
[17:43:53.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.512]             }
[17:43:53.512]             {
[17:43:53.512]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.512]                   0L) {
[17:43:53.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.512]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.512]                   base::options(opts)
[17:43:53.512]                 }
[17:43:53.512]                 {
[17:43:53.512]                   {
[17:43:53.512]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.512]                     NULL
[17:43:53.512]                   }
[17:43:53.512]                   options(future.plan = NULL)
[17:43:53.512]                   if (is.na(NA_character_)) 
[17:43:53.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.512]                     .init = FALSE)
[17:43:53.512]                 }
[17:43:53.512]             }
[17:43:53.512]         }
[17:43:53.512]     })
[17:43:53.512]     if (TRUE) {
[17:43:53.512]         base::sink(type = "output", split = FALSE)
[17:43:53.512]         if (TRUE) {
[17:43:53.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.512]         }
[17:43:53.512]         else {
[17:43:53.512]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.512]         }
[17:43:53.512]         base::close(...future.stdout)
[17:43:53.512]         ...future.stdout <- NULL
[17:43:53.512]     }
[17:43:53.512]     ...future.result$conditions <- ...future.conditions
[17:43:53.512]     ...future.result$finished <- base::Sys.time()
[17:43:53.512]     ...future.result
[17:43:53.512] }
[17:43:53.515] assign_globals() ...
[17:43:53.515] List of 7
[17:43:53.515]  $ ...future.FUN            :function (x)  
[17:43:53.515]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:53.515]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.515]  $ future.call.arguments    : list()
[17:43:53.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.515]  $ ...future.elements_ii    :List of 1
[17:43:53.515]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.515]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.515]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.515]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.515]  $ ...future.seeds_ii       : NULL
[17:43:53.515]  $ ...future.globals.maxSize: NULL
[17:43:53.515]  - attr(*, "where")=List of 7
[17:43:53.515]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.515]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:43:53.515]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:43:53.515]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.515]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.515]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.515]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.515]  - attr(*, "resolved")= logi FALSE
[17:43:53.515]  - attr(*, "total_size")= num 2320
[17:43:53.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.515]  - attr(*, "already-done")= logi TRUE
[17:43:53.524] - reassign environment for ‘...future.FUN’
[17:43:53.525] - copied ‘...future.FUN’ to environment
[17:43:53.525] - copied ‘breaks’ to environment
[17:43:53.525] - copied ‘wool’ to environment
[17:43:53.525] - copied ‘future.call.arguments’ to environment
[17:43:53.525] - copied ‘...future.elements_ii’ to environment
[17:43:53.525] - copied ‘...future.seeds_ii’ to environment
[17:43:53.525] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.525] assign_globals() ... done
[17:43:53.525] requestCore(): workers = 2
[17:43:53.528] MulticoreFuture started
[17:43:53.528] - Launch lazy future ... done
[17:43:53.528] run() for ‘MulticoreFuture’ ... done
[17:43:53.529] Created future:
[17:43:53.529] plan(): Setting new future strategy stack:
[17:43:53.530] List of future strategies:
[17:43:53.530] 1. sequential:
[17:43:53.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.530]    - tweaked: FALSE
[17:43:53.530]    - call: NULL
[17:43:53.531] plan(): nbrOfWorkers() = 1
[17:43:53.534] plan(): Setting new future strategy stack:
[17:43:53.535] List of future strategies:
[17:43:53.535] 1. multicore:
[17:43:53.535]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.535]    - tweaked: FALSE
[17:43:53.535]    - call: plan(strategy)
[17:43:53.540] plan(): nbrOfWorkers() = 2
[17:43:53.529] MulticoreFuture:
[17:43:53.529] Label: ‘future_by-1’
[17:43:53.529] Expression:
[17:43:53.529] {
[17:43:53.529]     do.call(function(...) {
[17:43:53.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.529]             on.exit(options(oopts), add = TRUE)
[17:43:53.529]         }
[17:43:53.529]         {
[17:43:53.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.529]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.529]             })
[17:43:53.529]         }
[17:43:53.529]     }, args = future.call.arguments)
[17:43:53.529] }
[17:43:53.529] Lazy evaluation: FALSE
[17:43:53.529] Asynchronous evaluation: TRUE
[17:43:53.529] Local evaluation: TRUE
[17:43:53.529] Environment: 0x55d6baadba78
[17:43:53.529] Capture standard output: TRUE
[17:43:53.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.529] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:43:53.529] Packages: 1 packages (‘stats’)
[17:43:53.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.529] Resolved: TRUE
[17:43:53.529] Value: <not collected>
[17:43:53.529] Conditions captured: <none>
[17:43:53.529] Early signaling: FALSE
[17:43:53.529] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.529] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.542] Chunk #1 of 2 ... DONE
[17:43:53.542] Chunk #2 of 2 ...
[17:43:53.543]  - Finding globals in 'X' for chunk #2 ...
[17:43:53.543] getGlobalsAndPackages() ...
[17:43:53.543] Searching for globals...
[17:43:53.544] 
[17:43:53.544] Searching for globals ... DONE
[17:43:53.544] - globals: [0] <none>
[17:43:53.544] getGlobalsAndPackages() ... DONE
[17:43:53.544]    + additional globals found: [n=0] 
[17:43:53.544]    + additional namespaces needed: [n=0] 
[17:43:53.544]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:53.545]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.545]  - seeds: <none>
[17:43:53.545]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.545] getGlobalsAndPackages() ...
[17:43:53.545] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.545] Resolving globals: FALSE
[17:43:53.545] Tweak future expression to call with '...' arguments ...
[17:43:53.546] {
[17:43:53.546]     do.call(function(...) {
[17:43:53.546]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.546]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.546]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.546]             on.exit(options(oopts), add = TRUE)
[17:43:53.546]         }
[17:43:53.546]         {
[17:43:53.546]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.546]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.546]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.546]             })
[17:43:53.546]         }
[17:43:53.546]     }, args = future.call.arguments)
[17:43:53.546] }
[17:43:53.546] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.547] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.547] 
[17:43:53.547] getGlobalsAndPackages() ... DONE
[17:43:53.548] run() for ‘Future’ ...
[17:43:53.548] - state: ‘created’
[17:43:53.548] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.553] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.553]   - Field: ‘label’
[17:43:53.553]   - Field: ‘local’
[17:43:53.553]   - Field: ‘owner’
[17:43:53.554]   - Field: ‘envir’
[17:43:53.554]   - Field: ‘workers’
[17:43:53.554]   - Field: ‘packages’
[17:43:53.554]   - Field: ‘gc’
[17:43:53.554]   - Field: ‘job’
[17:43:53.554]   - Field: ‘conditions’
[17:43:53.554]   - Field: ‘expr’
[17:43:53.555]   - Field: ‘uuid’
[17:43:53.555]   - Field: ‘seed’
[17:43:53.555]   - Field: ‘version’
[17:43:53.555]   - Field: ‘result’
[17:43:53.555]   - Field: ‘asynchronous’
[17:43:53.555]   - Field: ‘calls’
[17:43:53.555]   - Field: ‘globals’
[17:43:53.556]   - Field: ‘stdout’
[17:43:53.556]   - Field: ‘earlySignal’
[17:43:53.556]   - Field: ‘lazy’
[17:43:53.556]   - Field: ‘state’
[17:43:53.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.556] - Launch lazy future ...
[17:43:53.557] Packages needed by the future expression (n = 1): ‘stats’
[17:43:53.557] Packages needed by future strategies (n = 0): <none>
[17:43:53.558] {
[17:43:53.558]     {
[17:43:53.558]         {
[17:43:53.558]             ...future.startTime <- base::Sys.time()
[17:43:53.558]             {
[17:43:53.558]                 {
[17:43:53.558]                   {
[17:43:53.558]                     {
[17:43:53.558]                       {
[17:43:53.558]                         base::local({
[17:43:53.558]                           has_future <- base::requireNamespace("future", 
[17:43:53.558]                             quietly = TRUE)
[17:43:53.558]                           if (has_future) {
[17:43:53.558]                             ns <- base::getNamespace("future")
[17:43:53.558]                             version <- ns[[".package"]][["version"]]
[17:43:53.558]                             if (is.null(version)) 
[17:43:53.558]                               version <- utils::packageVersion("future")
[17:43:53.558]                           }
[17:43:53.558]                           else {
[17:43:53.558]                             version <- NULL
[17:43:53.558]                           }
[17:43:53.558]                           if (!has_future || version < "1.8.0") {
[17:43:53.558]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.558]                               "", base::R.version$version.string), 
[17:43:53.558]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:53.558]                                 base::R.version$platform, 8 * 
[17:43:53.558]                                   base::.Machine$sizeof.pointer), 
[17:43:53.558]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.558]                                 "release", "version")], collapse = " "), 
[17:43:53.558]                               hostname = base::Sys.info()[["nodename"]])
[17:43:53.558]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.558]                               info)
[17:43:53.558]                             info <- base::paste(info, collapse = "; ")
[17:43:53.558]                             if (!has_future) {
[17:43:53.558]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.558]                                 info)
[17:43:53.558]                             }
[17:43:53.558]                             else {
[17:43:53.558]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.558]                                 info, version)
[17:43:53.558]                             }
[17:43:53.558]                             base::stop(msg)
[17:43:53.558]                           }
[17:43:53.558]                         })
[17:43:53.558]                       }
[17:43:53.558]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.558]                       base::options(mc.cores = 1L)
[17:43:53.558]                     }
[17:43:53.558]                     base::local({
[17:43:53.558]                       for (pkg in "stats") {
[17:43:53.558]                         base::loadNamespace(pkg)
[17:43:53.558]                         base::library(pkg, character.only = TRUE)
[17:43:53.558]                       }
[17:43:53.558]                     })
[17:43:53.558]                   }
[17:43:53.558]                   ...future.strategy.old <- future::plan("list")
[17:43:53.558]                   options(future.plan = NULL)
[17:43:53.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.558]                 }
[17:43:53.558]                 ...future.workdir <- getwd()
[17:43:53.558]             }
[17:43:53.558]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.558]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.558]         }
[17:43:53.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.558]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.558]             base::names(...future.oldOptions))
[17:43:53.558]     }
[17:43:53.558]     if (FALSE) {
[17:43:53.558]     }
[17:43:53.558]     else {
[17:43:53.558]         if (TRUE) {
[17:43:53.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.558]                 open = "w")
[17:43:53.558]         }
[17:43:53.558]         else {
[17:43:53.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.558]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.558]         }
[17:43:53.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.558]             base::sink(type = "output", split = FALSE)
[17:43:53.558]             base::close(...future.stdout)
[17:43:53.558]         }, add = TRUE)
[17:43:53.558]     }
[17:43:53.558]     ...future.frame <- base::sys.nframe()
[17:43:53.558]     ...future.conditions <- base::list()
[17:43:53.558]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.558]     if (FALSE) {
[17:43:53.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.558]     }
[17:43:53.558]     ...future.result <- base::tryCatch({
[17:43:53.558]         base::withCallingHandlers({
[17:43:53.558]             ...future.value <- base::withVisible(base::local({
[17:43:53.558]                 withCallingHandlers({
[17:43:53.558]                   {
[17:43:53.558]                     do.call(function(...) {
[17:43:53.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.558]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.558]                         ...future.globals.maxSize)) {
[17:43:53.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.558]                         on.exit(options(oopts), add = TRUE)
[17:43:53.558]                       }
[17:43:53.558]                       {
[17:43:53.558]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.558]                           FUN = function(jj) {
[17:43:53.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.558]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.558]                           })
[17:43:53.558]                       }
[17:43:53.558]                     }, args = future.call.arguments)
[17:43:53.558]                   }
[17:43:53.558]                 }, immediateCondition = function(cond) {
[17:43:53.558]                   save_rds <- function (object, pathname, ...) 
[17:43:53.558]                   {
[17:43:53.558]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.558]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.558]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.558]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.558]                         fi_tmp[["mtime"]])
[17:43:53.558]                     }
[17:43:53.558]                     tryCatch({
[17:43:53.558]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.558]                     }, error = function(ex) {
[17:43:53.558]                       msg <- conditionMessage(ex)
[17:43:53.558]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.558]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.558]                         fi_tmp[["mtime"]], msg)
[17:43:53.558]                       ex$message <- msg
[17:43:53.558]                       stop(ex)
[17:43:53.558]                     })
[17:43:53.558]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.558]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.558]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.558]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.558]                       fi <- file.info(pathname)
[17:43:53.558]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.558]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.558]                         fi[["size"]], fi[["mtime"]])
[17:43:53.558]                       stop(msg)
[17:43:53.558]                     }
[17:43:53.558]                     invisible(pathname)
[17:43:53.558]                   }
[17:43:53.558]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.558]                     rootPath = tempdir()) 
[17:43:53.558]                   {
[17:43:53.558]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.558]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.558]                       tmpdir = path, fileext = ".rds")
[17:43:53.558]                     save_rds(obj, file)
[17:43:53.558]                   }
[17:43:53.558]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.558]                   {
[17:43:53.558]                     inherits <- base::inherits
[17:43:53.558]                     invokeRestart <- base::invokeRestart
[17:43:53.558]                     is.null <- base::is.null
[17:43:53.558]                     muffled <- FALSE
[17:43:53.558]                     if (inherits(cond, "message")) {
[17:43:53.558]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.558]                       if (muffled) 
[17:43:53.558]                         invokeRestart("muffleMessage")
[17:43:53.558]                     }
[17:43:53.558]                     else if (inherits(cond, "warning")) {
[17:43:53.558]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.558]                       if (muffled) 
[17:43:53.558]                         invokeRestart("muffleWarning")
[17:43:53.558]                     }
[17:43:53.558]                     else if (inherits(cond, "condition")) {
[17:43:53.558]                       if (!is.null(pattern)) {
[17:43:53.558]                         computeRestarts <- base::computeRestarts
[17:43:53.558]                         grepl <- base::grepl
[17:43:53.558]                         restarts <- computeRestarts(cond)
[17:43:53.558]                         for (restart in restarts) {
[17:43:53.558]                           name <- restart$name
[17:43:53.558]                           if (is.null(name)) 
[17:43:53.558]                             next
[17:43:53.558]                           if (!grepl(pattern, name)) 
[17:43:53.558]                             next
[17:43:53.558]                           invokeRestart(restart)
[17:43:53.558]                           muffled <- TRUE
[17:43:53.558]                           break
[17:43:53.558]                         }
[17:43:53.558]                       }
[17:43:53.558]                     }
[17:43:53.558]                     invisible(muffled)
[17:43:53.558]                   }
[17:43:53.558]                   muffleCondition(cond)
[17:43:53.558]                 })
[17:43:53.558]             }))
[17:43:53.558]             future::FutureResult(value = ...future.value$value, 
[17:43:53.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.558]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.558]                     ...future.globalenv.names))
[17:43:53.558]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.558]         }, condition = base::local({
[17:43:53.558]             c <- base::c
[17:43:53.558]             inherits <- base::inherits
[17:43:53.558]             invokeRestart <- base::invokeRestart
[17:43:53.558]             length <- base::length
[17:43:53.558]             list <- base::list
[17:43:53.558]             seq.int <- base::seq.int
[17:43:53.558]             signalCondition <- base::signalCondition
[17:43:53.558]             sys.calls <- base::sys.calls
[17:43:53.558]             `[[` <- base::`[[`
[17:43:53.558]             `+` <- base::`+`
[17:43:53.558]             `<<-` <- base::`<<-`
[17:43:53.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.558]                   3L)]
[17:43:53.558]             }
[17:43:53.558]             function(cond) {
[17:43:53.558]                 is_error <- inherits(cond, "error")
[17:43:53.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.558]                   NULL)
[17:43:53.558]                 if (is_error) {
[17:43:53.558]                   sessionInformation <- function() {
[17:43:53.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.558]                       search = base::search(), system = base::Sys.info())
[17:43:53.558]                   }
[17:43:53.558]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.558]                     cond$call), session = sessionInformation(), 
[17:43:53.558]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.558]                   signalCondition(cond)
[17:43:53.558]                 }
[17:43:53.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.558]                 "immediateCondition"))) {
[17:43:53.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.558]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.558]                   if (TRUE && !signal) {
[17:43:53.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.558]                     {
[17:43:53.558]                       inherits <- base::inherits
[17:43:53.558]                       invokeRestart <- base::invokeRestart
[17:43:53.558]                       is.null <- base::is.null
[17:43:53.558]                       muffled <- FALSE
[17:43:53.558]                       if (inherits(cond, "message")) {
[17:43:53.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.558]                         if (muffled) 
[17:43:53.558]                           invokeRestart("muffleMessage")
[17:43:53.558]                       }
[17:43:53.558]                       else if (inherits(cond, "warning")) {
[17:43:53.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.558]                         if (muffled) 
[17:43:53.558]                           invokeRestart("muffleWarning")
[17:43:53.558]                       }
[17:43:53.558]                       else if (inherits(cond, "condition")) {
[17:43:53.558]                         if (!is.null(pattern)) {
[17:43:53.558]                           computeRestarts <- base::computeRestarts
[17:43:53.558]                           grepl <- base::grepl
[17:43:53.558]                           restarts <- computeRestarts(cond)
[17:43:53.558]                           for (restart in restarts) {
[17:43:53.558]                             name <- restart$name
[17:43:53.558]                             if (is.null(name)) 
[17:43:53.558]                               next
[17:43:53.558]                             if (!grepl(pattern, name)) 
[17:43:53.558]                               next
[17:43:53.558]                             invokeRestart(restart)
[17:43:53.558]                             muffled <- TRUE
[17:43:53.558]                             break
[17:43:53.558]                           }
[17:43:53.558]                         }
[17:43:53.558]                       }
[17:43:53.558]                       invisible(muffled)
[17:43:53.558]                     }
[17:43:53.558]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.558]                   }
[17:43:53.558]                 }
[17:43:53.558]                 else {
[17:43:53.558]                   if (TRUE) {
[17:43:53.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.558]                     {
[17:43:53.558]                       inherits <- base::inherits
[17:43:53.558]                       invokeRestart <- base::invokeRestart
[17:43:53.558]                       is.null <- base::is.null
[17:43:53.558]                       muffled <- FALSE
[17:43:53.558]                       if (inherits(cond, "message")) {
[17:43:53.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.558]                         if (muffled) 
[17:43:53.558]                           invokeRestart("muffleMessage")
[17:43:53.558]                       }
[17:43:53.558]                       else if (inherits(cond, "warning")) {
[17:43:53.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.558]                         if (muffled) 
[17:43:53.558]                           invokeRestart("muffleWarning")
[17:43:53.558]                       }
[17:43:53.558]                       else if (inherits(cond, "condition")) {
[17:43:53.558]                         if (!is.null(pattern)) {
[17:43:53.558]                           computeRestarts <- base::computeRestarts
[17:43:53.558]                           grepl <- base::grepl
[17:43:53.558]                           restarts <- computeRestarts(cond)
[17:43:53.558]                           for (restart in restarts) {
[17:43:53.558]                             name <- restart$name
[17:43:53.558]                             if (is.null(name)) 
[17:43:53.558]                               next
[17:43:53.558]                             if (!grepl(pattern, name)) 
[17:43:53.558]                               next
[17:43:53.558]                             invokeRestart(restart)
[17:43:53.558]                             muffled <- TRUE
[17:43:53.558]                             break
[17:43:53.558]                           }
[17:43:53.558]                         }
[17:43:53.558]                       }
[17:43:53.558]                       invisible(muffled)
[17:43:53.558]                     }
[17:43:53.558]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.558]                   }
[17:43:53.558]                 }
[17:43:53.558]             }
[17:43:53.558]         }))
[17:43:53.558]     }, error = function(ex) {
[17:43:53.558]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.558]                 ...future.rng), started = ...future.startTime, 
[17:43:53.558]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.558]             version = "1.8"), class = "FutureResult")
[17:43:53.558]     }, finally = {
[17:43:53.558]         if (!identical(...future.workdir, getwd())) 
[17:43:53.558]             setwd(...future.workdir)
[17:43:53.558]         {
[17:43:53.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.558]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.558]             }
[17:43:53.558]             base::options(...future.oldOptions)
[17:43:53.558]             if (.Platform$OS.type == "windows") {
[17:43:53.558]                 old_names <- names(...future.oldEnvVars)
[17:43:53.558]                 envs <- base::Sys.getenv()
[17:43:53.558]                 names <- names(envs)
[17:43:53.558]                 common <- intersect(names, old_names)
[17:43:53.558]                 added <- setdiff(names, old_names)
[17:43:53.558]                 removed <- setdiff(old_names, names)
[17:43:53.558]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.558]                   envs[common]]
[17:43:53.558]                 NAMES <- toupper(changed)
[17:43:53.558]                 args <- list()
[17:43:53.558]                 for (kk in seq_along(NAMES)) {
[17:43:53.558]                   name <- changed[[kk]]
[17:43:53.558]                   NAME <- NAMES[[kk]]
[17:43:53.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.558]                     next
[17:43:53.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.558]                 }
[17:43:53.558]                 NAMES <- toupper(added)
[17:43:53.558]                 for (kk in seq_along(NAMES)) {
[17:43:53.558]                   name <- added[[kk]]
[17:43:53.558]                   NAME <- NAMES[[kk]]
[17:43:53.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.558]                     next
[17:43:53.558]                   args[[name]] <- ""
[17:43:53.558]                 }
[17:43:53.558]                 NAMES <- toupper(removed)
[17:43:53.558]                 for (kk in seq_along(NAMES)) {
[17:43:53.558]                   name <- removed[[kk]]
[17:43:53.558]                   NAME <- NAMES[[kk]]
[17:43:53.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.558]                     next
[17:43:53.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.558]                 }
[17:43:53.558]                 if (length(args) > 0) 
[17:43:53.558]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.558]             }
[17:43:53.558]             else {
[17:43:53.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.558]             }
[17:43:53.558]             {
[17:43:53.558]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.558]                   0L) {
[17:43:53.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.558]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.558]                   base::options(opts)
[17:43:53.558]                 }
[17:43:53.558]                 {
[17:43:53.558]                   {
[17:43:53.558]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.558]                     NULL
[17:43:53.558]                   }
[17:43:53.558]                   options(future.plan = NULL)
[17:43:53.558]                   if (is.na(NA_character_)) 
[17:43:53.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.558]                     .init = FALSE)
[17:43:53.558]                 }
[17:43:53.558]             }
[17:43:53.558]         }
[17:43:53.558]     })
[17:43:53.558]     if (TRUE) {
[17:43:53.558]         base::sink(type = "output", split = FALSE)
[17:43:53.558]         if (TRUE) {
[17:43:53.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.558]         }
[17:43:53.558]         else {
[17:43:53.558]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.558]         }
[17:43:53.558]         base::close(...future.stdout)
[17:43:53.558]         ...future.stdout <- NULL
[17:43:53.558]     }
[17:43:53.558]     ...future.result$conditions <- ...future.conditions
[17:43:53.558]     ...future.result$finished <- base::Sys.time()
[17:43:53.558]     ...future.result
[17:43:53.558] }
[17:43:53.561] assign_globals() ...
[17:43:53.561] List of 7
[17:43:53.561]  $ ...future.FUN            :function (x)  
[17:43:53.561]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:53.561]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.561]  $ future.call.arguments    : list()
[17:43:53.561]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.561]  $ ...future.elements_ii    :List of 2
[17:43:53.561]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.561]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.561]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.561]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:53.561]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.561]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.561]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.561]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:53.561]  $ ...future.seeds_ii       : NULL
[17:43:53.561]  $ ...future.globals.maxSize: NULL
[17:43:53.561]  - attr(*, "where")=List of 7
[17:43:53.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.561]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:43:53.561]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:43:53.561]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.561]  - attr(*, "resolved")= logi FALSE
[17:43:53.561]  - attr(*, "total_size")= num 2320
[17:43:53.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.561]  - attr(*, "already-done")= logi TRUE
[17:43:53.578] - reassign environment for ‘...future.FUN’
[17:43:53.578] - copied ‘...future.FUN’ to environment
[17:43:53.579] - copied ‘breaks’ to environment
[17:43:53.579] - copied ‘wool’ to environment
[17:43:53.579] - copied ‘future.call.arguments’ to environment
[17:43:53.579] - copied ‘...future.elements_ii’ to environment
[17:43:53.579] - copied ‘...future.seeds_ii’ to environment
[17:43:53.579] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.579] assign_globals() ... done
[17:43:53.579] requestCore(): workers = 2
[17:43:53.581] MulticoreFuture started
[17:43:53.582] - Launch lazy future ... done
[17:43:53.582] run() for ‘MulticoreFuture’ ... done
[17:43:53.582] Created future:
[17:43:53.583] plan(): Setting new future strategy stack:
[17:43:53.583] List of future strategies:
[17:43:53.583] 1. sequential:
[17:43:53.583]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.583]    - tweaked: FALSE
[17:43:53.583]    - call: NULL
[17:43:53.584] plan(): nbrOfWorkers() = 1
[17:43:53.589] plan(): Setting new future strategy stack:
[17:43:53.589] List of future strategies:
[17:43:53.589] 1. multicore:
[17:43:53.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.589]    - tweaked: FALSE
[17:43:53.589]    - call: plan(strategy)
[17:43:53.594] plan(): nbrOfWorkers() = 2
[17:43:53.582] MulticoreFuture:
[17:43:53.582] Label: ‘future_by-2’
[17:43:53.582] Expression:
[17:43:53.582] {
[17:43:53.582]     do.call(function(...) {
[17:43:53.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.582]             on.exit(options(oopts), add = TRUE)
[17:43:53.582]         }
[17:43:53.582]         {
[17:43:53.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.582]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.582]             })
[17:43:53.582]         }
[17:43:53.582]     }, args = future.call.arguments)
[17:43:53.582] }
[17:43:53.582] Lazy evaluation: FALSE
[17:43:53.582] Asynchronous evaluation: TRUE
[17:43:53.582] Local evaluation: TRUE
[17:43:53.582] Environment: 0x55d6baadba78
[17:43:53.582] Capture standard output: TRUE
[17:43:53.582] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.582] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:43:53.582] Packages: 1 packages (‘stats’)
[17:43:53.582] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.582] Resolved: FALSE
[17:43:53.582] Value: <not collected>
[17:43:53.582] Conditions captured: <none>
[17:43:53.582] Early signaling: FALSE
[17:43:53.582] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.582] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.596] Chunk #2 of 2 ... DONE
[17:43:53.596] Launching 2 futures (chunks) ... DONE
[17:43:53.596] Resolving 2 futures (chunks) ...
[17:43:53.596] resolve() on list ...
[17:43:53.597]  recursive: 0
[17:43:53.597]  length: 2
[17:43:53.597] 
[17:43:53.597] Future #1
[17:43:53.597] result() for MulticoreFuture ...
[17:43:53.599] result() for MulticoreFuture ...
[17:43:53.599] result() for MulticoreFuture ... done
[17:43:53.599] result() for MulticoreFuture ... done
[17:43:53.599] result() for MulticoreFuture ...
[17:43:53.599] result() for MulticoreFuture ... done
[17:43:53.600] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:53.600] - nx: 2
[17:43:53.600] - relay: TRUE
[17:43:53.600] - stdout: TRUE
[17:43:53.600] - signal: TRUE
[17:43:53.600] - resignal: FALSE
[17:43:53.600] - force: TRUE
[17:43:53.600] - relayed: [n=2] FALSE, FALSE
[17:43:53.601] - queued futures: [n=2] FALSE, FALSE
[17:43:53.601]  - until=1
[17:43:53.601]  - relaying element #1
[17:43:53.601] result() for MulticoreFuture ...
[17:43:53.601] result() for MulticoreFuture ... done
[17:43:53.601] result() for MulticoreFuture ...
[17:43:53.601] result() for MulticoreFuture ... done
[17:43:53.602] result() for MulticoreFuture ...
[17:43:53.602] result() for MulticoreFuture ... done
[17:43:53.602] result() for MulticoreFuture ...
[17:43:53.602] result() for MulticoreFuture ... done
[17:43:53.602] - relayed: [n=2] TRUE, FALSE
[17:43:53.602] - queued futures: [n=2] TRUE, FALSE
[17:43:53.602] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:53.603]  length: 1 (resolved future 1)
[17:43:53.603] Future #2
[17:43:53.603] result() for MulticoreFuture ...
[17:43:53.604] result() for MulticoreFuture ...
[17:43:53.605] result() for MulticoreFuture ... done
[17:43:53.605] result() for MulticoreFuture ... done
[17:43:53.605] result() for MulticoreFuture ...
[17:43:53.605] result() for MulticoreFuture ... done
[17:43:53.605] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:53.605] - nx: 2
[17:43:53.605] - relay: TRUE
[17:43:53.606] - stdout: TRUE
[17:43:53.606] - signal: TRUE
[17:43:53.606] - resignal: FALSE
[17:43:53.606] - force: TRUE
[17:43:53.606] - relayed: [n=2] TRUE, FALSE
[17:43:53.606] - queued futures: [n=2] TRUE, FALSE
[17:43:53.606]  - until=2
[17:43:53.606]  - relaying element #2
[17:43:53.607] result() for MulticoreFuture ...
[17:43:53.607] result() for MulticoreFuture ... done
[17:43:53.607] result() for MulticoreFuture ...
[17:43:53.607] result() for MulticoreFuture ... done
[17:43:53.607] result() for MulticoreFuture ...
[17:43:53.607] result() for MulticoreFuture ... done
[17:43:53.610] result() for MulticoreFuture ...
[17:43:53.610] result() for MulticoreFuture ... done
[17:43:53.610] - relayed: [n=2] TRUE, TRUE
[17:43:53.610] - queued futures: [n=2] TRUE, TRUE
[17:43:53.610] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:53.611]  length: 0 (resolved future 2)
[17:43:53.611] Relaying remaining futures
[17:43:53.611] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.611] - nx: 2
[17:43:53.611] - relay: TRUE
[17:43:53.611] - stdout: TRUE
[17:43:53.611] - signal: TRUE
[17:43:53.612] - resignal: FALSE
[17:43:53.612] - force: TRUE
[17:43:53.612] - relayed: [n=2] TRUE, TRUE
[17:43:53.612] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:53.612] - relayed: [n=2] TRUE, TRUE
[17:43:53.612] - queued futures: [n=2] TRUE, TRUE
[17:43:53.613] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.613] resolve() on list ... DONE
[17:43:53.613] result() for MulticoreFuture ...
[17:43:53.613] result() for MulticoreFuture ... done
[17:43:53.613] result() for MulticoreFuture ...
[17:43:53.613] result() for MulticoreFuture ... done
[17:43:53.613] result() for MulticoreFuture ...
[17:43:53.614] result() for MulticoreFuture ... done
[17:43:53.614] result() for MulticoreFuture ...
[17:43:53.614] result() for MulticoreFuture ... done
[17:43:53.614]  - Number of value chunks collected: 2
[17:43:53.614] Resolving 2 futures (chunks) ... DONE
[17:43:53.614] Reducing values from 2 chunks ...
[17:43:53.615]  - Number of values collected after concatenation: 3
[17:43:53.615]  - Number of values expected: 3
[17:43:53.615] Reducing values from 2 chunks ... DONE
[17:43:53.615] future_lapply() ... DONE
[17:43:53.615] future_by_internal() ... DONE
[17:43:53.616] future_by_internal() ...
[17:43:53.616] future_lapply() ...
[17:43:53.621] Number of chunks: 2
[17:43:53.621] getGlobalsAndPackagesXApply() ...
[17:43:53.621]  - future.globals: TRUE
[17:43:53.621] getGlobalsAndPackages() ...
[17:43:53.621] Searching for globals...
[17:43:53.623] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:53.623] Searching for globals ... DONE
[17:43:53.623] Resolving globals: FALSE
[17:43:53.623] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:53.624] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:53.624] - globals: [1] ‘FUN’
[17:43:53.624] 
[17:43:53.624] getGlobalsAndPackages() ... DONE
[17:43:53.624]  - globals found/used: [n=1] ‘FUN’
[17:43:53.624]  - needed namespaces: [n=0] 
[17:43:53.624] Finding globals ... DONE
[17:43:53.624]  - use_args: TRUE
[17:43:53.625]  - Getting '...' globals ...
[17:43:53.625] resolve() on list ...
[17:43:53.625]  recursive: 0
[17:43:53.625]  length: 1
[17:43:53.625]  elements: ‘...’
[17:43:53.625]  length: 0 (resolved future 1)
[17:43:53.625] resolve() on list ... DONE
[17:43:53.626]    - '...' content: [n=0] 
[17:43:53.626] List of 1
[17:43:53.626]  $ ...: list()
[17:43:53.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.626]  - attr(*, "where")=List of 1
[17:43:53.626]   ..$ ...:<environment: 0x55d6bac23790> 
[17:43:53.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.626]  - attr(*, "resolved")= logi TRUE
[17:43:53.626]  - attr(*, "total_size")= num NA
[17:43:53.628]  - Getting '...' globals ... DONE
[17:43:53.628] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.629] List of 2
[17:43:53.629]  $ ...future.FUN:function (object, ...)  
[17:43:53.629]  $ ...          : list()
[17:43:53.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.629]  - attr(*, "where")=List of 2
[17:43:53.629]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.629]   ..$ ...          :<environment: 0x55d6bac23790> 
[17:43:53.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.629]  - attr(*, "resolved")= logi FALSE
[17:43:53.629]  - attr(*, "total_size")= num 1240
[17:43:53.631] Packages to be attached in all futures: [n=0] 
[17:43:53.631] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.631] Number of futures (= number of chunks): 2
[17:43:53.631] Launching 2 futures (chunks) ...
[17:43:53.632] Chunk #1 of 2 ...
[17:43:53.632]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.632] getGlobalsAndPackages() ...
[17:43:53.632] Searching for globals...
[17:43:53.632] 
[17:43:53.632] Searching for globals ... DONE
[17:43:53.632] - globals: [0] <none>
[17:43:53.632] getGlobalsAndPackages() ... DONE
[17:43:53.633]    + additional globals found: [n=0] 
[17:43:53.633]    + additional namespaces needed: [n=0] 
[17:43:53.633]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.633]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.633]  - seeds: <none>
[17:43:53.633]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.635] getGlobalsAndPackages() ...
[17:43:53.635] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.635] Resolving globals: FALSE
[17:43:53.635] Tweak future expression to call with '...' arguments ...
[17:43:53.635] {
[17:43:53.635]     do.call(function(...) {
[17:43:53.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.635]             on.exit(options(oopts), add = TRUE)
[17:43:53.635]         }
[17:43:53.635]         {
[17:43:53.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.635]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.635]             })
[17:43:53.635]         }
[17:43:53.635]     }, args = future.call.arguments)
[17:43:53.635] }
[17:43:53.636] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.636] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.636] 
[17:43:53.636] getGlobalsAndPackages() ... DONE
[17:43:53.637] run() for ‘Future’ ...
[17:43:53.637] - state: ‘created’
[17:43:53.637] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.641] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.641]   - Field: ‘label’
[17:43:53.641]   - Field: ‘local’
[17:43:53.641]   - Field: ‘owner’
[17:43:53.641]   - Field: ‘envir’
[17:43:53.641]   - Field: ‘workers’
[17:43:53.641]   - Field: ‘packages’
[17:43:53.642]   - Field: ‘gc’
[17:43:53.642]   - Field: ‘job’
[17:43:53.642]   - Field: ‘conditions’
[17:43:53.642]   - Field: ‘expr’
[17:43:53.642]   - Field: ‘uuid’
[17:43:53.642]   - Field: ‘seed’
[17:43:53.642]   - Field: ‘version’
[17:43:53.642]   - Field: ‘result’
[17:43:53.642]   - Field: ‘asynchronous’
[17:43:53.642]   - Field: ‘calls’
[17:43:53.643]   - Field: ‘globals’
[17:43:53.643]   - Field: ‘stdout’
[17:43:53.643]   - Field: ‘earlySignal’
[17:43:53.643]   - Field: ‘lazy’
[17:43:53.643]   - Field: ‘state’
[17:43:53.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.643] - Launch lazy future ...
[17:43:53.643] Packages needed by the future expression (n = 0): <none>
[17:43:53.644] Packages needed by future strategies (n = 0): <none>
[17:43:53.644] {
[17:43:53.644]     {
[17:43:53.644]         {
[17:43:53.644]             ...future.startTime <- base::Sys.time()
[17:43:53.644]             {
[17:43:53.644]                 {
[17:43:53.644]                   {
[17:43:53.644]                     {
[17:43:53.644]                       base::local({
[17:43:53.644]                         has_future <- base::requireNamespace("future", 
[17:43:53.644]                           quietly = TRUE)
[17:43:53.644]                         if (has_future) {
[17:43:53.644]                           ns <- base::getNamespace("future")
[17:43:53.644]                           version <- ns[[".package"]][["version"]]
[17:43:53.644]                           if (is.null(version)) 
[17:43:53.644]                             version <- utils::packageVersion("future")
[17:43:53.644]                         }
[17:43:53.644]                         else {
[17:43:53.644]                           version <- NULL
[17:43:53.644]                         }
[17:43:53.644]                         if (!has_future || version < "1.8.0") {
[17:43:53.644]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.644]                             "", base::R.version$version.string), 
[17:43:53.644]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.644]                               "release", "version")], collapse = " "), 
[17:43:53.644]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.644]                             info)
[17:43:53.644]                           info <- base::paste(info, collapse = "; ")
[17:43:53.644]                           if (!has_future) {
[17:43:53.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.644]                               info)
[17:43:53.644]                           }
[17:43:53.644]                           else {
[17:43:53.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.644]                               info, version)
[17:43:53.644]                           }
[17:43:53.644]                           base::stop(msg)
[17:43:53.644]                         }
[17:43:53.644]                       })
[17:43:53.644]                     }
[17:43:53.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.644]                     base::options(mc.cores = 1L)
[17:43:53.644]                   }
[17:43:53.644]                   ...future.strategy.old <- future::plan("list")
[17:43:53.644]                   options(future.plan = NULL)
[17:43:53.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.644]                 }
[17:43:53.644]                 ...future.workdir <- getwd()
[17:43:53.644]             }
[17:43:53.644]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.644]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.644]         }
[17:43:53.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.644]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.644]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.644]             base::names(...future.oldOptions))
[17:43:53.644]     }
[17:43:53.644]     if (FALSE) {
[17:43:53.644]     }
[17:43:53.644]     else {
[17:43:53.644]         if (TRUE) {
[17:43:53.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.644]                 open = "w")
[17:43:53.644]         }
[17:43:53.644]         else {
[17:43:53.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.644]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.644]         }
[17:43:53.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.644]             base::sink(type = "output", split = FALSE)
[17:43:53.644]             base::close(...future.stdout)
[17:43:53.644]         }, add = TRUE)
[17:43:53.644]     }
[17:43:53.644]     ...future.frame <- base::sys.nframe()
[17:43:53.644]     ...future.conditions <- base::list()
[17:43:53.644]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.644]     if (FALSE) {
[17:43:53.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.644]     }
[17:43:53.644]     ...future.result <- base::tryCatch({
[17:43:53.644]         base::withCallingHandlers({
[17:43:53.644]             ...future.value <- base::withVisible(base::local({
[17:43:53.644]                 withCallingHandlers({
[17:43:53.644]                   {
[17:43:53.644]                     do.call(function(...) {
[17:43:53.644]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.644]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.644]                         ...future.globals.maxSize)) {
[17:43:53.644]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.644]                         on.exit(options(oopts), add = TRUE)
[17:43:53.644]                       }
[17:43:53.644]                       {
[17:43:53.644]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.644]                           FUN = function(jj) {
[17:43:53.644]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.644]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.644]                           })
[17:43:53.644]                       }
[17:43:53.644]                     }, args = future.call.arguments)
[17:43:53.644]                   }
[17:43:53.644]                 }, immediateCondition = function(cond) {
[17:43:53.644]                   save_rds <- function (object, pathname, ...) 
[17:43:53.644]                   {
[17:43:53.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.644]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.644]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.644]                         fi_tmp[["mtime"]])
[17:43:53.644]                     }
[17:43:53.644]                     tryCatch({
[17:43:53.644]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.644]                     }, error = function(ex) {
[17:43:53.644]                       msg <- conditionMessage(ex)
[17:43:53.644]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.644]                         fi_tmp[["mtime"]], msg)
[17:43:53.644]                       ex$message <- msg
[17:43:53.644]                       stop(ex)
[17:43:53.644]                     })
[17:43:53.644]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.644]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.644]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.644]                       fi <- file.info(pathname)
[17:43:53.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.644]                         fi[["size"]], fi[["mtime"]])
[17:43:53.644]                       stop(msg)
[17:43:53.644]                     }
[17:43:53.644]                     invisible(pathname)
[17:43:53.644]                   }
[17:43:53.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.644]                     rootPath = tempdir()) 
[17:43:53.644]                   {
[17:43:53.644]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.644]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.644]                       tmpdir = path, fileext = ".rds")
[17:43:53.644]                     save_rds(obj, file)
[17:43:53.644]                   }
[17:43:53.644]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.644]                   {
[17:43:53.644]                     inherits <- base::inherits
[17:43:53.644]                     invokeRestart <- base::invokeRestart
[17:43:53.644]                     is.null <- base::is.null
[17:43:53.644]                     muffled <- FALSE
[17:43:53.644]                     if (inherits(cond, "message")) {
[17:43:53.644]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.644]                       if (muffled) 
[17:43:53.644]                         invokeRestart("muffleMessage")
[17:43:53.644]                     }
[17:43:53.644]                     else if (inherits(cond, "warning")) {
[17:43:53.644]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.644]                       if (muffled) 
[17:43:53.644]                         invokeRestart("muffleWarning")
[17:43:53.644]                     }
[17:43:53.644]                     else if (inherits(cond, "condition")) {
[17:43:53.644]                       if (!is.null(pattern)) {
[17:43:53.644]                         computeRestarts <- base::computeRestarts
[17:43:53.644]                         grepl <- base::grepl
[17:43:53.644]                         restarts <- computeRestarts(cond)
[17:43:53.644]                         for (restart in restarts) {
[17:43:53.644]                           name <- restart$name
[17:43:53.644]                           if (is.null(name)) 
[17:43:53.644]                             next
[17:43:53.644]                           if (!grepl(pattern, name)) 
[17:43:53.644]                             next
[17:43:53.644]                           invokeRestart(restart)
[17:43:53.644]                           muffled <- TRUE
[17:43:53.644]                           break
[17:43:53.644]                         }
[17:43:53.644]                       }
[17:43:53.644]                     }
[17:43:53.644]                     invisible(muffled)
[17:43:53.644]                   }
[17:43:53.644]                   muffleCondition(cond)
[17:43:53.644]                 })
[17:43:53.644]             }))
[17:43:53.644]             future::FutureResult(value = ...future.value$value, 
[17:43:53.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.644]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.644]                     ...future.globalenv.names))
[17:43:53.644]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.644]         }, condition = base::local({
[17:43:53.644]             c <- base::c
[17:43:53.644]             inherits <- base::inherits
[17:43:53.644]             invokeRestart <- base::invokeRestart
[17:43:53.644]             length <- base::length
[17:43:53.644]             list <- base::list
[17:43:53.644]             seq.int <- base::seq.int
[17:43:53.644]             signalCondition <- base::signalCondition
[17:43:53.644]             sys.calls <- base::sys.calls
[17:43:53.644]             `[[` <- base::`[[`
[17:43:53.644]             `+` <- base::`+`
[17:43:53.644]             `<<-` <- base::`<<-`
[17:43:53.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.644]                   3L)]
[17:43:53.644]             }
[17:43:53.644]             function(cond) {
[17:43:53.644]                 is_error <- inherits(cond, "error")
[17:43:53.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.644]                   NULL)
[17:43:53.644]                 if (is_error) {
[17:43:53.644]                   sessionInformation <- function() {
[17:43:53.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.644]                       search = base::search(), system = base::Sys.info())
[17:43:53.644]                   }
[17:43:53.644]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.644]                     cond$call), session = sessionInformation(), 
[17:43:53.644]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.644]                   signalCondition(cond)
[17:43:53.644]                 }
[17:43:53.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.644]                 "immediateCondition"))) {
[17:43:53.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.644]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.644]                   if (TRUE && !signal) {
[17:43:53.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.644]                     {
[17:43:53.644]                       inherits <- base::inherits
[17:43:53.644]                       invokeRestart <- base::invokeRestart
[17:43:53.644]                       is.null <- base::is.null
[17:43:53.644]                       muffled <- FALSE
[17:43:53.644]                       if (inherits(cond, "message")) {
[17:43:53.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.644]                         if (muffled) 
[17:43:53.644]                           invokeRestart("muffleMessage")
[17:43:53.644]                       }
[17:43:53.644]                       else if (inherits(cond, "warning")) {
[17:43:53.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.644]                         if (muffled) 
[17:43:53.644]                           invokeRestart("muffleWarning")
[17:43:53.644]                       }
[17:43:53.644]                       else if (inherits(cond, "condition")) {
[17:43:53.644]                         if (!is.null(pattern)) {
[17:43:53.644]                           computeRestarts <- base::computeRestarts
[17:43:53.644]                           grepl <- base::grepl
[17:43:53.644]                           restarts <- computeRestarts(cond)
[17:43:53.644]                           for (restart in restarts) {
[17:43:53.644]                             name <- restart$name
[17:43:53.644]                             if (is.null(name)) 
[17:43:53.644]                               next
[17:43:53.644]                             if (!grepl(pattern, name)) 
[17:43:53.644]                               next
[17:43:53.644]                             invokeRestart(restart)
[17:43:53.644]                             muffled <- TRUE
[17:43:53.644]                             break
[17:43:53.644]                           }
[17:43:53.644]                         }
[17:43:53.644]                       }
[17:43:53.644]                       invisible(muffled)
[17:43:53.644]                     }
[17:43:53.644]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.644]                   }
[17:43:53.644]                 }
[17:43:53.644]                 else {
[17:43:53.644]                   if (TRUE) {
[17:43:53.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.644]                     {
[17:43:53.644]                       inherits <- base::inherits
[17:43:53.644]                       invokeRestart <- base::invokeRestart
[17:43:53.644]                       is.null <- base::is.null
[17:43:53.644]                       muffled <- FALSE
[17:43:53.644]                       if (inherits(cond, "message")) {
[17:43:53.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.644]                         if (muffled) 
[17:43:53.644]                           invokeRestart("muffleMessage")
[17:43:53.644]                       }
[17:43:53.644]                       else if (inherits(cond, "warning")) {
[17:43:53.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.644]                         if (muffled) 
[17:43:53.644]                           invokeRestart("muffleWarning")
[17:43:53.644]                       }
[17:43:53.644]                       else if (inherits(cond, "condition")) {
[17:43:53.644]                         if (!is.null(pattern)) {
[17:43:53.644]                           computeRestarts <- base::computeRestarts
[17:43:53.644]                           grepl <- base::grepl
[17:43:53.644]                           restarts <- computeRestarts(cond)
[17:43:53.644]                           for (restart in restarts) {
[17:43:53.644]                             name <- restart$name
[17:43:53.644]                             if (is.null(name)) 
[17:43:53.644]                               next
[17:43:53.644]                             if (!grepl(pattern, name)) 
[17:43:53.644]                               next
[17:43:53.644]                             invokeRestart(restart)
[17:43:53.644]                             muffled <- TRUE
[17:43:53.644]                             break
[17:43:53.644]                           }
[17:43:53.644]                         }
[17:43:53.644]                       }
[17:43:53.644]                       invisible(muffled)
[17:43:53.644]                     }
[17:43:53.644]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.644]                   }
[17:43:53.644]                 }
[17:43:53.644]             }
[17:43:53.644]         }))
[17:43:53.644]     }, error = function(ex) {
[17:43:53.644]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.644]                 ...future.rng), started = ...future.startTime, 
[17:43:53.644]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.644]             version = "1.8"), class = "FutureResult")
[17:43:53.644]     }, finally = {
[17:43:53.644]         if (!identical(...future.workdir, getwd())) 
[17:43:53.644]             setwd(...future.workdir)
[17:43:53.644]         {
[17:43:53.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.644]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.644]             }
[17:43:53.644]             base::options(...future.oldOptions)
[17:43:53.644]             if (.Platform$OS.type == "windows") {
[17:43:53.644]                 old_names <- names(...future.oldEnvVars)
[17:43:53.644]                 envs <- base::Sys.getenv()
[17:43:53.644]                 names <- names(envs)
[17:43:53.644]                 common <- intersect(names, old_names)
[17:43:53.644]                 added <- setdiff(names, old_names)
[17:43:53.644]                 removed <- setdiff(old_names, names)
[17:43:53.644]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.644]                   envs[common]]
[17:43:53.644]                 NAMES <- toupper(changed)
[17:43:53.644]                 args <- list()
[17:43:53.644]                 for (kk in seq_along(NAMES)) {
[17:43:53.644]                   name <- changed[[kk]]
[17:43:53.644]                   NAME <- NAMES[[kk]]
[17:43:53.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.644]                     next
[17:43:53.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.644]                 }
[17:43:53.644]                 NAMES <- toupper(added)
[17:43:53.644]                 for (kk in seq_along(NAMES)) {
[17:43:53.644]                   name <- added[[kk]]
[17:43:53.644]                   NAME <- NAMES[[kk]]
[17:43:53.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.644]                     next
[17:43:53.644]                   args[[name]] <- ""
[17:43:53.644]                 }
[17:43:53.644]                 NAMES <- toupper(removed)
[17:43:53.644]                 for (kk in seq_along(NAMES)) {
[17:43:53.644]                   name <- removed[[kk]]
[17:43:53.644]                   NAME <- NAMES[[kk]]
[17:43:53.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.644]                     next
[17:43:53.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.644]                 }
[17:43:53.644]                 if (length(args) > 0) 
[17:43:53.644]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.644]             }
[17:43:53.644]             else {
[17:43:53.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.644]             }
[17:43:53.644]             {
[17:43:53.644]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.644]                   0L) {
[17:43:53.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.644]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.644]                   base::options(opts)
[17:43:53.644]                 }
[17:43:53.644]                 {
[17:43:53.644]                   {
[17:43:53.644]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.644]                     NULL
[17:43:53.644]                   }
[17:43:53.644]                   options(future.plan = NULL)
[17:43:53.644]                   if (is.na(NA_character_)) 
[17:43:53.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.644]                     .init = FALSE)
[17:43:53.644]                 }
[17:43:53.644]             }
[17:43:53.644]         }
[17:43:53.644]     })
[17:43:53.644]     if (TRUE) {
[17:43:53.644]         base::sink(type = "output", split = FALSE)
[17:43:53.644]         if (TRUE) {
[17:43:53.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.644]         }
[17:43:53.644]         else {
[17:43:53.644]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.644]         }
[17:43:53.644]         base::close(...future.stdout)
[17:43:53.644]         ...future.stdout <- NULL
[17:43:53.644]     }
[17:43:53.644]     ...future.result$conditions <- ...future.conditions
[17:43:53.644]     ...future.result$finished <- base::Sys.time()
[17:43:53.644]     ...future.result
[17:43:53.644] }
[17:43:53.646] assign_globals() ...
[17:43:53.646] List of 5
[17:43:53.646]  $ ...future.FUN            :function (object, ...)  
[17:43:53.646]  $ future.call.arguments    : list()
[17:43:53.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.646]  $ ...future.elements_ii    :List of 1
[17:43:53.646]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.646]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.646]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.646]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.646]  $ ...future.seeds_ii       : NULL
[17:43:53.646]  $ ...future.globals.maxSize: NULL
[17:43:53.646]  - attr(*, "where")=List of 5
[17:43:53.646]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.646]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.646]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.646]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.646]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.646]  - attr(*, "resolved")= logi FALSE
[17:43:53.646]  - attr(*, "total_size")= num 1240
[17:43:53.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.646]  - attr(*, "already-done")= logi TRUE
[17:43:53.652] - copied ‘...future.FUN’ to environment
[17:43:53.652] - copied ‘future.call.arguments’ to environment
[17:43:53.652] - copied ‘...future.elements_ii’ to environment
[17:43:53.652] - copied ‘...future.seeds_ii’ to environment
[17:43:53.653] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.653] assign_globals() ... done
[17:43:53.653] requestCore(): workers = 2
[17:43:53.655] MulticoreFuture started
[17:43:53.655] - Launch lazy future ... done
[17:43:53.655] run() for ‘MulticoreFuture’ ... done
[17:43:53.655] Created future:
[17:43:53.656] plan(): Setting new future strategy stack:
[17:43:53.656] List of future strategies:
[17:43:53.656] 1. sequential:
[17:43:53.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.656]    - tweaked: FALSE
[17:43:53.656]    - call: NULL
[17:43:53.657] plan(): nbrOfWorkers() = 1
[17:43:53.660] plan(): Setting new future strategy stack:
[17:43:53.661] List of future strategies:
[17:43:53.661] 1. multicore:
[17:43:53.661]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.661]    - tweaked: FALSE
[17:43:53.661]    - call: plan(strategy)
[17:43:53.665] plan(): nbrOfWorkers() = 2
[17:43:53.656] MulticoreFuture:
[17:43:53.656] Label: ‘future_by-1’
[17:43:53.656] Expression:
[17:43:53.656] {
[17:43:53.656]     do.call(function(...) {
[17:43:53.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.656]             on.exit(options(oopts), add = TRUE)
[17:43:53.656]         }
[17:43:53.656]         {
[17:43:53.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.656]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.656]             })
[17:43:53.656]         }
[17:43:53.656]     }, args = future.call.arguments)
[17:43:53.656] }
[17:43:53.656] Lazy evaluation: FALSE
[17:43:53.656] Asynchronous evaluation: TRUE
[17:43:53.656] Local evaluation: TRUE
[17:43:53.656] Environment: 0x55d6bb126178
[17:43:53.656] Capture standard output: TRUE
[17:43:53.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.656] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.656] Packages: <none>
[17:43:53.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.656] Resolved: TRUE
[17:43:53.656] Value: <not collected>
[17:43:53.656] Conditions captured: <none>
[17:43:53.656] Early signaling: FALSE
[17:43:53.656] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.656] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.666] Chunk #1 of 2 ... DONE
[17:43:53.667] Chunk #2 of 2 ...
[17:43:53.667]  - Finding globals in 'X' for chunk #2 ...
[17:43:53.667] getGlobalsAndPackages() ...
[17:43:53.667] Searching for globals...
[17:43:53.668] 
[17:43:53.668] Searching for globals ... DONE
[17:43:53.668] - globals: [0] <none>
[17:43:53.668] getGlobalsAndPackages() ... DONE
[17:43:53.668]    + additional globals found: [n=0] 
[17:43:53.668]    + additional namespaces needed: [n=0] 
[17:43:53.669]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:53.669]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.669]  - seeds: <none>
[17:43:53.669]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.669] getGlobalsAndPackages() ...
[17:43:53.669] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.669] Resolving globals: FALSE
[17:43:53.670] Tweak future expression to call with '...' arguments ...
[17:43:53.670] {
[17:43:53.670]     do.call(function(...) {
[17:43:53.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.670]             on.exit(options(oopts), add = TRUE)
[17:43:53.670]         }
[17:43:53.670]         {
[17:43:53.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.670]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.670]             })
[17:43:53.670]         }
[17:43:53.670]     }, args = future.call.arguments)
[17:43:53.670] }
[17:43:53.670] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.671] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.674] 
[17:43:53.675] getGlobalsAndPackages() ... DONE
[17:43:53.676] run() for ‘Future’ ...
[17:43:53.676] - state: ‘created’
[17:43:53.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.683] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.683]   - Field: ‘label’
[17:43:53.683]   - Field: ‘local’
[17:43:53.684]   - Field: ‘owner’
[17:43:53.684]   - Field: ‘envir’
[17:43:53.684]   - Field: ‘workers’
[17:43:53.684]   - Field: ‘packages’
[17:43:53.685]   - Field: ‘gc’
[17:43:53.685]   - Field: ‘job’
[17:43:53.685]   - Field: ‘conditions’
[17:43:53.685]   - Field: ‘expr’
[17:43:53.685]   - Field: ‘uuid’
[17:43:53.686]   - Field: ‘seed’
[17:43:53.686]   - Field: ‘version’
[17:43:53.686]   - Field: ‘result’
[17:43:53.686]   - Field: ‘asynchronous’
[17:43:53.687]   - Field: ‘calls’
[17:43:53.687]   - Field: ‘globals’
[17:43:53.687]   - Field: ‘stdout’
[17:43:53.687]   - Field: ‘earlySignal’
[17:43:53.687]   - Field: ‘lazy’
[17:43:53.687]   - Field: ‘state’
[17:43:53.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.688] - Launch lazy future ...
[17:43:53.688] Packages needed by the future expression (n = 0): <none>
[17:43:53.688] Packages needed by future strategies (n = 0): <none>
[17:43:53.689] {
[17:43:53.689]     {
[17:43:53.689]         {
[17:43:53.689]             ...future.startTime <- base::Sys.time()
[17:43:53.689]             {
[17:43:53.689]                 {
[17:43:53.689]                   {
[17:43:53.689]                     {
[17:43:53.689]                       base::local({
[17:43:53.689]                         has_future <- base::requireNamespace("future", 
[17:43:53.689]                           quietly = TRUE)
[17:43:53.689]                         if (has_future) {
[17:43:53.689]                           ns <- base::getNamespace("future")
[17:43:53.689]                           version <- ns[[".package"]][["version"]]
[17:43:53.689]                           if (is.null(version)) 
[17:43:53.689]                             version <- utils::packageVersion("future")
[17:43:53.689]                         }
[17:43:53.689]                         else {
[17:43:53.689]                           version <- NULL
[17:43:53.689]                         }
[17:43:53.689]                         if (!has_future || version < "1.8.0") {
[17:43:53.689]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.689]                             "", base::R.version$version.string), 
[17:43:53.689]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.689]                               "release", "version")], collapse = " "), 
[17:43:53.689]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.689]                             info)
[17:43:53.689]                           info <- base::paste(info, collapse = "; ")
[17:43:53.689]                           if (!has_future) {
[17:43:53.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.689]                               info)
[17:43:53.689]                           }
[17:43:53.689]                           else {
[17:43:53.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.689]                               info, version)
[17:43:53.689]                           }
[17:43:53.689]                           base::stop(msg)
[17:43:53.689]                         }
[17:43:53.689]                       })
[17:43:53.689]                     }
[17:43:53.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.689]                     base::options(mc.cores = 1L)
[17:43:53.689]                   }
[17:43:53.689]                   ...future.strategy.old <- future::plan("list")
[17:43:53.689]                   options(future.plan = NULL)
[17:43:53.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.689]                 }
[17:43:53.689]                 ...future.workdir <- getwd()
[17:43:53.689]             }
[17:43:53.689]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.689]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.689]         }
[17:43:53.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.689]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.689]             base::names(...future.oldOptions))
[17:43:53.689]     }
[17:43:53.689]     if (FALSE) {
[17:43:53.689]     }
[17:43:53.689]     else {
[17:43:53.689]         if (TRUE) {
[17:43:53.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.689]                 open = "w")
[17:43:53.689]         }
[17:43:53.689]         else {
[17:43:53.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.689]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.689]         }
[17:43:53.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.689]             base::sink(type = "output", split = FALSE)
[17:43:53.689]             base::close(...future.stdout)
[17:43:53.689]         }, add = TRUE)
[17:43:53.689]     }
[17:43:53.689]     ...future.frame <- base::sys.nframe()
[17:43:53.689]     ...future.conditions <- base::list()
[17:43:53.689]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.689]     if (FALSE) {
[17:43:53.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.689]     }
[17:43:53.689]     ...future.result <- base::tryCatch({
[17:43:53.689]         base::withCallingHandlers({
[17:43:53.689]             ...future.value <- base::withVisible(base::local({
[17:43:53.689]                 withCallingHandlers({
[17:43:53.689]                   {
[17:43:53.689]                     do.call(function(...) {
[17:43:53.689]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.689]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.689]                         ...future.globals.maxSize)) {
[17:43:53.689]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.689]                         on.exit(options(oopts), add = TRUE)
[17:43:53.689]                       }
[17:43:53.689]                       {
[17:43:53.689]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.689]                           FUN = function(jj) {
[17:43:53.689]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.689]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.689]                           })
[17:43:53.689]                       }
[17:43:53.689]                     }, args = future.call.arguments)
[17:43:53.689]                   }
[17:43:53.689]                 }, immediateCondition = function(cond) {
[17:43:53.689]                   save_rds <- function (object, pathname, ...) 
[17:43:53.689]                   {
[17:43:53.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.689]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.689]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.689]                         fi_tmp[["mtime"]])
[17:43:53.689]                     }
[17:43:53.689]                     tryCatch({
[17:43:53.689]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.689]                     }, error = function(ex) {
[17:43:53.689]                       msg <- conditionMessage(ex)
[17:43:53.689]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.689]                         fi_tmp[["mtime"]], msg)
[17:43:53.689]                       ex$message <- msg
[17:43:53.689]                       stop(ex)
[17:43:53.689]                     })
[17:43:53.689]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.689]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.689]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.689]                       fi <- file.info(pathname)
[17:43:53.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.689]                         fi[["size"]], fi[["mtime"]])
[17:43:53.689]                       stop(msg)
[17:43:53.689]                     }
[17:43:53.689]                     invisible(pathname)
[17:43:53.689]                   }
[17:43:53.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.689]                     rootPath = tempdir()) 
[17:43:53.689]                   {
[17:43:53.689]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.689]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.689]                       tmpdir = path, fileext = ".rds")
[17:43:53.689]                     save_rds(obj, file)
[17:43:53.689]                   }
[17:43:53.689]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.689]                   {
[17:43:53.689]                     inherits <- base::inherits
[17:43:53.689]                     invokeRestart <- base::invokeRestart
[17:43:53.689]                     is.null <- base::is.null
[17:43:53.689]                     muffled <- FALSE
[17:43:53.689]                     if (inherits(cond, "message")) {
[17:43:53.689]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.689]                       if (muffled) 
[17:43:53.689]                         invokeRestart("muffleMessage")
[17:43:53.689]                     }
[17:43:53.689]                     else if (inherits(cond, "warning")) {
[17:43:53.689]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.689]                       if (muffled) 
[17:43:53.689]                         invokeRestart("muffleWarning")
[17:43:53.689]                     }
[17:43:53.689]                     else if (inherits(cond, "condition")) {
[17:43:53.689]                       if (!is.null(pattern)) {
[17:43:53.689]                         computeRestarts <- base::computeRestarts
[17:43:53.689]                         grepl <- base::grepl
[17:43:53.689]                         restarts <- computeRestarts(cond)
[17:43:53.689]                         for (restart in restarts) {
[17:43:53.689]                           name <- restart$name
[17:43:53.689]                           if (is.null(name)) 
[17:43:53.689]                             next
[17:43:53.689]                           if (!grepl(pattern, name)) 
[17:43:53.689]                             next
[17:43:53.689]                           invokeRestart(restart)
[17:43:53.689]                           muffled <- TRUE
[17:43:53.689]                           break
[17:43:53.689]                         }
[17:43:53.689]                       }
[17:43:53.689]                     }
[17:43:53.689]                     invisible(muffled)
[17:43:53.689]                   }
[17:43:53.689]                   muffleCondition(cond)
[17:43:53.689]                 })
[17:43:53.689]             }))
[17:43:53.689]             future::FutureResult(value = ...future.value$value, 
[17:43:53.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.689]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.689]                     ...future.globalenv.names))
[17:43:53.689]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.689]         }, condition = base::local({
[17:43:53.689]             c <- base::c
[17:43:53.689]             inherits <- base::inherits
[17:43:53.689]             invokeRestart <- base::invokeRestart
[17:43:53.689]             length <- base::length
[17:43:53.689]             list <- base::list
[17:43:53.689]             seq.int <- base::seq.int
[17:43:53.689]             signalCondition <- base::signalCondition
[17:43:53.689]             sys.calls <- base::sys.calls
[17:43:53.689]             `[[` <- base::`[[`
[17:43:53.689]             `+` <- base::`+`
[17:43:53.689]             `<<-` <- base::`<<-`
[17:43:53.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.689]                   3L)]
[17:43:53.689]             }
[17:43:53.689]             function(cond) {
[17:43:53.689]                 is_error <- inherits(cond, "error")
[17:43:53.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.689]                   NULL)
[17:43:53.689]                 if (is_error) {
[17:43:53.689]                   sessionInformation <- function() {
[17:43:53.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.689]                       search = base::search(), system = base::Sys.info())
[17:43:53.689]                   }
[17:43:53.689]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.689]                     cond$call), session = sessionInformation(), 
[17:43:53.689]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.689]                   signalCondition(cond)
[17:43:53.689]                 }
[17:43:53.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.689]                 "immediateCondition"))) {
[17:43:53.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.689]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.689]                   if (TRUE && !signal) {
[17:43:53.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.689]                     {
[17:43:53.689]                       inherits <- base::inherits
[17:43:53.689]                       invokeRestart <- base::invokeRestart
[17:43:53.689]                       is.null <- base::is.null
[17:43:53.689]                       muffled <- FALSE
[17:43:53.689]                       if (inherits(cond, "message")) {
[17:43:53.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.689]                         if (muffled) 
[17:43:53.689]                           invokeRestart("muffleMessage")
[17:43:53.689]                       }
[17:43:53.689]                       else if (inherits(cond, "warning")) {
[17:43:53.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.689]                         if (muffled) 
[17:43:53.689]                           invokeRestart("muffleWarning")
[17:43:53.689]                       }
[17:43:53.689]                       else if (inherits(cond, "condition")) {
[17:43:53.689]                         if (!is.null(pattern)) {
[17:43:53.689]                           computeRestarts <- base::computeRestarts
[17:43:53.689]                           grepl <- base::grepl
[17:43:53.689]                           restarts <- computeRestarts(cond)
[17:43:53.689]                           for (restart in restarts) {
[17:43:53.689]                             name <- restart$name
[17:43:53.689]                             if (is.null(name)) 
[17:43:53.689]                               next
[17:43:53.689]                             if (!grepl(pattern, name)) 
[17:43:53.689]                               next
[17:43:53.689]                             invokeRestart(restart)
[17:43:53.689]                             muffled <- TRUE
[17:43:53.689]                             break
[17:43:53.689]                           }
[17:43:53.689]                         }
[17:43:53.689]                       }
[17:43:53.689]                       invisible(muffled)
[17:43:53.689]                     }
[17:43:53.689]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.689]                   }
[17:43:53.689]                 }
[17:43:53.689]                 else {
[17:43:53.689]                   if (TRUE) {
[17:43:53.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.689]                     {
[17:43:53.689]                       inherits <- base::inherits
[17:43:53.689]                       invokeRestart <- base::invokeRestart
[17:43:53.689]                       is.null <- base::is.null
[17:43:53.689]                       muffled <- FALSE
[17:43:53.689]                       if (inherits(cond, "message")) {
[17:43:53.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.689]                         if (muffled) 
[17:43:53.689]                           invokeRestart("muffleMessage")
[17:43:53.689]                       }
[17:43:53.689]                       else if (inherits(cond, "warning")) {
[17:43:53.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.689]                         if (muffled) 
[17:43:53.689]                           invokeRestart("muffleWarning")
[17:43:53.689]                       }
[17:43:53.689]                       else if (inherits(cond, "condition")) {
[17:43:53.689]                         if (!is.null(pattern)) {
[17:43:53.689]                           computeRestarts <- base::computeRestarts
[17:43:53.689]                           grepl <- base::grepl
[17:43:53.689]                           restarts <- computeRestarts(cond)
[17:43:53.689]                           for (restart in restarts) {
[17:43:53.689]                             name <- restart$name
[17:43:53.689]                             if (is.null(name)) 
[17:43:53.689]                               next
[17:43:53.689]                             if (!grepl(pattern, name)) 
[17:43:53.689]                               next
[17:43:53.689]                             invokeRestart(restart)
[17:43:53.689]                             muffled <- TRUE
[17:43:53.689]                             break
[17:43:53.689]                           }
[17:43:53.689]                         }
[17:43:53.689]                       }
[17:43:53.689]                       invisible(muffled)
[17:43:53.689]                     }
[17:43:53.689]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.689]                   }
[17:43:53.689]                 }
[17:43:53.689]             }
[17:43:53.689]         }))
[17:43:53.689]     }, error = function(ex) {
[17:43:53.689]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.689]                 ...future.rng), started = ...future.startTime, 
[17:43:53.689]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.689]             version = "1.8"), class = "FutureResult")
[17:43:53.689]     }, finally = {
[17:43:53.689]         if (!identical(...future.workdir, getwd())) 
[17:43:53.689]             setwd(...future.workdir)
[17:43:53.689]         {
[17:43:53.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.689]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.689]             }
[17:43:53.689]             base::options(...future.oldOptions)
[17:43:53.689]             if (.Platform$OS.type == "windows") {
[17:43:53.689]                 old_names <- names(...future.oldEnvVars)
[17:43:53.689]                 envs <- base::Sys.getenv()
[17:43:53.689]                 names <- names(envs)
[17:43:53.689]                 common <- intersect(names, old_names)
[17:43:53.689]                 added <- setdiff(names, old_names)
[17:43:53.689]                 removed <- setdiff(old_names, names)
[17:43:53.689]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.689]                   envs[common]]
[17:43:53.689]                 NAMES <- toupper(changed)
[17:43:53.689]                 args <- list()
[17:43:53.689]                 for (kk in seq_along(NAMES)) {
[17:43:53.689]                   name <- changed[[kk]]
[17:43:53.689]                   NAME <- NAMES[[kk]]
[17:43:53.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.689]                     next
[17:43:53.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.689]                 }
[17:43:53.689]                 NAMES <- toupper(added)
[17:43:53.689]                 for (kk in seq_along(NAMES)) {
[17:43:53.689]                   name <- added[[kk]]
[17:43:53.689]                   NAME <- NAMES[[kk]]
[17:43:53.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.689]                     next
[17:43:53.689]                   args[[name]] <- ""
[17:43:53.689]                 }
[17:43:53.689]                 NAMES <- toupper(removed)
[17:43:53.689]                 for (kk in seq_along(NAMES)) {
[17:43:53.689]                   name <- removed[[kk]]
[17:43:53.689]                   NAME <- NAMES[[kk]]
[17:43:53.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.689]                     next
[17:43:53.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.689]                 }
[17:43:53.689]                 if (length(args) > 0) 
[17:43:53.689]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.689]             }
[17:43:53.689]             else {
[17:43:53.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.689]             }
[17:43:53.689]             {
[17:43:53.689]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.689]                   0L) {
[17:43:53.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.689]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.689]                   base::options(opts)
[17:43:53.689]                 }
[17:43:53.689]                 {
[17:43:53.689]                   {
[17:43:53.689]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.689]                     NULL
[17:43:53.689]                   }
[17:43:53.689]                   options(future.plan = NULL)
[17:43:53.689]                   if (is.na(NA_character_)) 
[17:43:53.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.689]                     .init = FALSE)
[17:43:53.689]                 }
[17:43:53.689]             }
[17:43:53.689]         }
[17:43:53.689]     })
[17:43:53.689]     if (TRUE) {
[17:43:53.689]         base::sink(type = "output", split = FALSE)
[17:43:53.689]         if (TRUE) {
[17:43:53.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.689]         }
[17:43:53.689]         else {
[17:43:53.689]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.689]         }
[17:43:53.689]         base::close(...future.stdout)
[17:43:53.689]         ...future.stdout <- NULL
[17:43:53.689]     }
[17:43:53.689]     ...future.result$conditions <- ...future.conditions
[17:43:53.689]     ...future.result$finished <- base::Sys.time()
[17:43:53.689]     ...future.result
[17:43:53.689] }
[17:43:53.692] assign_globals() ...
[17:43:53.692] List of 5
[17:43:53.692]  $ ...future.FUN            :function (object, ...)  
[17:43:53.692]  $ future.call.arguments    : list()
[17:43:53.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.692]  $ ...future.elements_ii    :List of 2
[17:43:53.692]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.692]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.692]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.692]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:53.692]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.692]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.692]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.692]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:53.692]  $ ...future.seeds_ii       : NULL
[17:43:53.692]  $ ...future.globals.maxSize: NULL
[17:43:53.692]  - attr(*, "where")=List of 5
[17:43:53.692]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.692]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.692]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.692]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.692]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.692]  - attr(*, "resolved")= logi FALSE
[17:43:53.692]  - attr(*, "total_size")= num 1240
[17:43:53.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.692]  - attr(*, "already-done")= logi TRUE
[17:43:53.701] - copied ‘...future.FUN’ to environment
[17:43:53.701] - copied ‘future.call.arguments’ to environment
[17:43:53.701] - copied ‘...future.elements_ii’ to environment
[17:43:53.702] - copied ‘...future.seeds_ii’ to environment
[17:43:53.702] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.702] assign_globals() ... done
[17:43:53.702] requestCore(): workers = 2
[17:43:53.704] MulticoreFuture started
[17:43:53.704] - Launch lazy future ... done
[17:43:53.704] run() for ‘MulticoreFuture’ ... done
[17:43:53.705] Created future:
[17:43:53.705] plan(): Setting new future strategy stack:
[17:43:53.705] List of future strategies:
[17:43:53.705] 1. sequential:
[17:43:53.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.705]    - tweaked: FALSE
[17:43:53.705]    - call: NULL
[17:43:53.706] plan(): nbrOfWorkers() = 1
[17:43:53.710] plan(): Setting new future strategy stack:
[17:43:53.710] List of future strategies:
[17:43:53.710] 1. multicore:
[17:43:53.710]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.710]    - tweaked: FALSE
[17:43:53.710]    - call: plan(strategy)
[17:43:53.705] MulticoreFuture:
[17:43:53.705] Label: ‘future_by-2’
[17:43:53.705] Expression:
[17:43:53.705] {
[17:43:53.705]     do.call(function(...) {
[17:43:53.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.705]             on.exit(options(oopts), add = TRUE)
[17:43:53.705]         }
[17:43:53.705]         {
[17:43:53.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.705]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.705]             })
[17:43:53.705]         }
[17:43:53.705]     }, args = future.call.arguments)
[17:43:53.705] }
[17:43:53.705] Lazy evaluation: FALSE
[17:43:53.705] Asynchronous evaluation: TRUE
[17:43:53.705] Local evaluation: TRUE
[17:43:53.705] Environment: 0x55d6bb126178
[17:43:53.705] Capture standard output: TRUE
[17:43:53.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.705] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.705] Packages: <none>
[17:43:53.705] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.705] Resolved: FALSE
[17:43:53.705] Value: <not collected>
[17:43:53.705] Conditions captured: <none>
[17:43:53.705] Early signaling: FALSE
[17:43:53.705] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.705] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.718] Chunk #2 of 2 ... DONE
[17:43:53.718] Launching 2 futures (chunks) ... DONE
[17:43:53.718] Resolving 2 futures (chunks) ...
[17:43:53.719] resolve() on list ...
[17:43:53.719]  recursive: 0
[17:43:53.719]  length: 2
[17:43:53.719] 
[17:43:53.719] plan(): nbrOfWorkers() = 2
[17:43:53.719] Future #1
[17:43:53.720] result() for MulticoreFuture ...
[17:43:53.720] result() for MulticoreFuture ...
[17:43:53.721] result() for MulticoreFuture ... done
[17:43:53.721] result() for MulticoreFuture ... done
[17:43:53.721] result() for MulticoreFuture ...
[17:43:53.721] result() for MulticoreFuture ... done
[17:43:53.721] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:53.721] - nx: 2
[17:43:53.721] - relay: TRUE
[17:43:53.722] - stdout: TRUE
[17:43:53.724] - signal: TRUE
[17:43:53.724] - resignal: FALSE
[17:43:53.724] - force: TRUE
[17:43:53.725] - relayed: [n=2] FALSE, FALSE
[17:43:53.725] - queued futures: [n=2] FALSE, FALSE
[17:43:53.725]  - until=1
[17:43:53.726]  - relaying element #1
[17:43:53.726] result() for MulticoreFuture ...
[17:43:53.726] result() for MulticoreFuture ... done
[17:43:53.727] result() for MulticoreFuture ...
[17:43:53.727] result() for MulticoreFuture ... done
[17:43:53.727] result() for MulticoreFuture ...
[17:43:53.728] result() for MulticoreFuture ... done
[17:43:53.728] result() for MulticoreFuture ...
[17:43:53.728] result() for MulticoreFuture ... done
[17:43:53.728] - relayed: [n=2] TRUE, FALSE
[17:43:53.728] - queued futures: [n=2] TRUE, FALSE
[17:43:53.729] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:53.729]  length: 1 (resolved future 1)
[17:43:53.729] Future #2
[17:43:53.730] result() for MulticoreFuture ...
[17:43:53.731] result() for MulticoreFuture ...
[17:43:53.731] result() for MulticoreFuture ... done
[17:43:53.731] result() for MulticoreFuture ... done
[17:43:53.731] result() for MulticoreFuture ...
[17:43:53.732] result() for MulticoreFuture ... done
[17:43:53.732] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:53.732] - nx: 2
[17:43:53.732] - relay: TRUE
[17:43:53.732] - stdout: TRUE
[17:43:53.732] - signal: TRUE
[17:43:53.733] - resignal: FALSE
[17:43:53.733] - force: TRUE
[17:43:53.733] - relayed: [n=2] TRUE, FALSE
[17:43:53.733] - queued futures: [n=2] TRUE, FALSE
[17:43:53.733]  - until=2
[17:43:53.733]  - relaying element #2
[17:43:53.733] result() for MulticoreFuture ...
[17:43:53.733] result() for MulticoreFuture ... done
[17:43:53.734] result() for MulticoreFuture ...
[17:43:53.734] result() for MulticoreFuture ... done
[17:43:53.734] result() for MulticoreFuture ...
[17:43:53.734] result() for MulticoreFuture ... done
[17:43:53.734] result() for MulticoreFuture ...
[17:43:53.734] result() for MulticoreFuture ... done
[17:43:53.734] - relayed: [n=2] TRUE, TRUE
[17:43:53.734] - queued futures: [n=2] TRUE, TRUE
[17:43:53.735] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:53.735]  length: 0 (resolved future 2)
[17:43:53.735] Relaying remaining futures
[17:43:53.735] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.735] - nx: 2
[17:43:53.735] - relay: TRUE
[17:43:53.735] - stdout: TRUE
[17:43:53.735] - signal: TRUE
[17:43:53.736] - resignal: FALSE
[17:43:53.736] - force: TRUE
[17:43:53.736] - relayed: [n=2] TRUE, TRUE
[17:43:53.736] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:53.736] - relayed: [n=2] TRUE, TRUE
[17:43:53.736] - queued futures: [n=2] TRUE, TRUE
[17:43:53.736] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.736] resolve() on list ... DONE
[17:43:53.736] result() for MulticoreFuture ...
[17:43:53.736] result() for MulticoreFuture ... done
[17:43:53.737] result() for MulticoreFuture ...
[17:43:53.737] result() for MulticoreFuture ... done
[17:43:53.737] result() for MulticoreFuture ...
[17:43:53.737] result() for MulticoreFuture ... done
[17:43:53.737] result() for MulticoreFuture ...
[17:43:53.737] result() for MulticoreFuture ... done
[17:43:53.737]  - Number of value chunks collected: 2
[17:43:53.737] Resolving 2 futures (chunks) ... DONE
[17:43:53.737] Reducing values from 2 chunks ...
[17:43:53.738]  - Number of values collected after concatenation: 3
[17:43:53.738]  - Number of values expected: 3
[17:43:53.738] Reducing values from 2 chunks ... DONE
[17:43:53.738] future_lapply() ... DONE
[17:43:53.738] future_by_internal() ... DONE
[17:43:53.739] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:43:53.740] future_lapply() ...
[17:43:53.744] Number of chunks: 2
[17:43:53.744] getGlobalsAndPackagesXApply() ...
[17:43:53.744]  - future.globals: TRUE
[17:43:53.744] getGlobalsAndPackages() ...
[17:43:53.744] Searching for globals...
[17:43:53.745] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:53.746] Searching for globals ... DONE
[17:43:53.746] Resolving globals: FALSE
[17:43:53.746] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:53.746] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:53.747] - globals: [1] ‘FUN’
[17:43:53.747] 
[17:43:53.747] getGlobalsAndPackages() ... DONE
[17:43:53.747]  - globals found/used: [n=1] ‘FUN’
[17:43:53.747]  - needed namespaces: [n=0] 
[17:43:53.747] Finding globals ... DONE
[17:43:53.747]  - use_args: TRUE
[17:43:53.747]  - Getting '...' globals ...
[17:43:53.748] resolve() on list ...
[17:43:53.748]  recursive: 0
[17:43:53.748]  length: 1
[17:43:53.748]  elements: ‘...’
[17:43:53.748]  length: 0 (resolved future 1)
[17:43:53.748] resolve() on list ... DONE
[17:43:53.748]    - '...' content: [n=0] 
[17:43:53.748] List of 1
[17:43:53.748]  $ ...: list()
[17:43:53.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.748]  - attr(*, "where")=List of 1
[17:43:53.748]   ..$ ...:<environment: 0x55d6b8ebdcd8> 
[17:43:53.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.748]  - attr(*, "resolved")= logi TRUE
[17:43:53.748]  - attr(*, "total_size")= num NA
[17:43:53.753]  - Getting '...' globals ... DONE
[17:43:53.753] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:53.753] List of 2
[17:43:53.753]  $ ...future.FUN:function (object, ...)  
[17:43:53.753]  $ ...          : list()
[17:43:53.753]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.753]  - attr(*, "where")=List of 2
[17:43:53.753]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:53.753]   ..$ ...          :<environment: 0x55d6b8ebdcd8> 
[17:43:53.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.753]  - attr(*, "resolved")= logi FALSE
[17:43:53.753]  - attr(*, "total_size")= num 1240
[17:43:53.756] Packages to be attached in all futures: [n=0] 
[17:43:53.756] getGlobalsAndPackagesXApply() ... DONE
[17:43:53.756] Number of futures (= number of chunks): 2
[17:43:53.756] Launching 2 futures (chunks) ...
[17:43:53.756] Chunk #1 of 2 ...
[17:43:53.757]  - Finding globals in 'X' for chunk #1 ...
[17:43:53.757] getGlobalsAndPackages() ...
[17:43:53.757] Searching for globals...
[17:43:53.757] 
[17:43:53.757] Searching for globals ... DONE
[17:43:53.757] - globals: [0] <none>
[17:43:53.757] getGlobalsAndPackages() ... DONE
[17:43:53.757]    + additional globals found: [n=0] 
[17:43:53.758]    + additional namespaces needed: [n=0] 
[17:43:53.758]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:53.758]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.758]  - seeds: <none>
[17:43:53.758]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.758] getGlobalsAndPackages() ...
[17:43:53.758] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.758] Resolving globals: FALSE
[17:43:53.758] Tweak future expression to call with '...' arguments ...
[17:43:53.759] {
[17:43:53.759]     do.call(function(...) {
[17:43:53.759]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.759]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.759]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.759]             on.exit(options(oopts), add = TRUE)
[17:43:53.759]         }
[17:43:53.759]         {
[17:43:53.759]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.759]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.759]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.759]             })
[17:43:53.759]         }
[17:43:53.759]     }, args = future.call.arguments)
[17:43:53.759] }
[17:43:53.759] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.759] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.759] 
[17:43:53.759] getGlobalsAndPackages() ... DONE
[17:43:53.760] run() for ‘Future’ ...
[17:43:53.760] - state: ‘created’
[17:43:53.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.763] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.764]   - Field: ‘label’
[17:43:53.764]   - Field: ‘local’
[17:43:53.764]   - Field: ‘owner’
[17:43:53.764]   - Field: ‘envir’
[17:43:53.764]   - Field: ‘workers’
[17:43:53.764]   - Field: ‘packages’
[17:43:53.764]   - Field: ‘gc’
[17:43:53.764]   - Field: ‘job’
[17:43:53.764]   - Field: ‘conditions’
[17:43:53.764]   - Field: ‘expr’
[17:43:53.764]   - Field: ‘uuid’
[17:43:53.765]   - Field: ‘seed’
[17:43:53.765]   - Field: ‘version’
[17:43:53.765]   - Field: ‘result’
[17:43:53.765]   - Field: ‘asynchronous’
[17:43:53.765]   - Field: ‘calls’
[17:43:53.765]   - Field: ‘globals’
[17:43:53.765]   - Field: ‘stdout’
[17:43:53.765]   - Field: ‘earlySignal’
[17:43:53.765]   - Field: ‘lazy’
[17:43:53.765]   - Field: ‘state’
[17:43:53.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.766] - Launch lazy future ...
[17:43:53.766] Packages needed by the future expression (n = 0): <none>
[17:43:53.766] Packages needed by future strategies (n = 0): <none>
[17:43:53.766] {
[17:43:53.766]     {
[17:43:53.766]         {
[17:43:53.766]             ...future.startTime <- base::Sys.time()
[17:43:53.766]             {
[17:43:53.766]                 {
[17:43:53.766]                   {
[17:43:53.766]                     {
[17:43:53.766]                       base::local({
[17:43:53.766]                         has_future <- base::requireNamespace("future", 
[17:43:53.766]                           quietly = TRUE)
[17:43:53.766]                         if (has_future) {
[17:43:53.766]                           ns <- base::getNamespace("future")
[17:43:53.766]                           version <- ns[[".package"]][["version"]]
[17:43:53.766]                           if (is.null(version)) 
[17:43:53.766]                             version <- utils::packageVersion("future")
[17:43:53.766]                         }
[17:43:53.766]                         else {
[17:43:53.766]                           version <- NULL
[17:43:53.766]                         }
[17:43:53.766]                         if (!has_future || version < "1.8.0") {
[17:43:53.766]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.766]                             "", base::R.version$version.string), 
[17:43:53.766]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.766]                               "release", "version")], collapse = " "), 
[17:43:53.766]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.766]                             info)
[17:43:53.766]                           info <- base::paste(info, collapse = "; ")
[17:43:53.766]                           if (!has_future) {
[17:43:53.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.766]                               info)
[17:43:53.766]                           }
[17:43:53.766]                           else {
[17:43:53.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.766]                               info, version)
[17:43:53.766]                           }
[17:43:53.766]                           base::stop(msg)
[17:43:53.766]                         }
[17:43:53.766]                       })
[17:43:53.766]                     }
[17:43:53.766]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.766]                     base::options(mc.cores = 1L)
[17:43:53.766]                   }
[17:43:53.766]                   ...future.strategy.old <- future::plan("list")
[17:43:53.766]                   options(future.plan = NULL)
[17:43:53.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.766]                 }
[17:43:53.766]                 ...future.workdir <- getwd()
[17:43:53.766]             }
[17:43:53.766]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.766]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.766]         }
[17:43:53.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.766]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.766]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.766]             base::names(...future.oldOptions))
[17:43:53.766]     }
[17:43:53.766]     if (FALSE) {
[17:43:53.766]     }
[17:43:53.766]     else {
[17:43:53.766]         if (TRUE) {
[17:43:53.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.766]                 open = "w")
[17:43:53.766]         }
[17:43:53.766]         else {
[17:43:53.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.766]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.766]         }
[17:43:53.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.766]             base::sink(type = "output", split = FALSE)
[17:43:53.766]             base::close(...future.stdout)
[17:43:53.766]         }, add = TRUE)
[17:43:53.766]     }
[17:43:53.766]     ...future.frame <- base::sys.nframe()
[17:43:53.766]     ...future.conditions <- base::list()
[17:43:53.766]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.766]     if (FALSE) {
[17:43:53.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.766]     }
[17:43:53.766]     ...future.result <- base::tryCatch({
[17:43:53.766]         base::withCallingHandlers({
[17:43:53.766]             ...future.value <- base::withVisible(base::local({
[17:43:53.766]                 withCallingHandlers({
[17:43:53.766]                   {
[17:43:53.766]                     do.call(function(...) {
[17:43:53.766]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.766]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.766]                         ...future.globals.maxSize)) {
[17:43:53.766]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.766]                         on.exit(options(oopts), add = TRUE)
[17:43:53.766]                       }
[17:43:53.766]                       {
[17:43:53.766]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.766]                           FUN = function(jj) {
[17:43:53.766]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.766]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.766]                           })
[17:43:53.766]                       }
[17:43:53.766]                     }, args = future.call.arguments)
[17:43:53.766]                   }
[17:43:53.766]                 }, immediateCondition = function(cond) {
[17:43:53.766]                   save_rds <- function (object, pathname, ...) 
[17:43:53.766]                   {
[17:43:53.766]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.766]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.766]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.766]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.766]                         fi_tmp[["mtime"]])
[17:43:53.766]                     }
[17:43:53.766]                     tryCatch({
[17:43:53.766]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.766]                     }, error = function(ex) {
[17:43:53.766]                       msg <- conditionMessage(ex)
[17:43:53.766]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.766]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.766]                         fi_tmp[["mtime"]], msg)
[17:43:53.766]                       ex$message <- msg
[17:43:53.766]                       stop(ex)
[17:43:53.766]                     })
[17:43:53.766]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.766]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.766]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.766]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.766]                       fi <- file.info(pathname)
[17:43:53.766]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.766]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.766]                         fi[["size"]], fi[["mtime"]])
[17:43:53.766]                       stop(msg)
[17:43:53.766]                     }
[17:43:53.766]                     invisible(pathname)
[17:43:53.766]                   }
[17:43:53.766]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.766]                     rootPath = tempdir()) 
[17:43:53.766]                   {
[17:43:53.766]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.766]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.766]                       tmpdir = path, fileext = ".rds")
[17:43:53.766]                     save_rds(obj, file)
[17:43:53.766]                   }
[17:43:53.766]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.766]                   {
[17:43:53.766]                     inherits <- base::inherits
[17:43:53.766]                     invokeRestart <- base::invokeRestart
[17:43:53.766]                     is.null <- base::is.null
[17:43:53.766]                     muffled <- FALSE
[17:43:53.766]                     if (inherits(cond, "message")) {
[17:43:53.766]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.766]                       if (muffled) 
[17:43:53.766]                         invokeRestart("muffleMessage")
[17:43:53.766]                     }
[17:43:53.766]                     else if (inherits(cond, "warning")) {
[17:43:53.766]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.766]                       if (muffled) 
[17:43:53.766]                         invokeRestart("muffleWarning")
[17:43:53.766]                     }
[17:43:53.766]                     else if (inherits(cond, "condition")) {
[17:43:53.766]                       if (!is.null(pattern)) {
[17:43:53.766]                         computeRestarts <- base::computeRestarts
[17:43:53.766]                         grepl <- base::grepl
[17:43:53.766]                         restarts <- computeRestarts(cond)
[17:43:53.766]                         for (restart in restarts) {
[17:43:53.766]                           name <- restart$name
[17:43:53.766]                           if (is.null(name)) 
[17:43:53.766]                             next
[17:43:53.766]                           if (!grepl(pattern, name)) 
[17:43:53.766]                             next
[17:43:53.766]                           invokeRestart(restart)
[17:43:53.766]                           muffled <- TRUE
[17:43:53.766]                           break
[17:43:53.766]                         }
[17:43:53.766]                       }
[17:43:53.766]                     }
[17:43:53.766]                     invisible(muffled)
[17:43:53.766]                   }
[17:43:53.766]                   muffleCondition(cond)
[17:43:53.766]                 })
[17:43:53.766]             }))
[17:43:53.766]             future::FutureResult(value = ...future.value$value, 
[17:43:53.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.766]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.766]                     ...future.globalenv.names))
[17:43:53.766]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.766]         }, condition = base::local({
[17:43:53.766]             c <- base::c
[17:43:53.766]             inherits <- base::inherits
[17:43:53.766]             invokeRestart <- base::invokeRestart
[17:43:53.766]             length <- base::length
[17:43:53.766]             list <- base::list
[17:43:53.766]             seq.int <- base::seq.int
[17:43:53.766]             signalCondition <- base::signalCondition
[17:43:53.766]             sys.calls <- base::sys.calls
[17:43:53.766]             `[[` <- base::`[[`
[17:43:53.766]             `+` <- base::`+`
[17:43:53.766]             `<<-` <- base::`<<-`
[17:43:53.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.766]                   3L)]
[17:43:53.766]             }
[17:43:53.766]             function(cond) {
[17:43:53.766]                 is_error <- inherits(cond, "error")
[17:43:53.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.766]                   NULL)
[17:43:53.766]                 if (is_error) {
[17:43:53.766]                   sessionInformation <- function() {
[17:43:53.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.766]                       search = base::search(), system = base::Sys.info())
[17:43:53.766]                   }
[17:43:53.766]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.766]                     cond$call), session = sessionInformation(), 
[17:43:53.766]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.766]                   signalCondition(cond)
[17:43:53.766]                 }
[17:43:53.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.766]                 "immediateCondition"))) {
[17:43:53.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.766]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.766]                   if (TRUE && !signal) {
[17:43:53.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.766]                     {
[17:43:53.766]                       inherits <- base::inherits
[17:43:53.766]                       invokeRestart <- base::invokeRestart
[17:43:53.766]                       is.null <- base::is.null
[17:43:53.766]                       muffled <- FALSE
[17:43:53.766]                       if (inherits(cond, "message")) {
[17:43:53.766]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.766]                         if (muffled) 
[17:43:53.766]                           invokeRestart("muffleMessage")
[17:43:53.766]                       }
[17:43:53.766]                       else if (inherits(cond, "warning")) {
[17:43:53.766]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.766]                         if (muffled) 
[17:43:53.766]                           invokeRestart("muffleWarning")
[17:43:53.766]                       }
[17:43:53.766]                       else if (inherits(cond, "condition")) {
[17:43:53.766]                         if (!is.null(pattern)) {
[17:43:53.766]                           computeRestarts <- base::computeRestarts
[17:43:53.766]                           grepl <- base::grepl
[17:43:53.766]                           restarts <- computeRestarts(cond)
[17:43:53.766]                           for (restart in restarts) {
[17:43:53.766]                             name <- restart$name
[17:43:53.766]                             if (is.null(name)) 
[17:43:53.766]                               next
[17:43:53.766]                             if (!grepl(pattern, name)) 
[17:43:53.766]                               next
[17:43:53.766]                             invokeRestart(restart)
[17:43:53.766]                             muffled <- TRUE
[17:43:53.766]                             break
[17:43:53.766]                           }
[17:43:53.766]                         }
[17:43:53.766]                       }
[17:43:53.766]                       invisible(muffled)
[17:43:53.766]                     }
[17:43:53.766]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.766]                   }
[17:43:53.766]                 }
[17:43:53.766]                 else {
[17:43:53.766]                   if (TRUE) {
[17:43:53.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.766]                     {
[17:43:53.766]                       inherits <- base::inherits
[17:43:53.766]                       invokeRestart <- base::invokeRestart
[17:43:53.766]                       is.null <- base::is.null
[17:43:53.766]                       muffled <- FALSE
[17:43:53.766]                       if (inherits(cond, "message")) {
[17:43:53.766]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.766]                         if (muffled) 
[17:43:53.766]                           invokeRestart("muffleMessage")
[17:43:53.766]                       }
[17:43:53.766]                       else if (inherits(cond, "warning")) {
[17:43:53.766]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.766]                         if (muffled) 
[17:43:53.766]                           invokeRestart("muffleWarning")
[17:43:53.766]                       }
[17:43:53.766]                       else if (inherits(cond, "condition")) {
[17:43:53.766]                         if (!is.null(pattern)) {
[17:43:53.766]                           computeRestarts <- base::computeRestarts
[17:43:53.766]                           grepl <- base::grepl
[17:43:53.766]                           restarts <- computeRestarts(cond)
[17:43:53.766]                           for (restart in restarts) {
[17:43:53.766]                             name <- restart$name
[17:43:53.766]                             if (is.null(name)) 
[17:43:53.766]                               next
[17:43:53.766]                             if (!grepl(pattern, name)) 
[17:43:53.766]                               next
[17:43:53.766]                             invokeRestart(restart)
[17:43:53.766]                             muffled <- TRUE
[17:43:53.766]                             break
[17:43:53.766]                           }
[17:43:53.766]                         }
[17:43:53.766]                       }
[17:43:53.766]                       invisible(muffled)
[17:43:53.766]                     }
[17:43:53.766]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.766]                   }
[17:43:53.766]                 }
[17:43:53.766]             }
[17:43:53.766]         }))
[17:43:53.766]     }, error = function(ex) {
[17:43:53.766]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.766]                 ...future.rng), started = ...future.startTime, 
[17:43:53.766]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.766]             version = "1.8"), class = "FutureResult")
[17:43:53.766]     }, finally = {
[17:43:53.766]         if (!identical(...future.workdir, getwd())) 
[17:43:53.766]             setwd(...future.workdir)
[17:43:53.766]         {
[17:43:53.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.766]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.766]             }
[17:43:53.766]             base::options(...future.oldOptions)
[17:43:53.766]             if (.Platform$OS.type == "windows") {
[17:43:53.766]                 old_names <- names(...future.oldEnvVars)
[17:43:53.766]                 envs <- base::Sys.getenv()
[17:43:53.766]                 names <- names(envs)
[17:43:53.766]                 common <- intersect(names, old_names)
[17:43:53.766]                 added <- setdiff(names, old_names)
[17:43:53.766]                 removed <- setdiff(old_names, names)
[17:43:53.766]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.766]                   envs[common]]
[17:43:53.766]                 NAMES <- toupper(changed)
[17:43:53.766]                 args <- list()
[17:43:53.766]                 for (kk in seq_along(NAMES)) {
[17:43:53.766]                   name <- changed[[kk]]
[17:43:53.766]                   NAME <- NAMES[[kk]]
[17:43:53.766]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.766]                     next
[17:43:53.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.766]                 }
[17:43:53.766]                 NAMES <- toupper(added)
[17:43:53.766]                 for (kk in seq_along(NAMES)) {
[17:43:53.766]                   name <- added[[kk]]
[17:43:53.766]                   NAME <- NAMES[[kk]]
[17:43:53.766]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.766]                     next
[17:43:53.766]                   args[[name]] <- ""
[17:43:53.766]                 }
[17:43:53.766]                 NAMES <- toupper(removed)
[17:43:53.766]                 for (kk in seq_along(NAMES)) {
[17:43:53.766]                   name <- removed[[kk]]
[17:43:53.766]                   NAME <- NAMES[[kk]]
[17:43:53.766]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.766]                     next
[17:43:53.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.766]                 }
[17:43:53.766]                 if (length(args) > 0) 
[17:43:53.766]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.766]             }
[17:43:53.766]             else {
[17:43:53.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.766]             }
[17:43:53.766]             {
[17:43:53.766]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.766]                   0L) {
[17:43:53.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.766]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.766]                   base::options(opts)
[17:43:53.766]                 }
[17:43:53.766]                 {
[17:43:53.766]                   {
[17:43:53.766]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.766]                     NULL
[17:43:53.766]                   }
[17:43:53.766]                   options(future.plan = NULL)
[17:43:53.766]                   if (is.na(NA_character_)) 
[17:43:53.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.766]                     .init = FALSE)
[17:43:53.766]                 }
[17:43:53.766]             }
[17:43:53.766]         }
[17:43:53.766]     })
[17:43:53.766]     if (TRUE) {
[17:43:53.766]         base::sink(type = "output", split = FALSE)
[17:43:53.766]         if (TRUE) {
[17:43:53.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.766]         }
[17:43:53.766]         else {
[17:43:53.766]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.766]         }
[17:43:53.766]         base::close(...future.stdout)
[17:43:53.766]         ...future.stdout <- NULL
[17:43:53.766]     }
[17:43:53.766]     ...future.result$conditions <- ...future.conditions
[17:43:53.766]     ...future.result$finished <- base::Sys.time()
[17:43:53.766]     ...future.result
[17:43:53.766] }
[17:43:53.769] assign_globals() ...
[17:43:53.769] List of 5
[17:43:53.769]  $ ...future.FUN            :function (object, ...)  
[17:43:53.769]  $ future.call.arguments    : list()
[17:43:53.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.769]  $ ...future.elements_ii    :List of 1
[17:43:53.769]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.769]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:43:53.769]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.769]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:53.769]  $ ...future.seeds_ii       : NULL
[17:43:53.769]  $ ...future.globals.maxSize: NULL
[17:43:53.769]  - attr(*, "where")=List of 5
[17:43:53.769]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.769]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.769]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.769]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.769]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.769]  - attr(*, "resolved")= logi FALSE
[17:43:53.769]  - attr(*, "total_size")= num 1240
[17:43:53.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.769]  - attr(*, "already-done")= logi TRUE
[17:43:53.776] - copied ‘...future.FUN’ to environment
[17:43:53.776] - copied ‘future.call.arguments’ to environment
[17:43:53.776] - copied ‘...future.elements_ii’ to environment
[17:43:53.776] - copied ‘...future.seeds_ii’ to environment
[17:43:53.777] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.777] assign_globals() ... done
[17:43:53.777] requestCore(): workers = 2
[17:43:53.779] MulticoreFuture started
[17:43:53.780] - Launch lazy future ... done
[17:43:53.780] plan(): Setting new future strategy stack:
[17:43:53.780] run() for ‘MulticoreFuture’ ... done
[17:43:53.781] Created future:
[17:43:53.781] List of future strategies:
[17:43:53.781] 1. sequential:
[17:43:53.781]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.781]    - tweaked: FALSE
[17:43:53.781]    - call: NULL
[17:43:53.783] plan(): nbrOfWorkers() = 1
[17:43:53.787] plan(): Setting new future strategy stack:
[17:43:53.788] List of future strategies:
[17:43:53.788] 1. multicore:
[17:43:53.788]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.788]    - tweaked: FALSE
[17:43:53.788]    - call: plan(strategy)
[17:43:53.793] plan(): nbrOfWorkers() = 2
[17:43:53.781] MulticoreFuture:
[17:43:53.781] Label: ‘future_by-1’
[17:43:53.781] Expression:
[17:43:53.781] {
[17:43:53.781]     do.call(function(...) {
[17:43:53.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.781]             on.exit(options(oopts), add = TRUE)
[17:43:53.781]         }
[17:43:53.781]         {
[17:43:53.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.781]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.781]             })
[17:43:53.781]         }
[17:43:53.781]     }, args = future.call.arguments)
[17:43:53.781] }
[17:43:53.781] Lazy evaluation: FALSE
[17:43:53.781] Asynchronous evaluation: TRUE
[17:43:53.781] Local evaluation: TRUE
[17:43:53.781] Environment: 0x55d6b8c72c30
[17:43:53.781] Capture standard output: TRUE
[17:43:53.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.781] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.781] Packages: <none>
[17:43:53.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.781] Resolved: TRUE
[17:43:53.781] Value: <not collected>
[17:43:53.781] Conditions captured: <none>
[17:43:53.781] Early signaling: FALSE
[17:43:53.781] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.781] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.794] Chunk #1 of 2 ... DONE
[17:43:53.795] Chunk #2 of 2 ...
[17:43:53.795]  - Finding globals in 'X' for chunk #2 ...
[17:43:53.795] getGlobalsAndPackages() ...
[17:43:53.795] Searching for globals...
[17:43:53.796] 
[17:43:53.796] Searching for globals ... DONE
[17:43:53.797] - globals: [0] <none>
[17:43:53.797] getGlobalsAndPackages() ... DONE
[17:43:53.797]    + additional globals found: [n=0] 
[17:43:53.797]    + additional namespaces needed: [n=0] 
[17:43:53.797]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:53.797]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:53.798]  - seeds: <none>
[17:43:53.798]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.798] getGlobalsAndPackages() ...
[17:43:53.798] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.798] Resolving globals: FALSE
[17:43:53.799] Tweak future expression to call with '...' arguments ...
[17:43:53.799] {
[17:43:53.799]     do.call(function(...) {
[17:43:53.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.799]             on.exit(options(oopts), add = TRUE)
[17:43:53.799]         }
[17:43:53.799]         {
[17:43:53.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.799]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.799]             })
[17:43:53.799]         }
[17:43:53.799]     }, args = future.call.arguments)
[17:43:53.799] }
[17:43:53.799] Tweak future expression to call with '...' arguments ... DONE
[17:43:53.800] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:53.800] 
[17:43:53.800] getGlobalsAndPackages() ... DONE
[17:43:53.801] run() for ‘Future’ ...
[17:43:53.801] - state: ‘created’
[17:43:53.801] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:53.806]   - Field: ‘label’
[17:43:53.806]   - Field: ‘local’
[17:43:53.806]   - Field: ‘owner’
[17:43:53.806]   - Field: ‘envir’
[17:43:53.806]   - Field: ‘workers’
[17:43:53.807]   - Field: ‘packages’
[17:43:53.807]   - Field: ‘gc’
[17:43:53.807]   - Field: ‘job’
[17:43:53.807]   - Field: ‘conditions’
[17:43:53.807]   - Field: ‘expr’
[17:43:53.807]   - Field: ‘uuid’
[17:43:53.807]   - Field: ‘seed’
[17:43:53.807]   - Field: ‘version’
[17:43:53.808]   - Field: ‘result’
[17:43:53.808]   - Field: ‘asynchronous’
[17:43:53.808]   - Field: ‘calls’
[17:43:53.808]   - Field: ‘globals’
[17:43:53.808]   - Field: ‘stdout’
[17:43:53.808]   - Field: ‘earlySignal’
[17:43:53.808]   - Field: ‘lazy’
[17:43:53.808]   - Field: ‘state’
[17:43:53.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:53.809] - Launch lazy future ...
[17:43:53.809] Packages needed by the future expression (n = 0): <none>
[17:43:53.809] Packages needed by future strategies (n = 0): <none>
[17:43:53.810] {
[17:43:53.810]     {
[17:43:53.810]         {
[17:43:53.810]             ...future.startTime <- base::Sys.time()
[17:43:53.810]             {
[17:43:53.810]                 {
[17:43:53.810]                   {
[17:43:53.810]                     {
[17:43:53.810]                       base::local({
[17:43:53.810]                         has_future <- base::requireNamespace("future", 
[17:43:53.810]                           quietly = TRUE)
[17:43:53.810]                         if (has_future) {
[17:43:53.810]                           ns <- base::getNamespace("future")
[17:43:53.810]                           version <- ns[[".package"]][["version"]]
[17:43:53.810]                           if (is.null(version)) 
[17:43:53.810]                             version <- utils::packageVersion("future")
[17:43:53.810]                         }
[17:43:53.810]                         else {
[17:43:53.810]                           version <- NULL
[17:43:53.810]                         }
[17:43:53.810]                         if (!has_future || version < "1.8.0") {
[17:43:53.810]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.810]                             "", base::R.version$version.string), 
[17:43:53.810]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.810]                               "release", "version")], collapse = " "), 
[17:43:53.810]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.810]                             info)
[17:43:53.810]                           info <- base::paste(info, collapse = "; ")
[17:43:53.810]                           if (!has_future) {
[17:43:53.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.810]                               info)
[17:43:53.810]                           }
[17:43:53.810]                           else {
[17:43:53.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.810]                               info, version)
[17:43:53.810]                           }
[17:43:53.810]                           base::stop(msg)
[17:43:53.810]                         }
[17:43:53.810]                       })
[17:43:53.810]                     }
[17:43:53.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.810]                     base::options(mc.cores = 1L)
[17:43:53.810]                   }
[17:43:53.810]                   ...future.strategy.old <- future::plan("list")
[17:43:53.810]                   options(future.plan = NULL)
[17:43:53.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.810]                 }
[17:43:53.810]                 ...future.workdir <- getwd()
[17:43:53.810]             }
[17:43:53.810]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.810]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.810]         }
[17:43:53.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.810]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:53.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.810]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.810]             base::names(...future.oldOptions))
[17:43:53.810]     }
[17:43:53.810]     if (FALSE) {
[17:43:53.810]     }
[17:43:53.810]     else {
[17:43:53.810]         if (TRUE) {
[17:43:53.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.810]                 open = "w")
[17:43:53.810]         }
[17:43:53.810]         else {
[17:43:53.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.810]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.810]         }
[17:43:53.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.810]             base::sink(type = "output", split = FALSE)
[17:43:53.810]             base::close(...future.stdout)
[17:43:53.810]         }, add = TRUE)
[17:43:53.810]     }
[17:43:53.810]     ...future.frame <- base::sys.nframe()
[17:43:53.810]     ...future.conditions <- base::list()
[17:43:53.810]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.810]     if (FALSE) {
[17:43:53.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.810]     }
[17:43:53.810]     ...future.result <- base::tryCatch({
[17:43:53.810]         base::withCallingHandlers({
[17:43:53.810]             ...future.value <- base::withVisible(base::local({
[17:43:53.810]                 withCallingHandlers({
[17:43:53.810]                   {
[17:43:53.810]                     do.call(function(...) {
[17:43:53.810]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.810]                       if (!identical(...future.globals.maxSize.org, 
[17:43:53.810]                         ...future.globals.maxSize)) {
[17:43:53.810]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.810]                         on.exit(options(oopts), add = TRUE)
[17:43:53.810]                       }
[17:43:53.810]                       {
[17:43:53.810]                         lapply(seq_along(...future.elements_ii), 
[17:43:53.810]                           FUN = function(jj) {
[17:43:53.810]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.810]                             ...future.FUN(...future.X_jj, ...)
[17:43:53.810]                           })
[17:43:53.810]                       }
[17:43:53.810]                     }, args = future.call.arguments)
[17:43:53.810]                   }
[17:43:53.810]                 }, immediateCondition = function(cond) {
[17:43:53.810]                   save_rds <- function (object, pathname, ...) 
[17:43:53.810]                   {
[17:43:53.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:53.810]                     if (file_test("-f", pathname_tmp)) {
[17:43:53.810]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:53.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.810]                         fi_tmp[["mtime"]])
[17:43:53.810]                     }
[17:43:53.810]                     tryCatch({
[17:43:53.810]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:53.810]                     }, error = function(ex) {
[17:43:53.810]                       msg <- conditionMessage(ex)
[17:43:53.810]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:53.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.810]                         fi_tmp[["mtime"]], msg)
[17:43:53.810]                       ex$message <- msg
[17:43:53.810]                       stop(ex)
[17:43:53.810]                     })
[17:43:53.810]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:53.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:53.810]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:53.810]                       fi_tmp <- file.info(pathname_tmp)
[17:43:53.810]                       fi <- file.info(pathname)
[17:43:53.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:53.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:53.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:53.810]                         fi[["size"]], fi[["mtime"]])
[17:43:53.810]                       stop(msg)
[17:43:53.810]                     }
[17:43:53.810]                     invisible(pathname)
[17:43:53.810]                   }
[17:43:53.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:53.810]                     rootPath = tempdir()) 
[17:43:53.810]                   {
[17:43:53.810]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:53.810]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:53.810]                       tmpdir = path, fileext = ".rds")
[17:43:53.810]                     save_rds(obj, file)
[17:43:53.810]                   }
[17:43:53.810]                   saveImmediateCondition(cond, path = "/tmp/RtmphqPkhL/.future/immediateConditions")
[17:43:53.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.810]                   {
[17:43:53.810]                     inherits <- base::inherits
[17:43:53.810]                     invokeRestart <- base::invokeRestart
[17:43:53.810]                     is.null <- base::is.null
[17:43:53.810]                     muffled <- FALSE
[17:43:53.810]                     if (inherits(cond, "message")) {
[17:43:53.810]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.810]                       if (muffled) 
[17:43:53.810]                         invokeRestart("muffleMessage")
[17:43:53.810]                     }
[17:43:53.810]                     else if (inherits(cond, "warning")) {
[17:43:53.810]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.810]                       if (muffled) 
[17:43:53.810]                         invokeRestart("muffleWarning")
[17:43:53.810]                     }
[17:43:53.810]                     else if (inherits(cond, "condition")) {
[17:43:53.810]                       if (!is.null(pattern)) {
[17:43:53.810]                         computeRestarts <- base::computeRestarts
[17:43:53.810]                         grepl <- base::grepl
[17:43:53.810]                         restarts <- computeRestarts(cond)
[17:43:53.810]                         for (restart in restarts) {
[17:43:53.810]                           name <- restart$name
[17:43:53.810]                           if (is.null(name)) 
[17:43:53.810]                             next
[17:43:53.810]                           if (!grepl(pattern, name)) 
[17:43:53.810]                             next
[17:43:53.810]                           invokeRestart(restart)
[17:43:53.810]                           muffled <- TRUE
[17:43:53.810]                           break
[17:43:53.810]                         }
[17:43:53.810]                       }
[17:43:53.810]                     }
[17:43:53.810]                     invisible(muffled)
[17:43:53.810]                   }
[17:43:53.810]                   muffleCondition(cond)
[17:43:53.810]                 })
[17:43:53.810]             }))
[17:43:53.810]             future::FutureResult(value = ...future.value$value, 
[17:43:53.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.810]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.810]                     ...future.globalenv.names))
[17:43:53.810]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.810]         }, condition = base::local({
[17:43:53.810]             c <- base::c
[17:43:53.810]             inherits <- base::inherits
[17:43:53.810]             invokeRestart <- base::invokeRestart
[17:43:53.810]             length <- base::length
[17:43:53.810]             list <- base::list
[17:43:53.810]             seq.int <- base::seq.int
[17:43:53.810]             signalCondition <- base::signalCondition
[17:43:53.810]             sys.calls <- base::sys.calls
[17:43:53.810]             `[[` <- base::`[[`
[17:43:53.810]             `+` <- base::`+`
[17:43:53.810]             `<<-` <- base::`<<-`
[17:43:53.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.810]                   3L)]
[17:43:53.810]             }
[17:43:53.810]             function(cond) {
[17:43:53.810]                 is_error <- inherits(cond, "error")
[17:43:53.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.810]                   NULL)
[17:43:53.810]                 if (is_error) {
[17:43:53.810]                   sessionInformation <- function() {
[17:43:53.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.810]                       search = base::search(), system = base::Sys.info())
[17:43:53.810]                   }
[17:43:53.810]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.810]                     cond$call), session = sessionInformation(), 
[17:43:53.810]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.810]                   signalCondition(cond)
[17:43:53.810]                 }
[17:43:53.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.810]                 "immediateCondition"))) {
[17:43:53.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.810]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.810]                   if (TRUE && !signal) {
[17:43:53.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.810]                     {
[17:43:53.810]                       inherits <- base::inherits
[17:43:53.810]                       invokeRestart <- base::invokeRestart
[17:43:53.810]                       is.null <- base::is.null
[17:43:53.810]                       muffled <- FALSE
[17:43:53.810]                       if (inherits(cond, "message")) {
[17:43:53.810]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.810]                         if (muffled) 
[17:43:53.810]                           invokeRestart("muffleMessage")
[17:43:53.810]                       }
[17:43:53.810]                       else if (inherits(cond, "warning")) {
[17:43:53.810]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.810]                         if (muffled) 
[17:43:53.810]                           invokeRestart("muffleWarning")
[17:43:53.810]                       }
[17:43:53.810]                       else if (inherits(cond, "condition")) {
[17:43:53.810]                         if (!is.null(pattern)) {
[17:43:53.810]                           computeRestarts <- base::computeRestarts
[17:43:53.810]                           grepl <- base::grepl
[17:43:53.810]                           restarts <- computeRestarts(cond)
[17:43:53.810]                           for (restart in restarts) {
[17:43:53.810]                             name <- restart$name
[17:43:53.810]                             if (is.null(name)) 
[17:43:53.810]                               next
[17:43:53.810]                             if (!grepl(pattern, name)) 
[17:43:53.810]                               next
[17:43:53.810]                             invokeRestart(restart)
[17:43:53.810]                             muffled <- TRUE
[17:43:53.810]                             break
[17:43:53.810]                           }
[17:43:53.810]                         }
[17:43:53.810]                       }
[17:43:53.810]                       invisible(muffled)
[17:43:53.810]                     }
[17:43:53.810]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.810]                   }
[17:43:53.810]                 }
[17:43:53.810]                 else {
[17:43:53.810]                   if (TRUE) {
[17:43:53.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.810]                     {
[17:43:53.810]                       inherits <- base::inherits
[17:43:53.810]                       invokeRestart <- base::invokeRestart
[17:43:53.810]                       is.null <- base::is.null
[17:43:53.810]                       muffled <- FALSE
[17:43:53.810]                       if (inherits(cond, "message")) {
[17:43:53.810]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.810]                         if (muffled) 
[17:43:53.810]                           invokeRestart("muffleMessage")
[17:43:53.810]                       }
[17:43:53.810]                       else if (inherits(cond, "warning")) {
[17:43:53.810]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.810]                         if (muffled) 
[17:43:53.810]                           invokeRestart("muffleWarning")
[17:43:53.810]                       }
[17:43:53.810]                       else if (inherits(cond, "condition")) {
[17:43:53.810]                         if (!is.null(pattern)) {
[17:43:53.810]                           computeRestarts <- base::computeRestarts
[17:43:53.810]                           grepl <- base::grepl
[17:43:53.810]                           restarts <- computeRestarts(cond)
[17:43:53.810]                           for (restart in restarts) {
[17:43:53.810]                             name <- restart$name
[17:43:53.810]                             if (is.null(name)) 
[17:43:53.810]                               next
[17:43:53.810]                             if (!grepl(pattern, name)) 
[17:43:53.810]                               next
[17:43:53.810]                             invokeRestart(restart)
[17:43:53.810]                             muffled <- TRUE
[17:43:53.810]                             break
[17:43:53.810]                           }
[17:43:53.810]                         }
[17:43:53.810]                       }
[17:43:53.810]                       invisible(muffled)
[17:43:53.810]                     }
[17:43:53.810]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.810]                   }
[17:43:53.810]                 }
[17:43:53.810]             }
[17:43:53.810]         }))
[17:43:53.810]     }, error = function(ex) {
[17:43:53.810]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.810]                 ...future.rng), started = ...future.startTime, 
[17:43:53.810]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.810]             version = "1.8"), class = "FutureResult")
[17:43:53.810]     }, finally = {
[17:43:53.810]         if (!identical(...future.workdir, getwd())) 
[17:43:53.810]             setwd(...future.workdir)
[17:43:53.810]         {
[17:43:53.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.810]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.810]             }
[17:43:53.810]             base::options(...future.oldOptions)
[17:43:53.810]             if (.Platform$OS.type == "windows") {
[17:43:53.810]                 old_names <- names(...future.oldEnvVars)
[17:43:53.810]                 envs <- base::Sys.getenv()
[17:43:53.810]                 names <- names(envs)
[17:43:53.810]                 common <- intersect(names, old_names)
[17:43:53.810]                 added <- setdiff(names, old_names)
[17:43:53.810]                 removed <- setdiff(old_names, names)
[17:43:53.810]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.810]                   envs[common]]
[17:43:53.810]                 NAMES <- toupper(changed)
[17:43:53.810]                 args <- list()
[17:43:53.810]                 for (kk in seq_along(NAMES)) {
[17:43:53.810]                   name <- changed[[kk]]
[17:43:53.810]                   NAME <- NAMES[[kk]]
[17:43:53.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.810]                     next
[17:43:53.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.810]                 }
[17:43:53.810]                 NAMES <- toupper(added)
[17:43:53.810]                 for (kk in seq_along(NAMES)) {
[17:43:53.810]                   name <- added[[kk]]
[17:43:53.810]                   NAME <- NAMES[[kk]]
[17:43:53.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.810]                     next
[17:43:53.810]                   args[[name]] <- ""
[17:43:53.810]                 }
[17:43:53.810]                 NAMES <- toupper(removed)
[17:43:53.810]                 for (kk in seq_along(NAMES)) {
[17:43:53.810]                   name <- removed[[kk]]
[17:43:53.810]                   NAME <- NAMES[[kk]]
[17:43:53.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.810]                     next
[17:43:53.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.810]                 }
[17:43:53.810]                 if (length(args) > 0) 
[17:43:53.810]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.810]             }
[17:43:53.810]             else {
[17:43:53.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.810]             }
[17:43:53.810]             {
[17:43:53.810]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.810]                   0L) {
[17:43:53.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.810]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.810]                   base::options(opts)
[17:43:53.810]                 }
[17:43:53.810]                 {
[17:43:53.810]                   {
[17:43:53.810]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.810]                     NULL
[17:43:53.810]                   }
[17:43:53.810]                   options(future.plan = NULL)
[17:43:53.810]                   if (is.na(NA_character_)) 
[17:43:53.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:53.810]                     .init = FALSE)
[17:43:53.810]                 }
[17:43:53.810]             }
[17:43:53.810]         }
[17:43:53.810]     })
[17:43:53.810]     if (TRUE) {
[17:43:53.810]         base::sink(type = "output", split = FALSE)
[17:43:53.810]         if (TRUE) {
[17:43:53.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.810]         }
[17:43:53.810]         else {
[17:43:53.810]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.810]         }
[17:43:53.810]         base::close(...future.stdout)
[17:43:53.810]         ...future.stdout <- NULL
[17:43:53.810]     }
[17:43:53.810]     ...future.result$conditions <- ...future.conditions
[17:43:53.810]     ...future.result$finished <- base::Sys.time()
[17:43:53.810]     ...future.result
[17:43:53.810] }
[17:43:53.813] assign_globals() ...
[17:43:53.813] List of 5
[17:43:53.813]  $ ...future.FUN            :function (object, ...)  
[17:43:53.813]  $ future.call.arguments    : list()
[17:43:53.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:53.813]  $ ...future.elements_ii    :List of 2
[17:43:53.813]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.813]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:43:53.813]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.813]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:43:53.813]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:43:53.813]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:43:53.813]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:43:53.813]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:43:53.813]  $ ...future.seeds_ii       : NULL
[17:43:53.813]  $ ...future.globals.maxSize: NULL
[17:43:53.813]  - attr(*, "where")=List of 5
[17:43:53.813]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:53.813]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:53.813]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:53.813]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:53.813]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:53.813]  - attr(*, "resolved")= logi FALSE
[17:43:53.813]  - attr(*, "total_size")= num 1240
[17:43:53.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:53.813]  - attr(*, "already-done")= logi TRUE
[17:43:53.825] - copied ‘...future.FUN’ to environment
[17:43:53.825] - copied ‘future.call.arguments’ to environment
[17:43:53.825] - copied ‘...future.elements_ii’ to environment
[17:43:53.825] - copied ‘...future.seeds_ii’ to environment
[17:43:53.825] - copied ‘...future.globals.maxSize’ to environment
[17:43:53.825] assign_globals() ... done
[17:43:53.825] requestCore(): workers = 2
[17:43:53.828] MulticoreFuture started
[17:43:53.828] - Launch lazy future ... done
[17:43:53.829] plan(): Setting new future strategy stack:
[17:43:53.829] run() for ‘MulticoreFuture’ ... done
[17:43:53.829] Created future:
[17:43:53.829] List of future strategies:
[17:43:53.829] 1. sequential:
[17:43:53.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:53.829]    - tweaked: FALSE
[17:43:53.829]    - call: NULL
[17:43:53.831] plan(): nbrOfWorkers() = 1
[17:43:53.837] plan(): Setting new future strategy stack:
[17:43:53.837] List of future strategies:
[17:43:53.837] 1. multicore:
[17:43:53.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:53.837]    - tweaked: FALSE
[17:43:53.837]    - call: plan(strategy)
[17:43:53.842] plan(): nbrOfWorkers() = 2
[17:43:53.830] MulticoreFuture:
[17:43:53.830] Label: ‘future_by-2’
[17:43:53.830] Expression:
[17:43:53.830] {
[17:43:53.830]     do.call(function(...) {
[17:43:53.830]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:53.830]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:53.830]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:53.830]             on.exit(options(oopts), add = TRUE)
[17:43:53.830]         }
[17:43:53.830]         {
[17:43:53.830]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:53.830]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:53.830]                 ...future.FUN(...future.X_jj, ...)
[17:43:53.830]             })
[17:43:53.830]         }
[17:43:53.830]     }, args = future.call.arguments)
[17:43:53.830] }
[17:43:53.830] Lazy evaluation: FALSE
[17:43:53.830] Asynchronous evaluation: TRUE
[17:43:53.830] Local evaluation: TRUE
[17:43:53.830] Environment: 0x55d6b8c72c30
[17:43:53.830] Capture standard output: TRUE
[17:43:53.830] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:53.830] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:53.830] Packages: <none>
[17:43:53.830] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:53.830] Resolved: TRUE
[17:43:53.830] Value: <not collected>
[17:43:53.830] Conditions captured: <none>
[17:43:53.830] Early signaling: FALSE
[17:43:53.830] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:53.830] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.843] Chunk #2 of 2 ... DONE
[17:43:53.843] Launching 2 futures (chunks) ... DONE
[17:43:53.844] Resolving 2 futures (chunks) ...
[17:43:53.844] resolve() on list ...
[17:43:53.844]  recursive: 0
[17:43:53.844]  length: 2
[17:43:53.844] 
[17:43:53.845] Future #1
[17:43:53.845] result() for MulticoreFuture ...
[17:43:53.846] result() for MulticoreFuture ...
[17:43:53.846] result() for MulticoreFuture ... done
[17:43:53.846] result() for MulticoreFuture ... done
[17:43:53.846] result() for MulticoreFuture ...
[17:43:53.846] result() for MulticoreFuture ... done
[17:43:53.847] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:53.847] - nx: 2
[17:43:53.847] - relay: TRUE
[17:43:53.847] - stdout: TRUE
[17:43:53.847] - signal: TRUE
[17:43:53.847] - resignal: FALSE
[17:43:53.847] - force: TRUE
[17:43:53.848] - relayed: [n=2] FALSE, FALSE
[17:43:53.848] - queued futures: [n=2] FALSE, FALSE
[17:43:53.848]  - until=1
[17:43:53.848]  - relaying element #1
[17:43:53.848] result() for MulticoreFuture ...
[17:43:53.848] result() for MulticoreFuture ... done
[17:43:53.849] result() for MulticoreFuture ...
[17:43:53.849] result() for MulticoreFuture ... done
[17:43:53.849] result() for MulticoreFuture ...
[17:43:53.849] result() for MulticoreFuture ... done
[17:43:53.849] result() for MulticoreFuture ...
[17:43:53.849] result() for MulticoreFuture ... done
[17:43:53.850] - relayed: [n=2] TRUE, FALSE
[17:43:53.850] - queued futures: [n=2] TRUE, FALSE
[17:43:53.850] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:53.850]  length: 1 (resolved future 1)
[17:43:53.850] Future #2
[17:43:53.851] result() for MulticoreFuture ...
[17:43:53.851] result() for MulticoreFuture ...
[17:43:53.851] result() for MulticoreFuture ... done
[17:43:53.852] result() for MulticoreFuture ... done
[17:43:53.852] result() for MulticoreFuture ...
[17:43:53.852] result() for MulticoreFuture ... done
[17:43:53.852] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:53.852] - nx: 2
[17:43:53.852] - relay: TRUE
[17:43:53.852] - stdout: TRUE
[17:43:53.852] - signal: TRUE
[17:43:53.852] - resignal: FALSE
[17:43:53.853] - force: TRUE
[17:43:53.853] - relayed: [n=2] TRUE, FALSE
[17:43:53.853] - queued futures: [n=2] TRUE, FALSE
[17:43:53.853]  - until=2
[17:43:53.853]  - relaying element #2
[17:43:53.853] result() for MulticoreFuture ...
[17:43:53.853] result() for MulticoreFuture ... done
[17:43:53.853] result() for MulticoreFuture ...
[17:43:53.853] result() for MulticoreFuture ... done
[17:43:53.854] result() for MulticoreFuture ...
[17:43:53.854] result() for MulticoreFuture ... done
[17:43:53.854] result() for MulticoreFuture ...
[17:43:53.854] result() for MulticoreFuture ... done
[17:43:53.854] - relayed: [n=2] TRUE, TRUE
[17:43:53.854] - queued futures: [n=2] TRUE, TRUE
[17:43:53.854] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:53.854]  length: 0 (resolved future 2)
[17:43:53.855] Relaying remaining futures
[17:43:53.855] signalConditionsASAP(NULL, pos=0) ...
[17:43:53.855] - nx: 2
[17:43:53.855] - relay: TRUE
[17:43:53.855] - stdout: TRUE
[17:43:53.855] - signal: TRUE
[17:43:53.855] - resignal: FALSE
[17:43:53.855] - force: TRUE
[17:43:53.855] - relayed: [n=2] TRUE, TRUE
[17:43:53.855] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:53.856] - relayed: [n=2] TRUE, TRUE
[17:43:53.856] - queued futures: [n=2] TRUE, TRUE
[17:43:53.856] signalConditionsASAP(NULL, pos=0) ... done
[17:43:53.856] resolve() on list ... DONE
[17:43:53.856] result() for MulticoreFuture ...
[17:43:53.856] result() for MulticoreFuture ... done
[17:43:53.856] result() for MulticoreFuture ...
[17:43:53.856] result() for MulticoreFuture ... done
[17:43:53.856] result() for MulticoreFuture ...
[17:43:53.857] result() for MulticoreFuture ... done
[17:43:53.857] result() for MulticoreFuture ...
[17:43:53.857] result() for MulticoreFuture ... done
[17:43:53.857]  - Number of value chunks collected: 2
[17:43:53.857] Resolving 2 futures (chunks) ... DONE
[17:43:53.857] Reducing values from 2 chunks ...
[17:43:53.857]  - Number of values collected after concatenation: 3
[17:43:53.857]  - Number of values expected: 3
[17:43:53.857] Reducing values from 2 chunks ... DONE
[17:43:53.858] future_lapply() ... DONE
[17:43:53.858] future_by_internal() ... DONE
[17:43:53.859] future_by_internal() ...
- plan('multisession') ...
[17:43:53.859] plan(): Setting new future strategy stack:
[17:43:53.859] List of future strategies:
[17:43:53.859] 1. multisession:
[17:43:53.859]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:53.859]    - tweaked: FALSE
[17:43:53.859]    - call: plan(strategy)
[17:43:53.860] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:53.860] multisession:
[17:43:53.860] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:53.860] - tweaked: FALSE
[17:43:53.860] - call: plan(strategy)
[17:43:53.869] getGlobalsAndPackages() ...
[17:43:53.869] Not searching for globals
[17:43:53.869] - globals: [0] <none>
[17:43:53.870] getGlobalsAndPackages() ... DONE
[17:43:53.870] [local output] makeClusterPSOCK() ...
[17:43:53.914] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:53.915] [local output] Base port: 11590
[17:43:53.915] [local output] Getting setup options for 2 cluster nodes ...
[17:43:53.916] [local output]  - Node 1 of 2 ...
[17:43:53.916] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:53.917] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphqPkhL/worker.rank=1.parallelly.parent=28742.704668e6b94b.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmphqPkhL/worker.rank=1.parallelly.parent=28742.704668e6b94b.pid")'’
[17:43:54.104] - Possible to infer worker's PID: TRUE
[17:43:54.105] [local output] Rscript port: 11590

[17:43:54.105] [local output]  - Node 2 of 2 ...
[17:43:54.105] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:54.106] [local output] Rscript port: 11590

[17:43:54.106] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:54.106] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:54.107] [local output] Setting up PSOCK nodes in parallel
[17:43:54.107] List of 36
[17:43:54.107]  $ worker          : chr "localhost"
[17:43:54.107]   ..- attr(*, "localhost")= logi TRUE
[17:43:54.107]  $ master          : chr "localhost"
[17:43:54.107]  $ port            : int 11590
[17:43:54.107]  $ connectTimeout  : num 120
[17:43:54.107]  $ timeout         : num 2592000
[17:43:54.107]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:54.107]  $ homogeneous     : logi TRUE
[17:43:54.107]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:54.107]  $ rscript_envs    : NULL
[17:43:54.107]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:54.107]  $ rscript_startup : NULL
[17:43:54.107]  $ rscript_sh      : chr "sh"
[17:43:54.107]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:54.107]  $ methods         : logi TRUE
[17:43:54.107]  $ socketOptions   : chr "no-delay"
[17:43:54.107]  $ useXDR          : logi FALSE
[17:43:54.107]  $ outfile         : chr "/dev/null"
[17:43:54.107]  $ renice          : int NA
[17:43:54.107]  $ rshcmd          : NULL
[17:43:54.107]  $ user            : chr(0) 
[17:43:54.107]  $ revtunnel       : logi FALSE
[17:43:54.107]  $ rshlogfile      : NULL
[17:43:54.107]  $ rshopts         : chr(0) 
[17:43:54.107]  $ rank            : int 1
[17:43:54.107]  $ manual          : logi FALSE
[17:43:54.107]  $ dryrun          : logi FALSE
[17:43:54.107]  $ quiet           : logi FALSE
[17:43:54.107]  $ setup_strategy  : chr "parallel"
[17:43:54.107]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:54.107]  $ pidfile         : chr "/tmp/RtmphqPkhL/worker.rank=1.parallelly.parent=28742.704668e6b94b.pid"
[17:43:54.107]  $ rshcmd_label    : NULL
[17:43:54.107]  $ rsh_call        : NULL
[17:43:54.107]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:54.107]  $ localMachine    : logi TRUE
[17:43:54.107]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:54.107]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:54.107]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:54.107]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:54.107]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:54.107]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:54.107]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:54.107]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:54.107]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:54.107]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:54.107]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:54.107]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:54.107]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:54.107]  $ arguments       :List of 28
[17:43:54.107]   ..$ worker          : chr "localhost"
[17:43:54.107]   ..$ master          : NULL
[17:43:54.107]   ..$ port            : int 11590
[17:43:54.107]   ..$ connectTimeout  : num 120
[17:43:54.107]   ..$ timeout         : num 2592000
[17:43:54.107]   ..$ rscript         : NULL
[17:43:54.107]   ..$ homogeneous     : NULL
[17:43:54.107]   ..$ rscript_args    : NULL
[17:43:54.107]   ..$ rscript_envs    : NULL
[17:43:54.107]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:54.107]   ..$ rscript_startup : NULL
[17:43:54.107]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:54.107]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:54.107]   ..$ methods         : logi TRUE
[17:43:54.107]   ..$ socketOptions   : chr "no-delay"
[17:43:54.107]   ..$ useXDR          : logi FALSE
[17:43:54.107]   ..$ outfile         : chr "/dev/null"
[17:43:54.107]   ..$ renice          : int NA
[17:43:54.107]   ..$ rshcmd          : NULL
[17:43:54.107]   ..$ user            : NULL
[17:43:54.107]   ..$ revtunnel       : logi NA
[17:43:54.107]   ..$ rshlogfile      : NULL
[17:43:54.107]   ..$ rshopts         : NULL
[17:43:54.107]   ..$ rank            : int 1
[17:43:54.107]   ..$ manual          : logi FALSE
[17:43:54.107]   ..$ dryrun          : logi FALSE
[17:43:54.107]   ..$ quiet           : logi FALSE
[17:43:54.107]   ..$ setup_strategy  : chr "parallel"
[17:43:54.107]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:54.124] [local output] System call to launch all workers:
[17:43:54.124] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphqPkhL/worker.rank=1.parallelly.parent=28742.704668e6b94b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11590 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:54.124] [local output] Starting PSOCK main server
[17:43:54.129] [local output] Workers launched
[17:43:54.130] [local output] Waiting for workers to connect back
[17:43:54.130]  - [local output] 0 workers out of 2 ready
[17:43:54.372]  - [local output] 0 workers out of 2 ready
[17:43:54.373]  - [local output] 1 workers out of 2 ready
[17:43:54.373]  - [local output] 2 workers out of 2 ready
[17:43:54.373] [local output] Launching of workers completed
[17:43:54.373] [local output] Collecting session information from workers
[17:43:54.374] [local output]  - Worker #1 of 2
[17:43:54.374] [local output]  - Worker #2 of 2
[17:43:54.375] [local output] makeClusterPSOCK() ... done
[17:43:54.386] Packages needed by the future expression (n = 0): <none>
[17:43:54.386] Packages needed by future strategies (n = 0): <none>
[17:43:54.387] {
[17:43:54.387]     {
[17:43:54.387]         {
[17:43:54.387]             ...future.startTime <- base::Sys.time()
[17:43:54.387]             {
[17:43:54.387]                 {
[17:43:54.387]                   {
[17:43:54.387]                     {
[17:43:54.387]                       base::local({
[17:43:54.387]                         has_future <- base::requireNamespace("future", 
[17:43:54.387]                           quietly = TRUE)
[17:43:54.387]                         if (has_future) {
[17:43:54.387]                           ns <- base::getNamespace("future")
[17:43:54.387]                           version <- ns[[".package"]][["version"]]
[17:43:54.387]                           if (is.null(version)) 
[17:43:54.387]                             version <- utils::packageVersion("future")
[17:43:54.387]                         }
[17:43:54.387]                         else {
[17:43:54.387]                           version <- NULL
[17:43:54.387]                         }
[17:43:54.387]                         if (!has_future || version < "1.8.0") {
[17:43:54.387]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.387]                             "", base::R.version$version.string), 
[17:43:54.387]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.387]                               "release", "version")], collapse = " "), 
[17:43:54.387]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.387]                             info)
[17:43:54.387]                           info <- base::paste(info, collapse = "; ")
[17:43:54.387]                           if (!has_future) {
[17:43:54.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.387]                               info)
[17:43:54.387]                           }
[17:43:54.387]                           else {
[17:43:54.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.387]                               info, version)
[17:43:54.387]                           }
[17:43:54.387]                           base::stop(msg)
[17:43:54.387]                         }
[17:43:54.387]                       })
[17:43:54.387]                     }
[17:43:54.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.387]                     base::options(mc.cores = 1L)
[17:43:54.387]                   }
[17:43:54.387]                   ...future.strategy.old <- future::plan("list")
[17:43:54.387]                   options(future.plan = NULL)
[17:43:54.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.387]                 }
[17:43:54.387]                 ...future.workdir <- getwd()
[17:43:54.387]             }
[17:43:54.387]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.387]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.387]         }
[17:43:54.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.387]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.387]             base::names(...future.oldOptions))
[17:43:54.387]     }
[17:43:54.387]     if (FALSE) {
[17:43:54.387]     }
[17:43:54.387]     else {
[17:43:54.387]         if (TRUE) {
[17:43:54.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.387]                 open = "w")
[17:43:54.387]         }
[17:43:54.387]         else {
[17:43:54.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.387]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.387]         }
[17:43:54.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.387]             base::sink(type = "output", split = FALSE)
[17:43:54.387]             base::close(...future.stdout)
[17:43:54.387]         }, add = TRUE)
[17:43:54.387]     }
[17:43:54.387]     ...future.frame <- base::sys.nframe()
[17:43:54.387]     ...future.conditions <- base::list()
[17:43:54.387]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.387]     if (FALSE) {
[17:43:54.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.387]     }
[17:43:54.387]     ...future.result <- base::tryCatch({
[17:43:54.387]         base::withCallingHandlers({
[17:43:54.387]             ...future.value <- base::withVisible(base::local({
[17:43:54.387]                 ...future.makeSendCondition <- base::local({
[17:43:54.387]                   sendCondition <- NULL
[17:43:54.387]                   function(frame = 1L) {
[17:43:54.387]                     if (is.function(sendCondition)) 
[17:43:54.387]                       return(sendCondition)
[17:43:54.387]                     ns <- getNamespace("parallel")
[17:43:54.387]                     if (exists("sendData", mode = "function", 
[17:43:54.387]                       envir = ns)) {
[17:43:54.387]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.387]                         envir = ns)
[17:43:54.387]                       envir <- sys.frame(frame)
[17:43:54.387]                       master <- NULL
[17:43:54.387]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.387]                         !identical(envir, emptyenv())) {
[17:43:54.387]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.387]                           inherits = FALSE)) {
[17:43:54.387]                           master <- get("master", mode = "list", 
[17:43:54.387]                             envir = envir, inherits = FALSE)
[17:43:54.387]                           if (inherits(master, c("SOCKnode", 
[17:43:54.387]                             "SOCK0node"))) {
[17:43:54.387]                             sendCondition <<- function(cond) {
[17:43:54.387]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.387]                                 success = TRUE)
[17:43:54.387]                               parallel_sendData(master, data)
[17:43:54.387]                             }
[17:43:54.387]                             return(sendCondition)
[17:43:54.387]                           }
[17:43:54.387]                         }
[17:43:54.387]                         frame <- frame + 1L
[17:43:54.387]                         envir <- sys.frame(frame)
[17:43:54.387]                       }
[17:43:54.387]                     }
[17:43:54.387]                     sendCondition <<- function(cond) NULL
[17:43:54.387]                   }
[17:43:54.387]                 })
[17:43:54.387]                 withCallingHandlers({
[17:43:54.387]                   NA
[17:43:54.387]                 }, immediateCondition = function(cond) {
[17:43:54.387]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.387]                   sendCondition(cond)
[17:43:54.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.387]                   {
[17:43:54.387]                     inherits <- base::inherits
[17:43:54.387]                     invokeRestart <- base::invokeRestart
[17:43:54.387]                     is.null <- base::is.null
[17:43:54.387]                     muffled <- FALSE
[17:43:54.387]                     if (inherits(cond, "message")) {
[17:43:54.387]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.387]                       if (muffled) 
[17:43:54.387]                         invokeRestart("muffleMessage")
[17:43:54.387]                     }
[17:43:54.387]                     else if (inherits(cond, "warning")) {
[17:43:54.387]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.387]                       if (muffled) 
[17:43:54.387]                         invokeRestart("muffleWarning")
[17:43:54.387]                     }
[17:43:54.387]                     else if (inherits(cond, "condition")) {
[17:43:54.387]                       if (!is.null(pattern)) {
[17:43:54.387]                         computeRestarts <- base::computeRestarts
[17:43:54.387]                         grepl <- base::grepl
[17:43:54.387]                         restarts <- computeRestarts(cond)
[17:43:54.387]                         for (restart in restarts) {
[17:43:54.387]                           name <- restart$name
[17:43:54.387]                           if (is.null(name)) 
[17:43:54.387]                             next
[17:43:54.387]                           if (!grepl(pattern, name)) 
[17:43:54.387]                             next
[17:43:54.387]                           invokeRestart(restart)
[17:43:54.387]                           muffled <- TRUE
[17:43:54.387]                           break
[17:43:54.387]                         }
[17:43:54.387]                       }
[17:43:54.387]                     }
[17:43:54.387]                     invisible(muffled)
[17:43:54.387]                   }
[17:43:54.387]                   muffleCondition(cond)
[17:43:54.387]                 })
[17:43:54.387]             }))
[17:43:54.387]             future::FutureResult(value = ...future.value$value, 
[17:43:54.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.387]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.387]                     ...future.globalenv.names))
[17:43:54.387]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.387]         }, condition = base::local({
[17:43:54.387]             c <- base::c
[17:43:54.387]             inherits <- base::inherits
[17:43:54.387]             invokeRestart <- base::invokeRestart
[17:43:54.387]             length <- base::length
[17:43:54.387]             list <- base::list
[17:43:54.387]             seq.int <- base::seq.int
[17:43:54.387]             signalCondition <- base::signalCondition
[17:43:54.387]             sys.calls <- base::sys.calls
[17:43:54.387]             `[[` <- base::`[[`
[17:43:54.387]             `+` <- base::`+`
[17:43:54.387]             `<<-` <- base::`<<-`
[17:43:54.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.387]                   3L)]
[17:43:54.387]             }
[17:43:54.387]             function(cond) {
[17:43:54.387]                 is_error <- inherits(cond, "error")
[17:43:54.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.387]                   NULL)
[17:43:54.387]                 if (is_error) {
[17:43:54.387]                   sessionInformation <- function() {
[17:43:54.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.387]                       search = base::search(), system = base::Sys.info())
[17:43:54.387]                   }
[17:43:54.387]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.387]                     cond$call), session = sessionInformation(), 
[17:43:54.387]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.387]                   signalCondition(cond)
[17:43:54.387]                 }
[17:43:54.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.387]                 "immediateCondition"))) {
[17:43:54.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.387]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.387]                   if (TRUE && !signal) {
[17:43:54.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.387]                     {
[17:43:54.387]                       inherits <- base::inherits
[17:43:54.387]                       invokeRestart <- base::invokeRestart
[17:43:54.387]                       is.null <- base::is.null
[17:43:54.387]                       muffled <- FALSE
[17:43:54.387]                       if (inherits(cond, "message")) {
[17:43:54.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.387]                         if (muffled) 
[17:43:54.387]                           invokeRestart("muffleMessage")
[17:43:54.387]                       }
[17:43:54.387]                       else if (inherits(cond, "warning")) {
[17:43:54.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.387]                         if (muffled) 
[17:43:54.387]                           invokeRestart("muffleWarning")
[17:43:54.387]                       }
[17:43:54.387]                       else if (inherits(cond, "condition")) {
[17:43:54.387]                         if (!is.null(pattern)) {
[17:43:54.387]                           computeRestarts <- base::computeRestarts
[17:43:54.387]                           grepl <- base::grepl
[17:43:54.387]                           restarts <- computeRestarts(cond)
[17:43:54.387]                           for (restart in restarts) {
[17:43:54.387]                             name <- restart$name
[17:43:54.387]                             if (is.null(name)) 
[17:43:54.387]                               next
[17:43:54.387]                             if (!grepl(pattern, name)) 
[17:43:54.387]                               next
[17:43:54.387]                             invokeRestart(restart)
[17:43:54.387]                             muffled <- TRUE
[17:43:54.387]                             break
[17:43:54.387]                           }
[17:43:54.387]                         }
[17:43:54.387]                       }
[17:43:54.387]                       invisible(muffled)
[17:43:54.387]                     }
[17:43:54.387]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.387]                   }
[17:43:54.387]                 }
[17:43:54.387]                 else {
[17:43:54.387]                   if (TRUE) {
[17:43:54.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.387]                     {
[17:43:54.387]                       inherits <- base::inherits
[17:43:54.387]                       invokeRestart <- base::invokeRestart
[17:43:54.387]                       is.null <- base::is.null
[17:43:54.387]                       muffled <- FALSE
[17:43:54.387]                       if (inherits(cond, "message")) {
[17:43:54.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.387]                         if (muffled) 
[17:43:54.387]                           invokeRestart("muffleMessage")
[17:43:54.387]                       }
[17:43:54.387]                       else if (inherits(cond, "warning")) {
[17:43:54.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.387]                         if (muffled) 
[17:43:54.387]                           invokeRestart("muffleWarning")
[17:43:54.387]                       }
[17:43:54.387]                       else if (inherits(cond, "condition")) {
[17:43:54.387]                         if (!is.null(pattern)) {
[17:43:54.387]                           computeRestarts <- base::computeRestarts
[17:43:54.387]                           grepl <- base::grepl
[17:43:54.387]                           restarts <- computeRestarts(cond)
[17:43:54.387]                           for (restart in restarts) {
[17:43:54.387]                             name <- restart$name
[17:43:54.387]                             if (is.null(name)) 
[17:43:54.387]                               next
[17:43:54.387]                             if (!grepl(pattern, name)) 
[17:43:54.387]                               next
[17:43:54.387]                             invokeRestart(restart)
[17:43:54.387]                             muffled <- TRUE
[17:43:54.387]                             break
[17:43:54.387]                           }
[17:43:54.387]                         }
[17:43:54.387]                       }
[17:43:54.387]                       invisible(muffled)
[17:43:54.387]                     }
[17:43:54.387]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.387]                   }
[17:43:54.387]                 }
[17:43:54.387]             }
[17:43:54.387]         }))
[17:43:54.387]     }, error = function(ex) {
[17:43:54.387]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.387]                 ...future.rng), started = ...future.startTime, 
[17:43:54.387]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.387]             version = "1.8"), class = "FutureResult")
[17:43:54.387]     }, finally = {
[17:43:54.387]         if (!identical(...future.workdir, getwd())) 
[17:43:54.387]             setwd(...future.workdir)
[17:43:54.387]         {
[17:43:54.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.387]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.387]             }
[17:43:54.387]             base::options(...future.oldOptions)
[17:43:54.387]             if (.Platform$OS.type == "windows") {
[17:43:54.387]                 old_names <- names(...future.oldEnvVars)
[17:43:54.387]                 envs <- base::Sys.getenv()
[17:43:54.387]                 names <- names(envs)
[17:43:54.387]                 common <- intersect(names, old_names)
[17:43:54.387]                 added <- setdiff(names, old_names)
[17:43:54.387]                 removed <- setdiff(old_names, names)
[17:43:54.387]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.387]                   envs[common]]
[17:43:54.387]                 NAMES <- toupper(changed)
[17:43:54.387]                 args <- list()
[17:43:54.387]                 for (kk in seq_along(NAMES)) {
[17:43:54.387]                   name <- changed[[kk]]
[17:43:54.387]                   NAME <- NAMES[[kk]]
[17:43:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.387]                     next
[17:43:54.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.387]                 }
[17:43:54.387]                 NAMES <- toupper(added)
[17:43:54.387]                 for (kk in seq_along(NAMES)) {
[17:43:54.387]                   name <- added[[kk]]
[17:43:54.387]                   NAME <- NAMES[[kk]]
[17:43:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.387]                     next
[17:43:54.387]                   args[[name]] <- ""
[17:43:54.387]                 }
[17:43:54.387]                 NAMES <- toupper(removed)
[17:43:54.387]                 for (kk in seq_along(NAMES)) {
[17:43:54.387]                   name <- removed[[kk]]
[17:43:54.387]                   NAME <- NAMES[[kk]]
[17:43:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.387]                     next
[17:43:54.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.387]                 }
[17:43:54.387]                 if (length(args) > 0) 
[17:43:54.387]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.387]             }
[17:43:54.387]             else {
[17:43:54.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.387]             }
[17:43:54.387]             {
[17:43:54.387]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.387]                   0L) {
[17:43:54.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.387]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.387]                   base::options(opts)
[17:43:54.387]                 }
[17:43:54.387]                 {
[17:43:54.387]                   {
[17:43:54.387]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.387]                     NULL
[17:43:54.387]                   }
[17:43:54.387]                   options(future.plan = NULL)
[17:43:54.387]                   if (is.na(NA_character_)) 
[17:43:54.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.387]                     .init = FALSE)
[17:43:54.387]                 }
[17:43:54.387]             }
[17:43:54.387]         }
[17:43:54.387]     })
[17:43:54.387]     if (TRUE) {
[17:43:54.387]         base::sink(type = "output", split = FALSE)
[17:43:54.387]         if (TRUE) {
[17:43:54.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.387]         }
[17:43:54.387]         else {
[17:43:54.387]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.387]         }
[17:43:54.387]         base::close(...future.stdout)
[17:43:54.387]         ...future.stdout <- NULL
[17:43:54.387]     }
[17:43:54.387]     ...future.result$conditions <- ...future.conditions
[17:43:54.387]     ...future.result$finished <- base::Sys.time()
[17:43:54.387]     ...future.result
[17:43:54.387] }
[17:43:54.439] MultisessionFuture started
[17:43:54.439] result() for ClusterFuture ...
[17:43:54.440] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.440] - Validating connection of MultisessionFuture
[17:43:54.471] - received message: FutureResult
[17:43:54.472] - Received FutureResult
[17:43:54.472] - Erased future from FutureRegistry
[17:43:54.472] result() for ClusterFuture ...
[17:43:54.472] - result already collected: FutureResult
[17:43:54.472] result() for ClusterFuture ... done
[17:43:54.472] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.472] result() for ClusterFuture ... done
[17:43:54.472] result() for ClusterFuture ...
[17:43:54.473] - result already collected: FutureResult
[17:43:54.473] result() for ClusterFuture ... done
[17:43:54.473] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:54.477] plan(): nbrOfWorkers() = 2
[17:43:54.477] future_by_internal() ...
[17:43:54.477] future_lapply() ...
[17:43:54.481] Number of chunks: 2
[17:43:54.482] getGlobalsAndPackagesXApply() ...
[17:43:54.482]  - future.globals: TRUE
[17:43:54.482] getGlobalsAndPackages() ...
[17:43:54.482] Searching for globals...
[17:43:54.483] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:54.483] Searching for globals ... DONE
[17:43:54.484] Resolving globals: FALSE
[17:43:54.484] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:54.484] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:54.484] - globals: [1] ‘FUN’
[17:43:54.485] 
[17:43:54.485] getGlobalsAndPackages() ... DONE
[17:43:54.485]  - globals found/used: [n=1] ‘FUN’
[17:43:54.485]  - needed namespaces: [n=0] 
[17:43:54.485] Finding globals ... DONE
[17:43:54.485]  - use_args: TRUE
[17:43:54.485]  - Getting '...' globals ...
[17:43:54.486] resolve() on list ...
[17:43:54.486]  recursive: 0
[17:43:54.486]  length: 1
[17:43:54.486]  elements: ‘...’
[17:43:54.486]  length: 0 (resolved future 1)
[17:43:54.486] resolve() on list ... DONE
[17:43:54.486]    - '...' content: [n=0] 
[17:43:54.487] List of 1
[17:43:54.487]  $ ...: list()
[17:43:54.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.487]  - attr(*, "where")=List of 1
[17:43:54.487]   ..$ ...:<environment: 0x55d6bc1a94c8> 
[17:43:54.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.487]  - attr(*, "resolved")= logi TRUE
[17:43:54.487]  - attr(*, "total_size")= num NA
[17:43:54.490]  - Getting '...' globals ... DONE
[17:43:54.490] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:54.490] List of 2
[17:43:54.490]  $ ...future.FUN:function (object, ...)  
[17:43:54.490]  $ ...          : list()
[17:43:54.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.490]  - attr(*, "where")=List of 2
[17:43:54.490]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:54.490]   ..$ ...          :<environment: 0x55d6bc1a94c8> 
[17:43:54.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.490]  - attr(*, "resolved")= logi FALSE
[17:43:54.490]  - attr(*, "total_size")= num 1240
[17:43:54.493] Packages to be attached in all futures: [n=0] 
[17:43:54.493] getGlobalsAndPackagesXApply() ... DONE
[17:43:54.494] Number of futures (= number of chunks): 2
[17:43:54.494] Launching 2 futures (chunks) ...
[17:43:54.494] Chunk #1 of 2 ...
[17:43:54.494]  - Finding globals in 'X' for chunk #1 ...
[17:43:54.494] getGlobalsAndPackages() ...
[17:43:54.494] Searching for globals...
[17:43:54.495] 
[17:43:54.495] Searching for globals ... DONE
[17:43:54.495] - globals: [0] <none>
[17:43:54.495] getGlobalsAndPackages() ... DONE
[17:43:54.495]    + additional globals found: [n=0] 
[17:43:54.495]    + additional namespaces needed: [n=0] 
[17:43:54.495]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:54.496]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.496]  - seeds: <none>
[17:43:54.496]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.496] getGlobalsAndPackages() ...
[17:43:54.496] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.496] Resolving globals: FALSE
[17:43:54.496] Tweak future expression to call with '...' arguments ...
[17:43:54.496] {
[17:43:54.496]     do.call(function(...) {
[17:43:54.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.496]             on.exit(options(oopts), add = TRUE)
[17:43:54.496]         }
[17:43:54.496]         {
[17:43:54.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.496]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.496]             })
[17:43:54.496]         }
[17:43:54.496]     }, args = future.call.arguments)
[17:43:54.496] }
[17:43:54.497] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.497] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.497] 
[17:43:54.497] getGlobalsAndPackages() ... DONE
[17:43:54.498] run() for ‘Future’ ...
[17:43:54.498] - state: ‘created’
[17:43:54.498] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.513] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.513]   - Field: ‘node’
[17:43:54.513]   - Field: ‘label’
[17:43:54.513]   - Field: ‘local’
[17:43:54.513]   - Field: ‘owner’
[17:43:54.513]   - Field: ‘envir’
[17:43:54.513]   - Field: ‘workers’
[17:43:54.513]   - Field: ‘packages’
[17:43:54.514]   - Field: ‘gc’
[17:43:54.514]   - Field: ‘conditions’
[17:43:54.514]   - Field: ‘persistent’
[17:43:54.514]   - Field: ‘expr’
[17:43:54.514]   - Field: ‘uuid’
[17:43:54.514]   - Field: ‘seed’
[17:43:54.514]   - Field: ‘version’
[17:43:54.514]   - Field: ‘result’
[17:43:54.514]   - Field: ‘asynchronous’
[17:43:54.515]   - Field: ‘calls’
[17:43:54.515]   - Field: ‘globals’
[17:43:54.515]   - Field: ‘stdout’
[17:43:54.515]   - Field: ‘earlySignal’
[17:43:54.515]   - Field: ‘lazy’
[17:43:54.515]   - Field: ‘state’
[17:43:54.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.515] - Launch lazy future ...
[17:43:54.516] Packages needed by the future expression (n = 0): <none>
[17:43:54.516] Packages needed by future strategies (n = 0): <none>
[17:43:54.516] {
[17:43:54.516]     {
[17:43:54.516]         {
[17:43:54.516]             ...future.startTime <- base::Sys.time()
[17:43:54.516]             {
[17:43:54.516]                 {
[17:43:54.516]                   {
[17:43:54.516]                     {
[17:43:54.516]                       base::local({
[17:43:54.516]                         has_future <- base::requireNamespace("future", 
[17:43:54.516]                           quietly = TRUE)
[17:43:54.516]                         if (has_future) {
[17:43:54.516]                           ns <- base::getNamespace("future")
[17:43:54.516]                           version <- ns[[".package"]][["version"]]
[17:43:54.516]                           if (is.null(version)) 
[17:43:54.516]                             version <- utils::packageVersion("future")
[17:43:54.516]                         }
[17:43:54.516]                         else {
[17:43:54.516]                           version <- NULL
[17:43:54.516]                         }
[17:43:54.516]                         if (!has_future || version < "1.8.0") {
[17:43:54.516]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.516]                             "", base::R.version$version.string), 
[17:43:54.516]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.516]                               "release", "version")], collapse = " "), 
[17:43:54.516]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.516]                             info)
[17:43:54.516]                           info <- base::paste(info, collapse = "; ")
[17:43:54.516]                           if (!has_future) {
[17:43:54.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.516]                               info)
[17:43:54.516]                           }
[17:43:54.516]                           else {
[17:43:54.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.516]                               info, version)
[17:43:54.516]                           }
[17:43:54.516]                           base::stop(msg)
[17:43:54.516]                         }
[17:43:54.516]                       })
[17:43:54.516]                     }
[17:43:54.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.516]                     base::options(mc.cores = 1L)
[17:43:54.516]                   }
[17:43:54.516]                   ...future.strategy.old <- future::plan("list")
[17:43:54.516]                   options(future.plan = NULL)
[17:43:54.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.516]                 }
[17:43:54.516]                 ...future.workdir <- getwd()
[17:43:54.516]             }
[17:43:54.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.516]         }
[17:43:54.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.516]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:54.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.516]             base::names(...future.oldOptions))
[17:43:54.516]     }
[17:43:54.516]     if (FALSE) {
[17:43:54.516]     }
[17:43:54.516]     else {
[17:43:54.516]         if (TRUE) {
[17:43:54.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.516]                 open = "w")
[17:43:54.516]         }
[17:43:54.516]         else {
[17:43:54.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.516]         }
[17:43:54.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.516]             base::sink(type = "output", split = FALSE)
[17:43:54.516]             base::close(...future.stdout)
[17:43:54.516]         }, add = TRUE)
[17:43:54.516]     }
[17:43:54.516]     ...future.frame <- base::sys.nframe()
[17:43:54.516]     ...future.conditions <- base::list()
[17:43:54.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.516]     if (FALSE) {
[17:43:54.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.516]     }
[17:43:54.516]     ...future.result <- base::tryCatch({
[17:43:54.516]         base::withCallingHandlers({
[17:43:54.516]             ...future.value <- base::withVisible(base::local({
[17:43:54.516]                 ...future.makeSendCondition <- base::local({
[17:43:54.516]                   sendCondition <- NULL
[17:43:54.516]                   function(frame = 1L) {
[17:43:54.516]                     if (is.function(sendCondition)) 
[17:43:54.516]                       return(sendCondition)
[17:43:54.516]                     ns <- getNamespace("parallel")
[17:43:54.516]                     if (exists("sendData", mode = "function", 
[17:43:54.516]                       envir = ns)) {
[17:43:54.516]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.516]                         envir = ns)
[17:43:54.516]                       envir <- sys.frame(frame)
[17:43:54.516]                       master <- NULL
[17:43:54.516]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.516]                         !identical(envir, emptyenv())) {
[17:43:54.516]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.516]                           inherits = FALSE)) {
[17:43:54.516]                           master <- get("master", mode = "list", 
[17:43:54.516]                             envir = envir, inherits = FALSE)
[17:43:54.516]                           if (inherits(master, c("SOCKnode", 
[17:43:54.516]                             "SOCK0node"))) {
[17:43:54.516]                             sendCondition <<- function(cond) {
[17:43:54.516]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.516]                                 success = TRUE)
[17:43:54.516]                               parallel_sendData(master, data)
[17:43:54.516]                             }
[17:43:54.516]                             return(sendCondition)
[17:43:54.516]                           }
[17:43:54.516]                         }
[17:43:54.516]                         frame <- frame + 1L
[17:43:54.516]                         envir <- sys.frame(frame)
[17:43:54.516]                       }
[17:43:54.516]                     }
[17:43:54.516]                     sendCondition <<- function(cond) NULL
[17:43:54.516]                   }
[17:43:54.516]                 })
[17:43:54.516]                 withCallingHandlers({
[17:43:54.516]                   {
[17:43:54.516]                     do.call(function(...) {
[17:43:54.516]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.516]                       if (!identical(...future.globals.maxSize.org, 
[17:43:54.516]                         ...future.globals.maxSize)) {
[17:43:54.516]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.516]                         on.exit(options(oopts), add = TRUE)
[17:43:54.516]                       }
[17:43:54.516]                       {
[17:43:54.516]                         lapply(seq_along(...future.elements_ii), 
[17:43:54.516]                           FUN = function(jj) {
[17:43:54.516]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.516]                             ...future.FUN(...future.X_jj, ...)
[17:43:54.516]                           })
[17:43:54.516]                       }
[17:43:54.516]                     }, args = future.call.arguments)
[17:43:54.516]                   }
[17:43:54.516]                 }, immediateCondition = function(cond) {
[17:43:54.516]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.516]                   sendCondition(cond)
[17:43:54.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.516]                   {
[17:43:54.516]                     inherits <- base::inherits
[17:43:54.516]                     invokeRestart <- base::invokeRestart
[17:43:54.516]                     is.null <- base::is.null
[17:43:54.516]                     muffled <- FALSE
[17:43:54.516]                     if (inherits(cond, "message")) {
[17:43:54.516]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.516]                       if (muffled) 
[17:43:54.516]                         invokeRestart("muffleMessage")
[17:43:54.516]                     }
[17:43:54.516]                     else if (inherits(cond, "warning")) {
[17:43:54.516]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.516]                       if (muffled) 
[17:43:54.516]                         invokeRestart("muffleWarning")
[17:43:54.516]                     }
[17:43:54.516]                     else if (inherits(cond, "condition")) {
[17:43:54.516]                       if (!is.null(pattern)) {
[17:43:54.516]                         computeRestarts <- base::computeRestarts
[17:43:54.516]                         grepl <- base::grepl
[17:43:54.516]                         restarts <- computeRestarts(cond)
[17:43:54.516]                         for (restart in restarts) {
[17:43:54.516]                           name <- restart$name
[17:43:54.516]                           if (is.null(name)) 
[17:43:54.516]                             next
[17:43:54.516]                           if (!grepl(pattern, name)) 
[17:43:54.516]                             next
[17:43:54.516]                           invokeRestart(restart)
[17:43:54.516]                           muffled <- TRUE
[17:43:54.516]                           break
[17:43:54.516]                         }
[17:43:54.516]                       }
[17:43:54.516]                     }
[17:43:54.516]                     invisible(muffled)
[17:43:54.516]                   }
[17:43:54.516]                   muffleCondition(cond)
[17:43:54.516]                 })
[17:43:54.516]             }))
[17:43:54.516]             future::FutureResult(value = ...future.value$value, 
[17:43:54.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.516]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.516]                     ...future.globalenv.names))
[17:43:54.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.516]         }, condition = base::local({
[17:43:54.516]             c <- base::c
[17:43:54.516]             inherits <- base::inherits
[17:43:54.516]             invokeRestart <- base::invokeRestart
[17:43:54.516]             length <- base::length
[17:43:54.516]             list <- base::list
[17:43:54.516]             seq.int <- base::seq.int
[17:43:54.516]             signalCondition <- base::signalCondition
[17:43:54.516]             sys.calls <- base::sys.calls
[17:43:54.516]             `[[` <- base::`[[`
[17:43:54.516]             `+` <- base::`+`
[17:43:54.516]             `<<-` <- base::`<<-`
[17:43:54.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.516]                   3L)]
[17:43:54.516]             }
[17:43:54.516]             function(cond) {
[17:43:54.516]                 is_error <- inherits(cond, "error")
[17:43:54.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.516]                   NULL)
[17:43:54.516]                 if (is_error) {
[17:43:54.516]                   sessionInformation <- function() {
[17:43:54.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.516]                       search = base::search(), system = base::Sys.info())
[17:43:54.516]                   }
[17:43:54.516]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.516]                     cond$call), session = sessionInformation(), 
[17:43:54.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.516]                   signalCondition(cond)
[17:43:54.516]                 }
[17:43:54.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.516]                 "immediateCondition"))) {
[17:43:54.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.516]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.516]                   if (TRUE && !signal) {
[17:43:54.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.516]                     {
[17:43:54.516]                       inherits <- base::inherits
[17:43:54.516]                       invokeRestart <- base::invokeRestart
[17:43:54.516]                       is.null <- base::is.null
[17:43:54.516]                       muffled <- FALSE
[17:43:54.516]                       if (inherits(cond, "message")) {
[17:43:54.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.516]                         if (muffled) 
[17:43:54.516]                           invokeRestart("muffleMessage")
[17:43:54.516]                       }
[17:43:54.516]                       else if (inherits(cond, "warning")) {
[17:43:54.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.516]                         if (muffled) 
[17:43:54.516]                           invokeRestart("muffleWarning")
[17:43:54.516]                       }
[17:43:54.516]                       else if (inherits(cond, "condition")) {
[17:43:54.516]                         if (!is.null(pattern)) {
[17:43:54.516]                           computeRestarts <- base::computeRestarts
[17:43:54.516]                           grepl <- base::grepl
[17:43:54.516]                           restarts <- computeRestarts(cond)
[17:43:54.516]                           for (restart in restarts) {
[17:43:54.516]                             name <- restart$name
[17:43:54.516]                             if (is.null(name)) 
[17:43:54.516]                               next
[17:43:54.516]                             if (!grepl(pattern, name)) 
[17:43:54.516]                               next
[17:43:54.516]                             invokeRestart(restart)
[17:43:54.516]                             muffled <- TRUE
[17:43:54.516]                             break
[17:43:54.516]                           }
[17:43:54.516]                         }
[17:43:54.516]                       }
[17:43:54.516]                       invisible(muffled)
[17:43:54.516]                     }
[17:43:54.516]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.516]                   }
[17:43:54.516]                 }
[17:43:54.516]                 else {
[17:43:54.516]                   if (TRUE) {
[17:43:54.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.516]                     {
[17:43:54.516]                       inherits <- base::inherits
[17:43:54.516]                       invokeRestart <- base::invokeRestart
[17:43:54.516]                       is.null <- base::is.null
[17:43:54.516]                       muffled <- FALSE
[17:43:54.516]                       if (inherits(cond, "message")) {
[17:43:54.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.516]                         if (muffled) 
[17:43:54.516]                           invokeRestart("muffleMessage")
[17:43:54.516]                       }
[17:43:54.516]                       else if (inherits(cond, "warning")) {
[17:43:54.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.516]                         if (muffled) 
[17:43:54.516]                           invokeRestart("muffleWarning")
[17:43:54.516]                       }
[17:43:54.516]                       else if (inherits(cond, "condition")) {
[17:43:54.516]                         if (!is.null(pattern)) {
[17:43:54.516]                           computeRestarts <- base::computeRestarts
[17:43:54.516]                           grepl <- base::grepl
[17:43:54.516]                           restarts <- computeRestarts(cond)
[17:43:54.516]                           for (restart in restarts) {
[17:43:54.516]                             name <- restart$name
[17:43:54.516]                             if (is.null(name)) 
[17:43:54.516]                               next
[17:43:54.516]                             if (!grepl(pattern, name)) 
[17:43:54.516]                               next
[17:43:54.516]                             invokeRestart(restart)
[17:43:54.516]                             muffled <- TRUE
[17:43:54.516]                             break
[17:43:54.516]                           }
[17:43:54.516]                         }
[17:43:54.516]                       }
[17:43:54.516]                       invisible(muffled)
[17:43:54.516]                     }
[17:43:54.516]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.516]                   }
[17:43:54.516]                 }
[17:43:54.516]             }
[17:43:54.516]         }))
[17:43:54.516]     }, error = function(ex) {
[17:43:54.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.516]                 ...future.rng), started = ...future.startTime, 
[17:43:54.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.516]             version = "1.8"), class = "FutureResult")
[17:43:54.516]     }, finally = {
[17:43:54.516]         if (!identical(...future.workdir, getwd())) 
[17:43:54.516]             setwd(...future.workdir)
[17:43:54.516]         {
[17:43:54.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.516]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.516]             }
[17:43:54.516]             base::options(...future.oldOptions)
[17:43:54.516]             if (.Platform$OS.type == "windows") {
[17:43:54.516]                 old_names <- names(...future.oldEnvVars)
[17:43:54.516]                 envs <- base::Sys.getenv()
[17:43:54.516]                 names <- names(envs)
[17:43:54.516]                 common <- intersect(names, old_names)
[17:43:54.516]                 added <- setdiff(names, old_names)
[17:43:54.516]                 removed <- setdiff(old_names, names)
[17:43:54.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.516]                   envs[common]]
[17:43:54.516]                 NAMES <- toupper(changed)
[17:43:54.516]                 args <- list()
[17:43:54.516]                 for (kk in seq_along(NAMES)) {
[17:43:54.516]                   name <- changed[[kk]]
[17:43:54.516]                   NAME <- NAMES[[kk]]
[17:43:54.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.516]                     next
[17:43:54.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.516]                 }
[17:43:54.516]                 NAMES <- toupper(added)
[17:43:54.516]                 for (kk in seq_along(NAMES)) {
[17:43:54.516]                   name <- added[[kk]]
[17:43:54.516]                   NAME <- NAMES[[kk]]
[17:43:54.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.516]                     next
[17:43:54.516]                   args[[name]] <- ""
[17:43:54.516]                 }
[17:43:54.516]                 NAMES <- toupper(removed)
[17:43:54.516]                 for (kk in seq_along(NAMES)) {
[17:43:54.516]                   name <- removed[[kk]]
[17:43:54.516]                   NAME <- NAMES[[kk]]
[17:43:54.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.516]                     next
[17:43:54.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.516]                 }
[17:43:54.516]                 if (length(args) > 0) 
[17:43:54.516]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.516]             }
[17:43:54.516]             else {
[17:43:54.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.516]             }
[17:43:54.516]             {
[17:43:54.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.516]                   0L) {
[17:43:54.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.516]                   base::options(opts)
[17:43:54.516]                 }
[17:43:54.516]                 {
[17:43:54.516]                   {
[17:43:54.516]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.516]                     NULL
[17:43:54.516]                   }
[17:43:54.516]                   options(future.plan = NULL)
[17:43:54.516]                   if (is.na(NA_character_)) 
[17:43:54.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.516]                     .init = FALSE)
[17:43:54.516]                 }
[17:43:54.516]             }
[17:43:54.516]         }
[17:43:54.516]     })
[17:43:54.516]     if (TRUE) {
[17:43:54.516]         base::sink(type = "output", split = FALSE)
[17:43:54.516]         if (TRUE) {
[17:43:54.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.516]         }
[17:43:54.516]         else {
[17:43:54.516]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.516]         }
[17:43:54.516]         base::close(...future.stdout)
[17:43:54.516]         ...future.stdout <- NULL
[17:43:54.516]     }
[17:43:54.516]     ...future.result$conditions <- ...future.conditions
[17:43:54.516]     ...future.result$finished <- base::Sys.time()
[17:43:54.516]     ...future.result
[17:43:54.516] }
[17:43:54.519] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:43:54.520] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:43:54.520] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:43:54.520] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:54.521] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.521] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[17:43:54.521] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[17:43:54.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:54.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:54.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.523] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:43:54.523] MultisessionFuture started
[17:43:54.524] - Launch lazy future ... done
[17:43:54.524] run() for ‘MultisessionFuture’ ... done
[17:43:54.524] Created future:
[17:43:54.524] MultisessionFuture:
[17:43:54.524] Label: ‘future_by-1’
[17:43:54.524] Expression:
[17:43:54.524] {
[17:43:54.524]     do.call(function(...) {
[17:43:54.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.524]             on.exit(options(oopts), add = TRUE)
[17:43:54.524]         }
[17:43:54.524]         {
[17:43:54.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.524]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.524]             })
[17:43:54.524]         }
[17:43:54.524]     }, args = future.call.arguments)
[17:43:54.524] }
[17:43:54.524] Lazy evaluation: FALSE
[17:43:54.524] Asynchronous evaluation: TRUE
[17:43:54.524] Local evaluation: TRUE
[17:43:54.524] Environment: R_GlobalEnv
[17:43:54.524] Capture standard output: TRUE
[17:43:54.524] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:54.524] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:54.524] Packages: <none>
[17:43:54.524] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:54.524] Resolved: FALSE
[17:43:54.524] Value: <not collected>
[17:43:54.524] Conditions captured: <none>
[17:43:54.524] Early signaling: FALSE
[17:43:54.524] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:54.524] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.536] Chunk #1 of 2 ... DONE
[17:43:54.536] Chunk #2 of 2 ...
[17:43:54.536]  - Finding globals in 'X' for chunk #2 ...
[17:43:54.536] getGlobalsAndPackages() ...
[17:43:54.537] Searching for globals...
[17:43:54.537] 
[17:43:54.537] Searching for globals ... DONE
[17:43:54.537] - globals: [0] <none>
[17:43:54.537] getGlobalsAndPackages() ... DONE
[17:43:54.538]    + additional globals found: [n=0] 
[17:43:54.538]    + additional namespaces needed: [n=0] 
[17:43:54.538]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:54.538]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.538]  - seeds: <none>
[17:43:54.538]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.538] getGlobalsAndPackages() ...
[17:43:54.538] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.538] Resolving globals: FALSE
[17:43:54.539] Tweak future expression to call with '...' arguments ...
[17:43:54.539] {
[17:43:54.539]     do.call(function(...) {
[17:43:54.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.539]             on.exit(options(oopts), add = TRUE)
[17:43:54.539]         }
[17:43:54.539]         {
[17:43:54.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.539]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.539]             })
[17:43:54.539]         }
[17:43:54.539]     }, args = future.call.arguments)
[17:43:54.539] }
[17:43:54.539] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.539] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.540] 
[17:43:54.540] getGlobalsAndPackages() ... DONE
[17:43:54.540] run() for ‘Future’ ...
[17:43:54.540] - state: ‘created’
[17:43:54.540] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.555]   - Field: ‘node’
[17:43:54.555]   - Field: ‘label’
[17:43:54.555]   - Field: ‘local’
[17:43:54.555]   - Field: ‘owner’
[17:43:54.555]   - Field: ‘envir’
[17:43:54.555]   - Field: ‘workers’
[17:43:54.555]   - Field: ‘packages’
[17:43:54.556]   - Field: ‘gc’
[17:43:54.556]   - Field: ‘conditions’
[17:43:54.556]   - Field: ‘persistent’
[17:43:54.556]   - Field: ‘expr’
[17:43:54.556]   - Field: ‘uuid’
[17:43:54.556]   - Field: ‘seed’
[17:43:54.556]   - Field: ‘version’
[17:43:54.556]   - Field: ‘result’
[17:43:54.556]   - Field: ‘asynchronous’
[17:43:54.557]   - Field: ‘calls’
[17:43:54.557]   - Field: ‘globals’
[17:43:54.557]   - Field: ‘stdout’
[17:43:54.557]   - Field: ‘earlySignal’
[17:43:54.557]   - Field: ‘lazy’
[17:43:54.557]   - Field: ‘state’
[17:43:54.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.557] - Launch lazy future ...
[17:43:54.558] Packages needed by the future expression (n = 0): <none>
[17:43:54.558] Packages needed by future strategies (n = 0): <none>
[17:43:54.558] {
[17:43:54.558]     {
[17:43:54.558]         {
[17:43:54.558]             ...future.startTime <- base::Sys.time()
[17:43:54.558]             {
[17:43:54.558]                 {
[17:43:54.558]                   {
[17:43:54.558]                     {
[17:43:54.558]                       base::local({
[17:43:54.558]                         has_future <- base::requireNamespace("future", 
[17:43:54.558]                           quietly = TRUE)
[17:43:54.558]                         if (has_future) {
[17:43:54.558]                           ns <- base::getNamespace("future")
[17:43:54.558]                           version <- ns[[".package"]][["version"]]
[17:43:54.558]                           if (is.null(version)) 
[17:43:54.558]                             version <- utils::packageVersion("future")
[17:43:54.558]                         }
[17:43:54.558]                         else {
[17:43:54.558]                           version <- NULL
[17:43:54.558]                         }
[17:43:54.558]                         if (!has_future || version < "1.8.0") {
[17:43:54.558]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.558]                             "", base::R.version$version.string), 
[17:43:54.558]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.558]                               "release", "version")], collapse = " "), 
[17:43:54.558]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.558]                             info)
[17:43:54.558]                           info <- base::paste(info, collapse = "; ")
[17:43:54.558]                           if (!has_future) {
[17:43:54.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.558]                               info)
[17:43:54.558]                           }
[17:43:54.558]                           else {
[17:43:54.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.558]                               info, version)
[17:43:54.558]                           }
[17:43:54.558]                           base::stop(msg)
[17:43:54.558]                         }
[17:43:54.558]                       })
[17:43:54.558]                     }
[17:43:54.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.558]                     base::options(mc.cores = 1L)
[17:43:54.558]                   }
[17:43:54.558]                   ...future.strategy.old <- future::plan("list")
[17:43:54.558]                   options(future.plan = NULL)
[17:43:54.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.558]                 }
[17:43:54.558]                 ...future.workdir <- getwd()
[17:43:54.558]             }
[17:43:54.558]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.558]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.558]         }
[17:43:54.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:54.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.558]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.558]             base::names(...future.oldOptions))
[17:43:54.558]     }
[17:43:54.558]     if (FALSE) {
[17:43:54.558]     }
[17:43:54.558]     else {
[17:43:54.558]         if (TRUE) {
[17:43:54.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.558]                 open = "w")
[17:43:54.558]         }
[17:43:54.558]         else {
[17:43:54.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.558]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.558]         }
[17:43:54.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.558]             base::sink(type = "output", split = FALSE)
[17:43:54.558]             base::close(...future.stdout)
[17:43:54.558]         }, add = TRUE)
[17:43:54.558]     }
[17:43:54.558]     ...future.frame <- base::sys.nframe()
[17:43:54.558]     ...future.conditions <- base::list()
[17:43:54.558]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.558]     if (FALSE) {
[17:43:54.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.558]     }
[17:43:54.558]     ...future.result <- base::tryCatch({
[17:43:54.558]         base::withCallingHandlers({
[17:43:54.558]             ...future.value <- base::withVisible(base::local({
[17:43:54.558]                 ...future.makeSendCondition <- base::local({
[17:43:54.558]                   sendCondition <- NULL
[17:43:54.558]                   function(frame = 1L) {
[17:43:54.558]                     if (is.function(sendCondition)) 
[17:43:54.558]                       return(sendCondition)
[17:43:54.558]                     ns <- getNamespace("parallel")
[17:43:54.558]                     if (exists("sendData", mode = "function", 
[17:43:54.558]                       envir = ns)) {
[17:43:54.558]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.558]                         envir = ns)
[17:43:54.558]                       envir <- sys.frame(frame)
[17:43:54.558]                       master <- NULL
[17:43:54.558]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.558]                         !identical(envir, emptyenv())) {
[17:43:54.558]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.558]                           inherits = FALSE)) {
[17:43:54.558]                           master <- get("master", mode = "list", 
[17:43:54.558]                             envir = envir, inherits = FALSE)
[17:43:54.558]                           if (inherits(master, c("SOCKnode", 
[17:43:54.558]                             "SOCK0node"))) {
[17:43:54.558]                             sendCondition <<- function(cond) {
[17:43:54.558]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.558]                                 success = TRUE)
[17:43:54.558]                               parallel_sendData(master, data)
[17:43:54.558]                             }
[17:43:54.558]                             return(sendCondition)
[17:43:54.558]                           }
[17:43:54.558]                         }
[17:43:54.558]                         frame <- frame + 1L
[17:43:54.558]                         envir <- sys.frame(frame)
[17:43:54.558]                       }
[17:43:54.558]                     }
[17:43:54.558]                     sendCondition <<- function(cond) NULL
[17:43:54.558]                   }
[17:43:54.558]                 })
[17:43:54.558]                 withCallingHandlers({
[17:43:54.558]                   {
[17:43:54.558]                     do.call(function(...) {
[17:43:54.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.558]                       if (!identical(...future.globals.maxSize.org, 
[17:43:54.558]                         ...future.globals.maxSize)) {
[17:43:54.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.558]                         on.exit(options(oopts), add = TRUE)
[17:43:54.558]                       }
[17:43:54.558]                       {
[17:43:54.558]                         lapply(seq_along(...future.elements_ii), 
[17:43:54.558]                           FUN = function(jj) {
[17:43:54.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.558]                             ...future.FUN(...future.X_jj, ...)
[17:43:54.558]                           })
[17:43:54.558]                       }
[17:43:54.558]                     }, args = future.call.arguments)
[17:43:54.558]                   }
[17:43:54.558]                 }, immediateCondition = function(cond) {
[17:43:54.558]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.558]                   sendCondition(cond)
[17:43:54.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.558]                   {
[17:43:54.558]                     inherits <- base::inherits
[17:43:54.558]                     invokeRestart <- base::invokeRestart
[17:43:54.558]                     is.null <- base::is.null
[17:43:54.558]                     muffled <- FALSE
[17:43:54.558]                     if (inherits(cond, "message")) {
[17:43:54.558]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.558]                       if (muffled) 
[17:43:54.558]                         invokeRestart("muffleMessage")
[17:43:54.558]                     }
[17:43:54.558]                     else if (inherits(cond, "warning")) {
[17:43:54.558]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.558]                       if (muffled) 
[17:43:54.558]                         invokeRestart("muffleWarning")
[17:43:54.558]                     }
[17:43:54.558]                     else if (inherits(cond, "condition")) {
[17:43:54.558]                       if (!is.null(pattern)) {
[17:43:54.558]                         computeRestarts <- base::computeRestarts
[17:43:54.558]                         grepl <- base::grepl
[17:43:54.558]                         restarts <- computeRestarts(cond)
[17:43:54.558]                         for (restart in restarts) {
[17:43:54.558]                           name <- restart$name
[17:43:54.558]                           if (is.null(name)) 
[17:43:54.558]                             next
[17:43:54.558]                           if (!grepl(pattern, name)) 
[17:43:54.558]                             next
[17:43:54.558]                           invokeRestart(restart)
[17:43:54.558]                           muffled <- TRUE
[17:43:54.558]                           break
[17:43:54.558]                         }
[17:43:54.558]                       }
[17:43:54.558]                     }
[17:43:54.558]                     invisible(muffled)
[17:43:54.558]                   }
[17:43:54.558]                   muffleCondition(cond)
[17:43:54.558]                 })
[17:43:54.558]             }))
[17:43:54.558]             future::FutureResult(value = ...future.value$value, 
[17:43:54.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.558]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.558]                     ...future.globalenv.names))
[17:43:54.558]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.558]         }, condition = base::local({
[17:43:54.558]             c <- base::c
[17:43:54.558]             inherits <- base::inherits
[17:43:54.558]             invokeRestart <- base::invokeRestart
[17:43:54.558]             length <- base::length
[17:43:54.558]             list <- base::list
[17:43:54.558]             seq.int <- base::seq.int
[17:43:54.558]             signalCondition <- base::signalCondition
[17:43:54.558]             sys.calls <- base::sys.calls
[17:43:54.558]             `[[` <- base::`[[`
[17:43:54.558]             `+` <- base::`+`
[17:43:54.558]             `<<-` <- base::`<<-`
[17:43:54.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.558]                   3L)]
[17:43:54.558]             }
[17:43:54.558]             function(cond) {
[17:43:54.558]                 is_error <- inherits(cond, "error")
[17:43:54.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.558]                   NULL)
[17:43:54.558]                 if (is_error) {
[17:43:54.558]                   sessionInformation <- function() {
[17:43:54.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.558]                       search = base::search(), system = base::Sys.info())
[17:43:54.558]                   }
[17:43:54.558]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.558]                     cond$call), session = sessionInformation(), 
[17:43:54.558]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.558]                   signalCondition(cond)
[17:43:54.558]                 }
[17:43:54.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.558]                 "immediateCondition"))) {
[17:43:54.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.558]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.558]                   if (TRUE && !signal) {
[17:43:54.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.558]                     {
[17:43:54.558]                       inherits <- base::inherits
[17:43:54.558]                       invokeRestart <- base::invokeRestart
[17:43:54.558]                       is.null <- base::is.null
[17:43:54.558]                       muffled <- FALSE
[17:43:54.558]                       if (inherits(cond, "message")) {
[17:43:54.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.558]                         if (muffled) 
[17:43:54.558]                           invokeRestart("muffleMessage")
[17:43:54.558]                       }
[17:43:54.558]                       else if (inherits(cond, "warning")) {
[17:43:54.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.558]                         if (muffled) 
[17:43:54.558]                           invokeRestart("muffleWarning")
[17:43:54.558]                       }
[17:43:54.558]                       else if (inherits(cond, "condition")) {
[17:43:54.558]                         if (!is.null(pattern)) {
[17:43:54.558]                           computeRestarts <- base::computeRestarts
[17:43:54.558]                           grepl <- base::grepl
[17:43:54.558]                           restarts <- computeRestarts(cond)
[17:43:54.558]                           for (restart in restarts) {
[17:43:54.558]                             name <- restart$name
[17:43:54.558]                             if (is.null(name)) 
[17:43:54.558]                               next
[17:43:54.558]                             if (!grepl(pattern, name)) 
[17:43:54.558]                               next
[17:43:54.558]                             invokeRestart(restart)
[17:43:54.558]                             muffled <- TRUE
[17:43:54.558]                             break
[17:43:54.558]                           }
[17:43:54.558]                         }
[17:43:54.558]                       }
[17:43:54.558]                       invisible(muffled)
[17:43:54.558]                     }
[17:43:54.558]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.558]                   }
[17:43:54.558]                 }
[17:43:54.558]                 else {
[17:43:54.558]                   if (TRUE) {
[17:43:54.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.558]                     {
[17:43:54.558]                       inherits <- base::inherits
[17:43:54.558]                       invokeRestart <- base::invokeRestart
[17:43:54.558]                       is.null <- base::is.null
[17:43:54.558]                       muffled <- FALSE
[17:43:54.558]                       if (inherits(cond, "message")) {
[17:43:54.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.558]                         if (muffled) 
[17:43:54.558]                           invokeRestart("muffleMessage")
[17:43:54.558]                       }
[17:43:54.558]                       else if (inherits(cond, "warning")) {
[17:43:54.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.558]                         if (muffled) 
[17:43:54.558]                           invokeRestart("muffleWarning")
[17:43:54.558]                       }
[17:43:54.558]                       else if (inherits(cond, "condition")) {
[17:43:54.558]                         if (!is.null(pattern)) {
[17:43:54.558]                           computeRestarts <- base::computeRestarts
[17:43:54.558]                           grepl <- base::grepl
[17:43:54.558]                           restarts <- computeRestarts(cond)
[17:43:54.558]                           for (restart in restarts) {
[17:43:54.558]                             name <- restart$name
[17:43:54.558]                             if (is.null(name)) 
[17:43:54.558]                               next
[17:43:54.558]                             if (!grepl(pattern, name)) 
[17:43:54.558]                               next
[17:43:54.558]                             invokeRestart(restart)
[17:43:54.558]                             muffled <- TRUE
[17:43:54.558]                             break
[17:43:54.558]                           }
[17:43:54.558]                         }
[17:43:54.558]                       }
[17:43:54.558]                       invisible(muffled)
[17:43:54.558]                     }
[17:43:54.558]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.558]                   }
[17:43:54.558]                 }
[17:43:54.558]             }
[17:43:54.558]         }))
[17:43:54.558]     }, error = function(ex) {
[17:43:54.558]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.558]                 ...future.rng), started = ...future.startTime, 
[17:43:54.558]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.558]             version = "1.8"), class = "FutureResult")
[17:43:54.558]     }, finally = {
[17:43:54.558]         if (!identical(...future.workdir, getwd())) 
[17:43:54.558]             setwd(...future.workdir)
[17:43:54.558]         {
[17:43:54.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.558]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.558]             }
[17:43:54.558]             base::options(...future.oldOptions)
[17:43:54.558]             if (.Platform$OS.type == "windows") {
[17:43:54.558]                 old_names <- names(...future.oldEnvVars)
[17:43:54.558]                 envs <- base::Sys.getenv()
[17:43:54.558]                 names <- names(envs)
[17:43:54.558]                 common <- intersect(names, old_names)
[17:43:54.558]                 added <- setdiff(names, old_names)
[17:43:54.558]                 removed <- setdiff(old_names, names)
[17:43:54.558]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.558]                   envs[common]]
[17:43:54.558]                 NAMES <- toupper(changed)
[17:43:54.558]                 args <- list()
[17:43:54.558]                 for (kk in seq_along(NAMES)) {
[17:43:54.558]                   name <- changed[[kk]]
[17:43:54.558]                   NAME <- NAMES[[kk]]
[17:43:54.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.558]                     next
[17:43:54.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.558]                 }
[17:43:54.558]                 NAMES <- toupper(added)
[17:43:54.558]                 for (kk in seq_along(NAMES)) {
[17:43:54.558]                   name <- added[[kk]]
[17:43:54.558]                   NAME <- NAMES[[kk]]
[17:43:54.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.558]                     next
[17:43:54.558]                   args[[name]] <- ""
[17:43:54.558]                 }
[17:43:54.558]                 NAMES <- toupper(removed)
[17:43:54.558]                 for (kk in seq_along(NAMES)) {
[17:43:54.558]                   name <- removed[[kk]]
[17:43:54.558]                   NAME <- NAMES[[kk]]
[17:43:54.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.558]                     next
[17:43:54.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.558]                 }
[17:43:54.558]                 if (length(args) > 0) 
[17:43:54.558]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.558]             }
[17:43:54.558]             else {
[17:43:54.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.558]             }
[17:43:54.558]             {
[17:43:54.558]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.558]                   0L) {
[17:43:54.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.558]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.558]                   base::options(opts)
[17:43:54.558]                 }
[17:43:54.558]                 {
[17:43:54.558]                   {
[17:43:54.558]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.558]                     NULL
[17:43:54.558]                   }
[17:43:54.558]                   options(future.plan = NULL)
[17:43:54.558]                   if (is.na(NA_character_)) 
[17:43:54.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.558]                     .init = FALSE)
[17:43:54.558]                 }
[17:43:54.558]             }
[17:43:54.558]         }
[17:43:54.558]     })
[17:43:54.558]     if (TRUE) {
[17:43:54.558]         base::sink(type = "output", split = FALSE)
[17:43:54.558]         if (TRUE) {
[17:43:54.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.558]         }
[17:43:54.558]         else {
[17:43:54.558]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.558]         }
[17:43:54.558]         base::close(...future.stdout)
[17:43:54.558]         ...future.stdout <- NULL
[17:43:54.558]     }
[17:43:54.558]     ...future.result$conditions <- ...future.conditions
[17:43:54.558]     ...future.result$finished <- base::Sys.time()
[17:43:54.558]     ...future.result
[17:43:54.558] }
[17:43:54.613] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:43:54.614] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:43:54.614] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:43:54.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:54.615] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.615] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[17:43:54.616] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[17:43:54.616] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:54.616] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:54.617] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.617] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:43:54.617] MultisessionFuture started
[17:43:54.617] - Launch lazy future ... done
[17:43:54.618] run() for ‘MultisessionFuture’ ... done
[17:43:54.618] Created future:
[17:43:54.618] MultisessionFuture:
[17:43:54.618] Label: ‘future_by-2’
[17:43:54.618] Expression:
[17:43:54.618] {
[17:43:54.618]     do.call(function(...) {
[17:43:54.618]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.618]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.618]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.618]             on.exit(options(oopts), add = TRUE)
[17:43:54.618]         }
[17:43:54.618]         {
[17:43:54.618]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.618]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.618]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.618]             })
[17:43:54.618]         }
[17:43:54.618]     }, args = future.call.arguments)
[17:43:54.618] }
[17:43:54.618] Lazy evaluation: FALSE
[17:43:54.618] Asynchronous evaluation: TRUE
[17:43:54.618] Local evaluation: TRUE
[17:43:54.618] Environment: R_GlobalEnv
[17:43:54.618] Capture standard output: TRUE
[17:43:54.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:54.618] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:54.618] Packages: <none>
[17:43:54.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:54.618] Resolved: FALSE
[17:43:54.618] Value: <not collected>
[17:43:54.618] Conditions captured: <none>
[17:43:54.618] Early signaling: FALSE
[17:43:54.618] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:54.618] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.630] Chunk #2 of 2 ... DONE
[17:43:54.630] Launching 2 futures (chunks) ... DONE
[17:43:54.630] Resolving 2 futures (chunks) ...
[17:43:54.630] resolve() on list ...
[17:43:54.630]  recursive: 0
[17:43:54.630]  length: 2
[17:43:54.631] 
[17:43:54.631] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.631] - Validating connection of MultisessionFuture
[17:43:54.631] - received message: FutureResult
[17:43:54.632] - Received FutureResult
[17:43:54.632] - Erased future from FutureRegistry
[17:43:54.632] result() for ClusterFuture ...
[17:43:54.632] - result already collected: FutureResult
[17:43:54.632] result() for ClusterFuture ... done
[17:43:54.632] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.632] Future #1
[17:43:54.632] result() for ClusterFuture ...
[17:43:54.632] - result already collected: FutureResult
[17:43:54.633] result() for ClusterFuture ... done
[17:43:54.633] result() for ClusterFuture ...
[17:43:54.633] - result already collected: FutureResult
[17:43:54.633] result() for ClusterFuture ... done
[17:43:54.633] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:54.633] - nx: 2
[17:43:54.633] - relay: TRUE
[17:43:54.633] - stdout: TRUE
[17:43:54.633] - signal: TRUE
[17:43:54.634] - resignal: FALSE
[17:43:54.634] - force: TRUE
[17:43:54.634] - relayed: [n=2] FALSE, FALSE
[17:43:54.634] - queued futures: [n=2] FALSE, FALSE
[17:43:54.634]  - until=1
[17:43:54.634]  - relaying element #1
[17:43:54.634] result() for ClusterFuture ...
[17:43:54.634] - result already collected: FutureResult
[17:43:54.634] result() for ClusterFuture ... done
[17:43:54.635] result() for ClusterFuture ...
[17:43:54.635] - result already collected: FutureResult
[17:43:54.635] result() for ClusterFuture ... done
[17:43:54.635] result() for ClusterFuture ...
[17:43:54.635] - result already collected: FutureResult
[17:43:54.635] result() for ClusterFuture ... done
[17:43:54.635] result() for ClusterFuture ...
[17:43:54.635] - result already collected: FutureResult
[17:43:54.635] result() for ClusterFuture ... done
[17:43:54.636] - relayed: [n=2] TRUE, FALSE
[17:43:54.636] - queued futures: [n=2] TRUE, FALSE
[17:43:54.636] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:54.636]  length: 1 (resolved future 1)
[17:43:54.699] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.699] - Validating connection of MultisessionFuture
[17:43:54.699] - received message: FutureResult
[17:43:54.699] - Received FutureResult
[17:43:54.699] - Erased future from FutureRegistry
[17:43:54.699] result() for ClusterFuture ...
[17:43:54.700] - result already collected: FutureResult
[17:43:54.700] result() for ClusterFuture ... done
[17:43:54.700] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.700] Future #2
[17:43:54.700] result() for ClusterFuture ...
[17:43:54.700] - result already collected: FutureResult
[17:43:54.700] result() for ClusterFuture ... done
[17:43:54.700] result() for ClusterFuture ...
[17:43:54.700] - result already collected: FutureResult
[17:43:54.701] result() for ClusterFuture ... done
[17:43:54.701] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:54.701] - nx: 2
[17:43:54.701] - relay: TRUE
[17:43:54.703] - stdout: TRUE
[17:43:54.703] - signal: TRUE
[17:43:54.704] - resignal: FALSE
[17:43:54.704] - force: TRUE
[17:43:54.704] - relayed: [n=2] TRUE, FALSE
[17:43:54.704] - queued futures: [n=2] TRUE, FALSE
[17:43:54.704]  - until=2
[17:43:54.704]  - relaying element #2
[17:43:54.704] result() for ClusterFuture ...
[17:43:54.704] - result already collected: FutureResult
[17:43:54.704] result() for ClusterFuture ... done
[17:43:54.704] result() for ClusterFuture ...
[17:43:54.704] - result already collected: FutureResult
[17:43:54.704] result() for ClusterFuture ... done
[17:43:54.705] result() for ClusterFuture ...
[17:43:54.705] - result already collected: FutureResult
[17:43:54.705] result() for ClusterFuture ... done
[17:43:54.705] result() for ClusterFuture ...
[17:43:54.705] - result already collected: FutureResult
[17:43:54.705] result() for ClusterFuture ... done
[17:43:54.705] - relayed: [n=2] TRUE, TRUE
[17:43:54.705] - queued futures: [n=2] TRUE, TRUE
[17:43:54.705] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:54.705]  length: 0 (resolved future 2)
[17:43:54.705] Relaying remaining futures
[17:43:54.705] signalConditionsASAP(NULL, pos=0) ...
[17:43:54.706] - nx: 2
[17:43:54.706] - relay: TRUE
[17:43:54.706] - stdout: TRUE
[17:43:54.706] - signal: TRUE
[17:43:54.706] - resignal: FALSE
[17:43:54.706] - force: TRUE
[17:43:54.706] - relayed: [n=2] TRUE, TRUE
[17:43:54.706] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:54.706] - relayed: [n=2] TRUE, TRUE
[17:43:54.706] - queued futures: [n=2] TRUE, TRUE
[17:43:54.706] signalConditionsASAP(NULL, pos=0) ... done
[17:43:54.707] resolve() on list ... DONE
[17:43:54.707] result() for ClusterFuture ...
[17:43:54.707] - result already collected: FutureResult
[17:43:54.707] result() for ClusterFuture ... done
[17:43:54.707] result() for ClusterFuture ...
[17:43:54.707] - result already collected: FutureResult
[17:43:54.707] result() for ClusterFuture ... done
[17:43:54.707] result() for ClusterFuture ...
[17:43:54.707] - result already collected: FutureResult
[17:43:54.707] result() for ClusterFuture ... done
[17:43:54.707] result() for ClusterFuture ...
[17:43:54.707] - result already collected: FutureResult
[17:43:54.708] result() for ClusterFuture ... done
[17:43:54.708]  - Number of value chunks collected: 2
[17:43:54.708] Resolving 2 futures (chunks) ... DONE
[17:43:54.708] Reducing values from 2 chunks ...
[17:43:54.708]  - Number of values collected after concatenation: 3
[17:43:54.708]  - Number of values expected: 3
[17:43:54.708] Reducing values from 2 chunks ... DONE
[17:43:54.708] future_lapply() ... DONE
[17:43:54.708] future_by_internal() ... DONE
[17:43:54.709] future_by_internal() ...
[17:43:54.709] future_lapply() ...
[17:43:54.713] Number of chunks: 2
[17:43:54.713] getGlobalsAndPackagesXApply() ...
[17:43:54.713]  - future.globals: TRUE
[17:43:54.713] getGlobalsAndPackages() ...
[17:43:54.713] Searching for globals...
[17:43:54.714] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:54.714] Searching for globals ... DONE
[17:43:54.715] Resolving globals: FALSE
[17:43:54.715] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:54.715] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:54.715] - globals: [1] ‘FUN’
[17:43:54.715] 
[17:43:54.716] getGlobalsAndPackages() ... DONE
[17:43:54.716]  - globals found/used: [n=1] ‘FUN’
[17:43:54.716]  - needed namespaces: [n=0] 
[17:43:54.716] Finding globals ... DONE
[17:43:54.716]  - use_args: TRUE
[17:43:54.716]  - Getting '...' globals ...
[17:43:54.716] resolve() on list ...
[17:43:54.716]  recursive: 0
[17:43:54.717]  length: 1
[17:43:54.717]  elements: ‘...’
[17:43:54.717]  length: 0 (resolved future 1)
[17:43:54.717] resolve() on list ... DONE
[17:43:54.717]    - '...' content: [n=1] ‘digits’
[17:43:54.717] List of 1
[17:43:54.717]  $ ...:List of 1
[17:43:54.717]   ..$ digits: int 2
[17:43:54.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.717]  - attr(*, "where")=List of 1
[17:43:54.717]   ..$ ...:<environment: 0x55d6bb0d1060> 
[17:43:54.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.717]  - attr(*, "resolved")= logi TRUE
[17:43:54.717]  - attr(*, "total_size")= num NA
[17:43:54.720]  - Getting '...' globals ... DONE
[17:43:54.720] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:54.720] List of 2
[17:43:54.720]  $ ...future.FUN:function (object, ...)  
[17:43:54.720]  $ ...          :List of 1
[17:43:54.720]   ..$ digits: int 2
[17:43:54.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.720]  - attr(*, "where")=List of 2
[17:43:54.720]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:54.720]   ..$ ...          :<environment: 0x55d6bb0d1060> 
[17:43:54.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.720]  - attr(*, "resolved")= logi FALSE
[17:43:54.720]  - attr(*, "total_size")= num 1296
[17:43:54.723] Packages to be attached in all futures: [n=0] 
[17:43:54.723] getGlobalsAndPackagesXApply() ... DONE
[17:43:54.723] Number of futures (= number of chunks): 2
[17:43:54.724] Launching 2 futures (chunks) ...
[17:43:54.724] Chunk #1 of 2 ...
[17:43:54.724]  - Finding globals in 'X' for chunk #1 ...
[17:43:54.724] getGlobalsAndPackages() ...
[17:43:54.724] Searching for globals...
[17:43:54.724] 
[17:43:54.724] Searching for globals ... DONE
[17:43:54.724] - globals: [0] <none>
[17:43:54.724] getGlobalsAndPackages() ... DONE
[17:43:54.725]    + additional globals found: [n=0] 
[17:43:54.725]    + additional namespaces needed: [n=0] 
[17:43:54.725]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:54.725]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.725]  - seeds: <none>
[17:43:54.725]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.725] getGlobalsAndPackages() ...
[17:43:54.725] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.725] Resolving globals: FALSE
[17:43:54.725] Tweak future expression to call with '...' arguments ...
[17:43:54.725] {
[17:43:54.725]     do.call(function(...) {
[17:43:54.725]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.725]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.725]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.725]             on.exit(options(oopts), add = TRUE)
[17:43:54.725]         }
[17:43:54.725]         {
[17:43:54.725]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.725]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.725]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.725]             })
[17:43:54.725]         }
[17:43:54.725]     }, args = future.call.arguments)
[17:43:54.725] }
[17:43:54.726] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.726] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.726] 
[17:43:54.726] getGlobalsAndPackages() ... DONE
[17:43:54.727] run() for ‘Future’ ...
[17:43:54.727] - state: ‘created’
[17:43:54.727] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.741]   - Field: ‘node’
[17:43:54.741]   - Field: ‘label’
[17:43:54.741]   - Field: ‘local’
[17:43:54.741]   - Field: ‘owner’
[17:43:54.741]   - Field: ‘envir’
[17:43:54.741]   - Field: ‘workers’
[17:43:54.741]   - Field: ‘packages’
[17:43:54.741]   - Field: ‘gc’
[17:43:54.741]   - Field: ‘conditions’
[17:43:54.742]   - Field: ‘persistent’
[17:43:54.742]   - Field: ‘expr’
[17:43:54.742]   - Field: ‘uuid’
[17:43:54.742]   - Field: ‘seed’
[17:43:54.742]   - Field: ‘version’
[17:43:54.742]   - Field: ‘result’
[17:43:54.742]   - Field: ‘asynchronous’
[17:43:54.742]   - Field: ‘calls’
[17:43:54.742]   - Field: ‘globals’
[17:43:54.742]   - Field: ‘stdout’
[17:43:54.742]   - Field: ‘earlySignal’
[17:43:54.742]   - Field: ‘lazy’
[17:43:54.743]   - Field: ‘state’
[17:43:54.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.743] - Launch lazy future ...
[17:43:54.743] Packages needed by the future expression (n = 0): <none>
[17:43:54.743] Packages needed by future strategies (n = 0): <none>
[17:43:54.744] {
[17:43:54.744]     {
[17:43:54.744]         {
[17:43:54.744]             ...future.startTime <- base::Sys.time()
[17:43:54.744]             {
[17:43:54.744]                 {
[17:43:54.744]                   {
[17:43:54.744]                     {
[17:43:54.744]                       base::local({
[17:43:54.744]                         has_future <- base::requireNamespace("future", 
[17:43:54.744]                           quietly = TRUE)
[17:43:54.744]                         if (has_future) {
[17:43:54.744]                           ns <- base::getNamespace("future")
[17:43:54.744]                           version <- ns[[".package"]][["version"]]
[17:43:54.744]                           if (is.null(version)) 
[17:43:54.744]                             version <- utils::packageVersion("future")
[17:43:54.744]                         }
[17:43:54.744]                         else {
[17:43:54.744]                           version <- NULL
[17:43:54.744]                         }
[17:43:54.744]                         if (!has_future || version < "1.8.0") {
[17:43:54.744]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.744]                             "", base::R.version$version.string), 
[17:43:54.744]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.744]                               "release", "version")], collapse = " "), 
[17:43:54.744]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.744]                             info)
[17:43:54.744]                           info <- base::paste(info, collapse = "; ")
[17:43:54.744]                           if (!has_future) {
[17:43:54.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.744]                               info)
[17:43:54.744]                           }
[17:43:54.744]                           else {
[17:43:54.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.744]                               info, version)
[17:43:54.744]                           }
[17:43:54.744]                           base::stop(msg)
[17:43:54.744]                         }
[17:43:54.744]                       })
[17:43:54.744]                     }
[17:43:54.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.744]                     base::options(mc.cores = 1L)
[17:43:54.744]                   }
[17:43:54.744]                   ...future.strategy.old <- future::plan("list")
[17:43:54.744]                   options(future.plan = NULL)
[17:43:54.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.744]                 }
[17:43:54.744]                 ...future.workdir <- getwd()
[17:43:54.744]             }
[17:43:54.744]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.744]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.744]         }
[17:43:54.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.744]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:54.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.744]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.744]             base::names(...future.oldOptions))
[17:43:54.744]     }
[17:43:54.744]     if (FALSE) {
[17:43:54.744]     }
[17:43:54.744]     else {
[17:43:54.744]         if (TRUE) {
[17:43:54.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.744]                 open = "w")
[17:43:54.744]         }
[17:43:54.744]         else {
[17:43:54.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.744]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.744]         }
[17:43:54.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.744]             base::sink(type = "output", split = FALSE)
[17:43:54.744]             base::close(...future.stdout)
[17:43:54.744]         }, add = TRUE)
[17:43:54.744]     }
[17:43:54.744]     ...future.frame <- base::sys.nframe()
[17:43:54.744]     ...future.conditions <- base::list()
[17:43:54.744]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.744]     if (FALSE) {
[17:43:54.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.744]     }
[17:43:54.744]     ...future.result <- base::tryCatch({
[17:43:54.744]         base::withCallingHandlers({
[17:43:54.744]             ...future.value <- base::withVisible(base::local({
[17:43:54.744]                 ...future.makeSendCondition <- base::local({
[17:43:54.744]                   sendCondition <- NULL
[17:43:54.744]                   function(frame = 1L) {
[17:43:54.744]                     if (is.function(sendCondition)) 
[17:43:54.744]                       return(sendCondition)
[17:43:54.744]                     ns <- getNamespace("parallel")
[17:43:54.744]                     if (exists("sendData", mode = "function", 
[17:43:54.744]                       envir = ns)) {
[17:43:54.744]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.744]                         envir = ns)
[17:43:54.744]                       envir <- sys.frame(frame)
[17:43:54.744]                       master <- NULL
[17:43:54.744]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.744]                         !identical(envir, emptyenv())) {
[17:43:54.744]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.744]                           inherits = FALSE)) {
[17:43:54.744]                           master <- get("master", mode = "list", 
[17:43:54.744]                             envir = envir, inherits = FALSE)
[17:43:54.744]                           if (inherits(master, c("SOCKnode", 
[17:43:54.744]                             "SOCK0node"))) {
[17:43:54.744]                             sendCondition <<- function(cond) {
[17:43:54.744]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.744]                                 success = TRUE)
[17:43:54.744]                               parallel_sendData(master, data)
[17:43:54.744]                             }
[17:43:54.744]                             return(sendCondition)
[17:43:54.744]                           }
[17:43:54.744]                         }
[17:43:54.744]                         frame <- frame + 1L
[17:43:54.744]                         envir <- sys.frame(frame)
[17:43:54.744]                       }
[17:43:54.744]                     }
[17:43:54.744]                     sendCondition <<- function(cond) NULL
[17:43:54.744]                   }
[17:43:54.744]                 })
[17:43:54.744]                 withCallingHandlers({
[17:43:54.744]                   {
[17:43:54.744]                     do.call(function(...) {
[17:43:54.744]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.744]                       if (!identical(...future.globals.maxSize.org, 
[17:43:54.744]                         ...future.globals.maxSize)) {
[17:43:54.744]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.744]                         on.exit(options(oopts), add = TRUE)
[17:43:54.744]                       }
[17:43:54.744]                       {
[17:43:54.744]                         lapply(seq_along(...future.elements_ii), 
[17:43:54.744]                           FUN = function(jj) {
[17:43:54.744]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.744]                             ...future.FUN(...future.X_jj, ...)
[17:43:54.744]                           })
[17:43:54.744]                       }
[17:43:54.744]                     }, args = future.call.arguments)
[17:43:54.744]                   }
[17:43:54.744]                 }, immediateCondition = function(cond) {
[17:43:54.744]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.744]                   sendCondition(cond)
[17:43:54.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.744]                   {
[17:43:54.744]                     inherits <- base::inherits
[17:43:54.744]                     invokeRestart <- base::invokeRestart
[17:43:54.744]                     is.null <- base::is.null
[17:43:54.744]                     muffled <- FALSE
[17:43:54.744]                     if (inherits(cond, "message")) {
[17:43:54.744]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.744]                       if (muffled) 
[17:43:54.744]                         invokeRestart("muffleMessage")
[17:43:54.744]                     }
[17:43:54.744]                     else if (inherits(cond, "warning")) {
[17:43:54.744]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.744]                       if (muffled) 
[17:43:54.744]                         invokeRestart("muffleWarning")
[17:43:54.744]                     }
[17:43:54.744]                     else if (inherits(cond, "condition")) {
[17:43:54.744]                       if (!is.null(pattern)) {
[17:43:54.744]                         computeRestarts <- base::computeRestarts
[17:43:54.744]                         grepl <- base::grepl
[17:43:54.744]                         restarts <- computeRestarts(cond)
[17:43:54.744]                         for (restart in restarts) {
[17:43:54.744]                           name <- restart$name
[17:43:54.744]                           if (is.null(name)) 
[17:43:54.744]                             next
[17:43:54.744]                           if (!grepl(pattern, name)) 
[17:43:54.744]                             next
[17:43:54.744]                           invokeRestart(restart)
[17:43:54.744]                           muffled <- TRUE
[17:43:54.744]                           break
[17:43:54.744]                         }
[17:43:54.744]                       }
[17:43:54.744]                     }
[17:43:54.744]                     invisible(muffled)
[17:43:54.744]                   }
[17:43:54.744]                   muffleCondition(cond)
[17:43:54.744]                 })
[17:43:54.744]             }))
[17:43:54.744]             future::FutureResult(value = ...future.value$value, 
[17:43:54.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.744]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.744]                     ...future.globalenv.names))
[17:43:54.744]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.744]         }, condition = base::local({
[17:43:54.744]             c <- base::c
[17:43:54.744]             inherits <- base::inherits
[17:43:54.744]             invokeRestart <- base::invokeRestart
[17:43:54.744]             length <- base::length
[17:43:54.744]             list <- base::list
[17:43:54.744]             seq.int <- base::seq.int
[17:43:54.744]             signalCondition <- base::signalCondition
[17:43:54.744]             sys.calls <- base::sys.calls
[17:43:54.744]             `[[` <- base::`[[`
[17:43:54.744]             `+` <- base::`+`
[17:43:54.744]             `<<-` <- base::`<<-`
[17:43:54.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.744]                   3L)]
[17:43:54.744]             }
[17:43:54.744]             function(cond) {
[17:43:54.744]                 is_error <- inherits(cond, "error")
[17:43:54.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.744]                   NULL)
[17:43:54.744]                 if (is_error) {
[17:43:54.744]                   sessionInformation <- function() {
[17:43:54.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.744]                       search = base::search(), system = base::Sys.info())
[17:43:54.744]                   }
[17:43:54.744]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.744]                     cond$call), session = sessionInformation(), 
[17:43:54.744]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.744]                   signalCondition(cond)
[17:43:54.744]                 }
[17:43:54.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.744]                 "immediateCondition"))) {
[17:43:54.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.744]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.744]                   if (TRUE && !signal) {
[17:43:54.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.744]                     {
[17:43:54.744]                       inherits <- base::inherits
[17:43:54.744]                       invokeRestart <- base::invokeRestart
[17:43:54.744]                       is.null <- base::is.null
[17:43:54.744]                       muffled <- FALSE
[17:43:54.744]                       if (inherits(cond, "message")) {
[17:43:54.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.744]                         if (muffled) 
[17:43:54.744]                           invokeRestart("muffleMessage")
[17:43:54.744]                       }
[17:43:54.744]                       else if (inherits(cond, "warning")) {
[17:43:54.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.744]                         if (muffled) 
[17:43:54.744]                           invokeRestart("muffleWarning")
[17:43:54.744]                       }
[17:43:54.744]                       else if (inherits(cond, "condition")) {
[17:43:54.744]                         if (!is.null(pattern)) {
[17:43:54.744]                           computeRestarts <- base::computeRestarts
[17:43:54.744]                           grepl <- base::grepl
[17:43:54.744]                           restarts <- computeRestarts(cond)
[17:43:54.744]                           for (restart in restarts) {
[17:43:54.744]                             name <- restart$name
[17:43:54.744]                             if (is.null(name)) 
[17:43:54.744]                               next
[17:43:54.744]                             if (!grepl(pattern, name)) 
[17:43:54.744]                               next
[17:43:54.744]                             invokeRestart(restart)
[17:43:54.744]                             muffled <- TRUE
[17:43:54.744]                             break
[17:43:54.744]                           }
[17:43:54.744]                         }
[17:43:54.744]                       }
[17:43:54.744]                       invisible(muffled)
[17:43:54.744]                     }
[17:43:54.744]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.744]                   }
[17:43:54.744]                 }
[17:43:54.744]                 else {
[17:43:54.744]                   if (TRUE) {
[17:43:54.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.744]                     {
[17:43:54.744]                       inherits <- base::inherits
[17:43:54.744]                       invokeRestart <- base::invokeRestart
[17:43:54.744]                       is.null <- base::is.null
[17:43:54.744]                       muffled <- FALSE
[17:43:54.744]                       if (inherits(cond, "message")) {
[17:43:54.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.744]                         if (muffled) 
[17:43:54.744]                           invokeRestart("muffleMessage")
[17:43:54.744]                       }
[17:43:54.744]                       else if (inherits(cond, "warning")) {
[17:43:54.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.744]                         if (muffled) 
[17:43:54.744]                           invokeRestart("muffleWarning")
[17:43:54.744]                       }
[17:43:54.744]                       else if (inherits(cond, "condition")) {
[17:43:54.744]                         if (!is.null(pattern)) {
[17:43:54.744]                           computeRestarts <- base::computeRestarts
[17:43:54.744]                           grepl <- base::grepl
[17:43:54.744]                           restarts <- computeRestarts(cond)
[17:43:54.744]                           for (restart in restarts) {
[17:43:54.744]                             name <- restart$name
[17:43:54.744]                             if (is.null(name)) 
[17:43:54.744]                               next
[17:43:54.744]                             if (!grepl(pattern, name)) 
[17:43:54.744]                               next
[17:43:54.744]                             invokeRestart(restart)
[17:43:54.744]                             muffled <- TRUE
[17:43:54.744]                             break
[17:43:54.744]                           }
[17:43:54.744]                         }
[17:43:54.744]                       }
[17:43:54.744]                       invisible(muffled)
[17:43:54.744]                     }
[17:43:54.744]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.744]                   }
[17:43:54.744]                 }
[17:43:54.744]             }
[17:43:54.744]         }))
[17:43:54.744]     }, error = function(ex) {
[17:43:54.744]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.744]                 ...future.rng), started = ...future.startTime, 
[17:43:54.744]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.744]             version = "1.8"), class = "FutureResult")
[17:43:54.744]     }, finally = {
[17:43:54.744]         if (!identical(...future.workdir, getwd())) 
[17:43:54.744]             setwd(...future.workdir)
[17:43:54.744]         {
[17:43:54.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.744]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.744]             }
[17:43:54.744]             base::options(...future.oldOptions)
[17:43:54.744]             if (.Platform$OS.type == "windows") {
[17:43:54.744]                 old_names <- names(...future.oldEnvVars)
[17:43:54.744]                 envs <- base::Sys.getenv()
[17:43:54.744]                 names <- names(envs)
[17:43:54.744]                 common <- intersect(names, old_names)
[17:43:54.744]                 added <- setdiff(names, old_names)
[17:43:54.744]                 removed <- setdiff(old_names, names)
[17:43:54.744]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.744]                   envs[common]]
[17:43:54.744]                 NAMES <- toupper(changed)
[17:43:54.744]                 args <- list()
[17:43:54.744]                 for (kk in seq_along(NAMES)) {
[17:43:54.744]                   name <- changed[[kk]]
[17:43:54.744]                   NAME <- NAMES[[kk]]
[17:43:54.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.744]                     next
[17:43:54.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.744]                 }
[17:43:54.744]                 NAMES <- toupper(added)
[17:43:54.744]                 for (kk in seq_along(NAMES)) {
[17:43:54.744]                   name <- added[[kk]]
[17:43:54.744]                   NAME <- NAMES[[kk]]
[17:43:54.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.744]                     next
[17:43:54.744]                   args[[name]] <- ""
[17:43:54.744]                 }
[17:43:54.744]                 NAMES <- toupper(removed)
[17:43:54.744]                 for (kk in seq_along(NAMES)) {
[17:43:54.744]                   name <- removed[[kk]]
[17:43:54.744]                   NAME <- NAMES[[kk]]
[17:43:54.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.744]                     next
[17:43:54.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.744]                 }
[17:43:54.744]                 if (length(args) > 0) 
[17:43:54.744]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.744]             }
[17:43:54.744]             else {
[17:43:54.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.744]             }
[17:43:54.744]             {
[17:43:54.744]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.744]                   0L) {
[17:43:54.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.744]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.744]                   base::options(opts)
[17:43:54.744]                 }
[17:43:54.744]                 {
[17:43:54.744]                   {
[17:43:54.744]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.744]                     NULL
[17:43:54.744]                   }
[17:43:54.744]                   options(future.plan = NULL)
[17:43:54.744]                   if (is.na(NA_character_)) 
[17:43:54.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.744]                     .init = FALSE)
[17:43:54.744]                 }
[17:43:54.744]             }
[17:43:54.744]         }
[17:43:54.744]     })
[17:43:54.744]     if (TRUE) {
[17:43:54.744]         base::sink(type = "output", split = FALSE)
[17:43:54.744]         if (TRUE) {
[17:43:54.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.744]         }
[17:43:54.744]         else {
[17:43:54.744]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.744]         }
[17:43:54.744]         base::close(...future.stdout)
[17:43:54.744]         ...future.stdout <- NULL
[17:43:54.744]     }
[17:43:54.744]     ...future.result$conditions <- ...future.conditions
[17:43:54.744]     ...future.result$finished <- base::Sys.time()
[17:43:54.744]     ...future.result
[17:43:54.744] }
[17:43:54.746] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[17:43:54.746] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:43:54.747] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:43:54.747] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:43:54.747] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:43:54.747] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[17:43:54.748] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[17:43:54.748] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:54.748] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.748] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:54.748] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.749] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[17:43:54.749] MultisessionFuture started
[17:43:54.749] - Launch lazy future ... done
[17:43:54.749] run() for ‘MultisessionFuture’ ... done
[17:43:54.749] Created future:
[17:43:54.749] MultisessionFuture:
[17:43:54.749] Label: ‘future_by-1’
[17:43:54.749] Expression:
[17:43:54.749] {
[17:43:54.749]     do.call(function(...) {
[17:43:54.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.749]             on.exit(options(oopts), add = TRUE)
[17:43:54.749]         }
[17:43:54.749]         {
[17:43:54.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.749]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.749]             })
[17:43:54.749]         }
[17:43:54.749]     }, args = future.call.arguments)
[17:43:54.749] }
[17:43:54.749] Lazy evaluation: FALSE
[17:43:54.749] Asynchronous evaluation: TRUE
[17:43:54.749] Local evaluation: TRUE
[17:43:54.749] Environment: R_GlobalEnv
[17:43:54.749] Capture standard output: TRUE
[17:43:54.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:54.749] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:54.749] Packages: <none>
[17:43:54.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:54.749] Resolved: FALSE
[17:43:54.749] Value: <not collected>
[17:43:54.749] Conditions captured: <none>
[17:43:54.749] Early signaling: FALSE
[17:43:54.749] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:54.749] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.761] Chunk #1 of 2 ... DONE
[17:43:54.761] Chunk #2 of 2 ...
[17:43:54.761]  - Finding globals in 'X' for chunk #2 ...
[17:43:54.761] getGlobalsAndPackages() ...
[17:43:54.761] Searching for globals...
[17:43:54.761] 
[17:43:54.762] Searching for globals ... DONE
[17:43:54.762] - globals: [0] <none>
[17:43:54.762] getGlobalsAndPackages() ... DONE
[17:43:54.762]    + additional globals found: [n=0] 
[17:43:54.762]    + additional namespaces needed: [n=0] 
[17:43:54.762]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:54.762]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.762]  - seeds: <none>
[17:43:54.762]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.762] getGlobalsAndPackages() ...
[17:43:54.762] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.763] Resolving globals: FALSE
[17:43:54.763] Tweak future expression to call with '...' arguments ...
[17:43:54.763] {
[17:43:54.763]     do.call(function(...) {
[17:43:54.763]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.763]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.763]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.763]             on.exit(options(oopts), add = TRUE)
[17:43:54.763]         }
[17:43:54.763]         {
[17:43:54.763]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.763]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.763]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.763]             })
[17:43:54.763]         }
[17:43:54.763]     }, args = future.call.arguments)
[17:43:54.763] }
[17:43:54.763] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.763] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.763] 
[17:43:54.764] getGlobalsAndPackages() ... DONE
[17:43:54.764] run() for ‘Future’ ...
[17:43:54.764] - state: ‘created’
[17:43:54.764] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.777] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.777]   - Field: ‘node’
[17:43:54.778]   - Field: ‘label’
[17:43:54.778]   - Field: ‘local’
[17:43:54.778]   - Field: ‘owner’
[17:43:54.778]   - Field: ‘envir’
[17:43:54.778]   - Field: ‘workers’
[17:43:54.778]   - Field: ‘packages’
[17:43:54.778]   - Field: ‘gc’
[17:43:54.778]   - Field: ‘conditions’
[17:43:54.778]   - Field: ‘persistent’
[17:43:54.778]   - Field: ‘expr’
[17:43:54.778]   - Field: ‘uuid’
[17:43:54.779]   - Field: ‘seed’
[17:43:54.779]   - Field: ‘version’
[17:43:54.779]   - Field: ‘result’
[17:43:54.779]   - Field: ‘asynchronous’
[17:43:54.779]   - Field: ‘calls’
[17:43:54.779]   - Field: ‘globals’
[17:43:54.779]   - Field: ‘stdout’
[17:43:54.779]   - Field: ‘earlySignal’
[17:43:54.779]   - Field: ‘lazy’
[17:43:54.779]   - Field: ‘state’
[17:43:54.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.780] - Launch lazy future ...
[17:43:54.780] Packages needed by the future expression (n = 0): <none>
[17:43:54.780] Packages needed by future strategies (n = 0): <none>
[17:43:54.780] {
[17:43:54.780]     {
[17:43:54.780]         {
[17:43:54.780]             ...future.startTime <- base::Sys.time()
[17:43:54.780]             {
[17:43:54.780]                 {
[17:43:54.780]                   {
[17:43:54.780]                     {
[17:43:54.780]                       base::local({
[17:43:54.780]                         has_future <- base::requireNamespace("future", 
[17:43:54.780]                           quietly = TRUE)
[17:43:54.780]                         if (has_future) {
[17:43:54.780]                           ns <- base::getNamespace("future")
[17:43:54.780]                           version <- ns[[".package"]][["version"]]
[17:43:54.780]                           if (is.null(version)) 
[17:43:54.780]                             version <- utils::packageVersion("future")
[17:43:54.780]                         }
[17:43:54.780]                         else {
[17:43:54.780]                           version <- NULL
[17:43:54.780]                         }
[17:43:54.780]                         if (!has_future || version < "1.8.0") {
[17:43:54.780]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.780]                             "", base::R.version$version.string), 
[17:43:54.780]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.780]                               "release", "version")], collapse = " "), 
[17:43:54.780]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.780]                             info)
[17:43:54.780]                           info <- base::paste(info, collapse = "; ")
[17:43:54.780]                           if (!has_future) {
[17:43:54.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.780]                               info)
[17:43:54.780]                           }
[17:43:54.780]                           else {
[17:43:54.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.780]                               info, version)
[17:43:54.780]                           }
[17:43:54.780]                           base::stop(msg)
[17:43:54.780]                         }
[17:43:54.780]                       })
[17:43:54.780]                     }
[17:43:54.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.780]                     base::options(mc.cores = 1L)
[17:43:54.780]                   }
[17:43:54.780]                   ...future.strategy.old <- future::plan("list")
[17:43:54.780]                   options(future.plan = NULL)
[17:43:54.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.780]                 }
[17:43:54.780]                 ...future.workdir <- getwd()
[17:43:54.780]             }
[17:43:54.780]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.780]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.780]         }
[17:43:54.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.780]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:54.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.780]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.780]             base::names(...future.oldOptions))
[17:43:54.780]     }
[17:43:54.780]     if (FALSE) {
[17:43:54.780]     }
[17:43:54.780]     else {
[17:43:54.780]         if (TRUE) {
[17:43:54.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.780]                 open = "w")
[17:43:54.780]         }
[17:43:54.780]         else {
[17:43:54.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.780]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.780]         }
[17:43:54.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.780]             base::sink(type = "output", split = FALSE)
[17:43:54.780]             base::close(...future.stdout)
[17:43:54.780]         }, add = TRUE)
[17:43:54.780]     }
[17:43:54.780]     ...future.frame <- base::sys.nframe()
[17:43:54.780]     ...future.conditions <- base::list()
[17:43:54.780]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.780]     if (FALSE) {
[17:43:54.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.780]     }
[17:43:54.780]     ...future.result <- base::tryCatch({
[17:43:54.780]         base::withCallingHandlers({
[17:43:54.780]             ...future.value <- base::withVisible(base::local({
[17:43:54.780]                 ...future.makeSendCondition <- base::local({
[17:43:54.780]                   sendCondition <- NULL
[17:43:54.780]                   function(frame = 1L) {
[17:43:54.780]                     if (is.function(sendCondition)) 
[17:43:54.780]                       return(sendCondition)
[17:43:54.780]                     ns <- getNamespace("parallel")
[17:43:54.780]                     if (exists("sendData", mode = "function", 
[17:43:54.780]                       envir = ns)) {
[17:43:54.780]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.780]                         envir = ns)
[17:43:54.780]                       envir <- sys.frame(frame)
[17:43:54.780]                       master <- NULL
[17:43:54.780]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.780]                         !identical(envir, emptyenv())) {
[17:43:54.780]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.780]                           inherits = FALSE)) {
[17:43:54.780]                           master <- get("master", mode = "list", 
[17:43:54.780]                             envir = envir, inherits = FALSE)
[17:43:54.780]                           if (inherits(master, c("SOCKnode", 
[17:43:54.780]                             "SOCK0node"))) {
[17:43:54.780]                             sendCondition <<- function(cond) {
[17:43:54.780]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.780]                                 success = TRUE)
[17:43:54.780]                               parallel_sendData(master, data)
[17:43:54.780]                             }
[17:43:54.780]                             return(sendCondition)
[17:43:54.780]                           }
[17:43:54.780]                         }
[17:43:54.780]                         frame <- frame + 1L
[17:43:54.780]                         envir <- sys.frame(frame)
[17:43:54.780]                       }
[17:43:54.780]                     }
[17:43:54.780]                     sendCondition <<- function(cond) NULL
[17:43:54.780]                   }
[17:43:54.780]                 })
[17:43:54.780]                 withCallingHandlers({
[17:43:54.780]                   {
[17:43:54.780]                     do.call(function(...) {
[17:43:54.780]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.780]                       if (!identical(...future.globals.maxSize.org, 
[17:43:54.780]                         ...future.globals.maxSize)) {
[17:43:54.780]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.780]                         on.exit(options(oopts), add = TRUE)
[17:43:54.780]                       }
[17:43:54.780]                       {
[17:43:54.780]                         lapply(seq_along(...future.elements_ii), 
[17:43:54.780]                           FUN = function(jj) {
[17:43:54.780]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.780]                             ...future.FUN(...future.X_jj, ...)
[17:43:54.780]                           })
[17:43:54.780]                       }
[17:43:54.780]                     }, args = future.call.arguments)
[17:43:54.780]                   }
[17:43:54.780]                 }, immediateCondition = function(cond) {
[17:43:54.780]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.780]                   sendCondition(cond)
[17:43:54.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.780]                   {
[17:43:54.780]                     inherits <- base::inherits
[17:43:54.780]                     invokeRestart <- base::invokeRestart
[17:43:54.780]                     is.null <- base::is.null
[17:43:54.780]                     muffled <- FALSE
[17:43:54.780]                     if (inherits(cond, "message")) {
[17:43:54.780]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.780]                       if (muffled) 
[17:43:54.780]                         invokeRestart("muffleMessage")
[17:43:54.780]                     }
[17:43:54.780]                     else if (inherits(cond, "warning")) {
[17:43:54.780]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.780]                       if (muffled) 
[17:43:54.780]                         invokeRestart("muffleWarning")
[17:43:54.780]                     }
[17:43:54.780]                     else if (inherits(cond, "condition")) {
[17:43:54.780]                       if (!is.null(pattern)) {
[17:43:54.780]                         computeRestarts <- base::computeRestarts
[17:43:54.780]                         grepl <- base::grepl
[17:43:54.780]                         restarts <- computeRestarts(cond)
[17:43:54.780]                         for (restart in restarts) {
[17:43:54.780]                           name <- restart$name
[17:43:54.780]                           if (is.null(name)) 
[17:43:54.780]                             next
[17:43:54.780]                           if (!grepl(pattern, name)) 
[17:43:54.780]                             next
[17:43:54.780]                           invokeRestart(restart)
[17:43:54.780]                           muffled <- TRUE
[17:43:54.780]                           break
[17:43:54.780]                         }
[17:43:54.780]                       }
[17:43:54.780]                     }
[17:43:54.780]                     invisible(muffled)
[17:43:54.780]                   }
[17:43:54.780]                   muffleCondition(cond)
[17:43:54.780]                 })
[17:43:54.780]             }))
[17:43:54.780]             future::FutureResult(value = ...future.value$value, 
[17:43:54.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.780]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.780]                     ...future.globalenv.names))
[17:43:54.780]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.780]         }, condition = base::local({
[17:43:54.780]             c <- base::c
[17:43:54.780]             inherits <- base::inherits
[17:43:54.780]             invokeRestart <- base::invokeRestart
[17:43:54.780]             length <- base::length
[17:43:54.780]             list <- base::list
[17:43:54.780]             seq.int <- base::seq.int
[17:43:54.780]             signalCondition <- base::signalCondition
[17:43:54.780]             sys.calls <- base::sys.calls
[17:43:54.780]             `[[` <- base::`[[`
[17:43:54.780]             `+` <- base::`+`
[17:43:54.780]             `<<-` <- base::`<<-`
[17:43:54.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.780]                   3L)]
[17:43:54.780]             }
[17:43:54.780]             function(cond) {
[17:43:54.780]                 is_error <- inherits(cond, "error")
[17:43:54.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.780]                   NULL)
[17:43:54.780]                 if (is_error) {
[17:43:54.780]                   sessionInformation <- function() {
[17:43:54.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.780]                       search = base::search(), system = base::Sys.info())
[17:43:54.780]                   }
[17:43:54.780]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.780]                     cond$call), session = sessionInformation(), 
[17:43:54.780]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.780]                   signalCondition(cond)
[17:43:54.780]                 }
[17:43:54.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.780]                 "immediateCondition"))) {
[17:43:54.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.780]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.780]                   if (TRUE && !signal) {
[17:43:54.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.780]                     {
[17:43:54.780]                       inherits <- base::inherits
[17:43:54.780]                       invokeRestart <- base::invokeRestart
[17:43:54.780]                       is.null <- base::is.null
[17:43:54.780]                       muffled <- FALSE
[17:43:54.780]                       if (inherits(cond, "message")) {
[17:43:54.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.780]                         if (muffled) 
[17:43:54.780]                           invokeRestart("muffleMessage")
[17:43:54.780]                       }
[17:43:54.780]                       else if (inherits(cond, "warning")) {
[17:43:54.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.780]                         if (muffled) 
[17:43:54.780]                           invokeRestart("muffleWarning")
[17:43:54.780]                       }
[17:43:54.780]                       else if (inherits(cond, "condition")) {
[17:43:54.780]                         if (!is.null(pattern)) {
[17:43:54.780]                           computeRestarts <- base::computeRestarts
[17:43:54.780]                           grepl <- base::grepl
[17:43:54.780]                           restarts <- computeRestarts(cond)
[17:43:54.780]                           for (restart in restarts) {
[17:43:54.780]                             name <- restart$name
[17:43:54.780]                             if (is.null(name)) 
[17:43:54.780]                               next
[17:43:54.780]                             if (!grepl(pattern, name)) 
[17:43:54.780]                               next
[17:43:54.780]                             invokeRestart(restart)
[17:43:54.780]                             muffled <- TRUE
[17:43:54.780]                             break
[17:43:54.780]                           }
[17:43:54.780]                         }
[17:43:54.780]                       }
[17:43:54.780]                       invisible(muffled)
[17:43:54.780]                     }
[17:43:54.780]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.780]                   }
[17:43:54.780]                 }
[17:43:54.780]                 else {
[17:43:54.780]                   if (TRUE) {
[17:43:54.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.780]                     {
[17:43:54.780]                       inherits <- base::inherits
[17:43:54.780]                       invokeRestart <- base::invokeRestart
[17:43:54.780]                       is.null <- base::is.null
[17:43:54.780]                       muffled <- FALSE
[17:43:54.780]                       if (inherits(cond, "message")) {
[17:43:54.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.780]                         if (muffled) 
[17:43:54.780]                           invokeRestart("muffleMessage")
[17:43:54.780]                       }
[17:43:54.780]                       else if (inherits(cond, "warning")) {
[17:43:54.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.780]                         if (muffled) 
[17:43:54.780]                           invokeRestart("muffleWarning")
[17:43:54.780]                       }
[17:43:54.780]                       else if (inherits(cond, "condition")) {
[17:43:54.780]                         if (!is.null(pattern)) {
[17:43:54.780]                           computeRestarts <- base::computeRestarts
[17:43:54.780]                           grepl <- base::grepl
[17:43:54.780]                           restarts <- computeRestarts(cond)
[17:43:54.780]                           for (restart in restarts) {
[17:43:54.780]                             name <- restart$name
[17:43:54.780]                             if (is.null(name)) 
[17:43:54.780]                               next
[17:43:54.780]                             if (!grepl(pattern, name)) 
[17:43:54.780]                               next
[17:43:54.780]                             invokeRestart(restart)
[17:43:54.780]                             muffled <- TRUE
[17:43:54.780]                             break
[17:43:54.780]                           }
[17:43:54.780]                         }
[17:43:54.780]                       }
[17:43:54.780]                       invisible(muffled)
[17:43:54.780]                     }
[17:43:54.780]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.780]                   }
[17:43:54.780]                 }
[17:43:54.780]             }
[17:43:54.780]         }))
[17:43:54.780]     }, error = function(ex) {
[17:43:54.780]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.780]                 ...future.rng), started = ...future.startTime, 
[17:43:54.780]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.780]             version = "1.8"), class = "FutureResult")
[17:43:54.780]     }, finally = {
[17:43:54.780]         if (!identical(...future.workdir, getwd())) 
[17:43:54.780]             setwd(...future.workdir)
[17:43:54.780]         {
[17:43:54.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.780]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.780]             }
[17:43:54.780]             base::options(...future.oldOptions)
[17:43:54.780]             if (.Platform$OS.type == "windows") {
[17:43:54.780]                 old_names <- names(...future.oldEnvVars)
[17:43:54.780]                 envs <- base::Sys.getenv()
[17:43:54.780]                 names <- names(envs)
[17:43:54.780]                 common <- intersect(names, old_names)
[17:43:54.780]                 added <- setdiff(names, old_names)
[17:43:54.780]                 removed <- setdiff(old_names, names)
[17:43:54.780]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.780]                   envs[common]]
[17:43:54.780]                 NAMES <- toupper(changed)
[17:43:54.780]                 args <- list()
[17:43:54.780]                 for (kk in seq_along(NAMES)) {
[17:43:54.780]                   name <- changed[[kk]]
[17:43:54.780]                   NAME <- NAMES[[kk]]
[17:43:54.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.780]                     next
[17:43:54.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.780]                 }
[17:43:54.780]                 NAMES <- toupper(added)
[17:43:54.780]                 for (kk in seq_along(NAMES)) {
[17:43:54.780]                   name <- added[[kk]]
[17:43:54.780]                   NAME <- NAMES[[kk]]
[17:43:54.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.780]                     next
[17:43:54.780]                   args[[name]] <- ""
[17:43:54.780]                 }
[17:43:54.780]                 NAMES <- toupper(removed)
[17:43:54.780]                 for (kk in seq_along(NAMES)) {
[17:43:54.780]                   name <- removed[[kk]]
[17:43:54.780]                   NAME <- NAMES[[kk]]
[17:43:54.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.780]                     next
[17:43:54.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.780]                 }
[17:43:54.780]                 if (length(args) > 0) 
[17:43:54.780]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.780]             }
[17:43:54.780]             else {
[17:43:54.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.780]             }
[17:43:54.780]             {
[17:43:54.780]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.780]                   0L) {
[17:43:54.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.780]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.780]                   base::options(opts)
[17:43:54.780]                 }
[17:43:54.780]                 {
[17:43:54.780]                   {
[17:43:54.780]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.780]                     NULL
[17:43:54.780]                   }
[17:43:54.780]                   options(future.plan = NULL)
[17:43:54.780]                   if (is.na(NA_character_)) 
[17:43:54.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.780]                     .init = FALSE)
[17:43:54.780]                 }
[17:43:54.780]             }
[17:43:54.780]         }
[17:43:54.780]     })
[17:43:54.780]     if (TRUE) {
[17:43:54.780]         base::sink(type = "output", split = FALSE)
[17:43:54.780]         if (TRUE) {
[17:43:54.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.780]         }
[17:43:54.780]         else {
[17:43:54.780]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.780]         }
[17:43:54.780]         base::close(...future.stdout)
[17:43:54.780]         ...future.stdout <- NULL
[17:43:54.780]     }
[17:43:54.780]     ...future.result$conditions <- ...future.conditions
[17:43:54.780]     ...future.result$finished <- base::Sys.time()
[17:43:54.780]     ...future.result
[17:43:54.780] }
[17:43:54.783] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[17:43:54.783] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:43:54.783] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:43:54.784] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:43:54.784] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:43:54.784] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[17:43:54.785] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[17:43:54.785] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:54.785] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.785] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:54.786] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.786] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[17:43:54.786] MultisessionFuture started
[17:43:54.786] - Launch lazy future ... done
[17:43:54.786] run() for ‘MultisessionFuture’ ... done
[17:43:54.787] Created future:
[17:43:54.787] MultisessionFuture:
[17:43:54.787] Label: ‘future_by-2’
[17:43:54.787] Expression:
[17:43:54.787] {
[17:43:54.787]     do.call(function(...) {
[17:43:54.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.787]             on.exit(options(oopts), add = TRUE)
[17:43:54.787]         }
[17:43:54.787]         {
[17:43:54.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.787]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.787]             })
[17:43:54.787]         }
[17:43:54.787]     }, args = future.call.arguments)
[17:43:54.787] }
[17:43:54.787] Lazy evaluation: FALSE
[17:43:54.787] Asynchronous evaluation: TRUE
[17:43:54.787] Local evaluation: TRUE
[17:43:54.787] Environment: R_GlobalEnv
[17:43:54.787] Capture standard output: TRUE
[17:43:54.787] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:54.787] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:54.787] Packages: <none>
[17:43:54.787] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:54.787] Resolved: FALSE
[17:43:54.787] Value: <not collected>
[17:43:54.787] Conditions captured: <none>
[17:43:54.787] Early signaling: FALSE
[17:43:54.787] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:54.787] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.798] Chunk #2 of 2 ... DONE
[17:43:54.798] Launching 2 futures (chunks) ... DONE
[17:43:54.798] Resolving 2 futures (chunks) ...
[17:43:54.798] resolve() on list ...
[17:43:54.799]  recursive: 0
[17:43:54.799]  length: 2
[17:43:54.799] 
[17:43:54.799] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.799] - Validating connection of MultisessionFuture
[17:43:54.799] - received message: FutureResult
[17:43:54.800] - Received FutureResult
[17:43:54.800] - Erased future from FutureRegistry
[17:43:54.800] result() for ClusterFuture ...
[17:43:54.800] - result already collected: FutureResult
[17:43:54.800] result() for ClusterFuture ... done
[17:43:54.800] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.800] Future #1
[17:43:54.800] result() for ClusterFuture ...
[17:43:54.800] - result already collected: FutureResult
[17:43:54.800] result() for ClusterFuture ... done
[17:43:54.800] result() for ClusterFuture ...
[17:43:54.801] - result already collected: FutureResult
[17:43:54.801] result() for ClusterFuture ... done
[17:43:54.801] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:54.801] - nx: 2
[17:43:54.801] - relay: TRUE
[17:43:54.801] - stdout: TRUE
[17:43:54.801] - signal: TRUE
[17:43:54.801] - resignal: FALSE
[17:43:54.801] - force: TRUE
[17:43:54.801] - relayed: [n=2] FALSE, FALSE
[17:43:54.801] - queued futures: [n=2] FALSE, FALSE
[17:43:54.802]  - until=1
[17:43:54.802]  - relaying element #1
[17:43:54.802] result() for ClusterFuture ...
[17:43:54.802] - result already collected: FutureResult
[17:43:54.802] result() for ClusterFuture ... done
[17:43:54.802] result() for ClusterFuture ...
[17:43:54.802] - result already collected: FutureResult
[17:43:54.802] result() for ClusterFuture ... done
[17:43:54.802] result() for ClusterFuture ...
[17:43:54.802] - result already collected: FutureResult
[17:43:54.802] result() for ClusterFuture ... done
[17:43:54.802] result() for ClusterFuture ...
[17:43:54.803] - result already collected: FutureResult
[17:43:54.803] result() for ClusterFuture ... done
[17:43:54.803] - relayed: [n=2] TRUE, FALSE
[17:43:54.803] - queued futures: [n=2] TRUE, FALSE
[17:43:54.803] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:54.803]  length: 1 (resolved future 1)
[17:43:54.829] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.830] - Validating connection of MultisessionFuture
[17:43:54.830] - received message: FutureResult
[17:43:54.830] - Received FutureResult
[17:43:54.830] - Erased future from FutureRegistry
[17:43:54.830] result() for ClusterFuture ...
[17:43:54.830] - result already collected: FutureResult
[17:43:54.830] result() for ClusterFuture ... done
[17:43:54.830] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.830] Future #2
[17:43:54.830] result() for ClusterFuture ...
[17:43:54.831] - result already collected: FutureResult
[17:43:54.831] result() for ClusterFuture ... done
[17:43:54.831] result() for ClusterFuture ...
[17:43:54.831] - result already collected: FutureResult
[17:43:54.831] result() for ClusterFuture ... done
[17:43:54.831] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:54.831] - nx: 2
[17:43:54.831] - relay: TRUE
[17:43:54.831] - stdout: TRUE
[17:43:54.831] - signal: TRUE
[17:43:54.831] - resignal: FALSE
[17:43:54.832] - force: TRUE
[17:43:54.832] - relayed: [n=2] TRUE, FALSE
[17:43:54.832] - queued futures: [n=2] TRUE, FALSE
[17:43:54.832]  - until=2
[17:43:54.832]  - relaying element #2
[17:43:54.832] result() for ClusterFuture ...
[17:43:54.832] - result already collected: FutureResult
[17:43:54.832] result() for ClusterFuture ... done
[17:43:54.832] result() for ClusterFuture ...
[17:43:54.832] - result already collected: FutureResult
[17:43:54.832] result() for ClusterFuture ... done
[17:43:54.833] result() for ClusterFuture ...
[17:43:54.833] - result already collected: FutureResult
[17:43:54.833] result() for ClusterFuture ... done
[17:43:54.833] result() for ClusterFuture ...
[17:43:54.833] - result already collected: FutureResult
[17:43:54.833] result() for ClusterFuture ... done
[17:43:54.833] - relayed: [n=2] TRUE, TRUE
[17:43:54.833] - queued futures: [n=2] TRUE, TRUE
[17:43:54.833] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:54.833]  length: 0 (resolved future 2)
[17:43:54.833] Relaying remaining futures
[17:43:54.833] signalConditionsASAP(NULL, pos=0) ...
[17:43:54.834] - nx: 2
[17:43:54.834] - relay: TRUE
[17:43:54.834] - stdout: TRUE
[17:43:54.834] - signal: TRUE
[17:43:54.834] - resignal: FALSE
[17:43:54.834] - force: TRUE
[17:43:54.834] - relayed: [n=2] TRUE, TRUE
[17:43:54.834] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:54.834] - relayed: [n=2] TRUE, TRUE
[17:43:54.834] - queued futures: [n=2] TRUE, TRUE
[17:43:54.834] signalConditionsASAP(NULL, pos=0) ... done
[17:43:54.834] resolve() on list ... DONE
[17:43:54.835] result() for ClusterFuture ...
[17:43:54.835] - result already collected: FutureResult
[17:43:54.835] result() for ClusterFuture ... done
[17:43:54.835] result() for ClusterFuture ...
[17:43:54.835] - result already collected: FutureResult
[17:43:54.835] result() for ClusterFuture ... done
[17:43:54.835] result() for ClusterFuture ...
[17:43:54.835] - result already collected: FutureResult
[17:43:54.835] result() for ClusterFuture ... done
[17:43:54.835] result() for ClusterFuture ...
[17:43:54.835] - result already collected: FutureResult
[17:43:54.836] result() for ClusterFuture ... done
[17:43:54.836]  - Number of value chunks collected: 2
[17:43:54.836] Resolving 2 futures (chunks) ... DONE
[17:43:54.836] Reducing values from 2 chunks ...
[17:43:54.836]  - Number of values collected after concatenation: 6
[17:43:54.836]  - Number of values expected: 6
[17:43:54.836] Reducing values from 2 chunks ... DONE
[17:43:54.836] future_lapply() ... DONE
[17:43:54.836] future_by_internal() ... DONE
[17:43:54.837] future_by_internal() ...
[17:43:54.838] future_lapply() ...
[17:43:54.842] Number of chunks: 2
[17:43:54.842] getGlobalsAndPackagesXApply() ...
[17:43:54.842]  - future.globals: TRUE
[17:43:54.842] getGlobalsAndPackages() ...
[17:43:54.842] Searching for globals...
[17:43:54.844] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:54.844] Searching for globals ... DONE
[17:43:54.844] Resolving globals: FALSE
[17:43:54.845] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:43:54.845] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:43:54.845] - globals: [1] ‘FUN’
[17:43:54.845] - packages: [1] ‘stats’
[17:43:54.845] getGlobalsAndPackages() ... DONE
[17:43:54.845]  - globals found/used: [n=1] ‘FUN’
[17:43:54.845]  - needed namespaces: [n=1] ‘stats’
[17:43:54.846] Finding globals ... DONE
[17:43:54.846]  - use_args: TRUE
[17:43:54.846]  - Getting '...' globals ...
[17:43:54.846] resolve() on list ...
[17:43:54.846]  recursive: 0
[17:43:54.846]  length: 1
[17:43:54.846]  elements: ‘...’
[17:43:54.846]  length: 0 (resolved future 1)
[17:43:54.847] resolve() on list ... DONE
[17:43:54.847]    - '...' content: [n=1] ‘singular.ok’
[17:43:54.847] List of 1
[17:43:54.847]  $ ...:List of 1
[17:43:54.847]   ..$ singular.ok: logi FALSE
[17:43:54.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.847]  - attr(*, "where")=List of 1
[17:43:54.847]   ..$ ...:<environment: 0x55d6bce715b8> 
[17:43:54.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.847]  - attr(*, "resolved")= logi TRUE
[17:43:54.847]  - attr(*, "total_size")= num NA
[17:43:54.850]  - Getting '...' globals ... DONE
[17:43:54.850] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:54.850] List of 2
[17:43:54.850]  $ ...future.FUN:function (x, ...)  
[17:43:54.850]  $ ...          :List of 1
[17:43:54.850]   ..$ singular.ok: logi FALSE
[17:43:54.850]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.850]  - attr(*, "where")=List of 2
[17:43:54.850]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:54.850]   ..$ ...          :<environment: 0x55d6bce715b8> 
[17:43:54.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.850]  - attr(*, "resolved")= logi FALSE
[17:43:54.850]  - attr(*, "total_size")= num 5384
[17:43:54.853] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:54.853] getGlobalsAndPackagesXApply() ... DONE
[17:43:54.853] Number of futures (= number of chunks): 2
[17:43:54.853] Launching 2 futures (chunks) ...
[17:43:54.853] Chunk #1 of 2 ...
[17:43:54.854]  - Finding globals in 'X' for chunk #1 ...
[17:43:54.854] getGlobalsAndPackages() ...
[17:43:54.854] Searching for globals...
[17:43:54.854] 
[17:43:54.854] Searching for globals ... DONE
[17:43:54.854] - globals: [0] <none>
[17:43:54.854] getGlobalsAndPackages() ... DONE
[17:43:54.854]    + additional globals found: [n=0] 
[17:43:54.854]    + additional namespaces needed: [n=0] 
[17:43:54.855]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:54.855]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.855]  - seeds: <none>
[17:43:54.855]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.855] getGlobalsAndPackages() ...
[17:43:54.855] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.855] Resolving globals: FALSE
[17:43:54.855] Tweak future expression to call with '...' arguments ...
[17:43:54.855] {
[17:43:54.855]     do.call(function(...) {
[17:43:54.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.855]             on.exit(options(oopts), add = TRUE)
[17:43:54.855]         }
[17:43:54.855]         {
[17:43:54.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.855]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.855]             })
[17:43:54.855]         }
[17:43:54.855]     }, args = future.call.arguments)
[17:43:54.855] }
[17:43:54.856] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.856] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.856] 
[17:43:54.856] getGlobalsAndPackages() ... DONE
[17:43:54.856] run() for ‘Future’ ...
[17:43:54.857] - state: ‘created’
[17:43:54.857] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.873]   - Field: ‘node’
[17:43:54.873]   - Field: ‘label’
[17:43:54.873]   - Field: ‘local’
[17:43:54.873]   - Field: ‘owner’
[17:43:54.873]   - Field: ‘envir’
[17:43:54.873]   - Field: ‘workers’
[17:43:54.873]   - Field: ‘packages’
[17:43:54.873]   - Field: ‘gc’
[17:43:54.873]   - Field: ‘conditions’
[17:43:54.873]   - Field: ‘persistent’
[17:43:54.873]   - Field: ‘expr’
[17:43:54.874]   - Field: ‘uuid’
[17:43:54.874]   - Field: ‘seed’
[17:43:54.874]   - Field: ‘version’
[17:43:54.874]   - Field: ‘result’
[17:43:54.874]   - Field: ‘asynchronous’
[17:43:54.874]   - Field: ‘calls’
[17:43:54.874]   - Field: ‘globals’
[17:43:54.874]   - Field: ‘stdout’
[17:43:54.874]   - Field: ‘earlySignal’
[17:43:54.874]   - Field: ‘lazy’
[17:43:54.874]   - Field: ‘state’
[17:43:54.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.875] - Launch lazy future ...
[17:43:54.875] Packages needed by the future expression (n = 1): ‘stats’
[17:43:54.875] Packages needed by future strategies (n = 0): <none>
[17:43:54.875] {
[17:43:54.875]     {
[17:43:54.875]         {
[17:43:54.875]             ...future.startTime <- base::Sys.time()
[17:43:54.875]             {
[17:43:54.875]                 {
[17:43:54.875]                   {
[17:43:54.875]                     {
[17:43:54.875]                       {
[17:43:54.875]                         base::local({
[17:43:54.875]                           has_future <- base::requireNamespace("future", 
[17:43:54.875]                             quietly = TRUE)
[17:43:54.875]                           if (has_future) {
[17:43:54.875]                             ns <- base::getNamespace("future")
[17:43:54.875]                             version <- ns[[".package"]][["version"]]
[17:43:54.875]                             if (is.null(version)) 
[17:43:54.875]                               version <- utils::packageVersion("future")
[17:43:54.875]                           }
[17:43:54.875]                           else {
[17:43:54.875]                             version <- NULL
[17:43:54.875]                           }
[17:43:54.875]                           if (!has_future || version < "1.8.0") {
[17:43:54.875]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.875]                               "", base::R.version$version.string), 
[17:43:54.875]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:54.875]                                 base::R.version$platform, 8 * 
[17:43:54.875]                                   base::.Machine$sizeof.pointer), 
[17:43:54.875]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.875]                                 "release", "version")], collapse = " "), 
[17:43:54.875]                               hostname = base::Sys.info()[["nodename"]])
[17:43:54.875]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.875]                               info)
[17:43:54.875]                             info <- base::paste(info, collapse = "; ")
[17:43:54.875]                             if (!has_future) {
[17:43:54.875]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.875]                                 info)
[17:43:54.875]                             }
[17:43:54.875]                             else {
[17:43:54.875]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.875]                                 info, version)
[17:43:54.875]                             }
[17:43:54.875]                             base::stop(msg)
[17:43:54.875]                           }
[17:43:54.875]                         })
[17:43:54.875]                       }
[17:43:54.875]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.875]                       base::options(mc.cores = 1L)
[17:43:54.875]                     }
[17:43:54.875]                     base::local({
[17:43:54.875]                       for (pkg in "stats") {
[17:43:54.875]                         base::loadNamespace(pkg)
[17:43:54.875]                         base::library(pkg, character.only = TRUE)
[17:43:54.875]                       }
[17:43:54.875]                     })
[17:43:54.875]                   }
[17:43:54.875]                   ...future.strategy.old <- future::plan("list")
[17:43:54.875]                   options(future.plan = NULL)
[17:43:54.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.875]                 }
[17:43:54.875]                 ...future.workdir <- getwd()
[17:43:54.875]             }
[17:43:54.875]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.875]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.875]         }
[17:43:54.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.875]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:54.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.875]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.875]             base::names(...future.oldOptions))
[17:43:54.875]     }
[17:43:54.875]     if (FALSE) {
[17:43:54.875]     }
[17:43:54.875]     else {
[17:43:54.875]         if (TRUE) {
[17:43:54.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.875]                 open = "w")
[17:43:54.875]         }
[17:43:54.875]         else {
[17:43:54.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.875]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.875]         }
[17:43:54.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.875]             base::sink(type = "output", split = FALSE)
[17:43:54.875]             base::close(...future.stdout)
[17:43:54.875]         }, add = TRUE)
[17:43:54.875]     }
[17:43:54.875]     ...future.frame <- base::sys.nframe()
[17:43:54.875]     ...future.conditions <- base::list()
[17:43:54.875]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.875]     if (FALSE) {
[17:43:54.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.875]     }
[17:43:54.875]     ...future.result <- base::tryCatch({
[17:43:54.875]         base::withCallingHandlers({
[17:43:54.875]             ...future.value <- base::withVisible(base::local({
[17:43:54.875]                 ...future.makeSendCondition <- base::local({
[17:43:54.875]                   sendCondition <- NULL
[17:43:54.875]                   function(frame = 1L) {
[17:43:54.875]                     if (is.function(sendCondition)) 
[17:43:54.875]                       return(sendCondition)
[17:43:54.875]                     ns <- getNamespace("parallel")
[17:43:54.875]                     if (exists("sendData", mode = "function", 
[17:43:54.875]                       envir = ns)) {
[17:43:54.875]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.875]                         envir = ns)
[17:43:54.875]                       envir <- sys.frame(frame)
[17:43:54.875]                       master <- NULL
[17:43:54.875]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.875]                         !identical(envir, emptyenv())) {
[17:43:54.875]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.875]                           inherits = FALSE)) {
[17:43:54.875]                           master <- get("master", mode = "list", 
[17:43:54.875]                             envir = envir, inherits = FALSE)
[17:43:54.875]                           if (inherits(master, c("SOCKnode", 
[17:43:54.875]                             "SOCK0node"))) {
[17:43:54.875]                             sendCondition <<- function(cond) {
[17:43:54.875]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.875]                                 success = TRUE)
[17:43:54.875]                               parallel_sendData(master, data)
[17:43:54.875]                             }
[17:43:54.875]                             return(sendCondition)
[17:43:54.875]                           }
[17:43:54.875]                         }
[17:43:54.875]                         frame <- frame + 1L
[17:43:54.875]                         envir <- sys.frame(frame)
[17:43:54.875]                       }
[17:43:54.875]                     }
[17:43:54.875]                     sendCondition <<- function(cond) NULL
[17:43:54.875]                   }
[17:43:54.875]                 })
[17:43:54.875]                 withCallingHandlers({
[17:43:54.875]                   {
[17:43:54.875]                     do.call(function(...) {
[17:43:54.875]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.875]                       if (!identical(...future.globals.maxSize.org, 
[17:43:54.875]                         ...future.globals.maxSize)) {
[17:43:54.875]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.875]                         on.exit(options(oopts), add = TRUE)
[17:43:54.875]                       }
[17:43:54.875]                       {
[17:43:54.875]                         lapply(seq_along(...future.elements_ii), 
[17:43:54.875]                           FUN = function(jj) {
[17:43:54.875]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.875]                             ...future.FUN(...future.X_jj, ...)
[17:43:54.875]                           })
[17:43:54.875]                       }
[17:43:54.875]                     }, args = future.call.arguments)
[17:43:54.875]                   }
[17:43:54.875]                 }, immediateCondition = function(cond) {
[17:43:54.875]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.875]                   sendCondition(cond)
[17:43:54.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.875]                   {
[17:43:54.875]                     inherits <- base::inherits
[17:43:54.875]                     invokeRestart <- base::invokeRestart
[17:43:54.875]                     is.null <- base::is.null
[17:43:54.875]                     muffled <- FALSE
[17:43:54.875]                     if (inherits(cond, "message")) {
[17:43:54.875]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.875]                       if (muffled) 
[17:43:54.875]                         invokeRestart("muffleMessage")
[17:43:54.875]                     }
[17:43:54.875]                     else if (inherits(cond, "warning")) {
[17:43:54.875]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.875]                       if (muffled) 
[17:43:54.875]                         invokeRestart("muffleWarning")
[17:43:54.875]                     }
[17:43:54.875]                     else if (inherits(cond, "condition")) {
[17:43:54.875]                       if (!is.null(pattern)) {
[17:43:54.875]                         computeRestarts <- base::computeRestarts
[17:43:54.875]                         grepl <- base::grepl
[17:43:54.875]                         restarts <- computeRestarts(cond)
[17:43:54.875]                         for (restart in restarts) {
[17:43:54.875]                           name <- restart$name
[17:43:54.875]                           if (is.null(name)) 
[17:43:54.875]                             next
[17:43:54.875]                           if (!grepl(pattern, name)) 
[17:43:54.875]                             next
[17:43:54.875]                           invokeRestart(restart)
[17:43:54.875]                           muffled <- TRUE
[17:43:54.875]                           break
[17:43:54.875]                         }
[17:43:54.875]                       }
[17:43:54.875]                     }
[17:43:54.875]                     invisible(muffled)
[17:43:54.875]                   }
[17:43:54.875]                   muffleCondition(cond)
[17:43:54.875]                 })
[17:43:54.875]             }))
[17:43:54.875]             future::FutureResult(value = ...future.value$value, 
[17:43:54.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.875]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.875]                     ...future.globalenv.names))
[17:43:54.875]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.875]         }, condition = base::local({
[17:43:54.875]             c <- base::c
[17:43:54.875]             inherits <- base::inherits
[17:43:54.875]             invokeRestart <- base::invokeRestart
[17:43:54.875]             length <- base::length
[17:43:54.875]             list <- base::list
[17:43:54.875]             seq.int <- base::seq.int
[17:43:54.875]             signalCondition <- base::signalCondition
[17:43:54.875]             sys.calls <- base::sys.calls
[17:43:54.875]             `[[` <- base::`[[`
[17:43:54.875]             `+` <- base::`+`
[17:43:54.875]             `<<-` <- base::`<<-`
[17:43:54.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.875]                   3L)]
[17:43:54.875]             }
[17:43:54.875]             function(cond) {
[17:43:54.875]                 is_error <- inherits(cond, "error")
[17:43:54.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.875]                   NULL)
[17:43:54.875]                 if (is_error) {
[17:43:54.875]                   sessionInformation <- function() {
[17:43:54.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.875]                       search = base::search(), system = base::Sys.info())
[17:43:54.875]                   }
[17:43:54.875]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.875]                     cond$call), session = sessionInformation(), 
[17:43:54.875]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.875]                   signalCondition(cond)
[17:43:54.875]                 }
[17:43:54.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.875]                 "immediateCondition"))) {
[17:43:54.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.875]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.875]                   if (TRUE && !signal) {
[17:43:54.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.875]                     {
[17:43:54.875]                       inherits <- base::inherits
[17:43:54.875]                       invokeRestart <- base::invokeRestart
[17:43:54.875]                       is.null <- base::is.null
[17:43:54.875]                       muffled <- FALSE
[17:43:54.875]                       if (inherits(cond, "message")) {
[17:43:54.875]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.875]                         if (muffled) 
[17:43:54.875]                           invokeRestart("muffleMessage")
[17:43:54.875]                       }
[17:43:54.875]                       else if (inherits(cond, "warning")) {
[17:43:54.875]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.875]                         if (muffled) 
[17:43:54.875]                           invokeRestart("muffleWarning")
[17:43:54.875]                       }
[17:43:54.875]                       else if (inherits(cond, "condition")) {
[17:43:54.875]                         if (!is.null(pattern)) {
[17:43:54.875]                           computeRestarts <- base::computeRestarts
[17:43:54.875]                           grepl <- base::grepl
[17:43:54.875]                           restarts <- computeRestarts(cond)
[17:43:54.875]                           for (restart in restarts) {
[17:43:54.875]                             name <- restart$name
[17:43:54.875]                             if (is.null(name)) 
[17:43:54.875]                               next
[17:43:54.875]                             if (!grepl(pattern, name)) 
[17:43:54.875]                               next
[17:43:54.875]                             invokeRestart(restart)
[17:43:54.875]                             muffled <- TRUE
[17:43:54.875]                             break
[17:43:54.875]                           }
[17:43:54.875]                         }
[17:43:54.875]                       }
[17:43:54.875]                       invisible(muffled)
[17:43:54.875]                     }
[17:43:54.875]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.875]                   }
[17:43:54.875]                 }
[17:43:54.875]                 else {
[17:43:54.875]                   if (TRUE) {
[17:43:54.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.875]                     {
[17:43:54.875]                       inherits <- base::inherits
[17:43:54.875]                       invokeRestart <- base::invokeRestart
[17:43:54.875]                       is.null <- base::is.null
[17:43:54.875]                       muffled <- FALSE
[17:43:54.875]                       if (inherits(cond, "message")) {
[17:43:54.875]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.875]                         if (muffled) 
[17:43:54.875]                           invokeRestart("muffleMessage")
[17:43:54.875]                       }
[17:43:54.875]                       else if (inherits(cond, "warning")) {
[17:43:54.875]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.875]                         if (muffled) 
[17:43:54.875]                           invokeRestart("muffleWarning")
[17:43:54.875]                       }
[17:43:54.875]                       else if (inherits(cond, "condition")) {
[17:43:54.875]                         if (!is.null(pattern)) {
[17:43:54.875]                           computeRestarts <- base::computeRestarts
[17:43:54.875]                           grepl <- base::grepl
[17:43:54.875]                           restarts <- computeRestarts(cond)
[17:43:54.875]                           for (restart in restarts) {
[17:43:54.875]                             name <- restart$name
[17:43:54.875]                             if (is.null(name)) 
[17:43:54.875]                               next
[17:43:54.875]                             if (!grepl(pattern, name)) 
[17:43:54.875]                               next
[17:43:54.875]                             invokeRestart(restart)
[17:43:54.875]                             muffled <- TRUE
[17:43:54.875]                             break
[17:43:54.875]                           }
[17:43:54.875]                         }
[17:43:54.875]                       }
[17:43:54.875]                       invisible(muffled)
[17:43:54.875]                     }
[17:43:54.875]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.875]                   }
[17:43:54.875]                 }
[17:43:54.875]             }
[17:43:54.875]         }))
[17:43:54.875]     }, error = function(ex) {
[17:43:54.875]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.875]                 ...future.rng), started = ...future.startTime, 
[17:43:54.875]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.875]             version = "1.8"), class = "FutureResult")
[17:43:54.875]     }, finally = {
[17:43:54.875]         if (!identical(...future.workdir, getwd())) 
[17:43:54.875]             setwd(...future.workdir)
[17:43:54.875]         {
[17:43:54.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.875]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.875]             }
[17:43:54.875]             base::options(...future.oldOptions)
[17:43:54.875]             if (.Platform$OS.type == "windows") {
[17:43:54.875]                 old_names <- names(...future.oldEnvVars)
[17:43:54.875]                 envs <- base::Sys.getenv()
[17:43:54.875]                 names <- names(envs)
[17:43:54.875]                 common <- intersect(names, old_names)
[17:43:54.875]                 added <- setdiff(names, old_names)
[17:43:54.875]                 removed <- setdiff(old_names, names)
[17:43:54.875]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.875]                   envs[common]]
[17:43:54.875]                 NAMES <- toupper(changed)
[17:43:54.875]                 args <- list()
[17:43:54.875]                 for (kk in seq_along(NAMES)) {
[17:43:54.875]                   name <- changed[[kk]]
[17:43:54.875]                   NAME <- NAMES[[kk]]
[17:43:54.875]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.875]                     next
[17:43:54.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.875]                 }
[17:43:54.875]                 NAMES <- toupper(added)
[17:43:54.875]                 for (kk in seq_along(NAMES)) {
[17:43:54.875]                   name <- added[[kk]]
[17:43:54.875]                   NAME <- NAMES[[kk]]
[17:43:54.875]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.875]                     next
[17:43:54.875]                   args[[name]] <- ""
[17:43:54.875]                 }
[17:43:54.875]                 NAMES <- toupper(removed)
[17:43:54.875]                 for (kk in seq_along(NAMES)) {
[17:43:54.875]                   name <- removed[[kk]]
[17:43:54.875]                   NAME <- NAMES[[kk]]
[17:43:54.875]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.875]                     next
[17:43:54.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.875]                 }
[17:43:54.875]                 if (length(args) > 0) 
[17:43:54.875]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.875]             }
[17:43:54.875]             else {
[17:43:54.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.875]             }
[17:43:54.875]             {
[17:43:54.875]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.875]                   0L) {
[17:43:54.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.875]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.875]                   base::options(opts)
[17:43:54.875]                 }
[17:43:54.875]                 {
[17:43:54.875]                   {
[17:43:54.875]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.875]                     NULL
[17:43:54.875]                   }
[17:43:54.875]                   options(future.plan = NULL)
[17:43:54.875]                   if (is.na(NA_character_)) 
[17:43:54.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.875]                     .init = FALSE)
[17:43:54.875]                 }
[17:43:54.875]             }
[17:43:54.875]         }
[17:43:54.875]     })
[17:43:54.875]     if (TRUE) {
[17:43:54.875]         base::sink(type = "output", split = FALSE)
[17:43:54.875]         if (TRUE) {
[17:43:54.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.875]         }
[17:43:54.875]         else {
[17:43:54.875]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.875]         }
[17:43:54.875]         base::close(...future.stdout)
[17:43:54.875]         ...future.stdout <- NULL
[17:43:54.875]     }
[17:43:54.875]     ...future.result$conditions <- ...future.conditions
[17:43:54.875]     ...future.result$finished <- base::Sys.time()
[17:43:54.875]     ...future.result
[17:43:54.875] }
[17:43:54.878] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[17:43:54.878] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[17:43:54.879] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[17:43:54.879] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:43:54.879] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:43:54.879] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:43:54.880] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:43:54.880] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:54.880] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.880] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:54.881] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:54.881] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[17:43:54.881] MultisessionFuture started
[17:43:54.881] - Launch lazy future ... done
[17:43:54.881] run() for ‘MultisessionFuture’ ... done
[17:43:54.881] Created future:
[17:43:54.881] MultisessionFuture:
[17:43:54.881] Label: ‘future_by-1’
[17:43:54.881] Expression:
[17:43:54.881] {
[17:43:54.881]     do.call(function(...) {
[17:43:54.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.881]             on.exit(options(oopts), add = TRUE)
[17:43:54.881]         }
[17:43:54.881]         {
[17:43:54.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.881]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.881]             })
[17:43:54.881]         }
[17:43:54.881]     }, args = future.call.arguments)
[17:43:54.881] }
[17:43:54.881] Lazy evaluation: FALSE
[17:43:54.881] Asynchronous evaluation: TRUE
[17:43:54.881] Local evaluation: TRUE
[17:43:54.881] Environment: R_GlobalEnv
[17:43:54.881] Capture standard output: TRUE
[17:43:54.881] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:54.881] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:54.881] Packages: 1 packages (‘stats’)
[17:43:54.881] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:54.881] Resolved: FALSE
[17:43:54.881] Value: <not collected>
[17:43:54.881] Conditions captured: <none>
[17:43:54.881] Early signaling: FALSE
[17:43:54.881] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:54.881] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.893] Chunk #1 of 2 ... DONE
[17:43:54.893] Chunk #2 of 2 ...
[17:43:54.893]  - Finding globals in 'X' for chunk #2 ...
[17:43:54.893] getGlobalsAndPackages() ...
[17:43:54.893] Searching for globals...
[17:43:54.894] 
[17:43:54.894] Searching for globals ... DONE
[17:43:54.894] - globals: [0] <none>
[17:43:54.894] getGlobalsAndPackages() ... DONE
[17:43:54.894]    + additional globals found: [n=0] 
[17:43:54.894]    + additional namespaces needed: [n=0] 
[17:43:54.894]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:54.894]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.894]  - seeds: <none>
[17:43:54.895]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.895] getGlobalsAndPackages() ...
[17:43:54.895] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.895] Resolving globals: FALSE
[17:43:54.895] Tweak future expression to call with '...' arguments ...
[17:43:54.895] {
[17:43:54.895]     do.call(function(...) {
[17:43:54.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.895]             on.exit(options(oopts), add = TRUE)
[17:43:54.895]         }
[17:43:54.895]         {
[17:43:54.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.895]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.895]             })
[17:43:54.895]         }
[17:43:54.895]     }, args = future.call.arguments)
[17:43:54.895] }
[17:43:54.895] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.896] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.896] 
[17:43:54.896] getGlobalsAndPackages() ... DONE
[17:43:54.896] run() for ‘Future’ ...
[17:43:54.896] - state: ‘created’
[17:43:54.896] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.910]   - Field: ‘node’
[17:43:54.910]   - Field: ‘label’
[17:43:54.911]   - Field: ‘local’
[17:43:54.911]   - Field: ‘owner’
[17:43:54.911]   - Field: ‘envir’
[17:43:54.911]   - Field: ‘workers’
[17:43:54.911]   - Field: ‘packages’
[17:43:54.911]   - Field: ‘gc’
[17:43:54.911]   - Field: ‘conditions’
[17:43:54.911]   - Field: ‘persistent’
[17:43:54.911]   - Field: ‘expr’
[17:43:54.911]   - Field: ‘uuid’
[17:43:54.911]   - Field: ‘seed’
[17:43:54.912]   - Field: ‘version’
[17:43:54.912]   - Field: ‘result’
[17:43:54.912]   - Field: ‘asynchronous’
[17:43:54.912]   - Field: ‘calls’
[17:43:54.912]   - Field: ‘globals’
[17:43:54.912]   - Field: ‘stdout’
[17:43:54.912]   - Field: ‘earlySignal’
[17:43:54.912]   - Field: ‘lazy’
[17:43:54.912]   - Field: ‘state’
[17:43:54.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.912] - Launch lazy future ...
[17:43:54.913] Packages needed by the future expression (n = 1): ‘stats’
[17:43:54.913] Packages needed by future strategies (n = 0): <none>
[17:43:54.913] {
[17:43:54.913]     {
[17:43:54.913]         {
[17:43:54.913]             ...future.startTime <- base::Sys.time()
[17:43:54.913]             {
[17:43:54.913]                 {
[17:43:54.913]                   {
[17:43:54.913]                     {
[17:43:54.913]                       {
[17:43:54.913]                         base::local({
[17:43:54.913]                           has_future <- base::requireNamespace("future", 
[17:43:54.913]                             quietly = TRUE)
[17:43:54.913]                           if (has_future) {
[17:43:54.913]                             ns <- base::getNamespace("future")
[17:43:54.913]                             version <- ns[[".package"]][["version"]]
[17:43:54.913]                             if (is.null(version)) 
[17:43:54.913]                               version <- utils::packageVersion("future")
[17:43:54.913]                           }
[17:43:54.913]                           else {
[17:43:54.913]                             version <- NULL
[17:43:54.913]                           }
[17:43:54.913]                           if (!has_future || version < "1.8.0") {
[17:43:54.913]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.913]                               "", base::R.version$version.string), 
[17:43:54.913]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:54.913]                                 base::R.version$platform, 8 * 
[17:43:54.913]                                   base::.Machine$sizeof.pointer), 
[17:43:54.913]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.913]                                 "release", "version")], collapse = " "), 
[17:43:54.913]                               hostname = base::Sys.info()[["nodename"]])
[17:43:54.913]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.913]                               info)
[17:43:54.913]                             info <- base::paste(info, collapse = "; ")
[17:43:54.913]                             if (!has_future) {
[17:43:54.913]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.913]                                 info)
[17:43:54.913]                             }
[17:43:54.913]                             else {
[17:43:54.913]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.913]                                 info, version)
[17:43:54.913]                             }
[17:43:54.913]                             base::stop(msg)
[17:43:54.913]                           }
[17:43:54.913]                         })
[17:43:54.913]                       }
[17:43:54.913]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.913]                       base::options(mc.cores = 1L)
[17:43:54.913]                     }
[17:43:54.913]                     base::local({
[17:43:54.913]                       for (pkg in "stats") {
[17:43:54.913]                         base::loadNamespace(pkg)
[17:43:54.913]                         base::library(pkg, character.only = TRUE)
[17:43:54.913]                       }
[17:43:54.913]                     })
[17:43:54.913]                   }
[17:43:54.913]                   ...future.strategy.old <- future::plan("list")
[17:43:54.913]                   options(future.plan = NULL)
[17:43:54.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.913]                 }
[17:43:54.913]                 ...future.workdir <- getwd()
[17:43:54.913]             }
[17:43:54.913]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.913]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.913]         }
[17:43:54.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.913]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:54.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.913]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.913]             base::names(...future.oldOptions))
[17:43:54.913]     }
[17:43:54.913]     if (FALSE) {
[17:43:54.913]     }
[17:43:54.913]     else {
[17:43:54.913]         if (TRUE) {
[17:43:54.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.913]                 open = "w")
[17:43:54.913]         }
[17:43:54.913]         else {
[17:43:54.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.913]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.913]         }
[17:43:54.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.913]             base::sink(type = "output", split = FALSE)
[17:43:54.913]             base::close(...future.stdout)
[17:43:54.913]         }, add = TRUE)
[17:43:54.913]     }
[17:43:54.913]     ...future.frame <- base::sys.nframe()
[17:43:54.913]     ...future.conditions <- base::list()
[17:43:54.913]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.913]     if (FALSE) {
[17:43:54.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.913]     }
[17:43:54.913]     ...future.result <- base::tryCatch({
[17:43:54.913]         base::withCallingHandlers({
[17:43:54.913]             ...future.value <- base::withVisible(base::local({
[17:43:54.913]                 ...future.makeSendCondition <- base::local({
[17:43:54.913]                   sendCondition <- NULL
[17:43:54.913]                   function(frame = 1L) {
[17:43:54.913]                     if (is.function(sendCondition)) 
[17:43:54.913]                       return(sendCondition)
[17:43:54.913]                     ns <- getNamespace("parallel")
[17:43:54.913]                     if (exists("sendData", mode = "function", 
[17:43:54.913]                       envir = ns)) {
[17:43:54.913]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.913]                         envir = ns)
[17:43:54.913]                       envir <- sys.frame(frame)
[17:43:54.913]                       master <- NULL
[17:43:54.913]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.913]                         !identical(envir, emptyenv())) {
[17:43:54.913]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.913]                           inherits = FALSE)) {
[17:43:54.913]                           master <- get("master", mode = "list", 
[17:43:54.913]                             envir = envir, inherits = FALSE)
[17:43:54.913]                           if (inherits(master, c("SOCKnode", 
[17:43:54.913]                             "SOCK0node"))) {
[17:43:54.913]                             sendCondition <<- function(cond) {
[17:43:54.913]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.913]                                 success = TRUE)
[17:43:54.913]                               parallel_sendData(master, data)
[17:43:54.913]                             }
[17:43:54.913]                             return(sendCondition)
[17:43:54.913]                           }
[17:43:54.913]                         }
[17:43:54.913]                         frame <- frame + 1L
[17:43:54.913]                         envir <- sys.frame(frame)
[17:43:54.913]                       }
[17:43:54.913]                     }
[17:43:54.913]                     sendCondition <<- function(cond) NULL
[17:43:54.913]                   }
[17:43:54.913]                 })
[17:43:54.913]                 withCallingHandlers({
[17:43:54.913]                   {
[17:43:54.913]                     do.call(function(...) {
[17:43:54.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.913]                       if (!identical(...future.globals.maxSize.org, 
[17:43:54.913]                         ...future.globals.maxSize)) {
[17:43:54.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.913]                         on.exit(options(oopts), add = TRUE)
[17:43:54.913]                       }
[17:43:54.913]                       {
[17:43:54.913]                         lapply(seq_along(...future.elements_ii), 
[17:43:54.913]                           FUN = function(jj) {
[17:43:54.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.913]                             ...future.FUN(...future.X_jj, ...)
[17:43:54.913]                           })
[17:43:54.913]                       }
[17:43:54.913]                     }, args = future.call.arguments)
[17:43:54.913]                   }
[17:43:54.913]                 }, immediateCondition = function(cond) {
[17:43:54.913]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.913]                   sendCondition(cond)
[17:43:54.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.913]                   {
[17:43:54.913]                     inherits <- base::inherits
[17:43:54.913]                     invokeRestart <- base::invokeRestart
[17:43:54.913]                     is.null <- base::is.null
[17:43:54.913]                     muffled <- FALSE
[17:43:54.913]                     if (inherits(cond, "message")) {
[17:43:54.913]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.913]                       if (muffled) 
[17:43:54.913]                         invokeRestart("muffleMessage")
[17:43:54.913]                     }
[17:43:54.913]                     else if (inherits(cond, "warning")) {
[17:43:54.913]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.913]                       if (muffled) 
[17:43:54.913]                         invokeRestart("muffleWarning")
[17:43:54.913]                     }
[17:43:54.913]                     else if (inherits(cond, "condition")) {
[17:43:54.913]                       if (!is.null(pattern)) {
[17:43:54.913]                         computeRestarts <- base::computeRestarts
[17:43:54.913]                         grepl <- base::grepl
[17:43:54.913]                         restarts <- computeRestarts(cond)
[17:43:54.913]                         for (restart in restarts) {
[17:43:54.913]                           name <- restart$name
[17:43:54.913]                           if (is.null(name)) 
[17:43:54.913]                             next
[17:43:54.913]                           if (!grepl(pattern, name)) 
[17:43:54.913]                             next
[17:43:54.913]                           invokeRestart(restart)
[17:43:54.913]                           muffled <- TRUE
[17:43:54.913]                           break
[17:43:54.913]                         }
[17:43:54.913]                       }
[17:43:54.913]                     }
[17:43:54.913]                     invisible(muffled)
[17:43:54.913]                   }
[17:43:54.913]                   muffleCondition(cond)
[17:43:54.913]                 })
[17:43:54.913]             }))
[17:43:54.913]             future::FutureResult(value = ...future.value$value, 
[17:43:54.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.913]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.913]                     ...future.globalenv.names))
[17:43:54.913]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.913]         }, condition = base::local({
[17:43:54.913]             c <- base::c
[17:43:54.913]             inherits <- base::inherits
[17:43:54.913]             invokeRestart <- base::invokeRestart
[17:43:54.913]             length <- base::length
[17:43:54.913]             list <- base::list
[17:43:54.913]             seq.int <- base::seq.int
[17:43:54.913]             signalCondition <- base::signalCondition
[17:43:54.913]             sys.calls <- base::sys.calls
[17:43:54.913]             `[[` <- base::`[[`
[17:43:54.913]             `+` <- base::`+`
[17:43:54.913]             `<<-` <- base::`<<-`
[17:43:54.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.913]                   3L)]
[17:43:54.913]             }
[17:43:54.913]             function(cond) {
[17:43:54.913]                 is_error <- inherits(cond, "error")
[17:43:54.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.913]                   NULL)
[17:43:54.913]                 if (is_error) {
[17:43:54.913]                   sessionInformation <- function() {
[17:43:54.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.913]                       search = base::search(), system = base::Sys.info())
[17:43:54.913]                   }
[17:43:54.913]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.913]                     cond$call), session = sessionInformation(), 
[17:43:54.913]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.913]                   signalCondition(cond)
[17:43:54.913]                 }
[17:43:54.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.913]                 "immediateCondition"))) {
[17:43:54.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.913]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.913]                   if (TRUE && !signal) {
[17:43:54.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.913]                     {
[17:43:54.913]                       inherits <- base::inherits
[17:43:54.913]                       invokeRestart <- base::invokeRestart
[17:43:54.913]                       is.null <- base::is.null
[17:43:54.913]                       muffled <- FALSE
[17:43:54.913]                       if (inherits(cond, "message")) {
[17:43:54.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.913]                         if (muffled) 
[17:43:54.913]                           invokeRestart("muffleMessage")
[17:43:54.913]                       }
[17:43:54.913]                       else if (inherits(cond, "warning")) {
[17:43:54.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.913]                         if (muffled) 
[17:43:54.913]                           invokeRestart("muffleWarning")
[17:43:54.913]                       }
[17:43:54.913]                       else if (inherits(cond, "condition")) {
[17:43:54.913]                         if (!is.null(pattern)) {
[17:43:54.913]                           computeRestarts <- base::computeRestarts
[17:43:54.913]                           grepl <- base::grepl
[17:43:54.913]                           restarts <- computeRestarts(cond)
[17:43:54.913]                           for (restart in restarts) {
[17:43:54.913]                             name <- restart$name
[17:43:54.913]                             if (is.null(name)) 
[17:43:54.913]                               next
[17:43:54.913]                             if (!grepl(pattern, name)) 
[17:43:54.913]                               next
[17:43:54.913]                             invokeRestart(restart)
[17:43:54.913]                             muffled <- TRUE
[17:43:54.913]                             break
[17:43:54.913]                           }
[17:43:54.913]                         }
[17:43:54.913]                       }
[17:43:54.913]                       invisible(muffled)
[17:43:54.913]                     }
[17:43:54.913]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.913]                   }
[17:43:54.913]                 }
[17:43:54.913]                 else {
[17:43:54.913]                   if (TRUE) {
[17:43:54.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.913]                     {
[17:43:54.913]                       inherits <- base::inherits
[17:43:54.913]                       invokeRestart <- base::invokeRestart
[17:43:54.913]                       is.null <- base::is.null
[17:43:54.913]                       muffled <- FALSE
[17:43:54.913]                       if (inherits(cond, "message")) {
[17:43:54.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.913]                         if (muffled) 
[17:43:54.913]                           invokeRestart("muffleMessage")
[17:43:54.913]                       }
[17:43:54.913]                       else if (inherits(cond, "warning")) {
[17:43:54.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.913]                         if (muffled) 
[17:43:54.913]                           invokeRestart("muffleWarning")
[17:43:54.913]                       }
[17:43:54.913]                       else if (inherits(cond, "condition")) {
[17:43:54.913]                         if (!is.null(pattern)) {
[17:43:54.913]                           computeRestarts <- base::computeRestarts
[17:43:54.913]                           grepl <- base::grepl
[17:43:54.913]                           restarts <- computeRestarts(cond)
[17:43:54.913]                           for (restart in restarts) {
[17:43:54.913]                             name <- restart$name
[17:43:54.913]                             if (is.null(name)) 
[17:43:54.913]                               next
[17:43:54.913]                             if (!grepl(pattern, name)) 
[17:43:54.913]                               next
[17:43:54.913]                             invokeRestart(restart)
[17:43:54.913]                             muffled <- TRUE
[17:43:54.913]                             break
[17:43:54.913]                           }
[17:43:54.913]                         }
[17:43:54.913]                       }
[17:43:54.913]                       invisible(muffled)
[17:43:54.913]                     }
[17:43:54.913]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.913]                   }
[17:43:54.913]                 }
[17:43:54.913]             }
[17:43:54.913]         }))
[17:43:54.913]     }, error = function(ex) {
[17:43:54.913]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.913]                 ...future.rng), started = ...future.startTime, 
[17:43:54.913]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.913]             version = "1.8"), class = "FutureResult")
[17:43:54.913]     }, finally = {
[17:43:54.913]         if (!identical(...future.workdir, getwd())) 
[17:43:54.913]             setwd(...future.workdir)
[17:43:54.913]         {
[17:43:54.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.913]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.913]             }
[17:43:54.913]             base::options(...future.oldOptions)
[17:43:54.913]             if (.Platform$OS.type == "windows") {
[17:43:54.913]                 old_names <- names(...future.oldEnvVars)
[17:43:54.913]                 envs <- base::Sys.getenv()
[17:43:54.913]                 names <- names(envs)
[17:43:54.913]                 common <- intersect(names, old_names)
[17:43:54.913]                 added <- setdiff(names, old_names)
[17:43:54.913]                 removed <- setdiff(old_names, names)
[17:43:54.913]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.913]                   envs[common]]
[17:43:54.913]                 NAMES <- toupper(changed)
[17:43:54.913]                 args <- list()
[17:43:54.913]                 for (kk in seq_along(NAMES)) {
[17:43:54.913]                   name <- changed[[kk]]
[17:43:54.913]                   NAME <- NAMES[[kk]]
[17:43:54.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.913]                     next
[17:43:54.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.913]                 }
[17:43:54.913]                 NAMES <- toupper(added)
[17:43:54.913]                 for (kk in seq_along(NAMES)) {
[17:43:54.913]                   name <- added[[kk]]
[17:43:54.913]                   NAME <- NAMES[[kk]]
[17:43:54.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.913]                     next
[17:43:54.913]                   args[[name]] <- ""
[17:43:54.913]                 }
[17:43:54.913]                 NAMES <- toupper(removed)
[17:43:54.913]                 for (kk in seq_along(NAMES)) {
[17:43:54.913]                   name <- removed[[kk]]
[17:43:54.913]                   NAME <- NAMES[[kk]]
[17:43:54.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.913]                     next
[17:43:54.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.913]                 }
[17:43:54.913]                 if (length(args) > 0) 
[17:43:54.913]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.913]             }
[17:43:54.913]             else {
[17:43:54.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.913]             }
[17:43:54.913]             {
[17:43:54.913]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.913]                   0L) {
[17:43:54.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.913]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.913]                   base::options(opts)
[17:43:54.913]                 }
[17:43:54.913]                 {
[17:43:54.913]                   {
[17:43:54.913]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.913]                     NULL
[17:43:54.913]                   }
[17:43:54.913]                   options(future.plan = NULL)
[17:43:54.913]                   if (is.na(NA_character_)) 
[17:43:54.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:54.913]                     .init = FALSE)
[17:43:54.913]                 }
[17:43:54.913]             }
[17:43:54.913]         }
[17:43:54.913]     })
[17:43:54.913]     if (TRUE) {
[17:43:54.913]         base::sink(type = "output", split = FALSE)
[17:43:54.913]         if (TRUE) {
[17:43:54.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.913]         }
[17:43:54.913]         else {
[17:43:54.913]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.913]         }
[17:43:54.913]         base::close(...future.stdout)
[17:43:54.913]         ...future.stdout <- NULL
[17:43:54.913]     }
[17:43:54.913]     ...future.result$conditions <- ...future.conditions
[17:43:54.913]     ...future.result$finished <- base::Sys.time()
[17:43:54.913]     ...future.result
[17:43:54.913] }
[17:43:54.916] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[17:43:54.916] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[17:43:54.916] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[17:43:54.917] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:43:54.917] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:43:54.917] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:43:54.918] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:43:54.918] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:54.918] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.918] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:54.919] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:54.919] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[17:43:54.919] MultisessionFuture started
[17:43:54.919] - Launch lazy future ... done
[17:43:54.920] run() for ‘MultisessionFuture’ ... done
[17:43:54.920] Created future:
[17:43:54.920] MultisessionFuture:
[17:43:54.920] Label: ‘future_by-2’
[17:43:54.920] Expression:
[17:43:54.920] {
[17:43:54.920]     do.call(function(...) {
[17:43:54.920]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.920]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.920]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.920]             on.exit(options(oopts), add = TRUE)
[17:43:54.920]         }
[17:43:54.920]         {
[17:43:54.920]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.920]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.920]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.920]             })
[17:43:54.920]         }
[17:43:54.920]     }, args = future.call.arguments)
[17:43:54.920] }
[17:43:54.920] Lazy evaluation: FALSE
[17:43:54.920] Asynchronous evaluation: TRUE
[17:43:54.920] Local evaluation: TRUE
[17:43:54.920] Environment: R_GlobalEnv
[17:43:54.920] Capture standard output: TRUE
[17:43:54.920] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:54.920] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:54.920] Packages: 1 packages (‘stats’)
[17:43:54.920] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:54.920] Resolved: FALSE
[17:43:54.920] Value: <not collected>
[17:43:54.920] Conditions captured: <none>
[17:43:54.920] Early signaling: FALSE
[17:43:54.920] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:54.920] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.931] Chunk #2 of 2 ... DONE
[17:43:54.932] Launching 2 futures (chunks) ... DONE
[17:43:54.932] Resolving 2 futures (chunks) ...
[17:43:54.932] resolve() on list ...
[17:43:54.932]  recursive: 0
[17:43:54.932]  length: 2
[17:43:54.932] 
[17:43:54.933] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.933] - Validating connection of MultisessionFuture
[17:43:54.933] - received message: FutureResult
[17:43:54.933] - Received FutureResult
[17:43:54.933] - Erased future from FutureRegistry
[17:43:54.933] result() for ClusterFuture ...
[17:43:54.933] - result already collected: FutureResult
[17:43:54.933] result() for ClusterFuture ... done
[17:43:54.933] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.934] Future #1
[17:43:54.934] result() for ClusterFuture ...
[17:43:54.934] - result already collected: FutureResult
[17:43:54.934] result() for ClusterFuture ... done
[17:43:54.934] result() for ClusterFuture ...
[17:43:54.934] - result already collected: FutureResult
[17:43:54.934] result() for ClusterFuture ... done
[17:43:54.934] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:54.934] - nx: 2
[17:43:54.934] - relay: TRUE
[17:43:54.934] - stdout: TRUE
[17:43:54.934] - signal: TRUE
[17:43:54.935] - resignal: FALSE
[17:43:54.935] - force: TRUE
[17:43:54.935] - relayed: [n=2] FALSE, FALSE
[17:43:54.935] - queued futures: [n=2] FALSE, FALSE
[17:43:54.935]  - until=1
[17:43:54.935]  - relaying element #1
[17:43:54.935] result() for ClusterFuture ...
[17:43:54.935] - result already collected: FutureResult
[17:43:54.935] result() for ClusterFuture ... done
[17:43:54.935] result() for ClusterFuture ...
[17:43:54.935] - result already collected: FutureResult
[17:43:54.936] result() for ClusterFuture ... done
[17:43:54.936] result() for ClusterFuture ...
[17:43:54.936] - result already collected: FutureResult
[17:43:54.936] result() for ClusterFuture ... done
[17:43:54.936] result() for ClusterFuture ...
[17:43:54.936] - result already collected: FutureResult
[17:43:54.936] result() for ClusterFuture ... done
[17:43:54.936] - relayed: [n=2] TRUE, FALSE
[17:43:54.936] - queued futures: [n=2] TRUE, FALSE
[17:43:54.936] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:54.936]  length: 1 (resolved future 1)
[17:43:54.965] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.965] - Validating connection of MultisessionFuture
[17:43:54.965] - received message: FutureResult
[17:43:54.965] - Received FutureResult
[17:43:54.965] - Erased future from FutureRegistry
[17:43:54.966] result() for ClusterFuture ...
[17:43:54.966] - result already collected: FutureResult
[17:43:54.966] result() for ClusterFuture ... done
[17:43:54.966] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.966] Future #2
[17:43:54.966] result() for ClusterFuture ...
[17:43:54.966] - result already collected: FutureResult
[17:43:54.966] result() for ClusterFuture ... done
[17:43:54.966] result() for ClusterFuture ...
[17:43:54.966] - result already collected: FutureResult
[17:43:54.966] result() for ClusterFuture ... done
[17:43:54.967] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:54.967] - nx: 2
[17:43:54.967] - relay: TRUE
[17:43:54.967] - stdout: TRUE
[17:43:54.967] - signal: TRUE
[17:43:54.967] - resignal: FALSE
[17:43:54.967] - force: TRUE
[17:43:54.967] - relayed: [n=2] TRUE, FALSE
[17:43:54.967] - queued futures: [n=2] TRUE, FALSE
[17:43:54.967]  - until=2
[17:43:54.967]  - relaying element #2
[17:43:54.968] result() for ClusterFuture ...
[17:43:54.968] - result already collected: FutureResult
[17:43:54.968] result() for ClusterFuture ... done
[17:43:54.968] result() for ClusterFuture ...
[17:43:54.968] - result already collected: FutureResult
[17:43:54.968] result() for ClusterFuture ... done
[17:43:54.968] result() for ClusterFuture ...
[17:43:54.968] - result already collected: FutureResult
[17:43:54.968] result() for ClusterFuture ... done
[17:43:54.968] result() for ClusterFuture ...
[17:43:54.968] - result already collected: FutureResult
[17:43:54.968] result() for ClusterFuture ... done
[17:43:54.969] - relayed: [n=2] TRUE, TRUE
[17:43:54.969] - queued futures: [n=2] TRUE, TRUE
[17:43:54.969] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:54.969]  length: 0 (resolved future 2)
[17:43:54.969] Relaying remaining futures
[17:43:54.969] signalConditionsASAP(NULL, pos=0) ...
[17:43:54.969] - nx: 2
[17:43:54.969] - relay: TRUE
[17:43:54.969] - stdout: TRUE
[17:43:54.969] - signal: TRUE
[17:43:54.969] - resignal: FALSE
[17:43:54.969] - force: TRUE
[17:43:54.970] - relayed: [n=2] TRUE, TRUE
[17:43:54.970] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:54.970] - relayed: [n=2] TRUE, TRUE
[17:43:54.970] - queued futures: [n=2] TRUE, TRUE
[17:43:54.970] signalConditionsASAP(NULL, pos=0) ... done
[17:43:54.970] resolve() on list ... DONE
[17:43:54.970] result() for ClusterFuture ...
[17:43:54.970] - result already collected: FutureResult
[17:43:54.970] result() for ClusterFuture ... done
[17:43:54.970] result() for ClusterFuture ...
[17:43:54.970] - result already collected: FutureResult
[17:43:54.971] result() for ClusterFuture ... done
[17:43:54.971] result() for ClusterFuture ...
[17:43:54.971] - result already collected: FutureResult
[17:43:54.971] result() for ClusterFuture ... done
[17:43:54.971] result() for ClusterFuture ...
[17:43:54.971] - result already collected: FutureResult
[17:43:54.971] result() for ClusterFuture ... done
[17:43:54.971]  - Number of value chunks collected: 2
[17:43:54.971] Resolving 2 futures (chunks) ... DONE
[17:43:54.971] Reducing values from 2 chunks ...
[17:43:54.971]  - Number of values collected after concatenation: 3
[17:43:54.972]  - Number of values expected: 3
[17:43:54.972] Reducing values from 2 chunks ... DONE
[17:43:54.972] future_lapply() ... DONE
[17:43:54.972] future_by_internal() ... DONE
[17:43:54.975] future_by_internal() ...
[17:43:54.976] future_lapply() ...
[17:43:54.980] Number of chunks: 2
[17:43:54.980] getGlobalsAndPackagesXApply() ...
[17:43:54.980]  - future.globals: TRUE
[17:43:54.980] getGlobalsAndPackages() ...
[17:43:54.980] Searching for globals...
[17:43:54.982] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:43:54.982] Searching for globals ... DONE
[17:43:54.982] Resolving globals: FALSE
[17:43:54.983] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:43:54.983] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:43:54.983] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:54.983] - packages: [1] ‘stats’
[17:43:54.983] getGlobalsAndPackages() ... DONE
[17:43:54.984]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:43:54.984]  - needed namespaces: [n=1] ‘stats’
[17:43:54.984] Finding globals ... DONE
[17:43:54.984]  - use_args: TRUE
[17:43:54.984]  - Getting '...' globals ...
[17:43:54.984] resolve() on list ...
[17:43:54.984]  recursive: 0
[17:43:54.984]  length: 1
[17:43:54.985]  elements: ‘...’
[17:43:54.985]  length: 0 (resolved future 1)
[17:43:54.985] resolve() on list ... DONE
[17:43:54.985]    - '...' content: [n=0] 
[17:43:54.985] List of 1
[17:43:54.985]  $ ...: list()
[17:43:54.985]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.985]  - attr(*, "where")=List of 1
[17:43:54.985]   ..$ ...:<environment: 0x55d6bc4df610> 
[17:43:54.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.985]  - attr(*, "resolved")= logi TRUE
[17:43:54.985]  - attr(*, "total_size")= num NA
[17:43:54.987]  - Getting '...' globals ... DONE
[17:43:54.988] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:43:54.988] List of 4
[17:43:54.988]  $ ...future.FUN:function (x)  
[17:43:54.988]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:43:54.988]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:43:54.988]  $ ...          : list()
[17:43:54.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:54.988]  - attr(*, "where")=List of 4
[17:43:54.988]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:54.988]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:43:54.988]   ..$ wool         :<environment: R_EmptyEnv> 
[17:43:54.988]   ..$ ...          :<environment: 0x55d6bc4df610> 
[17:43:54.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:54.988]  - attr(*, "resolved")= logi FALSE
[17:43:54.988]  - attr(*, "total_size")= num 2320
[17:43:54.991] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:54.991] getGlobalsAndPackagesXApply() ... DONE
[17:43:54.992] Number of futures (= number of chunks): 2
[17:43:54.992] Launching 2 futures (chunks) ...
[17:43:54.992] Chunk #1 of 2 ...
[17:43:54.992]  - Finding globals in 'X' for chunk #1 ...
[17:43:54.992] getGlobalsAndPackages() ...
[17:43:54.992] Searching for globals...
[17:43:54.992] 
[17:43:54.992] Searching for globals ... DONE
[17:43:54.993] - globals: [0] <none>
[17:43:54.993] getGlobalsAndPackages() ... DONE
[17:43:54.993]    + additional globals found: [n=0] 
[17:43:54.993]    + additional namespaces needed: [n=0] 
[17:43:54.993]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:54.993]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:54.993]  - seeds: <none>
[17:43:54.993]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.993] getGlobalsAndPackages() ...
[17:43:54.993] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.993] Resolving globals: FALSE
[17:43:54.994] Tweak future expression to call with '...' arguments ...
[17:43:54.994] {
[17:43:54.994]     do.call(function(...) {
[17:43:54.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:54.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:54.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:54.994]             on.exit(options(oopts), add = TRUE)
[17:43:54.994]         }
[17:43:54.994]         {
[17:43:54.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:54.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:54.994]                 ...future.FUN(...future.X_jj, ...)
[17:43:54.994]             })
[17:43:54.994]         }
[17:43:54.994]     }, args = future.call.arguments)
[17:43:54.994] }
[17:43:54.994] Tweak future expression to call with '...' arguments ... DONE
[17:43:54.994] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:54.994] 
[17:43:54.994] getGlobalsAndPackages() ... DONE
[17:43:54.995] run() for ‘Future’ ...
[17:43:54.995] - state: ‘created’
[17:43:54.995] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.008] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.009]   - Field: ‘node’
[17:43:55.009]   - Field: ‘label’
[17:43:55.009]   - Field: ‘local’
[17:43:55.009]   - Field: ‘owner’
[17:43:55.009]   - Field: ‘envir’
[17:43:55.009]   - Field: ‘workers’
[17:43:55.009]   - Field: ‘packages’
[17:43:55.009]   - Field: ‘gc’
[17:43:55.009]   - Field: ‘conditions’
[17:43:55.009]   - Field: ‘persistent’
[17:43:55.010]   - Field: ‘expr’
[17:43:55.010]   - Field: ‘uuid’
[17:43:55.010]   - Field: ‘seed’
[17:43:55.010]   - Field: ‘version’
[17:43:55.010]   - Field: ‘result’
[17:43:55.010]   - Field: ‘asynchronous’
[17:43:55.010]   - Field: ‘calls’
[17:43:55.010]   - Field: ‘globals’
[17:43:55.010]   - Field: ‘stdout’
[17:43:55.010]   - Field: ‘earlySignal’
[17:43:55.010]   - Field: ‘lazy’
[17:43:55.011]   - Field: ‘state’
[17:43:55.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.011] - Launch lazy future ...
[17:43:55.011] Packages needed by the future expression (n = 1): ‘stats’
[17:43:55.011] Packages needed by future strategies (n = 0): <none>
[17:43:55.012] {
[17:43:55.012]     {
[17:43:55.012]         {
[17:43:55.012]             ...future.startTime <- base::Sys.time()
[17:43:55.012]             {
[17:43:55.012]                 {
[17:43:55.012]                   {
[17:43:55.012]                     {
[17:43:55.012]                       {
[17:43:55.012]                         base::local({
[17:43:55.012]                           has_future <- base::requireNamespace("future", 
[17:43:55.012]                             quietly = TRUE)
[17:43:55.012]                           if (has_future) {
[17:43:55.012]                             ns <- base::getNamespace("future")
[17:43:55.012]                             version <- ns[[".package"]][["version"]]
[17:43:55.012]                             if (is.null(version)) 
[17:43:55.012]                               version <- utils::packageVersion("future")
[17:43:55.012]                           }
[17:43:55.012]                           else {
[17:43:55.012]                             version <- NULL
[17:43:55.012]                           }
[17:43:55.012]                           if (!has_future || version < "1.8.0") {
[17:43:55.012]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.012]                               "", base::R.version$version.string), 
[17:43:55.012]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:55.012]                                 base::R.version$platform, 8 * 
[17:43:55.012]                                   base::.Machine$sizeof.pointer), 
[17:43:55.012]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.012]                                 "release", "version")], collapse = " "), 
[17:43:55.012]                               hostname = base::Sys.info()[["nodename"]])
[17:43:55.012]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.012]                               info)
[17:43:55.012]                             info <- base::paste(info, collapse = "; ")
[17:43:55.012]                             if (!has_future) {
[17:43:55.012]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.012]                                 info)
[17:43:55.012]                             }
[17:43:55.012]                             else {
[17:43:55.012]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.012]                                 info, version)
[17:43:55.012]                             }
[17:43:55.012]                             base::stop(msg)
[17:43:55.012]                           }
[17:43:55.012]                         })
[17:43:55.012]                       }
[17:43:55.012]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.012]                       base::options(mc.cores = 1L)
[17:43:55.012]                     }
[17:43:55.012]                     base::local({
[17:43:55.012]                       for (pkg in "stats") {
[17:43:55.012]                         base::loadNamespace(pkg)
[17:43:55.012]                         base::library(pkg, character.only = TRUE)
[17:43:55.012]                       }
[17:43:55.012]                     })
[17:43:55.012]                   }
[17:43:55.012]                   ...future.strategy.old <- future::plan("list")
[17:43:55.012]                   options(future.plan = NULL)
[17:43:55.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.012]                 }
[17:43:55.012]                 ...future.workdir <- getwd()
[17:43:55.012]             }
[17:43:55.012]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.012]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.012]         }
[17:43:55.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.012]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.012]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.012]             base::names(...future.oldOptions))
[17:43:55.012]     }
[17:43:55.012]     if (FALSE) {
[17:43:55.012]     }
[17:43:55.012]     else {
[17:43:55.012]         if (TRUE) {
[17:43:55.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.012]                 open = "w")
[17:43:55.012]         }
[17:43:55.012]         else {
[17:43:55.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.012]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.012]         }
[17:43:55.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.012]             base::sink(type = "output", split = FALSE)
[17:43:55.012]             base::close(...future.stdout)
[17:43:55.012]         }, add = TRUE)
[17:43:55.012]     }
[17:43:55.012]     ...future.frame <- base::sys.nframe()
[17:43:55.012]     ...future.conditions <- base::list()
[17:43:55.012]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.012]     if (FALSE) {
[17:43:55.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.012]     }
[17:43:55.012]     ...future.result <- base::tryCatch({
[17:43:55.012]         base::withCallingHandlers({
[17:43:55.012]             ...future.value <- base::withVisible(base::local({
[17:43:55.012]                 ...future.makeSendCondition <- base::local({
[17:43:55.012]                   sendCondition <- NULL
[17:43:55.012]                   function(frame = 1L) {
[17:43:55.012]                     if (is.function(sendCondition)) 
[17:43:55.012]                       return(sendCondition)
[17:43:55.012]                     ns <- getNamespace("parallel")
[17:43:55.012]                     if (exists("sendData", mode = "function", 
[17:43:55.012]                       envir = ns)) {
[17:43:55.012]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.012]                         envir = ns)
[17:43:55.012]                       envir <- sys.frame(frame)
[17:43:55.012]                       master <- NULL
[17:43:55.012]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.012]                         !identical(envir, emptyenv())) {
[17:43:55.012]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.012]                           inherits = FALSE)) {
[17:43:55.012]                           master <- get("master", mode = "list", 
[17:43:55.012]                             envir = envir, inherits = FALSE)
[17:43:55.012]                           if (inherits(master, c("SOCKnode", 
[17:43:55.012]                             "SOCK0node"))) {
[17:43:55.012]                             sendCondition <<- function(cond) {
[17:43:55.012]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.012]                                 success = TRUE)
[17:43:55.012]                               parallel_sendData(master, data)
[17:43:55.012]                             }
[17:43:55.012]                             return(sendCondition)
[17:43:55.012]                           }
[17:43:55.012]                         }
[17:43:55.012]                         frame <- frame + 1L
[17:43:55.012]                         envir <- sys.frame(frame)
[17:43:55.012]                       }
[17:43:55.012]                     }
[17:43:55.012]                     sendCondition <<- function(cond) NULL
[17:43:55.012]                   }
[17:43:55.012]                 })
[17:43:55.012]                 withCallingHandlers({
[17:43:55.012]                   {
[17:43:55.012]                     do.call(function(...) {
[17:43:55.012]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.012]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.012]                         ...future.globals.maxSize)) {
[17:43:55.012]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.012]                         on.exit(options(oopts), add = TRUE)
[17:43:55.012]                       }
[17:43:55.012]                       {
[17:43:55.012]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.012]                           FUN = function(jj) {
[17:43:55.012]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.012]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.012]                           })
[17:43:55.012]                       }
[17:43:55.012]                     }, args = future.call.arguments)
[17:43:55.012]                   }
[17:43:55.012]                 }, immediateCondition = function(cond) {
[17:43:55.012]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.012]                   sendCondition(cond)
[17:43:55.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.012]                   {
[17:43:55.012]                     inherits <- base::inherits
[17:43:55.012]                     invokeRestart <- base::invokeRestart
[17:43:55.012]                     is.null <- base::is.null
[17:43:55.012]                     muffled <- FALSE
[17:43:55.012]                     if (inherits(cond, "message")) {
[17:43:55.012]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.012]                       if (muffled) 
[17:43:55.012]                         invokeRestart("muffleMessage")
[17:43:55.012]                     }
[17:43:55.012]                     else if (inherits(cond, "warning")) {
[17:43:55.012]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.012]                       if (muffled) 
[17:43:55.012]                         invokeRestart("muffleWarning")
[17:43:55.012]                     }
[17:43:55.012]                     else if (inherits(cond, "condition")) {
[17:43:55.012]                       if (!is.null(pattern)) {
[17:43:55.012]                         computeRestarts <- base::computeRestarts
[17:43:55.012]                         grepl <- base::grepl
[17:43:55.012]                         restarts <- computeRestarts(cond)
[17:43:55.012]                         for (restart in restarts) {
[17:43:55.012]                           name <- restart$name
[17:43:55.012]                           if (is.null(name)) 
[17:43:55.012]                             next
[17:43:55.012]                           if (!grepl(pattern, name)) 
[17:43:55.012]                             next
[17:43:55.012]                           invokeRestart(restart)
[17:43:55.012]                           muffled <- TRUE
[17:43:55.012]                           break
[17:43:55.012]                         }
[17:43:55.012]                       }
[17:43:55.012]                     }
[17:43:55.012]                     invisible(muffled)
[17:43:55.012]                   }
[17:43:55.012]                   muffleCondition(cond)
[17:43:55.012]                 })
[17:43:55.012]             }))
[17:43:55.012]             future::FutureResult(value = ...future.value$value, 
[17:43:55.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.012]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.012]                     ...future.globalenv.names))
[17:43:55.012]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.012]         }, condition = base::local({
[17:43:55.012]             c <- base::c
[17:43:55.012]             inherits <- base::inherits
[17:43:55.012]             invokeRestart <- base::invokeRestart
[17:43:55.012]             length <- base::length
[17:43:55.012]             list <- base::list
[17:43:55.012]             seq.int <- base::seq.int
[17:43:55.012]             signalCondition <- base::signalCondition
[17:43:55.012]             sys.calls <- base::sys.calls
[17:43:55.012]             `[[` <- base::`[[`
[17:43:55.012]             `+` <- base::`+`
[17:43:55.012]             `<<-` <- base::`<<-`
[17:43:55.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.012]                   3L)]
[17:43:55.012]             }
[17:43:55.012]             function(cond) {
[17:43:55.012]                 is_error <- inherits(cond, "error")
[17:43:55.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.012]                   NULL)
[17:43:55.012]                 if (is_error) {
[17:43:55.012]                   sessionInformation <- function() {
[17:43:55.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.012]                       search = base::search(), system = base::Sys.info())
[17:43:55.012]                   }
[17:43:55.012]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.012]                     cond$call), session = sessionInformation(), 
[17:43:55.012]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.012]                   signalCondition(cond)
[17:43:55.012]                 }
[17:43:55.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.012]                 "immediateCondition"))) {
[17:43:55.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.012]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.012]                   if (TRUE && !signal) {
[17:43:55.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.012]                     {
[17:43:55.012]                       inherits <- base::inherits
[17:43:55.012]                       invokeRestart <- base::invokeRestart
[17:43:55.012]                       is.null <- base::is.null
[17:43:55.012]                       muffled <- FALSE
[17:43:55.012]                       if (inherits(cond, "message")) {
[17:43:55.012]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.012]                         if (muffled) 
[17:43:55.012]                           invokeRestart("muffleMessage")
[17:43:55.012]                       }
[17:43:55.012]                       else if (inherits(cond, "warning")) {
[17:43:55.012]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.012]                         if (muffled) 
[17:43:55.012]                           invokeRestart("muffleWarning")
[17:43:55.012]                       }
[17:43:55.012]                       else if (inherits(cond, "condition")) {
[17:43:55.012]                         if (!is.null(pattern)) {
[17:43:55.012]                           computeRestarts <- base::computeRestarts
[17:43:55.012]                           grepl <- base::grepl
[17:43:55.012]                           restarts <- computeRestarts(cond)
[17:43:55.012]                           for (restart in restarts) {
[17:43:55.012]                             name <- restart$name
[17:43:55.012]                             if (is.null(name)) 
[17:43:55.012]                               next
[17:43:55.012]                             if (!grepl(pattern, name)) 
[17:43:55.012]                               next
[17:43:55.012]                             invokeRestart(restart)
[17:43:55.012]                             muffled <- TRUE
[17:43:55.012]                             break
[17:43:55.012]                           }
[17:43:55.012]                         }
[17:43:55.012]                       }
[17:43:55.012]                       invisible(muffled)
[17:43:55.012]                     }
[17:43:55.012]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.012]                   }
[17:43:55.012]                 }
[17:43:55.012]                 else {
[17:43:55.012]                   if (TRUE) {
[17:43:55.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.012]                     {
[17:43:55.012]                       inherits <- base::inherits
[17:43:55.012]                       invokeRestart <- base::invokeRestart
[17:43:55.012]                       is.null <- base::is.null
[17:43:55.012]                       muffled <- FALSE
[17:43:55.012]                       if (inherits(cond, "message")) {
[17:43:55.012]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.012]                         if (muffled) 
[17:43:55.012]                           invokeRestart("muffleMessage")
[17:43:55.012]                       }
[17:43:55.012]                       else if (inherits(cond, "warning")) {
[17:43:55.012]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.012]                         if (muffled) 
[17:43:55.012]                           invokeRestart("muffleWarning")
[17:43:55.012]                       }
[17:43:55.012]                       else if (inherits(cond, "condition")) {
[17:43:55.012]                         if (!is.null(pattern)) {
[17:43:55.012]                           computeRestarts <- base::computeRestarts
[17:43:55.012]                           grepl <- base::grepl
[17:43:55.012]                           restarts <- computeRestarts(cond)
[17:43:55.012]                           for (restart in restarts) {
[17:43:55.012]                             name <- restart$name
[17:43:55.012]                             if (is.null(name)) 
[17:43:55.012]                               next
[17:43:55.012]                             if (!grepl(pattern, name)) 
[17:43:55.012]                               next
[17:43:55.012]                             invokeRestart(restart)
[17:43:55.012]                             muffled <- TRUE
[17:43:55.012]                             break
[17:43:55.012]                           }
[17:43:55.012]                         }
[17:43:55.012]                       }
[17:43:55.012]                       invisible(muffled)
[17:43:55.012]                     }
[17:43:55.012]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.012]                   }
[17:43:55.012]                 }
[17:43:55.012]             }
[17:43:55.012]         }))
[17:43:55.012]     }, error = function(ex) {
[17:43:55.012]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.012]                 ...future.rng), started = ...future.startTime, 
[17:43:55.012]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.012]             version = "1.8"), class = "FutureResult")
[17:43:55.012]     }, finally = {
[17:43:55.012]         if (!identical(...future.workdir, getwd())) 
[17:43:55.012]             setwd(...future.workdir)
[17:43:55.012]         {
[17:43:55.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.012]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.012]             }
[17:43:55.012]             base::options(...future.oldOptions)
[17:43:55.012]             if (.Platform$OS.type == "windows") {
[17:43:55.012]                 old_names <- names(...future.oldEnvVars)
[17:43:55.012]                 envs <- base::Sys.getenv()
[17:43:55.012]                 names <- names(envs)
[17:43:55.012]                 common <- intersect(names, old_names)
[17:43:55.012]                 added <- setdiff(names, old_names)
[17:43:55.012]                 removed <- setdiff(old_names, names)
[17:43:55.012]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.012]                   envs[common]]
[17:43:55.012]                 NAMES <- toupper(changed)
[17:43:55.012]                 args <- list()
[17:43:55.012]                 for (kk in seq_along(NAMES)) {
[17:43:55.012]                   name <- changed[[kk]]
[17:43:55.012]                   NAME <- NAMES[[kk]]
[17:43:55.012]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.012]                     next
[17:43:55.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.012]                 }
[17:43:55.012]                 NAMES <- toupper(added)
[17:43:55.012]                 for (kk in seq_along(NAMES)) {
[17:43:55.012]                   name <- added[[kk]]
[17:43:55.012]                   NAME <- NAMES[[kk]]
[17:43:55.012]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.012]                     next
[17:43:55.012]                   args[[name]] <- ""
[17:43:55.012]                 }
[17:43:55.012]                 NAMES <- toupper(removed)
[17:43:55.012]                 for (kk in seq_along(NAMES)) {
[17:43:55.012]                   name <- removed[[kk]]
[17:43:55.012]                   NAME <- NAMES[[kk]]
[17:43:55.012]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.012]                     next
[17:43:55.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.012]                 }
[17:43:55.012]                 if (length(args) > 0) 
[17:43:55.012]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.012]             }
[17:43:55.012]             else {
[17:43:55.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.012]             }
[17:43:55.012]             {
[17:43:55.012]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.012]                   0L) {
[17:43:55.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.012]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.012]                   base::options(opts)
[17:43:55.012]                 }
[17:43:55.012]                 {
[17:43:55.012]                   {
[17:43:55.012]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.012]                     NULL
[17:43:55.012]                   }
[17:43:55.012]                   options(future.plan = NULL)
[17:43:55.012]                   if (is.na(NA_character_)) 
[17:43:55.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.012]                     .init = FALSE)
[17:43:55.012]                 }
[17:43:55.012]             }
[17:43:55.012]         }
[17:43:55.012]     })
[17:43:55.012]     if (TRUE) {
[17:43:55.012]         base::sink(type = "output", split = FALSE)
[17:43:55.012]         if (TRUE) {
[17:43:55.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.012]         }
[17:43:55.012]         else {
[17:43:55.012]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.012]         }
[17:43:55.012]         base::close(...future.stdout)
[17:43:55.012]         ...future.stdout <- NULL
[17:43:55.012]     }
[17:43:55.012]     ...future.result$conditions <- ...future.conditions
[17:43:55.012]     ...future.result$finished <- base::Sys.time()
[17:43:55.012]     ...future.result
[17:43:55.012] }
[17:43:55.014] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[17:43:55.014] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[17:43:55.015] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[17:43:55.015] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[17:43:55.015] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[17:43:55.015] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[17:43:55.016] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[17:43:55.016] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:55.016] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.016] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:43:55.017] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:43:55.017] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:55.017] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.017] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:55.017] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.018] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[17:43:55.018] MultisessionFuture started
[17:43:55.018] - Launch lazy future ... done
[17:43:55.018] run() for ‘MultisessionFuture’ ... done
[17:43:55.018] Created future:
[17:43:55.018] MultisessionFuture:
[17:43:55.018] Label: ‘future_by-1’
[17:43:55.018] Expression:
[17:43:55.018] {
[17:43:55.018]     do.call(function(...) {
[17:43:55.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.018]             on.exit(options(oopts), add = TRUE)
[17:43:55.018]         }
[17:43:55.018]         {
[17:43:55.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.018]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.018]             })
[17:43:55.018]         }
[17:43:55.018]     }, args = future.call.arguments)
[17:43:55.018] }
[17:43:55.018] Lazy evaluation: FALSE
[17:43:55.018] Asynchronous evaluation: TRUE
[17:43:55.018] Local evaluation: TRUE
[17:43:55.018] Environment: 0x55d6bc4b5d58
[17:43:55.018] Capture standard output: TRUE
[17:43:55.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.018] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:43:55.018] Packages: 1 packages (‘stats’)
[17:43:55.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.018] Resolved: FALSE
[17:43:55.018] Value: <not collected>
[17:43:55.018] Conditions captured: <none>
[17:43:55.018] Early signaling: FALSE
[17:43:55.018] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:55.018] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.030] Chunk #1 of 2 ... DONE
[17:43:55.030] Chunk #2 of 2 ...
[17:43:55.030]  - Finding globals in 'X' for chunk #2 ...
[17:43:55.030] getGlobalsAndPackages() ...
[17:43:55.031] Searching for globals...
[17:43:55.031] 
[17:43:55.031] Searching for globals ... DONE
[17:43:55.031] - globals: [0] <none>
[17:43:55.031] getGlobalsAndPackages() ... DONE
[17:43:55.031]    + additional globals found: [n=0] 
[17:43:55.032]    + additional namespaces needed: [n=0] 
[17:43:55.032]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:55.032]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.032]  - seeds: <none>
[17:43:55.032]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.032] getGlobalsAndPackages() ...
[17:43:55.032] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.032] Resolving globals: FALSE
[17:43:55.032] Tweak future expression to call with '...' arguments ...
[17:43:55.032] {
[17:43:55.032]     do.call(function(...) {
[17:43:55.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.032]             on.exit(options(oopts), add = TRUE)
[17:43:55.032]         }
[17:43:55.032]         {
[17:43:55.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.032]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.032]             })
[17:43:55.032]         }
[17:43:55.032]     }, args = future.call.arguments)
[17:43:55.032] }
[17:43:55.033] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.033] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.033] 
[17:43:55.033] getGlobalsAndPackages() ... DONE
[17:43:55.034] run() for ‘Future’ ...
[17:43:55.034] - state: ‘created’
[17:43:55.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.048] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.048]   - Field: ‘node’
[17:43:55.048]   - Field: ‘label’
[17:43:55.048]   - Field: ‘local’
[17:43:55.048]   - Field: ‘owner’
[17:43:55.048]   - Field: ‘envir’
[17:43:55.048]   - Field: ‘workers’
[17:43:55.049]   - Field: ‘packages’
[17:43:55.049]   - Field: ‘gc’
[17:43:55.049]   - Field: ‘conditions’
[17:43:55.049]   - Field: ‘persistent’
[17:43:55.049]   - Field: ‘expr’
[17:43:55.049]   - Field: ‘uuid’
[17:43:55.049]   - Field: ‘seed’
[17:43:55.049]   - Field: ‘version’
[17:43:55.049]   - Field: ‘result’
[17:43:55.049]   - Field: ‘asynchronous’
[17:43:55.049]   - Field: ‘calls’
[17:43:55.050]   - Field: ‘globals’
[17:43:55.050]   - Field: ‘stdout’
[17:43:55.052]   - Field: ‘earlySignal’
[17:43:55.052]   - Field: ‘lazy’
[17:43:55.052]   - Field: ‘state’
[17:43:55.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.052] - Launch lazy future ...
[17:43:55.052] Packages needed by the future expression (n = 1): ‘stats’
[17:43:55.053] Packages needed by future strategies (n = 0): <none>
[17:43:55.053] {
[17:43:55.053]     {
[17:43:55.053]         {
[17:43:55.053]             ...future.startTime <- base::Sys.time()
[17:43:55.053]             {
[17:43:55.053]                 {
[17:43:55.053]                   {
[17:43:55.053]                     {
[17:43:55.053]                       {
[17:43:55.053]                         base::local({
[17:43:55.053]                           has_future <- base::requireNamespace("future", 
[17:43:55.053]                             quietly = TRUE)
[17:43:55.053]                           if (has_future) {
[17:43:55.053]                             ns <- base::getNamespace("future")
[17:43:55.053]                             version <- ns[[".package"]][["version"]]
[17:43:55.053]                             if (is.null(version)) 
[17:43:55.053]                               version <- utils::packageVersion("future")
[17:43:55.053]                           }
[17:43:55.053]                           else {
[17:43:55.053]                             version <- NULL
[17:43:55.053]                           }
[17:43:55.053]                           if (!has_future || version < "1.8.0") {
[17:43:55.053]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.053]                               "", base::R.version$version.string), 
[17:43:55.053]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:55.053]                                 base::R.version$platform, 8 * 
[17:43:55.053]                                   base::.Machine$sizeof.pointer), 
[17:43:55.053]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.053]                                 "release", "version")], collapse = " "), 
[17:43:55.053]                               hostname = base::Sys.info()[["nodename"]])
[17:43:55.053]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.053]                               info)
[17:43:55.053]                             info <- base::paste(info, collapse = "; ")
[17:43:55.053]                             if (!has_future) {
[17:43:55.053]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.053]                                 info)
[17:43:55.053]                             }
[17:43:55.053]                             else {
[17:43:55.053]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.053]                                 info, version)
[17:43:55.053]                             }
[17:43:55.053]                             base::stop(msg)
[17:43:55.053]                           }
[17:43:55.053]                         })
[17:43:55.053]                       }
[17:43:55.053]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.053]                       base::options(mc.cores = 1L)
[17:43:55.053]                     }
[17:43:55.053]                     base::local({
[17:43:55.053]                       for (pkg in "stats") {
[17:43:55.053]                         base::loadNamespace(pkg)
[17:43:55.053]                         base::library(pkg, character.only = TRUE)
[17:43:55.053]                       }
[17:43:55.053]                     })
[17:43:55.053]                   }
[17:43:55.053]                   ...future.strategy.old <- future::plan("list")
[17:43:55.053]                   options(future.plan = NULL)
[17:43:55.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.053]                 }
[17:43:55.053]                 ...future.workdir <- getwd()
[17:43:55.053]             }
[17:43:55.053]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.053]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.053]         }
[17:43:55.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.053]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.053]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.053]             base::names(...future.oldOptions))
[17:43:55.053]     }
[17:43:55.053]     if (FALSE) {
[17:43:55.053]     }
[17:43:55.053]     else {
[17:43:55.053]         if (TRUE) {
[17:43:55.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.053]                 open = "w")
[17:43:55.053]         }
[17:43:55.053]         else {
[17:43:55.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.053]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.053]         }
[17:43:55.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.053]             base::sink(type = "output", split = FALSE)
[17:43:55.053]             base::close(...future.stdout)
[17:43:55.053]         }, add = TRUE)
[17:43:55.053]     }
[17:43:55.053]     ...future.frame <- base::sys.nframe()
[17:43:55.053]     ...future.conditions <- base::list()
[17:43:55.053]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.053]     if (FALSE) {
[17:43:55.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.053]     }
[17:43:55.053]     ...future.result <- base::tryCatch({
[17:43:55.053]         base::withCallingHandlers({
[17:43:55.053]             ...future.value <- base::withVisible(base::local({
[17:43:55.053]                 ...future.makeSendCondition <- base::local({
[17:43:55.053]                   sendCondition <- NULL
[17:43:55.053]                   function(frame = 1L) {
[17:43:55.053]                     if (is.function(sendCondition)) 
[17:43:55.053]                       return(sendCondition)
[17:43:55.053]                     ns <- getNamespace("parallel")
[17:43:55.053]                     if (exists("sendData", mode = "function", 
[17:43:55.053]                       envir = ns)) {
[17:43:55.053]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.053]                         envir = ns)
[17:43:55.053]                       envir <- sys.frame(frame)
[17:43:55.053]                       master <- NULL
[17:43:55.053]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.053]                         !identical(envir, emptyenv())) {
[17:43:55.053]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.053]                           inherits = FALSE)) {
[17:43:55.053]                           master <- get("master", mode = "list", 
[17:43:55.053]                             envir = envir, inherits = FALSE)
[17:43:55.053]                           if (inherits(master, c("SOCKnode", 
[17:43:55.053]                             "SOCK0node"))) {
[17:43:55.053]                             sendCondition <<- function(cond) {
[17:43:55.053]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.053]                                 success = TRUE)
[17:43:55.053]                               parallel_sendData(master, data)
[17:43:55.053]                             }
[17:43:55.053]                             return(sendCondition)
[17:43:55.053]                           }
[17:43:55.053]                         }
[17:43:55.053]                         frame <- frame + 1L
[17:43:55.053]                         envir <- sys.frame(frame)
[17:43:55.053]                       }
[17:43:55.053]                     }
[17:43:55.053]                     sendCondition <<- function(cond) NULL
[17:43:55.053]                   }
[17:43:55.053]                 })
[17:43:55.053]                 withCallingHandlers({
[17:43:55.053]                   {
[17:43:55.053]                     do.call(function(...) {
[17:43:55.053]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.053]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.053]                         ...future.globals.maxSize)) {
[17:43:55.053]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.053]                         on.exit(options(oopts), add = TRUE)
[17:43:55.053]                       }
[17:43:55.053]                       {
[17:43:55.053]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.053]                           FUN = function(jj) {
[17:43:55.053]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.053]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.053]                           })
[17:43:55.053]                       }
[17:43:55.053]                     }, args = future.call.arguments)
[17:43:55.053]                   }
[17:43:55.053]                 }, immediateCondition = function(cond) {
[17:43:55.053]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.053]                   sendCondition(cond)
[17:43:55.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.053]                   {
[17:43:55.053]                     inherits <- base::inherits
[17:43:55.053]                     invokeRestart <- base::invokeRestart
[17:43:55.053]                     is.null <- base::is.null
[17:43:55.053]                     muffled <- FALSE
[17:43:55.053]                     if (inherits(cond, "message")) {
[17:43:55.053]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.053]                       if (muffled) 
[17:43:55.053]                         invokeRestart("muffleMessage")
[17:43:55.053]                     }
[17:43:55.053]                     else if (inherits(cond, "warning")) {
[17:43:55.053]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.053]                       if (muffled) 
[17:43:55.053]                         invokeRestart("muffleWarning")
[17:43:55.053]                     }
[17:43:55.053]                     else if (inherits(cond, "condition")) {
[17:43:55.053]                       if (!is.null(pattern)) {
[17:43:55.053]                         computeRestarts <- base::computeRestarts
[17:43:55.053]                         grepl <- base::grepl
[17:43:55.053]                         restarts <- computeRestarts(cond)
[17:43:55.053]                         for (restart in restarts) {
[17:43:55.053]                           name <- restart$name
[17:43:55.053]                           if (is.null(name)) 
[17:43:55.053]                             next
[17:43:55.053]                           if (!grepl(pattern, name)) 
[17:43:55.053]                             next
[17:43:55.053]                           invokeRestart(restart)
[17:43:55.053]                           muffled <- TRUE
[17:43:55.053]                           break
[17:43:55.053]                         }
[17:43:55.053]                       }
[17:43:55.053]                     }
[17:43:55.053]                     invisible(muffled)
[17:43:55.053]                   }
[17:43:55.053]                   muffleCondition(cond)
[17:43:55.053]                 })
[17:43:55.053]             }))
[17:43:55.053]             future::FutureResult(value = ...future.value$value, 
[17:43:55.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.053]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.053]                     ...future.globalenv.names))
[17:43:55.053]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.053]         }, condition = base::local({
[17:43:55.053]             c <- base::c
[17:43:55.053]             inherits <- base::inherits
[17:43:55.053]             invokeRestart <- base::invokeRestart
[17:43:55.053]             length <- base::length
[17:43:55.053]             list <- base::list
[17:43:55.053]             seq.int <- base::seq.int
[17:43:55.053]             signalCondition <- base::signalCondition
[17:43:55.053]             sys.calls <- base::sys.calls
[17:43:55.053]             `[[` <- base::`[[`
[17:43:55.053]             `+` <- base::`+`
[17:43:55.053]             `<<-` <- base::`<<-`
[17:43:55.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.053]                   3L)]
[17:43:55.053]             }
[17:43:55.053]             function(cond) {
[17:43:55.053]                 is_error <- inherits(cond, "error")
[17:43:55.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.053]                   NULL)
[17:43:55.053]                 if (is_error) {
[17:43:55.053]                   sessionInformation <- function() {
[17:43:55.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.053]                       search = base::search(), system = base::Sys.info())
[17:43:55.053]                   }
[17:43:55.053]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.053]                     cond$call), session = sessionInformation(), 
[17:43:55.053]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.053]                   signalCondition(cond)
[17:43:55.053]                 }
[17:43:55.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.053]                 "immediateCondition"))) {
[17:43:55.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.053]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.053]                   if (TRUE && !signal) {
[17:43:55.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.053]                     {
[17:43:55.053]                       inherits <- base::inherits
[17:43:55.053]                       invokeRestart <- base::invokeRestart
[17:43:55.053]                       is.null <- base::is.null
[17:43:55.053]                       muffled <- FALSE
[17:43:55.053]                       if (inherits(cond, "message")) {
[17:43:55.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.053]                         if (muffled) 
[17:43:55.053]                           invokeRestart("muffleMessage")
[17:43:55.053]                       }
[17:43:55.053]                       else if (inherits(cond, "warning")) {
[17:43:55.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.053]                         if (muffled) 
[17:43:55.053]                           invokeRestart("muffleWarning")
[17:43:55.053]                       }
[17:43:55.053]                       else if (inherits(cond, "condition")) {
[17:43:55.053]                         if (!is.null(pattern)) {
[17:43:55.053]                           computeRestarts <- base::computeRestarts
[17:43:55.053]                           grepl <- base::grepl
[17:43:55.053]                           restarts <- computeRestarts(cond)
[17:43:55.053]                           for (restart in restarts) {
[17:43:55.053]                             name <- restart$name
[17:43:55.053]                             if (is.null(name)) 
[17:43:55.053]                               next
[17:43:55.053]                             if (!grepl(pattern, name)) 
[17:43:55.053]                               next
[17:43:55.053]                             invokeRestart(restart)
[17:43:55.053]                             muffled <- TRUE
[17:43:55.053]                             break
[17:43:55.053]                           }
[17:43:55.053]                         }
[17:43:55.053]                       }
[17:43:55.053]                       invisible(muffled)
[17:43:55.053]                     }
[17:43:55.053]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.053]                   }
[17:43:55.053]                 }
[17:43:55.053]                 else {
[17:43:55.053]                   if (TRUE) {
[17:43:55.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.053]                     {
[17:43:55.053]                       inherits <- base::inherits
[17:43:55.053]                       invokeRestart <- base::invokeRestart
[17:43:55.053]                       is.null <- base::is.null
[17:43:55.053]                       muffled <- FALSE
[17:43:55.053]                       if (inherits(cond, "message")) {
[17:43:55.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.053]                         if (muffled) 
[17:43:55.053]                           invokeRestart("muffleMessage")
[17:43:55.053]                       }
[17:43:55.053]                       else if (inherits(cond, "warning")) {
[17:43:55.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.053]                         if (muffled) 
[17:43:55.053]                           invokeRestart("muffleWarning")
[17:43:55.053]                       }
[17:43:55.053]                       else if (inherits(cond, "condition")) {
[17:43:55.053]                         if (!is.null(pattern)) {
[17:43:55.053]                           computeRestarts <- base::computeRestarts
[17:43:55.053]                           grepl <- base::grepl
[17:43:55.053]                           restarts <- computeRestarts(cond)
[17:43:55.053]                           for (restart in restarts) {
[17:43:55.053]                             name <- restart$name
[17:43:55.053]                             if (is.null(name)) 
[17:43:55.053]                               next
[17:43:55.053]                             if (!grepl(pattern, name)) 
[17:43:55.053]                               next
[17:43:55.053]                             invokeRestart(restart)
[17:43:55.053]                             muffled <- TRUE
[17:43:55.053]                             break
[17:43:55.053]                           }
[17:43:55.053]                         }
[17:43:55.053]                       }
[17:43:55.053]                       invisible(muffled)
[17:43:55.053]                     }
[17:43:55.053]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.053]                   }
[17:43:55.053]                 }
[17:43:55.053]             }
[17:43:55.053]         }))
[17:43:55.053]     }, error = function(ex) {
[17:43:55.053]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.053]                 ...future.rng), started = ...future.startTime, 
[17:43:55.053]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.053]             version = "1.8"), class = "FutureResult")
[17:43:55.053]     }, finally = {
[17:43:55.053]         if (!identical(...future.workdir, getwd())) 
[17:43:55.053]             setwd(...future.workdir)
[17:43:55.053]         {
[17:43:55.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.053]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.053]             }
[17:43:55.053]             base::options(...future.oldOptions)
[17:43:55.053]             if (.Platform$OS.type == "windows") {
[17:43:55.053]                 old_names <- names(...future.oldEnvVars)
[17:43:55.053]                 envs <- base::Sys.getenv()
[17:43:55.053]                 names <- names(envs)
[17:43:55.053]                 common <- intersect(names, old_names)
[17:43:55.053]                 added <- setdiff(names, old_names)
[17:43:55.053]                 removed <- setdiff(old_names, names)
[17:43:55.053]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.053]                   envs[common]]
[17:43:55.053]                 NAMES <- toupper(changed)
[17:43:55.053]                 args <- list()
[17:43:55.053]                 for (kk in seq_along(NAMES)) {
[17:43:55.053]                   name <- changed[[kk]]
[17:43:55.053]                   NAME <- NAMES[[kk]]
[17:43:55.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.053]                     next
[17:43:55.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.053]                 }
[17:43:55.053]                 NAMES <- toupper(added)
[17:43:55.053]                 for (kk in seq_along(NAMES)) {
[17:43:55.053]                   name <- added[[kk]]
[17:43:55.053]                   NAME <- NAMES[[kk]]
[17:43:55.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.053]                     next
[17:43:55.053]                   args[[name]] <- ""
[17:43:55.053]                 }
[17:43:55.053]                 NAMES <- toupper(removed)
[17:43:55.053]                 for (kk in seq_along(NAMES)) {
[17:43:55.053]                   name <- removed[[kk]]
[17:43:55.053]                   NAME <- NAMES[[kk]]
[17:43:55.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.053]                     next
[17:43:55.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.053]                 }
[17:43:55.053]                 if (length(args) > 0) 
[17:43:55.053]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.053]             }
[17:43:55.053]             else {
[17:43:55.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.053]             }
[17:43:55.053]             {
[17:43:55.053]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.053]                   0L) {
[17:43:55.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.053]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.053]                   base::options(opts)
[17:43:55.053]                 }
[17:43:55.053]                 {
[17:43:55.053]                   {
[17:43:55.053]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.053]                     NULL
[17:43:55.053]                   }
[17:43:55.053]                   options(future.plan = NULL)
[17:43:55.053]                   if (is.na(NA_character_)) 
[17:43:55.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.053]                     .init = FALSE)
[17:43:55.053]                 }
[17:43:55.053]             }
[17:43:55.053]         }
[17:43:55.053]     })
[17:43:55.053]     if (TRUE) {
[17:43:55.053]         base::sink(type = "output", split = FALSE)
[17:43:55.053]         if (TRUE) {
[17:43:55.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.053]         }
[17:43:55.053]         else {
[17:43:55.053]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.053]         }
[17:43:55.053]         base::close(...future.stdout)
[17:43:55.053]         ...future.stdout <- NULL
[17:43:55.053]     }
[17:43:55.053]     ...future.result$conditions <- ...future.conditions
[17:43:55.053]     ...future.result$finished <- base::Sys.time()
[17:43:55.053]     ...future.result
[17:43:55.053] }
[17:43:55.056] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[17:43:55.056] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[17:43:55.056] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[17:43:55.056] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[17:43:55.057] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[17:43:55.057] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[17:43:55.057] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[17:43:55.058] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:55.058] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.058] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:43:55.059] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:43:55.059] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:55.059] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.059] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:55.060] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.060] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[17:43:55.060] MultisessionFuture started
[17:43:55.060] - Launch lazy future ... done
[17:43:55.060] run() for ‘MultisessionFuture’ ... done
[17:43:55.061] Created future:
[17:43:55.061] MultisessionFuture:
[17:43:55.061] Label: ‘future_by-2’
[17:43:55.061] Expression:
[17:43:55.061] {
[17:43:55.061]     do.call(function(...) {
[17:43:55.061]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.061]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.061]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.061]             on.exit(options(oopts), add = TRUE)
[17:43:55.061]         }
[17:43:55.061]         {
[17:43:55.061]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.061]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.061]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.061]             })
[17:43:55.061]         }
[17:43:55.061]     }, args = future.call.arguments)
[17:43:55.061] }
[17:43:55.061] Lazy evaluation: FALSE
[17:43:55.061] Asynchronous evaluation: TRUE
[17:43:55.061] Local evaluation: TRUE
[17:43:55.061] Environment: 0x55d6bc4b5d58
[17:43:55.061] Capture standard output: TRUE
[17:43:55.061] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.061] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:43:55.061] Packages: 1 packages (‘stats’)
[17:43:55.061] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.061] Resolved: FALSE
[17:43:55.061] Value: <not collected>
[17:43:55.061] Conditions captured: <none>
[17:43:55.061] Early signaling: FALSE
[17:43:55.061] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:55.061] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.072] Chunk #2 of 2 ... DONE
[17:43:55.072] Launching 2 futures (chunks) ... DONE
[17:43:55.073] Resolving 2 futures (chunks) ...
[17:43:55.073] resolve() on list ...
[17:43:55.073]  recursive: 0
[17:43:55.073]  length: 2
[17:43:55.073] 
[17:43:55.073] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.073] - Validating connection of MultisessionFuture
[17:43:55.074] - received message: FutureResult
[17:43:55.074] - Received FutureResult
[17:43:55.074] - Erased future from FutureRegistry
[17:43:55.074] result() for ClusterFuture ...
[17:43:55.074] - result already collected: FutureResult
[17:43:55.074] result() for ClusterFuture ... done
[17:43:55.074] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.074] Future #1
[17:43:55.074] result() for ClusterFuture ...
[17:43:55.075] - result already collected: FutureResult
[17:43:55.075] result() for ClusterFuture ... done
[17:43:55.075] result() for ClusterFuture ...
[17:43:55.075] - result already collected: FutureResult
[17:43:55.075] result() for ClusterFuture ... done
[17:43:55.075] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:55.075] - nx: 2
[17:43:55.075] - relay: TRUE
[17:43:55.075] - stdout: TRUE
[17:43:55.075] - signal: TRUE
[17:43:55.075] - resignal: FALSE
[17:43:55.075] - force: TRUE
[17:43:55.076] - relayed: [n=2] FALSE, FALSE
[17:43:55.076] - queued futures: [n=2] FALSE, FALSE
[17:43:55.076]  - until=1
[17:43:55.076]  - relaying element #1
[17:43:55.076] result() for ClusterFuture ...
[17:43:55.076] - result already collected: FutureResult
[17:43:55.076] result() for ClusterFuture ... done
[17:43:55.076] result() for ClusterFuture ...
[17:43:55.076] - result already collected: FutureResult
[17:43:55.076] result() for ClusterFuture ... done
[17:43:55.076] result() for ClusterFuture ...
[17:43:55.077] - result already collected: FutureResult
[17:43:55.077] result() for ClusterFuture ... done
[17:43:55.077] result() for ClusterFuture ...
[17:43:55.077] - result already collected: FutureResult
[17:43:55.077] result() for ClusterFuture ... done
[17:43:55.077] - relayed: [n=2] TRUE, FALSE
[17:43:55.077] - queued futures: [n=2] TRUE, FALSE
[17:43:55.077] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:55.077]  length: 1 (resolved future 1)
[17:43:55.107] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.107] - Validating connection of MultisessionFuture
[17:43:55.107] - received message: FutureResult
[17:43:55.107] - Received FutureResult
[17:43:55.107] - Erased future from FutureRegistry
[17:43:55.107] result() for ClusterFuture ...
[17:43:55.107] - result already collected: FutureResult
[17:43:55.108] result() for ClusterFuture ... done
[17:43:55.108] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.108] Future #2
[17:43:55.108] result() for ClusterFuture ...
[17:43:55.108] - result already collected: FutureResult
[17:43:55.108] result() for ClusterFuture ... done
[17:43:55.108] result() for ClusterFuture ...
[17:43:55.108] - result already collected: FutureResult
[17:43:55.108] result() for ClusterFuture ... done
[17:43:55.108] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:55.108] - nx: 2
[17:43:55.109] - relay: TRUE
[17:43:55.109] - stdout: TRUE
[17:43:55.109] - signal: TRUE
[17:43:55.109] - resignal: FALSE
[17:43:55.109] - force: TRUE
[17:43:55.109] - relayed: [n=2] TRUE, FALSE
[17:43:55.109] - queued futures: [n=2] TRUE, FALSE
[17:43:55.109]  - until=2
[17:43:55.109]  - relaying element #2
[17:43:55.109] result() for ClusterFuture ...
[17:43:55.109] - result already collected: FutureResult
[17:43:55.109] result() for ClusterFuture ... done
[17:43:55.110] result() for ClusterFuture ...
[17:43:55.110] - result already collected: FutureResult
[17:43:55.110] result() for ClusterFuture ... done
[17:43:55.110] result() for ClusterFuture ...
[17:43:55.110] - result already collected: FutureResult
[17:43:55.110] result() for ClusterFuture ... done
[17:43:55.110] result() for ClusterFuture ...
[17:43:55.110] - result already collected: FutureResult
[17:43:55.110] result() for ClusterFuture ... done
[17:43:55.110] - relayed: [n=2] TRUE, TRUE
[17:43:55.110] - queued futures: [n=2] TRUE, TRUE
[17:43:55.111] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:55.111]  length: 0 (resolved future 2)
[17:43:55.111] Relaying remaining futures
[17:43:55.111] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.111] - nx: 2
[17:43:55.111] - relay: TRUE
[17:43:55.111] - stdout: TRUE
[17:43:55.111] - signal: TRUE
[17:43:55.111] - resignal: FALSE
[17:43:55.111] - force: TRUE
[17:43:55.111] - relayed: [n=2] TRUE, TRUE
[17:43:55.112] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:55.112] - relayed: [n=2] TRUE, TRUE
[17:43:55.112] - queued futures: [n=2] TRUE, TRUE
[17:43:55.112] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.112] resolve() on list ... DONE
[17:43:55.112] result() for ClusterFuture ...
[17:43:55.112] - result already collected: FutureResult
[17:43:55.112] result() for ClusterFuture ... done
[17:43:55.112] result() for ClusterFuture ...
[17:43:55.112] - result already collected: FutureResult
[17:43:55.112] result() for ClusterFuture ... done
[17:43:55.113] result() for ClusterFuture ...
[17:43:55.113] - result already collected: FutureResult
[17:43:55.113] result() for ClusterFuture ... done
[17:43:55.113] result() for ClusterFuture ...
[17:43:55.113] - result already collected: FutureResult
[17:43:55.113] result() for ClusterFuture ... done
[17:43:55.113]  - Number of value chunks collected: 2
[17:43:55.113] Resolving 2 futures (chunks) ... DONE
[17:43:55.113] Reducing values from 2 chunks ...
[17:43:55.113]  - Number of values collected after concatenation: 3
[17:43:55.113]  - Number of values expected: 3
[17:43:55.114] Reducing values from 2 chunks ... DONE
[17:43:55.114] future_lapply() ... DONE
[17:43:55.114] future_by_internal() ... DONE
[17:43:55.114] future_by_internal() ...
[17:43:55.114] future_lapply() ...
[17:43:55.119] Number of chunks: 2
[17:43:55.119] getGlobalsAndPackagesXApply() ...
[17:43:55.119]  - future.globals: TRUE
[17:43:55.119] getGlobalsAndPackages() ...
[17:43:55.119] Searching for globals...
[17:43:55.120] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.120] Searching for globals ... DONE
[17:43:55.120] Resolving globals: FALSE
[17:43:55.121] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:55.121] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:55.121] - globals: [1] ‘FUN’
[17:43:55.121] 
[17:43:55.121] getGlobalsAndPackages() ... DONE
[17:43:55.121]  - globals found/used: [n=1] ‘FUN’
[17:43:55.121]  - needed namespaces: [n=0] 
[17:43:55.122] Finding globals ... DONE
[17:43:55.122]  - use_args: TRUE
[17:43:55.122]  - Getting '...' globals ...
[17:43:55.122] resolve() on list ...
[17:43:55.122]  recursive: 0
[17:43:55.122]  length: 1
[17:43:55.122]  elements: ‘...’
[17:43:55.122]  length: 0 (resolved future 1)
[17:43:55.122] resolve() on list ... DONE
[17:43:55.123]    - '...' content: [n=0] 
[17:43:55.123] List of 1
[17:43:55.123]  $ ...: list()
[17:43:55.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.123]  - attr(*, "where")=List of 1
[17:43:55.123]   ..$ ...:<environment: 0x55d6ba0a2040> 
[17:43:55.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.123]  - attr(*, "resolved")= logi TRUE
[17:43:55.123]  - attr(*, "total_size")= num NA
[17:43:55.125]  - Getting '...' globals ... DONE
[17:43:55.125] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.125] List of 2
[17:43:55.125]  $ ...future.FUN:function (object, ...)  
[17:43:55.125]  $ ...          : list()
[17:43:55.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.125]  - attr(*, "where")=List of 2
[17:43:55.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.125]   ..$ ...          :<environment: 0x55d6ba0a2040> 
[17:43:55.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.125]  - attr(*, "resolved")= logi FALSE
[17:43:55.125]  - attr(*, "total_size")= num 1240
[17:43:55.128] Packages to be attached in all futures: [n=0] 
[17:43:55.128] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.128] Number of futures (= number of chunks): 2
[17:43:55.128] Launching 2 futures (chunks) ...
[17:43:55.128] Chunk #1 of 2 ...
[17:43:55.128]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.129] getGlobalsAndPackages() ...
[17:43:55.129] Searching for globals...
[17:43:55.129] 
[17:43:55.129] Searching for globals ... DONE
[17:43:55.129] - globals: [0] <none>
[17:43:55.129] getGlobalsAndPackages() ... DONE
[17:43:55.129]    + additional globals found: [n=0] 
[17:43:55.129]    + additional namespaces needed: [n=0] 
[17:43:55.129]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.130]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.130]  - seeds: <none>
[17:43:55.130]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.130] getGlobalsAndPackages() ...
[17:43:55.130] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.130] Resolving globals: FALSE
[17:43:55.130] Tweak future expression to call with '...' arguments ...
[17:43:55.130] {
[17:43:55.130]     do.call(function(...) {
[17:43:55.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.130]             on.exit(options(oopts), add = TRUE)
[17:43:55.130]         }
[17:43:55.130]         {
[17:43:55.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.130]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.130]             })
[17:43:55.130]         }
[17:43:55.130]     }, args = future.call.arguments)
[17:43:55.130] }
[17:43:55.131] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.131] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.131] 
[17:43:55.131] getGlobalsAndPackages() ... DONE
[17:43:55.131] run() for ‘Future’ ...
[17:43:55.131] - state: ‘created’
[17:43:55.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.145]   - Field: ‘node’
[17:43:55.145]   - Field: ‘label’
[17:43:55.146]   - Field: ‘local’
[17:43:55.146]   - Field: ‘owner’
[17:43:55.146]   - Field: ‘envir’
[17:43:55.146]   - Field: ‘workers’
[17:43:55.146]   - Field: ‘packages’
[17:43:55.146]   - Field: ‘gc’
[17:43:55.146]   - Field: ‘conditions’
[17:43:55.146]   - Field: ‘persistent’
[17:43:55.146]   - Field: ‘expr’
[17:43:55.146]   - Field: ‘uuid’
[17:43:55.146]   - Field: ‘seed’
[17:43:55.146]   - Field: ‘version’
[17:43:55.147]   - Field: ‘result’
[17:43:55.147]   - Field: ‘asynchronous’
[17:43:55.147]   - Field: ‘calls’
[17:43:55.147]   - Field: ‘globals’
[17:43:55.147]   - Field: ‘stdout’
[17:43:55.147]   - Field: ‘earlySignal’
[17:43:55.147]   - Field: ‘lazy’
[17:43:55.147]   - Field: ‘state’
[17:43:55.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.147] - Launch lazy future ...
[17:43:55.148] Packages needed by the future expression (n = 0): <none>
[17:43:55.148] Packages needed by future strategies (n = 0): <none>
[17:43:55.148] {
[17:43:55.148]     {
[17:43:55.148]         {
[17:43:55.148]             ...future.startTime <- base::Sys.time()
[17:43:55.148]             {
[17:43:55.148]                 {
[17:43:55.148]                   {
[17:43:55.148]                     {
[17:43:55.148]                       base::local({
[17:43:55.148]                         has_future <- base::requireNamespace("future", 
[17:43:55.148]                           quietly = TRUE)
[17:43:55.148]                         if (has_future) {
[17:43:55.148]                           ns <- base::getNamespace("future")
[17:43:55.148]                           version <- ns[[".package"]][["version"]]
[17:43:55.148]                           if (is.null(version)) 
[17:43:55.148]                             version <- utils::packageVersion("future")
[17:43:55.148]                         }
[17:43:55.148]                         else {
[17:43:55.148]                           version <- NULL
[17:43:55.148]                         }
[17:43:55.148]                         if (!has_future || version < "1.8.0") {
[17:43:55.148]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.148]                             "", base::R.version$version.string), 
[17:43:55.148]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.148]                               "release", "version")], collapse = " "), 
[17:43:55.148]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.148]                             info)
[17:43:55.148]                           info <- base::paste(info, collapse = "; ")
[17:43:55.148]                           if (!has_future) {
[17:43:55.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.148]                               info)
[17:43:55.148]                           }
[17:43:55.148]                           else {
[17:43:55.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.148]                               info, version)
[17:43:55.148]                           }
[17:43:55.148]                           base::stop(msg)
[17:43:55.148]                         }
[17:43:55.148]                       })
[17:43:55.148]                     }
[17:43:55.148]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.148]                     base::options(mc.cores = 1L)
[17:43:55.148]                   }
[17:43:55.148]                   ...future.strategy.old <- future::plan("list")
[17:43:55.148]                   options(future.plan = NULL)
[17:43:55.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.148]                 }
[17:43:55.148]                 ...future.workdir <- getwd()
[17:43:55.148]             }
[17:43:55.148]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.148]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.148]         }
[17:43:55.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.148]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.148]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.148]             base::names(...future.oldOptions))
[17:43:55.148]     }
[17:43:55.148]     if (FALSE) {
[17:43:55.148]     }
[17:43:55.148]     else {
[17:43:55.148]         if (TRUE) {
[17:43:55.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.148]                 open = "w")
[17:43:55.148]         }
[17:43:55.148]         else {
[17:43:55.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.148]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.148]         }
[17:43:55.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.148]             base::sink(type = "output", split = FALSE)
[17:43:55.148]             base::close(...future.stdout)
[17:43:55.148]         }, add = TRUE)
[17:43:55.148]     }
[17:43:55.148]     ...future.frame <- base::sys.nframe()
[17:43:55.148]     ...future.conditions <- base::list()
[17:43:55.148]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.148]     if (FALSE) {
[17:43:55.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.148]     }
[17:43:55.148]     ...future.result <- base::tryCatch({
[17:43:55.148]         base::withCallingHandlers({
[17:43:55.148]             ...future.value <- base::withVisible(base::local({
[17:43:55.148]                 ...future.makeSendCondition <- base::local({
[17:43:55.148]                   sendCondition <- NULL
[17:43:55.148]                   function(frame = 1L) {
[17:43:55.148]                     if (is.function(sendCondition)) 
[17:43:55.148]                       return(sendCondition)
[17:43:55.148]                     ns <- getNamespace("parallel")
[17:43:55.148]                     if (exists("sendData", mode = "function", 
[17:43:55.148]                       envir = ns)) {
[17:43:55.148]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.148]                         envir = ns)
[17:43:55.148]                       envir <- sys.frame(frame)
[17:43:55.148]                       master <- NULL
[17:43:55.148]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.148]                         !identical(envir, emptyenv())) {
[17:43:55.148]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.148]                           inherits = FALSE)) {
[17:43:55.148]                           master <- get("master", mode = "list", 
[17:43:55.148]                             envir = envir, inherits = FALSE)
[17:43:55.148]                           if (inherits(master, c("SOCKnode", 
[17:43:55.148]                             "SOCK0node"))) {
[17:43:55.148]                             sendCondition <<- function(cond) {
[17:43:55.148]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.148]                                 success = TRUE)
[17:43:55.148]                               parallel_sendData(master, data)
[17:43:55.148]                             }
[17:43:55.148]                             return(sendCondition)
[17:43:55.148]                           }
[17:43:55.148]                         }
[17:43:55.148]                         frame <- frame + 1L
[17:43:55.148]                         envir <- sys.frame(frame)
[17:43:55.148]                       }
[17:43:55.148]                     }
[17:43:55.148]                     sendCondition <<- function(cond) NULL
[17:43:55.148]                   }
[17:43:55.148]                 })
[17:43:55.148]                 withCallingHandlers({
[17:43:55.148]                   {
[17:43:55.148]                     do.call(function(...) {
[17:43:55.148]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.148]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.148]                         ...future.globals.maxSize)) {
[17:43:55.148]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.148]                         on.exit(options(oopts), add = TRUE)
[17:43:55.148]                       }
[17:43:55.148]                       {
[17:43:55.148]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.148]                           FUN = function(jj) {
[17:43:55.148]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.148]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.148]                           })
[17:43:55.148]                       }
[17:43:55.148]                     }, args = future.call.arguments)
[17:43:55.148]                   }
[17:43:55.148]                 }, immediateCondition = function(cond) {
[17:43:55.148]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.148]                   sendCondition(cond)
[17:43:55.148]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.148]                   {
[17:43:55.148]                     inherits <- base::inherits
[17:43:55.148]                     invokeRestart <- base::invokeRestart
[17:43:55.148]                     is.null <- base::is.null
[17:43:55.148]                     muffled <- FALSE
[17:43:55.148]                     if (inherits(cond, "message")) {
[17:43:55.148]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.148]                       if (muffled) 
[17:43:55.148]                         invokeRestart("muffleMessage")
[17:43:55.148]                     }
[17:43:55.148]                     else if (inherits(cond, "warning")) {
[17:43:55.148]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.148]                       if (muffled) 
[17:43:55.148]                         invokeRestart("muffleWarning")
[17:43:55.148]                     }
[17:43:55.148]                     else if (inherits(cond, "condition")) {
[17:43:55.148]                       if (!is.null(pattern)) {
[17:43:55.148]                         computeRestarts <- base::computeRestarts
[17:43:55.148]                         grepl <- base::grepl
[17:43:55.148]                         restarts <- computeRestarts(cond)
[17:43:55.148]                         for (restart in restarts) {
[17:43:55.148]                           name <- restart$name
[17:43:55.148]                           if (is.null(name)) 
[17:43:55.148]                             next
[17:43:55.148]                           if (!grepl(pattern, name)) 
[17:43:55.148]                             next
[17:43:55.148]                           invokeRestart(restart)
[17:43:55.148]                           muffled <- TRUE
[17:43:55.148]                           break
[17:43:55.148]                         }
[17:43:55.148]                       }
[17:43:55.148]                     }
[17:43:55.148]                     invisible(muffled)
[17:43:55.148]                   }
[17:43:55.148]                   muffleCondition(cond)
[17:43:55.148]                 })
[17:43:55.148]             }))
[17:43:55.148]             future::FutureResult(value = ...future.value$value, 
[17:43:55.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.148]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.148]                     ...future.globalenv.names))
[17:43:55.148]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.148]         }, condition = base::local({
[17:43:55.148]             c <- base::c
[17:43:55.148]             inherits <- base::inherits
[17:43:55.148]             invokeRestart <- base::invokeRestart
[17:43:55.148]             length <- base::length
[17:43:55.148]             list <- base::list
[17:43:55.148]             seq.int <- base::seq.int
[17:43:55.148]             signalCondition <- base::signalCondition
[17:43:55.148]             sys.calls <- base::sys.calls
[17:43:55.148]             `[[` <- base::`[[`
[17:43:55.148]             `+` <- base::`+`
[17:43:55.148]             `<<-` <- base::`<<-`
[17:43:55.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.148]                   3L)]
[17:43:55.148]             }
[17:43:55.148]             function(cond) {
[17:43:55.148]                 is_error <- inherits(cond, "error")
[17:43:55.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.148]                   NULL)
[17:43:55.148]                 if (is_error) {
[17:43:55.148]                   sessionInformation <- function() {
[17:43:55.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.148]                       search = base::search(), system = base::Sys.info())
[17:43:55.148]                   }
[17:43:55.148]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.148]                     cond$call), session = sessionInformation(), 
[17:43:55.148]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.148]                   signalCondition(cond)
[17:43:55.148]                 }
[17:43:55.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.148]                 "immediateCondition"))) {
[17:43:55.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.148]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.148]                   if (TRUE && !signal) {
[17:43:55.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.148]                     {
[17:43:55.148]                       inherits <- base::inherits
[17:43:55.148]                       invokeRestart <- base::invokeRestart
[17:43:55.148]                       is.null <- base::is.null
[17:43:55.148]                       muffled <- FALSE
[17:43:55.148]                       if (inherits(cond, "message")) {
[17:43:55.148]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.148]                         if (muffled) 
[17:43:55.148]                           invokeRestart("muffleMessage")
[17:43:55.148]                       }
[17:43:55.148]                       else if (inherits(cond, "warning")) {
[17:43:55.148]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.148]                         if (muffled) 
[17:43:55.148]                           invokeRestart("muffleWarning")
[17:43:55.148]                       }
[17:43:55.148]                       else if (inherits(cond, "condition")) {
[17:43:55.148]                         if (!is.null(pattern)) {
[17:43:55.148]                           computeRestarts <- base::computeRestarts
[17:43:55.148]                           grepl <- base::grepl
[17:43:55.148]                           restarts <- computeRestarts(cond)
[17:43:55.148]                           for (restart in restarts) {
[17:43:55.148]                             name <- restart$name
[17:43:55.148]                             if (is.null(name)) 
[17:43:55.148]                               next
[17:43:55.148]                             if (!grepl(pattern, name)) 
[17:43:55.148]                               next
[17:43:55.148]                             invokeRestart(restart)
[17:43:55.148]                             muffled <- TRUE
[17:43:55.148]                             break
[17:43:55.148]                           }
[17:43:55.148]                         }
[17:43:55.148]                       }
[17:43:55.148]                       invisible(muffled)
[17:43:55.148]                     }
[17:43:55.148]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.148]                   }
[17:43:55.148]                 }
[17:43:55.148]                 else {
[17:43:55.148]                   if (TRUE) {
[17:43:55.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.148]                     {
[17:43:55.148]                       inherits <- base::inherits
[17:43:55.148]                       invokeRestart <- base::invokeRestart
[17:43:55.148]                       is.null <- base::is.null
[17:43:55.148]                       muffled <- FALSE
[17:43:55.148]                       if (inherits(cond, "message")) {
[17:43:55.148]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.148]                         if (muffled) 
[17:43:55.148]                           invokeRestart("muffleMessage")
[17:43:55.148]                       }
[17:43:55.148]                       else if (inherits(cond, "warning")) {
[17:43:55.148]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.148]                         if (muffled) 
[17:43:55.148]                           invokeRestart("muffleWarning")
[17:43:55.148]                       }
[17:43:55.148]                       else if (inherits(cond, "condition")) {
[17:43:55.148]                         if (!is.null(pattern)) {
[17:43:55.148]                           computeRestarts <- base::computeRestarts
[17:43:55.148]                           grepl <- base::grepl
[17:43:55.148]                           restarts <- computeRestarts(cond)
[17:43:55.148]                           for (restart in restarts) {
[17:43:55.148]                             name <- restart$name
[17:43:55.148]                             if (is.null(name)) 
[17:43:55.148]                               next
[17:43:55.148]                             if (!grepl(pattern, name)) 
[17:43:55.148]                               next
[17:43:55.148]                             invokeRestart(restart)
[17:43:55.148]                             muffled <- TRUE
[17:43:55.148]                             break
[17:43:55.148]                           }
[17:43:55.148]                         }
[17:43:55.148]                       }
[17:43:55.148]                       invisible(muffled)
[17:43:55.148]                     }
[17:43:55.148]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.148]                   }
[17:43:55.148]                 }
[17:43:55.148]             }
[17:43:55.148]         }))
[17:43:55.148]     }, error = function(ex) {
[17:43:55.148]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.148]                 ...future.rng), started = ...future.startTime, 
[17:43:55.148]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.148]             version = "1.8"), class = "FutureResult")
[17:43:55.148]     }, finally = {
[17:43:55.148]         if (!identical(...future.workdir, getwd())) 
[17:43:55.148]             setwd(...future.workdir)
[17:43:55.148]         {
[17:43:55.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.148]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.148]             }
[17:43:55.148]             base::options(...future.oldOptions)
[17:43:55.148]             if (.Platform$OS.type == "windows") {
[17:43:55.148]                 old_names <- names(...future.oldEnvVars)
[17:43:55.148]                 envs <- base::Sys.getenv()
[17:43:55.148]                 names <- names(envs)
[17:43:55.148]                 common <- intersect(names, old_names)
[17:43:55.148]                 added <- setdiff(names, old_names)
[17:43:55.148]                 removed <- setdiff(old_names, names)
[17:43:55.148]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.148]                   envs[common]]
[17:43:55.148]                 NAMES <- toupper(changed)
[17:43:55.148]                 args <- list()
[17:43:55.148]                 for (kk in seq_along(NAMES)) {
[17:43:55.148]                   name <- changed[[kk]]
[17:43:55.148]                   NAME <- NAMES[[kk]]
[17:43:55.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.148]                     next
[17:43:55.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.148]                 }
[17:43:55.148]                 NAMES <- toupper(added)
[17:43:55.148]                 for (kk in seq_along(NAMES)) {
[17:43:55.148]                   name <- added[[kk]]
[17:43:55.148]                   NAME <- NAMES[[kk]]
[17:43:55.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.148]                     next
[17:43:55.148]                   args[[name]] <- ""
[17:43:55.148]                 }
[17:43:55.148]                 NAMES <- toupper(removed)
[17:43:55.148]                 for (kk in seq_along(NAMES)) {
[17:43:55.148]                   name <- removed[[kk]]
[17:43:55.148]                   NAME <- NAMES[[kk]]
[17:43:55.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.148]                     next
[17:43:55.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.148]                 }
[17:43:55.148]                 if (length(args) > 0) 
[17:43:55.148]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.148]             }
[17:43:55.148]             else {
[17:43:55.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.148]             }
[17:43:55.148]             {
[17:43:55.148]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.148]                   0L) {
[17:43:55.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.148]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.148]                   base::options(opts)
[17:43:55.148]                 }
[17:43:55.148]                 {
[17:43:55.148]                   {
[17:43:55.148]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.148]                     NULL
[17:43:55.148]                   }
[17:43:55.148]                   options(future.plan = NULL)
[17:43:55.148]                   if (is.na(NA_character_)) 
[17:43:55.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.148]                     .init = FALSE)
[17:43:55.148]                 }
[17:43:55.148]             }
[17:43:55.148]         }
[17:43:55.148]     })
[17:43:55.148]     if (TRUE) {
[17:43:55.148]         base::sink(type = "output", split = FALSE)
[17:43:55.148]         if (TRUE) {
[17:43:55.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.148]         }
[17:43:55.148]         else {
[17:43:55.148]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.148]         }
[17:43:55.148]         base::close(...future.stdout)
[17:43:55.148]         ...future.stdout <- NULL
[17:43:55.148]     }
[17:43:55.148]     ...future.result$conditions <- ...future.conditions
[17:43:55.148]     ...future.result$finished <- base::Sys.time()
[17:43:55.148]     ...future.result
[17:43:55.148] }
[17:43:55.151] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:43:55.151] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:43:55.151] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:43:55.152] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:55.152] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.152] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:43:55.153] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:43:55.153] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:55.153] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.153] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:55.154] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.154] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:43:55.154] MultisessionFuture started
[17:43:55.154] - Launch lazy future ... done
[17:43:55.154] run() for ‘MultisessionFuture’ ... done
[17:43:55.155] Created future:
[17:43:55.155] MultisessionFuture:
[17:43:55.155] Label: ‘future_by-1’
[17:43:55.155] Expression:
[17:43:55.155] {
[17:43:55.155]     do.call(function(...) {
[17:43:55.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.155]             on.exit(options(oopts), add = TRUE)
[17:43:55.155]         }
[17:43:55.155]         {
[17:43:55.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.155]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.155]             })
[17:43:55.155]         }
[17:43:55.155]     }, args = future.call.arguments)
[17:43:55.155] }
[17:43:55.155] Lazy evaluation: FALSE
[17:43:55.155] Asynchronous evaluation: TRUE
[17:43:55.155] Local evaluation: TRUE
[17:43:55.155] Environment: 0x55d6ba0dcd48
[17:43:55.155] Capture standard output: TRUE
[17:43:55.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.155] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.155] Packages: <none>
[17:43:55.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.155] Resolved: FALSE
[17:43:55.155] Value: <not collected>
[17:43:55.155] Conditions captured: <none>
[17:43:55.155] Early signaling: FALSE
[17:43:55.155] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:55.155] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.167] Chunk #1 of 2 ... DONE
[17:43:55.167] Chunk #2 of 2 ...
[17:43:55.167]  - Finding globals in 'X' for chunk #2 ...
[17:43:55.167] getGlobalsAndPackages() ...
[17:43:55.167] Searching for globals...
[17:43:55.167] 
[17:43:55.168] Searching for globals ... DONE
[17:43:55.168] - globals: [0] <none>
[17:43:55.168] getGlobalsAndPackages() ... DONE
[17:43:55.168]    + additional globals found: [n=0] 
[17:43:55.168]    + additional namespaces needed: [n=0] 
[17:43:55.168]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:55.168]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.168]  - seeds: <none>
[17:43:55.168]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.168] getGlobalsAndPackages() ...
[17:43:55.168] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.169] Resolving globals: FALSE
[17:43:55.169] Tweak future expression to call with '...' arguments ...
[17:43:55.169] {
[17:43:55.169]     do.call(function(...) {
[17:43:55.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.169]             on.exit(options(oopts), add = TRUE)
[17:43:55.169]         }
[17:43:55.169]         {
[17:43:55.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.169]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.169]             })
[17:43:55.169]         }
[17:43:55.169]     }, args = future.call.arguments)
[17:43:55.169] }
[17:43:55.169] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.169] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.169] 
[17:43:55.170] getGlobalsAndPackages() ... DONE
[17:43:55.170] run() for ‘Future’ ...
[17:43:55.170] - state: ‘created’
[17:43:55.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.183] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.184]   - Field: ‘node’
[17:43:55.184]   - Field: ‘label’
[17:43:55.184]   - Field: ‘local’
[17:43:55.184]   - Field: ‘owner’
[17:43:55.184]   - Field: ‘envir’
[17:43:55.184]   - Field: ‘workers’
[17:43:55.184]   - Field: ‘packages’
[17:43:55.184]   - Field: ‘gc’
[17:43:55.184]   - Field: ‘conditions’
[17:43:55.185]   - Field: ‘persistent’
[17:43:55.185]   - Field: ‘expr’
[17:43:55.185]   - Field: ‘uuid’
[17:43:55.185]   - Field: ‘seed’
[17:43:55.185]   - Field: ‘version’
[17:43:55.185]   - Field: ‘result’
[17:43:55.185]   - Field: ‘asynchronous’
[17:43:55.185]   - Field: ‘calls’
[17:43:55.185]   - Field: ‘globals’
[17:43:55.185]   - Field: ‘stdout’
[17:43:55.185]   - Field: ‘earlySignal’
[17:43:55.186]   - Field: ‘lazy’
[17:43:55.186]   - Field: ‘state’
[17:43:55.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.186] - Launch lazy future ...
[17:43:55.186] Packages needed by the future expression (n = 0): <none>
[17:43:55.186] Packages needed by future strategies (n = 0): <none>
[17:43:55.187] {
[17:43:55.187]     {
[17:43:55.187]         {
[17:43:55.187]             ...future.startTime <- base::Sys.time()
[17:43:55.187]             {
[17:43:55.187]                 {
[17:43:55.187]                   {
[17:43:55.187]                     {
[17:43:55.187]                       base::local({
[17:43:55.187]                         has_future <- base::requireNamespace("future", 
[17:43:55.187]                           quietly = TRUE)
[17:43:55.187]                         if (has_future) {
[17:43:55.187]                           ns <- base::getNamespace("future")
[17:43:55.187]                           version <- ns[[".package"]][["version"]]
[17:43:55.187]                           if (is.null(version)) 
[17:43:55.187]                             version <- utils::packageVersion("future")
[17:43:55.187]                         }
[17:43:55.187]                         else {
[17:43:55.187]                           version <- NULL
[17:43:55.187]                         }
[17:43:55.187]                         if (!has_future || version < "1.8.0") {
[17:43:55.187]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.187]                             "", base::R.version$version.string), 
[17:43:55.187]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.187]                               "release", "version")], collapse = " "), 
[17:43:55.187]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.187]                             info)
[17:43:55.187]                           info <- base::paste(info, collapse = "; ")
[17:43:55.187]                           if (!has_future) {
[17:43:55.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.187]                               info)
[17:43:55.187]                           }
[17:43:55.187]                           else {
[17:43:55.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.187]                               info, version)
[17:43:55.187]                           }
[17:43:55.187]                           base::stop(msg)
[17:43:55.187]                         }
[17:43:55.187]                       })
[17:43:55.187]                     }
[17:43:55.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.187]                     base::options(mc.cores = 1L)
[17:43:55.187]                   }
[17:43:55.187]                   ...future.strategy.old <- future::plan("list")
[17:43:55.187]                   options(future.plan = NULL)
[17:43:55.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.187]                 }
[17:43:55.187]                 ...future.workdir <- getwd()
[17:43:55.187]             }
[17:43:55.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.187]         }
[17:43:55.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.187]             base::names(...future.oldOptions))
[17:43:55.187]     }
[17:43:55.187]     if (FALSE) {
[17:43:55.187]     }
[17:43:55.187]     else {
[17:43:55.187]         if (TRUE) {
[17:43:55.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.187]                 open = "w")
[17:43:55.187]         }
[17:43:55.187]         else {
[17:43:55.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.187]         }
[17:43:55.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.187]             base::sink(type = "output", split = FALSE)
[17:43:55.187]             base::close(...future.stdout)
[17:43:55.187]         }, add = TRUE)
[17:43:55.187]     }
[17:43:55.187]     ...future.frame <- base::sys.nframe()
[17:43:55.187]     ...future.conditions <- base::list()
[17:43:55.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.187]     if (FALSE) {
[17:43:55.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.187]     }
[17:43:55.187]     ...future.result <- base::tryCatch({
[17:43:55.187]         base::withCallingHandlers({
[17:43:55.187]             ...future.value <- base::withVisible(base::local({
[17:43:55.187]                 ...future.makeSendCondition <- base::local({
[17:43:55.187]                   sendCondition <- NULL
[17:43:55.187]                   function(frame = 1L) {
[17:43:55.187]                     if (is.function(sendCondition)) 
[17:43:55.187]                       return(sendCondition)
[17:43:55.187]                     ns <- getNamespace("parallel")
[17:43:55.187]                     if (exists("sendData", mode = "function", 
[17:43:55.187]                       envir = ns)) {
[17:43:55.187]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.187]                         envir = ns)
[17:43:55.187]                       envir <- sys.frame(frame)
[17:43:55.187]                       master <- NULL
[17:43:55.187]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.187]                         !identical(envir, emptyenv())) {
[17:43:55.187]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.187]                           inherits = FALSE)) {
[17:43:55.187]                           master <- get("master", mode = "list", 
[17:43:55.187]                             envir = envir, inherits = FALSE)
[17:43:55.187]                           if (inherits(master, c("SOCKnode", 
[17:43:55.187]                             "SOCK0node"))) {
[17:43:55.187]                             sendCondition <<- function(cond) {
[17:43:55.187]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.187]                                 success = TRUE)
[17:43:55.187]                               parallel_sendData(master, data)
[17:43:55.187]                             }
[17:43:55.187]                             return(sendCondition)
[17:43:55.187]                           }
[17:43:55.187]                         }
[17:43:55.187]                         frame <- frame + 1L
[17:43:55.187]                         envir <- sys.frame(frame)
[17:43:55.187]                       }
[17:43:55.187]                     }
[17:43:55.187]                     sendCondition <<- function(cond) NULL
[17:43:55.187]                   }
[17:43:55.187]                 })
[17:43:55.187]                 withCallingHandlers({
[17:43:55.187]                   {
[17:43:55.187]                     do.call(function(...) {
[17:43:55.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.187]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.187]                         ...future.globals.maxSize)) {
[17:43:55.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.187]                         on.exit(options(oopts), add = TRUE)
[17:43:55.187]                       }
[17:43:55.187]                       {
[17:43:55.187]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.187]                           FUN = function(jj) {
[17:43:55.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.187]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.187]                           })
[17:43:55.187]                       }
[17:43:55.187]                     }, args = future.call.arguments)
[17:43:55.187]                   }
[17:43:55.187]                 }, immediateCondition = function(cond) {
[17:43:55.187]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.187]                   sendCondition(cond)
[17:43:55.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.187]                   {
[17:43:55.187]                     inherits <- base::inherits
[17:43:55.187]                     invokeRestart <- base::invokeRestart
[17:43:55.187]                     is.null <- base::is.null
[17:43:55.187]                     muffled <- FALSE
[17:43:55.187]                     if (inherits(cond, "message")) {
[17:43:55.187]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.187]                       if (muffled) 
[17:43:55.187]                         invokeRestart("muffleMessage")
[17:43:55.187]                     }
[17:43:55.187]                     else if (inherits(cond, "warning")) {
[17:43:55.187]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.187]                       if (muffled) 
[17:43:55.187]                         invokeRestart("muffleWarning")
[17:43:55.187]                     }
[17:43:55.187]                     else if (inherits(cond, "condition")) {
[17:43:55.187]                       if (!is.null(pattern)) {
[17:43:55.187]                         computeRestarts <- base::computeRestarts
[17:43:55.187]                         grepl <- base::grepl
[17:43:55.187]                         restarts <- computeRestarts(cond)
[17:43:55.187]                         for (restart in restarts) {
[17:43:55.187]                           name <- restart$name
[17:43:55.187]                           if (is.null(name)) 
[17:43:55.187]                             next
[17:43:55.187]                           if (!grepl(pattern, name)) 
[17:43:55.187]                             next
[17:43:55.187]                           invokeRestart(restart)
[17:43:55.187]                           muffled <- TRUE
[17:43:55.187]                           break
[17:43:55.187]                         }
[17:43:55.187]                       }
[17:43:55.187]                     }
[17:43:55.187]                     invisible(muffled)
[17:43:55.187]                   }
[17:43:55.187]                   muffleCondition(cond)
[17:43:55.187]                 })
[17:43:55.187]             }))
[17:43:55.187]             future::FutureResult(value = ...future.value$value, 
[17:43:55.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.187]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.187]                     ...future.globalenv.names))
[17:43:55.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.187]         }, condition = base::local({
[17:43:55.187]             c <- base::c
[17:43:55.187]             inherits <- base::inherits
[17:43:55.187]             invokeRestart <- base::invokeRestart
[17:43:55.187]             length <- base::length
[17:43:55.187]             list <- base::list
[17:43:55.187]             seq.int <- base::seq.int
[17:43:55.187]             signalCondition <- base::signalCondition
[17:43:55.187]             sys.calls <- base::sys.calls
[17:43:55.187]             `[[` <- base::`[[`
[17:43:55.187]             `+` <- base::`+`
[17:43:55.187]             `<<-` <- base::`<<-`
[17:43:55.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.187]                   3L)]
[17:43:55.187]             }
[17:43:55.187]             function(cond) {
[17:43:55.187]                 is_error <- inherits(cond, "error")
[17:43:55.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.187]                   NULL)
[17:43:55.187]                 if (is_error) {
[17:43:55.187]                   sessionInformation <- function() {
[17:43:55.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.187]                       search = base::search(), system = base::Sys.info())
[17:43:55.187]                   }
[17:43:55.187]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.187]                     cond$call), session = sessionInformation(), 
[17:43:55.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.187]                   signalCondition(cond)
[17:43:55.187]                 }
[17:43:55.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.187]                 "immediateCondition"))) {
[17:43:55.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.187]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.187]                   if (TRUE && !signal) {
[17:43:55.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.187]                     {
[17:43:55.187]                       inherits <- base::inherits
[17:43:55.187]                       invokeRestart <- base::invokeRestart
[17:43:55.187]                       is.null <- base::is.null
[17:43:55.187]                       muffled <- FALSE
[17:43:55.187]                       if (inherits(cond, "message")) {
[17:43:55.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.187]                         if (muffled) 
[17:43:55.187]                           invokeRestart("muffleMessage")
[17:43:55.187]                       }
[17:43:55.187]                       else if (inherits(cond, "warning")) {
[17:43:55.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.187]                         if (muffled) 
[17:43:55.187]                           invokeRestart("muffleWarning")
[17:43:55.187]                       }
[17:43:55.187]                       else if (inherits(cond, "condition")) {
[17:43:55.187]                         if (!is.null(pattern)) {
[17:43:55.187]                           computeRestarts <- base::computeRestarts
[17:43:55.187]                           grepl <- base::grepl
[17:43:55.187]                           restarts <- computeRestarts(cond)
[17:43:55.187]                           for (restart in restarts) {
[17:43:55.187]                             name <- restart$name
[17:43:55.187]                             if (is.null(name)) 
[17:43:55.187]                               next
[17:43:55.187]                             if (!grepl(pattern, name)) 
[17:43:55.187]                               next
[17:43:55.187]                             invokeRestart(restart)
[17:43:55.187]                             muffled <- TRUE
[17:43:55.187]                             break
[17:43:55.187]                           }
[17:43:55.187]                         }
[17:43:55.187]                       }
[17:43:55.187]                       invisible(muffled)
[17:43:55.187]                     }
[17:43:55.187]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.187]                   }
[17:43:55.187]                 }
[17:43:55.187]                 else {
[17:43:55.187]                   if (TRUE) {
[17:43:55.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.187]                     {
[17:43:55.187]                       inherits <- base::inherits
[17:43:55.187]                       invokeRestart <- base::invokeRestart
[17:43:55.187]                       is.null <- base::is.null
[17:43:55.187]                       muffled <- FALSE
[17:43:55.187]                       if (inherits(cond, "message")) {
[17:43:55.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.187]                         if (muffled) 
[17:43:55.187]                           invokeRestart("muffleMessage")
[17:43:55.187]                       }
[17:43:55.187]                       else if (inherits(cond, "warning")) {
[17:43:55.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.187]                         if (muffled) 
[17:43:55.187]                           invokeRestart("muffleWarning")
[17:43:55.187]                       }
[17:43:55.187]                       else if (inherits(cond, "condition")) {
[17:43:55.187]                         if (!is.null(pattern)) {
[17:43:55.187]                           computeRestarts <- base::computeRestarts
[17:43:55.187]                           grepl <- base::grepl
[17:43:55.187]                           restarts <- computeRestarts(cond)
[17:43:55.187]                           for (restart in restarts) {
[17:43:55.187]                             name <- restart$name
[17:43:55.187]                             if (is.null(name)) 
[17:43:55.187]                               next
[17:43:55.187]                             if (!grepl(pattern, name)) 
[17:43:55.187]                               next
[17:43:55.187]                             invokeRestart(restart)
[17:43:55.187]                             muffled <- TRUE
[17:43:55.187]                             break
[17:43:55.187]                           }
[17:43:55.187]                         }
[17:43:55.187]                       }
[17:43:55.187]                       invisible(muffled)
[17:43:55.187]                     }
[17:43:55.187]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.187]                   }
[17:43:55.187]                 }
[17:43:55.187]             }
[17:43:55.187]         }))
[17:43:55.187]     }, error = function(ex) {
[17:43:55.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.187]                 ...future.rng), started = ...future.startTime, 
[17:43:55.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.187]             version = "1.8"), class = "FutureResult")
[17:43:55.187]     }, finally = {
[17:43:55.187]         if (!identical(...future.workdir, getwd())) 
[17:43:55.187]             setwd(...future.workdir)
[17:43:55.187]         {
[17:43:55.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.187]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.187]             }
[17:43:55.187]             base::options(...future.oldOptions)
[17:43:55.187]             if (.Platform$OS.type == "windows") {
[17:43:55.187]                 old_names <- names(...future.oldEnvVars)
[17:43:55.187]                 envs <- base::Sys.getenv()
[17:43:55.187]                 names <- names(envs)
[17:43:55.187]                 common <- intersect(names, old_names)
[17:43:55.187]                 added <- setdiff(names, old_names)
[17:43:55.187]                 removed <- setdiff(old_names, names)
[17:43:55.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.187]                   envs[common]]
[17:43:55.187]                 NAMES <- toupper(changed)
[17:43:55.187]                 args <- list()
[17:43:55.187]                 for (kk in seq_along(NAMES)) {
[17:43:55.187]                   name <- changed[[kk]]
[17:43:55.187]                   NAME <- NAMES[[kk]]
[17:43:55.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.187]                     next
[17:43:55.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.187]                 }
[17:43:55.187]                 NAMES <- toupper(added)
[17:43:55.187]                 for (kk in seq_along(NAMES)) {
[17:43:55.187]                   name <- added[[kk]]
[17:43:55.187]                   NAME <- NAMES[[kk]]
[17:43:55.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.187]                     next
[17:43:55.187]                   args[[name]] <- ""
[17:43:55.187]                 }
[17:43:55.187]                 NAMES <- toupper(removed)
[17:43:55.187]                 for (kk in seq_along(NAMES)) {
[17:43:55.187]                   name <- removed[[kk]]
[17:43:55.187]                   NAME <- NAMES[[kk]]
[17:43:55.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.187]                     next
[17:43:55.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.187]                 }
[17:43:55.187]                 if (length(args) > 0) 
[17:43:55.187]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.187]             }
[17:43:55.187]             else {
[17:43:55.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.187]             }
[17:43:55.187]             {
[17:43:55.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.187]                   0L) {
[17:43:55.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.187]                   base::options(opts)
[17:43:55.187]                 }
[17:43:55.187]                 {
[17:43:55.187]                   {
[17:43:55.187]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.187]                     NULL
[17:43:55.187]                   }
[17:43:55.187]                   options(future.plan = NULL)
[17:43:55.187]                   if (is.na(NA_character_)) 
[17:43:55.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.187]                     .init = FALSE)
[17:43:55.187]                 }
[17:43:55.187]             }
[17:43:55.187]         }
[17:43:55.187]     })
[17:43:55.187]     if (TRUE) {
[17:43:55.187]         base::sink(type = "output", split = FALSE)
[17:43:55.187]         if (TRUE) {
[17:43:55.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.187]         }
[17:43:55.187]         else {
[17:43:55.187]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.187]         }
[17:43:55.187]         base::close(...future.stdout)
[17:43:55.187]         ...future.stdout <- NULL
[17:43:55.187]     }
[17:43:55.187]     ...future.result$conditions <- ...future.conditions
[17:43:55.187]     ...future.result$finished <- base::Sys.time()
[17:43:55.187]     ...future.result
[17:43:55.187] }
[17:43:55.189] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:43:55.189] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:43:55.190] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:43:55.190] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:55.190] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.190] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:43:55.191] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:43:55.191] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:55.191] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.191] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:55.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.192] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:43:55.192] MultisessionFuture started
[17:43:55.192] - Launch lazy future ... done
[17:43:55.192] run() for ‘MultisessionFuture’ ... done
[17:43:55.192] Created future:
[17:43:55.193] MultisessionFuture:
[17:43:55.193] Label: ‘future_by-2’
[17:43:55.193] Expression:
[17:43:55.193] {
[17:43:55.193]     do.call(function(...) {
[17:43:55.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.193]             on.exit(options(oopts), add = TRUE)
[17:43:55.193]         }
[17:43:55.193]         {
[17:43:55.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.193]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.193]             })
[17:43:55.193]         }
[17:43:55.193]     }, args = future.call.arguments)
[17:43:55.193] }
[17:43:55.193] Lazy evaluation: FALSE
[17:43:55.193] Asynchronous evaluation: TRUE
[17:43:55.193] Local evaluation: TRUE
[17:43:55.193] Environment: 0x55d6ba0dcd48
[17:43:55.193] Capture standard output: TRUE
[17:43:55.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.193] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.193] Packages: <none>
[17:43:55.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.193] Resolved: FALSE
[17:43:55.193] Value: <not collected>
[17:43:55.193] Conditions captured: <none>
[17:43:55.193] Early signaling: FALSE
[17:43:55.193] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:55.193] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.204] Chunk #2 of 2 ... DONE
[17:43:55.204] Launching 2 futures (chunks) ... DONE
[17:43:55.204] Resolving 2 futures (chunks) ...
[17:43:55.204] resolve() on list ...
[17:43:55.205]  recursive: 0
[17:43:55.205]  length: 2
[17:43:55.205] 
[17:43:55.205] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.205] - Validating connection of MultisessionFuture
[17:43:55.205] - received message: FutureResult
[17:43:55.206] - Received FutureResult
[17:43:55.206] - Erased future from FutureRegistry
[17:43:55.206] result() for ClusterFuture ...
[17:43:55.206] - result already collected: FutureResult
[17:43:55.206] result() for ClusterFuture ... done
[17:43:55.206] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.206] Future #1
[17:43:55.206] result() for ClusterFuture ...
[17:43:55.206] - result already collected: FutureResult
[17:43:55.206] result() for ClusterFuture ... done
[17:43:55.207] result() for ClusterFuture ...
[17:43:55.207] - result already collected: FutureResult
[17:43:55.207] result() for ClusterFuture ... done
[17:43:55.207] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:55.207] - nx: 2
[17:43:55.207] - relay: TRUE
[17:43:55.207] - stdout: TRUE
[17:43:55.207] - signal: TRUE
[17:43:55.207] - resignal: FALSE
[17:43:55.208] - force: TRUE
[17:43:55.208] - relayed: [n=2] FALSE, FALSE
[17:43:55.208] - queued futures: [n=2] FALSE, FALSE
[17:43:55.208]  - until=1
[17:43:55.208]  - relaying element #1
[17:43:55.208] result() for ClusterFuture ...
[17:43:55.208] - result already collected: FutureResult
[17:43:55.208] result() for ClusterFuture ... done
[17:43:55.209] result() for ClusterFuture ...
[17:43:55.209] - result already collected: FutureResult
[17:43:55.209] result() for ClusterFuture ... done
[17:43:55.209] result() for ClusterFuture ...
[17:43:55.209] - result already collected: FutureResult
[17:43:55.209] result() for ClusterFuture ... done
[17:43:55.209] result() for ClusterFuture ...
[17:43:55.209] - result already collected: FutureResult
[17:43:55.210] result() for ClusterFuture ... done
[17:43:55.210] - relayed: [n=2] TRUE, FALSE
[17:43:55.210] - queued futures: [n=2] TRUE, FALSE
[17:43:55.210] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:55.210]  length: 1 (resolved future 1)
[17:43:55.238] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.238] - Validating connection of MultisessionFuture
[17:43:55.239] - received message: FutureResult
[17:43:55.239] - Received FutureResult
[17:43:55.239] - Erased future from FutureRegistry
[17:43:55.239] result() for ClusterFuture ...
[17:43:55.239] - result already collected: FutureResult
[17:43:55.239] result() for ClusterFuture ... done
[17:43:55.240] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.240] Future #2
[17:43:55.240] result() for ClusterFuture ...
[17:43:55.240] - result already collected: FutureResult
[17:43:55.240] result() for ClusterFuture ... done
[17:43:55.240] result() for ClusterFuture ...
[17:43:55.240] - result already collected: FutureResult
[17:43:55.240] result() for ClusterFuture ... done
[17:43:55.240] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:55.240] - nx: 2
[17:43:55.240] - relay: TRUE
[17:43:55.241] - stdout: TRUE
[17:43:55.241] - signal: TRUE
[17:43:55.241] - resignal: FALSE
[17:43:55.241] - force: TRUE
[17:43:55.241] - relayed: [n=2] TRUE, FALSE
[17:43:55.241] - queued futures: [n=2] TRUE, FALSE
[17:43:55.241]  - until=2
[17:43:55.241]  - relaying element #2
[17:43:55.241] result() for ClusterFuture ...
[17:43:55.241] - result already collected: FutureResult
[17:43:55.241] result() for ClusterFuture ... done
[17:43:55.241] result() for ClusterFuture ...
[17:43:55.242] - result already collected: FutureResult
[17:43:55.242] result() for ClusterFuture ... done
[17:43:55.242] result() for ClusterFuture ...
[17:43:55.242] - result already collected: FutureResult
[17:43:55.242] result() for ClusterFuture ... done
[17:43:55.242] result() for ClusterFuture ...
[17:43:55.242] - result already collected: FutureResult
[17:43:55.242] result() for ClusterFuture ... done
[17:43:55.242] - relayed: [n=2] TRUE, TRUE
[17:43:55.242] - queued futures: [n=2] TRUE, TRUE
[17:43:55.242] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:55.243]  length: 0 (resolved future 2)
[17:43:55.243] Relaying remaining futures
[17:43:55.243] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.243] - nx: 2
[17:43:55.243] - relay: TRUE
[17:43:55.243] - stdout: TRUE
[17:43:55.243] - signal: TRUE
[17:43:55.243] - resignal: FALSE
[17:43:55.243] - force: TRUE
[17:43:55.243] - relayed: [n=2] TRUE, TRUE
[17:43:55.243] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:55.244] - relayed: [n=2] TRUE, TRUE
[17:43:55.244] - queued futures: [n=2] TRUE, TRUE
[17:43:55.244] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.244] resolve() on list ... DONE
[17:43:55.244] result() for ClusterFuture ...
[17:43:55.244] - result already collected: FutureResult
[17:43:55.244] result() for ClusterFuture ... done
[17:43:55.244] result() for ClusterFuture ...
[17:43:55.244] - result already collected: FutureResult
[17:43:55.244] result() for ClusterFuture ... done
[17:43:55.244] result() for ClusterFuture ...
[17:43:55.244] - result already collected: FutureResult
[17:43:55.245] result() for ClusterFuture ... done
[17:43:55.245] result() for ClusterFuture ...
[17:43:55.245] - result already collected: FutureResult
[17:43:55.245] result() for ClusterFuture ... done
[17:43:55.245]  - Number of value chunks collected: 2
[17:43:55.245] Resolving 2 futures (chunks) ... DONE
[17:43:55.245] Reducing values from 2 chunks ...
[17:43:55.245]  - Number of values collected after concatenation: 3
[17:43:55.245]  - Number of values expected: 3
[17:43:55.245] Reducing values from 2 chunks ... DONE
[17:43:55.245] future_lapply() ... DONE
[17:43:55.246] future_by_internal() ... DONE
[17:43:55.246] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:43:55.247] future_lapply() ...
[17:43:55.251] Number of chunks: 2
[17:43:55.251] getGlobalsAndPackagesXApply() ...
[17:43:55.251]  - future.globals: TRUE
[17:43:55.251] getGlobalsAndPackages() ...
[17:43:55.251] Searching for globals...
[17:43:55.253] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:55.253] Searching for globals ... DONE
[17:43:55.253] Resolving globals: FALSE
[17:43:55.253] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:43:55.253] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:43:55.254] - globals: [1] ‘FUN’
[17:43:55.254] 
[17:43:55.254] getGlobalsAndPackages() ... DONE
[17:43:55.254]  - globals found/used: [n=1] ‘FUN’
[17:43:55.256]  - needed namespaces: [n=0] 
[17:43:55.256] Finding globals ... DONE
[17:43:55.256]  - use_args: TRUE
[17:43:55.256]  - Getting '...' globals ...
[17:43:55.257] resolve() on list ...
[17:43:55.257]  recursive: 0
[17:43:55.257]  length: 1
[17:43:55.257]  elements: ‘...’
[17:43:55.257]  length: 0 (resolved future 1)
[17:43:55.257] resolve() on list ... DONE
[17:43:55.257]    - '...' content: [n=0] 
[17:43:55.257] List of 1
[17:43:55.257]  $ ...: list()
[17:43:55.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.257]  - attr(*, "where")=List of 1
[17:43:55.257]   ..$ ...:<environment: 0x55d6bd5e37a0> 
[17:43:55.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.257]  - attr(*, "resolved")= logi TRUE
[17:43:55.257]  - attr(*, "total_size")= num NA
[17:43:55.260]  - Getting '...' globals ... DONE
[17:43:55.260] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:55.260] List of 2
[17:43:55.260]  $ ...future.FUN:function (object, ...)  
[17:43:55.260]  $ ...          : list()
[17:43:55.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:55.260]  - attr(*, "where")=List of 2
[17:43:55.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:55.260]   ..$ ...          :<environment: 0x55d6bd5e37a0> 
[17:43:55.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:55.260]  - attr(*, "resolved")= logi FALSE
[17:43:55.260]  - attr(*, "total_size")= num 1240
[17:43:55.263] Packages to be attached in all futures: [n=0] 
[17:43:55.263] getGlobalsAndPackagesXApply() ... DONE
[17:43:55.263] Number of futures (= number of chunks): 2
[17:43:55.263] Launching 2 futures (chunks) ...
[17:43:55.263] Chunk #1 of 2 ...
[17:43:55.263]  - Finding globals in 'X' for chunk #1 ...
[17:43:55.264] getGlobalsAndPackages() ...
[17:43:55.264] Searching for globals...
[17:43:55.264] 
[17:43:55.264] Searching for globals ... DONE
[17:43:55.264] - globals: [0] <none>
[17:43:55.264] getGlobalsAndPackages() ... DONE
[17:43:55.264]    + additional globals found: [n=0] 
[17:43:55.265]    + additional namespaces needed: [n=0] 
[17:43:55.265]  - Finding globals in 'X' for chunk #1 ... DONE
[17:43:55.265]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.265]  - seeds: <none>
[17:43:55.265]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.265] getGlobalsAndPackages() ...
[17:43:55.265] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.265] Resolving globals: FALSE
[17:43:55.265] Tweak future expression to call with '...' arguments ...
[17:43:55.265] {
[17:43:55.265]     do.call(function(...) {
[17:43:55.265]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.265]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.265]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.265]             on.exit(options(oopts), add = TRUE)
[17:43:55.265]         }
[17:43:55.265]         {
[17:43:55.265]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.265]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.265]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.265]             })
[17:43:55.265]         }
[17:43:55.265]     }, args = future.call.arguments)
[17:43:55.265] }
[17:43:55.266] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.266] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.266] 
[17:43:55.266] getGlobalsAndPackages() ... DONE
[17:43:55.266] run() for ‘Future’ ...
[17:43:55.267] - state: ‘created’
[17:43:55.267] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.282]   - Field: ‘node’
[17:43:55.282]   - Field: ‘label’
[17:43:55.282]   - Field: ‘local’
[17:43:55.282]   - Field: ‘owner’
[17:43:55.282]   - Field: ‘envir’
[17:43:55.282]   - Field: ‘workers’
[17:43:55.283]   - Field: ‘packages’
[17:43:55.283]   - Field: ‘gc’
[17:43:55.283]   - Field: ‘conditions’
[17:43:55.283]   - Field: ‘persistent’
[17:43:55.283]   - Field: ‘expr’
[17:43:55.283]   - Field: ‘uuid’
[17:43:55.283]   - Field: ‘seed’
[17:43:55.283]   - Field: ‘version’
[17:43:55.283]   - Field: ‘result’
[17:43:55.283]   - Field: ‘asynchronous’
[17:43:55.284]   - Field: ‘calls’
[17:43:55.284]   - Field: ‘globals’
[17:43:55.284]   - Field: ‘stdout’
[17:43:55.284]   - Field: ‘earlySignal’
[17:43:55.284]   - Field: ‘lazy’
[17:43:55.284]   - Field: ‘state’
[17:43:55.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.284] - Launch lazy future ...
[17:43:55.284] Packages needed by the future expression (n = 0): <none>
[17:43:55.285] Packages needed by future strategies (n = 0): <none>
[17:43:55.285] {
[17:43:55.285]     {
[17:43:55.285]         {
[17:43:55.285]             ...future.startTime <- base::Sys.time()
[17:43:55.285]             {
[17:43:55.285]                 {
[17:43:55.285]                   {
[17:43:55.285]                     {
[17:43:55.285]                       base::local({
[17:43:55.285]                         has_future <- base::requireNamespace("future", 
[17:43:55.285]                           quietly = TRUE)
[17:43:55.285]                         if (has_future) {
[17:43:55.285]                           ns <- base::getNamespace("future")
[17:43:55.285]                           version <- ns[[".package"]][["version"]]
[17:43:55.285]                           if (is.null(version)) 
[17:43:55.285]                             version <- utils::packageVersion("future")
[17:43:55.285]                         }
[17:43:55.285]                         else {
[17:43:55.285]                           version <- NULL
[17:43:55.285]                         }
[17:43:55.285]                         if (!has_future || version < "1.8.0") {
[17:43:55.285]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.285]                             "", base::R.version$version.string), 
[17:43:55.285]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.285]                               "release", "version")], collapse = " "), 
[17:43:55.285]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.285]                             info)
[17:43:55.285]                           info <- base::paste(info, collapse = "; ")
[17:43:55.285]                           if (!has_future) {
[17:43:55.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.285]                               info)
[17:43:55.285]                           }
[17:43:55.285]                           else {
[17:43:55.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.285]                               info, version)
[17:43:55.285]                           }
[17:43:55.285]                           base::stop(msg)
[17:43:55.285]                         }
[17:43:55.285]                       })
[17:43:55.285]                     }
[17:43:55.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.285]                     base::options(mc.cores = 1L)
[17:43:55.285]                   }
[17:43:55.285]                   ...future.strategy.old <- future::plan("list")
[17:43:55.285]                   options(future.plan = NULL)
[17:43:55.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.285]                 }
[17:43:55.285]                 ...future.workdir <- getwd()
[17:43:55.285]             }
[17:43:55.285]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.285]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.285]         }
[17:43:55.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.285]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.285]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.285]             base::names(...future.oldOptions))
[17:43:55.285]     }
[17:43:55.285]     if (FALSE) {
[17:43:55.285]     }
[17:43:55.285]     else {
[17:43:55.285]         if (TRUE) {
[17:43:55.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.285]                 open = "w")
[17:43:55.285]         }
[17:43:55.285]         else {
[17:43:55.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.285]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.285]         }
[17:43:55.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.285]             base::sink(type = "output", split = FALSE)
[17:43:55.285]             base::close(...future.stdout)
[17:43:55.285]         }, add = TRUE)
[17:43:55.285]     }
[17:43:55.285]     ...future.frame <- base::sys.nframe()
[17:43:55.285]     ...future.conditions <- base::list()
[17:43:55.285]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.285]     if (FALSE) {
[17:43:55.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.285]     }
[17:43:55.285]     ...future.result <- base::tryCatch({
[17:43:55.285]         base::withCallingHandlers({
[17:43:55.285]             ...future.value <- base::withVisible(base::local({
[17:43:55.285]                 ...future.makeSendCondition <- base::local({
[17:43:55.285]                   sendCondition <- NULL
[17:43:55.285]                   function(frame = 1L) {
[17:43:55.285]                     if (is.function(sendCondition)) 
[17:43:55.285]                       return(sendCondition)
[17:43:55.285]                     ns <- getNamespace("parallel")
[17:43:55.285]                     if (exists("sendData", mode = "function", 
[17:43:55.285]                       envir = ns)) {
[17:43:55.285]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.285]                         envir = ns)
[17:43:55.285]                       envir <- sys.frame(frame)
[17:43:55.285]                       master <- NULL
[17:43:55.285]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.285]                         !identical(envir, emptyenv())) {
[17:43:55.285]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.285]                           inherits = FALSE)) {
[17:43:55.285]                           master <- get("master", mode = "list", 
[17:43:55.285]                             envir = envir, inherits = FALSE)
[17:43:55.285]                           if (inherits(master, c("SOCKnode", 
[17:43:55.285]                             "SOCK0node"))) {
[17:43:55.285]                             sendCondition <<- function(cond) {
[17:43:55.285]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.285]                                 success = TRUE)
[17:43:55.285]                               parallel_sendData(master, data)
[17:43:55.285]                             }
[17:43:55.285]                             return(sendCondition)
[17:43:55.285]                           }
[17:43:55.285]                         }
[17:43:55.285]                         frame <- frame + 1L
[17:43:55.285]                         envir <- sys.frame(frame)
[17:43:55.285]                       }
[17:43:55.285]                     }
[17:43:55.285]                     sendCondition <<- function(cond) NULL
[17:43:55.285]                   }
[17:43:55.285]                 })
[17:43:55.285]                 withCallingHandlers({
[17:43:55.285]                   {
[17:43:55.285]                     do.call(function(...) {
[17:43:55.285]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.285]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.285]                         ...future.globals.maxSize)) {
[17:43:55.285]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.285]                         on.exit(options(oopts), add = TRUE)
[17:43:55.285]                       }
[17:43:55.285]                       {
[17:43:55.285]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.285]                           FUN = function(jj) {
[17:43:55.285]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.285]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.285]                           })
[17:43:55.285]                       }
[17:43:55.285]                     }, args = future.call.arguments)
[17:43:55.285]                   }
[17:43:55.285]                 }, immediateCondition = function(cond) {
[17:43:55.285]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.285]                   sendCondition(cond)
[17:43:55.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.285]                   {
[17:43:55.285]                     inherits <- base::inherits
[17:43:55.285]                     invokeRestart <- base::invokeRestart
[17:43:55.285]                     is.null <- base::is.null
[17:43:55.285]                     muffled <- FALSE
[17:43:55.285]                     if (inherits(cond, "message")) {
[17:43:55.285]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.285]                       if (muffled) 
[17:43:55.285]                         invokeRestart("muffleMessage")
[17:43:55.285]                     }
[17:43:55.285]                     else if (inherits(cond, "warning")) {
[17:43:55.285]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.285]                       if (muffled) 
[17:43:55.285]                         invokeRestart("muffleWarning")
[17:43:55.285]                     }
[17:43:55.285]                     else if (inherits(cond, "condition")) {
[17:43:55.285]                       if (!is.null(pattern)) {
[17:43:55.285]                         computeRestarts <- base::computeRestarts
[17:43:55.285]                         grepl <- base::grepl
[17:43:55.285]                         restarts <- computeRestarts(cond)
[17:43:55.285]                         for (restart in restarts) {
[17:43:55.285]                           name <- restart$name
[17:43:55.285]                           if (is.null(name)) 
[17:43:55.285]                             next
[17:43:55.285]                           if (!grepl(pattern, name)) 
[17:43:55.285]                             next
[17:43:55.285]                           invokeRestart(restart)
[17:43:55.285]                           muffled <- TRUE
[17:43:55.285]                           break
[17:43:55.285]                         }
[17:43:55.285]                       }
[17:43:55.285]                     }
[17:43:55.285]                     invisible(muffled)
[17:43:55.285]                   }
[17:43:55.285]                   muffleCondition(cond)
[17:43:55.285]                 })
[17:43:55.285]             }))
[17:43:55.285]             future::FutureResult(value = ...future.value$value, 
[17:43:55.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.285]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.285]                     ...future.globalenv.names))
[17:43:55.285]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.285]         }, condition = base::local({
[17:43:55.285]             c <- base::c
[17:43:55.285]             inherits <- base::inherits
[17:43:55.285]             invokeRestart <- base::invokeRestart
[17:43:55.285]             length <- base::length
[17:43:55.285]             list <- base::list
[17:43:55.285]             seq.int <- base::seq.int
[17:43:55.285]             signalCondition <- base::signalCondition
[17:43:55.285]             sys.calls <- base::sys.calls
[17:43:55.285]             `[[` <- base::`[[`
[17:43:55.285]             `+` <- base::`+`
[17:43:55.285]             `<<-` <- base::`<<-`
[17:43:55.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.285]                   3L)]
[17:43:55.285]             }
[17:43:55.285]             function(cond) {
[17:43:55.285]                 is_error <- inherits(cond, "error")
[17:43:55.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.285]                   NULL)
[17:43:55.285]                 if (is_error) {
[17:43:55.285]                   sessionInformation <- function() {
[17:43:55.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.285]                       search = base::search(), system = base::Sys.info())
[17:43:55.285]                   }
[17:43:55.285]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.285]                     cond$call), session = sessionInformation(), 
[17:43:55.285]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.285]                   signalCondition(cond)
[17:43:55.285]                 }
[17:43:55.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.285]                 "immediateCondition"))) {
[17:43:55.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.285]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.285]                   if (TRUE && !signal) {
[17:43:55.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.285]                     {
[17:43:55.285]                       inherits <- base::inherits
[17:43:55.285]                       invokeRestart <- base::invokeRestart
[17:43:55.285]                       is.null <- base::is.null
[17:43:55.285]                       muffled <- FALSE
[17:43:55.285]                       if (inherits(cond, "message")) {
[17:43:55.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.285]                         if (muffled) 
[17:43:55.285]                           invokeRestart("muffleMessage")
[17:43:55.285]                       }
[17:43:55.285]                       else if (inherits(cond, "warning")) {
[17:43:55.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.285]                         if (muffled) 
[17:43:55.285]                           invokeRestart("muffleWarning")
[17:43:55.285]                       }
[17:43:55.285]                       else if (inherits(cond, "condition")) {
[17:43:55.285]                         if (!is.null(pattern)) {
[17:43:55.285]                           computeRestarts <- base::computeRestarts
[17:43:55.285]                           grepl <- base::grepl
[17:43:55.285]                           restarts <- computeRestarts(cond)
[17:43:55.285]                           for (restart in restarts) {
[17:43:55.285]                             name <- restart$name
[17:43:55.285]                             if (is.null(name)) 
[17:43:55.285]                               next
[17:43:55.285]                             if (!grepl(pattern, name)) 
[17:43:55.285]                               next
[17:43:55.285]                             invokeRestart(restart)
[17:43:55.285]                             muffled <- TRUE
[17:43:55.285]                             break
[17:43:55.285]                           }
[17:43:55.285]                         }
[17:43:55.285]                       }
[17:43:55.285]                       invisible(muffled)
[17:43:55.285]                     }
[17:43:55.285]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.285]                   }
[17:43:55.285]                 }
[17:43:55.285]                 else {
[17:43:55.285]                   if (TRUE) {
[17:43:55.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.285]                     {
[17:43:55.285]                       inherits <- base::inherits
[17:43:55.285]                       invokeRestart <- base::invokeRestart
[17:43:55.285]                       is.null <- base::is.null
[17:43:55.285]                       muffled <- FALSE
[17:43:55.285]                       if (inherits(cond, "message")) {
[17:43:55.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.285]                         if (muffled) 
[17:43:55.285]                           invokeRestart("muffleMessage")
[17:43:55.285]                       }
[17:43:55.285]                       else if (inherits(cond, "warning")) {
[17:43:55.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.285]                         if (muffled) 
[17:43:55.285]                           invokeRestart("muffleWarning")
[17:43:55.285]                       }
[17:43:55.285]                       else if (inherits(cond, "condition")) {
[17:43:55.285]                         if (!is.null(pattern)) {
[17:43:55.285]                           computeRestarts <- base::computeRestarts
[17:43:55.285]                           grepl <- base::grepl
[17:43:55.285]                           restarts <- computeRestarts(cond)
[17:43:55.285]                           for (restart in restarts) {
[17:43:55.285]                             name <- restart$name
[17:43:55.285]                             if (is.null(name)) 
[17:43:55.285]                               next
[17:43:55.285]                             if (!grepl(pattern, name)) 
[17:43:55.285]                               next
[17:43:55.285]                             invokeRestart(restart)
[17:43:55.285]                             muffled <- TRUE
[17:43:55.285]                             break
[17:43:55.285]                           }
[17:43:55.285]                         }
[17:43:55.285]                       }
[17:43:55.285]                       invisible(muffled)
[17:43:55.285]                     }
[17:43:55.285]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.285]                   }
[17:43:55.285]                 }
[17:43:55.285]             }
[17:43:55.285]         }))
[17:43:55.285]     }, error = function(ex) {
[17:43:55.285]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.285]                 ...future.rng), started = ...future.startTime, 
[17:43:55.285]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.285]             version = "1.8"), class = "FutureResult")
[17:43:55.285]     }, finally = {
[17:43:55.285]         if (!identical(...future.workdir, getwd())) 
[17:43:55.285]             setwd(...future.workdir)
[17:43:55.285]         {
[17:43:55.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.285]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.285]             }
[17:43:55.285]             base::options(...future.oldOptions)
[17:43:55.285]             if (.Platform$OS.type == "windows") {
[17:43:55.285]                 old_names <- names(...future.oldEnvVars)
[17:43:55.285]                 envs <- base::Sys.getenv()
[17:43:55.285]                 names <- names(envs)
[17:43:55.285]                 common <- intersect(names, old_names)
[17:43:55.285]                 added <- setdiff(names, old_names)
[17:43:55.285]                 removed <- setdiff(old_names, names)
[17:43:55.285]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.285]                   envs[common]]
[17:43:55.285]                 NAMES <- toupper(changed)
[17:43:55.285]                 args <- list()
[17:43:55.285]                 for (kk in seq_along(NAMES)) {
[17:43:55.285]                   name <- changed[[kk]]
[17:43:55.285]                   NAME <- NAMES[[kk]]
[17:43:55.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.285]                     next
[17:43:55.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.285]                 }
[17:43:55.285]                 NAMES <- toupper(added)
[17:43:55.285]                 for (kk in seq_along(NAMES)) {
[17:43:55.285]                   name <- added[[kk]]
[17:43:55.285]                   NAME <- NAMES[[kk]]
[17:43:55.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.285]                     next
[17:43:55.285]                   args[[name]] <- ""
[17:43:55.285]                 }
[17:43:55.285]                 NAMES <- toupper(removed)
[17:43:55.285]                 for (kk in seq_along(NAMES)) {
[17:43:55.285]                   name <- removed[[kk]]
[17:43:55.285]                   NAME <- NAMES[[kk]]
[17:43:55.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.285]                     next
[17:43:55.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.285]                 }
[17:43:55.285]                 if (length(args) > 0) 
[17:43:55.285]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.285]             }
[17:43:55.285]             else {
[17:43:55.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.285]             }
[17:43:55.285]             {
[17:43:55.285]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.285]                   0L) {
[17:43:55.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.285]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.285]                   base::options(opts)
[17:43:55.285]                 }
[17:43:55.285]                 {
[17:43:55.285]                   {
[17:43:55.285]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.285]                     NULL
[17:43:55.285]                   }
[17:43:55.285]                   options(future.plan = NULL)
[17:43:55.285]                   if (is.na(NA_character_)) 
[17:43:55.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.285]                     .init = FALSE)
[17:43:55.285]                 }
[17:43:55.285]             }
[17:43:55.285]         }
[17:43:55.285]     })
[17:43:55.285]     if (TRUE) {
[17:43:55.285]         base::sink(type = "output", split = FALSE)
[17:43:55.285]         if (TRUE) {
[17:43:55.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.285]         }
[17:43:55.285]         else {
[17:43:55.285]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.285]         }
[17:43:55.285]         base::close(...future.stdout)
[17:43:55.285]         ...future.stdout <- NULL
[17:43:55.285]     }
[17:43:55.285]     ...future.result$conditions <- ...future.conditions
[17:43:55.285]     ...future.result$finished <- base::Sys.time()
[17:43:55.285]     ...future.result
[17:43:55.285] }
[17:43:55.288] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:43:55.288] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:43:55.288] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:43:55.289] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:55.289] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.289] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:43:55.289] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:43:55.289] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:55.290] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.290] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:43:55.290] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:43:55.290] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:43:55.291] MultisessionFuture started
[17:43:55.291] - Launch lazy future ... done
[17:43:55.291] run() for ‘MultisessionFuture’ ... done
[17:43:55.291] Created future:
[17:43:55.291] MultisessionFuture:
[17:43:55.291] Label: ‘future_by-1’
[17:43:55.291] Expression:
[17:43:55.291] {
[17:43:55.291]     do.call(function(...) {
[17:43:55.291]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.291]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.291]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.291]             on.exit(options(oopts), add = TRUE)
[17:43:55.291]         }
[17:43:55.291]         {
[17:43:55.291]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.291]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.291]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.291]             })
[17:43:55.291]         }
[17:43:55.291]     }, args = future.call.arguments)
[17:43:55.291] }
[17:43:55.291] Lazy evaluation: FALSE
[17:43:55.291] Asynchronous evaluation: TRUE
[17:43:55.291] Local evaluation: TRUE
[17:43:55.291] Environment: 0x55d6bd5ad330
[17:43:55.291] Capture standard output: TRUE
[17:43:55.291] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.291] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.291] Packages: <none>
[17:43:55.291] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.291] Resolved: FALSE
[17:43:55.291] Value: <not collected>
[17:43:55.291] Conditions captured: <none>
[17:43:55.291] Early signaling: FALSE
[17:43:55.291] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:55.291] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.303] Chunk #1 of 2 ... DONE
[17:43:55.303] Chunk #2 of 2 ...
[17:43:55.303]  - Finding globals in 'X' for chunk #2 ...
[17:43:55.303] getGlobalsAndPackages() ...
[17:43:55.303] Searching for globals...
[17:43:55.304] 
[17:43:55.304] Searching for globals ... DONE
[17:43:55.304] - globals: [0] <none>
[17:43:55.304] getGlobalsAndPackages() ... DONE
[17:43:55.304]    + additional globals found: [n=0] 
[17:43:55.304]    + additional namespaces needed: [n=0] 
[17:43:55.304]  - Finding globals in 'X' for chunk #2 ... DONE
[17:43:55.305]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:43:55.305]  - seeds: <none>
[17:43:55.305]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.305] getGlobalsAndPackages() ...
[17:43:55.305] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.305] Resolving globals: FALSE
[17:43:55.305] Tweak future expression to call with '...' arguments ...
[17:43:55.305] {
[17:43:55.305]     do.call(function(...) {
[17:43:55.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.305]             on.exit(options(oopts), add = TRUE)
[17:43:55.305]         }
[17:43:55.305]         {
[17:43:55.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.305]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.305]             })
[17:43:55.305]         }
[17:43:55.305]     }, args = future.call.arguments)
[17:43:55.305] }
[17:43:55.306] Tweak future expression to call with '...' arguments ... DONE
[17:43:55.306] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:55.306] 
[17:43:55.306] getGlobalsAndPackages() ... DONE
[17:43:55.306] run() for ‘Future’ ...
[17:43:55.306] - state: ‘created’
[17:43:55.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.321] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.321]   - Field: ‘node’
[17:43:55.321]   - Field: ‘label’
[17:43:55.321]   - Field: ‘local’
[17:43:55.321]   - Field: ‘owner’
[17:43:55.321]   - Field: ‘envir’
[17:43:55.321]   - Field: ‘workers’
[17:43:55.321]   - Field: ‘packages’
[17:43:55.322]   - Field: ‘gc’
[17:43:55.322]   - Field: ‘conditions’
[17:43:55.322]   - Field: ‘persistent’
[17:43:55.322]   - Field: ‘expr’
[17:43:55.322]   - Field: ‘uuid’
[17:43:55.322]   - Field: ‘seed’
[17:43:55.322]   - Field: ‘version’
[17:43:55.322]   - Field: ‘result’
[17:43:55.322]   - Field: ‘asynchronous’
[17:43:55.322]   - Field: ‘calls’
[17:43:55.322]   - Field: ‘globals’
[17:43:55.323]   - Field: ‘stdout’
[17:43:55.323]   - Field: ‘earlySignal’
[17:43:55.323]   - Field: ‘lazy’
[17:43:55.323]   - Field: ‘state’
[17:43:55.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.323] - Launch lazy future ...
[17:43:55.323] Packages needed by the future expression (n = 0): <none>
[17:43:55.323] Packages needed by future strategies (n = 0): <none>
[17:43:55.324] {
[17:43:55.324]     {
[17:43:55.324]         {
[17:43:55.324]             ...future.startTime <- base::Sys.time()
[17:43:55.324]             {
[17:43:55.324]                 {
[17:43:55.324]                   {
[17:43:55.324]                     {
[17:43:55.324]                       base::local({
[17:43:55.324]                         has_future <- base::requireNamespace("future", 
[17:43:55.324]                           quietly = TRUE)
[17:43:55.324]                         if (has_future) {
[17:43:55.324]                           ns <- base::getNamespace("future")
[17:43:55.324]                           version <- ns[[".package"]][["version"]]
[17:43:55.324]                           if (is.null(version)) 
[17:43:55.324]                             version <- utils::packageVersion("future")
[17:43:55.324]                         }
[17:43:55.324]                         else {
[17:43:55.324]                           version <- NULL
[17:43:55.324]                         }
[17:43:55.324]                         if (!has_future || version < "1.8.0") {
[17:43:55.324]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.324]                             "", base::R.version$version.string), 
[17:43:55.324]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.324]                               "release", "version")], collapse = " "), 
[17:43:55.324]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.324]                             info)
[17:43:55.324]                           info <- base::paste(info, collapse = "; ")
[17:43:55.324]                           if (!has_future) {
[17:43:55.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.324]                               info)
[17:43:55.324]                           }
[17:43:55.324]                           else {
[17:43:55.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.324]                               info, version)
[17:43:55.324]                           }
[17:43:55.324]                           base::stop(msg)
[17:43:55.324]                         }
[17:43:55.324]                       })
[17:43:55.324]                     }
[17:43:55.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.324]                     base::options(mc.cores = 1L)
[17:43:55.324]                   }
[17:43:55.324]                   ...future.strategy.old <- future::plan("list")
[17:43:55.324]                   options(future.plan = NULL)
[17:43:55.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.324]                 }
[17:43:55.324]                 ...future.workdir <- getwd()
[17:43:55.324]             }
[17:43:55.324]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.324]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.324]         }
[17:43:55.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.324]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:43:55.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.324]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.324]             base::names(...future.oldOptions))
[17:43:55.324]     }
[17:43:55.324]     if (FALSE) {
[17:43:55.324]     }
[17:43:55.324]     else {
[17:43:55.324]         if (TRUE) {
[17:43:55.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.324]                 open = "w")
[17:43:55.324]         }
[17:43:55.324]         else {
[17:43:55.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.324]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.324]         }
[17:43:55.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.324]             base::sink(type = "output", split = FALSE)
[17:43:55.324]             base::close(...future.stdout)
[17:43:55.324]         }, add = TRUE)
[17:43:55.324]     }
[17:43:55.324]     ...future.frame <- base::sys.nframe()
[17:43:55.324]     ...future.conditions <- base::list()
[17:43:55.324]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.324]     if (FALSE) {
[17:43:55.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.324]     }
[17:43:55.324]     ...future.result <- base::tryCatch({
[17:43:55.324]         base::withCallingHandlers({
[17:43:55.324]             ...future.value <- base::withVisible(base::local({
[17:43:55.324]                 ...future.makeSendCondition <- base::local({
[17:43:55.324]                   sendCondition <- NULL
[17:43:55.324]                   function(frame = 1L) {
[17:43:55.324]                     if (is.function(sendCondition)) 
[17:43:55.324]                       return(sendCondition)
[17:43:55.324]                     ns <- getNamespace("parallel")
[17:43:55.324]                     if (exists("sendData", mode = "function", 
[17:43:55.324]                       envir = ns)) {
[17:43:55.324]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.324]                         envir = ns)
[17:43:55.324]                       envir <- sys.frame(frame)
[17:43:55.324]                       master <- NULL
[17:43:55.324]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.324]                         !identical(envir, emptyenv())) {
[17:43:55.324]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.324]                           inherits = FALSE)) {
[17:43:55.324]                           master <- get("master", mode = "list", 
[17:43:55.324]                             envir = envir, inherits = FALSE)
[17:43:55.324]                           if (inherits(master, c("SOCKnode", 
[17:43:55.324]                             "SOCK0node"))) {
[17:43:55.324]                             sendCondition <<- function(cond) {
[17:43:55.324]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.324]                                 success = TRUE)
[17:43:55.324]                               parallel_sendData(master, data)
[17:43:55.324]                             }
[17:43:55.324]                             return(sendCondition)
[17:43:55.324]                           }
[17:43:55.324]                         }
[17:43:55.324]                         frame <- frame + 1L
[17:43:55.324]                         envir <- sys.frame(frame)
[17:43:55.324]                       }
[17:43:55.324]                     }
[17:43:55.324]                     sendCondition <<- function(cond) NULL
[17:43:55.324]                   }
[17:43:55.324]                 })
[17:43:55.324]                 withCallingHandlers({
[17:43:55.324]                   {
[17:43:55.324]                     do.call(function(...) {
[17:43:55.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.324]                       if (!identical(...future.globals.maxSize.org, 
[17:43:55.324]                         ...future.globals.maxSize)) {
[17:43:55.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.324]                         on.exit(options(oopts), add = TRUE)
[17:43:55.324]                       }
[17:43:55.324]                       {
[17:43:55.324]                         lapply(seq_along(...future.elements_ii), 
[17:43:55.324]                           FUN = function(jj) {
[17:43:55.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.324]                             ...future.FUN(...future.X_jj, ...)
[17:43:55.324]                           })
[17:43:55.324]                       }
[17:43:55.324]                     }, args = future.call.arguments)
[17:43:55.324]                   }
[17:43:55.324]                 }, immediateCondition = function(cond) {
[17:43:55.324]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.324]                   sendCondition(cond)
[17:43:55.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.324]                   {
[17:43:55.324]                     inherits <- base::inherits
[17:43:55.324]                     invokeRestart <- base::invokeRestart
[17:43:55.324]                     is.null <- base::is.null
[17:43:55.324]                     muffled <- FALSE
[17:43:55.324]                     if (inherits(cond, "message")) {
[17:43:55.324]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.324]                       if (muffled) 
[17:43:55.324]                         invokeRestart("muffleMessage")
[17:43:55.324]                     }
[17:43:55.324]                     else if (inherits(cond, "warning")) {
[17:43:55.324]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.324]                       if (muffled) 
[17:43:55.324]                         invokeRestart("muffleWarning")
[17:43:55.324]                     }
[17:43:55.324]                     else if (inherits(cond, "condition")) {
[17:43:55.324]                       if (!is.null(pattern)) {
[17:43:55.324]                         computeRestarts <- base::computeRestarts
[17:43:55.324]                         grepl <- base::grepl
[17:43:55.324]                         restarts <- computeRestarts(cond)
[17:43:55.324]                         for (restart in restarts) {
[17:43:55.324]                           name <- restart$name
[17:43:55.324]                           if (is.null(name)) 
[17:43:55.324]                             next
[17:43:55.324]                           if (!grepl(pattern, name)) 
[17:43:55.324]                             next
[17:43:55.324]                           invokeRestart(restart)
[17:43:55.324]                           muffled <- TRUE
[17:43:55.324]                           break
[17:43:55.324]                         }
[17:43:55.324]                       }
[17:43:55.324]                     }
[17:43:55.324]                     invisible(muffled)
[17:43:55.324]                   }
[17:43:55.324]                   muffleCondition(cond)
[17:43:55.324]                 })
[17:43:55.324]             }))
[17:43:55.324]             future::FutureResult(value = ...future.value$value, 
[17:43:55.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.324]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.324]                     ...future.globalenv.names))
[17:43:55.324]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.324]         }, condition = base::local({
[17:43:55.324]             c <- base::c
[17:43:55.324]             inherits <- base::inherits
[17:43:55.324]             invokeRestart <- base::invokeRestart
[17:43:55.324]             length <- base::length
[17:43:55.324]             list <- base::list
[17:43:55.324]             seq.int <- base::seq.int
[17:43:55.324]             signalCondition <- base::signalCondition
[17:43:55.324]             sys.calls <- base::sys.calls
[17:43:55.324]             `[[` <- base::`[[`
[17:43:55.324]             `+` <- base::`+`
[17:43:55.324]             `<<-` <- base::`<<-`
[17:43:55.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.324]                   3L)]
[17:43:55.324]             }
[17:43:55.324]             function(cond) {
[17:43:55.324]                 is_error <- inherits(cond, "error")
[17:43:55.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.324]                   NULL)
[17:43:55.324]                 if (is_error) {
[17:43:55.324]                   sessionInformation <- function() {
[17:43:55.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.324]                       search = base::search(), system = base::Sys.info())
[17:43:55.324]                   }
[17:43:55.324]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.324]                     cond$call), session = sessionInformation(), 
[17:43:55.324]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.324]                   signalCondition(cond)
[17:43:55.324]                 }
[17:43:55.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.324]                 "immediateCondition"))) {
[17:43:55.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.324]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.324]                   if (TRUE && !signal) {
[17:43:55.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.324]                     {
[17:43:55.324]                       inherits <- base::inherits
[17:43:55.324]                       invokeRestart <- base::invokeRestart
[17:43:55.324]                       is.null <- base::is.null
[17:43:55.324]                       muffled <- FALSE
[17:43:55.324]                       if (inherits(cond, "message")) {
[17:43:55.324]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.324]                         if (muffled) 
[17:43:55.324]                           invokeRestart("muffleMessage")
[17:43:55.324]                       }
[17:43:55.324]                       else if (inherits(cond, "warning")) {
[17:43:55.324]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.324]                         if (muffled) 
[17:43:55.324]                           invokeRestart("muffleWarning")
[17:43:55.324]                       }
[17:43:55.324]                       else if (inherits(cond, "condition")) {
[17:43:55.324]                         if (!is.null(pattern)) {
[17:43:55.324]                           computeRestarts <- base::computeRestarts
[17:43:55.324]                           grepl <- base::grepl
[17:43:55.324]                           restarts <- computeRestarts(cond)
[17:43:55.324]                           for (restart in restarts) {
[17:43:55.324]                             name <- restart$name
[17:43:55.324]                             if (is.null(name)) 
[17:43:55.324]                               next
[17:43:55.324]                             if (!grepl(pattern, name)) 
[17:43:55.324]                               next
[17:43:55.324]                             invokeRestart(restart)
[17:43:55.324]                             muffled <- TRUE
[17:43:55.324]                             break
[17:43:55.324]                           }
[17:43:55.324]                         }
[17:43:55.324]                       }
[17:43:55.324]                       invisible(muffled)
[17:43:55.324]                     }
[17:43:55.324]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.324]                   }
[17:43:55.324]                 }
[17:43:55.324]                 else {
[17:43:55.324]                   if (TRUE) {
[17:43:55.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.324]                     {
[17:43:55.324]                       inherits <- base::inherits
[17:43:55.324]                       invokeRestart <- base::invokeRestart
[17:43:55.324]                       is.null <- base::is.null
[17:43:55.324]                       muffled <- FALSE
[17:43:55.324]                       if (inherits(cond, "message")) {
[17:43:55.324]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.324]                         if (muffled) 
[17:43:55.324]                           invokeRestart("muffleMessage")
[17:43:55.324]                       }
[17:43:55.324]                       else if (inherits(cond, "warning")) {
[17:43:55.324]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.324]                         if (muffled) 
[17:43:55.324]                           invokeRestart("muffleWarning")
[17:43:55.324]                       }
[17:43:55.324]                       else if (inherits(cond, "condition")) {
[17:43:55.324]                         if (!is.null(pattern)) {
[17:43:55.324]                           computeRestarts <- base::computeRestarts
[17:43:55.324]                           grepl <- base::grepl
[17:43:55.324]                           restarts <- computeRestarts(cond)
[17:43:55.324]                           for (restart in restarts) {
[17:43:55.324]                             name <- restart$name
[17:43:55.324]                             if (is.null(name)) 
[17:43:55.324]                               next
[17:43:55.324]                             if (!grepl(pattern, name)) 
[17:43:55.324]                               next
[17:43:55.324]                             invokeRestart(restart)
[17:43:55.324]                             muffled <- TRUE
[17:43:55.324]                             break
[17:43:55.324]                           }
[17:43:55.324]                         }
[17:43:55.324]                       }
[17:43:55.324]                       invisible(muffled)
[17:43:55.324]                     }
[17:43:55.324]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.324]                   }
[17:43:55.324]                 }
[17:43:55.324]             }
[17:43:55.324]         }))
[17:43:55.324]     }, error = function(ex) {
[17:43:55.324]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.324]                 ...future.rng), started = ...future.startTime, 
[17:43:55.324]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.324]             version = "1.8"), class = "FutureResult")
[17:43:55.324]     }, finally = {
[17:43:55.324]         if (!identical(...future.workdir, getwd())) 
[17:43:55.324]             setwd(...future.workdir)
[17:43:55.324]         {
[17:43:55.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.324]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.324]             }
[17:43:55.324]             base::options(...future.oldOptions)
[17:43:55.324]             if (.Platform$OS.type == "windows") {
[17:43:55.324]                 old_names <- names(...future.oldEnvVars)
[17:43:55.324]                 envs <- base::Sys.getenv()
[17:43:55.324]                 names <- names(envs)
[17:43:55.324]                 common <- intersect(names, old_names)
[17:43:55.324]                 added <- setdiff(names, old_names)
[17:43:55.324]                 removed <- setdiff(old_names, names)
[17:43:55.324]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.324]                   envs[common]]
[17:43:55.324]                 NAMES <- toupper(changed)
[17:43:55.324]                 args <- list()
[17:43:55.324]                 for (kk in seq_along(NAMES)) {
[17:43:55.324]                   name <- changed[[kk]]
[17:43:55.324]                   NAME <- NAMES[[kk]]
[17:43:55.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.324]                     next
[17:43:55.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.324]                 }
[17:43:55.324]                 NAMES <- toupper(added)
[17:43:55.324]                 for (kk in seq_along(NAMES)) {
[17:43:55.324]                   name <- added[[kk]]
[17:43:55.324]                   NAME <- NAMES[[kk]]
[17:43:55.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.324]                     next
[17:43:55.324]                   args[[name]] <- ""
[17:43:55.324]                 }
[17:43:55.324]                 NAMES <- toupper(removed)
[17:43:55.324]                 for (kk in seq_along(NAMES)) {
[17:43:55.324]                   name <- removed[[kk]]
[17:43:55.324]                   NAME <- NAMES[[kk]]
[17:43:55.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.324]                     next
[17:43:55.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.324]                 }
[17:43:55.324]                 if (length(args) > 0) 
[17:43:55.324]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.324]             }
[17:43:55.324]             else {
[17:43:55.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.324]             }
[17:43:55.324]             {
[17:43:55.324]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.324]                   0L) {
[17:43:55.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.324]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.324]                   base::options(opts)
[17:43:55.324]                 }
[17:43:55.324]                 {
[17:43:55.324]                   {
[17:43:55.324]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.324]                     NULL
[17:43:55.324]                   }
[17:43:55.324]                   options(future.plan = NULL)
[17:43:55.324]                   if (is.na(NA_character_)) 
[17:43:55.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:55.324]                     .init = FALSE)
[17:43:55.324]                 }
[17:43:55.324]             }
[17:43:55.324]         }
[17:43:55.324]     })
[17:43:55.324]     if (TRUE) {
[17:43:55.324]         base::sink(type = "output", split = FALSE)
[17:43:55.324]         if (TRUE) {
[17:43:55.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.324]         }
[17:43:55.324]         else {
[17:43:55.324]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.324]         }
[17:43:55.324]         base::close(...future.stdout)
[17:43:55.324]         ...future.stdout <- NULL
[17:43:55.324]     }
[17:43:55.324]     ...future.result$conditions <- ...future.conditions
[17:43:55.324]     ...future.result$finished <- base::Sys.time()
[17:43:55.324]     ...future.result
[17:43:55.324] }
[17:43:55.326] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:43:55.327] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:43:55.327] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:43:55.327] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:55.328] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.328] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:43:55.328] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:43:55.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:55.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:43:55.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:43:55.329] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:43:55.330] MultisessionFuture started
[17:43:55.330] - Launch lazy future ... done
[17:43:55.330] run() for ‘MultisessionFuture’ ... done
[17:43:55.330] Created future:
[17:43:55.330] MultisessionFuture:
[17:43:55.330] Label: ‘future_by-2’
[17:43:55.330] Expression:
[17:43:55.330] {
[17:43:55.330]     do.call(function(...) {
[17:43:55.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:55.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:55.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:55.330]             on.exit(options(oopts), add = TRUE)
[17:43:55.330]         }
[17:43:55.330]         {
[17:43:55.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:55.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:55.330]                 ...future.FUN(...future.X_jj, ...)
[17:43:55.330]             })
[17:43:55.330]         }
[17:43:55.330]     }, args = future.call.arguments)
[17:43:55.330] }
[17:43:55.330] Lazy evaluation: FALSE
[17:43:55.330] Asynchronous evaluation: TRUE
[17:43:55.330] Local evaluation: TRUE
[17:43:55.330] Environment: 0x55d6bd5ad330
[17:43:55.330] Capture standard output: TRUE
[17:43:55.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:55.330] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:43:55.330] Packages: <none>
[17:43:55.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:55.330] Resolved: FALSE
[17:43:55.330] Value: <not collected>
[17:43:55.330] Conditions captured: <none>
[17:43:55.330] Early signaling: FALSE
[17:43:55.330] Owner process: 2f65da69-b359-3493-9f1c-2669d44f930c
[17:43:55.330] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.342] Chunk #2 of 2 ... DONE
[17:43:55.342] Launching 2 futures (chunks) ... DONE
[17:43:55.342] Resolving 2 futures (chunks) ...
[17:43:55.342] resolve() on list ...
[17:43:55.342]  recursive: 0
[17:43:55.342]  length: 2
[17:43:55.342] 
[17:43:55.343] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.343] - Validating connection of MultisessionFuture
[17:43:55.343] - received message: FutureResult
[17:43:55.343] - Received FutureResult
[17:43:55.343] - Erased future from FutureRegistry
[17:43:55.343] result() for ClusterFuture ...
[17:43:55.344] - result already collected: FutureResult
[17:43:55.344] result() for ClusterFuture ... done
[17:43:55.344] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.344] Future #1
[17:43:55.344] result() for ClusterFuture ...
[17:43:55.344] - result already collected: FutureResult
[17:43:55.344] result() for ClusterFuture ... done
[17:43:55.344] result() for ClusterFuture ...
[17:43:55.344] - result already collected: FutureResult
[17:43:55.344] result() for ClusterFuture ... done
[17:43:55.344] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:55.345] - nx: 2
[17:43:55.345] - relay: TRUE
[17:43:55.345] - stdout: TRUE
[17:43:55.345] - signal: TRUE
[17:43:55.345] - resignal: FALSE
[17:43:55.345] - force: TRUE
[17:43:55.345] - relayed: [n=2] FALSE, FALSE
[17:43:55.345] - queued futures: [n=2] FALSE, FALSE
[17:43:55.345]  - until=1
[17:43:55.345]  - relaying element #1
[17:43:55.345] result() for ClusterFuture ...
[17:43:55.345] - result already collected: FutureResult
[17:43:55.346] result() for ClusterFuture ... done
[17:43:55.346] result() for ClusterFuture ...
[17:43:55.346] - result already collected: FutureResult
[17:43:55.346] result() for ClusterFuture ... done
[17:43:55.346] result() for ClusterFuture ...
[17:43:55.346] - result already collected: FutureResult
[17:43:55.346] result() for ClusterFuture ... done
[17:43:55.346] result() for ClusterFuture ...
[17:43:55.346] - result already collected: FutureResult
[17:43:55.346] result() for ClusterFuture ... done
[17:43:55.346] - relayed: [n=2] TRUE, FALSE
[17:43:55.346] - queued futures: [n=2] TRUE, FALSE
[17:43:55.347] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:55.347]  length: 1 (resolved future 1)
[17:43:55.374] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.374] - Validating connection of MultisessionFuture
[17:43:55.374] - received message: FutureResult
[17:43:55.374] - Received FutureResult
[17:43:55.375] - Erased future from FutureRegistry
[17:43:55.375] result() for ClusterFuture ...
[17:43:55.375] - result already collected: FutureResult
[17:43:55.375] result() for ClusterFuture ... done
[17:43:55.375] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.375] Future #2
[17:43:55.375] result() for ClusterFuture ...
[17:43:55.375] - result already collected: FutureResult
[17:43:55.375] result() for ClusterFuture ... done
[17:43:55.375] result() for ClusterFuture ...
[17:43:55.375] - result already collected: FutureResult
[17:43:55.376] result() for ClusterFuture ... done
[17:43:55.376] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:55.376] - nx: 2
[17:43:55.376] - relay: TRUE
[17:43:55.376] - stdout: TRUE
[17:43:55.376] - signal: TRUE
[17:43:55.376] - resignal: FALSE
[17:43:55.376] - force: TRUE
[17:43:55.376] - relayed: [n=2] TRUE, FALSE
[17:43:55.376] - queued futures: [n=2] TRUE, FALSE
[17:43:55.376]  - until=2
[17:43:55.376]  - relaying element #2
[17:43:55.377] result() for ClusterFuture ...
[17:43:55.377] - result already collected: FutureResult
[17:43:55.377] result() for ClusterFuture ... done
[17:43:55.377] result() for ClusterFuture ...
[17:43:55.377] - result already collected: FutureResult
[17:43:55.377] result() for ClusterFuture ... done
[17:43:55.377] result() for ClusterFuture ...
[17:43:55.377] - result already collected: FutureResult
[17:43:55.377] result() for ClusterFuture ... done
[17:43:55.377] result() for ClusterFuture ...
[17:43:55.377] - result already collected: FutureResult
[17:43:55.377] result() for ClusterFuture ... done
[17:43:55.378] - relayed: [n=2] TRUE, TRUE
[17:43:55.378] - queued futures: [n=2] TRUE, TRUE
[17:43:55.378] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:55.378]  length: 0 (resolved future 2)
[17:43:55.378] Relaying remaining futures
[17:43:55.378] signalConditionsASAP(NULL, pos=0) ...
[17:43:55.378] - nx: 2
[17:43:55.378] - relay: TRUE
[17:43:55.378] - stdout: TRUE
[17:43:55.378] - signal: TRUE
[17:43:55.378] - resignal: FALSE
[17:43:55.378] - force: TRUE
[17:43:55.379] - relayed: [n=2] TRUE, TRUE
[17:43:55.379] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:55.379] - relayed: [n=2] TRUE, TRUE
[17:43:55.379] - queued futures: [n=2] TRUE, TRUE
[17:43:55.379] signalConditionsASAP(NULL, pos=0) ... done
[17:43:55.379] resolve() on list ... DONE
[17:43:55.379] result() for ClusterFuture ...
[17:43:55.379] - result already collected: FutureResult
[17:43:55.379] result() for ClusterFuture ... done
[17:43:55.379] result() for ClusterFuture ...
[17:43:55.379] - result already collected: FutureResult
[17:43:55.380] result() for ClusterFuture ... done
[17:43:55.380] result() for ClusterFuture ...
[17:43:55.380] - result already collected: FutureResult
[17:43:55.380] result() for ClusterFuture ... done
[17:43:55.380] result() for ClusterFuture ...
[17:43:55.380] - result already collected: FutureResult
[17:43:55.380] result() for ClusterFuture ... done
[17:43:55.380]  - Number of value chunks collected: 2
[17:43:55.380] Resolving 2 futures (chunks) ... DONE
[17:43:55.380] Reducing values from 2 chunks ...
[17:43:55.380]  - Number of values collected after concatenation: 3
[17:43:55.381]  - Number of values expected: 3
[17:43:55.381] Reducing values from 2 chunks ... DONE
[17:43:55.381] future_lapply() ... DONE
[17:43:55.381] future_by_internal() ... DONE
[17:43:55.382] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[17:43:55.382] plan(): Setting new future strategy stack:
[17:43:55.383] List of future strategies:
[17:43:55.383] 1. FutureStrategy:
[17:43:55.383]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:55.383]    - tweaked: FALSE
[17:43:55.383]    - call: future::plan(oplan)
[17:43:55.383] plan(): nbrOfWorkers() = 1
> 
